/**
 * @license
 * ==============================================================================
 *   Solace Corporation
 *   SOLACE CORPORATION MESSAGING API FOR JAVASCRIPT
 *   SolclientJS
 * ==============================================================================
 * Copyright 2009-2018 Solace Corporation. All rights reserved.
 *
 * This software is proprietary software of Solace Corporation and intended only
 * for use in conjunction with one or more Solace Message Routers.  By using this
 * software, you are agreeing to the license terms and conditions located at
 * https://solace.com/license-software.
 */

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 265);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(165);
var ArrayOperations = ref.ArrayOperations;
var ref$1 = __webpack_require__(166);
var assert = ref$1.assert;
var ref$2 = __webpack_require__(167);
var BidiMap = ref$2.BidiMap;
var ref$3 = __webpack_require__(168);
var Enum = ref$3.Enum;
var ref$4 = __webpack_require__(169);
var Iterator = ref$4.Iterator;
var ref$5 = __webpack_require__(90);
var Lazy = ref$5.Lazy;
var ref$6 = __webpack_require__(170);
var makeMap = ref$6.makeMap;
var ref$7 = __webpack_require__(171);
var Mixin = ref$7.Mixin;
var ref$8 = __webpack_require__(172);
var Resolver = ref$8.Resolver;
var ref$9 = __webpack_require__(173);
var SetOperations = ref$9.SetOperations;

module.exports.assert = assert;
module.exports.ArrayOperations = ArrayOperations;
module.exports.BidiMap = BidiMap;
module.exports.Enum = Enum;
module.exports.Iterator = Iterator;
module.exports.Lazy = Lazy;
module.exports.makeIterator = Iterator.makeIterator;
module.exports.makeMap = makeMap;
module.exports.Mixin = Mixin;
module.exports.mixin = Mixin.mixin;
module.exports.Resolver = Resolver;
module.exports.resolve = Resolver.resolve;
module.exports.SetOperations = SetOperations;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(182);
var ConsoleLogImpl = ref.ConsoleLogImpl;
var ref$1 = __webpack_require__(183);
var GlobalBinding = ref$1.GlobalBinding;
var ref$2 = __webpack_require__(97);
var LogImpl = ref$2.LogImpl;
var ref$3 = __webpack_require__(98);
var LogLevel = ref$3.LogLevel;

var ref$4 = __webpack_require__(7);
var Parameter = ref$4.Parameter;
var ref$5 = __webpack_require__(9);
var SolclientFactory = ref$5.SolclientFactory;

var isEnumMember = Parameter.isEnumMember;
var isFunction = Parameter.isFunction;

var getImpl = GlobalBinding.getImpl;
var getLogLevel = GlobalBinding.getLogLevel;
var setImpl = GlobalBinding.setImpl;
var setLogLevel = GlobalBinding.setLogLevel;

var forwarder = {};
function buildLogForwarder() {
  Object.assign(forwarder, {
    trace: function trace() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.trace && getLogLevel() >= LogLevel.TRACE) {
        impl.trace.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    debug: function debug() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.debug && getLogLevel() >= LogLevel.DEBUG) {
        impl.debug.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    info: function info() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.info && getLogLevel() >= LogLevel.INFO) {
        impl.info.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    warn: function warn() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.warn && getLogLevel() >= LogLevel.WARN) {
        impl.warn.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    error: function error() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.error && getLogLevel() >= LogLevel.ERROR) {
        impl.error.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    fatal: function fatal() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.fatal) {
        impl.fatal.apply(null, ['solclientjs: ' ].concat( args));
      }
    },
  });
}
buildLogForwarder(); // stripped by production build

function addGlobalFuncs(source, target) {
  Object.keys(forwarder).forEach(function (k) {
    target[("LOG_" + (k.toUpperCase()))] = source[k];
  });
}

var LogFormatter = function LogFormatter(formatter) {
  var this$1 = this;

  this._formatter = (function () {
    if (typeof formatter === 'function') { return formatter; }
    if (typeof formatter === 'string') { return function prepend() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 return [formatter ].concat( args); }; }
    if (!formatter) { return function passthrough() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 return [].concat( args ); }; }
    return formatter;
  })();
  var self = this;
  Object.keys(forwarder).forEach(function (key) {
    this$1[key] = function forward() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return forwarder[key].apply(null, self._formatter.apply(self, args));
    };
  });
  addGlobalFuncs(this, this);
};

var prototypeAccessors = { formatter: {} };

prototypeAccessors.formatter.get = function () {
  return this._formatter;
};
prototypeAccessors.formatter.set = function (func) {
  this._formatter = func;
};

LogFormatter.prototype.wrap = function wrap (genericFunction, targetSelf) {
  var self = this;
  return function genericLogWrapper() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

    return genericFunction.apply(targetSelf, self._formatter.apply(self, args));
  };
};

Object.defineProperties( LogFormatter.prototype, prototypeAccessors );

/**
 * Gets the current log level, which was set by {@link solace.SolclientFactory.init} or a
 * subsequent call to {@link solace.SolclientFactory.setLogLevel}.
 *
 * @returns {solace.LogLevel} The current log level.
 */
SolclientFactory.getLogLevel = function () { return getLogLevel(); };

  /**
   * This method changes the current log level from the level set when
   * {@link solace.SolclientFactory.init} was called.
   *
   * @param {solace.LogLevel} newLevel The new log level to set.
   * @throws {solace.OperationError} Invalid log level
   */
SolclientFactory.setLogLevel = function (newLevel) {
  isEnumMember('logLevel', newLevel, LogLevel);
  setLogLevel(newLevel);
};

SolclientFactory.addInitializer(function (props) {
  setLogLevel(props.logLevel);

  var logger = props.logger || getImpl() || new ConsoleLogImpl();
  // Validate that the supplied log implementation is a superset of LogImpl
  Object.keys(new LogImpl()).forEach(function (key) { return isFunction(("logger." + key), logger[key]); });

  setImpl(logger);
});

addGlobalFuncs(forwarder, module.exports);
module.exports.LogImpl = LogImpl;
module.exports.LogLevel = LogLevel;
module.exports.Binding = GlobalBinding;
module.exports.ConsoleLogImpl = ConsoleLogImpl;
GlobalBinding.setImpl(new ConsoleLogImpl());
module.exports.LogFormatter = LogFormatter;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(162);
var ErrorResponseSubcodeMapper = ref.ErrorResponseSubcodeMapper;
var ref$1 = __webpack_require__(51);
var ErrorSubcode = ref$1.ErrorSubcode;
var ref$2 = __webpack_require__(163);
var NotImplementedError = ref$2.NotImplementedError;
var ref$3 = __webpack_require__(88);
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(164);
var RequestError = ref$4.RequestError;
var ref$5 = __webpack_require__(89);
var RequestEventCode = ref$5.RequestEventCode;
var ref$6 = __webpack_require__(52);
var SolaceError = ref$6.SolaceError;

module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
module.exports.ErrorSubcode = ErrorSubcode;
module.exports.NotImplementedError = NotImplementedError;
module.exports.OperationError = OperationError;
module.exports.RequestError = RequestError;
module.exports.RequestEventCode = RequestEventCode;
module.exports.SolaceError = SolaceError;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(152);
var Base64 = ref.Base64;
var ref$1 = __webpack_require__(153);
var Bits = ref$1.Bits;
var ref$2 = __webpack_require__(154);
var Convert = ref$2.Convert;
var ref$3 = __webpack_require__(155);
var Hex = ref$3.Hex;
var ref$4 = __webpack_require__(156);
var Long = ref$4.Long;

module.exports.Base64 = Base64;
module.exports.Bits = Bits;
module.exports.Convert = Convert;
module.exports.Hex = Hex;
module.exports.Long = Long;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(255);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(254);
var APIPropertiesValidators = ref$1.APIPropertiesValidators;
var ref$2 = __webpack_require__(256);
var ArrayUtils = ref$2.ArrayUtils;
var ref$3 = __webpack_require__(260);
var parseURL = ref$3.parseURL;
var ref$4 = __webpack_require__(257);
var Process = ref$4.Process;
var ref$5 = __webpack_require__(147);
var StringBuffer = ref$5.StringBuffer;
var ref$6 = __webpack_require__(258);
var StringUtils = ref$6.StringUtils;
var ref$7 = __webpack_require__(259);
var TimingBucket = ref$7.TimingBucket;
var ref$8 = __webpack_require__(261);
var UUID = ref$8.UUID;
var ref$9 = __webpack_require__(262);
var Version = ref$9.Version;

module.exports = {
  parseURL: parseURL,

  APIProperties: APIProperties,
  APIPropertiesValidators: APIPropertiesValidators,
  ArrayUtils: ArrayUtils,
  Process: Process,
  StringBuffer: StringBuffer,
  StringUtils: StringUtils,
  TimingBucket: TimingBucket,
  UUID: UUID,
  Version: Version,
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(50);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(160);
var DestinationFromNetwork = ref$1.DestinationFromNetwork;
var ref$2 = __webpack_require__(25);
var DestinationType = ref$2.DestinationType;
var ref$3 = __webpack_require__(26);
var DestinationUtil = ref$3.DestinationUtil;
var ref$4 = __webpack_require__(7);
var Parameter = ref$4.Parameter;
var ref$5 = __webpack_require__(86);
var Queue = ref$5.Queue;
var ref$6 = __webpack_require__(9);
var SolclientFactory = ref$6.SolclientFactory;
var ref$7 = __webpack_require__(87);
var Topic = ref$7.Topic;


/**
 * Creates a topic {@link solace.Destination} instance. When the returned Destination is set as
 * the destination of a message via {@link solace.Message#setDestination}, the message will be
 * delivered to direct subscribers or topic endpoints subscribed to the given topic.
 *
 * @param {String} topicName The topic string for the new topic.
 * @returns {solace.Destination} The newly created topic destination.
 * @method
 * @name solace.SolclientFactory.createTopicDestination
 */
SolclientFactory.createTopicDestination = SolclientFactory.createFactory(function (topicName) {
  Parameter.isString('topicName', topicName);
  return Topic.createFromName(topicName);
});
/* @deprecated @*/
SolclientFactory.createTopic = SolclientFactory.createFactory(function (topicName) { return new Topic(topicName); });

/**
 * Creates a durable queue {@link solace.Destination} instance. When the returned Destination is
 * set as the destination of a message via {@link solace.Message#setDestination}, the message will
 * be delivered to the Guaranteed Message queue on the Solace Message Router of the same name.
 *
 * @since 10.0.0
 * @param {String} queueName The queueName of the queue
 * @returns {solace.Destination} The newly created queue destination.
 * @method
 * @name solace.SolclientFactory.createDurableQueueDestination
 */
SolclientFactory.createDurableQueueDestination = SolclientFactory.createFactory(function (queueName) {
  Parameter.isString('queueName', queueName);
  return Queue.createFromLocalName(queueName);
});

module.exports.Destination = Destination;
module.exports.DestinationFromNetwork = DestinationFromNetwork;
module.exports.DestinationType = DestinationType;
module.exports.DestinationUtil = DestinationUtil;
module.exports.Queue = Queue;
module.exports.Topic = Topic;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(148);
var Check = ref.Check;
var ref$1 = __webpack_require__(264);
var Parameter = ref$1.Parameter;

module.exports.Check = Check;
module.exports.Parameter = Parameter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var CodecLib = __webpack_require__(220);
var ref = __webpack_require__(13);
var AdProtocolMessage = ref.AdProtocolMessage;
var BinaryMetaBlock = ref.BinaryMetaBlock;
var ClientCtrlMessage = ref.ClientCtrlMessage;
var KeepAliveMessage = ref.KeepAliveMessage;
var SMPMessage = ref.SMPMessage;
var ref$1 = __webpack_require__(126);
var SMFAdProtocolMessageType = ref$1.SMFAdProtocolMessageType;
var ref$2 = __webpack_require__(127);
var SMFAdProtocolParam = ref$2.SMFAdProtocolParam;
var ref$3 = __webpack_require__(128);
var SMFClientCtrlMessageType = ref$3.SMFClientCtrlMessageType;
var ref$4 = __webpack_require__(129);
var SMFClientCtrlParam = ref$4.SMFClientCtrlParam;
var ref$5 = __webpack_require__(78);
var SMFParameterType = ref$5.SMFParameterType;
var ref$6 = __webpack_require__(22);
var SMFProtocol = ref$6.SMFProtocol;
var ref$7 = __webpack_require__(79);
var SMFSMPMessageType = ref$7.SMFSMPMessageType;
var ref$8 = __webpack_require__(130);
var SMFSMPMessageTypeFlags = ref$8.SMFSMPMessageTypeFlags;
var ref$9 = __webpack_require__(131);
var SMFTransportSessionMessageType = ref$9.SMFTransportSessionMessageType;

module.exports.AdProtocolMessage = AdProtocolMessage;
module.exports.BinaryMetaBlock = BinaryMetaBlock;
module.exports.ClientCtrlMessage = ClientCtrlMessage;
module.exports.Codec = CodecLib;
module.exports.KeepAliveMessage = KeepAliveMessage;
module.exports.SMFAdProtocolMessageType = SMFAdProtocolMessageType;
module.exports.SMFAdProtocolParam = SMFAdProtocolParam;
module.exports.SMFClientCtrlMessageType = SMFClientCtrlMessageType;
module.exports.SMFClientCtrlParam = SMFClientCtrlParam;
module.exports.SMFParameterType = SMFParameterType;
module.exports.SMFProtocol = SMFProtocol;
module.exports.SMFSMPMessageTypeFlags = SMFSMPMessageTypeFlags;
module.exports.SMFSMPMessageType = SMFSMPMessageType;
module.exports.SMFTransportSessionMessageType = SMFTransportSessionMessageType;
module.exports.SMPMessage = SMPMessage;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(92);
var FactoryProfile = ref.FactoryProfile;
var SolclientFactoryProfiles = ref.SolclientFactoryProfiles;
var ref$1 = __webpack_require__(91);
var ProfileBinding = ref$1.ProfileBinding;
var ref$2 = __webpack_require__(176);
var SolclientFactory = ref$2.SolclientFactory;
var ref$3 = __webpack_require__(93);
var SolclientFactoryProperties = ref$3.SolclientFactoryProperties;

module.exports.FactoryProfile = FactoryProfile;
module.exports.ProfileBinding = ProfileBinding;
module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
module.exports.SolclientFactory = SolclientFactory;



/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(200);
var Codec = ref.Codec;
var ref$1 = __webpack_require__(70);
var SDTDestType = ref$1.SDTDestType;
var ref$2 = __webpack_require__(12);
var SDTField = ref$2.SDTField;
var ref$3 = __webpack_require__(11);
var SDTFieldType = ref$3.SDTFieldType;
var ref$4 = __webpack_require__(41);
var SDTMapContainer = ref$4.SDTMapContainer;
var ref$5 = __webpack_require__(42);
var SDTStreamContainer = ref$5.SDTStreamContainer;
var ref$6 = __webpack_require__(109);
var SDTUnsupportedValueError = ref$6.SDTUnsupportedValueError;
var ref$7 = __webpack_require__(110);
var SDTValueErrorSubcode = ref$7.SDTValueErrorSubcode;

module.exports.Codec = Codec;
module.exports.SDTDestType = SDTDestType;
module.exports.SDTField = SDTField;
module.exports.SDTFieldType = SDTFieldType;
module.exports.SDTMapContainer = SDTMapContainer;
module.exports.SDTStreamContainer = SDTStreamContainer;
module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
module.exports.SDTValueErrorSubcode = SDTValueErrorSubcode;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SDTFieldType = {
  /**
   * @type {Number}
   * @description Maps to a boolean.
   */
  BOOL:        0,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT8:       1,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  INT8:        2,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT16:      3,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  INT16:       4,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT32:      5,
  /**
   *@type {Number}
   * @description Maps to a number.
   */
  INT32:       6,
  /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers (range: 0 to 2<sup>48</sup>-1).
   * When decoding, only the lower 48 bits are considered significant.
   */
  UINT64:      7,
  /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers + sign (range: -(2<sup>48</sup>-1) to
   * 2<sup>48</sup>-1). When decoding, only the lower 48 bits are considered significant.
   */
  INT64:       8,
  /**
   * @type {Number}
   * @description A single character; maps to a string.
   */
  WCHAR:       9,
  /**
   * @type {Number}
   * @description Maps to a string.
   */
  STRING:      10,
  /**
   * @type {Number}
   * @description Maps to a string (string representation of a byte array).
   */
  BYTEARRAY:   11,
  /**
   * @type {Number}
   * @description Single-precision float; maps to a number.
   */
  FLOATTYPE:   12,
  /**
   * @type {Number}
   * @description Double-precision float; maps to a number.
   */
  DOUBLETYPE:  13,
  /**
   * @type {Number}
   * @description Maps to {@link SDTMapContainer}.
   */
  MAP:         14,
  /**
   * @type {Number}
   * @description Maps to {@link SDTStreamContainer}.
   */
  STREAM:      15,
  /**
   * @type {Number}
   * @description Maps to {@link Destination}.
   */
  DESTINATION: 16,
  /**
   * @type {Number}
   * @description Maps to <code>null</code>.
   */
  NULLTYPE:    17,
  /**
   * @type {Number}
   * @description Maps to an unknown type.
   */
  UNKNOWN:     18,
  /**
   * @type {Number}
   * @description Maps to an encoded SMF message.
   */
  SMF_MESSAGE: 19,
};

module.exports.SDTFieldType = Enum.new(SDTFieldType);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(11);
var SDTFieldType = ref.SDTFieldType;
var ref$1 = __webpack_require__(208);
var validateSdtField = ref$1.validateSdtField;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT (Structured Data Type) field. To create an instance of an <code>SDTField</code>,
 * call {@link solace.SDTField.create}.
 *
 * SDTField objects are used in Solace Containers ({@link solace.SDTMapContainer}
 * and {@link solace.SDTStreamContainer}). The <b>deprecated</b> usage of
 * {@link solace.SDTMapContainer#addField} and {@link solace.SDTStreamContainer#addField}
 * take a SDTField object as an argument. The preferred usage is to pass a
 * {@link solace.SDTFieldType} and value as arguments.
 *
 * SDTField objectts must be used as an argument to {@link solace.Message#setSdtContainer}.
 * The only valid SDTField objects for {@link solace.Message#setSdtContainer} are:
 * * {@link solace.SDTFieldType.STREAM}
 * * {@link solace.SDTFieldType.MAP}
 * * {@link solace.SDTFieldType.STRING}
 * @memberof solace
 */
var SDTField = function SDTField(type, value) {
  if ( type === void 0 ) type = SDTFieldType.NULLTYPE;
  if ( value === void 0 ) value = null;

  var err = validateSdtField(type, value);
  if (err !== null) {
    throw (err);
  }
  this._type = type;
  this._value = value;
  this._error = undefined;
};

/**
 * Gets the type of field represented.
 * @returns {solace.SDTFieldType} The type of field represented.
 */
SDTField.prototype.getType = function getType () {
  return this._type;
};

/**
 * Gets the field value.
 * @returns {*} Field value (as one of the supported data types).
 * @throws {solace.SDTUnsupportedValueError} if value found in the field
 * is not in range supported by the platform/runtime.
 */
SDTField.prototype.getValue = function getValue () {
  if (this._error !== undefined) {
    throw (this._error);
  }
  return this._value;
};

/**
 * Sets an error on the object to be thrown on getValue().
 * Used only by parse-integer, as it is possible to receive
 * 64 bit integers that cannot be represented in a javaScript number.
 * JavaScript numbers are floats and can only hold a 48 bit integer.
 * @private
 * @param {solace.SDTUnsupportedValueError} err error object.
 */
SDTField.prototype.setError = function setError (err) {
  this._error = err;
};

SDTField.prototype.toString = function toString () {
  return ("[SDTField type:" + (this._type) + " value:" + (this._value) + "]");
};

/**
 * Create a new SDTField instance representing a Value of a given Type.
 *
 * @param {solace.SDTFieldType} type The type of field represented.
 * @param {*} value The corresponding value to store in the field.
 * @returns {solace.SDTField} The new SDT field with the given type and value
 * @throws {solace.OperationError} if value does not match type
 * @static
 */
SDTField.create = function create (type, value) {
  return new SDTField(type, value);
};

module.exports.SDTField = SDTField;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(223);
var AdProtocolMessage = ref.AdProtocolMessage;
var ref$1 = __webpack_require__(224);
var BinaryMetaBlock = ref$1.BinaryMetaBlock;
var ref$2 = __webpack_require__(225);
var ClientCtrlMessage = ref$2.ClientCtrlMessage;
var ref$3 = __webpack_require__(226);
var KeepAliveMessage = ref$3.KeepAliveMessage;
var ref$4 = __webpack_require__(32);
var SMFHeader = ref$4.SMFHeader;
var ref$5 = __webpack_require__(77);
var SMFParameter = ref$5.SMFParameter;
var ref$6 = __webpack_require__(125);
var SMFUH = ref$6.SMFUH;
var ref$7 = __webpack_require__(227);
var SMPMessage = ref$7.SMPMessage;
var ref$8 = __webpack_require__(228);
var TransportSMFMessage = ref$8.TransportSMFMessage;

module.exports.AdProtocolMessage = AdProtocolMessage;
module.exports.BinaryMetaBlock = BinaryMetaBlock;
module.exports.ClientCtrlMessage = ClientCtrlMessage;
module.exports.KeepAliveMessage = KeepAliveMessage;
module.exports.SMFHeader = SMFHeader;
module.exports.SMFParameter = SMFParameter;
module.exports.SMFUH = SMFUH;
module.exports.SMPMessage = SMPMessage;
module.exports.TransportSMFMessage = TransportSMFMessage;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(159);
var Debug = ref.Debug;

module.exports.Debug = Debug;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module solace/fsm
 */

var ref = __webpack_require__(179);
var FsmEvent = ref.FsmEvent;
var ref$1 = __webpack_require__(27);
var State = ref$1.State;
var ref$2 = __webpack_require__(181);
var StateMachine = ref$2.StateMachine;

module.exports.FsmEvent = FsmEvent;
module.exports.State = State;
module.exports.StateMachine = StateMachine;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(196);
var Message = ref.Message;
var ref$1 = __webpack_require__(58);
var MessageCacheStatus = ref$1.MessageCacheStatus;
var ref$2 = __webpack_require__(59);
var MessageDeliveryModeType = ref$2.MessageDeliveryModeType;
var ref$3 = __webpack_require__(40);
var MessageDumpFlag = ref$3.MessageDumpFlag;
var ref$4 = __webpack_require__(103);
var MessageDumpStandardProvider = ref$4.MessageDumpStandardProvider;
var ref$5 = __webpack_require__(60);
var MessageDumpUtil = ref$5.MessageDumpUtil;
var ref$6 = __webpack_require__(104);
var MessageType = ref$6.MessageType;
var ref$7 = __webpack_require__(61);
var MessageUserCosType = ref$7.MessageUserCosType;

var ref$8 = __webpack_require__(9);
var SolclientFactory = ref$8.SolclientFactory;

/**
 * Creates a {@link solace.Message} instance.
 * @returns {solace.Message} a new message instance.
 * @method
 * @name solace.SolclientFactory.createMessage
 */
SolclientFactory.createMessage = SolclientFactory.createFactory(function () { return new Message(); });

module.exports.Message = Message;
module.exports.MessageCacheStatus = MessageCacheStatus;
module.exports.MessageDeliveryModeType = MessageDeliveryModeType;
module.exports.MessageDumpFlag = MessageDumpFlag;
module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
module.exports.MessageDumpUtil = MessageDumpUtil;
module.exports.MessageType = MessageType;
module.exports.MessageUserCosType = MessageUserCosType;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var TransportReturnCode = {
  OK:                          0,
  FAIL:                        1,
  NO_SPACE:                    2,
  DATA_DECODE_ERROR:           3,
  INVALID_STATE_FOR_OPERATION: 4,
  CONNECTION_ERROR:            5,
};

module.exports.TransportReturnCode = Enum.new(TransportReturnCode);

/* eslint-disable */
// Manually demangle these names; bug 70031
module.exports.TransportReturnCode._setCanonical({
  'OK':                          TransportReturnCode.OK,
  'FAIL':                        TransportReturnCode.FAIL,
  'NO_SPACE':                    TransportReturnCode.NO_SPACE,
  'DATA_DECODE_ERROR':           TransportReturnCode.DATA_DECODE_ERROR,
  'INVALID_STATE_FOR_OPERATION': TransportReturnCode.INVALID_STATE_FOR_OPERATION,
  'CONNECTION_ERRROR':           TransportReturnCode.CONNECTION_ERROR
});
/* eslint-enable */


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(105);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var ref$1 = __webpack_require__(62);
var QueueAccessType = ref$1.QueueAccessType;
var ref$2 = __webpack_require__(106);
var QueueDescriptor = ref$2.QueueDescriptor;
var ref$3 = __webpack_require__(197);
var QueueDescriptorValidator = ref$3.QueueDescriptorValidator;
var ref$4 = __webpack_require__(63);
var QueueDiscardBehavior = ref$4.QueueDiscardBehavior;
var ref$5 = __webpack_require__(64);
var QueuePermissions = ref$5.QueuePermissions;
var ref$6 = __webpack_require__(199);
var QueueProperties = ref$6.QueueProperties;
var ref$7 = __webpack_require__(198);
var QueuePropertiesValidator = ref$7.QueuePropertiesValidator;
var ref$8 = __webpack_require__(65);
var QueueType = ref$8.QueueType;

module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
module.exports.QueueAccessType = QueueAccessType;
module.exports.QueueDescriptor = QueueDescriptor;
module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
module.exports.QueueDiscardBehavior = QueueDiscardBehavior;
module.exports.QueuePermissions = QueuePermissions;
module.exports.QueueProperties = QueueProperties;
module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
module.exports.QueueType = QueueType;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(235);
var Stats = ref.Stats;
var ref$1 = __webpack_require__(234);
var StatsByMode = ref$1.StatsByMode;
var ref$2 = __webpack_require__(82);
var StatType = ref$2.StatType;

module.exports = {
  Stats: Stats,
  StatType: StatType,
  StatsByMode: StatsByMode,
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Connection scheme types referenced by {@link solace.SessionProperties#transportProtocol},
 * {@link solace.SessionProperties#webTransportProtocolList} (browser only), and
 * {@link solace.SessionProperties#transportProtocolInUse}.
 *
 * @target browser
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var TransportProtocol = {

  /**
   * A COMET model that uses base64 payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BASE64: 'HTTP_BASE64',

  /**
   * A COMET model that uses binary payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BINARY: 'HTTP_BINARY',

  /**
   * A COMET model that uses binary payload encoding. HTTP responses use Chunked Transfer-Encoding
   * to stream data from the Solace Message Router to the client without needing to terminate the
   * HTTP response.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BINARY_STREAMING: 'HTTP_BINARY_STREAMING',

  /**
   * A WebSocket communication channel uses binary payload encoding and provides full-duplex
   * communication between the client and the Solace Message Router over a single TCP connection.
   *
   * This is the preferred protocol to use if all networking infrastructure betweed the application
   * and the Solace Message router support WebSockets. If this is not the case, it may be necessary
   * to use one of the HTTP protocols that use the COMET model of messaging.
   *
   * This transport protocol supports Guaranteed Messaging.
   */
  WS_BINARY: 'WS_BINARY',

};

module.exports.TransportProtocol = Enum.new(TransportProtocol);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(71);
var AuthenticationScheme = ref.AuthenticationScheme;
var ref$1 = __webpack_require__(43);
var CapabilityType = ref$1.CapabilityType;
var ref$2 = __webpack_require__(111);
var MessageRxCBInfo = ref$2.MessageRxCBInfo;
var ref$3 = __webpack_require__(112);
var MutableSessionProperty = ref$3.MutableSessionProperty;
var ref$4 = __webpack_require__(218);
var Session = ref$4.Session;
var ref$5 = __webpack_require__(73);
var SessionEvent = ref$5.SessionEvent;
var ref$6 = __webpack_require__(114);
var SessionEventCBInfo = ref$6.SessionEventCBInfo;
var ref$7 = __webpack_require__(44);
var SessionEventCode = ref$7.SessionEventCode;
var ref$8 = __webpack_require__(72);
var SessionEventName = ref$8.SessionEventName;
var ref$9 = __webpack_require__(74);
var SessionProperties = ref$9.SessionProperties;
var ref$10 = __webpack_require__(117);
var SessionState = ref$10.SessionState;

var ref$11 = __webpack_require__(9);
var SolclientFactory = ref$11.SolclientFactory;

/**
 * Creates a session instance.
 * @param {solace.SessionProperties} sessionProperties Properties to configure the session.
 * @param {solace.MessageRxCBInfo} [messageCallbackInfo] <b>Deprecated:</b>
 *    Callback method for messages.  Instead applications should receive message events via
 *    `session.on(solace.SessionEventCode.MESSAGE, (message) => { ... });`
 * @param {solace.SessionEventCBInfo} [eventCallbackInfo] <b>Deprecated:</b> Callback method for
 *    events on the <i>Session</i>. Instaead applications should receive session events via
 *    `session.on(solace.SessionEventCode.<code>, (event) => { ... });`
 * @returns {solace.Session} The newly-created session.
 * @throws {solace.OperationError} if the parameters have an invalid type or value.
 *                          Subcode: {@link ErrorSubcode.PARAMETER_INVALID_TYPE}.
 * @method
 * @name solace.SolclientFactory.createSession
 */
SolclientFactory.createSession = SolclientFactory.createFactory(
  function (sessionProperties, messageCallbackInfo, eventCallbackInfo) { return new Session(sessionProperties, messageCallbackInfo, eventCallbackInfo); });

module.exports.AuthenticationScheme = AuthenticationScheme;
module.exports.CapabilityType = CapabilityType;
module.exports.MessageRxCBInfo = MessageRxCBInfo;
module.exports.MutableSessionProperty = MutableSessionProperty;
module.exports.Session = Session;
module.exports.SessionEventCBInfo = SessionEventCBInfo;
module.exports.SessionEventCode = SessionEventCode;
module.exports.SessionEvent = SessionEvent;
module.exports.SessionEventName = SessionEventName;
module.exports.SessionProperties = SessionProperties;
module.exports.SessionState = SessionState;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * SMFProtocol
 * @private
 * @enum {number}
 */
var SMFProtocol = {
  CSPF:               0x01,
  CSMP:               0x02,
  PUBMSG:             0x03,
  XMLLINK:            0x04,
  WSE:                0x05,
  SEMP:               0x06,
  SUBCTRL:            0x07,
  PUBCTRL:            0x08,
  ADCTRL:             0x09,
  KEEPALIVE:          0x0a,
  KEEPALIVEV2:        0x0b,
  CLIENTCTRL:         0x0c,
  TRMSG:              0x0d,
  JNDI:               0x0e,
  SMP:                0x0f,
  SMRP:               0x10,
  SMF_IN_SMF:         0x11,
  SMF_IN_RV:          0x12,
  ADCTRL_PASSTHROUGH: 0x13,
  TSESSION:           0x14,

};

module.exports.SMFProtocol = Enum.new(SMFProtocol);


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(140);
var SMFClient = ref.SMFClient;
var ref$1 = __webpack_require__(241);
var TransportCapabilities = ref$1.TransportCapabilities;
var ref$2 = __webpack_require__(33);
var TransportError = ref$2.TransportError;
var ref$3 = __webpack_require__(242);
var TransportFactory = ref$3.TransportFactory;
var ref$4 = __webpack_require__(20);
var TransportProtocol = ref$4.TransportProtocol;
var ref$5 = __webpack_require__(17);
var TransportReturnCode = ref$5.TransportReturnCode;
var ref$6 = __webpack_require__(24);
var TransportSessionEventCode = ref$6.TransportSessionEventCode;
var ref$7 = __webpack_require__(34);
var TransportSessionStates = ref$7.TransportSessionStates;


module.exports.SMFClient = SMFClient;
module.exports.TransportCapabilities = TransportCapabilities;
module.exports.TransportError = TransportError;
module.exports.TransportFactory = TransportFactory;
module.exports.TransportProtocol = TransportProtocol;
module.exports.TransportReturnCode = TransportReturnCode;
module.exports.TransportSessionEventCode = TransportSessionEventCode;
module.exports.TransportSessionStates = TransportSessionStates;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Defines the possible TransportSessionEvent codes.
 * @private
 * @enum {number}
 */
var TransportSessionEventCode = {
  // Raised when TransportSession is up and ready to send/receive data
  UP_NOTICE:           1,
  // Raised if the session is destroyed
  DESTROYED_NOTICE:    2,
  // Raised when the send queue had reached its maximum, but now has space again
  CAN_ACCEPT_DATA:     4,
  // Raised when there is a decode error on received data.  The app should destroy the session
  DATA_DECODE_ERROR:   5,
  // Raised when there is a decode error on received data.  The app should destroy the session
  PARSE_FAILURE:       6,
  // Raised when the connection times out. The app should attempt downgrade if available.
  CONNECT_TIMEOUT:     7,
  // There was an error sending a message on an etablished transport
  SEND_ERROR:          8,
  // The requested downgrade was rejected.
  DOWNGRADE_FAILED:    10,
  // The requested downgrade completed.
  DOWNGRADE_SUCCEEDED: 11,
};

module.exports.TransportSessionEventCode = Enum.new(TransportSessionEventCode);


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumerates destination types for destination objects.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var DestinationType = {
  /**
   * A Topic destination.
   */
  TOPIC:           'topic',
  /**
   * A queue destination.
   */
  QUEUE:           'queue',
  /**
   * A temporary queue destination.
   */
  TEMPORARY_QUEUE: 'temporary_queue',
};

module.exports.DestinationType = Enum.new(DestinationType);

/* eslint-disable */
// Manually demangle these names; bug 70131
module.exports.DestinationType._setCanonical({
  'TOPIC':           DestinationType.TOPIC,
  'QUEUE':           DestinationType.QUEUE,
  'TEMPORARY_QUEUE': DestinationType.TEMPORARY_QUEUE
});
/* eslint-enable */


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(25);
var DestinationType = ref$1.DestinationType;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(4);
var UUID = ref$3.UUID;
var StringUtils = ref$3.StringUtils;

var ucs2ToUtf8 = Convert.ucs2ToUtf8;
var utf8ToUcs2 = Convert.utf8ToUcs2;
var ProfileBinding = SolclientFactoryLib.ProfileBinding;

var toSafeChars = StringUtils.toSafeChars;
var stripNullTerminate = StringUtils.stripNullTerminate;
var ref$4 = __webpack_require__(2);
var ErrorSubcode = ref$4.ErrorSubcode;
var OperationError = ref$4.OperationError;

var DESTINATION_PREFIX_FROM_TYPE = {};
DESTINATION_PREFIX_FROM_TYPE[DestinationType.QUEUE] = '#P2P/QUE/';
DESTINATION_PREFIX_FROM_TYPE[DestinationType.TEMPORARY_QUEUE] = '#P2P/QTMP/';

function createTemporaryName(type, vrid, name) {
  var id = name || UUID.generateUUID();
  switch (type) {
    case DestinationType.TOPIC:
      return ("#P2P/TTMP/" + vrid + "/" + id);
    case DestinationType.TEMPORARY_QUEUE:
      return ("#P2P/QTMP/" + vrid + "/" + id);
    default:
      LOG_ERROR('Unknown/invalid destination type', DestinationType.describe(type));
  }
  return undefined;
}

function createPrefix(type) {
  return DESTINATION_PREFIX_FROM_TYPE[type] || '';
}

function createOperationError(type, errorStr) {
  return new OperationError(("Invalid " + type + ": " + errorStr), ErrorSubcode.INVALID_TOPIC_SYNTAX);
}

// This function validates topics in all code paths -- legacy code paths that relied on validating
// topics as they were used, and newer code paths that validate Destinations on construction.  We
// must not add validation here that could break legacy apps that used the deprecated 'new Topic'
// interface that doesn't perform validation, and subsequently rely on validate-on-use.
//
// More strict checks done during Destination construction should be placed in validateAndEncode.
// @return { error, isWildcarded }.  isWildcarded will not be defined if erorr is defined.
function legacyValidate(type, bytes, name,
                        exceptionCreator) {
  if ( exceptionCreator === void 0 ) exceptionCreator = createOperationError.bind(null, type);

  var error;

  /*
    * TRB topics can contain any utf-8 character and must be <= 250 bytes
    * in length.
    * '*', if present in a level, must be the last character in that level.
    * May not have empty levels.
    */

  // Check minimum length using name, since the bytes may include a destination type prefix.
  // e.g. #P2P/QUE/ should fail on length, not empty level.
  var nameLength = name.length;
  if (nameLength < 1) {
    error = exceptionCreator('Too short (must be >= 1 character).');
    return { error: error };
  }

  // Check maximum length using encoded bytes, since UTF-8 is a variable length encoding.
  var bytesLength = bytes.length;
  if (bytesLength > 251) { // null terminator doesn't count
    error = exceptionCreator(("Too long (encoding must be <= 250 bytes); name is " + bytesLength + " bytes: '" + name + "'"));
    return { error: error };
  }

  var isWildcarded = false;
  if (name.charAt(nameLength - 1) === '>') {
    isWildcarded = true;
  }

  for (var i = 0; i < nameLength; ++i) {
    switch (name.charAt(i)) {
      case '/':
        if (i === 0 || i === (nameLength - 1) || name.charAt(i - 1) === '/') {
          error = exceptionCreator(("Empty level(s) in '" + name + "'@" + i + "."));
          return { error: error };
        }
        break;

      case '*':
        if ((i < (nameLength - 1)) && (name.charAt(i + 1) !== '/')) {
          // must not have something other than '/' to the right
          error = exceptionCreator(("Illegal wildcard(s) in '" + name + "'@" + i + "."));
          return { error: error };
        }

        isWildcarded = true;
        break;

      default:
        break;
    }
  }

  return { isWildcarded: isWildcarded };
}

function encodeBytes(bytes) {
  return ProfileBinding.value.topicUtf8Encode
    ? ((ucs2ToUtf8(bytes)) + "\u0000")
    : (bytes + "\u0000");
}

function decodeBytes(bytes) {
  return stripNullTerminate(ProfileBinding.value.topicUtf8Encode
    ? utf8ToUcs2(bytes)
    : bytes);
}

/**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @returns {Object} {bytes, offset, networkName} The result of the encoding.
 *
 * @private
 */
function encode(type, name) {
  var prefix = createPrefix(type);
  var offset = prefix.length;
  var networkName = prefix + name;
  var bytes = encodeBytes(networkName);
  return { bytes: bytes, offset: offset, networkName: networkName };
}

/**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {Function} [exceptionCreator=createOperationError] A function to create an exception if an
 *   error is encountered.
 * @returns {Object} {bytes, error, offset, isWildcarded} The result of the encoding and any
 *      validation error
 *
 * @private
 */
function validateAndEncode(type, name, exceptionCreator) {
  if ( exceptionCreator === void 0 ) exceptionCreator = createOperationError.bind(null, type);

  var ref = encode(type, name);
  var bytes = ref.bytes;
  var offset = ref.offset;
  var ref$1 = legacyValidate(type, bytes, name, exceptionCreator);
  var constError = ref$1.error;
  var isWildcarded = ref$1.isWildcarded;
  var error = constError;

  // If there was no 'legacy' error, perform an additional check to see if the provided name starts
  // with a reserved prefix.  It shouldn't.  Prefixes should always be added by us by encode().
  if (!error) {
    Object.keys(DESTINATION_PREFIX_FROM_TYPE).some(function (prefixType) {
      var prefix = DESTINATION_PREFIX_FROM_TYPE[prefixType];
      if (!name.startsWith(prefix)) {
        return false; // keep processing more array elements.
      }

      error = exceptionCreator(("Reserved prefix '" + prefix + "' found at start of '" + name + "'"));
      return true;
    });
  }

  return { bytes: bytes, offset: offset, error: error, isWildcarded: isWildcarded };
}

var DestinationUtil = {
  createPrefix: createPrefix,
  createTemporaryName: createTemporaryName,
  decodeBytes: decodeBytes,
  encode: encode,
  encodeBytes: encodeBytes,
  legacyValidate: legacyValidate,
  toSafeChars: toSafeChars,
  validateAndEncode: validateAndEncode,
};

module.exports.DestinationUtil = DestinationUtil;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(178);
var EntryPoint = ref.EntryPoint;
var ref$1 = __webpack_require__(180);
var ExitPoint = ref$1.ExitPoint;
var ref$2 = __webpack_require__(96);
var StateContext = ref$2.StateContext;

/**
 * @classdesc
 * This class represents a state in a state machine.
 * @private
 */
var State = (function (StateContext) {
  function State(spec, extensions) {
    var this$1 = this;
    if ( extensions === void 0 ) extensions = null;

    StateContext.call(this, spec);

    var parentContext = spec.parentContext;
    Object.assign(this.impl, {
      parentContext: parentContext,
      reactions:            {},
      entryPoints:          {},
      exitPoints:           {},
      ancestorList:         parentContext.getAncestorList().concat( [this]),
      handleUnhandledEvent: function (e) { return (
        parentContext.handleEvent
          ? parentContext.handleEvent(e)
          : parentContext.impl.handleUnhandledEvent(e)
      ); },
    });
    if (parentContext) { this.log = parentContext.log.bind(this); }

    // Extend and bind functions
    Object.keys(extensions || {}).forEach(function (k) {
      var extension = extensions[k];
      this$1[k] = typeof extension === 'function' ? extension.bind(this$1) : extension;
    });

    this.setLogPadding(' '.repeat(this.impl.ancestorList.length));
  }

  if ( StateContext ) State.__proto__ = StateContext;
  State.prototype = Object.create( StateContext && StateContext.prototype );
  State.prototype.constructor = State;

  /**
   * Register a reaction function for a particular event.
   * @param {String} eventName The name of the event func is to react to.
   * @param {StateContext.reactionCallback} func The function to call when
   *  the state processes an event with the name eventName.  The function is
   *  bound to this object so that this refers to this state object when it
   *  is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.reaction = function reaction (eventName, func) {
    if (!eventName) { throw new Error('No event name for reaction'); }
    if (!func) { throw new Error(("No reaction function for reaction " + eventName)); }

    this.log(("Adding reaction to " + (this) + " for event " + eventName));

    if (this.impl.reactions[eventName]) {
      this.log(("Replacing reaction " + (this.impl.reactions[eventName]) + " with " + func));
    }
    this.impl.reactions[eventName] = func.bind(this);
    return this;
  };

  /**
   * Create an entryPoint for this state.
   * @param {String} entryPointName The name of the entryPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is entered via this entryPoint
   * @returns {State} This state object.
   * @public
   */
  State.prototype.entryPoint = function entryPoint (entryPointName, func) {
    if (!entryPointName) { throw new Error('No entry point name for entry point'); }
    if (!func) { throw new Error(("No reaction function for entry point " + entryPointName)); }

    this.log(("Adding entryPoint " + entryPointName + " to " + (this)));

    if (this.impl.entryPoints[entryPointName]) {
      this.log(("EntryPoint " + entryPointName + " already exists in " + (this)));
      return this;
    }

    this.impl.entryPoints[entryPointName] = new EntryPoint({
      state: this,
      entryPointName: entryPointName,
      func: func,
    });

    return this;
  };

  /**
   * Create an exitPoint for this state.
   * @param {String} exitPointName The name of the exitPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is exited via this exitPoint.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.exitPoint = function exitPoint (exitPointName, func) {
    if (!exitPointName) { throw new Error('No exit point name for entry point'); }
    if (!func) { throw new Error(("No reaction function for exit point " + exitPointName)); }

    this.log(("Adding exitPoint " + exitPointName + " to " + (this)));

    if (this.impl.exitPoints[exitPointName]) {
      this.log(("ExitPoint " + exitPointName + " already exists in  " + (this)));
      return this;
    }

    this.impl.exitPoints[exitPointName] = new ExitPoint({
      state: this,
      exitPointName: exitPointName,
      func: func,
    });

    return this;
  };

  /**
   * @param {String} entryPointName The name of the entry point to be
   *      transitioned to.
   * @returns { StateContext } The state context to transition to when
   *      entering via the state's entryPoint named entryPointName.
   * @protected
   */
  State.prototype.getEntryPointDestState = function getEntryPointDestState (entryPointName) {
    if (this.impl.entryPoints[entryPointName] === undefined) {
      this.log(((this) + ": EntryPoint " + entryPointName + " does not exist."));
      return this;
    }

    return this.impl.entryPoints[entryPointName].getDestState();
  };

  /**
   * @param {String} exitPointName The name of the exit point to be
   *      transitioned to.
   * @returns {StateContext} The state context to transition to when
   *      exiting via the state's exitPoint named exitPointName.
   * @protected
   */
  State.prototype.getExitPointDestState = function getExitPointDestState (exitPointName) {
    if (this.impl.exitPoints[exitPointName] === undefined) {
      this.log(((this) + ": ExitPoint " + exitPointName + " does not exist."));
      return this;
    }

    return this.impl.exitPoints[exitPointName].getDestState();
  };

  /**
   * Register a function to be called when the state is entered.
   * @param {function} func The function to call when the state is entered.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.entry = function entry (func) {
    if (this.impl.appEntryFunc) {
      this.log(("Replacing entry function " + (this.impl.appEntryFunc) + " with " + func));
    }
    this.impl.appEntryFunc = func.bind(this);
    return this;
  };

  /**
   * Register a function to be called when the state is exited.
   * @param {function} func The function to call when the state is exited.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.exit = function exit (func) {
    if (this.impl.appExitFunc) {
      this.log(("Replacing exit function " + (this.impl.appExitFunc) + " with " + func));
    }
    this.impl.appExitFunc = func.bind(this);
    return this;
  };

  /**
   * This is the same as [transitionTo]{@link StateContext#transitionTo},
   * except the outermost state is exited if the source state is within the
   * dest state or vice versa.  If one state is not within the other, this
   * is equivalent to [transitionTo]{@link StateContext#transitionTo}.
   * @param {State} state The state to transition to; if undefined, it is
   *      a self-transition.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as part
   *      of the transition, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition.
   */
  State.prototype.externalTransitionTo = function externalTransitionTo (state, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state,
      action: action,
      external:  true,
    });
  };

  /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named entryPoint created on state.  If the
   * named entryPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named entryPoint.
   * @param {String} entryPointName The name of the entryPoint of state.
   * @param {StateContext.actionCallback} action The action to perform as part of
   *      the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.transitionToEntryPoint = function transitionToEntryPoint (state, entryPointName, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state.getEntryPointDestState(entryPointName),
      action: action,
    });
  };

  /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named exitPoint created on state.  If the
   * named exitPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named exitPoint.
   * @param {String} exitPointName The name of the exitPoint of state.
   * @param {StateContext.actionCallback} [action] Optional The
   * action to perform as part of the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.transitionToExitPoint = function transitionToExitPoint (state, exitPointName, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state.getExitPointDestState(exitPointName),
      action: action,
    });
  };

  /**
   * If a reaction evaluates the guard conditions for the reaction and none
   * succeed, the eventUnhandled
   * [ReactionResult]{@link StateContext.ReactionResult} should be
   * returned.  This causes the FSM to continue looking for a reaction to
   * process the event.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.eventUnhandled = function eventUnhandled () {
    return new StateContext.ReactionResult({
      caller: this,
    });
  };

  /**
   * This [ReactionResult]{@link StateContext.ReactionResult} is used
   * when an event has been handled in a state and the transition is a local
   * transition back to itself.  Note that internal transitions never cause
   * state exits or entries -- if the internal transition is defined in an
   * outer state that contains the active state, then the behaviour is as if the
   * active state has inherited the internal transition from the outer state.
   * @param {?Function} action The action to perform in the transition.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.internalTransition = function internalTransition (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getCurrentState(),
      action: action,
    });
  };

  /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.terminate = function terminate (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getFinalState(),
      action: action,
    });
  };


  /**
   * @returns {StateContext} The parent state context for this state, which
   *      could either be an outer state, or the state machine for top-level
   *      states.
   * @protected
   */
  State.prototype.getParent = function getParent () {
    return this.impl.parentContext;
  };

  /**
   * Called when a state is being entered.  Calls the app's registered entry
   * function, if any.
   * @protected
   */
  State.prototype.onEntry = function onEntry () {
    this.log(("Entering: " + (this)));
    if (this.impl.appEntryFunc) {
      this.impl.appEntryFunc();
    }
  };

  /**
   * Called when a state is being exited.  Calls the app's registered exit
   * function, if any.
   * @protected
   */
  State.prototype.onExit = function onExit () {
    this.log(("Exiting: " + (this)));
    if (this.impl.appExitFunc) {
      this.impl.appExitFunc();
    }
  };

  /**
   * Called when a state is to handle an event.
   * @param {FsmEvent} e The event to handle.
   * @returns {ReactionResult} The result of handling the event.
   * @protected
   */
  State.prototype.handleEvent = function handleEvent (e) {
    this.log(("Process: " + e));
    var reaction = this.impl.reactions[e.getName()];
    if (reaction) {
      var result = reaction(e);
      // All ReactionResults in which an event is considered handled
      // have a destState defined.
      if (!result) {
        this.log(("Reaction returned undefined: " + e + " in " + (this)));
      }
      if (result.destState) {
        this.log(("Handled: " + e));
        return result;
      }
      this.log(("Unhandled: " + e + " in " + (this)));
    } else {
      this.log(("No reaction: " + e + " in " + (this)));
    }

    return this.impl.handleUnhandledEvent(e);
  };

  return State;
}(StateContext));

module.exports.State = State;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;
/**
 * An enumeration of message consumer event names. A {@link solace.MessageConsumer} will emit
 * these events as part of its lifecycle.  Applications, having created a MessageConsumer can
 * choose to listen to all of the events described here, or any subset of these events. For Example:
 * <pre>
 *   <code>
 *     mc = solace.Session.createMessageConsumer(...);
 *     mc.on(solace.MessageConsumerEventName.CONNECT_FAILED_ERROR,
 *           function connectFailedErrorEventCb(error) {
 *             // details is an OperationError object
 *           });
 *   </code>
 * </pre>
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
var MessageConsumerEventName = {
  /**
   * The message consumer is established.
   * @event solace.MessageConsumerEventName#UP
   */
  UP:                   'MessageConsumerEventName_up',
  /**
   * The message consumer is successfully disconnected.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN
   */
  DOWN:                 'MessageConsumerEventName_down',
 /**
   * The message consumer has become active.
   *
   * @event solace.MessageConsumerEventName#ACTIVE
   */
  ACTIVE:               'MessageConsumerEventName_active',
  /**
   * The message consumer has become inactive.
   *
   * @event solace.MessageConsumerEventName#INACTIVE
   */
  INACTIVE:             'MessageConsumerEventName_inactive',
  /**
   * The message consumer was established and then disconnected by the router,
   * likely due to operator intervention. The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN_ERROR
   */
  DOWN_ERROR:           'MessageConsumerEventName_downError',
  /**
   * The message consumer attempted to connect but was unsuccessful.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
  CONNECT_FAILED_ERROR: 'MessageConsumerEventName_connectFailedError',
  /**
   * The message consumer will not connect because the current session is incompatible
   * with Guaranteed Messaging. The message consumer is disabled until a compatible session
   * is available.
   *
   * @event solace.MessageConsumerEventName#GM_DISABLED
   */
  GM_DISABLED:          'MessageConsumerEventName_GMDisabled',
  /**
   * The message consumer is being disposed. No further events will be emitted.
   *
   * @event solace.MessageConsumerEventName#DISPOSED
   */
  DISPOSED:             'MessageConsumerEventName_disposed',
  /**
   * A message was received on the message consumer.
   *
   * If the application throws an exception in this listener, and the consumer was configured
   * to automatically acknowledge messages
   * (see {@link solace.MessageConsumerProperties#acknowledgeMode}),
   * the API will not acknowledge the message, since it
   * may not have been successfully processed by the application. Such a message must be
   * acknowledged manually. If the application did not retain a reference to the message, it
   * may be redelivered by calling {@link solace.MessageConsumer#disconnect} followed by
   * {@link solace.MessageConsumer#connect} depending on the configuration of the queue.
   *
   * When there is no listener for <i>MESSAGE</i> on a MessageConsumer, messages are queued
   * internally until a listener is added.
   *
   * @event solace.MessageConsumerEventName#MESSAGE
   * @param {solace.Message} message The received message being delivered in this event.
   */
  MESSAGE:              'MessageConsumerEventName_message',
};

module.exports.MessageConsumerEventName = Enum.new(MessageConsumerEventName);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(193);
var MessagePublisher = ref.MessagePublisher;
var ref$1 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$1.MessagePublisherAcknowledgeMode;
var ref$2 = __webpack_require__(55);
var MessagePublisherEventName = ref$2.MessagePublisherEventName;
var ref$3 = __webpack_require__(102);
var MessagePublisherProperties = ref$3.MessagePublisherProperties;
var ref$4 = __webpack_require__(192);
var MessagePublisherPropertiesValidator = ref$4.MessagePublisherPropertiesValidator;
var ref$5 = __webpack_require__(57);
var PublisherFSMEvent = ref$5.PublisherFSMEvent;
var ref$6 = __webpack_require__(56);
var PublisherFSMEventNames = ref$6.PublisherFSMEventNames;

module.exports.MessagePublisherAcknowledgeMode = MessagePublisherAcknowledgeMode;
module.exports.MessagePublisher = MessagePublisher;
module.exports.MessagePublisherProperties = MessagePublisherProperties;
module.exports.PublisherFSMEvent = PublisherFSMEvent;
module.exports.PublisherFSMEventNames = PublisherFSMEventNames;
module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
module.exports.MessagePublisherEventName = MessagePublisherEventName;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SDTDataTypes = {
  Null:            0x00,
  Boolean:         0x01,
  Integer:         0x02,
  UnsignedInteger: 0x03,
  Float:           0x04,
  Char:            0x05,
  ByteArray:       0x06,
  String:          0x07,
  Destination:     0x08,
  SMFMessage:      0x09,
  Map:             0x0A,
  Stream:          0x0B,
};

module.exports.SDTDataTypes = Enum.new(SDTDataTypes);


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/**
 * @constructor BaseMessage
 * @private
 */
var BaseMessage = function BaseMessage(header, params) {
  if ( header === void 0 ) header = null;
  if ( params === void 0 ) params = [];

  this._smfHeader = header;
  this._parameters = params;
};

var prototypeAccessors = { smfHeader: {} };

BaseMessage.prototype.addParameter = function addParameter (param) {
  this._parameters[param.getType()] = param;
};

BaseMessage.prototype.getParameter = function getParameter (paramType) {
  return this._parameters[paramType];
};

BaseMessage.prototype.getParameterArray = function getParameterArray () {
  return this._parameters;
};

prototypeAccessors.smfHeader.get = function () {
  return this._smfHeader;
};
prototypeAccessors.smfHeader.set = function (val) {
  this._smfHeader = val;
};

BaseMessage.prototype.getResponse = function getResponse () {
  var smf = this.smfHeader;
  if (!(smf && smf.pm_respcode && smf.pm_respstr)) {
    return null;
  }
  return {
    responseCode: smf.pm_respcode,
    responseString: smf.pm_respstr,
  };
};

Object.defineProperties( BaseMessage.prototype, prototypeAccessors );

module.exports.BaseMessage = BaseMessage;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * Control messages wrap an SMFHeader instance
 * @private
 */
var SMFHeader = function SMFHeader(protocol, ttl) {
  if ( protocol === void 0 ) protocol = 0;
  if ( ttl === void 0 ) ttl = 0;

  // header properties
  // header block
  // SMF parameters
  // payload
  this._parameters = [];

  // Common SMF header field values
  this.smf_version = 3;
  this.smf_uh = 0;
  this.smf_protocol = protocol;
  this.smf_priority = 0;
  this.smf_ttl = ttl;
  this.smf_msgLen = 0;
  this.smf_di = 0;
  this.smf_tqd = 0;
  this.smf_elidingEligible = 0;
  this.smf_dto = 0;
  this.smf_adf = 0;                // AD
  this.smf_deadMessageQueueEligible = 0; //DMQ Eligible

  // Common SMF protocol parameters
  this.pm_userdata = null;
  this.pm_respcode = 0;
  this.pm_respstr = null;
  this.pm_username = null;
  this.pm_password = null;
  this.pm_tr_topicname_bytes = null;
  this.pm_deliverymode = null;

  this.pm_ad_msgid = undefined;    // AD
  this.pm_ad_prevmsgid = undefined;// AD
  this.pm_ad_redelflag = 0;        // AD
  this.pm_ad_flowredelflag = 0;    // AD
  this.pm_ad_ttl = undefined;      // AD
  this.pm_ad_ackimm = undefined;   // AD
  this.pm_ad_flowid = 0;           // AD
  this.pm_ad_publisherid = 0;
  this.pm_ad_publishermsgid = 0;

  this.pm_content_summary = null;
  this.pm_corrtag = null;
  this.pm_topic_offset = 0;
  this.pm_topic_len = 0;
  this.pm_queue_offset = 0;
  this.pm_queue_len = 0;
  this.pm_msg_priority = null;      // {number}

  // housekeeping
  this.unknownProtoFlag = false;
  this.messageLength = 0;
  this.payloadLength = 0;
  this.headerLength = 0;
  this.payload = null;

  // This message is invalid, but the framing (messageLength) is fine.
  // set by the parser when UH==2 on an unknown parameter.
  // The SMF fsm can then discard and increment the stats.
  this.discardMessage = false;
};

SMFHeader.prototype.setMessageSizes = function setMessageSizes (headerLength, payloadLength) {
  this.headerLength = headerLength;
  this.payloadLength = payloadLength;
  this.messageLength = headerLength + payloadLength;
};

SMFHeader.prototype.setPayloadSize = function setPayloadSize (payloadLength) {
  this.payloadLength = payloadLength;
};

module.exports.SMFHeader = SMFHeader;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * An error thrown when an error occurs on the transport session.
 * <p>
 * Applications are not expected to instantiate this type.
 *
 * @memberof solace
 * @private
 */
var TransportError = (function (SolaceError) {
  function TransportError(message, subcode) {
    SolaceError.call(this, 'TransportError', message);
    this.subcode = subcode;
  }

  if ( SolaceError ) TransportError.__proto__ = SolaceError;
  TransportError.prototype = Object.create( SolaceError && SolaceError.prototype );
  TransportError.prototype.constructor = TransportError;

  TransportError.prototype.toString = function toString () {
    return ((SolaceError.prototype.toString.call(this)) + ", subcode=" + (this.subcode));
  };

  return TransportError;
}(SolaceError));

module.exports.TransportError = TransportError;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Transport session states, used by WebSocketTransportSession and HTTPTransportSession
 * @enum {number}
 * @private
 */
var TransportSessionState = {
  DOWN:                0,
  WAITING_FOR_CREATE:  1,
  SESSION_UP:          2,
  WAITING_FOR_DESTROY: 4,
  CONNECTION_FAILED:   5,
};

module.exports.TransportSessionState = Enum.new(TransportSessionState);


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(174);
var EventEmitter = ref.EventEmitter;
var ref$1 = __webpack_require__(175);
var Timer = ref$1.Timer;

module.exports = {
  EventEmitter: EventEmitter,
  Timer: Timer,
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(177);
var Flow = ref.Flow;
var ref$1 = __webpack_require__(94);
var FlowOperation = ref$1.FlowOperation;
var ref$2 = __webpack_require__(95);
var PrivateFlowEventName = ref$2.PrivateFlowEventName;

module.exports.Flow = Flow;
module.exports.FlowOperation = FlowOperation;
module.exports.PrivateFlowEventName = PrivateFlowEventName;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var OperationError = ref.OperationError;

/**
 * @classdesc
 * This is a base class for various FSM-related objects.
 * @private
 */
var FsmObject = function FsmObject(spec) {
  if (!spec) {
    throw new OperationError('No spec provided');
  }
  if (!spec.name) {
    throw new OperationError('No name provided for spec');
  }
  this.impl = {
    name: spec.name,
  };
};

/**
 * @returns {String} A string representation of the object.
 */
FsmObject.prototype.toString = function toString () {
  var extraStringInfo = this.getExtraStringInfo();
  if (extraStringInfo.length > 0) {
    extraStringInfo = "; " + extraStringInfo;
  }
  return ("{" + (this.constructor.name) + ": " + (this.getName()) + extraStringInfo + "}");
};

/**
 * This is overridden by classes wanting to add more data, typically in the
 * form of 'name: value; name: value'.
 * @returns {String} Extra string information to be included in the object's
 *    toString() output.
 */
FsmObject.prototype.getExtraStringInfo = function getExtraStringInfo () { // eslint-disable-line class-methods-use-this
  return '';
};

/**
 * @returns {?String} The name passed into the object specifier.
 */
FsmObject.prototype.getName = function getName () {
  return this.impl.name;
};

module.exports.FsmObject = FsmObject;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An enumeration of consumer acknowledgement modes. The corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#acknowledgeMode}
 * configures how acknowledgments are generated for received Guaranteed messages.
 *
 * When received messages are acknowledged they are removed from the Guaranteed
 * Message storage on the Solace Message Router. Message Consumer acknowledgements,
 * <b>only</b> remove messages from the Solace Message Router.
 *
 * In particular, withholding Message Consumer Acknowledgemnts does not stop
 * message delivery. For Message Consumer flow control see
 * {@link solace.MessageConsumer.stop}/{@link solace.MessageConsumer.start}. Message Consumer
 * flow control may also be imlpemented by removing the
 * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
var MessageConsumerAcknowledgeMode = {
  /**
   * The API automatically acknowledges any message that was delivered to all
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listeners with no exception thrown
   * on any of them.
   */
  AUTO:   'AUTO',
  /**
   * The API acknowledges a message only when the application calls
   * {@link solace.Message#acknowledge}.
   */
  CLIENT: 'CLIENT',
};

module.exports.MessageConsumerAcknowledgeMode = Enum.new(MessageConsumerAcknowledgeMode);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents authentication scheme enumeration.
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var MessagePublisherAcknowledgeMode = {
  /**
   * @description Applications receive an acknowledgement for every
   * message.
   * @type {String}
   */
  PER_MESSAGE: 'PER_MESSAGE',
  /**
   * @description Applications receive a windowed acknowledgement that
   * acknowledges the returned correlation identifier and every message sent prior.
   * @type {String}
   */
  WINDOWED:    'WINDOWED',
};

module.exports.MessagePublisherAcknowledgeMode = Enum.new(MessagePublisherAcknowledgeMode);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message dump formats. It controls
 * the output of {@link solace.Message#dump}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageDumpFlag = {
  /**
   * Display only the length of the binary attachment, XML content and user property maps.
   */
  MSGDUMP_BRIEF: 0,
  /**
   * Display the entire message contents.
   */
  MSGDUMP_FULL:  1,
};

module.exports.MessageDumpFlag = Enum.new(MessageDumpFlag);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;

/**
 * @classdesc
 * Defines a Structured Data Type (SDT) map container.
 * @memberof solace
 */
var SDTMapContainer = function SDTMapContainer() {
  this._map = []; // key-value mappings (keys are strings)
};

/**
 * Get the list of keys in this map, in unspecified order.
 * @returns {Array.<String>} Array of defined keys in the map.
 */
SDTMapContainer.prototype.getKeys = function getKeys () {
  return Object.keys(this._map);
};

/**
 * Return the SDTField with the given key.
 * @param {String} key The key to look up.
 * @returns {solace.SDTField} The field referenced by key.
 */
SDTMapContainer.prototype.getField = function getField (key) {
  return this._map[key];
};

/**
 * Delete an SDTField with the given key.
 * @param {String} key The field key to delete.
 */
SDTMapContainer.prototype.deleteField = function deleteField (key) {
  delete this._map[key];
};

/**
 * Adds a field to this map. If a key:value mapping already exists for this key, it is replaced.
 * <p>
 * @deprecated If <code>typeOrField</code> is a {@link solace.SDTField} instance,
 * it is added to the map.
 *
 * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
 * SDTField of this type using <code>value</code> before adding it to the map.
 *
 * @param {String} key The key by which to store the given value.
 * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
 * @param {*} [value] The value to wrap as an SDTField.
 * @throws {solace.OperationError} if value does not match type
 * @throws {solace.SDTUnsupportedValueError} if value is not in range
 *supported by the platform/runtime
 */
SDTMapContainer.prototype.addField = function addField (key, typeOrField, value) {
    if ( value === void 0 ) value = undefined;

  if (typeOrField instanceof SDTField) {
    this._map[key] = typeOrField;
    return;
  } else if (typeof value !== 'undefined') {
    this._map[key] = SDTField.create(typeOrField, value);
    return;
  }
  throw new OperationError('Invalid parameters to addField: expected SDTField, or type and value',
    ErrorSubcode.PARAMETER_CONFLICT);
};

module.exports.SDTMapContainer = SDTMapContainer;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var SDTFieldLib = __webpack_require__(12);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;

/**
 * @classdesc
 * Defines a Structured Data Type (SDT) stream container. A stream is an iterable collection of
 * {@link solace.SDTField}s.
 * @memberof solace
 */
var SDTStreamContainer = function SDTStreamContainer() {
  this._stream = [];
  this._writable = true;
  this._readPt = 0;
};

/**
 * Returns true if the stream has at least one more {@link solace.SDTField}
 * at the current position.
 * @returns {Boolean} true, if there is an available field at the read pointer; false, otherwise.
 */
SDTStreamContainer.prototype.hasNext = function hasNext () {
  return (this._stream.length > this._readPt);
};

/**
 * Returns the next field in the stream and advances the read pointer.
 * If the end of the stream is reached, it returns undefined.
 * @returns {solace.SDTField} The next field in the stream.
 */
SDTStreamContainer.prototype.getNext = function getNext () {
  return (this._readPt < this._stream.length) ? this._stream[this._readPt++] : undefined;
};

/**
 * Rewinds the read pointer to the beginning of the stream. Normally when {@link hasNext}
 * returns false, a client application must call rewind() to reiterate over the stream's fields.
 * @throws {solace.OperationError} if the stream cannot be rewound.
 */
SDTStreamContainer.prototype.rewind = function rewind () {
  this._readPt = 0;
};

/**
 * Appends a SDTField to the stream.
 * <p>
 * If <code>field</code> is a {@link solace.SDTField}, this field is appended to the stream.
 * <br>
 * If <code>field</code> is a {@link solace.SDTFieldType},
 * then the API will create a SDTField of this
 * type with a value of <code>optValue</code> and append this new SDTField to
 * the stream.
 *
 * @param {solace.SDTField|solace.SDTFieldType} field The field to append to the stream.
 * @param {*} [optValue] The value to wrap as an SDTField.
 */
/**
 * Appends a field to this stream.
 * <p>
 * @deprecated If <code>typeOrField</code> is a {@link solace.SDTField} instance,
 * it is appended to the stream.
 *
 * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
 * SDTField of this type using <code>value</code> and append this new SDTField
 * to the stream.
 *
 * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
 * @param {*} [value] The value to wrap as an SDTField.
 * @throws {solace.OperationError} if value does not match type
 * @throws {solace.SDTUnsupportedValueError} if value is not in range
 *supported by the platform/runtime
 */
SDTStreamContainer.prototype.addField = function addField (typeOrField, value) {
    if ( value === void 0 ) value = undefined;

  if (!this._writable) { return; }

  if (typeOrField instanceof SDTFieldLib.SDTField) {
    this._stream.push(typeOrField);
    return;
  }

  if (typeof value !== 'undefined') {
    this._stream.push(SDTFieldLib.SDTField.create(typeOrField, value));
    return;
  }

  throw new OperationError('Invalid parameters to addField: expected SDTField, or type and value',
    ErrorSubcode.PARAMETER_CONFLICT);
};

module.exports.SDTStreamContainer = SDTStreamContainer;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of peer capabilities.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CapabilityType = {
  /**
   * Peer's software load version. Type: string.
   */
  PEER_SOFTWARE_VERSION:        0,
  /**
   * Peer's software release date. Type: string.
   */
  PEER_SOFTWARE_DATE:           1,
  /**
   * Peer's platform. Type: string.
   */
  PEER_PLATFORM:                2,
  /**
   * Speed (in Mbps) of the port the client connects to. Type: number.
   */
  PEER_PORT_SPEED:              3,
  /**
   * Type of the port the client has connected to (currently 0: Ethernet). Type: number.
   */
  PEER_PORT_TYPE:               4,
  /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
  MAX_DIRECT_MSG_SIZE:          5,
  /**
   * Peer's router name. Type: string.
   *
   * This property is useful when sending SEMP requests to a peer's SEMP topic, which may be
   * constructed as `#P2P/routername/#client/SEMP`.
   */
  PEER_ROUTER_NAME:             6,
  /**
   * Peer supports message eliding. Type: boolean.
   */
  MESSAGE_ELIDING:              7,
  /**
   * Peer supports NoLocal option (client may avoid receiving messages published by itself).
   */
  NO_LOCAL:                     8,
  /**
   * Peer supports Guaranteed Message Consumer connections for receiving guaranteed messages.
   */
  GUARANTEED_MESSAGE_CONSUME:   9,
  /**
   * Peer supports temporary endpoints.
   */
  TEMPORARY_ENDPOINT:           10,
  /**
   * Peer supports Guaranteed Message Publisher connections for sedning guaranteed messages.
   */
  GUARANTEED_MESSAGE_PUBLISH:   11,
  /**
   * Peer supports Guaranteed Messages Browser connections for receiving guaranteed messages
   */
  GUARANTEED_MESSAGE_BROWSE:    12,
  /**
   * Peer supports creating/modify/disposing endpoints.
   */
  ENDPOINT_MGMT:                13,
  /**
   * Peer supports selectors on Guaranteed Message Consumers.
   */
  SELECTOR:                     14,
  /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
  MAX_GUARANTEED_MSG_SIZE:      15,
  /**
   * Peer supports Guaranteed Messaging Consumer state change updates. Type: boolean
   */
  ACTIVE_CONSUMER_INDICATION:   16,
  /**
   * Peer accepts compressed (DEFLATE) data. Type: boolean.
   */
  COMPRESSION:                  17,
  /**
   * Peer supports Guaranteed Messaging cut-through. Type: boolean
   */
  CUT_THROUGH:                  18,
  /**
   * Peer supports provisioned queue and topic-endpoint discard behavior. Type: boolean
   */
  ENDPOINT_DISCARD_BEHAVIOR:    19,
  /**
   * Peer supports Guaranteed Messaging message TTL and Dead-Message Queues. Type: boolean
   */
  ENDPOINT_MESSAGE_TTL:         20,
  /**
   * Peer accepts JNDI queries. Type: boolean.
   */
  JNDI:                         21,
  /**
   * Peer supports per topic sequence numbering for Guaranteed Messaging messages. Type: boolean
   */
  PER_TOPIC_SEQUENCE_NUMBERING: 22,
  /**
   * Peer supports QueueSubscriptionAdd for managing subscriptions on queue endpoints.
   * Type: boolean
   */
  QUEUE_SUBSCRIPTIONS:          23,
  /**
   * Peer supports add/remove subscriptions for a specified clientName. Type: boolean
   */
  SUBSCRIPTION_MANAGER:         24,
  /**
   * Peer supports transacted sessions. Type: boolean.
   */
  TRANSACTED_SESSION:           25,
};

module.exports.CapabilityType = Enum.new(CapabilityType);


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;


/**
 * @callback solace.SessionEventCodes.sessionEvent
 * @function
 * @this {solace.Session} The message consumer for the event
 * @param {solace.SessionEvent|solace.OperationError} event The event. If the event is an
 *  error, the event will be an instance of {@link solace.OperationError} but will also be
 *  interface-compatible with {@link solace.SessionEvent}.
 */


/**
 * An attribute of {@link SessionEvent}. This enumeration represents the
 * different events emitted by {@link Session} through the session event
 * callback.
 *
 * When a session is no longer in a usable state, the API tears down the underlying
 * connection and notifies the application with one of the following session events:
 *  * {@link solace.SessionEventCode#event:DOWN_ERROR}
 *  * {@link solace.SessionEventCode#event:CONNECT_FAILED_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SessionEventCode = {
  /**
   * The Session is ready to send/receive messages and perform control operations.
   *
   * At this point the transport session is up, the Session has logged in, and the
   * P2PInbox subscription is added.
   *
   * The session is established.
   * @event solace.SessionEventCode#UP_NOTICE
   */
  UP_NOTICE:                         0,
  /**
   * The session was established and then went down.
   * @event solace.SessionEventCode#DOWN_ERROR
   * @param {solace.OperationError} error The details related to the session failure.
   */
  DOWN_ERROR:                        1,
  /**
   * The session attempted to connect but was unsuccessful.
   * @event solace.SessionEventCode#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error The details related to the failed connection attempt.
   */
  CONNECT_FAILED_ERROR:              2,
  /**
   * The Solace Message Router rejected a published message.
   * @event solace.SessionEventCode#REJECTED_MESSAGE_ERROR
   * @param {solace.RequestError} error The details related to the rejected message.
   */
  REJECTED_MESSAGE_ERROR:            4,
  /**
   * The Solace Message Router rejected a subscription (add or remove).
   * @event solace.SessionEventCode#SUBSCRIPTION_ERROR
   * @param {solace.RequestError} error The details related to the failed subscription update.
   */
  SUBSCRIPTION_ERROR:                5,
  /**
   * The subscribe or unsubscribe operation succeeded.
   * @event solace.SessionEventCode#SUBSCRIPTION_OK
   * @param {solace.SessionEvent} event The details related to the successful subscription update.
   */
  SUBSCRIPTION_OK:                   6,
  /**
   * The Solace Message Router's Virtual Router Name changed during a reconnect operation.
   * @event solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
   * @param {solace.SessionEvent} event Information related to the event.
   */
  VIRTUALROUTER_NAME_CHANGED:        7,
  /**
   * @deprecated
   * A request was aborted because the session is being disconnected.
   * Use {@link solace.RequestFailEvent} instead.
   */
  REQUEST_ABORTED:                   8,
  /**
   * @deprecated
   * The event represents a timed-out request API call.
   * Use {@link solace.RequestFailEvent} instead.
   */
  REQUEST_TIMEOUT:                   9,
  /**
   * The event represents a successful update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_OK
   * @param {solace.SessionEvent} event Information related to the successful property update.
   */
  PROPERTY_UPDATE_OK:                10,
  /**
   * The event represents a failed update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_ERROR
   * @param {solace.RequestError} error The details related to the failed property update.
   */
  PROPERTY_UPDATE_ERROR:             11,
  /**
   * The session transport can accept data again.  This event will occur after an
   * {@link solace.OperationError} is thrown from an API call with a subcode of
   * {@link solace.ErrorSubcode.INSUFFICIENT_SPACE} to indicate the operation can be retried.
   * @event solace.SessionEventCode#CAN_ACCEPT_DATA
   */
  CAN_ACCEPT_DATA:                   13,
  /**
   * The session connect operation failed, or the session that was once up,
   * is now disconnected.
   * @event solace.SessionEventCode#DISCONNECTED
   */
  DISCONNECTED:                      14,
  /**
   * The session has gone down, and an automatic reconnection attempt is in progress.
   * @event solace.SessionEventCode#RECONNECTING_NOTICE
   * @param {solace.SessionEvent} event The details related to the cause of the connection
   *    interruption.
   */
  RECONNECTING_NOTICE:               22,
  /**
   * The automatic reconnect of the Session was successful, and the session is established again.
   * @event solace.SessionEventCode#RECONNECTED_NOTICE
   * @param {solace.SessionEvent} event The details related to the re-establishment of the
   *    connection.
   */
  RECONNECTED_NOTICE:                23,
  /**
   * The session has automatically recovered after the Guaranteed Message publisher
   * failed to reconnect.
   * Messages sent but not acknowledged are being renumbered and retransmitted.
   * Some messages may be duplicated in the system.
   * @event solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
   * @param {solace.SessionEvent} event The details related to the republishing of messages on the
   *    session.  {@link solace.SessionEvent#infoStr} will indicate the number of messages being
   *    republished, which is an upper bound on the number of messages that could be duplicated due
   *    to this action.
   */
  REPUBLISHING_UNACKED_MESSAGES:     24,
  /**
   * A message was acknowledged by the router.
   * @event solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
   * @param {solace.SessionEvent} event Allows the acknowledgement to be correlated to the sent
   *    message.
   */
  ACKNOWLEDGED_MESSAGE:              25,
  /**
   * Unsubscribing the topic from the Durable Topic Endpoint succeeded.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
   */
  UNSUBSCRIBE_TE_TOPIC_OK:           26,
  /**
   * Unsubscribing the topic from the Durable Topic Endpoint failed.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
   * @param {solace.OperationError} error The details related to the failed attempt to remove the
   *    subscription from a topic endpoint.
   */
  UNSUBSCRIBE_TE_TOPIC_ERROR:        27,
  /**
   * A Direct message was received on the session. This event code is only used
   * on the <b>EventEmitter</b> session interface.  If using the deprecated callback interface,
   * messages are received via the callback provided in {@link solace.MessageRxCBInfo}.
   * @event solace.SessionEventCode#MESSAGE
   * @param {solace.Message} message The message received on the session.
   */
  MESSAGE:                           28,
  /**
   * Guaranteed Messaging Publisher has been closed by the Solace
   * message router. This usually indicates an operator has disabled the
   * message spool.
   * @event solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
   * @param {solace.OperationError} error Information related to the error.
   */
  GUARANTEED_MESSAGE_PUBLISHER_DOWN: 29,
};

module.exports.SessionEventCode = Enum.new(SessionEventCode);


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Type maching SMF encoding value
 * @enum {number}
 * @memberof solace
 * @private
 */
var ContentSummaryType = {
  XML_META:          0,
  XML_PAYLOAD:       1,
  BINARY_ATTACHMENT: 2,
  CID_LIST:          3,
  BINARY_METADATA:   4,
};

module.exports.ContentSummaryType = Enum.new(ContentSummaryType);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(17);
var TransportReturnCode = ref$1.TransportReturnCode;

// Stubs don't use this
/* eslint-disable class-methods-use-this */
// Stubs declare all params
/* eslint-disable no-unused-vars */

/**
 *
 * Base class for various transports
 * @private
 */
var TransportBase = function TransportBase(url, eventCB, client, transportProps, interceptor) {
  if ( interceptor === void 0 ) interceptor = null;

  this._url = url;
  this._ssl = TransportBase.useSsl(url);
  this._client = client;
  this._eventCB = eventCB;
  this._props = transportProps;
  this.setInterceptor(interceptor);
};

/**
 * Establish underlying transport.
 * Returns transport return code, to be overridden in subclass
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.connect = function connect () { return TransportReturnCode.OK; };

/**
 * Destroy the underlying transport.
 * Returns transport return code, to be overridden in subclass
 * @param {Boolean} immediate Destroy gracefully if false.
 * @param {?String} msg The message associated with this operation, if any.
 * @param {?ErrorSubcode} subcode The subcode associated with this operation, if any.
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.destroy = function destroy (immediate, msg, subcode) { return TransportReturnCode.OK; };

TransportBase.prototype.flush = function flush (callback) {
  callback();
  return TransportReturnCode.OK;
};

/**
 * Send encoded SMF message
 * Returns transport return code, to be overridden in subclass
 * @param {String} message The encoded SMF message to send
 * @param {?Boolean} [forceAllowEnqueue=false] If true, do not fail due to transport buffer full
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.send = function send (message, forceAllowEnqueue) {
  if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;
 return TransportReturnCode.OK; };

/**
 * @returns {TransportProtocol} Return transport protocol in use
 */
TransportBase.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._props.transportProtocol;
};

/**
 * @returns {?String} Return transport session information such as sessionId
 */
TransportBase.prototype.getInfoStr = function getInfoStr () { return null; };

/**
 * @returns {TransportClientStats} transport statistics
 */
TransportBase.prototype.getClientStats = function getClientStats () { return null; };

/**
 * Check whether or not the transport can be downgraded to the next protocol.
 * It is possible to downgrade the transport, the existing transport is destroyed and
 * the new transport connection initiated.
 * @param {String} msg The message associated with this operation
 * @param {ErrorSubcode} subcode The subcode associated with this operation
 * @returns {Boolean} Return true if downgrade is allowed and has been initiated; false otherwise
 */
TransportBase.prototype.beginDowngrade = function beginDowngrade (msg, subcode) { return false; };

/**
 * Sets the interceptor for this transport. This object has the chance
 * to intervene before bytes are sent or received.
 * @param {Object} [interceptor] If set, the interceptor is inserted into the
 *
 * @private
 */
TransportBase.prototype.setInterceptor = function setInterceptor (interceptor) {
  if (this._interceptor) {
    // Reset original callbacks
    if (this._interceptor.removed) { this._interceptor.removed(this); }
  }
  this._interceptor = interceptor;
  if (interceptor) {
    if (interceptor.installed) { interceptor.installed(this); }
  }
};

TransportBase.prototype.toString = function toString () {
  return ("" + (this.getTransportProtocol()) + (this._ssl ? ' (SSL)' : ''));
};

/**
 * @param {String} url The URL to check
 * @returns {Boolean} `true` if the URL requires SSL; `false` otherwise
 * @static
 */
TransportBase.useSsl = function useSsl (url) {
  var urlParts = (url || '').split('://');
  if (urlParts.length === 0 || TransportBase.validSchemes.indexOf(urlParts[0]) < 0) {
    throw new OperationError(("Invalid url \"" + url + "\": Only [" + (TransportBase.validSchemes.join(', ')) + "] URL schemes are supported"),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }

  var useSSL = (urlParts[0] === 'https' || urlParts[0] === 'wss' || urlParts[0] === 'tcps');
  return useSSL;
};

/**
 * @type {Array.<String>}
 */
TransportBase.validSchemes = ['http', 'https', 'ws', 'wss', 'tcp', 'tcps'];

module.exports.TransportBase = TransportBase;



/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(3);
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(24);
var TransportSessionEventCode = ref$2.TransportSessionEventCode;

var formatHexString = Hex.formatHexString;

/**
 * @classdesc
 * Defines a Transport Session Event
 *
 * @private
 */
var TransportSessionEvent = function TransportSessionEvent(tsEventCode, infoStr, responseCode, subcode, sessionId) {
  this._transportEventCode = tsEventCode;
  this._infoStr = infoStr;
  this._responseCode = responseCode;
  this._errorSubcode = subcode;
  this._sid = sessionId;
};

var prototypeAccessors = { transportEventCode: {},infoStr: {},responseCode: {},errorSubcode: {},sessionId: {} };

// TransportSessionEvent functions

TransportSessionEvent.prototype.getTransportEventCode = function getTransportEventCode () {
  return this._transportEventCode;
};

prototypeAccessors.transportEventCode.get = function () {
  return this._transportEventCode;
};

TransportSessionEvent.prototype.getInfoStr = function getInfoStr () {
  return this.infoStr;
};

prototypeAccessors.infoStr.get = function () {
  return this._infoStr;
};

TransportSessionEvent.prototype.getResponseCode = function getResponseCode () {
  return this.responseCode;
};

prototypeAccessors.responseCode.get = function () {
  return this._responseCode;
};

TransportSessionEvent.prototype.getSubcode = function getSubcode () {
  return this.errorSubcode;
};

prototypeAccessors.errorSubcode.get = function () {
  return this._errorSubcode;
};

TransportSessionEvent.prototype.getSessionId = function getSessionId () {
  return this.sessionId;
};

prototypeAccessors.sessionId.get = function () {
  return this._sid;
};

TransportSessionEvent.prototype[util.inspect.custom] = function () {
  return {
    'transportEventCode': TransportSessionEventCode.describe(this.transportEventCode),
    'infoStr':          this.infoStr,
    'responseCode':     this.responseCode,
    'errorSubcode':     ErrorSubcode.describe(this.errorSubcode),
    'sid':              this.sid && formatHexString(this.sid) || 'N/A',
  };
};

TransportSessionEvent.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( TransportSessionEvent.prototype, prototypeAccessors );

module.exports.TransportSessionEvent = TransportSessionEvent;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_INFO = ref.LOG_INFO;
var LOG_WARN = ref.LOG_WARN;
var ref$1 = __webpack_require__(4);
var Process = ref$1.Process;

/**
 * @classdesc
 * Base class for transports
 * @memberof solace
 * @private
 */
var TSHState = function TSHState(useSsl, tpProtocol, exitCallback, nextState) {
  this._ssl = !!useSsl;
  this._transportProtocol = tpProtocol;
  this._exitCallback = exitCallback;
  this._nextState = nextState;
  this._unsupportedRuntimeMessage =
    (this._transportProtocol) + " not supported by this runtime: " + (Process.userAgent);
};

TSHState.prototype.getNextState = function getNextState () {
  return this._nextState;
};

TSHState.prototype.setNextState = function setNextState (nextState) {
  this._nextState = nextState;
};

TSHState.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._transportProtocol;
};

TSHState.prototype.getUseSsl = function getUseSsl () {
  return this._ssl;
};

// Override me
TSHState.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
  return true;
};

TSHState.prototype.onEnter = function onEnter () {
  if (!this.validateLegal()) {
    if (this._nextState && this._exitCallback) {
      this._exitCallback(this._nextState, this._unsupportedRuntimeMessage);
    } else {
      LOG_WARN(((this._unsupportedRuntimeMessage) + ", no next state."));
    }
  }
};

TSHState.prototype.completeDowngrade = function completeDowngrade (err) {
  if (this._nextState && this._exitCallback) {
    LOG_INFO(("Connect failed (" + err + "), try next state."));
    this._exitCallback(this._nextState, 'Connect failed');
    return true;
  }
  LOG_WARN(("Connect failed (" + err + "), no next state."));
  return false;
};

TSHState.prototype.toString = function toString () {
  return this._transportProtocol + (this._ssl ? ' (SSL)' : '');
};

module.exports.TSHState = TSHState;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var HTTPLib = __webpack_require__(85);
var ref = __webpack_require__(146);
var WebSocketTransportSession = ref.WebSocketTransportSession;

var HTTPConnection = HTTPLib.HTTPConnection;

var WebTransportCapabilities = {
  webSocket: function webSocket() { return WebSocketTransportSession.browserSupportsBinaryWebSockets(); },
  xhrBinary: function xhrBinary() { return HTTPConnection.browserSupportsXhrBinary(); },
  streaming: function streaming() { return HTTPConnection.browserSupportsStreamingResponse(); },
};

module.exports.WebTransportCapabilities = WebTransportCapabilities;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(25);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(26);
var DestinationUtil = ref$1.DestinationUtil;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instances from
 * one of the following:</b>
 * * {@link solace.SolclientFactory.createTopicDestination}
 * * {@link solace.SolclientFactory.createDurableQueueDestination}
 * * {@link solace.MessageConsumer#getDestination}
 * * {@link solace.SDTField#getValue} when {@link solace.SDTField#getType} returns
 *   {@link solace.SDTFieldType.DESTINATION}.
 *
 * Represents a message destination.
 *
 * Publishers can send messages to topics or queues, to which subscribers can subscribe or
 * bind. A Destination specifies the target of such an operation.
 * @hideconstructor
 * @memberof solace
 */
var Destination = function Destination(spec, type) {
  if ( type === void 0 ) type = DestinationType.TOPIC;

  if (typeof spec === 'object') {
    this._name = spec.name;
    this._type = spec.type;
    this._bytes = spec.bytes;
    this._offset = spec.offset;
    if (spec.isValidated) {
      this._isValidated = true;
      this._isWildcarded = spec.isWildcarded;
    } else {
      this._isValidated = false;
    }
  } else {
    this._name = spec;
    this._type = type;

    // Don't validate encoding for deprecated construction path.
    // This path would have more restrictions now, and it allows
    // sdkperf a path for arbitrary topic construction.
    var result = DestinationUtil.encode(type, spec);
    this._bytes = result.bytes;
    this._offset = result.offset;
    this._isValidated = false;
  }
};

var prototypeAccessors = { name: {},type: {},bytes: {},offset: {} };

/**
 * @returns {String} The destination name specified at creation time.
 */
Destination.prototype.getName = function getName () {
  return this._name;
};

/**
 * @type {String}
 * @readonly
 */
prototypeAccessors.name.get = function () {
  return this.getName();
};

/**
 * @returns {solace.DestinationType} The destination type
 */
Destination.prototype.getType = function getType () {
  return this._type;
};

/**
 * @type {solace.DestinationType}
 * @readonly
 */
prototypeAccessors.type.get = function () {
  return this.getType();
};

/**
 * @returns {String} Returns the null-terminated UTF-8 encoded destination bytes.
 *
 * @private
 */
Destination.prototype.getBytes = function getBytes () {
  return this._bytes;
};
prototypeAccessors.bytes.get = function () {
  return this.getBytes();
};

Destination.prototype.getOffset = function getOffset () {
  return this._offset;
};
prototypeAccessors.offset.get = function () {
  return this.getOffset();
};

/**
 * This provides the legacy validation that was done post-creation and is used in some code paths
 * on use.It is preferred to use non-deprecated ways of creating destinations, which do
 * validation on create instead.
 * @throws OperationError if the destination is not valid.
 * @private
 */
Destination.prototype.validate = function validate () {
  if (this._isValidated) {
    if (this._error) { throw this._error; }
    return;
  }

  var ref =
    DestinationUtil.legacyValidate(this.type, this.bytes, this.name);
    var error = ref.error;
    var isWildcarded = ref.isWildcarded;
  this._isValidated = true;
  if (error) {
    this._error = error;
    throw error;
  }
  this._isWildcarded = isWildcarded;
};

/**
 * This is really only useful for topics.If a queue name contains a wildcarded construct, it is
 * up to the router what to do -- it would either reject it or treat the wildcard as literal.But
 * it is included here for all destination types since we have the info.
 * @returns {Boolean} True if the underlying name represents a wildcarded topic; false otherwise.
 * @throws {OperationError} If the destination is not valid.
 * @private
 */
Destination.prototype.isWildcarded = function isWildcarded () {
  this.validate();
  return this._isWildcarded;
};

/**
 * @returns {String} A generic description of the Destination.
 */
Destination.prototype.toString = function toString () {
  return util.inspect(this);
};

/**
 * @param {*} other The other object for comparison
 * @returns {Boolean} True if the passed destination is the same
 * @private
 */
Destination.prototype.equals = function equals (other) {
  if (!(other instanceof Destination)) {
    return false;
  }
  return (this.toString().valueOf() === other.toString().valueOf());
};

Object.defineProperties( Destination.prototype, prototypeAccessors );

module.exports.Destination = Destination;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Defines an error subcode enumeration which is returned as a property of
 * the errors/exceptions thrown by the API. The subcode provides more detailed
 * error information.
 *
 * The following subcodes can apply to error responses resulting from
 * any API method.
 * * {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}
 * * {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 * * {@link solace.ErrorSubcode.INTERNAL_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var ErrorSubcode = {
  /////////////
  // SESSION //
  /////////////
  /**
   * Errors that do not have a proper subcode.
   */
  UNKNOWN_ERROR:                                 0xFFFFFFFF,
  /**
   * No error is associated with this event.
   */
  NO_ERROR:                                      0,
  /**
   * The session is already connected.
   */
  // SESSION_ALREADY_CONNECTED: 1,
  /**
   * The session is not connected.
   */
  SESSION_NOT_CONNECTED:                         2,
  /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   * @deprecated Use {@link solace.ErrorSubCode.INVALID_OPERATION}
   */
  INVALID_SESSION_OPERATION:                     3,
  /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   */
  INVALID_OPERATION:                             3,
  /**
   * An API call failed due to a timeout.
   */
  TIMEOUT:                                       4,
  /////////////////
  // MESSAGE VPN //
  /////////////////
  /**
   * The Message VPN name configured for the session is not
   * configured to allow access for the session's username.
   *
   * Causes:
   *  * 403 Message VPN Not Allowed
   */
  MESSAGE_VPN_NOT_ALLOWED:                       5,
  /**
   * The Message VPN name set for the session (or the default VPN if none
   * was set) is currently shutdown on the router.
   *
   * Causes:
   *  * 503 Message VPN Unavailable
   */
  MESSAGE_VPN_UNAVAILABLE:                       6,
  ////////////
  // CLIENT //
  ////////////
  /**
   * The username for the client is administratively shutdown
   * on the router.
   *
   * Causes:
   *  * 403 Client Username Is Shutdown
   */
  CLIENT_USERNAME_IS_SHUTDOWN:                   7,
  /**
   * The username for the session has not been set and dynamic
   * clients are not allowed.
   *
   * Causes:
   *  * 403 Dynamic Clients Not Allowed
   */
  DYNAMIC_CLIENTS_NOT_ALLOWED:                   8,
  /**
   * The session is attempting to use a client name that is
   * in use by another client, and the router is configured to reject the
   * new session.
   * A client name cannot be used by multiple clients in the same Message
   * VPN.
   *
   * Causes:
   *  * 403 Client Name Already In Use
   */
  CLIENT_NAME_ALREADY_IN_USE:                    9,
  /**
   * The client name chosen has been rejected as invalid by the router.
   *
   * Causes:
   *  * 400 Client Name Parse Error
   */
  CLIENT_NAME_INVALID:                           10,
  /**
   * The client login is not currently possible because a previous
   * instance of same client was being deleted.
   *
   * Causes:
   *  * 503 Subscriber Delete In Progress
   */
  CLIENT_DELETE_IN_PROGRESS:                     11,
  /**
   * The client login is not currently possible because the maximum
   * number of active clients on router has already been reached.
   *
   * Causes:
   *  * 503 Too Many Clients
   *  * 503 Too Many Connections for VPN
   */
  TOO_MANY_CLIENTS:                              12,
  /**
   * The client could not log into the router.
   *
   * Causes:
   *  * 401 error codes
   *  * 404 error codes
   *  * Failed to send a session setup message in the transport.
   */
  LOGIN_FAILURE:                                 13,
  //////////
  // VRID //
  //////////
  /**
   * An attempt was made to connect to the wrong IP address on
   * the router (must use CVRID if configured), or the router CVRID has
   * changed and this was detected on reconnect.
   *
   * Causes:
   *  * 403 Invalid Virtual Router Address
   */
  INVALID_VIRTUAL_ADDRESS:                       14,
  /////////
  // ACL //
  /////////
  /**
   * The client login to the router was denied because the
   * IP address/netmask combination used for the client is designated in the
   * ACL (Access Control List) profile associated with that client.
   *
   * Causes:
   *  * 403 Forbidden
   */
  CLIENT_ACL_DENIED:                             15,
  /**
   * Adding a subscription was denied because it matched a
   * subscription that was defined as denied on the ACL (Access Control List)
   * profile associated with the client.
   *
   * Causes:
   *  * 403 Subscription ACL Denied
   */
  SUBSCRIPTION_ACL_DENIED:                       16,
  /**
   * A message could not be published because its topic matched
   * a topic defined as denied on the ACL (Access Control List) profile
   * associated with the client.
   *
   * Causes:
   *  * 403 Publish ACL Denied
   */
  PUBLISH_ACL_DENIED:                            17,
  ////////////////
  // VALIDATION //
  ////////////////
  /**
   * An API call was made with an out-of-range parameter.
   */
  PARAMETER_OUT_OF_RANGE:                        18,
  /**
   * An API call was made with a parameter combination
   * that is not valid.
   */
  PARAMETER_CONFLICT:                            19,
  /**
   * An API call was made with a parameter of incorrect type.
   */
  PARAMETER_INVALID_TYPE:                        20,
  //////////////////
  // FATAL ERRORS //
  //////////////////
  /**
   *  An API call had an internal error (not an application fault).
   */
  INTERNAL_ERROR:                                21,
  /**
   * An API call failed due to insufficient space in the transport
   * buffer to accept more data. After an insufficient space error, the
   * listeners on the {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}
   * event are notified when it is possible to retry the failed operation.
   */
  INSUFFICIENT_SPACE:                            22,
  /**
   * The message router has rejected the request. All available
   * resources of the requested type are in use.
   *
   * Causes:
   *  * 400 Not Enough Space
   */
  OUT_OF_RESOURCES:                              23,
  /**
   * An API call failed due to a protocol error with the router
   * (not an application fault).
   */
  PROTOCOL_ERROR:                                24,
  /**
   * An API call failed due to a communication error. This typically indicates the
   * transport connection to the message router has been unexpectedly closed.
   */
  COMMUNICATION_ERROR:                           25,
  ////////////////
  // KEEP ALIVE //
  ////////////////
  /**
   * The session keep-alive detected a failed session.
   */
  KEEP_ALIVE_FAILURE:                            26,
  /////////////////////
  // MESSAGE RELATED //
  /////////////////////
  /**
   * An attempt was made to use a topic which is longer
   * than the maximum that is supported.
   */
  // TOPIC_TOO_LARGE: 27,
  /**
   * A send call was made that did not have a topic in a mode
   * where one is required (for example, client mode).
   */
  TOPIC_MISSING:                                 28,
  /**
   *  An attempt was made to send a message with a total
   * size greater than that supported by the protocol. (???)
   */
  //  MAX_TOTAL_MSGSIZE_EXCEEDED: 29,
  /**
   * An attempt was made to send a message with user data larger
   * than the maximum that is supported.
   */
  // USER_DATA_TOO_LARGE: 30,
  /**
   * An attempt was made to use a topic which has a syntax that
   * is not supported.
   *
   * Causes:
   *  * 400 Topic Parse Error
   */
  INVALID_TOPIC_SYNTAX:                          31,
  /**
   * The client attempted to send a message larger than that
   * supported by the router.
   *
   * Causes:
   *  * 400 Document Is Too Large
   *  * 400 Message Too Long
   */
  MESSAGE_TOO_LARGE:                             32,
  /**
   * The router could not parse an XML message.
   *
   * Causes:
   *  * 400 XML Parse Error
   */
  XML_PARSE_ERROR:                               33,
  ///////////////////
  // SUBSCRIPTIONS //
  ///////////////////
  /**
   * The client attempted to add a subscription that already
   * exists. This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Already Exists)
   */
  SUBSCRIPTION_ALREADY_PRESENT:                  34,
  /**
   * The client attempted to remove a subscription which did not exist.
   * This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Not Found)
   */
  SUBSCRIPTION_NOT_FOUND:                        35,
  /**
   * The client attempted to add/remove a subscription that
   * is not valid.
   *
   * Causes:
   *  * 400 Subscription Parse Error
   */
  SUBSCRIPTION_INVALID:                          36,
  /**
   * The router rejected a subscription add or remove request
   * for a reason not separately enumerated.
   */
  SUBSCRIPTION_ERROR_OTHER:                      37,
  /**
   * The client attempted to add a subscription that
   * exceeded the maximum number allowed.
   *
   * Causes:
   *  * 400 Max Num Subscriptions Exceeded
   */
  SUBSCRIPTION_TOO_MANY:                         38,
  /**
   *  The client attempted to add a subscription which already
   * exists but it has different properties.
   *
   * Causes:
   *  * 400 Subscription Attributes Conflict With Existing Subscription
   */
  SUBSCRIPTION_ATTRIBUTES_CONFLICT:              39,
  /**
   * The client attempted to establish a session with No Local
   * enabled and the capability is not supported by the router.
   */
  NO_LOCAL_NOT_SUPPORTED:                        40,
  ////////////////////
  // UNKNOWN ERRORS //
  ////////////////////
  /**
   * The router rejected a control message for another reason
   * not separately enumerated.
   */
  // CONTROL_ERROR_OTHER: 41,
  /**
   * The router rejected a data message for a reason
   * not separately enumerated.
   */
  DATA_ERROR_OTHER:                              42,
  //////////////////////
  // TRANSPORT ERRORS //
  //////////////////////
  /**
   * Failed to create the HTTP connection.
   */
  CREATE_XHR_FAILED:                             43,
  /**
   * Failed to create the transport.
   */
  CONNECTION_ERROR:                              44,
  /**
   * Failed to decode the data.
   */
  DATA_DECODE_ERROR:                             45,
  /**
   * @deprecated
   * The session was inactive for too long.
   *
   * Causes:
   * * 400 Inactivity Timeout
   */
  INACTIVITY_TIMEOUT:                            46,
  /**
   * @deprecated
   * The router does not know this session's identifier.
   *
   * Causes:
   * * 400 Unknown Transport Session Identfier
   */
  UNKNOWN_TRANSPORT_SESSION_ID:                  47,
  /**
   * @deprecated This subcode is not used since 10.0.0.
   * Guaranteed Messages (with a delivery mode other than DIRECT) are not supported.
   */
  AD_MESSAGING_NOT_SUPPORTED:                    48,
  /**
   * @deprecated
   * Creating the WebSocket transport failed.
   */
  CREATE_WEBSOCKET_FAILED:                       49,
  /**
   * An attempt to perform an operation using a VPN that is configured to be
   * STANDBY for replication.
   *
   * Causes:
   * * 403 Replication Is Standby
   */
  REPLICATION_IS_STANDBY:                        50,
  ////////////////////
  // Authentication //
  ////////////////////
  /**
   * Basic authentication is administratively shut down on the
   * router.
   *
   * Causes:
   *  * 403 Basic Authentication is Shutdown
   */
  BASIC_AUTHENTICATION_IS_SHUTDOWN:              51,
  /**
   * Client certificate authentication is administratively
   * shut down on the router.
   *
   * Causes:
   *  * 403 Client Certificate Authentication Is Shutdown
   */
  CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN: 52,
  //////////////////////
  // Guaranteed Messaging //
  //////////////////////
  /**
   * Guaranteed Messaging services are not enabled on the router.
   *
   * Causes:
   *  * 503 Service Unavailable
   */
  GM_UNAVAILABLE:                                100,
  /**
   * The session attempted to connect to a Guaranteed Message Publisher
   * that does not exist on this router.
   * All unacked messages held by the API are renumbered and redelivered. This subCode
   * is handled internally and will not be seen by the application. After successfully
   * renumbereing and redelivering the messages, if any messages are resent, listeners
   * on the @{link solace.SessionEventCode#event:REPUBLISHING_UNACKED_MESSAGES} event are
   * invoked.
   *
   * Causes:
   * * 400 Unknown Flow Name
   * @private
   */
  UNKNOWN_FLOW_NAME:                             111,
  /**
   * Already bound to the Queue or not authorized to bind to the Queue.
   *
   * Causes:
   *  * 400 Already Bound
   */
  ALREADY_BOUND:                                 112,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint with an
   * invalid topic.
   *
   * Causes:
   *  * 400 Invalid Topic Name
   */
  INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT:         113,
  /**
   * An attempt was made to bind to an unknown Queue name (for example, not
   * configured on the router).
   *
   * Causes:
   *  * 503 Unknown Queue
   */
  UNKNOWN_QUEUE_NAME:                            114,
  /**
   * An attempt was made to perform an operation on an unknown Guaranteed Messaging
   * Topic Endpoint name (for example, not configured on router).
   *
   * Causes:
   *  * 503 Unknown Durable Topic Endpoint
   */
  UNKNOWN_TOPIC_ENDPOINT_NAME:                   115,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Queue that has already reached
   * its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for Queue
   */
  MAX_CLIENTS_FOR_QUEUE:                         116,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint that has already
   * reached its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for durable Topic Endpoint
   */
  MAX_CLIENTS_FOR_TE:                            117,
  /**
   * An unexpected unbind response was received for a Guaranteed Messaging Queue or Topic
   * Endpoint (for example, the Queue or Topic Endpoint was deleted from the router).
   */
  UNEXPECTED_UNBIND:                             118,
  /**
   * The specified Guaranteed Messaging Queue was not found when publishing a message.
   *
   * Causes:
   *  * 400 Queue Not Found
   */
  QUEUE_NOT_FOUND:                               119,
  /**
   * Message was not delivered because the Guaranteed Message spool is over its
   * allotted space quota.
   *
   * Causes:
   *  * 503 Spool Over Quota
   */
  SPOOL_OVER_QUOTA:                              120,
  /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging queue.
   *
   * Causes:
   *  * 503 Queue Shutdown
   */
  QUEUE_SHUTDOWN:                                121,
  /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging Topic Endpoint.
   *
   * Causes:
   *  * 503 Durable Topic Endpoint Shutdown
   *  * 503 TE Shutdown
   *  * 503 Endpoint Shutdown
   */
  TOPIC_ENDPOINT_SHUTDOWN:                       122,
  /**
   * An attempt was made to bind to a non-durable Guaranteed Messaging Queue or Topic
   * Endpoint, and the router is out of resources.
   *
   * Causes:
   *  * 503 No More Non-Durable Queue or Topic Endpoint
   */
  NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT:   123,
  /**
   * An attempt was made to create a Queue or Topic Endpoint that already exists.
   * This subcode is only returned if
   * {@link solace.SessionProperties.ignoreProvisionEndpointExists} was not set for the current
   * session.
   *
   * Causes:
   *  * 400 Endpoint Already Exists
   */
  ENDPOINT_ALREADY_EXISTS:                       124,
  /**
   * An attempt was made to delete or create a Queue or Topic Endpoint when the
   * Session does not have authorization for the action. This subcode is also returned when an
   * attempt is made to remove a message from an endpoint when the Session does not have 'consume'
   * authorization, or when an attempt is made to add or remove a Topic subscription from a Queue
   * when the Session does not have 'modify-topic' authorization.
   *
   * Causes:
   *  * 403 Permission Not Allowed
   */
  PERMISSION_NOT_ALLOWED:                        125,
  /**
   * An attempt was made to bind to a Queue or Topic Endpoint with an invalid
   * selector.
   *
   * Causes:
   *  * 400 Invalid Selector
   */
  INVALID_SELECTOR:                              126,
  /**
   * Publishing the message was denied due to exceeding the maximum spooled message
   * count.
   *
   * Causes:
   *  * 503 Max message usage exceeded
   */
  MAX_MESSAGE_USAGE_EXCEEDED:                    127,
  /**
   * An attempt was made to create a dynamic durable endpoint, and it was found to
   * exist with different properties.
   *
   * Causes:
   *  * 400 Endpoint Property Mismatch
   */
  ENDPOINT_PROPERTY_MISMATCH:                    128,
  /**
   * The client attempted to publish an Guaranteed Messaging message to a topic that
   * did not have any guaranteed subscription matches, or only matched a replicated topic.
   *
   * Causes:
   *  * 503 No Subscription Match
   */
  NO_SUBSCRIPTION_MATCH:                         129,
  /**
   * The application attempted to acknowledge a message that arrived via a delivery
   * mode that does not allow acknowledgements.
   */
  MESSAGE_DELIVERY_MODE_MISMATCH:                130,
  /**
   * The message was already acknowledged.
   */
  MESSAGE_ALREADY_ACKNOWLEDGED:                  131,

  /**
   * The API-supplied subscription did not match when attempting to bind to a
   * non-exclusive durable topic endoint.
   *
   * Causes:
   *  * 403 Subscription Does Not Match
   */
  SUBSCRIPTION_DOES_NOT_MATCH:           133,
  /**
   * The API-supplied selector did not match when attempting to bind to a
   * non-exclusive durable topic endpoint.
   *
   * Causes:
   *  * 403 Selector Does Not Match
   */
  SELECTOR_DOES_NOT_MATCH:               134,
  /**
   * The subscriber has provided an incorrectly formatted durable topic endpoint name.
   *
   * Causes:
   *  * 400 Invalid Durable Topic Endpoint Name
   */
  INVALID_DTE_NAME:                      135,
  /**
   * The unsubscribe request was denied by the router because the durable topic endpoint
   * had one or more clients bound.
   *
   * Causes:
   *  * 400 Unsubscribe Not Allowed, Client(s) Bound To DTE
   */
  UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND: 136,
  /**
   * An application callback threw an error back to the API. The reason property describes
   * the error that occurred.
   */
  CALLBACK_ERROR:                        137,
  /**
   * A published message was discarded by the router because it will not be published
   * anywhere based on the NoLocal properties. This can be considered normal.
   *
   * Causes:
   * * 400 Nolocal Discard
   */
  NOLOCAL_DISCARD:                       138,
  /**
   * The operation is delayed because Guaranteed Messaging is not ready on the router.
   *
   * Causes:
   * 507 Ad Not Ready
   */
  GM_NOT_READY:                          140,
  /**
   * The message was rejected because one or more matching endpoints'
   * reject-low-priority-msg-limit was exceeded.
   *
   * Causes:
   * * 503 Low Priority Msg Congestion
   */
  LOW_PRIORITY_MSG_CONGESTION:           141,
  /**
   * The specified endpoint quota was out of range.
   *
   * Causes:
   * 400 Quota Out Of Range
   */
  QUOTA_OUT_OF_RANGE:                    142,
  /**
   * Unable to load the certificate from the TrustStore for a SSL
   * secured session.
   */
  FAILED_LOADING_TRUSTSTORE:             143,
  /**
   * The client failed to load certificate and/or private key files.
   */
  FAILED_LOADING_CERTIFICATE_AND_KEY:    144,
  /**
   * DNS resolution failed for all hostnames.
   */
  UNRESOLVED_HOSTS:                      145,
};

module.exports.ErrorSubcode = Enum.new(ErrorSubcode);


/***/ }),
/* 52 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * The base class for all errors thrown by the API.
 * @hideconstructor
 * @extends {Error}
 *
 * @memberof solace
 */
var SolaceError = (function (Error) {
  function SolaceError(type, message, constructor) {
    Error.call(this, message || '');
    /**
     * Error Message.
     * @name solace.SolaceError#message
     * @type {String}
     */
    this.message = message; // force set
    /**
     * The name of the error.
     * @name solace.SolaceError#name
     * @type {String}
     */
    this.name = type;

    // ES6 error semantics are disappointing
    // Cleaner stack capture for V8-based VMs
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, constructor);
    } else {
      this.stack = new Error().stack;
    }
  }

  if ( Error ) SolaceError.__proto__ = Error;
  SolaceError.prototype = Object.create( Error && Error.prototype );
  SolaceError.prototype.constructor = SolaceError;

  return SolaceError;
}(Error));

module.exports.SolaceError = SolaceError;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * Events on the Consumer FSM
 * @enum {string}
 ********************************************************************************/
var ConsumerFSMEventNames = {
  SESSION_UP:                 'SESSION_UP',
  SESSION_UP_NO_AD:           'SESSION_UP_NO_AD',
  SESSION_DOWN:               'SESSION_DOWN',
  SESSION_DISCONNECT:         'SESSION_DISCONNECT',
  FLOW_FAILED:                'FLOW_FAILED',
  FLOW_UP:                    'FLOW_UP',
  FLOW_ACTIVE_IND:            'FLOW_ACTIVE_IND',
  FLOW_CLOSE:                 'FLOW_CLOSE',
  FLOW_OPEN:                  'FLOW_OPEN',
  FLOW_UNBOUND:               'FLOW_UNBOUND',
  ACK:                        'ACK',
  ACK_TIMEOUT:                'ACK_TIMEOUT',
  BIND_TIMEOUT:               'BIND_TIMEOUT',
  UNBIND_TIMEOUT:             'UNBIND_TIMEOUT',
  CAN_SEND:                   'CAN_SEND',
  TRANSPORT_ERROR:            'TRANSPORT_ERROR',
  DISPOSE:                    'DISPOSE',
  VIRTUALROUTER_NAME_CHANGED: 'VIRTUALROUTER_NAME_CHANGED',
};

module.exports.ConsumerFSMEventNames = Enum.new(ConsumerFSMEventNames);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(15);
var FsmEvent = ref.FsmEvent;

/**
 *
 * ConsumerFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the Subscriber FSM.  This extension provides members to carry information specfic to
 * the Subscriber FSM transitions.
 *
 * @extends FsmEvent
 * @private
 */
var ConsumerFSMEvent = (function (FsmEvent) {
  function ConsumerFSMEvent(spec, details) {
    FsmEvent.call(this, spec);
    this.details = details;
  }

  if ( FsmEvent ) ConsumerFSMEvent.__proto__ = FsmEvent;
  ConsumerFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  ConsumerFSMEvent.prototype.constructor = ConsumerFSMEvent;

  return ConsumerFSMEvent;
}(FsmEvent));

module.exports.ConsumerFSMEvent = ConsumerFSMEvent;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * The publisher currently isn't exposed, and its events are dispatched
 * via the Session. These events are therefore private. They should
 * be moved to MessageConsumerEventName when they are made public.
 * @private
 */
var MessagePublisherEventName = Enum.new({
  ACKNOWLEDGED_MESSAGE:      'MessagePublisherEventName_acknowledgedMessage',
  CONNECT_FAILED_ERROR:      'MessagePublisherEventName_connectFailedError',
  CAN_SEND:                  'MessagePublisherEventName_canSend',
  DISPOSED:                  'MessagePublisherEventName_disposed',
  DOWN:                      'MessagePublisherEventName_down',
  FLOW_NAME_CHANGED:         'MessagePublisherEventName_flowNameChanged',
  GUARANTEED_MESSAGING_DOWN: 'MessagePublisherEventName_guaranteedMessagingDown',
  REJECTED_MESSAGE:          'MessagePublisherEventName_rejectedMessage',
  DISCONNECT_FAILED_ERROR:   'MessagePublisherEventName_disconnectFailedError',
  UP:                        'MessagePublisherEventName_up',
  TRANSPORT_FULL:            'MessagePublisherEventName_transportFull',
});

module.exports.MessagePublisherEventName = MessagePublisherEventName;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * Events on the Publisher FSM
 * @enum {string}
 ********************************************************************************/
var PublisherFSMEventNames = {
  SESSION_UP:       'PublisherSessionUp',
  SESSION_UP_NO_AD: 'PublisherSessionUpNoAD',
  SESSION_DOWN:     'PublisherSessionDown',
  FLOW_FAILED:      'MessagePublisherFailed',
  FLOW_UP:          'MessagePublisherUp',
  FLOW_CLOSE:       'MessagePublisherClose',
  FLOW_UNBOUND:     'MessagePublisherUnbound',
  TRANSPORT_FULL:   'PublisherTransportFull',
  ACK:              'PublisherAck',
  ACK_TIMEOUT:      'PublisherAckTimeout',
  BIND_TIMEOUT:     'PublisherBindTimeout',
  UNBIND_TIMEOUT:   'PublisherUnbindTimeout',
  CAN_SEND:         'PublisherCanSend',
  TRANSPORT_ERROR:  'PublisherTransportError',
  RESEND_COMPLETE:  'PublisherResendComplete',
  DISPOSE:          'PublisherDispose',
};

module.exports.PublisherFSMEventNames = Enum.new(PublisherFSMEventNames);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(15);
var FsmEvent = ref.FsmEvent;

/**
 *
 * PublisherFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends {FsmEvent}
 * @private
 */
var PublisherFSMEvent = (function (FsmEvent) {
  function PublisherFSMEvent(spec, details, smfmessage) {
    FsmEvent.call(this, spec);
    Object.assign(this, details);
    Object.assign(this, smfmessage);
  }

  if ( FsmEvent ) PublisherFSMEvent.__proto__ = FsmEvent;
  PublisherFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  PublisherFSMEvent.prototype.constructor = PublisherFSMEvent;
  PublisherFSMEvent.prototype.getEventText = function getEventText () {
    return this._eventText;
  };

  return PublisherFSMEvent;
}(FsmEvent));

module.exports.PublisherFSMEvent = PublisherFSMEvent;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An attribue of a {@link solace.Message}. Applications receive messages due to subscriptions on
 * topics, or consumers connected to durable objects.  The MessageCacheStatus of such messages is:
 * {@link solace.MessageCacheStatus.LIVE}.
 *
 * Message are also delivered to an application
 * as a result of a cache request (see {@link solace.CacheSession#sendCacheRequest}) which
 * have a MessageCacheStatus that is {@link solace.MessageCacheStatus.CACHED} or
 * {@link solace.MessageCacheStatus.SUSPECT}.
 *
 * The MessageCacheStatus is retrieved with {@link solace.Message#getCacheStatus}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageCacheStatus = {
  /**
   * The message is live.
   * @type {Number}
   */
  LIVE:    0,
  /**
   * The message was retrieveed from a solCache Instance.
   * @type {Number}
   */
  CACHED:  1,
  /**
   * The message was retrieved from a suspect solCache Instance.
   * @type {Number}
   */
  SUSPECT: 2,

};

module.exports.MessageCacheStatus = Enum.new(MessageCacheStatus);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message delivery modes.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageDeliveryModeType = {
  /**
   * This mode provides at-most-once message delivery. Direct messages have
   * the following characteristics:
   *   * They are not retained for clients that are not connected to a Solace Message Router.
   *   * They can be discarded when congestion or system failures are encountered.
   *   * They can be reordered in the event of network topology changes.
   *
   * Direct messages are most appropriate for messaging applications that require very
   * high-rate or very low-latency message transmission. Direct Messaging enables
   * applications to efficiently publish messages to a large number of clients
   * with matching subscriptions.
   */
  DIRECT:         0,
  /**
   * A Persistent delivery mode is used for Guaranteed Messaging, and this delivery mode
   * is most appropriate for applications that require persistent storage of the messages
   * they send or intend to receive. Persistent messages have the following characteristics:
   *
   *  * They cannot be discarded or lost (once they are acknowledged by the Solace Message Router).
   *  * They cannot be reordered in the event of network topology changes.
   *  * They cannot be delivered more than once to a single client (unless the redelivered
   *    message flag is applied).
   *  * When they match subscriptions on durable endpoints, they are retained for a client
   *    when that client is not connected.
   *
   * Persistent messages are most appropriate for applications that require persistent storage
   * of the messages they send or intend to receive.
   */
  PERSISTENT:     1,
  /**
   * This mode is functionally the same as Persistent. It exists to facilitate interaction
   * with JMS applications. In most situations where you want to use Guaranteed Messaging,
   * it is recommended that you use {@link solace.MessageDeliveryModeType.PERSISTENT}.
   */
  NON_PERSISTENT: 2,
};

module.exports.MessageDeliveryModeType = Enum.new(MessageDeliveryModeType);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var MessageDumpStandardProviderLib = __webpack_require__(103);
var ref = __webpack_require__(10);
var SDTFieldType = ref.SDTFieldType;
var SDTMapContainer = ref.SDTMapContainer;
var SDTStreamContainer = ref.SDTStreamContainer;
var SDTUnsupportedValueError = ref.SDTUnsupportedValueError;
var SDTValueErrorSubcode = ref.SDTValueErrorSubcode;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var OperationError = ref$2.OperationError;
var ref$3 = __webpack_require__(40);
var MessageDumpFlag = ref$3.MessageDumpFlag;
var ref$4 = __webpack_require__(4);
var StringBuffer = ref$4.StringBuffer;
var StringUtils = ref$4.StringUtils;

var MessageDumpState = {
  get dumpProviders() {
    var providers = MessageDumpStandardProviderLib.MessageDumpStandardProvider;
    return Object.keys(providers).map(function (k) { return providers[k]; });
  },
};

var MessageDumpUtil = {
  getOutOfRangeValue: function getOutOfRangeValue(rawData) {
    return ("<out of range>\n" + (DebugLib.Debug.formatDumpBytes(rawData)));
  },

  getValue: function getValue(sdtField) {
    var value = null;
    try {
      value = sdtField.getValue();
      return value;
    } catch (e) {
      if (e instanceof SDTUnsupportedValueError) {
        if (e.getSubcode() === SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE) {
          return this.getOutOfRangeValue(e.getSourceData());
        }
      } else if (e instanceof OperationError && e.subcode === ErrorSubcode.PARAMETER_INVALID_TYPE) {
        return '<invalid type>';
      }
      throw e;
    }
  },

  printMap: function printMap(sdtMap, indent) {
    var this$1 = this;

    if (Check.nothing(sdtMap) || !(sdtMap instanceof SDTMapContainer)) {
      return null;
    }
    var lines = [];
    var strIndent = StringUtils.padRight('', indent, ' ');
    var keys = sdtMap.getKeys().sort();
    keys.forEach(function (key) {
      var sdtFieldValue = sdtMap.getField(key);
      var type = sdtFieldValue.getType();
      var value = this$1.getValue(sdtFieldValue);
      var strValue;
      switch (type) {
        case SDTFieldType.MAP:
          strValue = "\n" + (this$1.printMap(value, indent + 2));
          break;
        case SDTFieldType.STREAM:
          strValue = "\n" + (this$1.printStream(value, indent + 2));
          break;
        case SDTFieldType.BYTEARRAY:
          strValue = DebugLib.Debug.formatDumpBytes(value, false, 0);
          if (strValue !== null && strValue.substr(-1) === '\n') {
            strValue = strValue.substring(0, strValue.length - 1);
          }
          break;
        default:
          strValue = (value !== null) ? value.toString() : null;
      }
      lines.push((strIndent + "Key '" + key + "' (" + (SDTFieldType.nameOf(type)) + "): " + strValue));
    });
    return lines.join('\n');
  },

  printStream: function printStream(sdtStream, indent) {
    var this$1 = this;

    if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
      return null;
    }
    sdtStream.rewind();
    var lines = [];
    var strIndent = StringUtils.padRight('', indent, ' ');
    while (sdtStream.hasNext()) {
      var sdtFieldValue = sdtStream.getNext();
      var type = sdtFieldValue.getType();
      var value = this$1.getValue(sdtFieldValue);

      var strValue = (void 0);
      switch (type) {
        case SDTFieldType.MAP:
          strValue = "\n" + (this$1.printMap(value, indent + 2));
          break;
        case SDTFieldType.STREAM:
          strValue = "\n" + (this$1.printStream(value, indent + 2));
          break;
        case SDTFieldType.BYTEARRAY:
          strValue = DebugLib.Debug.formatDumpBytes(value, false, 0);
          if (strValue !== null && strValue.substr(-1) === '\n') {
            strValue = strValue.substring(0, strValue.length - 1);
          }
          break;
        case SDTFieldType.DESTINATION:
          strValue = value.toString();
          break;
        default:
          strValue = (value !== null) ? value.toString() : null;
      }
      lines.push((strIndent + "(" + (SDTFieldType.nameOf(type)) + "): " + strValue));
    }
    sdtStream.rewind();
    return lines.join('\n');
  },

  countItems: function countItems(sdtStream) {
    if (Check.nothing(sdtStream) || (!(sdtStream instanceof SDTStreamContainer))) {
      return 0;
    }
    sdtStream.rewind();
    var count = 0;
    while (sdtStream.hasNext()) {
      sdtStream.getNext();
      count++;
    }
    sdtStream.rewind();
    return count;
  },

  formatDate: function formatDate(timeStamp) {
    return new Date(timeStamp).toString();
  },

  dump: function dump(message, flags, separator, colPadding) {
    var sb = new StringBuffer();
    var theSeparator = '\n';
    var needSeparator = false;
    var theColPadding = 40;
    if (separator !== undefined && separator !== null && typeof separator === 'string') {
      theSeparator = separator;
    }
    if (colPadding !== undefined && colPadding !== null && typeof colPadding === 'number') {
      theColPadding = colPadding;
    }

    MessageDumpState.dumpProviders.forEach(function (provider, index) {
      var ref = provider(message, flags);
      var key = ref[0];
      var isPresent = ref[1];
      var value = ref[2];
      var detailValue = ref[3];
      if (!isPresent) {
        return;
      }
      if (needSeparator) {
        sb.append(theSeparator);
      }

      if (value === null || value.length === 0) {
        // If we have no VALUE field, this is probably a boolean flag
        // and we just end up displaying the key and a newline.
        sb.append(key);
      } else {
        sb.append(StringUtils.padRight((key + ":"), theColPadding, ' '));
        sb.append(value);
      }

      if (detailValue !== null && (flags & MessageDumpFlag.MSGDUMP_FULL)) {
        sb.append('\n');
        if (detailValue.indexOf('  ') !== 0) {
          sb.append('  ');
        }
        sb.append(detailValue);
        if (detailValue.substr(-1) !== '\n' && index < (MessageDumpState.dumpProviders.length - 1)) {
          sb.append('\n');
        }
      }
      needSeparator = true;
    });
    return sb.toString();
  },
};

module.exports.MessageDumpUtil = MessageDumpUtil;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of user Class of Service (COS) levels. The COS is set
 * on a Message with {@link solace.Message#setUserCos}
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.  {@link solace.MessageUserCosType.COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageUserCosType = {
  /**
   * Direct Messages: Lowest priority, use Solace Message Router client D-1 queues for delivery.
   *
   * Guaranteed Messages: Messages can be rejected if the message would cause any
   * queue or topic-endpoint to exceed it's configured <i>low-prioriity-max-msg-count</i>.
   * @type {Number}
   */
  COS1: 0,
  /**
   * Direct Messages: Medium priority, use Solace Message Router client D-2 queues for delivery.
   *
   * Guaranteed Messages: N/A (same as COS3)
   * @type {Number}
   */
  COS2: 1,
  /**
   * Direct Messages: Highest priority, use Solace Message Router client D-3 queues for delivery.
   *
   * Guaranteed Messages: Messages are not rejected for exceeding <i>low-priority-max-msg-count</i>.
   * Messages may still be rejected for other reasons such as Queue 'Spool Over Quota'.
   * @type {Number}
   */
  COS3: 2,
};

module.exports.MessageUserCosType = Enum.new(MessageUserCosType);


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents the possible endpoint access types. The corresponding endpoint property is
 * {@link solace.QueueProperties#accessType}.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueAccessType = {
  /**
   * @description An exclusive endpoint. The first client to bind
   * receives the stored messages on the Endpoint.
   * @type {String}
   */
  EXCLUSIVE:    'EXCLUSIVE',
  /**
   * @description A non-exclusive (shared) Queue. Each client to bind
   * receives messages in a round robin fashion.
   * @type {String}
   */
  NONEXCLUSIVE: 'NONEXCLUSIVE',
};

module.exports.QueueAccessType = Enum.new(QueueAccessType);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumerates the behavior options when a message cannot be added to an endpoint
 * (for example, the maximum quota {@link solace.QueueProperties#quotaMB} was exceeded).
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueDiscardBehavior = {
  /**
   * @description Send the publisher a message reject notification.
   * @type {String}
   */
  NOTIFY_SENDER_ON:  'NOTIFY_SENDER_ON',
  /**
   * @description Discard the message and acknowledge it.
   * @type {String}
   */
  NOTIFY_SENDER_OFF: 'NOTIFY_SENDER_OFF',
};

module.exports.QueueDiscardBehavior = Enum.new(QueueDiscardBehavior);


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents the permissions applicable to a queue.
 *
 * The corresponding endpoint property is
 * {@link solace.QueueProperties#permissions}.
 *
 * The access controls:
 *  * the permissions for all other users of the queue, this only applies to
 *  non-durable queues {@link solace.QueueProperties#permissions};
 *  * for the current Message Consumer  on a queue or endpoint,
 *    {@link solace.MessageConsumer.permissions}
 *
 * For example, creating a temporary topic endpoint with MODIFY_TOPIC will allow
 * other users to modify the topic subscribed to that endpoint.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueuePermissions = {
  /**
   * @description No client other than the queue's owner may access the endpoint.
   */
  NONE:         'NONE',
  /**
   * @description Client may read messages but not consume them.
   * @type {String}
   */
  READ_ONLY:    'READ_ONLY',
  /**
   * @description  Client may read and consume messages.
   * @type {String}
   */
  CONSUME:      'CONSUME',
  /**
   * @description Client may read and consume messages, and modify topic(s) associated with the
   * queue.
   * @type {String}
   */
  MODIFY_TOPIC: 'MODIFY_TOPIC',
  /**
   * @description Client may read and consume messages, modify topic(s) associated with the
   * queue, and delete the queue.
   * @type {String}
   */
  DELETE:       'DELETE',
};

module.exports.QueuePermissions = Enum.new(QueuePermissions);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Specifies the type of remote resource to which an
 * {@link solace.AbstractQueueDescriptor} refers.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueType = {
  /**
   * @description The queue descriptor refers to a queue endpoint.
   * @type {String}
   */
  QUEUE:          'QUEUE',
  /**
   * @description The queue descriptor refers to a topic endpoint.
   * @type {String}
   */
  TOPIC_ENDPOINT: 'TOPIC_ENDPOINT',
};

module.exports.QueueType = Enum.new(QueueType);


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(107);
var EncodeHeader = ref$1.EncodeHeader;
var ref$2 = __webpack_require__(201);
var EncodeInteger = ref$2.EncodeInteger;
var ref$3 = __webpack_require__(202);
var EncodeMap = ref$3.EncodeMap;
var ref$4 = __webpack_require__(203);
var EncodeStream = ref$4.EncodeStream;
var ref$5 = __webpack_require__(67);
var IEEE754LIB = ref$5.IEEE754LIB;
var ref$6 = __webpack_require__(30);
var SDTDataTypes = ref$6.SDTDataTypes;
var ref$7 = __webpack_require__(70);
var SDTDestType = ref$7.SDTDestType;
var ref$8 = __webpack_require__(12);
var SDTField = ref$8.SDTField;
var ref$9 = __webpack_require__(11);
var SDTFieldType = ref$9.SDTFieldType;
var ref$10 = __webpack_require__(4);
var StringUtils = ref$10.StringUtils;

var encodeHeader = EncodeHeader.encodeHeader;
var int48ToStr = EncodeInteger.int48ToStr;
var encodeMap = EncodeMap.encodeMap;
var encodeStream = EncodeStream.encodeStream;

var nullTerminate = StringUtils.nullTerminate;

var C_2_48 = Math.pow(2, 48);

// UCS-2 --> UTF-8 conversion
function strencode(data) {
  return unescape(encodeURIComponent(data));
}

// Encode an SDTField into provided buffer buf
function encodeSingleElementToBuf(sdtfield, buf) {
  if (!(sdtfield instanceof SDTField)) {
    return false;
  }
  // we write the header at the end, once we know the size
  var value = sdtfield.getValue();
  var fieldVal = null;
  var tag = 0; // SMF TAG
  switch (sdtfield.getType()) {
    case SDTFieldType.BOOL:
      tag = SDTDataTypes.Boolean;
      fieldVal = Convert.int8ToStr(value ? 1 : 0);
      break;
    case SDTFieldType.UINT8:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int8ToStr(value);
      break;
    case SDTFieldType.INT8:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int8ToStr(value);
      break;
    case SDTFieldType.UINT16:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int16ToStr(value);
      break;
    case SDTFieldType.INT16:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int16ToStr(value);
      break;
    case SDTFieldType.UINT32:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int32ToStr(value);
      break;
    case SDTFieldType.INT32:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int32ToStr(value);
      break;
    case SDTFieldType.UINT64:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
      break;
    case SDTFieldType.INT64:
      tag = SDTDataTypes.Integer;
      if (value >= 0) {
        fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
      } else {
        fieldVal = (String.fromCharCode(0xFF) +
                    String.fromCharCode(0xFF) +
                    int48ToStr(C_2_48 + value));
      }
      break;
    case SDTFieldType.WCHAR:
      tag = SDTDataTypes.Char;
      fieldVal = Convert.int16ToStr(value.charCodeAt(0));
      break;
    case SDTFieldType.STRING:
      tag = SDTDataTypes.String;
      fieldVal = nullTerminate(strencode(value));
      break;
    case SDTFieldType.BYTEARRAY:
      tag = SDTDataTypes.ByteArray;
      fieldVal = value;
      break;
    case SDTFieldType.FLOATTYPE:
      tag = SDTDataTypes.Float;
      fieldVal = IEEE754LIB.toIEEE754Single(value);
      break;
    case SDTFieldType.DOUBLETYPE:
      tag = SDTDataTypes.Float;
      fieldVal = IEEE754LIB.toIEEE754Double(value);
      break;
    case SDTFieldType.MAP:
      tag = SDTDataTypes.Map;
      fieldVal = encodeMap(value);
      break;
    case SDTFieldType.STREAM:
      tag = SDTDataTypes.Stream;
      fieldVal = encodeStream(value);
      break;
    case SDTFieldType.DESTINATION:
      tag = SDTDataTypes.Destination;
      if (value instanceof DestinationLib.Destination) {
        fieldVal = Convert.int8ToStr(SDTDestType[value.getType()])
          + value.getBytes();
      }
      break;
    case SDTFieldType.NULLTYPE:
      tag = SDTDataTypes.Null;
      fieldVal = '';
      break;
    case SDTFieldType.UNKNOWN:
      fieldVal = null;
      break;
    default:
  }
  if (fieldVal !== null) {
    var hdr = encodeHeader(tag, fieldVal.length);
    buf.push(hdr);
    buf.push(fieldVal);
    return true;
  }

  return false;
}

function encodeSingleElement(sdtfield) {
  var buf = [];
  encodeSingleElementToBuf(sdtfield, buf);
  return buf.join('');
}

var EncodeSingleElement = {
  encodeSingleElement: encodeSingleElement,
  encodeSingleElementToBuf: encodeSingleElementToBuf,
};

module.exports.EncodeSingleElement = EncodeSingleElement;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

var IEEE754LIB = {
  /**
   * @preserve
   * The MIT License
   *
   * Copyright (c) 2010 Alan Gutierrez
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  toIEEE754: function toIEEE754(vIn, ebits, fbits) {
    var v = vIn;
    var bias = (1 << (ebits - 1)) - 1;

    // Compute sign, exponent, fraction
    var s;
    var e;
    var f;
    if (isNaN(v)) {
      e = (1 << bias) - 1;
      f = 1;
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << bias) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = Math.abs(v);

      if (v >= Math.pow(2, 1 - bias)) {
        var ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
        e = ln + bias;
        f = (v * Math.pow(2, fbits - ln)) - Math.pow(2, fbits);
      } else {
        e = 0;
        f = v / Math.pow(2, 1 - bias - fbits);
      }
    }

    // Pack sign, exponent, fraction
    var bits = [];
    for (var i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = Math.floor(f / 2);
    }
    for (var i$1 = ebits; i$1; i$1 -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    var str = bits.join('');

    // Bits to bytes
    var bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  },

  fromIEEE754: function fromIEEE754(bytes, ebits, fbits) {
    // Bytes to bits
    var bits = [];
    for (var i = bytes.length; i; i -= 1) {
      var byteI = bytes[i - 1];
      for (var j = 8; j; j -= 1) {
        bits.push(byteI % 2 ? 1 : 0);
        byteI >>= 1;
      }
    }
    bits.reverse();
    var str = bits.join('');

    // Unpack sign, exponent, fraction
    var bias = (1 << (ebits - 1)) - 1;
    var s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    var e = parseInt(str.substring(1, 1 + ebits), 2);
    var f = parseInt(str.substring(1 + ebits), 2);

    // Produce number
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    }
    if (e > 0) {
      return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
    }
    if (f !== 0) {
      return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
    }
    return 0;
  },
  strToByteArr: function strToByteArr(str) {
    var bytes = [];
    for (var i = 0; i < str.length; i++) { bytes.push(str.charCodeAt(i) & 0xFF); }
    return bytes;
  },
  byteArrToStr: function byteArrToStr(bytes) {
    var str = [];
    for (var i = 0; i < bytes.length; i++) { str.push(String.fromCharCode(bytes[i] & 0xFF)); }
    return str.join('');
  },
  fromIEEE754Double: function fromIEEE754Double(b) { return this.fromIEEE754(this.strToByteArr(b), 11, 52); },
  toIEEE754Double: function toIEEE754Double(v) { return this.byteArrToStr(this.toIEEE754(v, 11, 52)); },
  fromIEEE754Single: function fromIEEE754Single(b) { return this.fromIEEE754(this.strToByteArr(b), 8, 23); },
  toIEEE754Single: function toIEEE754Single(v) { return this.byteArrToStr(this.toIEEE754(v, 8, 23)); },
};

module.exports.IEEE754LIB = IEEE754LIB;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(108);
var ParseInteger = ref$1.ParseInteger;

var autoDecodeVarLengthNumber = ParseInteger.autoDecodeVarLengthNumber;

var ParseFieldHeader = {
  // Parse the header part of an SDT field.
  // Returns [TYPE, DECLARED_LENGTH, VALUE_DATA_LENGTH, CONSUMED_BYTES]
  parseFieldHeader: function parseFieldHeader(data, offset) {
    var pos = offset;
    var onebyte = Convert.strToInt8(data.substr(pos, 1));
    var elemType = (onebyte & 0xFC) >> 2;
    var lenBytes = (onebyte & 0x03) + 1;
    pos++;
    var elemLen = autoDecodeVarLengthNumber(data.substr(pos, lenBytes));
    pos += lenBytes;
    var elemValLen = elemLen - (1 + lenBytes);
    return [elemType, elemLen, elemValLen, pos - offset];
  },
};

module.exports.ParseFieldHeader = ParseFieldHeader;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(204);
var ParseDestination = ref$2.ParseDestination;
var ref$3 = __webpack_require__(68);
var ParseFieldHeader = ref$3.ParseFieldHeader;
var ref$4 = __webpack_require__(205);
var ParseFloat = ref$4.ParseFloat;
var ref$5 = __webpack_require__(108);
var ParseInteger = ref$5.ParseInteger;
var ref$6 = __webpack_require__(206);
var ParseMap = ref$6.ParseMap;
var ref$7 = __webpack_require__(207);
var ParseStream = ref$7.ParseStream;
var ref$8 = __webpack_require__(30);
var SDTDataTypes = ref$8.SDTDataTypes;
var ref$9 = __webpack_require__(12);
var SDTField = ref$9.SDTField;
var ref$10 = __webpack_require__(11);
var SDTFieldType = ref$10.SDTFieldType;

var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var utf8ToUcs2 = Convert.utf8ToUcs2;
var parseFieldHeader = ParseFieldHeader.parseFieldHeader;
var parseFloatField = ParseFloat.parseFloatField;
var parseIntegerField = ParseInteger.parseIntegerField;
var parseMapAt = ParseMap.parseMapAt;
var parseStreamAt = ParseStream.parseStreamAt;
var parseDestination = ParseDestination.parseDestination;

var ParseSingleElement = {
  // Parse single SDT element, returns SDTField
  parseSingleElement: function parseSingleElement(data, offset) {
    var fieldHeader = parseFieldHeader(data, offset);
    if (!fieldHeader) {
      LOG_DEBUG(("parseSingleElement return false, fieldHeader=" + fieldHeader));
      return null;
    }

    var pos = offset + fieldHeader[3];

    // For use inside switch
    var elemValLen = fieldHeader[2];

    switch (fieldHeader[0]) {
      case SDTDataTypes.Null:
        return SDTField.create(SDTFieldType.NULLTYPE, null);
      case SDTDataTypes.Boolean:
        return SDTField.create(SDTFieldType.BOOL, strToInt8(data.substr(pos, 1)) !== 0);
      case SDTDataTypes.Integer:
        return parseIntegerField(true, data.substr(pos, elemValLen));
      case SDTDataTypes.UnsignedInteger:
        return parseIntegerField(false, data.substr(pos, elemValLen));
      case SDTDataTypes.Float:
        return parseFloatField(data.substr(pos, elemValLen));
      case SDTDataTypes.Char:
        return SDTField.create(SDTFieldType.WCHAR,
                               String.fromCharCode(strToInt16(data.substr(pos, 2))));
      case SDTDataTypes.ByteArray:
        return SDTField.create(SDTFieldType.BYTEARRAY, data.substr(pos, elemValLen));
      case SDTDataTypes.String:
        // strip last byte (null-terminator)
        return SDTField.create(SDTFieldType.STRING, utf8ToUcs2(data.substr(pos, elemValLen - 1)));
      case SDTDataTypes.Destination:
        return parseDestination(data.substr(pos, elemValLen));
      case SDTDataTypes.SMFMessage:
        return SDTField.create(SDTFieldType.SMF_MESSAGE, data.substr(pos, elemValLen));
      case SDTDataTypes.Map:
        return parseMapAt(data, pos, elemValLen);
      case SDTDataTypes.Stream:
        return parseStreamAt(data, pos, elemValLen);
      default:
        return SDTField.create(SDTFieldType.UNKNOWN, data.substr(pos, elemValLen));

    }
  },
};

module.exports.ParseSingleElement = ParseSingleElement;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(5);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(0);
var Enum = ref$1.Enum;

/**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 * @private
 */
var SDTDestType = {};
SDTDestType[DestinationType.TOPIC] = 0x00;
SDTDestType[DestinationType.QUEUE] = 0x01;
SDTDestType[DestinationType.TEMPORARY_QUEUE] = 0x01;

module.exports.SDTDestType = Enum.new(SDTDestType);


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents authentication schemes that can be used. The corresponding session
 * property is {@link solace.SessionProperties#authenticationScheme}.
 *
 * @readonly
 * @enum {String}
 * @memberof solace
 * @namespace
 */
var AuthenticationScheme = {
  /**
   * @description Username/Password based authentication scheme.
   * @type {String}
   */
  BASIC:                       'AuthenticationScheme_basic',
  /**
   * @name solace.AuthenticationScheme.CLIENT_CERTIFICATE
   * @default AuthenticationScheme_clientCertificate
   * @description Client-side certificate based authentication scheme.
   * @see {@link solace.SessionProperties#sslPfx}
   * @see {@link solace.SessionProperties#sslPfxPassword}
   * @see {@link solace.SessionProperties#sslPrivateKey}
   * @see {@link solace.SessionProperties#sslPrivateKeyPassword}
   * @see {@link solace.SessionProperties#sslCertificate}
   * @type {String}
   * @target node
   */
  /**
   * @description Client-side certificate based authentication scheme.  The certificate and
   *   private key are provided by the browser.
   * @type {String}
   * @target browser
   */
  CLIENT_CERTIFICATE:          'AuthenticationScheme_clientCertificate',
  /**
   * @deprecated Use {@link solace.AuthenticationScheme.BASIC} instead.
   * @type {String}
   */
  AUTHENTICATION_SCHEME_BASIC: 'AuthenticationScheme_basic',

  /**
   * @deprecated Use {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} instead.
   * @type {String}
   */
  AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: 'AuthenticationScheme_clientCertificate',
};

module.exports.AuthenticationScheme = Enum.new(AuthenticationScheme);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionEventName = {
  CONNECT:                       'SessionConnect',
  DISCONNECT:                    'SessionDisconnect',
  DISPOSE:                       'SessionDispose',
  CONNECT_TIMEOUT:               'SessionConnectTimeout',
  CONNECT_WAIT_TIMEOUT:          'SessionConnectWaitTimeout',
  DOWNGRADE_TIMEOUT:             'SessionDowngradeTimeout',
  TRANSPORT_UP:                  'SessionTransportUp',
  TRANSPORT_DESTROYED:           'SessionTransportDestroyed',
  TRANSPORT_CAN_ACCEPT_DATA:     'SessionTransportCanAcceptData',
  TRANSPORT_PARSE_ERROR:         'SessionTransportParseError',
  TRANSPORT_PROTOCOL_SMP:        'SessionSMPMessage',
  TRANSPORT_PROTOCOL_CLIENTCTRL: 'SessionClientCtrlMessage',
  EXCEPTION:                     'SessionException',
  SUBSCRIBE_TIMEOUT:             'SessionSubscribeTimeout',
  CREATE_SUBSCRIBER:             'SessionCreateSubscriber',
  FLOW_UP:                       'SessionFlowUp',
  FLOW_FAILED:                   'SessionFlowFailed',
  SEND_ERROR:                    'SessionSendError',
  FLOWS_DISCONNECTED:            'SessionFlowsDisconnected',
  TRANSPORT_FLUSHED:             'SessionTransportFlushed',
  DNS_RESOLUTION_COMPLETE:       'SessionDNSResolutionComplete',
};

module.exports.SessionEventName = Enum.new(SessionEventName);


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var RequestError = ref.RequestError;
var RequestEventCode = ref.RequestEventCode;
var ref$1 = __webpack_require__(44);
var SessionEventCode = ref$1.SessionEventCode;

function buildType(Superclass) {
  /**
   * @classdesc
   * Represents a session event; events are passed to the application-provided
   * event handling callback provided when creating the session.
   * @memberof solace
   */
  var SessionEvent = (function (Superclass) {
    function SessionEvent(superclassArgs,
                sessionEventCode,
                infoStr,
                responseCode,
                errorSubcode,
                correlationKey,
                reason) {
      if ( responseCode === void 0 ) responseCode = undefined;
      if ( errorSubcode === void 0 ) errorSubcode = 0;
      if ( correlationKey === void 0 ) correlationKey = undefined;
      if ( reason === void 0 ) reason = undefined;

      Superclass.apply(this, superclassArgs);
      this._sessionEventCode = sessionEventCode;
      this._infoStr = infoStr;
      this._responseCode = responseCode;
      this._errorSubcode = errorSubcode;
      this._correlationKey = correlationKey; // optional
      this._reason = reason; // optional
    }

    if ( Superclass ) SessionEvent.__proto__ = Superclass;
    SessionEvent.prototype = Object.create( Superclass && Superclass.prototype );
    SessionEvent.prototype.constructor = SessionEvent;

    var prototypeAccessors = { sessionEventCode: {},infoStr: {},responseCode: {},errorSubcode: {},errorSubCode: {},correlationKey: {},reason: {} };

    /**
     * @type {solace.SessionEventCode}
     * @description Further qualifies the session event.
     */
    prototypeAccessors.sessionEventCode.get = function () {
      return this._sessionEventCode;
    };

    /**
     * @type {String}
     * @description if applicable, an information string returned by the Solace Message Router.
     */
    prototypeAccessors.infoStr.get = function () {
      return this._infoStr;
    };

    /**
     * @type {?Number}
     * @description if applicable, a response code returned by the Solace Message Router.
     */
    prototypeAccessors.responseCode.get = function () {
      return this._responseCode;
    };

    /**
     * @type {?solace.ErrorSubcode}
     * @description if applicable, an error subcode. Defined in {@link solace.ErrorSubcode}
     */
    prototypeAccessors.errorSubcode.get = function () {
      // eslint-disable-next-line quote-property
      return this.subcode || this._errorSubcode;
    };

    /**
     * @deprecated Use {@link solace.SessionEvent#errorSubcode} instead.
     * @readonly
     */
    prototypeAccessors.errorSubCode.get = function () {
      return this.errorSubcode;
    };

    /**
     * @type {?Object}
     * @description A user-specified object
     * made available in the response or confirmation event by including it as a
     * parameter in the orignal API call.  If the user did not specify a
     * correlationKey, it will be <code>null</code>.
     */
    prototypeAccessors.correlationKey.get = function () {
      return this._correlationKey;
    };

    /**
     * @type {?String}
     * @description Additional information if it is applicable.
     */
    prototypeAccessors.reason.get = function () {
      return this._reason;
    };
    /**
     * @param {Object} value The reason info object
     * @internal
     */
    prototypeAccessors.reason.set = function (value) {
      this._reason = value;
    };

    SessionEvent.prototype[util.inspect.custom] = function () {
      return Object.assign(Superclass.prototype[util.inspect.custom] || {}, {
        'sessionEventCode': SessionEventCode.describe(this.sessionEventCode),
        'infoStr':          this.infoStr,
        'responseCode':     this.responseCode,
        'errorSubcode':     ErrorSubcode.describe(this.errorSubcode),
        'correlationKey':   this.correlationKey ? this.correlationKey.toString() : null,
      });
    };

    SessionEvent.prototype.toString = function toString () {
      return util.inspect(this);
    };

    Object.defineProperties( SessionEvent.prototype, prototypeAccessors );

    return SessionEvent;
  }(Superclass));

  return SessionEvent;
}

var SUPERCLASS_FOR_SESSION_EVENT = {};
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.CONNECT_FAILED_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.DOWN_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.PROPERTY_UPDATE_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.REJECTED_MESSAGE_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.SUBSCRIPTION_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[RequestEventCode.REQUEST_ABORTED] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[RequestEventCode.REQUEST_TIMEOUT] = RequestError;

var SUPERCLASS_ARGS = new Map()
  .set(Object, function () { return []; })
  .set(OperationError, function (sec, infoStr, rc, subcode, ck, reason) { return [infoStr, subcode, reason]; })
  .set(RequestError, function (sec, infoStr, rc, subcode, ck, reason) { return [infoStr, sec, ck, reason]; });

var TYPE_CACHE = new Map();

function build(sessionEventCode,
               infoStr,
               responseCode,
               errorSubcode,
               correlationKey,
               reason) {
  if ( responseCode === void 0 ) responseCode = undefined;
  if ( errorSubcode === void 0 ) errorSubcode = 0;
  if ( correlationKey === void 0 ) correlationKey = undefined;
  if ( reason === void 0 ) reason = undefined;

  var Superclass = SUPERCLASS_FOR_SESSION_EVENT[sessionEventCode] || Object;
  var SessionEvent = (function () {
    var result = TYPE_CACHE.get(Superclass);
    if (result) { return result; }
    result = buildType(Superclass);
    TYPE_CACHE.set(Superclass, result);
    return result;
  })();
  var superclassArgsBuilder = (SUPERCLASS_ARGS.get(Superclass) || (function () { return []; }));
  var superclassArgs = superclassArgsBuilder(sessionEventCode,
                                               infoStr,
                                               responseCode,
                                               errorSubcode,
                                               correlationKey,
                                               reason);
  return new SessionEvent(superclassArgs,
                          sessionEventCode,
                          infoStr,
                          responseCode,
                          errorSubcode,
                          correlationKey,
                          reason);
}

// Expose a type
var SessionEvent = buildType(Object);
SessionEvent.build = build;

module.exports.SessionEvent = SessionEvent;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var NodeSslConstants = __webpack_require__(267);
var PublisherLib = __webpack_require__(29);
var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(71);
var AuthenticationScheme = ref$1.AuthenticationScheme;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;

function makeDefaults() {
  // Defer binding. Publisher constructor may rely on profile.
  var MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
  return {
    _vpnNameInUse:        '',
    _virtualRouterName:   '',
    _p2pInboxInUse:       '',
    _p2pInboxBase:        '',
    _userIdentification:  '',
    _tpProtocolInUse:     null,
    _tpContentType:       'text/plain',
    _publisherProperties: new MessagePublisherProperties(),
  };
}

var DEFAULT_CIPHER_SUITES =  true ? [
  'ECDHE-RSA-AES256-GCM-SHA384',
  'ECDHE-RSA-AES256-SHA384',
  'ECDHE-RSA-AES256-SHA',
  'AES256-GCM-SHA384',
  'AES256-SHA256',
  'AES256-SHA',
  'ECDHE-RSA-DES-CBC3-SHA',
  'DES-CBC3-SHA',
  'ECDHE-RSA-AES128-GCM-SHA256',
  'ECDHE-RSA-AES128-SHA256',
  'ECDHE-RSA-AES128-SHA',
  'AES128-GCM-SHA256',
  'AES128-SHA256',
  'AES128-SHA' ].join(',') : null;

var SUPPORTED_CIPHER_SUITES =  true ? [
  'AES128-GCM-SHA256',
  'AES128-SHA',
  'AES128-SHA256',
  'AES256-GCM-SHA384',
  'AES256-SHA',
  'AES256-SHA256',
  'DES-CBC3-SHA',
  'ECDHE-RSA-AES128-GCM-SHA256',
  'ECDHE-RSA-AES128-SHA',
  'ECDHE-RSA-AES128-SHA256',
  'ECDHE-RSA-AES256-GCM-SHA384',
  'ECDHE-RSA-AES256-SHA',
  'ECDHE-RSA-AES256-SHA384',
  'ECDHE-RSA-DES-CBC3-SHA' ] : null;

var SUPPORTED_SSL_PROTOCOLS =  true
? [
  'tlsv1',
  'tlsv1.1',
  'tlsv1.2' ]
: null;

/**
 * @lends SessionProperties
 *
 */
var SessionPropertiesBrowser = (function (APIProperties) {
  function SessionPropertiesBrowser () {
    APIProperties.apply(this, arguments);
  }

  if ( APIProperties ) SessionPropertiesBrowser.__proto__ = APIProperties;
  SessionPropertiesBrowser.prototype = Object.create( APIProperties && APIProperties.prototype );
  SessionPropertiesBrowser.prototype.constructor = SessionPropertiesBrowser;

  var prototypeAccessors = { transportProtocol: {},transportDowngradeTimeoutInMsecs: {},webTransportProtocolList: {},bufferedAmountQueryIntervalInMsecs: {},transportProtocolInUse: {},webTransportProtocolInUse: {},transportContentType: {} };

  prototypeAccessors.transportProtocol.get = function () {
    return Check.nothing(this._tpProtocol) ? null : this._tpProtocol;
  };
  prototypeAccessors.transportProtocol.set = function (newValue) {
    this._tpProtocol = newValue;
  };


  /**
   * @name solace.SessionProperties#transportDowngradeTimeoutInMsecs
   * @type {Number}
   * @description The timeout, in milliseconds, that must elapse before the session will abandon a
   * connection attempt with the current transport protocol if no response is received, and begin
   * a new connection attempt with a downgraded transport protocol. If no remaining downgrades
   * exist, the session will continue the current connection attempt until the connection timeout
   * expires. Note that the WS_BINARY transport will also attempt a downgrade if the underlying
   * WebSocket fails to connect before this period elapses.
   *  * The valid range is > 0.
   * @default 3000
   * @target browser
   */
  prototypeAccessors.transportDowngradeTimeoutInMsecs.get = function () {
    return Check.nothing(this._tpDowngradeTimeout) ? 3000 : this._tpDowngradeTimeout;
  };
  prototypeAccessors.transportDowngradeTimeoutInMsecs.set = function (newValue) {
    this._tpDowngradeTimeout = newValue;
  };

  /**
   * @name solace.SessionProperties#webTransportProtocolList
   * @type {Array.<solace.TransportProtocol>}
   * @description The user provided web transport protocol list indicating the intial protocol
   * to be used by the session for its connection attempt, and the protocols to try
   * subsequently if the attempt fails.
   *  * Mutually exclusive to property transportProtocol
   * @default null
   * @target browser
   */
  prototypeAccessors.webTransportProtocolList.get = function () {
    return Check.nothing(this._transportProtocolList)
             ? null
             : this._transportProtocolList;
  };
  prototypeAccessors.webTransportProtocolList.set = function (newValue) {
    this._transportProtocolList = newValue;
  };

  /**
   * @private
   * @name SessionProperties#bufferedAmountQueryIntervalInMsecs
   * @type {Number}
   * @description When WebSocket transport protocol is used, SolClient uses this property
   * and {@link solace.SessionProperties.maxWebPayload} to throttle the publishing rate in order to
   * avoid network saturation.
   *  * The valid range is >=4.
   * @default 100
   */
  prototypeAccessors.bufferedAmountQueryIntervalInMsecs.get = function () {
    return Check.nothing(this._bufferedAmountQueryInterval)
    ? 100
    : this._bufferedAmountQueryInterval;
  };
  prototypeAccessors.bufferedAmountQueryIntervalInMsecs.set = function (newValue) {
    this._bufferedAmountQueryInterval = newValue;
  };


  /**
   *
   * @name solace.SessionProperties#transportProtocolInUse
   * @type {String}
   * @description This property is deprecated.
   * Use {@link solace.SessionProperties#webTransportProtocolInUse} instead.
   * @readonly
   * @target browser
   * @deprecated
   */
  prototypeAccessors.transportProtocolInUse.get = function () {
    return this._tpProtocolInUse || null;
  };
  SessionPropertiesBrowser.prototype._setTransportProtocolInUse = function _setTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   *
   * @name solace.SessionProperties#webTransportProtocolInUse
   * @type {String}
   * @description A read-only property about the web transport protocol that is currently being
   * used by the session for its current connection or connection attempt. To determine which
   * web transport protocol was successfully used by the API, interrogate this property after the
   * session event UP_NOTICE is dispatched.
   * @readonly
   * @target browser
   */
  prototypeAccessors.webTransportProtocolInUse.get = function () {
    return this._tpProtocolInUse || null;
  };
  SessionPropertiesBrowser.prototype._setWebTransportProtocolInUse = function _setWebTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   *
   * @name solace.SessionProperties#transportContentType
   * @type {String}
   * @description Transport content-type override for HTTP transports
   * @default 'text/plain'
   * @internal
   */
  prototypeAccessors.transportContentType.get = function () {
    return this._tpContentType || 'text/plain';
  };
  prototypeAccessors.transportContentType.set = function (newValue) {
    this._tpContentType = newValue;
  };

  SessionPropertiesBrowser.prototype._lendsInspect = function _lendsInspect () {
    return {
      'bufferedAmountQueryIntervalInMsecs': this.bufferedAmountQueryIntervalInMsecs,
      'transportContentType':               this.transportContentType,
      'transportDowngradeTimeoutInMsecs':   this.transportDowngradeTimeoutInMsecs,
      'transportProtocol':                  this.transportProtocol,
      'transportProtocolInUse':             this.transportProtocolInUse,
      'webTransportProtocolList':           this.webTransportProtocolList,
    };
  };

  Object.defineProperties( SessionPropertiesBrowser.prototype, prototypeAccessors );

  return SessionPropertiesBrowser;
}(APIProperties));

var SessionPropertiesNode = (function (APIProperties) {
  function SessionPropertiesNode () {
    APIProperties.apply(this, arguments);
  }

  if ( APIProperties ) SessionPropertiesNode.__proto__ = APIProperties;
  SessionPropertiesNode.prototype = Object.create( APIProperties && APIProperties.prototype );
  SessionPropertiesNode.prototype.constructor = SessionPropertiesNode;

  var prototypeAccessors$1 = { transportProtocol: {},webTransportProtocolList: {},transportDowngradeTimeoutInMsecs: {},transportProtocolInUse: {},webTransportProtocolInUse: {},transportContentType: {},sslExcludedProtocols: {},sslCipherSuites: {},sslValidateCertificate: {},sslTrustStores: {},sslTrustedCommonNameList: {},sslPfx: {},sslPfxPassword: {},sslPrivateKey: {},sslPrivateKeyPassword: {},sslCertificate: {},sslProtocol: {} };

  prototypeAccessors$1.transportProtocol.get = function () {
    return this._tpProtocol;
  };
  prototypeAccessors$1.transportProtocol.set = function (value) {
    this._tpProtocol = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.webTransportProtocolList.get = function () {
    return this._transportProtocolList;
  };
  prototypeAccessors$1.webTransportProtocolList.set = function (value) {
    this._transportProtocolList = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.transportDowngradeTimeoutInMsecs.get = function () {
    return this._tpDowngradeTimeout || 86400000; // All day
  };
  prototypeAccessors$1.transportDowngradeTimeoutInMsecs.set = function (value) {
    this._tpDowngradeTimeout = value;
  };

  /**
   * @internal
   * @deprecated
   */
  prototypeAccessors$1.transportProtocolInUse.get = function () {
    return this._tpProtocolInUse;
  };
  SessionPropertiesNode.prototype._setTransportProtocolInUse = function _setTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.webTransportProtocolInUse.get = function () {
    return this._tpProtocolInUse;
  };
  SessionPropertiesNode.prototype._setWebTransportProtocolInUse = function _setWebTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.transportContentType.get = function () {
    return this._tpContentType;
  };
  prototypeAccessors$1.transportContentType.set = function (value) {
    this._tpContentType = value;
  };

  // TLS connection options

  /**
   * @name solace.SessionProperties#sslExcludedProtocols
   * @type {Array.<String>}
   * @description An array of TLS protocols to be excluded when negotiating which protocol
   * to use.
   *  * Allowed values are: TLSv1, TLSv1.1, TLSv1.2
   *  * Note: when a protocol version is excluded without excluding all of its
   *    previous protocol versions, the effect is to also exclude all subsequent
   *    protocol versions.
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslExcludedProtocols.get = function () {
    return Check.nothing(this._sslExcludedProtocols)
      ? null
      : this._sslExcludedProtocols;
  };
  prototypeAccessors$1.sslExcludedProtocols.set = function (newValue) {
    this._sslExcludedProtocols = newValue;
  };

  /**
   * @name solace.SessionProperties#sslCipherSuites
   * @type {String}
   * @description A comma separated list of cipher suites in order of preference used for TLS
   * connections.
   *  * Allowed values:
   *     * AES128-GCM-SHA256
   *     * AES128-SHA
   *     * AES128-SHA256
   *     * AES256-GCM-SHA384
   *     * AES256-SHA
   *     * AES256-SHA256
   *     * DES-CBC3-SHA
   *     * ECDHE-RSA-AES128-GCM-SHA256
   *     * ECDHE-RSA-AES128-SHA
   *     * ECDHE-RSA-AES128-SHA256
   *     * ECDHE-RSA-AES256-GCM-SHA384
   *     * ECDHE-RSA-AES256-SHA
   *     * ECDHE-RSA-AES256-SHA384
   *     * ECDHE-RSA-DES-CBC3-SHA
   *     * RC4-SHA
   *     * RC4-MD5
   * @default {@link solace.SessionProperties.DEFAULT_CIPHER_SUITES}
   * @target node
   */
  prototypeAccessors$1.sslCipherSuites.get = function () {
    return Check.nothing(this._sslCipherSuites)
      ? DEFAULT_CIPHER_SUITES
      : this._sslCipherSuites;
  };
  prototypeAccessors$1.sslCipherSuites.set = function (newValue) {
    this._sslCipherSuites = newValue;
  };

  /**
   *
   * @name solace.SessionProperties#sslValidateCertificate
   * @type {Boolean}
   * @description Whether the server certificate shall be verified against the list of
   * certificates in the trust stores. If set to false, all certificate validation is disabled,
   * including date, hostname and common name validation.
   * @default true
   * @target node
   */
  prototypeAccessors$1.sslValidateCertificate.get = function () {
    // if the value is undefined, then use environment variable
    if (this._sslValidateCert === undefined) { return (process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0'); }
    if (this._sslValidateCert === null) { return true; }
    return this._sslValidateCert;
  };
  prototypeAccessors$1.sslValidateCertificate.set = function (newValue) {
    this._sslValidateCert = newValue;
  };

  /**
   * @name solace.SessionProperties#sslTrustStores
   * @type {Array.<String>}
   * @description An array of file names of trusted certificates in PEM format.
   * If not set, and {@link solace.SessionProperties#sslValidateCertificate} is set to true,
   * the server certificate will be validated against well known "root" CAs.
   *    * Mutually exclusive to sslPfx property when
   *      {@link solace.SessionProperties#sslValidateCertificate} is set
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslTrustStores.get = function () {
    return Check.nothing(this._sslTrustStores)
      ? null
      : this._sslTrustStores;
  };
  prototypeAccessors$1.sslTrustStores.set = function (newValue) {
    this._sslTrustStores = newValue;
  };

  /**
   * @name solace.SessionProperties#sslTrustedCommonNameList
   * @type {Array.<String>}
   * @description An array of acceptable common names for matching with the server certificate.
   * If set to a non-empty array, the API will override the default hostname validation logic
   * provided by Node.js with its own implemenation; if set to empty array, no hostname
   * validation will be performed.
   *    * Only relevant when {@link solace.SessionProperties#sslValidateCertificate} is set
   *      to true
   *    * Note that leading and trailing whitespaces are considered to be part of the common
   *      names and are not ignored
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslTrustedCommonNameList.get = function () {
    return Check.nothing(this._sslTrustedCNList)
      ? null
      : this._sslTrustedCNList;
  };
  prototypeAccessors$1.sslTrustedCommonNameList.set = function (newValue) {
    this._sslTrustedCNList = newValue;
  };

  // Client certificates related

  /**
   * @name solace.SessionProperties#sslPfx
   * @type {String}
   * @description The file name of a file containing private key, certificate and optional
   * CA certificates of the client in PFX or PKCS12 format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPrivateKey, sslCertificate and sslTrustStores properties
   * @default ""
   * @target node
   */
  prototypeAccessors$1.sslPfx.get = function () {
    return Check.nothing(this._sslPfx)
      ? ''
      : this._sslPfx;
  };
  prototypeAccessors$1.sslPfx.set = function (newValue) {
    this._sslPfx = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPfxPassword
   * @type {String}
   * @description A string containing password for the client pfx file.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPfxPassword.get = function () {
    return Check.nothing(this._sslPfxPasswd) ? '' : this._sslPfxPasswd;
  };
  prototypeAccessors$1.sslPfxPassword.set = function (newValue) {
    this._sslPfxPasswd = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPrivateKey
   * @type {String}
   * @description The file name of a file containing private key of the client in PEM format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPrivateKey.get = function () {
    return Check.nothing(this._sslPrivateKey) ? '' : this._sslPrivateKey;
  };
  prototypeAccessors$1.sslPrivateKey.set = function (newValue) {
    this._sslPrivateKey = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPrivateKeyPassword
   * @type {String}
   * @description A string containg password for the client private key.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPrivateKeyPassword.get = function () {
    return Check.nothing(this._sslPrivateKeyPasswd) ? '' : this._sslPrivateKeyPasswd;
  };
  prototypeAccessors$1.sslPrivateKeyPassword.set = function (newValue) {
    this._sslPrivateKeyPasswd = newValue;
  };

  /**
   * @name solace.SessionProperties#sslCertificate
   * @type {String}
   * @description The file name of a file containing certificate key of the client in PEM
   * format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslCertificate.get = function () {
    return Check.nothing(this._sslCertificate) ? '' : this._sslCertificate;
  };
  prototypeAccessors$1.sslCertificate.set = function (newValue) {
    this._sslCertificate = newValue;
  };

  // TLS connection options

  /**
   * @name SessionProperties#sslProtocol
   * @type {String}
   * @description The SSL protocols to use.
   *    * Allowed values are: SSLv3, TLSv1, TLSv1.1, TLSv1.2
   * @target node
   */
  prototypeAccessors$1.sslProtocol.get = function () {
    return this._sslProtocol;
  };
  prototypeAccessors$1.sslProtocol.set = function (newValue) {
    this._sslProtocol = newValue;
  };

  SessionPropertiesNode.prototype._lendsInspect = function _lendsInspect () {
    return {
      'sslExcludedProtocols':     this.sslExcludedProtocols,
      'sslCipherSuites':          this.sslCipherSuites,
      'sslValidateCertificate':   this.sslValidateCertificate,
      'sslTrustStores':           this.sslTrustStores,
      'sslTrustedCommonNameList': this.sslTrustedCommonNameList,
      'sslPfx':                   this.sslPfx,
      'sslPfxPassword':           this.sslPfxPassword ? '*****' : this.sslPfxPassword,
      'sslPrivateKey':            this.sslPrivateKey,
      'sslPrivateKeyPassword':    this.sslPrivateKeyPassword ? '*****' : this.sslPrivateKeyPassword,
      'sslCertificate':           this.sslCertificate,
      'sslProtocol':              this.sslProtocol,
    };
  };

  Object.defineProperties( SessionPropertiesNode.prototype, prototypeAccessors$1 );

  return SessionPropertiesNode;
}(APIProperties));

var SessionPropertiesBase =  true
  ? SessionPropertiesNode
  : SessionPropertiesBrowser;

/**
 * @classdesc
 * Represents a session properties object. Passed in to
 * {@link solace.SolclientFactory.createSession} when creating a {@link solace.Session} instance.
 * @memberof solace
 * @extends APIProperties
 */
var SessionProperties = (function (SessionPropertiesBase) {
  function SessionProperties(options) {
    SessionPropertiesBase.call(this, makeDefaults(), options);
  }

  if ( SessionPropertiesBase ) SessionProperties.__proto__ = SessionPropertiesBase;
  SessionProperties.prototype = Object.create( SessionPropertiesBase && SessionPropertiesBase.prototype );
  SessionProperties.prototype.constructor = SessionProperties;

  var prototypeAccessors$2 = { authenticationScheme: {},url: {},password: {},userName: {},clientName: {},applicationDescription: {},vpnName: {},vpnNameInUse: {},virtualRouterName: {},connectTimeoutInMsecs: {},defaultConnectTimeoutInMsecs: {},connectRetries: {},connectRetriesPerHost: {},reconnectRetryWaitInMsecs: {},reconnectRetries: {},generateSendTimestamps: {},generateReceiveTimestamps: {},includeSenderId: {},generateSequenceNumber: {},keepAliveIntervalInMsecs: {},keepAliveIntervalsLimit: {},p2pInboxInUse: {},p2pInboxBase: {},userIdentification: {},subscriberLocalPriority: {},subscriberNetworkPriority: {},ignoreDuplicateSubscriptionError: {},ignoreSubscriptionNotFoundError: {},reapplySubscriptions: {},publisherProperties: {},noLocal: {},readTimeoutInMsecs: {},sendBufferMaxSize: {},maxWebPayload: {},nonHTTPTransportPropsSet: {} };

  /**
   * The authentication scheme used when establishing the session.
   * @name solace.SessionProperties#authenticationScheme
   * @type {solace.AuthenticationScheme}
   * @default {@link solace.AuthenticationScheme.BASIC}
   */
  prototypeAccessors$2.authenticationScheme.get = function () {
    return Check.nothing(this._authScheme)
        ? AuthenticationScheme.BASIC
        : this._authScheme;
  };
  prototypeAccessors$2.authenticationScheme.set = function (newValue) {
    this._authScheme = newValue;
  };

  /**
   * The URL or URLs of the messaging service to connect to.  The URL is typically of the form
   * `<protocol>://<host[:port]>`, where:
   *  * `protocol` is one of `ws`, `wss`, `http`, `https`, `tcp` or `tcps`.
   *  (`tcp` and `tcps` supported in nodejs only.)
   *  * `host` is a hostname or IP address of the router to connect to.
   *  * `port` is the port on which the messaging service is listening. The default is the
   *    well-known port for the service associated with the given protocol, if any.
   *
   * Additionally, note:
   *  * When an Array is provided, each element is expected to be a string of the above format.
   *    The API will attempt to connect to these URLs in the specified order.
   *  * Cross-domain restrictions should be taken into consideration when deploying web
   *    applications with messaging capabilities. See the API User Guide for more
   *    information.
   * @name solace.SessionProperties#url
   * @type {String|Array.<String>}
   * @default ""
   */
  prototypeAccessors$2.url.get = function () {
    return Check.nothing(this._url) ? '' : this._url;
  };

  prototypeAccessors$2.url.set = function (newValue) {
    this._url = newValue;
  };

  //  ======================== Credentials  ========================

  /**
   * @name solace.SessionProperties#password
   * @type {String}
   * @description The password required for authentication.
   * @default ""
   */
  prototypeAccessors$2.password.get = function () {
    return Check.nothing(this._password) ? '' : this._password;
  };

  prototypeAccessors$2.password.set = function (newValue) {
    this._password = newValue;
  };

  /**
   * @name solace.SessionProperties#userName
   * @type {String}
   * @description  The client username required for authentication.
   * @default ""
   */
  prototypeAccessors$2.userName.get = function () {
    return Check.nothing(this._userName) ? '' : this._userName;
  };

  prototypeAccessors$2.userName.set = function (newValue) {
    this._userName = newValue;
  };

  /**
   * @name solace.SessionProperties#clientName
   * @type {String}
   * @default '' (automatically generated)
   * @description The client name that is used during login as a unique identifier for the session
   * on the Solace Message Router.
   *  * An empty string causes a unique client name to be generated
   *     automatically.
   *  * If specified, it must be a valid Topic name, and a maximum of 160 bytes in length.
   *  * This property is also used to uniquely identify the sender in
   *    a message's senderId field if {@link solace.SessionProperties.includeSenderId}
   *    is set.
   * @default ""
   */
  prototypeAccessors$2.clientName.get = function () {
    return Check.nothing(this._clientName) ? '' : this._clientName;
  };

  prototypeAccessors$2.clientName.set = function (newValue) {
    this._clientName = newValue;
  };

  /**
   * A string that uniquely describes the application instance.
   *  * If left blank, the API will generate a description string
   *    using the current user-agent string.
   * @default ""
   * @name solace.SessionProperties#applicationDescription
   * @type {String}
   */
  prototypeAccessors$2.applicationDescription.get = function () {
    return Check.nothing(this._appDesc) ? '' : this._appDesc;
  };
  prototypeAccessors$2.applicationDescription.set = function (newValue) {
    this._appDesc = newValue;
  };

  /**
   * The Message VPN name that the client is requesting for this session.
   * @default ""
   * @name solace.SessionProperties#vpnName
   * @type {String}
   */
  prototypeAccessors$2.vpnName.get = function () {
    return Check.nothing(this._vpnName) ? '' : this._vpnName;
  };
  prototypeAccessors$2.vpnName.set = function (newValue) {
    this._vpnName = newValue;
  };

  /**
   * A read-only session property that indicates which Message
   * VPN the session is connected to. When not connected, or when not in client mode,
   * an empty string is returned.
   * @default ""
   * @name solace.SessionProperties#vpnNameInUse
   * @type {String}
   * @readonly
   */
  prototypeAccessors$2.vpnNameInUse.get = function () {
    return Check.nothing(this._vpnNameInUse) ? '' : this._vpnNameInUse;
  };
  /**
   * @private
   * @param {String} value The vpn name currently being used.
   */
  SessionProperties.prototype._setVpnNameInUse = function _setVpnNameInUse (value) {
    this._vpnNameInUse = value;
  };

  /**
   * @name solace.SessionProperties#virtualRouterName
   * @type {String}
   * @description A read-only property that indicates the connected Solace Message Router's
   * virtual router name.
   * @default ""
   * @readonly
   */
  prototypeAccessors$2.virtualRouterName.get = function () {
    return Check.nothing(this._virtualRouterName) ? '' : this._virtualRouterName;
  };
  /**
   * @private
   * @param {String} value The current virtual router name.
   */
  SessionProperties.prototype._setVirtualRouterName = function _setVirtualRouterName (value) {
    this._virtualRouterName = value;
  };

  //  ======================== Connection Strategies ========================
  /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is 8000.
   *   * The valid range is > 0.
   * @default 8000
   * @target node
   */
  /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is calculated as shown below.
   *   * The valid range is > 0.
   * @default max(8000, 1000 + webTransportProtocolList.length * transportDowngradeTimeoutInMsecs)
   * @target browser
   */
  prototypeAccessors$2.connectTimeoutInMsecs.get = function () {
    if (Check.nothing(this._connectTimeout)) {
      return this.defaultConnectTimeoutInMsecs;
    }
    return this._connectTimeout;
  };
  prototypeAccessors$2.connectTimeoutInMsecs.set = function (newValue) {
    this._connectTimeout = newValue;
  };

  /**
   * @internal
   */
  prototypeAccessors$2.defaultConnectTimeoutInMsecs.get = function () {
    var minTimeout = 8000;
    var ref = this;
    var webTransportProtocolList = ref.webTransportProtocolList;
    var transportDowngradeTimeoutInMsecs = ref.transportDowngradeTimeoutInMsecs;
    var transportCount = webTransportProtocolList ? webTransportProtocolList.length : 1;
    var margin = transportCount > 1 ? 1000 : 0;
    var connectDowngradeDefault = transportCount * transportDowngradeTimeoutInMsecs + margin;
    return Math.max(minTimeout, connectDowngradeDefault);
  };

  /**
   * @name solace.SessionProperties#connectRetries
   * @type {Number}
   * @description The number of times to retry connecting during initial connection setup.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `connectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next connection attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   * If an established connection fails, the reconnection is attempted with
   * {@link solace.SessionProperties#reconnectRetries} retries instead.
   *
   *  * The valid range is connectRetries >= -1.
   *  * -1 means try to connect forever.
   *  * 0 means no automatic connection retries; the API will try once and then give up.
   *  * connectRetries >= 1 means reattempt connection n times.
   * @default 20
   */
  prototypeAccessors$2.connectRetries.get = function () {
    return Check.nothing(this._connectRetries) ? 20 : this._connectRetries;
  };
  prototypeAccessors$2.connectRetries.set = function (newValue) {
    this._connectRetries = newValue;
  };

  /**
   * @name solace.SessionProperties#connectRetriesPerHost
   * @type {Number}
   * @description When using a host list, this property defines how many times to
   * try to connect to a single host before moving to the next host in the list.
   *
   *  * The valid range is connectRetriesPerHost >= -1.
   *  * -1 means attempt an infinite number of connection retries. The API will only
   *    attempt to connect to the first host in the list.
   *  * 0 means make a single connection attempt per host, with no retries.
   * @default 0
   */
  prototypeAccessors$2.connectRetriesPerHost.get = function () {
    return Check.nothing(this._connectRetriesPerHost) ? 0 : this._connectRetriesPerHost;
  };
  prototypeAccessors$2.connectRetriesPerHost.set = function (newValue) {
    this._connectRetriesPerHost = newValue;
  };

  /**
   * @name solace.SessionProperties#reconnectRetryWaitInMsecs
   * @type {Number}
   * @description How much time to wait (in ms) between each attempt to connect to
   * a host.
   * If a connect attempt is not successful, the API waits for the amount of time
   * specified, and then makes another attempt to connect.
   * {@link solace.SessionProperties#connectRetriesPerHost} sets how many connection
   * attempts will be made before moving on to the next host in the list.
   * The valid range is >= 0 and <= 60000.
   * @default 3000
   */
  prototypeAccessors$2.reconnectRetryWaitInMsecs.get = function () {
    return Check.nothing(this._reconnectRetryWaitInMsecs) ? 3000 : this._reconnectRetryWaitInMsecs;
  };
  prototypeAccessors$2.reconnectRetryWaitInMsecs.set = function (newValue) {
    this._reconnectRetryWaitInMsecs = newValue;
  };

  /**
   * @name solace.SessionProperties#reconnectRetries
   * @type {Number}
   * @description The number of times to retry connecting after a connected session goes down.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `reconnectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next reconnect attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   *  * The valid range is reconnectRetries >= -1.
   *  * -1 means try to reconnect forever.
   *  * 0 means no automatic reconnect retries; the API will try once and then give up.
   *  * reconnectRetries >= 1 means reattempt reconnect n times.
   * @default 20
   */
  prototypeAccessors$2.reconnectRetries.get = function () {
    return Check.nothing(this._reconnectRetries) ? 20 : this._reconnectRetries;
  };
  prototypeAccessors$2.reconnectRetries.set = function (newValue) {
    this._reconnectRetries = newValue;
  };

  //  ======================== message properties ========================
  /**
   * @name solace.SessionProperties#generateSendTimestamps
   * @type {Boolean}
   * @description When enabled, a send timestamp is automatically included
   * (if not already present) in the Solace-defined fields for
   * each message sent.
   * @default  false
   */
  prototypeAccessors$2.generateSendTimestamps.get = function () {
    return Check.nothing(this._genSendTimestamps) ? false : this._genSendTimestamps;
  };
  prototypeAccessors$2.generateSendTimestamps.set = function (newValue) {
    this._genSendTimestamps = newValue;
  };

  /**
   * @name solace.SessionProperties#generateReceiveTimestamps
   * @type {Boolean}
   * @description When enabled, a receive timestamp is recorded for
   * each message and passed to the session's message callback receive handler.
   * @default  false
   */
  prototypeAccessors$2.generateReceiveTimestamps.get = function () {
    return Check.nothing(this._genReceiveTimestamps) ? false : this._genReceiveTimestamps;
  };
  prototypeAccessors$2.generateReceiveTimestamps.set = function (newValue) {
    this._genReceiveTimestamps = newValue;
  };

  /**
   * @name solace.SessionProperties#includeSenderId
   * @type {Boolean}
   * @description When enabled, a sender ID is automatically included
   * (if not already present) in the Solace-defined fields for each message
   * sent.
   * @default  false
   */
  prototypeAccessors$2.includeSenderId.get = function () {
    return Check.nothing(this._includeSenderId) ? false : this._includeSenderId;
  };
  prototypeAccessors$2.includeSenderId.set = function (newValue) {
    this._includeSenderId = newValue;
  };

  /**
   * @name solace.SessionProperties#generateSequenceNumber
   * @type {Boolean}
   * @description When enabled, a sequence number is automatically
   * included (if not already present) in the Solace-defined fields
   * for each message sent.
   * @default  false
   */
  prototypeAccessors$2.generateSequenceNumber.get = function () {
    return Check.nothing(this._genSequenceNumber) ? false : this._genSequenceNumber;
  };
  prototypeAccessors$2.generateSequenceNumber.set = function (newValue) {
    this._genSequenceNumber = newValue;
  };

  //  ======================== Keep Alive ========================
  /**
   * @name solace.SessionProperties#keepAliveIntervalInMsecs
   * @type {Number}
   * @description The amount of time (in milliseconds) to wait between sending
   * out keep-alive messages to the Solace Message Router.
   *  * The valid range is > 0.
   * @default  3000
   */
  prototypeAccessors$2.keepAliveIntervalInMsecs.get = function () {
    return Check.nothing(this._kaInterval) ? 3000 : this._kaInterval;
  };
  prototypeAccessors$2.keepAliveIntervalInMsecs.set = function (newValue) {
    this._kaInterval = newValue;
  };

  /**
   * @name solace.SessionProperties#keepAliveIntervalsLimit
   * @type {Number}
   * @description The maximum number of consecutive Keep-Alive messages that
   * can be sent without receiving a response before the session is declared down
   * and the connection is closed by the API.
   *  * The valid range is >= 3.
   * @default 3
   */
  prototypeAccessors$2.keepAliveIntervalsLimit.get = function () {
    return Check.nothing(this._kaIntervalsLimit) ? 3 : this._kaIntervalsLimit;
  };
  prototypeAccessors$2.keepAliveIntervalsLimit.set = function (newValue) {
    this._kaIntervalsLimit = newValue;
  };

  // ======================== P2P Inbox ========================

  /**
   * @name solace.SessionProperties#p2pInboxInUse
   * @type {String}
   * @description A read-only string that indicates the default
   * reply-to destination used for any request messages sent from this session.
   * See {@link solace.Session#sendRequest}.
   * This parameter is only valid when the session is connected.
   * @default ""
   * @readonly
   */
  prototypeAccessors$2.p2pInboxInUse.get = function () {
    return Check.nothing(this._p2pInboxInUse) ? '' : this._p2pInboxInUse;
  };
  /**
   * @private
   * @param {String} value The current P2P subscription.
   */
  SessionProperties.prototype._setP2pInboxInUse = function _setP2pInboxInUse (value) {
    this._p2pInboxInUse = value;
  };

  /**
   * @private
   *
   * @name solace.SessionProperties#p2pInboxBase
   * @description A read-only information string that stores the P2P topic subscription
   * obtained from the Solace Message Router.
   * This parameter is only valid when the session is connected.
   * @default  ""
   * @readonly
   */
  prototypeAccessors$2.p2pInboxBase.get = function () {
    return Check.nothing(this._p2pInboxBase) ? '' : this._p2pInboxBase;
  };
  /**
   * @private
   * @param {String} value The current P2P inbox root subscription. The subscription on the router
   *   additionally contains '/>', so extra topic levels can be added to this root and messages to
   *   those topics will be attracted with the subscription.
   */
  SessionProperties.prototype._setP2pInboxBase = function _setP2pInboxBase (value) {
    this._p2pInboxBase = value;
  };

  /**
   * @name solace.SessionProperties#userIdentification
   * @type {String}
   * @description A read-only string providing information
   * about the application, such as the name of operating system
   * that is running the application.
   * @default  ""
   * @readonly
   */
  prototypeAccessors$2.userIdentification.get = function () {
    return Check.nothing(this._userIdentification) ? '' : this._userIdentification;
  };
  /**
   * @private
   * @param {String} value The current userId
   */
  SessionProperties.prototype._setUserIdentification = function _setUserIdentification (value) {
    this._userIdentification = value;
  };

  // ================== Subscriptions ========================
  /**
   *
   * @name solace.SessionProperties#subscriberLocalPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority. Subscribers have two priorities; this
   * priority is for messages published locally.
   *  * The valid range is 1..4
   * @default 1
   */
  prototypeAccessors$2.subscriberLocalPriority.get = function () {
    return Check.nothing(this._subLocalPriority) ? 1 : this._subLocalPriority;
  };
  prototypeAccessors$2.subscriberLocalPriority.set = function (newValue) {
    this._subLocalPriority = newValue;
  };

  /**
   * @name solace.SessionProperties#subscriberNetworkPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority.
   *
   * Subscribers have two priorities; this priority is for messages published on Solace Message
   * Routers other than the one that the client is connected to.
   *  * The valid range is 1..4
   * @default  1
   */
  prototypeAccessors$2.subscriberNetworkPriority.get = function () {
    return Check.nothing(this._subNetworkPriority) ? 1 : this._subNetworkPriority;
  };
  prototypeAccessors$2.subscriberNetworkPriority.set = function (newValue) {
    this._subNetworkPriority = newValue;
  };

  /**
   * @name solace.SessionProperties#ignoreDuplicateSubscriptionError
   * @type {Boolean}
   * @description Used to ignore duplicate subscription errors on subscribe.
   * @default  true
   */
  prototypeAccessors$2.ignoreDuplicateSubscriptionError.get = function () {
    return Check.nothing(this._ignoreDupSubError) ? true : this._ignoreDupSubError;
  };
  prototypeAccessors$2.ignoreDuplicateSubscriptionError.set = function (newValue) {
    this._ignoreDupSubError = newValue;
  };

  /**
   * @name solace.SessionProperties#ignoreSubscriptionNotFoundError
   * @type {Boolean}
   * @description Used to ignore subscription not found errors on unsubscribe.
   * @default  true
   */
  prototypeAccessors$2.ignoreSubscriptionNotFoundError.get = function () {
    return Check.nothing(this._ignoreSubNotFoundError) ? true : this._ignoreSubNotFoundError;
  };
  prototypeAccessors$2.ignoreSubscriptionNotFoundError.set = function (newValue) {
    this._ignoreSubNotFoundError = newValue;
  };

  /**
   *
   * @name solace.SessionProperties#reapplySubscriptions
   * @type {Boolean}
   * @description Set to 'true' to have the API remember subscriptions and reapply them upon
   * calling {@link solace.Session#connect} on a disconnected session.
   * @default  false
   */
  prototypeAccessors$2.reapplySubscriptions.get = function () {
    return Check.nothing(this._reapplySubcriptions) ? false : this._reapplySubcriptions;
  };
  prototypeAccessors$2.reapplySubscriptions.set = function (newValue) {
    this._reapplySubcriptions = newValue;
  };

  // ================== AD configuration ========================
  /**
   * Sets the guaranteed messaging publisher properties for the session.
   * If the supplied value is not a {@link solace.MessagePublisherProperties},
   * one will be constructed using the supplied value as an argument.
   *
   * @name solace.SessionProperties#publisherProperties
   * @type {solace.MessagePublisherProperties}
   */
  prototypeAccessors$2.publisherProperties.get = function () {
    return this._publisherProperties;
  };
  prototypeAccessors$2.publisherProperties.set = function (val) {
    var MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
    this._publisherProperties = val instanceof MessagePublisherProperties
      ? val
      : new MessagePublisherProperties(val);
  };

  // ================== Transport configuration ========================

  /**
   *
   * @name solace.SessionProperties#noLocal
   * @type {Boolean}
   * @description Set to 'true' to signal the Solace Message Router that messages published on the
   * session should not be received on the same session even if the client has a subscription that
   * matches the published topic. If this restriction is requested, and the Solace Message Router
   * does not have No Local support, the session connect will fail.
   * @default  false
   */
  prototypeAccessors$2.noLocal.get = function () {
    return Check.nothing(this._noLocal) ? false : this._noLocal;
  };
  prototypeAccessors$2.noLocal.set = function (newValue) {
    this._noLocal = newValue;
  };

  /**
   * @name solace.SessionProperties#readTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a reply to
   * come back from the Solace Message Router. This timeout serves as the default
   * request timeout for {@link solace.Session#subscribe},
   * {@link solace.Session#unsubscribe}, {@link solace.Session#updateProperty}.
   *  * The valid range is >= 0.
   * @default 10000
   */
  prototypeAccessors$2.readTimeoutInMsecs.get = function () {
    return Check.nothing(this._readTimeout) ? 10000 : this._readTimeout;
  };
  prototypeAccessors$2.readTimeoutInMsecs.set = function (newValue) {
    this._readTimeout = newValue;
  };

  /**
   * @name solace.SessionProperties#sendBufferMaxSize
   * @type {Number}
   * @description The maximum buffer size for the transport session. This size must be bigger
   * than the largest message an application intends to send on the session.
   *
   * The session buffer size configured using the sendBufferMaxSize
   * session property controls SolClient buffering of transmit messages. When
   * sending small messages, the session buffer size should be set to multiple times
   * the typical message size to improve the performance. Regardless of the buffer
   * size, SolClient always accepts at least one message to transmit. So even if a
   * single message exceeds sendBufferMaxSize, it is accepted and
   * transmitted as long as the current buffered data is zero. However, no more
   * messages are accepted until the amount of data buffered is reduced
   * enough to allow room below sendBufferMaxSize.
   *  * The valid range is > 0.
   *
   * @default 65536 (64KB)
   */
  prototypeAccessors$2.sendBufferMaxSize.get = function () {
    return Check.nothing(this._sendBufferMaxSize) ? (64 * 1024) : this._sendBufferMaxSize;
  };
  prototypeAccessors$2.sendBufferMaxSize.set = function (newValue) {
    this._sendBufferMaxSize = newValue;
  };

  /**
   * @name solace.SessionProperties#maxWebPayload
   * @type {Number}
   * @description The maximum payload size (in bytes) when sending data using the Web transport
   * protocol.  Large messages may fail to be sent to the Solace Message Router when the maximum web
   * payload is set to a small value. To avoid this, use a large maximum web payload.
   *  * The valid range is >= 100.
   * @default 1048576 (1MB)
   */
  prototypeAccessors$2.maxWebPayload.get = function () {
    return Check.nothing(this._maxWebPayload) ? (1024 * 1024) : this._maxWebPayload;
  };
  prototypeAccessors$2.maxWebPayload.set = function (newValue) {
    this._maxWebPayload = newValue;
  };


  /**
   * @private
   */
  prototypeAccessors$2.nonHTTPTransportPropsSet.get = function () {
    var this$1 = this;

      // Calculate on demand based on presence of properties.
      // Currently not tracking this so no property names listed.
    return [].filter(function (k) { return Check.something(this$1[k]); });
  };

  /**
   * @returns {String} A brief description of this object
   * @private
   */
  SessionProperties.prototype[util.inspect.custom] = function () {
    return Object.assign(this._lendsInspect(), {
      'authenticationScheme':             AuthenticationScheme.describe(this.authenticationScheme),
      'url':                              this.url,
      'password':                         this.password ? '*****' : this.password,
      'userName':                         this.userName,
      'clientName':                       this.clientName,
      'applicationDescription':           this.applicationDescription,
      'vpnName':                          this.vpnName,
      'vpnNameInUse':                     this.vpnNameInUse,
      'virtualRouterName':                this.virtualRouterName,
      'connectTimeoutInMsecs':            this.connectTimeoutInMsecs,
      'connectRetries':                   this.connectRetries,
      'connectRetriesPerHost':            this.connectRetriesPerHost,
      'reconnectRetryWaitInMsecs':        this.reconnectRetryWaitInMsecs,
      'reconnectRetries':                 this.reconnectRetries,
      'generateSendTimestamps':           this.generateSendTimestamps,
      'generateReceiveTimestamps':        this.generateReceiveTimestamps,
      'includeSenderId':                  this.includeSenderId,
      'generateSequenceNumber':           this.generateSequenceNumber,
      'keepAliveIntervalInMsecs':         this.keepAliveIntervalInMsecs,
      'keepAliveIntervalsLimit':          this.keepAliveIntervalsLimit,
      'p2pInboxInUse':                    this.p2pInboxInUse,
      'p2pInboxBase':                     this.p2pInboxBase,
      'userIdentification':               this.userIdentification,
      'subscriberLocalPriority':          this.subscriberLocalPriority,
      'subscriberNetworkPriority':        this.subscriberNetworkPriority,
      'ignoreDuplicateSubscriptionError': this.ignoreDuplicateSubscriptionError,
      'reapplySubscriptions':             this.reapplySubscriptions,
      'publisherProperties':              this.publisherProperties,
      'noLocal':                          this.noLocal,
      'readTimeoutInMsecs':               this.readTimeoutInMsecs,
      'sendBufferMaxSize':                this.sendBufferMaxSize,
      'maxWebPayload':                    this.maxWebPayload,
    });
  };

  /**
   * @name solace.SessionProperties#toString
   * @description Returns a human-readable representation of this Session, subject to change.
   * @returns {String} A brief description of this object
   */
  SessionProperties.prototype.toString = function toString () {
    return SessionPropertiesBase.prototype.toString.call(this); // only here for the docs
  };

  Object.defineProperties( SessionProperties.prototype, prototypeAccessors$2 );

  return SessionProperties;
}(SessionPropertiesBase));

// Don't try to evaluate these constants in browser mode
if (true) {
  /**
   * @description The default comma separated list of cipher suites in
   * order of preference used for SSL connections.
   * @constant
   * @type {String}
   */
  SessionProperties.DEFAULT_CIPHER_SUITES = DEFAULT_CIPHER_SUITES;

  /**
   * A list of cipher suites supported by the API when using SSL connections
   * @constant
   * @type {string[]}
   * @private
   */
  SessionProperties.SUPPORTED_CIPHER_SUITES = SUPPORTED_CIPHER_SUITES;

  /**
   * SSL protocols supported by the API when using SSL connections
   * @type {string[]}
   * @private
   */
  SessionProperties.SUPPORTED_SSL_PROTOCOLS = SUPPORTED_SSL_PROTOCOLS;

  /* eslint-disable */ // don't mangle import
  SessionProperties.SslProtocolExcludeConstantMap = ( obj = {}, obj['sslv2'] = NodeSslConstants['SSL_OP_NO_SSLv2'] || 0, obj['sslv3'] = NodeSslConstants['SSL_OP_NO_SSLv3'] || 0, obj['tlsv1'] = NodeSslConstants['SSL_OP_NO_TLSv1'] || 0, obj['tlsv1.1'] = NodeSslConstants['SSL_OP_NO_TLSv1_1'] || 0, obj['tlsv1.2'] = NodeSslConstants['SSL_OP_NO_TLSv1_2'] || 0, obj );
  var obj;
  /* eslint-enable */ // don't mangle import
}


module.exports.SessionProperties = SessionProperties;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionRequestType = {
  ADD_SUBSCRIPTION:        0,
  REMOVE_SUBSCRIPTION:     1,
  ADD_P2PINBOX:            2,
  REMOVE_P2PINBOX:         3,
  REMOVE_DTE_SUBSCRIPTION: 100,
};

module.exports.SessionRequestType = Enum.new(SessionRequestType);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(0);
var BidiMap = ref.BidiMap;
var Lazy = ref.Lazy;
var ref$1 = __webpack_require__(3);
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(120);
var ContentSummaryElement = ref$2.ContentSummaryElement;
var ref$3 = __webpack_require__(45);
var ContentSummaryType = ref$3.ContentSummaryType;
var ref$4 = __webpack_require__(1);
var LOG_ERROR = ref$4.LOG_ERROR;
var ref$5 = __webpack_require__(13);
var SMFUH = ref$5.SMFUH;

var lazyValue = Lazy.lazyValue;
var int8ToStr = Convert.int8ToStr;
var int16ToStr = Convert.int16ToStr;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var strToInt24 = Convert.strToInt24;
var strToInt32 = Convert.strToInt32;

var delModeEnumBidiMap = lazyValue(
  function () {
    // Single bidirectional map for lookups. Note that the forward
    // keys are converted to strings.
    var source = [
      [0x00, MessageLib.MessageDeliveryModeType.NON_PERSISTENT],
      [0x01, MessageLib.MessageDeliveryModeType.PERSISTENT],
      [0x02, MessageLib.MessageDeliveryModeType.DIRECT] ].map(function (el) { return [el[0], el[1]]; });
    return new (Function.prototype.bind.apply( BidiMap, [ null ].concat( source) ));
  });
var lutDelModeToEnum = lazyValue(function () { return delModeEnumBidiMap.value.forward; });
var lutEnumToDelMode = lazyValue(function () { return delModeEnumBidiMap.value.reverse; });

/**
 * SMF TLV Param LUT
 * utTypeMap[uh][paramtype] is the binary prefix for a regular (not LW) TLV
 * parameter with uh and paramtype values as accessed in the array.
 *
 * @private
 */
var uhTypeMap = (function () {
  var result = [];
  var paramTypeBits = 5;
  var paramTypeCount = Math.pow(2, paramTypeBits);
  SMFUH.values.forEach(function (uh) {
    result[uh] = [];
    for (var i = 0; i < paramTypeCount; ++i) {
      var byte1 = 0;
      byte1 = Bits.set(byte1, uh, 6, 2);
      byte1 = Bits.set(byte1, i, 0, paramTypeBits);
      result[uh][i] = int8ToStr(byte1);
    }
  });
  return result;
})();

/**
 * SMF TLV length map LUT
 *
 * lenMap[x] === String.fromCharCode(x)
 *
 * @private
 */
var lenMap = (new Array(256).fill(null).map(function (_, idx) { return int8ToStr(idx); }));

/**
 * SMF Lightweight Param LUT
 *
 * lightMap[uh][paramtype][len] is the prefix for an SMF LWP
 * with uh, paramtype and len values as accessed in the array.
 *
 * @private
 */
var lightMap = (function () {
  var result = [];
  var paramTypeBits = 3;
  var paramTypeCount = Math.pow(2, paramTypeBits);
  var lenBits = 2;
  var lenCount = Math.pow(2, lenBits);
  SMFUH.values.forEach(function (uh) {
    result[uh] = [];
    for (var i = 0; i < paramTypeCount; ++i) {
      result[uh][i] = [];
      for (var j = 0; j < lenCount; ++j) {
        var byte1 = 0;
        byte1 = Bits.set(byte1, uh, 6, 2);
        byte1 = Bits.set(byte1, 1, 5, 1);
        byte1 = Bits.set(byte1, i, 2, 3);
        byte1 = Bits.set(byte1, j, 0, 2);
        result[uh][i][j] = int8ToStr(byte1);
      }
    }
  });
  return result;
})();

var ContentSummaryDecodeMap = [
  ContentSummaryType.XML_META,
  ContentSummaryType.XML_PAYLOAD,
  ContentSummaryType.BINARY_ATTACHMENT,
  ContentSummaryType.CID_LIST,
  ContentSummaryType.BINARY_METADATA ];

var ParamParse = {

  parseTopicQueueOffsets: function parseTopicQueueOffsets(data, offset) {
    var result = [];
    result[0] = strToInt8(data.substr(offset, 1));
    result[1] = strToInt8(data.substr(offset + 1, 1));
    return result;
  },

  parseResponseParam: function parseResponseParam(data, offset, paramLen) {
    var result = [];
    result[0] = strToInt32(data.substr(offset, 4));
    var respStrLen = paramLen - 4;
    if (respStrLen > 0) {
      result[1] = data.substr(offset + 4, respStrLen);
    } else {
      result[1] = '';
    }
    return result;
  },

  parseDeliveryMode: function parseDeliveryMode(data, offset) {
    var delmode = strToInt8(data.substr(offset, 1));
    var lookup = lutDelModeToEnum.value.get(delmode);
    return lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT;
  },

  encDeliveryMode: function encDeliveryMode(delmode) {
    var lut = lutEnumToDelMode.value;
    var lookup = lut.get(delmode);
    return int8ToStr(lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT);
  },

  parseContentSummary: function parseContentSummary(data, offset, length) {
    var elements = [];
    var cumulativeSize = 0;
    var pos = offset;

    while (pos < offset + length) {
      var byte1 = strToInt8(data.charAt(pos));
      var elementType = Bits.get(byte1, 4, 4);
      var elementDeclaredLength = Bits.get(byte1, 0, 4);
      var elementSize = 0;
      switch (elementDeclaredLength) {
        case 2:
          elementSize = strToInt8(data.substr(pos + 1, 1));
          break;
        case 3:
          elementSize = strToInt16(data.substr(pos + 1, 2));
          break;
        case 4:
          elementSize = strToInt24(data.substr(pos + 1, 3));
          break;
        case 5:
          elementSize = strToInt32(data.substr(pos + 1, 4));
          break;
        default:
          // Allow 1 and continue;
          break;
      }

      if (elementDeclaredLength === 0) {
        LOG_ERROR('Invalid content summary parameter - pos not advancing');
        return null;
      }
      pos += elementDeclaredLength;

      var cst = ContentSummaryDecodeMap[elementType];
      if (cst === undefined) {
        LOG_ERROR(("Unhandled element type " + elementType));
      }
      var currentElement = new ContentSummaryElement(cst, cumulativeSize, elementSize);
      elements.push(currentElement);
      cumulativeSize += elementSize;
    } // end while loop
    return elements;
  },

  encContentSummary: function encContentSummary(contentSummaryArr) {
    var messageElementDescriptions = [];
    for (var i = 0, n = contentSummaryArr.length; i < n; ++i) {
      // a ContentSummaryElement
      var currentContentSummary = contentSummaryArr[i];
      var currentSizeStr = '';
      var firstByte = Bits.set(0, currentContentSummary.type, 4, 4);
      if (currentContentSummary.length <= 255) {
        // element length: 2
        firstByte = Bits.set(firstByte, 2, 0, 4);
        currentSizeStr = int8ToStr(currentContentSummary.length);
      } else if (currentContentSummary.length <= 65535) {
        firstByte = Bits.set(firstByte, 3, 0, 4);
        currentSizeStr = int16ToStr(currentContentSummary.length);
      } else if (currentContentSummary.length <= 16777215) {
        firstByte = Bits.set(firstByte, 4, 0, 4);
        currentSizeStr = int24ToStr(currentContentSummary.length);
      } else {
        firstByte = Bits.set(firstByte, 5, 0, 4);
        currentSizeStr = int32ToStr(currentContentSummary.length);
      }
      messageElementDescriptions.push(int8ToStr(firstByte));
      messageElementDescriptions.push(currentSizeStr);
    }
    return messageElementDescriptions.join('');
  },

  encodeSMFParam: function encodeSMFParam(uh, paramtype, value) {
    if (value === undefined) {
      return uhTypeMap[uh][paramtype] + lenMap[2];
    }
    var len = value.length;
    if (len <= 253) {
      return uhTypeMap[uh][paramtype] + lenMap[len + 2] + value;
    }
    return uhTypeMap[uh][paramtype] + lenMap[0] + int32ToStr(len + 6) + value;
  },

  encLightSMFParam: function encLightSMFParam(uh, paramtype, value) {
    return lightMap[uh][paramtype][value.length] + value;
  },

};

module.exports.ParamParse = ParamParse;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * A representation of an SMF parameter
 *
 * @private
 */
var SMFParameter = function SMFParameter(uh, type, value) {
  this._type = type;
  this._value = value;
  this._uh = uh;
};
SMFParameter.prototype.getType = function getType () {
  return this._type;
};
SMFParameter.prototype.getValue = function getValue () {
  return this._value;
};
SMFParameter.prototype.getUh = function getUh () {
  return this._uh;
};
SMFParameter.prototype.toString = function toString () {
  return ((this._uh) + ":0x" + (this._type.toString(16)) + " = " + (this._value));
};

module.exports.SMFParameter = SMFParameter;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFParameterType = {
  // SMF parameter type
  PADDING:                  0x00,
  PUBLISHER_ID:             0x01,
  PUBLISHER_MSGID:          0x02,
  MESSAGEPRIORITY:          0x03,
  USERDATA:                 0x04,
  USERNAME:                 0x06,
  PASSWORD:                 0x07,
  RESPONSE:                 0x08,
  SUB_ID_LIST:              0x0A,
  GENERIC_ATTACHMENT:       0x0B,
  BINARY_ATTACHMENT:        0x0C,
  DELIVERY_MODE:            0x10,
  ASSURED_MESSAGE_ID:       0x11,
  ASSURED_PREVMESSAGE_ID:   0x12,
  ASSURED_REDELIVERED_FLAG: 0x13,
  MESSAGE_CONTENT_SUMMARY:  0x16,
  ASSURED_FLOWID:           0x17,
  TR_TOPICNAME:             0x18,
  AD_FLOWREDELIVERED_FLAG:  0x19,
  AD_TIMETOLIVE:            0x1C,
  AD_TOPICSEQUENCE_NUMBER:  0x1e,

  LIGHT_CORRELATION:       0x00,
  LIGHT_TOPIC_NAME_OFFSET: 0x01,
  LIGHT_QUEUE_NAME_OFFSET: 0x02,
  LIGHT_ACK_IMMEDIATELY:   0x03,
};

module.exports.SMFParameterType = Enum.new(SMFParameterType);


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFSMPMessageType = {
  ADDSUBSCRIPTION:              0x00,
  REMSUBSCRIPTION:              0x01,
  ADDQUEUESUBSCRIPTION:         0x02,
  REMQUEUESUBSCRIPTION:         0x03,
  ADDSUBSCRIPTIONFORCLIENTNAME: 0x04,
  REMSUBSCRIPTIONFORCLIENTNAME: 0x05,
};

module.exports.SMFSMPMessageType = Enum.new(SMFSMPMessageType);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(132);
var CacheCBInfo = ref.CacheCBInfo;
var ref$1 = __webpack_require__(81);
var CacheContext = ref$1.CacheContext;
var ref$2 = __webpack_require__(133);
var CacheLiveDataAction = ref$2.CacheLiveDataAction;
var ref$3 = __webpack_require__(135);
var CacheRequest = ref$3.CacheRequest;
var ref$4 = __webpack_require__(134);
var CacheRequestResult = ref$4.CacheRequestResult;
var ref$5 = __webpack_require__(136);
var CacheReturnCode = ref$5.CacheReturnCode;
var ref$6 = __webpack_require__(137);
var CacheReturnSubcode = ref$6.CacheReturnSubcode;
var ref$7 = __webpack_require__(233);
var CacheSession = ref$7.CacheSession;
var ref$8 = __webpack_require__(138);
var CacheSessionProperties = ref$8.CacheSessionProperties;

module.exports.CacheCBInfo = CacheCBInfo;
module.exports.CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
module.exports.CacheLiveDataAction = CacheLiveDataAction;
module.exports.CacheRequestResult = CacheRequestResult;
module.exports.CacheReturnCode = CacheReturnCode;
module.exports.CacheReturnSubcode = CacheReturnSubcode;
module.exports.CacheRequest = CacheRequest;
module.exports.CacheSession = CacheSession;
module.exports.CacheSessionProperties = CacheSessionProperties;



/***/ }),
/* 81 */
/***/ (function(module, exports) {

/**
 * @private
 * @static
 */
var CacheContext = {
  /**
   * A prefix appearing on the request IDs of all requests associated with a Solcache session.
   * @type {String}
   * @private
   */
  CACHE_REQUEST_PREFIX: '#CRQ',

  /**
   * A global counter generating unique correlation IDs for cache requests.
   * @private
   */
  cacheRequestCorrelationId: 0,
};

module.exports.CacheContext = CacheContext;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Statistics for sent/received messages and control operations.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var StatType = {

  // ------- SMF and Direct Messaging

  /**
   * Count of bytes sent as part of data messages.
   */
  TX_TOTAL_DATA_BYTES:            0,
  /**
   * Count of data messages sent.
   */
  TX_TOTAL_DATA_MSGS:             1,
  /**
   * Count of bytes sent as part of direct data messages.
   */
  TX_DIRECT_BYTES:                2,
  /**
   * Count of direct data messages sent.
   */
  TX_DIRECT_MSGS:                 3,
  /**
   * Count of bytes sent as part of control messages.
   */
  TX_CONTROL_BYTES:               4,
  /**
   * Count of control messages sent.
   */
  TX_CONTROL_MSGS:                5,
  /**
   * Count of request messages sent.
   */
  TX_REQUEST_SENT:                6,
  /**
   * Count of request timeouts that occurred.
   */
  TX_REQUEST_TIMEOUT:             7,
  /**
   * Count of bytes received as part of data messages.
   */
  RX_TOTAL_DATA_BYTES:            8,
  /**
   * Count of data messages received.
   */
  RX_TOTAL_DATA_MSGS:             9,
  /**
   * Count of bytes received as part of direct data messages.
   */
  RX_DIRECT_BYTES:                10,
  /**
   * Count of direct data messages received.
   */
  RX_DIRECT_MSGS:                 11,
  /**
   * Count of bytes received as part of control messages.
   */
  RX_CONTROL_BYTES:               12,
  /**
   * Count of control messages received.
   */
  RX_CONTROL_MSGS:                13,
  /**
   * Count discard message indications received on incoming messages.
   */
  RX_DISCARD_MSG_INDICATION:      14,
  /**
   * Count of reply messaged received.
   */
  RX_REPLY_MSG_RECVED:            15,
  /**
   * Count of received reply messages that were discarded.
   */
  RX_REPLY_MSG_DISCARD:           16,
  /**
   * @description
   * Count of messages discarded due to the presence of an unknown element or
   * unknown protocol in the SMF header.
   */
  RX_DISCARD_SMF_UNKNOWN_ELEMENT: 17,

  // ------- SolCache Session

  /**
   * @description
   * Count of cache requests sent. One conceptual request (i.e. one API call)
   * may involve many requests and replies.
   */
  CACHE_REQUEST_SENT:                     18,
  /**
   * @description
   * Count of OK responses to cache requests.
   */
  CACHE_REQUEST_OK_RESPONSE:              19,
  /**
   * @description
   * Count of cache requests that returned a failure response.
   */
  CACHE_REQUEST_FAIL_RESPONSE:            20,
  /**
   * @description
   * Count of cache replies discarded because a request has been fulfilled.
   */
  CACHE_REQUEST_FULFILL_DISCARD_RESPONSE: 21,
  /**
   * @description
   * Count of cached messages delivered to the application.
   */
  RX_CACHE_MSG:                           22,
  /**
   * @description
   * Count of cache requests that were incomplete.
   */
  CACHE_REQUEST_INCOMPLETE_RESPONSE:      23,
  /**
   * @description
   * The cache session operation completed when live data arrived on the requested topic.
   */
  CACHE_REQUEST_LIVE_DATA_FULFILL:        24,

  // ------ Guaranteed Messaging

  /**
   * Count of bytes sent as part of persistent data messages.
   */
  TX_PERSISTENT_BYTES:                25,
  /**
   * Count of persistent data messages sent.
   */
  TX_PERSISTENT_MSGS:                 26,
  /**
   * Count of non-persistent data bytes sent.
   */
  TX_NONPERSISTENT_BYTES:             27,
  /**
   * Count of non-persistent data messages sent.
   */
  TX_NONPERSISTENT_MSGS:              28,
  /**
   * The number of bytes redelivered in Persistent messages.
   */
  TX_PERSISTENT_BYTES_REDELIVERED:    29,
  /**
   * The number of Persistent messages redelivered.
   */
  TX_PERSISTENT_REDELIVERED:          30,
  /**
   * The number of bytes redelivered in Non-Persistent messages.
   */
  TX_NONPERSISTENT_BYTES_REDELIVERED: 31,
  /**
   * The number of Non-Persistent messages redelivered.
   */
  TX_NONPERSISTENT_REDELIVERED:       32,
  /**
   * The number of acknowledgments received.
   */
  TX_ACKS_RXED:                       33,
  /**
   * The number of times the transmit window closed.
   */
  TX_WINDOW_CLOSE:                    34,
  /**
   * The number of times the acknowledgment timer expired.
   */
  TX_ACK_TIMEOUT:                     35,
  /**
   * Count of bytes received as part of persistent data messages.
   */
  RX_PERSISTENT_BYTES:                36,
  /**
   * Count of persistent data messages received.
   */
  RX_PERSISTENT_MSGS:                 37,
  /**
   * Count of bytes received as part of non-persistent data messages.
   */
  RX_NONPERSISTENT_BYTES:             38,
  /**
   * Count of non-persistent data messages received.
   */
  RX_NONPERSISTENT_MSGS:              39,
  /**
   * Count of acknowledgements sent to the Solace Message Router
   * for guaranteed messages received by the API.
   */
  RX_ACKED:                           40,
  /**
   * Count of guaranteed messages discarded for being duplicates.
   */
  RX_DISCARD_DUPLICATE:               41,
  /**
   * Count of guaranteed messages discarded due to no match message consumer for the message.
   */
  RX_DISCARD_NO_MATCHING_CONSUMER:    42,
  /**
   * Count of guaranteed messages discarded for being received out of order.
   */
  RX_DISCARD_OUT_OF_ORDER:            43,
};

module.exports.StatType = Enum.new(StatType);


/***/ }),
/* 83 */
/***/ (function(module, exports) {

var BaseSMFClient = function BaseSMFClient(rxSmfCB, rxMessageErrorCB, session) {
  this.reset();
  this._rxSmfCB = rxSmfCB; // callback for parsed msg
  this._rxMessageErrorCB = rxMessageErrorCB; // invalid UH, etc.
  this._session = session;
};

BaseSMFClient.prototype.reset = function reset () {
  this._correlationCounter = 0;
};

BaseSMFClient.prototype.nextCorrelationTag = function nextCorrelationTag () {
  // Login uses the max value as a sentinel, so wrap around early
  if (++this._correlationCounter >= BaseSMFClient.SMF_MAX_CORRELATION) {
    this._correlationCounter = 1;
  }
  return this._correlationCounter;
};

BaseSMFClient.SMF_MAX_CORRELATION = 0xFFFFFF;


module.exports.BaseSMFClient = BaseSMFClient;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var HTTPLib = __webpack_require__(85);
var ref = __webpack_require__(246);
var StateBase64 = ref.StateBase64;
var ref$1 = __webpack_require__(247);
var StateBinary = ref$1.StateBinary;
var ref$2 = __webpack_require__(248);
var StateStreamingAndBinary = ref$2.StateStreamingAndBinary;
var ref$3 = __webpack_require__(249);
var StateWebSocketBinary = ref$3.StateWebSocketBinary;
var ref$4 = __webpack_require__(252);
var WebTransport = ref$4.WebTransport;
var ref$5 = __webpack_require__(49);
var WebTransportCapabilities = ref$5.WebTransportCapabilities;

var ref$6 = __webpack_require__(9);
var SolclientFactory = ref$6.SolclientFactory;

SolclientFactory.addInitializer(function factoryInitializer() {
  // eslint-disable-next-line global-require
  var https = __webpack_require__(287);
  if (true) {
    // WebSocket transport:
    // use custom agent for client certificate and SSL session resume support
    this.wsSslAgent = new https.Agent({
      keepAlive: false,
    });
  }
});

var HTTPConnection = HTTPLib.HTTPConnection;
var HTTPTransportSession = HTTPLib.HTTPTransportSession;

module.exports.HTTPConnection = HTTPConnection;
module.exports.HTTPTransportSession = HTTPTransportSession;
module.exports.StateBase64 = StateBase64;
module.exports.StateBinary = StateBinary;
module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
module.exports.StateWebSocketBinary = StateWebSocketBinary;
module.exports.WebTransport = WebTransport;
module.exports.WebTransportCapabilities = WebTransportCapabilities;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(142);
var HTTPConnection = ref.HTTPConnection;
var ref$1 = __webpack_require__(244);
var HTTPTransportSession = ref$1.HTTPTransportSession;

if (false) {
  module.exports.HTTPConnection = HTTPConnection;
  module.exports.HTTPTransportSession = HTTPTransportSession;
}


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationUtilLib = __webpack_require__(26);
var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(50);
var Destination = ref$1.Destination;
var ref$2 = __webpack_require__(25);
var DestinationType = ref$2.DestinationType;

/**
 * @classdesc
 * Represents a Queue, which is a type of {@link solace.Destination}.
 *
 * Instances should be acquired through
 * {@link solace.SolclientFactory.createDurableQueueDestination} or by calling
 * {@link solace.MessageConsumer#getDestination} on a consumer bound to a temporary queue.
 *
 * @extends solace.Destination
 * @memberof solace
 * @private
 */
var Queue = (function (Destination) {
  function Queue(spec) {
    assert(spec.name, 'Queue name not supplied');
    assert(spec.type === DestinationType.QUEUE
           || spec.type === DestinationType.TEMPORARY_QUEUE, 'Queue spec.type is invalid');
    assert(spec.bytes, 'Queue spec missing bytes');
    assert(spec.offset !== undefined, 'Queue spec missing offset');
    Destination.call(this, spec);
  }

  if ( Destination ) Queue.__proto__ = Destination;
  Queue.prototype = Object.create( Destination && Destination.prototype );
  Queue.prototype.constructor = Queue;

  var prototypeAccessors = { offset: {} };

  Queue.prototype.getOffset = function getOffset () {
    return this._offset;
  };
  prototypeAccessors.offset.get = function () {
    return this.getOffset();
  };

  Queue.prototype[util.inspect.custom] = function () {
    return ("[Queue " + (this.getName()) + "]");
  };

  /**
   * @static
   * @param {String} queueName The name of the queue (no prefix)
   * @returns {Queue} a Queue
   * @private
   */
  Queue.createFromLocalName = function createFromLocalName (queueName) {
    var encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(
      DestinationType.QUEUE, queueName);
    if (encoding.error) {
      throw encoding.error;
    }
    return new Queue({
      name:         queueName,
      type:         DestinationType.QUEUE,
      isValidated:  true,
      bytes:        encoding.bytes,
      offset:       encoding.offset,
      isWildcarded: encoding.isWildcarded,
    });
  };

  Object.defineProperties( Queue.prototype, prototypeAccessors );

  return Queue;
}(Destination));

module.exports.Queue = Queue;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationUtilLib = __webpack_require__(26);
var util = __webpack_require__(6);
var ref = __webpack_require__(50);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(25);
var DestinationType = ref$1.DestinationType;

/**
 * @classdesc
 * Represents a Topic, which is a type of {@link solace.Destination}.
 *
 * @extends solace.Destination
 * @memberof solace
 * @deprecated since 10.0 Applications should not directly refer to this type.
 *  {@link solace.Destination} provides the full interface available to topic, and it can be
 *  determined whether the destination represents a topic if {@link solace.Destination#getType}
 *  returns {@link solace.DestinationType.TOPIC}.
 */
var Topic = (function (Destination) {
  function Topic(spec) {
    if (typeof spec === 'object') {
      Destination.call(this, {
        type:         DestinationType.TOPIC,
        name:         spec.name,
        bytes:        spec.bytes,
        offset:       spec.offset,
        isValidated:  spec.isValidated,
        isWildcarded: spec.isWildcarded,
      });
    } else {
      // Deprecated path -- super will do topic encode
      Destination.call(this, spec, DestinationType.TOPIC);
    }
  }

  if ( Destination ) Topic.__proto__ = Destination;
  Topic.prototype = Object.create( Destination && Destination.prototype );
  Topic.prototype.constructor = Topic;

  Topic.prototype[util.inspect.custom] = function () {
    return ("[Topic " + (this.getName()) + "]");
  };

  /**
   * @static
   * @param {String} topicName The name for the topic
   * @returns {Topic} the Topic
   * @private
   */
  Topic.createFromName = function createFromName (topicName) {
    var encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(
      DestinationType.TOPIC, topicName);
    if (encoding.error) {
      throw encoding.error;
    }
    return new Topic({
      name:         topicName,
      isValidated:  true,
      bytes:        encoding.bytes,
      offset:       encoding.offset,
      isWildcarded: encoding.isWildcarded,
    });
  };

  return Topic;
}(Destination));

module.exports.Topic = Topic;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(52);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown by the API when an operational error is encountered.
 * @memberof solace
 * @extends {solace.SolaceError}
 * @hideconstructor
 */
var OperationError = (function (SolaceError) {
  function OperationError(message, subcode, reason) {
    /**
     * The name of the error.
     * @name solace.OperationError#name
     * @type {Constant}
     * @description 'OperationError'
     */
    SolaceError.call(this, 'OperationError', message, OperationError);
    /**
     * The subcode for the error. @see {@link solace.ErrorSubcode}
     * @name solace.OperationError#subcode
     * @type {solace.ErrorSubcode}
     */
    this.subcode = subcode;
    /**
     * The reason for the error: an embedded error object or exception.
     * @name solace.OperationError#reason
     * @type {Object}
     */
    this.reason = reason;
  }

  if ( SolaceError ) OperationError.__proto__ = SolaceError;
  OperationError.prototype = Object.create( SolaceError && SolaceError.prototype );
  OperationError.prototype.constructor = OperationError;

  return OperationError;
}(SolaceError));

module.exports.OperationError = OperationError;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An attribute of {@link solace.RequestError}. This enumeration represents the
 * different errors emitted by
 * {@link solace.Session.requestFailedCallback}
 * when a {@link solace.Sesssion#sendRequest} fails.
 *
 * The client application receives a request error with event code
 * {@link solace.RequestEventCode.REQUEST_ABORTED}
 * when the underlying connection is successfully closed, or closed as a result
 * of a communication error.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var RequestEventCode = {
  /**
   * A request was aborted because the session is disconnected.
   */
  REQUEST_ABORTED: 8,
  /**
   * The event represents a timed-out request API call.
   */
  REQUEST_TIMEOUT: 9,
};

module.exports.RequestEventCode = Enum.new(RequestEventCode);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

var DEFAULT_PROPERTY_OPTIONS = {
  enumerable: true,
};

function setPropertyValue(target, key, value, options) {
  if ( options === void 0 ) options = null;

  Object.defineProperty(
          target,
          key,
          Object.assign({ value: value }, DEFAULT_PROPERTY_OPTIONS, options));
}


function lazyProperty(target, key, evalFn) {
  Object.defineProperty(
    target,
    key,
    Object.assign({
      configurable: true, // Allow replacing this property with resolved value.
      get:          function () {
        // The getter evaluates the function provided.
        // It replaces itself with the value it resolves.
        var result = evalFn(target, key);
        setPropertyValue(target, key, result);
        return result;
      },
      set: function (value) {
        setPropertyValue(target, key, value);
      },
    }, DEFAULT_PROPERTY_OPTIONS));
  return target;
}

function lazyProperties(target, obj) {
  Object.keys(obj).forEach(function (k) {
    lazyProperty(target, k, obj[k]);
  });
  return obj;
}

function lazyValue(evalFn) {
  return lazyProperty({}, 'value', evalFn);
}

var Lazy = {
  lazyProperties: lazyProperties,
  lazyProperty: lazyProperty,
  lazyValue: lazyValue,
};

module.exports.Lazy = Lazy;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var OperationError = ref.OperationError;

var binding = null;

var ProfileBinding = {
  get value() {
    if (binding === null) {
      throw new OperationError('Profile binding not initialized. Call solace.SolclientFactory.init');
    }
    return binding;
  },
  set value(value) {
    // private, so we'll allow it for testing
    binding = value;
  },
};

module.exports.ProfileBinding = ProfileBinding;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);

// Preferred configuration for the profile system:

// End user:
//  opaque profiles, property-style access
// API implementation:
//  inherited properties, property-style access
// A root, forward compatible profile
// A legacy, backwards compatible profile
// Feature/milestone profiles that inherit from one of these two configurations

// The lowest-friction way of doing this is using prototype inheritance.
// Also considered:
//  getProperty() with child->parent pointers -- mixes string
//    and property access
//  ES6 proxies -- not universal and not shimmable

// Necessary to abuse prototype inheritance for static property inheritance:
/* eslint-disable class-methods-use-this */

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactoryProfiles}.</b>
 *
 * A factory profile determines the default functionality of the API. Profiles are predefined
 * combinations of capabilities that represent a mutually-consistent, valid configuration state
 * for API features.
 *
 * The factory may be initialized exactly once, with a single factory profile.
 *
 * Changing which factory profile is used by {@link solace.SolclientFactory.init} may result in
 * different default property values, validation, function signatures and implementations.
 *
 * Changing the factory profile will not change relationships between API methods. That is,
 * assuming all properties and arguments are explicitly set, an application may call the
 * API with the same values as before to cause the same result, unless explicitly noted.
 *
 * If no profile is specified, the default will provide equivalent functionality to
 * SolclientJS version 7.x. New applications are encouraged to use the
 * {@link solace.SolclientFactoryProfiles.version10} profile for the best compatibility with
 * other APIs (excluding 7.x JavaScript APIs).
 *
 * @memberof solace
 * @private
 */
var FactoryProfile = function FactoryProfile () {};

var prototypeAccessors = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

prototypeAccessors.guaranteedMessagingEnabled.get = function () { return undefined; };

/**
 * Returns whether the API will allow Comet (long-held HTTP request) transports
 * to be used. If this is `true`, transport protocols may fall back to HTTP
 * if a connection cannot be established with a preferred protocol.
 *
 ** NOTE: Guaranteed Messaging cannot be enabled if Comet is enabled.
 *
 * @type {Boolean}
 * @readonly
 * @target browser
 */
prototypeAccessors.cometEnabled.get = function () { return undefined; };

/**
 * Returns whether the API performs UTF-8 encoding on user strings where the SMF
 * spec requires it.
 ** When this is `true`, the API will correctly interoperate with other Solace APIs that send
 *  UTF-8 encoded topics.
 ** When this is `false`, the API will interoperate correctly with 7.x and earlier JavaScript
 *  APIs, that used an arbitrary encoding for such strings.
 *
 * @readonly
 */
prototypeAccessors.topicUtf8Encode.get = function () { return undefined; };

FactoryProfile.prototype[util.inspect.custom] = function () {
  return {
    'guaranteedMessagingEnabled': this.guaranteedMessagingEnabled,
    'cometEnabled':             this.cometEnabled,
    'topicUtf8Encode':          this.topicUtf8Encode,
  };
};

FactoryProfile.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( FactoryProfile.prototype, prototypeAccessors );

/**
 * The Version 7 profile for SolclientJS. This profile sets factory and session default values
 * that provide SolclientJS 7.x behaviour, and interoperability with SolclientJS 7.x clients.
 *
 * @namespace
 * @type {solace.FactoryProfile}
 * @name version7
 * @memberof solace.SolclientFactoryProfiles
 */
var Version7Profile = (function (FactoryProfile) {
  function Version7Profile () {
    FactoryProfile.apply(this, arguments);
  }

  if ( FactoryProfile ) Version7Profile.__proto__ = FactoryProfile;
  Version7Profile.prototype = Object.create( FactoryProfile && FactoryProfile.prototype );
  Version7Profile.prototype.constructor = Version7Profile;

  var prototypeAccessors$1 = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

  prototypeAccessors$1.guaranteedMessagingEnabled.get = function () { return !!true; };

  /**
   * Returns true: Comet HTTP transports are enabled for the API. The API user may, by default,
   * select Comet HTTP transport protocol, and the API may fall back to these protocols during a
   * connection attempt.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
  /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
  prototypeAccessors$1.cometEnabled.get = function () { return !!false; };
  /**
   * Returns false: topic UTF-8 encoding is disabled for the API. The network encoding of topics is
   * compatible with other SolclientJS 7.x clients, and may not be interoperable with other
   * Solace Messaging APIs.
   *
   * @name solace.SolclientFactoryProfiles.version7.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
  prototypeAccessors$1.topicUtf8Encode.get = function () { return false; };

  Object.defineProperties( Version7Profile.prototype, prototypeAccessors$1 );

  return Version7Profile;
}(FactoryProfile));
var legacyInstance = new Version7Profile();

/**
 * The Version 10 profile for SolclientJS. This profile sets factory and session default values
 * that provide the full capability of the API as of version 10.0, including interoperability with
 * other Solace Messaging products.
 *
 * @namespace
 * @name version10
 * @memberof solace.SolclientFactoryProfiles
 */
var Version10Profile = (function (FactoryProfile) {
  function Version10Profile () {
    FactoryProfile.apply(this, arguments);
  }

  if ( FactoryProfile ) Version10Profile.__proto__ = FactoryProfile;
  Version10Profile.prototype = Object.create( FactoryProfile && FactoryProfile.prototype );
  Version10Profile.prototype.constructor = Version10Profile;

  var prototypeAccessors$2 = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

  prototypeAccessors$2.guaranteedMessagingEnabled.get = function () {
    return true;
  };
  /**
   * Returns `false`: Comet HTTP transports are disabled for the API. The API will not select or
   * fall back to HTTP Comet transport protocols, which are mutually exclusive of Guaranteed
   * Messaging features.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
  /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
  prototypeAccessors$2.cometEnabled.get = function () {
    return false;
  };
  /**
   * Returns `true`: the API will encode topics for interoperability with other Solace Messaging
   * products. SolclientJS 7.x clients may fail to correctly decode when topic names that include
   * multi-byte UTF-8 code points.
   *
   * @name solace.SolclientFactoryProfiles.version10.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
  prototypeAccessors$2.topicUtf8Encode.get = function () {
    return true;
  };

  Object.defineProperties( Version10Profile.prototype, prototypeAccessors$2 );

  return Version10Profile;
}(FactoryProfile));
var forwardInstance = new Version10Profile();

/**
 * The collection of predefined factory profiles available for application use.
 *
 * See each member for a description of its configuration.
 *
 * @namespace
 * @memberof solace
 */
var SolclientFactoryProfiles = {
  _legacy:  legacyInstance,
  _forward: forwardInstance,
  _default: legacyInstance,

  /**
   * The version 7 profile for browsers. {@link solace.SolclientFactoryProfiles.version7}
   *
   * The version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @type {solace.FactoryProfile}
   * @target browser
   */
  /**
   * The version 7 profile for Node.JS. {@link solace.SolclientFactoryProfiles.version7}
   *
   * A version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @type {solace.FactoryProfile}
   * @target node
   */
  version7: legacyInstance,

  /**
   * The version 10 profile for browsers.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @type {solace.FactoryProfile}
   * @target browser
   */
  /**
   * The version 10 profile for Node.JS.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @type {solace.FactoryProfile}
   * @target node
   */
  version10: forwardInstance,

  toString: function toString() {
    return util.inspect(this);
  },
};
SolclientFactoryProfiles[util.inspect.custom] = function () {
    return {
      'version7':  this.version7,
      'version10': this.version10,
    };
  };

module.exports.FactoryProfile = FactoryProfile;
module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;

function getDefaultLogLevel() {
  // break dependency loop
  // eslint-disable-next-line global-require
  var ref = __webpack_require__(1);
  var LogLevel = ref.LogLevel;
  return LogLevel.INFO;
}

/**
 * @classdesc
 * Properties used during initialization of {@link solace.SolclientFactory}.
 *
 * @memberof solace
 */
var SolclientFactoryProperties = (function (APIProperties) {
  function SolclientFactoryProperties(options) {
    APIProperties.call(this, {
      logLevel: getDefaultLogLevel(),
      logger:   null,
    }, options);
  }

  if ( APIProperties ) SolclientFactoryProperties.__proto__ = APIProperties;
  SolclientFactoryProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  SolclientFactoryProperties.prototype.constructor = SolclientFactoryProperties;

  var prototypeAccessors = { profile: {},logLevel: {},logger: {} };

  /**
   * The factory profile to use. The following factory profiles are available:
   * * {@link solace.SolclientFactoryProfiles.version7}, a backwards-compatible profile
   *      for existing solClientJS 7.x applications
   * * {@link solace.SolclientFactoryProfiles.version10}, the recommended profile
   *      for new applications
   *
   * @type {solace.FactoryProfiles}
   */
  prototypeAccessors.profile.get = function () {
    return this._profile;
  };
  prototypeAccessors.profile.set = function (profile) {
    this._profile = profile;
  };

  /**
   * The logging level to use for filtering log events. Messages with a level of lesser importance
   * than this will be filtered out and not logged.
   * @type {solace.LogLevel}
   */
  prototypeAccessors.logLevel.get = function () {
    return Check.number(this._logLevel) ? this._logLevel : getDefaultLogLevel();
  };
  prototypeAccessors.logLevel.set = function (val) {
    this._logLevel = val;
  };

  /**
   * The logging implementation to use. In the debug API, the log implementation will be called
   * for every log statement not filtered out by the log level. If no implementation is supplied,
   * the default implementation will be used, which logs to the global console object.
   * @type {solace.LogImpl}
   */
  prototypeAccessors.logger.get = function () {
    return this._logger || null;
  };
  prototypeAccessors.logger.set = function (val) {
    this._logger = val;
  };

  SolclientFactoryProperties.prototype[util.inspect.custom] = function () {
    // break dependency loop
    // eslint-disable-next-line global-require
    var ref = __webpack_require__(1);
    var LogLevel = ref.LogLevel;
    return {
      'logLevel': LogLevel.describe(this._logLevel),
      'profile':  this._profile,
    };
  };

  SolclientFactoryProperties.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( SolclientFactoryProperties.prototype, prototypeAccessors );

  return SolclientFactoryProperties;
}(APIProperties));

module.exports.SolclientFactoryProperties = SolclientFactoryProperties;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var FlowOperation = {
  CONNECT:         'FlowOperation_CONNECT',
  DISCONNECT:      'FlowOperation_DISCONNECT',
  START:           'FlowOperation_START',
  STOP:            'FlowOperation_STOP',
  DISPOSE:         'FlowOperation_DESTROY',
  GET_STATS:       'FlowOperation_GET_STATS',
  RESET_STATS:     'FlowOperation_RESET_STATS',
  GET_PROPERTIES:  'FlowOperation_GET_PROPERTIES',
  GET_DESTINATION: 'FlowOperation_GET_DESTINATION',
};

module.exports.FlowOperation = Enum.new(FlowOperation);


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var PrivateFlowEventName = {
  BIND_WAITING: 'PrivateFlowEventName_bindWaiting',
};

module.exports.PrivateFlowEventName = Enum.new(PrivateFlowEventName);


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;
var ref$1 = __webpack_require__(0);
var Iterator = ref$1.Iterator;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;

var makeIterator = Iterator.makeIterator;

/**
 * React to an event.
 * @callback StateContext.reactionCallback
 * @param {FsmEvent} event The event to react to.
 * @returns {StateContext.ReactionResult} One of the many possible
 *      reaction results that can be created by one of the following methods:
 *          - {@link StateContext#transitionTo}
 *          - {@link FsmState#internalTransition}
 *          - {@link FsmState#externalTransitionTo}
 *          - {@link FsmState#terminate}
 *          - {@link FsmState#eventUnhandled}
 */


/**
 * @classdesc
 * This abstract class can host one or more states.  Concrete examples would
 * be a state, which can host one or more inner states, or a state machine,
 * which would typically have multiple top-level states.  It also serves as a
 * context in which transitions can occur.
 * @memberof solace
 * @private
 */
var StateContext = (function (FsmObject) {
  function StateContext(spec) {
    FsmObject.call(this, spec);
    this.impl = this.impl || {};
    this.impl.logPadding = '';
  }

  if ( FsmObject ) StateContext.__proto__ = FsmObject;
  StateContext.prototype = Object.create( FsmObject && FsmObject.prototype );
  StateContext.prototype.constructor = StateContext;

  /**
   * Gets the state-machine that hosts this state context.
   * @returns {StateMachine} The FSM that hosts this context.
   */
  StateContext.prototype.getStateMachine = function getStateMachine () {
    return this.impl.ancestorList[0];
  };

  /**
   * Sets the initial reaction for the state context.
   * @param {StateContext.reactionCallback} func The reaction callback to be
   *      called after the state is entered as the deepest state of a
   *      transition, or for a state machine when it is started.
   * @returns {StateContext} The object this function was called on
   */
  StateContext.prototype.initial = function initial (func) {
    if (this.impl.initialReaction) {
      this.log(("Replacing " + (this) + " initialReaction " + (this.impl.initialReaction) + " with " + func));
    }
    this.impl.initialReaction = func.bind(this);
    return this;
  };

  /**
   * This is used for 'local' transitions.  However, we extend the formal
   * definition of local transitions here.  The formal definition is that
   * the dest state is within the src state, and the src state is not
   * exited.  We extend this definition to include states where the src
   * state is within dest. In this case, a local transition means that dest
   * will not be exited and entered and the transition will occur in the
   * context of dest before executing dest's initial transition.  Note that
   * this definition of local transition matches that of
   * {@link https://en.wikipedia.org/wiki/UML_state_machine#Local_versus_external_transitions|Wikipedia}.
   * But it does not match figure 14.34 or section 14.5.12 of the
   * {@link http://www.omg.org/spec/UML/2.5/PDF/|Formal UML Specification v2.5}.
   * Nevertheless, it does seem helpful to be able to express a transition
   * that does leave the destination state vs. a transition that does not.
   *
   * If neither the source nor the dest states are within the other, the
   * behaviour is the same as an external transition -- src is always exited
   * and dest is always entered.
   *
   * This is included in the StateContext instead of within the State itself
   * since this can be used by the initial reaction for a state machine.
   *
   * @param {State} state The state to transition to.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as
   *      part of the transition, if desired.
   * @returns {StateContext.ReactionResult} the result object used
   *      internally for further processing of the event.
   */
  StateContext.prototype.transitionTo = function transitionTo (state, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state,
      action: action,
    });
  };

  /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The reaction result for the termination.
   */
  StateContext.prototype.terminate = function terminate (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getFinalState(),
      action: action,
    });
  };

  /**
   * A callback to execute an action as part of a transition in the
   * appropriate context.
   *
   * To be used only by the FSM infrastructure or unit tests.
   *
   * @callback StateContext.actionCallback
   * @param {StateContext} context The context within which the action is
   *      executed.  When the active state changes, this is done after
   *      states are exited and before states are entered.  It is the
   *      deepest context that contains the last exited and first entered
   *      state as part of the transition.
   * @param {FsmEvent} event The event that triggered the transition.
   * @returns {Array.<StateContext>} The context's ancestor list.
   * @protected
   */
  StateContext.prototype.getAncestorList = function getAncestorList () {
    return this.impl.ancestorList;
  };

  /**
   * Perform a debug log with appropriate padding for the context.  The padding
   * helps to visualize the level within the hierarchical state machine.
   * @protected
   */
  StateContext.prototype.log = function log () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    LOG_TRACE.apply(void 0, [ this.impl.logPadding ].concat( args ));
  };

  /**
   * Called when the initial transition for the context needs to be taken.
   * @param {FsmEvent} [event] The event causing this transition; undefined for the
   *      FSM's initial transition.
   * @returns {StateContext.ReactionResult} the result to be processed by
   *      the FSM infrastructure.
   * @protected
   */
  StateContext.prototype.onInitial = function onInitial (event) {
    var result;

    if (this.impl.initialReaction) {
      this.log(("Initial: for " + (this)));
      result = this.impl.initialReaction(event);
      if (result.external) {
        throw new Error(("Initial reaction for " + (this) + " returned external transitions"));
      }
      return result;
    }

    if (!(this instanceof (StateLib.State))) {
      throw new Error(("Missing initial reaction for " + (this)));
    }

    // If there is no initial reaction, then we just enter this state.
    // Technically this is a malformed FSM if there are inner states and
    // this state has no initial reaction.  We won't police this since it
    // isn't easily done with the data we are otherwise maintaining (we only
    // know about parent states, not children), and such a problem would be
    // easily caught by testing of the FSM.
    return this.transitionTo(this);
  };

  /**
   * After a reaction function has been called, this function processes the
   * returned {@link StateContext.ReactionResult}.
   * @param {StateContext.ReactionResult} result The result of a reaction.
   * @param {FsmEvent|undefined} e The event that triggered the reaction;
   *      undefined if this was due to the initial reaction.
   * @returns {State} The active state of the FSM after the ReactionResult was
   *      processed.
   * @protected
   */
  StateContext.prototype.processReactionResult = function processReactionResult (result, e) {
    var curContext = this;

    if (!result.destState) {
      return this;
    }

    var destStateIter = this.lowestCommonAncestor(result);

    // exit states until we get to the LCA
    while (curContext !== destStateIter.deref()) {
      curContext.onExit();
      curContext = curContext.getParent();
    }

    // perform the transition
    if (result.action) {
      result.action(curContext, e);
    }

    curContext.log(("Action: transition to " + (result.destState) + " in context " + curContext));

    // Start by incrementing the iterator so we don't enter the
    // context, which we are already in.  Then enter remaining states
    // in the list.
    for (destStateIter.incr(); !destStateIter.end(); destStateIter.incr()) {
      curContext = destStateIter.deref();
      curContext.onEntry();
    }

    // execute the initial transition in the destState.
    var destInitial = curContext.onInitial(e);
    if (destInitial.destState !== curContext) {
      return curContext.processReactionResult(destInitial, e);
    }
    return curContext;
  };

  /**
   * For a given reactionResult, this function returns an iterator to the
   * context in which to process a transition from 'self' to
   * 'reactionResult.destState'.  Advancing the iterator provides the states
   * that need to be entered after the transition is processed.
   * @param {ReactionResult} reactionResult An object created with one of the
   *                                        reaction result methods defined in
   *                                        either a state context or a state.
   * @returns {Iterator} The iterator where the first element is the
   * context in which to execute the transaction, and subsequent elements are
   * to be entered after executing the transaction.
   * @protected
   */
  StateContext.prototype.lowestCommonAncestor = function lowestCommonAncestor (reactionResult) {
    var ancestorList = this.impl.ancestorList;
    var destAncestorList = reactionResult.destState.getAncestorList();
    var i;

    // Make sure the states belong to the same state machine
    if (ancestorList[0] !== destAncestorList[0]) {
      throw new Error(("No common ancestor between (" + (this) + " in " + (ancestorList[0]) + ") and (" + (reactionResult.destState) + " in " + (destAncestorList[0]) + ")"));
    }

    // Optimize case where the two states are the same.  This would be the
    // case for internal and self-transitions.
    if (this === reactionResult.destState) {
      i = ancestorList.length;
      if (reactionResult.external) {
        // self-transition, must exit then re-enter state.  Therefore,
        // the context is our parent.
        --i;
      }
    } else {
      for (i = 1; i < ancestorList.length; ++i) {
        if (ancestorList[i] !== destAncestorList[i]) {
          break;
        }
      }

      // Check if one state is within the other state.
      if ((i === ancestorList.length) || (i === destAncestorList.length)) {
        // One state within the other. Check whether this is a local
        // or an external transition.
        if (reactionResult.external) {
          --i;    // Need to exit/re-enter the outermost state
        }
      }
    }

    // Here 'i' points to the first state to be entered after executing the
    // transition.  We make the iterator with 'i-1' so that the first element
    // is the context within which to execute the transition.
    return makeIterator(destAncestorList, i - 1);
  };

  StateContext.prototype.setLogPadding = function setLogPadding (padding) {
    this.impl.logPadding = padding;
  };

  return StateContext;
}(FsmObject));

/**
 * @classdesc
 * A ReactionResult is suitable as a return value from a reaction function
 * or an initial reaction.
 * @private
 */
StateContext.ReactionResult = (function () {
  function undefined(spec) {
    if (!spec || !spec.caller || !(spec.caller instanceof StateContext)) {
      throw new Error('spec.caller is required to be a StateContext');
    }

    if (!spec.caller.getStateMachine().isRunning()) {
      throw new Error('ReactionResult objects can only be created while processing events');
    }
    if (spec.destState) {
      if (!(spec.destState instanceof StateLib.State)) {
        throw new Error('destState must be a State object');
      }
      if (spec.action && (typeof (spec.action) !== 'function')) {
        throw new Error('action must be a function');
      }
      this.destState = spec.destState;
      this.action = spec.action;
      this.external = spec.external;
    }
  }

  return undefined;
}());

module.exports.StateContext = StateContext;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/* eslint-disable class-methods-use-this */ // declare prototype stubs

/**
 * A logging callback. It must accept any valid number of arguments of any type. It must not throw.
 *
 * @callback
 * @function
 * @name solace.LogImpl.loggingCallback
 * @param {...*} args The arguments to log. Typically this is a mixture of strings and
 *  objects to be inspected. A simple implementation might call .toString() on each
 *  argument.
 */

/**
 * @classdesc
 * A class that provides a binding to a log implementation. Applications that need to
 * control API logging must construct a LogImpl
 * instance, a log implementation that can be set in
 * {@link solace.SolclientFactoryProperties#logger}.
 * The binding will call the supplied log methods with the
 * parameters supplied to each.
 * @memberof solace
 */
var LogImpl = function LogImpl(trace, debug, info, warn, error, fatal) {
  Object.assign(this, {
    trace: trace,
    debug: debug,
    info: info,
    warn: warn,
    error: error,
    fatal: fatal,
  });
};

LogImpl.prototype.trace = function trace () {};
LogImpl.prototype.debug = function debug () {};
LogImpl.prototype.info = function info () {};
LogImpl.prototype.warn = function warn () {};
LogImpl.prototype.error = function error () {};
LogImpl.prototype.fatal = function fatal () {};

module.exports.LogImpl = LogImpl;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents a log level enumeration.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var LogLevel = {
  /**
   * Fatal. Rserved for unrecoverable errors.
   * @type {Number}
   */
  FATAL: 0,
  /**
   * Error. An internal error to the API or Solace Message Router.
   * @type {Number}
   */
  ERROR: 1,
  /**
   * Warn. An external error which may be caused by the application passing invalid
   * arguments or objects to the API. Often accompanied by an thrown exception.
   * @type {Number}
   */
  WARN:  2,
  /**
   * Info. An unexpected event or occurrence that does not affect the sane
   * operation of the SDK or application.
   * @type {Number}
   */
  INFO:  3,
  /**
   * Debug. The highest (least) level of debug logs. Debug logs provide an overview of
   * the API operation.
   * @type {Number}
   */
  DEBUG: 4,
  /**
   * Trace. The loweest (most verbose) level of debug logs.
   * @type {Number}
   */
  TRACE: 5,
};

module.exports.LogLevel = Enum.new(LogLevel);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(185);
var ConsumerFlows = ref.ConsumerFlows;
var ref$1 = __webpack_require__(54);
var ConsumerFSMEvent = ref$1.ConsumerFSMEvent;
var ref$2 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$2.ConsumerFSMEventNames;
var ref$3 = __webpack_require__(101);
var MessageConsumer = ref$3.MessageConsumer;
var ref$4 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$4.MessageConsumerAcknowledgeMode;
var ref$5 = __webpack_require__(28);
var MessageConsumerEventName = ref$5.MessageConsumerEventName;
var ref$6 = __webpack_require__(100);
var MessageConsumerProperties = ref$6.MessageConsumerProperties;

module.exports.ConsumerFlows = ConsumerFlows;
module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
module.exports.ConsumerFSMEventNames = ConsumerFSMEventNames;
module.exports.MessageConsumer = MessageConsumer;
module.exports.MessageConsumerAcknowledgeMode = MessageConsumerAcknowledgeMode;
module.exports.MessageConsumerEventName = MessageConsumerEventName;
module.exports.MessageConsumerProperties = MessageConsumerProperties;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var QueueLib = __webpack_require__(18);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$2.MessageConsumerAcknowledgeMode;
var ref$3 = __webpack_require__(5);
var Topic = ref$3.Topic;

var DEFAULTS = {
  queueDescriptor:           undefined,
  queueProperties:           undefined,
  connectTimeoutInMsecs:     10000,
  connectAttempts:           3,
  topicEndpointSubscription: undefined,
  // selector: undefined,
  acknowledgeMode:           MessageConsumerAcknowledgeMode.AUTO,
  acknowledgeTimeoutInMsecs: 1000,
  acknowledgeThreshold:      60,
  activeIndicationEnabled:   false,
  noLocal:                   false,
  windowSize:                255,
};

/**
 * @classdesc
 * Defines the properties for a {@link solace.MessageConsumer}.
 *
 * @memberof solace
 */
var MessageConsumerProperties = (function (APIProperties) {
  function MessageConsumerProperties(options) {
    APIProperties.call(this, DEFAULTS, options);
  }

  if ( APIProperties ) MessageConsumerProperties.__proto__ = APIProperties;
  MessageConsumerProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  MessageConsumerProperties.prototype.constructor = MessageConsumerProperties;

  var prototypeAccessors = { queueDescriptor: {},queueProperties: {},connectTimeoutInMsecs: {},connectAttempts: {},topicEndpointSubscription: {},acknowledgeMode: {},acknowledgeTimeoutInMsecs: {},acknowledgeThreshold: {},activeIndicationEnabled: {},noLocal: {},windowSize: {} };

  /**
   * Defines the queue from which to consume.
   *  * For durable queues and durable topic endpoints, this must be a
   *    {@link solace.QueueDescriptor}.
   *  * When an {@link solace.AbstractQueueDescriptor} is used, the name is generated when
   *    the {@link solace.MessageConsumer} is connected. The generated descriptor can be queried
   *    from the consumer after it has successfully connected by calling
   *    {@link solace.MessageConsumer#getQueueDescriptor}.
   * @type {solace.QueueDescriptor}
   */
  prototypeAccessors.queueDescriptor.get = function () {
    return Check.something(this._queueDescriptor)
      ? this._queueDescriptor
      : DEFAULTS.queueDescriptor;
  };
  prototypeAccessors.queueDescriptor.set = function (value) {
    if (value instanceof QueueLib.AbstractQueueDescriptor) {
      this._queueDescriptor = value;
    } else if (value) {
      this._queueDescriptor = value.name
        ? new QueueLib.QueueDescriptor(value)
        : new QueueLib.AbstractQueueDescriptor(value);
    } else {
      this._queueDescriptor = value;
    }
  };

  /**
   * Gets the properties of the remote queue.
   *  * For temporary queues and temporary topic endpoints, these properties define the queue that
   *    is created.
   *  * For durable queues, these must be unset on consumer creation. The values will be populated
   *    after the queue is connected and can be retrieved by calling
   *    {@link solace.MessageConsumer.#getQueueProperties}.
   * @type {solace.QueueProperties}
   */
  prototypeAccessors.queueProperties.get = function () {
    return Check.something(this._queueProperties)
      ? this._queueProperties
      : DEFAULTS.queueProperties;
  };
  prototypeAccessors.queueProperties.set = function (value) {
    if (value) {
      this._queueProperties = new QueueLib.QueueProperties(value);
    } else {
      this._queueProperties = value;
    }
  };

  // ------------ Properties controlling connection of the consumer ----------------
  /**
   * The bind timeout in milliseconds when creating a connection to the Solace Message Router.
   *  * The valid range is >= 50.
   * @type {Number}
   * @default 10000
   */
  prototypeAccessors.connectTimeoutInMsecs.get = function () {
    return Check.something(this._bindTimeoutInMsecs)
      ? this._bindTimeoutInMsecs
      : DEFAULTS.connectTimeoutInMsecs;
  };
  prototypeAccessors.connectTimeoutInMsecs.set = function (value) {
    this._bindTimeoutInMsecs = value;
  };

  /**
   * Gets and sets the maximum number of bind attempts when creating a connection to the
   * Solace Message Router.
   *  * The valid range is >= 1.
   * @type {Number}
   * @default 3
   */
  prototypeAccessors.connectAttempts.get = function () {
    return Check.something(this._connectAttempts)
      ? this._connectAttempts
      : DEFAULTS.connectAttempts;
  };
  prototypeAccessors.connectAttempts.set = function (val) {
    this._connectAttempts = val;
  };

  // ------------ Properties applied to the queue when connecting ----------------

  /**
   * This must be undefined if
   * {@link solace.MessageConsumerProperties#queueDescriptor#type} is not
   * {solace.QueueType.TOPIC_ENDPOINT}.
   *
   * If {@link solace.MessageConsumerProperties#queueDescriptor#durable} is
   * false, this may be left undefined to generate the topic endpoint's
   * destination. When generated, the destination can be obtained from
   * the {solace.MessageConsumer} after it is connected by calling
   * {@link solace.MessageConsumer#getDestination}.
   *
   * @type {solace.Destination}
   * @default undefined
   */
  prototypeAccessors.topicEndpointSubscription.get = function () {
    return this._topicEndpointSubscription;
  };
  prototypeAccessors.topicEndpointSubscription.set = function (val) {
    // Avoid instanceof check failing on Node 4?
    if (typeof val === 'string') {
      this._topicEndpointSubscription = Topic.createFromName(val);
    } else {
      this._topicEndpointSubscription = val;
    }
  };

  // ----------- Properties controlling an established connection to a queue --------------

  /**
   * The Application Acknowledgement mode for the Message Consumer.
   *
   * When the acknowledgement mode is {@link solace.MessageConsumerAcknowledgeMode.CLIENT},
   * a message is Application Acknowledged when the application calls
   * {@link solace.Message#acknowledge} on that message.
   *
   * When the acknowledge mode is {@link solace.MessageConsumerAcknowledgeMode.AUTO}, a message is
   * Application Acknowledged by the API after all
   * {@link solace.MessageConsumerEventName#event:MESSAGE}
   * listeners are called and none throw an exception. If a message handler throws, the message
   * can still be acknowledged by calling {@link solace.Message#acknowledge}, but this would not be
   * a recommended practice.
   *
   * When received messages are Application Acknowledged they are removed from the Guaranteed
   * Message storage on the Solace Message Router. Message Consumer Application Acknowledged,
   * <b>only</b> remove messages from the Solace Message Router.
   *
   * In particular, withholding Message Consumer Acknowledgemnts does not stop
   * message delivery. For Message Consumer flow control (aka transport acknowledgemeent) see
   * {@link solace.MessageConsumer.stop}/{@link solace.MessageConsumer.start}. Message Consumer
   * flow control may also be imlpemented by removing the
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
   *
   * Flow control and transport acknowledgements characteristics are defined by
   * {@link solace.MessageConsumerProperties.acknowledgeThreshold} and
   * {@link solace.MessageConsumerProperties.acknowledgeTimeoutInMsecs}
   *
   * @type {solace.MessageConsumerAcknowledgeMode}
   * @default solace.MessageConsumerAcknowledgeMode.AUTO
   */
  prototypeAccessors.acknowledgeMode.get = function () {
    return Check.something(this._acknowledgeMode)
      ? this._acknowledgeMode
      : DEFAULTS.acknowledgeMode;
  };
  prototypeAccessors.acknowledgeMode.set = function (value) {
    this._acknowledgeMode = value;
  };

  /**
   * The transport acknowledgement timeout for guaranteed messaging.
   * When the {@link solace.MessageConsumerProperties.acknowledgeThreshold} is not exceeded,
   * acknowledgements will be returned to the router at intervals not less than
   * this value.
   *   * The valid range is 20 <= acknowledgeTimeoutInMsecs <= 1500.
   * @type {Number}
   * @default 1000
   */
  prototypeAccessors.acknowledgeTimeoutInMsecs.get = function () {
    return Check.something(this._acknowledgeTimeoutInMsecs)
      ? this._acknowledgeTimeoutInMsecs
      : DEFAULTS.acknowledgeTimeoutInMsecs;
  };
  prototypeAccessors.acknowledgeTimeoutInMsecs.set = function (val) {
    this._acknowledgeTimeoutInMsecs = val;
  };

  /**
   * The threshold for sending an acknowledgement, as a percentage.
   * The API sends a transport acknowledgment every
   * N messages where N is calculated as this percentage of the transport
   * window size if the endpoint's max-delivered-unacked-msgs-per-flow
   * setting at bind time is greater than or equal to the transport
   * window size. Otherwise, N is calculated as this percentage of the
   * endpoint's max-delivered-unacked-msgs-per-flow setting at bind time.
   * * The valid range is 1 <= acknowledgeThreshold <= 75.
   * @type {Number}
   * @default 60
   */
  prototypeAccessors.acknowledgeThreshold.get = function () {
    return Check.something(this._acknowledgeThreshold)
      ? this._acknowledgeThreshold
      : DEFAULTS.acknowledgeThreshold;
  };
  prototypeAccessors.acknowledgeThreshold.set = function (value) {
    this._acknowledgeThreshold = value;
  };

  /**
   * @description When enabled, a Guaranteed Messaging Consumer requests Active and Inactive
   * events from the router and emits them to interested listeners.
   * @type {Boolean}
   * @default false
   * @see {solace.MessageConsumerEvent.ACTIVE}
   * @see {solace.MessageConsumerEvent.INACTIVE}
   */
  prototypeAccessors.activeIndicationEnabled.get = function () {
    return Check.something(this._activeIndicationEnabled)
      ? this._activeIndicationEnabled
      : DEFAULTS.activeIndicationEnabled;
  };
  prototypeAccessors.activeIndicationEnabled.set = function (newValue) {
    this._activeIndicationEnabled = newValue;
  };

  /**
   * When enabled, a Guaranteed Messaging Consumer does not receive messages published
   * in the same Session, even if the endpoint contains a subscription that matches the published
   * message.
   * @type {Boolean}
   * @default false
   */
  prototypeAccessors.noLocal.get = function () {
    return Check.something(this._noLocal)
      ? this._noLocal
      : DEFAULTS.noLocal;
  };
  prototypeAccessors.noLocal.set = function (newValue) {
    this._noLocal = newValue;
  };

  /**
   * The window size for Guaranteed Message delivery.  This is the maximum number of messages that
   * will be prefetched from the Solace Messaging Router and queued internally by the API while
   * waiting for the application to accept delivery of the messages.
   *   * The valid range is 1 <= windowSize <= 255.
   * @type {Number}
   * @default 255
   */
  prototypeAccessors.windowSize.get = function () {
    return Check.something(this._windowSize)
      ? this._windowSize :
      DEFAULTS.windowSize;
  };
  prototypeAccessors.windowSize.set = function (val) {
    this._windowSize = val;
  };

  Object.defineProperties( MessageConsumerProperties.prototype, prototypeAccessors );

  return MessageConsumerProperties;
}(APIProperties));

module.exports.MessageConsumerProperties = MessageConsumerProperties;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var util = __webpack_require__(6);
var ref = __webpack_require__(21);
var CapabilityType = ref.CapabilityType;
var ref$1 = __webpack_require__(186);
var ConsumerFSM = ref$1.ConsumerFSM;
var ref$2 = __webpack_require__(54);
var ConsumerFSMEvent = ref$2.ConsumerFSMEvent;
var ref$3 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$3.ConsumerFSMEventNames;
var ref$4 = __webpack_require__(36);
var Flow = ref$4.Flow;
var FlowOperation = ref$4.FlowOperation;
var ref$5 = __webpack_require__(28);
var MessageConsumerEventName = ref$5.MessageConsumerEventName;
var ref$6 = __webpack_require__(100);
var MessageConsumerProperties = ref$6.MessageConsumerProperties;
var ref$7 = __webpack_require__(188);
var MessageConsumerPropertiesValidator = ref$7.MessageConsumerPropertiesValidator;
var ref$8 = __webpack_require__(2);
var OperationError = ref$8.OperationError;
var ErrorSubcode = ref$8.ErrorSubcode;
var ref$9 = __webpack_require__(5);
var Queue = ref$9.Queue;
var Topic = ref$9.Topic;
var ref$10 = __webpack_require__(18);
var QueueAccessType = ref$10.QueueAccessType;
var QueuePermissions = ref$10.QueuePermissions;
var QueueDiscardBehavior = ref$10.QueueDiscardBehavior;


function formatEventName(eventName) {
  return ("MessageConsumerEventName." + (MessageConsumerEventName.describe(eventName)));
}

var localCounter = 0;
function getConsumerLocalName() {
  return ("ConsumerFSM " + (localCounter++));
}

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * A Message Consumer is created by calling {@link solace.Session#createMessageConsumer}.
 *
 * A MessageConsumer controls Guaranteed Message delivery to this client.
 *
 * Consumer characteristics and behavior are defined by {@link solace.MessageConsumerProperties}.
 * The properties can also be supplied as a simple key-value {Object}. The queue descriptor,
 * {@link solace.MessageConsumerProperties#queueDescriptor} must be specified to identify the
 * Guaranteed Message Queue or Guaranteed Message Topic Endpoint on the Solace Message Router.
 *
 * The MessageConsumer object is an EventEmitter, and will emit events to which the
 * application may choose to subscribe, such as the connection to the Solace Message Router
 * going up or down.
 *
 * If a registered listener for an emitted event throws an exception, this is caught and emitted as
 * an 'error'.
 *
 * @fires solace.MessageConsumerEventName#ACTIVE
 * @fires solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
 * @fires solace.MessageConsumerEventName#DISPOSED
 * @fires solace.MessageConsumerEventName#DOWN
 * @fires solace.MessageConsumerEventName#DOWN_ERROR
 * @fires solace.MessageConsumerEventName#GM_DISABLED
 * @fires solace.MessageConsumerEventName#INACTIVE
 * @fires solace.MessageConsumerEventName#MESSAGE
 * @fires solace.MessageConsumerEventName#UP
 *
 *
 *
 * @extends solace.Flow
 * @memberof solace
 */
var MessageConsumer = (function (Flow) {
  function MessageConsumer(ref) {
    var this$1 = this;
    if ( ref === void 0 ) ref = {};
    var properties = ref.properties;
    var sessionInterfaceFactory = ref.sessionInterfaceFactory;

    var applyProperties = new MessageConsumerProperties(properties);
    MessageConsumerPropertiesValidator.validate(applyProperties);
    Flow.call(this, applyProperties, sessionInterfaceFactory, {
      direct: MessageConsumerEventName.MESSAGE,
      emits:  MessageConsumerEventName.values,
      formatEventName: formatEventName,
    });

    var superFormatter = this.logger.formatter;
    this.logger.formatter = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return superFormatter.apply(void 0, [ '[message-consumer]' ].concat( args ));
    };

    this._active = undefined;
    this._fsm = this._makeFSM();

    this._on(MessageConsumerEventName.ACTIVE, function () { return this$1._onFlowActive(true); });
    this._on(MessageConsumerEventName.INACTIVE, function () { return this$1._onFlowActive(false); });
    this._on(MessageConsumerEventName.DOWN_ERROR, this._onFlowDisconnected.bind(this));
    this._on(MessageConsumerEventName.UP, this._onFlowUp.bind(this));
    this._fsm.start(); // Subscriber flows self-manage, so they start immediately
  }

  if ( Flow ) MessageConsumer.__proto__ = Flow;
  MessageConsumer.prototype = Object.create( Flow && Flow.prototype );
  MessageConsumer.prototype.constructor = MessageConsumer;

  var prototypeAccessors = { accessType: {},active: {},queueDiscardBehavior: {},respectsTTL: {},flowId: {},permissions: {} };

  MessageConsumer.prototype._makeFSM = function _makeFSM () {
    var properties = this._properties;
    var name = "" + (getConsumerLocalName());
    return new ConsumerFSM({
      name: name,
      consumer:         this,
      sessionInterface: this._sessionInterface,
      properties: properties,
    });
  };

  /**
   * Begins delivery of messages to this consumer. This method opens the protocol window
   * to the Solace Message Router so further messages can be received.
   *
   * A newly created consumer is in started state.
   *
   * If the consumer was already started, this method has no effect.
   *
   * A consumer is stopped by calling {@link solace.MessageConsumer.stop}
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disposed.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.start = function start () {
    this._operationCheck(FlowOperation.START);
    this._fsm.requestStartDispatchUser();
  };

  /**
   * Stops messages from being delivered to this consumer from the Solace Message Router.
   * Messages may continue to be prefetched by the API and queued internally
   * until {@link solace.MessageConsumer#start} is called.
   *
   * If the consumer was already stopped, this method has no effect.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.stop = function stop () {
    this._operationCheck(FlowOperation.STOP);
    this._fsm.requestStopDispatchUser();
  };

  /**
   * Connects the consumer immediately. The application should add event listeners (see
   * {@link solace.MessageConsumerEventName}). If there is no listener added for
   * {@link solace.MessageConsumerEventName#event:MESSAGE} then up to a window
   * {@link solace.MessageConsumerProperties.windowSize} of messages can be queued internally.
   * to the {@link solace.MessageConsumer} before calling this method.
   *
   * @throws {solace.OperationError}
   *  * if consumer is not supported by router for this client.
   *  subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   *
   */
  MessageConsumer.prototype.connect = function connect () {
    if ((this._sessionInterface.getCapability(CapabilityType.GUARANTEED_MESSAGE_CONSUME)
        !== null) &&
        (!this._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME))) {
      throw new OperationError('Consumer is not supported by router for this client',
              ErrorSubcode.INVALID_OPERATION, null);
    }
    Flow.prototype.connect.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_OPEN }));
  };

  /**
   * Initiates an orderly disconnection of the Message Consumer. The API will send any pending
   * client acknowledgements on the Message Consumer, then send an unbind request.
   * Any messages subsequently
   * received are discarded silently. When the unbind message is acknowledged, the application
   * receives a {@link solace.MessageConsumerEventName#event:DOWN} event if it has set a listener
   * for that event.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.disconnect = function disconnect () {
    Flow.prototype.disconnect.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_CLOSE }));
  };

  /**
   * Returns the destination that should be used to publish messages that this consumer
   * will receive.
   * * For topic endpoints, this is the topic to which the topic endpoint is subscribed.
   * * For queues, this is the associated queue destination.
   *
   * The destination returned can
   * be used to set the ReplyTo field in a message, or otherwise communicated
   * to partners that need to send messages to this Message Consumer. This is especially useful
   * for temporary endpoints (Queues and Topic Endpoints), as the destination
   * is unknown before the endpoint is created.
   *
   * This method will succeed after {@link MessageConsumerEventName#event:UP} for temporaries
   * with generated destinations.
   *
   * @throws {solace.OperationError}
   * * if the {@link solace.MessageConsumer} is disconnected and the destination is temporary.
   *
   * @returns {solace.Destination} The publishing destination that delivers to this consumer.
   */
  MessageConsumer.prototype.getDestination = function getDestination () {
    var destination = this._fsm.getDestination();
    if (destination instanceof Queue) {
      return new Queue(destination);
    }
    return new Topic(destination);
  };

  // Application has disconnected the session, we must continue to orderly shut down
  // unbinding Message Consumers,
  // but Message Consumers that are up merely treat this as a 'down' event and
  // transition to awaitingSessionUp
  MessageConsumer.prototype._disconnectSession = function _disconnectSession () {
    Flow.prototype._disconnectSession.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.SESSION_DISCONNECT }));
  };

  MessageConsumer.prototype._operationCheck = function _operationCheck (operation) {
    Flow.prototype._operationCheck.call(this, operation);
    switch (operation) {
      case FlowOperation.GET_DESTINATION:
        if (this._isDisconnected()) {
          throw new OperationError('Cannot get destination of a disconnected flow',
                                   ErrorSubcode.INVALID_OPERATION);
        }
        break;
      default:
    }
  };

  // ----

  /**
   * @param {any} messageId The message ID to ack
   * @internal
   */
  MessageConsumer.prototype.applicationAck = function applicationAck (messageId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE(("Adding application ack for " + messageId));
    this._fsm.applicationAck(messageId);
  };

  MessageConsumer.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    return MessageConsumerEventName.DISPOSED;
  };

  /**
   * @param {solace.Message} message The data message to handle
   * @internal
   */
  MessageConsumer.prototype.handleDataMessage = function handleDataMessage (message) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE('Handling data message');
    message.setMessageConsumer(this);
    this._fsm.acceptMessage(message);
  };

  /**
   * @override
   * @param {solace.AdProtocolMessage} message The control message to handle
   * @internal
   */
  MessageConsumer.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Handling uncorrelated control message');
    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.UNBIND:
        this.processFSMEvent(new ConsumerFSMEvent({
          name: ConsumerFSMEventNames.FLOW_UNBOUND,
        }));
        break;
      case SMFAdProtocolMessageType.FLOWCHANGEUPDATE:
        this.processFSMEvent(new ConsumerFSMEvent({
          name: ConsumerFSMEventNames.FLOW_ACTIVE_IND,
        }, {
          active: message.getActiveFlow(),
        }));
        break;
      default:
        LOG_DEBUG('Dropping unhandled AD control message: ',
                  SMFAdProtocolMessageType.describe(msgType));
    }
  };

  /**
   * Creates and returns copy of the properties for this MessageConsumer.
   *
   * If the object was constructed using an {@link solace.AbstractQueueDescriptor},
   * and the queue descriptor was subsequently connected to an endpoint, the
   * `MessageConsumerProperties` returned will include a {@link solace.QueueDescriptor}
   * that contains the resolved name.
   *
   * A new copy of the properties object is returned each time this property is accessed.
   * The returned object cannot be polled for mutations such as the one described above.
   *
   * @returns {solace.MessageConsumerProperties} The properties associated with this object.
   */
  MessageConsumer.prototype.getProperties = function getProperties () {
    return Flow.prototype.getProperties.call(this);
  };

  /**
   * Resets the router state contained in the consumer, e.g. on VRN change
   *
   * @memberof MessageConsumer
   * @internal
   */
  MessageConsumer.prototype.onVRNChanged = function onVRNChanged () {
    this.processFSMEvent(new ConsumerFSMEvent({
      name: ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED,
    }));
  };

  /**
   * After the MessageConsumer has connected to an endpoint
   * ({@link solace.MessageConsumerEventName#UP}), accesstype represents
   *  the access type for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.accessType
   * @type {solace.QueueAccessType}
   */
  prototypeAccessors.accessType.get = function () {
    return this._accessType;
  };
  /**
   * @param {solace.QueueAccessType} value The value to set
   * @internal
   */
  prototypeAccessors.accessType.set = function (value) {
    this._accessType = value;
  };

  /**
   * Whether the consumer is active. If active indications for the consumer are not
   * enabled, this will return undefined.
   * @type {?Boolean}
   * @internal
   */
  prototypeAccessors.active.get = function () {
    return this._active;
  };
  /**
   * @param {Boolean} value The value to set
   * @internal
   */
  prototypeAccessors.active.set = function (value) {
    if (value !== this._active) {
      this._emit(value ? MessageConsumerEventName.ACTIVE : MessageConsumerEventName.INACTIVE);
    }
    this._active = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, queueDiscardBehavior represents
   * the discard behavior flags for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.queueDiscardBehaviour
   * @type {solace.QueueDiscardBehavior}
   */
  prototypeAccessors.queueDiscardBehavior.get = function () {
    return this._queueDiscardBehavior;
  };
  /**
   * @param {solace.QueueDiscardBehavior} value The value to set
   * @internal
   */
  prototypeAccessors.queueDiscardBehavior.set = function (value) {
    this._queueDiscardBehavior = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}
   * respectsTTL is `true` when the endpoint respects Time To Live on messages
   * and 'false' otherwise.
   * @name solace.MessageConsumer.respectsTTL
   * @type {Boolean}
   */
  prototypeAccessors.respectsTTL.get = function () {
    return this._respectsTTL;
  };
  /**
   * @param {Boolean} value The value to set
   * @internal
   */
  prototypeAccessors.respectsTTL.set = function (value) {
    this._respectsTTL = value;
  };

  /**
   * Gets the flow ID for this consumer. This number will change between reconnects
   * and is purely informational.
   * @type {Long}
   * @internal
   */
  prototypeAccessors.flowId.get = function () {
    return this._flowId;
  };
  /**
   * @param {Long} value The value to set
   * @internal
   */
  prototypeAccessors.flowId.set = function (value) {
    this._flowId = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, this property represents
   * permissions granted by the router to this user on this Message Consumer
   * @name solace.MessageConsumer.permissions
   * @type {solace.QueuePermissions}
   */
  prototypeAccessors.permissions.get = function () {
    return this._permissions || 0;
  };
  /**
   * @param {Number} value The value to set
   * @internal
   */
  prototypeAccessors.permissions.set = function (value) {
    this._permissions = value;
  };

  MessageConsumer.prototype._onFlowActive = function _onFlowActive (isActive) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG(("Flow (flowId = " + (this._flowId) + ") became " + (isActive ? 'active' : 'inactive')));
    this._active = isActive;
  };

  MessageConsumer.prototype._onFlowDisconnected = function _onFlowDisconnected () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG(((this) + " disconnected"));
  };

  MessageConsumer.prototype._disposeFSM = function _disposeFSM () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Disposing FSM');
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.DISPOSE }));
  };

  MessageConsumer.prototype._onFlowUp = function _onFlowUp () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG(("Flow is up: flowId = " + (this._flowId)));
  };

  MessageConsumer.prototype[util.inspect.custom] = function () {
    return Object.assign(Flow.prototype[util.inspect.custom].call(this), {
      'destination':          this._destination,
      'accessType':           QueueAccessType.describe(this.accessType),
      'permissions':          QueuePermissions.describe(this.permissions),
      'respectsTTL':          this.respectsTTL,
      'active':               this.wantFlowChangeNotify ? this.active : '(indications disabled)',
      'wantFlowChangeNotify': this.wantFlowChangeNotify,
      'queueDiscardBehavior': QueueDiscardBehavior.describe(this.queueDiscardBehavior),
      'maxWindowSize':        this._fsm.maxWindowSize,
    });
  };

  MessageConsumer.prototype.toString = function toString () {
    return util.inspect(this);
  };

  MessageConsumer.prototype._isDisconnected = function _isDisconnected () {
    return this._fsm.isDisconnected();
  };

  Object.defineProperties( MessageConsumer.prototype, prototypeAccessors );

  return MessageConsumer;
}(Flow));

module.exports.MessageConsumer = MessageConsumer;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$2.MessagePublisherAcknowledgeMode;
var ref$3 = __webpack_require__(23);
var TransportCapabilities = ref$3.TransportCapabilities;

function defaultEnablePublisher() {
  var ProfileBinding = SolclientFactoryLib.ProfileBinding;
  var binding = ProfileBinding.value;
  var globallyEnabled = binding.guaranteedMessagingEnabled;
  var webSocketAvailable = TransportCapabilities.web.webSocket();
  return globallyEnabled && webSocketAvailable;
}

function getDefaults() {
  return {
    enabled:                   defaultEnablePublisher(),
    windowSize:                50,
    acknowledgeTimeoutInMsecs: 2000,
    acknowledgeMode:           MessagePublisherAcknowledgeMode.PER_MESSAGE,
    connectRetryCount:         3,
    connectTimeoutInMsecs:     5000,
  };
}

/**
 * @classdesc
 * Properties that define the configuration for a guaranteed message publisher.
 *
 * @memberof solace
 */
var MessagePublisherProperties = (function (APIProperties) {
  function MessagePublisherProperties(options) {
    APIProperties.call(this, getDefaults(), options || {});
  }

  if ( APIProperties ) MessagePublisherProperties.__proto__ = APIProperties;
  MessagePublisherProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  MessagePublisherProperties.prototype.constructor = MessagePublisherProperties;

  var prototypeAccessors = { enabled: {},windowSize: {},acknowledgeTimeoutInMsecs: {},acknowledgeMode: {},connectRetryCount: {},connectTimeoutInMsecs: {} };
  /**
   * @name solace.MessagePublisherProperties#enabled
   * @type {Boolean}
   * @description When enabled, a Guaranteed Messaging Publisher
   * is automatically created when a session is connected.
   *
   * The default value is the same as the value provided to
   * {@link solace.SolclientFactory.init},
   * in the profile, {@link solace.SolclientFactoryProperties#profile},
   * in the field {@link solace.FactoryProfile#guaranteedMessagingEnabled}.
   */
  prototypeAccessors.enabled.get = function () {
    return this._enabled;
  };
  prototypeAccessors.enabled.set = function (newValue) {
    this._enabled = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#windowSize
   * @default 50
   * @type {Number}
   * @description  Maximum number of messages that can be published
   * without acknowledgment.
   *  * The valid range is 1 <= value <= 255
   */
  prototypeAccessors.windowSize.get = function () {
    return Check.defined(this._windowSize)
      ? this._windowSize
      : getDefaults().windowSize;
  };
  prototypeAccessors.windowSize.set = function (newValue) {
    this._windowSize = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#acknowledgeTimeoutInMsecs
   * @type {Number}
   * @default 2000
   * @description  The time to wait for an acknowledgement,
   * in milliseconds, before retransmitting unacknowledged
   * messages.
   *  * The valid range is 20 <= value <= 60000.
   */
  prototypeAccessors.acknowledgeTimeoutInMsecs.get = function () {
    return Check.defined(this._acknowledgeTimeoutInMsecs)
      ? this._acknowledgeTimeoutInMsecs
      : getDefaults().acknowledgeTimeoutInMsecs;
  };
  prototypeAccessors.acknowledgeTimeoutInMsecs.set = function (newValue) {
    this._acknowledgeTimeoutInMsecs = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#acknowledgeMode
   * @type {solace.MessagePublisherAcknowledgeMode}
   * @default {@link solace.MessagePublisherAcknowledgeMode.PER_MESSAGE}
   * @description  The message-router sends windowed acknowledgements
   * which the API converts to per-message acknowledgement by default. If
   * acknowledgeMode is Windowed, then the API will simply pass through
   * the message-router acknowledgements.
   */
  prototypeAccessors.acknowledgeMode.get = function () {
    return this._acknowledgeMode || MessagePublisherAcknowledgeMode.PER_MESSAGE;
  };
  prototypeAccessors.acknowledgeMode.set = function (newValue) {
    this._acknowledgeMode = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#connectRetryCount
   * @type {Number}
   * @default 3
   * @description The number of times to retry a bind (aka open-flow) request
   * before deciding the the Guaranteed Message Publisher cannot be started.
   *  * The valid range 0 <= value.
   * @private
   */
  prototypeAccessors.connectRetryCount.get = function () {
    return Check.defined(this._connectRetryCount)
      ? this._connectRetryCount
      : getDefaults().connectRetryCount;
  };
  prototypeAccessors.connectRetryCount.set = function (newValue) {
    this._connectRetryCount = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#connectTimeoutInMsecs
   * @type {Number}
   * @default 5000
   * @description  The time to wait for an bind response,
   * in milliseconds, before retransmitting the bind request.
   *  * The valid range is 50 <= value</li>
   * @private
   */
  prototypeAccessors.connectTimeoutInMsecs.get = function () {
    return Check.defined(this._connectTimeoutInMsecs)
      ? this._connectTimeoutInMsecs
      : getDefaults().connectTimeoutInMsecs;
  };
  prototypeAccessors.connectTimeoutInMsecs.set = function (newValue) {
    this._connectTimeoutInMsecs = newValue;
  };

  MessagePublisherProperties.prototype[util.inspect.custom] = function () {
    return {
      enabled:                   this.enabled,
      windowSize:                this.windowSize,
      acknowledgeTimeoutInMsecs: this.acknowledgeTimeoutInMsecs,
      acknowledgeMode:           MessagePublisherAcknowledgeMode.describe(this.acknowledgeMode),
      connectRetryCount:         this.connectRetryCount,
      connectTimeoutInMsecs:     this.connectTimeoutInMsecs,
    };
  };

  Object.defineProperties( MessagePublisherProperties.prototype, prototypeAccessors );

  return MessagePublisherProperties;
}(APIProperties));

module.exports.MessagePublisherProperties = MessagePublisherProperties;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var MessageDumpUtilLib = __webpack_require__(60);
var ref = __webpack_require__(5);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(1);
var LOG_ERROR = ref$1.LOG_ERROR;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;
var ref$3 = __webpack_require__(58);
var MessageCacheStatus = ref$3.MessageCacheStatus;
var ref$4 = __webpack_require__(59);
var MessageDeliveryModeType = ref$4.MessageDeliveryModeType;
var ref$5 = __webpack_require__(40);
var MessageDumpFlag = ref$5.MessageDumpFlag;
var ref$6 = __webpack_require__(61);
var MessageUserCosType = ref$6.MessageUserCosType;
var ref$7 = __webpack_require__(10);
var SDTMapContainer = ref$7.SDTMapContainer;
var SDTFieldType = ref$7.SDTFieldType;
var ref$8 = __webpack_require__(4);
var StringUtils = ref$8.StringUtils;


var MessageDumpStandardProvider = {

  fpDestination: function fpDestination(message/* , flags*/) {
    var dest = message.getDestination();
    if (dest !== null && dest instanceof Destination) {
      return ['Destination', true, dest.toString(), null];
    }
    return ['Destination', false, '', null];
  },

  fpSenderId: function fpSenderId(message/* , flags*/) {
    return ['SenderId', (message.getSenderId() !== undefined && message.getSenderId() !== null), message.getSenderId(), null];
  },

  fpAppmsgType: function fpAppmsgType(message/* , flags*/) {
    return ['AppMessageType', (message.getApplicationMessageType() !== undefined && message.getApplicationMessageType() !== null),
      message.getApplicationMessageType(), null];
  },

  fpAppMsgId: function fpAppMsgId(message/* , flags*/) {
    return ['AppMessageID', (message.getApplicationMessageId() !== undefined && message.getApplicationMessageId() !== null),
      message.getApplicationMessageId(), null];
  },

  fpSequenceNumber: function fpSequenceNumber(message/* , flags*/) {
    var sequenceNum = message.getSequenceNumber();
    if (typeof sequenceNum === 'number') {
      return ['SequenceNumber', true, sequenceNum, null];
    }
    return ['SequenceNumber', false, '', null];
  },

  fpTopicSequenceNumber: function fpTopicSequenceNumber(message/*, flags */) {
    var topicSeqNo = message.getTopicSequenceNumber();
    if (Long.isLong(topicSeqNo)) {
      return ['TopicSequenceNumber', true, topicSeqNo.toString(), null];
    }
    return ['TopicequenceNumber', false, '', null];
  },

  fpCorrelationId: function fpCorrelationId(message/* , flags*/) {
    return ['CorrelationId', (message.getCorrelationId() !== undefined && message.getCorrelationId() !== null),
      message.getCorrelationId(), null];
  },

  fpHttpContentType: function fpHttpContentType(/*message*/ /*, flags*/) {
    // TODO:
    // HTTP Content Type is not supported
    // const strValue = message.getHTTPContentType();
    // return ['HTTP Content Type', (strValue !== undefined && strValue !== null), strValue, null];
    return ['HTTP Content Type', false, undefined, null];
  },

  fpHttpContentEncoding: function fpHttpContentEncoding(/*message*/ /*, flags*/) {
    // TODO:
    // HTTP Content Encoding is not supported
    // const strValue = message.getHTTPContentType();
    // return ['HTTP Content Encoding', (strValue !== undefined && strValue !== null), strValue,
    //         null];
    return ['HTTP Content Encoding', false, undefined, null];
  },

  fpSendTimestamp: function fpSendTimestamp(message/* , flags*/) {
    var timestamp = message.getSenderTimestamp();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['SendTimestamp', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['SendTimestamp', false, '', null];
  },

  fpRcvTimestamp: function fpRcvTimestamp(message/* , flags*/) {
    var timestamp = message.getReceiverTimestamp();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['RcvTimestamp', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['RcvTimestamp', false, '', null];
  },

  fpClassOfService: function fpClassOfService(message/* , flags*/) {
    var cos = message.getUserCos();
    if (typeof cos === 'number') {
      return ['Class Of Service', true, MessageUserCosType.nameOf(message.getUserCos()), null];
    }
    return ['Class Of Service', false, '', null];
  },

//  fpPriority(message/* , flags*/) {
//    const prio = message.getPriority() !== undefined ? message.getPriority() : 'undefined';
//    return ['Message Priority', true, prio, null];
//  },

  fpDeliveryMode: function fpDeliveryMode(message/* , flags*/) {
    var mode = message.getDeliveryMode();
    if (typeof mode === 'number') {
      return ['DeliveryMode', true, MessageDeliveryModeType.nameOf(message.getDeliveryMode()), null];
    }
    return ['DeliveryMode', false, '', null];
  },

  fpGuaranteedMsgId: function fpGuaranteedMsgId(message/*, flags*/) {
    var msgId = message.getGuaranteedMessageId();
    if (Long.isLong(msgId)) {
      return ['Message Id', true, msgId.toString(10), null];
    }
    return ['Message Id', false, '', null];
  },

  fpTimeToLive: function fpTimeToLive(message/* , flags */) {
    var timeToLive = message.getTimeToLive();
    if (typeof timeToLive === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      var d = new Date();
      return ['TimeToLive', true,
        (timeToLive + " (" + (mdu.formatDate(d.getTime() + timeToLive)) + ")"), null];
    }
    return ['TimeToLive', false, '', null];
  },

  fpExpiration: function fpExpiration(message/*, flags*/) {
    var timestamp = message.getGMExpiration();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['Expiration', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['Expiration', false, '', null];
  },

  fpMessageDMQEligible: function fpMessageDMQEligible(message/* , flags*/) {
    return ['DMQ Eligible', message.isDMQEligible(), '', null];
  },

  fpMessageRedelivered: function fpMessageRedelivered(message/* , flags*/) {
    return ['Message Re-delivered', message.isRedelivered(), '', null];
  },

  fpDiscardIndication: function fpDiscardIndication(message/* , flags*/) {
    return ['Discard Indication', message.isDiscardIndication(), '', null];
  },

  fpAckImmediately: function fpAckImmediately(message/* , flags*/) {
    return ['ACK Immediately', message.isAcknowledgeImmediately(), '', null];
  },

  fpElidingEligible: function fpElidingEligible(message/* , flags*/) {
    return ['Eliding Eligible', message.isElidingEligible(), '', null];
  },

  fpReplyMessage: function fpReplyMessage(message/* , flags*/) {
    return ['Reply Message', message.isReplyMessage(), '', null];
  },

  fpReplyTo: function fpReplyTo(message/* , flags*/) {
    var replyTo = message.getReplyTo();
    if (replyTo !== null && replyTo instanceof Destination) {
      return ['ReplyTo', true, replyTo.toString(), null];
    }
    return ['ReplyTo', false, '', null];
  },

  fpDeliverToOne: function fpDeliverToOne(message/* , flags*/) {
    return ['Deliver To One', message.isDeliverToOne(), '', null];
  },

  fpCacheMessage: function fpCacheMessage(message/* , flags*/) {
    return ['Message from cache', message.getCacheStatus() !== MessageCacheStatus.LIVE, '', null];
  },

  fpCacheRequestId: function fpCacheRequestId(message/*, flags */) {
    var cacheRequestId = message.getCacheRequestId();
    if (Long.isLong(cacheRequestId)) {
      return ['Cache Request Id', true, cacheRequestId.toString, null];
    }
    return ['Cache Request Id', false, '', null];
  },

  fpUserPropertyMap: function fpUserPropertyMap(message, flags) {
    var propMap = message.getUserPropertyMap();
    if (propMap !== null && propMap instanceof SDTMapContainer) {
      var value = (propMap.getKeys().length) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          var mdu = MessageDumpUtilLib.MessageDumpUtil;
          detailValue = mdu.printMap(propMap, 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['User Property Map', true, value, detailValue];
    }
    return ['User Property Map', false, '', null];
  },

  fpCorrelationTag: function fpCorrelationTag(message/*, flags*/) {
    var strValue = message.getCorrelationKey();
    return ['Correlation Tag Pointer', (strValue !== undefined && strValue !== null),
      strValue, null];
  },

  fpUserData: function fpUserData(message/* , flags*/) {
    if (StringUtils.notEmpty(message.getUserData())) {
      return ['User Data', true, ("len=" + (message.getUserData().length)),
        DebugLib.Debug.formatDumpBytes(message.getUserData(), true, 2)];
    }
    return ['User Data', false, '', null];
  },

  fpSdtStream: function fpSdtStream(message, flags) {
    var sdtFieldValue = message.getSdtContainer();
    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.STREAM) {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      var value = (mdu.countItems(sdtFieldValue.getValue())) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          detailValue = mdu.printStream(sdtFieldValue.getValue(), 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['SDT Stream', true, value, detailValue];
    }
    return ['SDT Stream', false, '', null];
  },

  fpSdtMap: function fpSdtMap(message, flags) {
    var sdtFieldValue = message.getSdtContainer();
    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.MAP) {
      var value = (sdtFieldValue.getValue().getKeys().length) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          var mdu = MessageDumpUtilLib.MessageDumpUtil;
          detailValue = mdu.printMap(sdtFieldValue.getValue(), 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['SDT Map', true, value, detailValue];
    }
    return ['SDT Map', false, '', null];
  },

  fpBinaryAttachment: function fpBinaryAttachment(message, flags) {
    var att = message.getBinaryAttachment();
    if (StringUtils.notEmpty(att)) {
      var value = "len=" + (att.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(att, true, 2);
      }
      return ['Binary Attachment', true, value, detailValue];
    }
    return ['Binary Attachment', false, '', null];
  },

  fpXmlContent: function fpXmlContent(message, flags) {
    var xml = message.getXmlContent();
    if (StringUtils.notEmpty(xml)) {
      var value = "len=" + (xml.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(xml, true, 2);
      }
      return ['XML', true, value, detailValue];
    }
    return ['XML', false, '', null];
  },

  fpXmlMetadata: function fpXmlMetadata(message, flags) {
    var xmlMetadata = message.getXmlMetadata();
    if (StringUtils.notEmpty(xmlMetadata)) {
      var value = "len=" + (xmlMetadata.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(xmlMetadata, true, 2);
      }
      return ['XML Metadata', true, value, detailValue];
    }
    return ['XML Metadata', false, '', null];
  },
};

module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message payload types
 * (see {@link solace.Message#getBinaryAttachment})
 *
 * A message may contain unstructured byte data, or a structured container.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageType = {
  /**
   * Binary message (unstructured bytes stored in the binary attachment message part).
   * @type {Number}
   */
  BINARY: 0,
  /**
   * Structured map message.
   * @type {Number}
   */
  MAP:    1,
  /**
   * Structured stream message.
   * @type {Number}
   */
  STREAM: 2,
  /**
   * Structured text message.
   * @type {Number}
   */
  TEXT:   3,
};

module.exports.MessageType = Enum.new(MessageType);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(5);
var DestinationType = ref$1.DestinationType;
var ref$2 = __webpack_require__(2);
var OperationError = ref$2.OperationError;
var ErrorSubcode = ref$2.ErrorSubcode;
var ref$3 = __webpack_require__(65);
var QueueType = ref$3.QueueType;

var DEFAULTS = {
  durable: true,
  type:    undefined,
};

var TYPE_DESCRIPTION = {};
TYPE_DESCRIPTION[QueueType.QUEUE] = 'queue';
TYPE_DESCRIPTION[QueueType.TOPIC_ENDPOINT] = 'topic endpoint';

var DESINATION_TYPE_TO_DESCRIPTOR_TYPE = {};
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.TOPIC] = null;
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.QUEUE] = QueueType.QUEUE;
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.TEMPORARY_QUEUE] = QueueType.QUEUE;

function maybeAdaptFromDestination(spec) {
  if (spec && spec.name && spec.type && DestinationType.values.includes(spec.type)) {
    var targetType = DESINATION_TYPE_TO_DESCRIPTOR_TYPE[spec.type];
    if (!targetType) {
      throw new OperationError(("Cannot create a descriptor from a " + (DestinationType.describe(spec.type)) + " destination"),
                               ErrorSubcode.PARAMETER_CONFLICT);
    }
    return {
      name:    spec.name,
      type:    QueueType.QUEUE,
      durable: spec.type !== DestinationType.TEMPORARY_QUEUE,
    };
  }
  return spec;
}


/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * <p>
 * This is a base class for {@link solace.QueueDescriptor}. API users should access the
 * methods described here through a {@link solace.QueueDescriptor}.
 * @memberof solace
 * @hideconstructor
 */
var AbstractQueueDescriptor = (function (APIProperties) {
  function AbstractQueueDescriptor(queueSpec) { // eslint-disable-line no-useless-constructor
    APIProperties.call(this, DEFAULTS, maybeAdaptFromDestination(queueSpec));
  }

  if ( APIProperties ) AbstractQueueDescriptor.__proto__ = APIProperties;
  AbstractQueueDescriptor.prototype = Object.create( APIProperties && APIProperties.prototype );
  AbstractQueueDescriptor.prototype.constructor = AbstractQueueDescriptor;

  var prototypeAccessors = { type: {},durable: {} };

  /**
   * Gets the queue type to which this descriptor refers.
   * @returns {solace.QueueType} The queue type that this object describes
   */
  AbstractQueueDescriptor.prototype.getType = function getType () {
    return this._type;
  };

  /**
   * @type {solace.QueueType}
   * @description The Queue Type.
   */
  prototypeAccessors.type.get = function () {
    return this.getType();
  };
  prototypeAccessors.type.set = function (value) {
    this._type = value;
  };

  /**
   * Gets whether this descriptor refers to a durable queue.
   *
   * @returns {Boolean} `true` if this describes a durable queue
   */
  AbstractQueueDescriptor.prototype.isDurable = function isDurable () { // eslint-disable-line class-methods-use-this
    return this._durable;
  };
  /**
   * @type {Boolean}
   * @description True if this descriptor refers to a Durabble Queue.
   */
  prototypeAccessors.durable.get = function () {
    return this.isDurable();
  };
  prototypeAccessors.durable.set = function (value) {
    this._durable = value;
  };

  AbstractQueueDescriptor.prototype[util.inspect.custom] = function () {
    return {
      'type':    this.type,
      'durable': this.durable,
    };
  };

  /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
  AbstractQueueDescriptor.prototype.toString = function toString () {
    return (!this.isDurable() ? 'non' : '') + "-durable " +
           "" + (TYPE_DESCRIPTION[this.getType()]);
  };

  Object.defineProperties( AbstractQueueDescriptor.prototype, prototypeAccessors );

  return AbstractQueueDescriptor;
}(APIProperties));

module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(105);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var ref$1 = __webpack_require__(5);
var Destination = ref$1.Destination;

var DEFAULTS = {
  name:    undefined,
  durable: true,
};

/**
 * This class identifies a queue or topic endpoint on the message router.
 *
 * Operations that make use of queue descriptors include
 *  * {@link solace.Session#createMessageConsumer}
 *  * {@link solace.Session#dteUnsubscribe}
 *
 * @classdesc QueueDescriptor
 * @extends {AbstractQueueDescriptor}
 * @memberof solace
 */
var QueueDescriptor = (function (AbstractQueueDescriptor) {
  function QueueDescriptor(queueSpec) {
    AbstractQueueDescriptor.call(this, queueSpec instanceof Destination
            ? { name: queueSpec.name, type: queueSpec.type } // synthesize durable later
            : Object.assign({ }, DEFAULTS, queueSpec));
  }

  if ( AbstractQueueDescriptor ) QueueDescriptor.__proto__ = AbstractQueueDescriptor;
  QueueDescriptor.prototype = Object.create( AbstractQueueDescriptor && AbstractQueueDescriptor.prototype );
  QueueDescriptor.prototype.constructor = QueueDescriptor;

  var prototypeAccessors = { name: {} };

  /**
   * Gets/sets the remote name to which this descriptor refers.
   * @returns {String} The name of the queue.
   */
  QueueDescriptor.prototype.getName = function getName () {
    return this._name;
  };
  prototypeAccessors.name.get = function () {
    return this.getName();
  };
  prototypeAccessors.name.set = function (value) {
    this._name = value;
  };

  QueueDescriptor.prototype[util.inspect.custom] = function () {
    return {
      'name':    this.name,
      'type':    this.type,
      'durable': this.durable,
    };
  };

  /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
  QueueDescriptor.prototype.toString = function toString () {
    return ((AbstractQueueDescriptor.prototype.toString.call(this)) + " '" + (this.getName()) + "'");
  };

  /**
   * @static
   * @param {any} spec The descriptor spec
   * @returns {QueueDescriptor|AbstractQueueDescriptor} A new descriptor for the spec
   * @private
   */
  QueueDescriptor.createFromSpec = function createFromSpec (spec) {
    if (spec.name) { return new QueueDescriptor(spec); }
    return AbstractQueueDescriptor(spec);
  };

  Object.defineProperties( QueueDescriptor.prototype, prototypeAccessors );

  return QueueDescriptor;
}(AbstractQueueDescriptor));

module.exports.QueueDescriptor = QueueDescriptor;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(30);
var SDTDataTypes = ref$1.SDTDataTypes;

var EncodeHeader = {
  encodeHeader: function encodeHeader(tag, valueLen) {
    // Tag in first 6 bits, then (lenbytes-1) in 2 bits
    var byte0 = (tag << 2) & 0xFF;
    var strSdtLen = null;

    if (tag === SDTDataTypes.Map || tag === SDTDataTypes.Stream) {
        // force 4 bytes
      strSdtLen = Convert.int32ToStr(valueLen + 5);
      byte0 |= 3; // 4 length bytes
    } else if (valueLen + 2 <= 255) {
      strSdtLen = Convert.int8ToStr(valueLen + 2);
      byte0 |= 0; // 1 length byte
    } else if (valueLen + 3 <= 65535) {
      strSdtLen = Convert.int16ToStr(valueLen + 3);
      byte0 |= 1; // 2 length bytes
    } else {
      strSdtLen = Convert.int32ToStr(valueLen + 5);
      byte0 |= 3; // 4 length bytes
    }
    var ret = Convert.int8ToStr(byte0) + strSdtLen;
    return ret;
  },
};

module.exports.EncodeHeader = EncodeHeader;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;
var ref$3 = __webpack_require__(109);
var SDTUnsupportedValueError = ref$3.SDTUnsupportedValueError;
var ref$4 = __webpack_require__(110);
var SDTValueErrorSubcode = ref$4.SDTValueErrorSubcode;

var createField = SDTField.create;

var C_2_48 = Math.pow(2, 48);

function getBinaryString(strBytes) {
  var bits = [];
  for (var i = strBytes.length - 1; i >= 0; --i) {
    var byteI = strBytes.charCodeAt(i) & 0xFF;
    for (var j = 0; j < 8; ++j) {
      bits.push(byteI % 2 ? 1 : 0);
      byteI >>= 1;
    }
  }
  bits.reverse();
  return bits.join('');
}

var ParseInteger = {

  // Util: decode 1, 2, 3, 4 byte UINT.
  autoDecodeVarLengthNumber: function autoDecodeVarLengthNumber(dataStr) {
    switch (dataStr.length) {
      case 1:
        return Convert.strToInt8(dataStr);
      case 2:
        return Convert.strToInt16(dataStr);
      case 3:
        return Convert.strToInt24(dataStr);
      case 4:
        return Convert.strToInt32(dataStr);
      default:
        return false;
    }
  },

    // Parse an integer SDT Field: [U]INT 8, 16, 32, 64.
  parseIntegerField: function parseIntegerField(isSigned, datastr) {
    var sign = false;
    var val = 0;
    var unsafeBits;

    switch (datastr.length) {
      case 1:
        val = Convert.strToInt8(datastr);
        if (!isSigned) {
          return createField(SDTFieldType.UINT8, val);
        }
        sign = (val & 0x80) !== 0;
        if (sign) {
          val -= 256;
        }
        return createField(SDTFieldType.INT8, val);

      case 2:
        val = Convert.strToInt16(datastr);
        if (!isSigned) {
          return createField(SDTFieldType.UINT16, val);
        }
        sign = (val & 0x8000) !== 0;
        if (sign) {
          val -= 65536;
        }
        return createField(SDTFieldType.INT16, val);

      case 4:
        val = Convert.strToInt32(datastr);
        if (isSigned) {
          // raw read using strToInt32 (it reads 2's complement)
          return createField(SDTFieldType.INT32, val);
        }

        // conversion error with strToInt32! (we can't read back a 32bit uint)
        // Solution is to convert byte positions ourselves without using bitwise shifts
        // Because the UINT is guaranteed to be < 2^53 this should work.
        val = (datastr.charCodeAt(0) * 16777216) +
              (datastr.charCodeAt(1) * 65536) +
              (datastr.charCodeAt(2) * 256) +
              (datastr.charCodeAt(3));
        return createField(SDTFieldType.UINT32, val);

      case 8:
        {
          var error = null;

          // we handle 48-bit ints safely
          val = getBinaryString(datastr.substr(0, 8));
          sign = isSigned && val.substr(0, 1) === '1';

          // If these bits change the representation, we can't
          // compute a valid representation.
          unsafeBits = parseInt(val.substr(1, 15), 2);

          // If the number is not signed, enforce bits 1-15 === 0.
          // If the number is signed and negative, enforce bits 1-15 === 1.
          if ((!sign && (unsafeBits !== 0)) ||
            (sign && (unsafeBits !== 0x7FFF))) {
            error = new SDTUnsupportedValueError('Value is not supported',
                        SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE,
                        datastr);
          }

          val = parseInt(val.substr(16, 48), 2);
          if (sign) {
            // negative (two's complement) number
            val -= C_2_48;
          }

          var field = createField(isSigned ? SDTFieldType.INT64 : SDTFieldType.UINT64, val);
          if (error) {
            field.setError(error);
          }

          return field;
        }

      default:
        return null;
    }
  },
};

module.exports.ParseInteger = ParseInteger;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var ref = __webpack_require__(2);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT unsupported value error.  An SDT field was assigned a value that is within
 * the type range for the given SDT type, but is not supported on this platform/runtime.
 * This occurs when a received {@link solace.SDTContainerMap} or {@link solace.SDTContainerStream}
 * contains a field with a value that can not represented in the local architecture.
 * Possible causes include:
 * * receive 64 bit integer that cannot be represented accurately in a javaScript number. JavaScript
 *   numbers are floats and can only hold a 48 bit integer without loss of precission. Any integer
 *   greater than 281474976710655 or less than -281474976710655 will cause this exception.
 * @extends solace.SolaceError
 * @memberof solace
 */
var SDTUnsupportedValueError = (function (SolaceError) {
  function SDTUnsupportedValueError(message, subcode, sourceData) {
    /**
     * The name of the error.
     * @name solace.SDTUnsupportedValueError#name
     * @type {Constant}
     * @description 'SDTUnsupportedValue'
     */
    SolaceError.call(this, 'SDTUnsupportedValue', message);
    /**
     * The subcode for the error. see {@link solace.SDTValueErrorSubcode}
     * @name solace.SDTUnsupportedValueError#subcode
     * @type {solace.SDTValueErrorSubcode}
     */
    this.subcode = subcode;
    this.sourceData = sourceData || '';
  }

  if ( SolaceError ) SDTUnsupportedValueError.__proto__ = SolaceError;
  SDTUnsupportedValueError.prototype = Object.create( SolaceError && SolaceError.prototype );
  SDTUnsupportedValueError.prototype.constructor = SDTUnsupportedValueError;

  SDTUnsupportedValueError.prototype.inspect = function inspect () {
    return SolaceError.prototype.inspect.call(this, {
      subcode:    null,
      sourceData: function (v) { return DebugLib.Debug.formatDumpBytes(v, false, 0); },
    });
  };

  SDTUnsupportedValueError.prototype.getSubcode = function getSubcode () {
    return this.subcode;
  };

  SDTUnsupportedValueError.prototype.getSourceData = function getSourceData () {
    return this.sourceData;
  };

  return SDTUnsupportedValueError;
}(SolaceError));


module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of {@link solace.SDTUnsuportedValueError} causes.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SDTValueErrorSubcode = {
  /**
   * @type {Number}
   * @description
   * The value for this field may be valid on other platforms, but is outside the
   * range that is supported on this platform for the given type.
   */
  VALUE_OUTSIDE_SUPPORTED_RANGE: 1,
};

module.exports.SDTValueErrorSubcode = Enum.new(SDTValueErrorSubcode);


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * @classdesc
 *
 * Encapsulates the session's message receive callback function and
 * an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.
 * Use <tt>sessionObject.on({@link solace.SessionEventCode.MESSAGE})</tt> instead.
 *
 * @memberof solace
 */
var MessageRxCBInfo = function MessageRxCBInfo(messageRxCBFunction, userObject) {
  /**
   * @type {function(Session, Message, Object)}
   * @description The prototype of this function is the
   * following: ({@link solace.Session}, {@link solace.Message}, userObject {Object})
   */
  this.messageRxCBFunction = messageRxCBFunction;

  /**
   * @type {Object}
   * @description user-specified object
   */
  this.userObject = userObject;
};

module.exports.MessageRxCBInfo = MessageRxCBInfo;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of session properties that can be modified by
 * {@link solace.Session.updateProperty} after the {@link solace.Session} is originally
 * created.
 *
 * These correspond to session properties in {@link solace.SessionProperties}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MutableSessionProperty = {
  /**
   * Client name: {@link solace.SessionProperties#clientName}
   * @type {Number}
   */
  CLIENT_NAME:        1,
  /**
   * Application description: {@link solace.SessionProperties#applicationDescription}
   * @type {Number}
   */
  CLIENT_DESCRIPTION: 2,
};

module.exports.MutableSessionProperty = Enum.new(MutableSessionProperty);


/***/ }),
/* 113 */
/***/ (function(module, exports) {

var P2PUtil = {
  getP2PInboxTopic: function getP2PInboxTopic(base) {
    return ((base + "/#"));
  },
  getP2PTopicSubscription: function getP2PTopicSubscription(base) {
    return ((base + "/>"));
  },
};

module.exports.P2PUtil = P2PUtil;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * Encapsulates the session's event callback function and an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.  Register event handlers
 * against {@link solace.SessionEventCode} events instead.
 *
 * @memberof solace
 */

var SessionEventCBInfo = function SessionEventCBInfo(sessionEventCBFunction, userObject) {
  /**
   * @type {Object}
   * @description user-specified object
   */
  this.userObject = userObject;

  /**
   * @type {function}
   * @description The prototype of this function is the
   * following:
   * ({@link solace.Session}, {@link solace.SessionEvent},
   * userObject {Object}, RFUObject {Object})
   */
  this.sessionEventCBFunction = sessionEventCBFunction;
};

module.exports.SessionEventCBInfo = SessionEventCBInfo;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(15);
var FsmEvent = ref$1.FsmEvent;
var ref$2 = __webpack_require__(3);
var Hex = ref$2.Hex;

var formatHexString = Hex.formatHexString;
/**
 * SessionFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends FsmEvent
 * @private
 */
var SessionFSMEvent = (function (FsmEvent) {
  function SessionFSMEvent(spec, fields) {
    FsmEvent.call(this, spec);
    /**
     * @type {String}
     * @description Information String for the {SessionEvent}
     */
    this.eventText = null;
    /**
     * @type {ErrorSubcode}
     * @description The Solace ErrorSubcode for any generated {SessionEvent}
     */
    this.errorSubcode = null;
    /**
     * @type {String}
     * @description The reason string to be included in any generated {SessionEvent}
     */
    this.eventReason = null;
    /**
     * @type {TransportSMFMessage}
     * @description A decoded SMF message received from the transport. May be
     * either a {ClientCtrlMessage} or a {SMPMessage}
     */
    this.smfMsg = null;
    /**
     * @type {Object}
     * @description The Transport SessionId retrieved from a {TransportSessionEvent}
     */
    this.sessionId = null;
    /**
     * @type {Object}
     * @description The Publisher or Consumer object associated with a GM event.
     */
    this.guaranteedFlowObject = null;

    Object.assign(this, fields);
  }

  if ( FsmEvent ) SessionFSMEvent.__proto__ = FsmEvent;
  SessionFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  SessionFSMEvent.prototype.constructor = SessionFSMEvent;

  SessionFSMEvent.prototype[util.inspect.custom] = function () {
    return {
      'eventText':    this.eventText,
      'eventReason':  this.eventReason,
      'errorSubcode': ErrorSubcode.describe(this.errorSubcode),
      'sessionId':    this.sessionId && formatHexString(this.sessionId) || 'N/A',
    };
  };

  SessionFSMEvent.prototype.getExtraStringInfo = function getExtraStringInfo () {
    return util.inspect(this);
  };

  return SessionFSMEvent;
}(FsmEvent));

module.exports.SessionFSMEvent = SessionFSMEvent;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Internal session state
 * @enum {string}
 * @memberof solace
 * @private
 */
var SessionStateName = {
  DISCONNECTED:                     'SessionDisconnected',
  CONNECTING:                       'SessionConnecting',
  WAITING_FOR_TRANSPORT:            'WaitingForTransport',
  WAITING_FOR_TRANSPORT_UP:         'WaitingForTransportUp',
  WAITING_FOR_LOGIN:                'WaitingForLogin',
  TRANSPORT_UP:                     'SessionTransportUp',
  FULLY_CONNECTED:                  'SessionFullyConnected',
  SESSION_ERROR:                    'SessionError',
  DISCONNECTING:                    'SessionDisconnecting',
  REAPPLYING_SUBSCRIPTIONS:         'ReapplyingSubscriptions',
  WAITING_FOR_PUBFLOW:              'WaitingForMessagePublisher',
  DISPOSED:                         'SessionDisposed',
  WAITING_FOR_SUBCONFIRM:           'WaitForSubConfirm',
  WAITING_FOR_CAN_ACCEPT_DATA:      'WaitForCanAcceptData',
  DISCONNECTING_FLOWS:              'DisconnectingFlows',
  FLUSHING_TRANSPORT:               'FlushingTransport',
  DESTROYING_TRANSPORT:             'DestroyingTransport',
  RECONNECTING:                     'Reconnecting',
  TRANSPORT_FAIL:                   'TransportFail',
  WAITING_FOR_INTERCONNECT_TIMEOUT: 'WaitingForInterconnectTimeout',
  WAITING_FOR_DNS:                  'WaitingForDNS',
};

module.exports.SessionStateName = Enum.new(SessionStateName);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionState = {
  /**
   * The session is connecting.
   */
  CONNECTING:    1,
  /**
   * The session is connected.
   */
  CONNECTED:     2,
  /**
   * The session experienced an error.
   */
  SESSION_ERROR: 3,
  /**
   * The session is disconnecting.
   */
  DISCONNECTING: 4,
  /**
   * The session is disconnected.
   */
  DISCONNECTED:  5,

};

module.exports.SessionState = Enum.new(SessionState);


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(13);
var AdProtocolMessage = ref.AdProtocolMessage;
var SMFParameter = ref.SMFParameter;
var ref$1 = __webpack_require__(3);
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(1);
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_INFO = ref$2.LOG_INFO;
var LOG_ERROR = ref$2.LOG_ERROR;
// const { SMFAdProtocolParam } = require('solclient-smf');

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

function parseAdpAt(data, offset) {
  if ((offset + 3) > data.length) {
    //not enough data
    LOG_DEBUG('Not enough data to read an ADP message.');
    return false;
  }
  var pos = offset;
  var onebyte = strToInt8(data.substr(pos, 1));
  pos++;

  // var msgRFU = bits(onebyte, 6, 2);
  var adpVersion = bits(onebyte, 0, 6);
  var msgLength;
  var msgType;
  if (adpVersion < 3) {
    var twobyte = strToInt16(data.substr(pos, 2));
    pos += 2;
    msgType = bits(twobyte, 12, 4);
    // length in 32 bit words is in the lower 12 bits
    msgLength = bits(twobyte, 0, 12);
    // convert length to number of bytes
    msgLength <<= 2;
  } else if (adpVersion === 3) {
    onebyte = strToInt8(data[pos]);
    pos++;
    msgType = bits(onebyte, 0, 8);
    msgLength = strToUInt32(data.substr(pos, 4));
    pos += 4;
  } else {
    LOG_ERROR('Found unsupported ADP Version', adpVersion);
    return false; //unsupported type
  }
  //
  // Verify that the ADP header length does not exceed the entire
  // contents of the SMF message.
  if (offset + msgLength > data.length) {
    LOG_ERROR(("Invalid Asssured Control Protocol length=" + msgLength + " exceeds remaining message buffer = " + (data.length - offset)));
    return false; // invalid message format
  }
  var adpMsg = new AdProtocolMessage(msgType, adpVersion);
  while (pos < (offset + msgLength)) {
    onebyte = strToInt8(data.substr(pos, 1));
    pos++;
    var paramUH = bits(onebyte, 6, 2);
    var paramType = bits(onebyte, 0, 6);

    // Look for and skip padding bytes
    if (paramType === 0) {
      continue;
    }
    if (pos >= (offset + msgLength)) {
      LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " at position =" + pos));
      return false; // Assured Control parsing fail
    }
    var paramLen = strToInt8(data.substr(pos, 1));
    var paramValueLen = (void 0);
    pos++;
    // If paramLen == 0, then this is an extended length format
    // and there is a 4 byte length following the '0'
    if (paramLen === 0) {
      // need at least 5 more bytes in the buffer
      if (pos + 5 > (offset + msgLength)) {
        LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " at position =" + pos));
        return false; // Assured Control parsing fail
      }
      paramLen = strToUInt32(data.substr(pos, 4));
      pos += 4;
      paramValueLen = paramLen - 5;
    } else {
      paramValueLen = paramLen - 2;
    }
    if (paramLen <= 0) {
      return false; // Assured Control parsing fail
    }
    //
    // make sure there is enough buffer for paramValueLen
    if (pos + paramValueLen > offset + msgLength) {
      LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " length =" + paramValueLen + " invalid at position =" + pos));
      return false; // Assured Control parsing fail
    }
    var paramValue = data.substr(pos, paramValueLen);
    adpMsg.addParameter(new SMFParameter(paramUH, paramType, paramValue));
    pos += paramValueLen;
  }
  return adpMsg;
}

function encAdp8Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(3)); // length
  data.push(Convert.int8ToStr(value));
  return data.join('');
}

function encAdp16Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(4)); // length
  data.push(Convert.int16ToStr(value));
  return data.join('');
}

function encAdp32Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(6)); // length
  data.push(Convert.int32ToStr(value));
  return data.join('');
}

function encAdp64Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(10)); // length
  data.push(Convert.int64ToStr(value));
  return data.join('');
}

function encAdp64AckPairParam(uh, paramtype, min, max) {
  var data = [];
  var byte1 = 0;
  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(18)); // length
  data.push(Convert.int64ToStr(min));
  data.push(Convert.int64ToStr(max));
  return data.join('');
}

function encAdpUTF8NTParam(uh, paramtype, value) {
  // value is already UTF8 encoded and null terminated.
  var data = [];
  var byte1 = 0;
  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));

  var byte2 = 0;
  if (value.length <= 253) {
    byte2 = value.length + 2; // full length of param
    data.push(Convert.int8ToStr(byte2));
  } else {
    byte2 = 0; // extended-length
    data.push(Convert.int8ToStr(byte2));
    data.push(Convert.int32ToStr(value.length + 5));
  }
  data.push(value);
  return data.join('');
}

function encAdp(adpMsg) {
  var paramspace = [];
  var paramarray = adpMsg.getParameterArray();

  var p;
  var byte1 = 0;
  for (p = 0; p < paramarray.length; p++) {
    var param = paramarray[p];
    // It's not a flat array, we have gaps!
    if (param === undefined) {
      continue;
    }

    switch (param.getType()) {
      /*
       * 8 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.WINDOW:
      case SMFLib.SMFAdProtocolParam.EP_DURABLE:
      case SMFLib.SMFAdProtocolParam.ACCESSTYPE:
      case SMFLib.SMFAdProtocolParam.FLOWTYPE:
      case SMFLib.SMFAdProtocolParam.EP_RESPECTS_TTL:
      case SMFLib.SMFAdProtocolParam.TRANSACTION_CTRL_MESSAGE_TYPE:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_STATE:
      case SMFLib.SMFAdProtocolParam.ACTIVE_FLOW_INDICATION:
      case SMFLib.SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY:
      case SMFLib.SMFAdProtocolParam.MAX_REDELIVERY:
        paramspace.push(encAdp8Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 16 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.EP_BEHAVIOUR:
        paramspace.push(encAdp16Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 32 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.FLOWID:
      case SMFLib.SMFAdProtocolParam.TRANSPORT_WINDOW:
      case SMFLib.SMFAdProtocolParam.EP_ALLOTHER_PERMISSION:
      case SMFLib.SMFAdProtocolParam.EP_QUOTA:
      case SMFLib.SMFAdProtocolParam.EP_MAX_MSGSIZE:
      case SMFLib.SMFAdProtocolParam.GRANTED_PERMISSION:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_ID:
      case SMFLib.SMFAdProtocolParam.PUBLISHER_ID:
        paramspace.push(encAdp32Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 64 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.LASTMSGIDSENT:
      case SMFLib.SMFAdProtocolParam.LASTMSGIDACKED:
      case SMFLib.SMFAdProtocolParam.LASTMSGIDRECEIVED:
      case SMFLib.SMFAdProtocolParam.TRANSACTION_ID:
        paramspace.push(encAdp64Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * application ack
       */
      case SMFLib.SMFAdProtocolParam.APPLICATION_ACK:
        {
          // Unpack this to multiple parameters
          var ranges = param.getValue();
          var uh = param.getUh();
          var type = param.getType();
          for (var i = 0; i < ranges.length; ++i) {
            var range = ranges[i];
            paramspace.push(encAdp64AckPairParam(uh,
                                                 type,
                                                 range[0],
                                                 range[1]));
          }
          break;
        }
      /*
       * string and other variable length parameters
       */
      case SMFLib.SMFAdProtocolParam.QUEUENAME:
      case SMFLib.SMFAdProtocolParam.DTENAME:
      case SMFLib.SMFAdProtocolParam.TOPICNAME:
      case SMFLib.SMFAdProtocolParam.FLOWNAME:
      case SMFLib.SMFAdProtocolParam.SELECTOR:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_NAME:
        paramspace.push(encAdpUTF8NTParam(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * Transaction Publisher Notify
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:
        // TODO:
        break;
      /*
       * Transaction Publisher Ack
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:
        // TODO:
        break;
      /*
       * Transaction Subscriber Ack
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:
        // TODO:
        break;
      /*
       * No Local Parameter has no data
       * Cut Through Parameter has no data
       */
      case SMFLib.SMFAdProtocolParam.NOLOCAL:
      case SMFLib.SMFAdProtocolParam.CUT_THROUGH:
        byte1 = setBits(byte1, param.getUh(), 6, 2);
        byte1 = setBits(byte1, param.getType(), 0, 6);
        paramspace.push(
          int8ToStr(byte1) + // uh, type
          int8ToStr(2)       // length
        );
        break;
      /*
       * Application Publisher Acknowledge
       */
      case SMFLib.SMFAdProtocolParam.APPLICATION_PUB_ACK:
        // TODO:
        break;
      default:
        LOG_INFO('Unrecognized ADProtocol Parameter in Message');
        break;
    }
  }

  var paramdata = paramspace.join('');

  var data = [];
  if (adpMsg.version === 2) {
    var threebytes = 0;
    threebytes = setBits(threebytes, 0, 22, 2); // RFU
    threebytes = setBits(threebytes, adpMsg.version, 16, 6); // RFU
    threebytes = setBits(threebytes, adpMsg.msgType, 12, 4); // msgtype
    // length in 32 bit words means the real length must always be a multiple of 4, so pad as
    // necessary

    // 4 - how many bytes passed a 4 byte boundary
    var padBytes = 4 - ((3 + paramdata.length) & 0x3);
    // calculate the total length, 3 bytes header + params, in 32 bit words
    var length = (3 + paramdata.length + padBytes) >> 2;
    threebytes = setBits(threebytes, length, 0, 12);
    data.push(int24ToStr(threebytes)); // first 3B (RFU, version, msgtype, length)
    data.push(paramdata);

    if (padBytes === 4) { padBytes = 0; } // don't add 4 pad bytes
    while (padBytes > 0) {
      data.push(int8ToStr(0));
      padBytes--;
    }
  } else if (adpMsg.version === 3) {
    var twobytes = 0;
    twobytes = setBits(twobytes, 0, 14, 2); // RFU
    twobytes = setBits(twobytes, adpMsg.version, 8, 6); // version
    twobytes = setBits(twobytes, adpMsg.msgType, 0, 8); // msgtype
    data.push(int16ToStr(twobytes)); // first 2B (RFU, version, msgtype)
    data.push(int32ToStr(6 + paramdata.length)); //length: 6B header + params
    data.push(paramdata);
  } else {
    LOG_ERROR(("Invalid Version " + (adpMsg.version) + " found while encoding"));
  }

  return data.join('');
}

module.exports.parseAdpAt = parseAdpAt;
module.exports.encAdp = encAdp;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(13);
var ClientCtrlMessage = ref$1.ClientCtrlMessage;
var SMFParameter = ref$1.SMFParameter;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

function parseCCAt(data, offset, payloadLen) {
  var ccMsg = new ClientCtrlMessage();
  if (payloadLen < 6 || offset + 6 > data.length) {
      // not enough data! Return empty.
      // This is required because we can get an empty CC payload as a router response
    return ccMsg;
  }

  var pos = offset;
  var twobytes = strToInt16(data.substr(pos, 2));
  pos += 2;
    // var uh = bits(twobytes, 15, 1);
  var version = bits(twobytes, 8, 3);
  var msgType = bits(twobytes, 0, 8);
  var len = strToUInt32(data.substr(pos, 4));
  pos += 4;

    // Sanity check: we support ClientCtrl v1
  if (version !== 1) {
    LOG_ERROR(("Unsupported ClientCtrl version " + version));
    return false;
  }

  if (len <= 0 || (offset + len) > data.length) {
    return false;
  }

  ccMsg.msgType = msgType;
  ccMsg.version = version;
  while (pos < (offset + len)) {
    var onebyte = strToInt8(data.substr(pos, 1));
    pos++;
    var paramUh = bits(onebyte, 7, 1);
    var paramType = bits(onebyte, 0, 7);
    var paramLen = strToUInt32(data.substr(pos, 4));
    if (paramLen <= 0) {
      return false; // SMF parsing fail
    }

    pos += 4;
    var paramValueLen = paramLen - 5;
    var paramValue = data.substr(pos, paramValueLen);
    ccMsg.addParameter(new SMFParameter(paramUh, paramType, paramValue));
    pos += paramValueLen;
  }
  return ccMsg;
}

function encCC(ccMsg) {
  var paramSpace = [];
  var paramArray = ccMsg.getParameterArray();
    /*
    ClientCtrl Parameter formatting:
        1 byte uh/type
        4 bytes length
        N bytes value
     */
  for (var p = 0, n = paramArray.length; p < n; ++p) {
    var currentParam = paramArray[p];
      // It's not a flat array, we have gaps!
    if (currentParam === undefined) {
      continue;
    }
    var currentParamOneByte = 0;
    currentParamOneByte = setBits(currentParamOneByte, currentParam.getUh(), 7, 1);
    currentParamOneByte = setBits(currentParamOneByte, currentParam.getType(), 0, 7);
    paramSpace.push(int8ToStr(currentParamOneByte));
    paramSpace.push(int32ToStr(currentParam.getValue().length + 5));
    paramSpace.push(currentParam.getValue());
  }

  var paramData = paramSpace.join('');
  var twobytes = 0;
  twobytes = setBits(twobytes, 0, 15, 1); // uh
  twobytes = setBits(twobytes, 0, 11, 4); // RFU
  twobytes = setBits(twobytes, 1, 8, 3); // version
  twobytes = setBits(twobytes, ccMsg.msgType, 0, 8); // msgtype

  var data = [];
  data.push(int16ToStr(twobytes)); // first 2B (uh, version, msgtype)
  data.push(int32ToStr(6 + paramData.length)); // length: 6B header + params
  data.push(paramData);
  return data.join('');
}

module.exports.parseCCAt = parseCCAt;
module.exports.encCC = encCC;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

var ContentSummaryElement = function ContentSummaryElement(type, position, length) {
  if ( type === void 0 ) type = null;
  if ( position === void 0 ) position = 0;
  if ( length === void 0 ) length = 0;

  this.type = type;
  this.position = position;
  this.length = length;
};

module.exports.ContentSummaryElement = ContentSummaryElement;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_ERROR = ref.LOG_ERROR;
var LOG_INFO = ref.LOG_INFO;
var ref$1 = __webpack_require__(3);
var Base64 = ref$1.Base64;
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(76);
var ParamParse = ref$2.ParamParse;
var ref$3 = __webpack_require__(13);
var SMFHeader = ref$3.SMFHeader;
var ref$4 = __webpack_require__(78);
var SMFParameterType = ref$4.SMFParameterType;

var base64Decode = Base64.decode;
var bits = Bits.get;
var strToInt8 = Convert.strToInt8;
var strToInt24 = Convert.strToInt24;
var strToInt32 = Convert.strToInt32;
var strToUInt32 = Convert.strToUInt32;
var strToUInt64 = Convert.strToUInt64;

function isSMFHeaderAvailable(data, offset) {
  var remaining = data.length - offset;
  if (remaining < 12) {
    return false;
  }

  return true;
}

function isSMFHeaderValid(data, offset) {
  if (!isSMFHeaderAvailable(data, offset)) {
    return false;
  }
  var version = strToInt8(data[offset]) & 0x7;
  if (version !== 3) {
    LOG_ERROR(("Invalid smf version in smf header, version=" + version));
    return false;
  }
  return true;
}

function isSMFAvailable(data, offset) {
  if (!isSMFHeaderValid(data, offset)) {
    return false;
  }
  var remaining = data.length - offset;
  var totalLen = strToUInt32(data.substr(offset + 8, 4));
  return (totalLen <= remaining);
}

/**
 * Parse SMF in the given data at the supplied offset.
 * @param {String} data The binary data to parse
 * @param {Number} offset The offset in the data to begin parsing
 * @param {Boolean} readHeaderOnly If true, stop parsing at end of header
 * @returns {SMFHeader|null} The SMF header, if possible
 * @private
 */
function parseSMFAt(data, offset, readHeaderOnly) {
  if ( readHeaderOnly === void 0 ) readHeaderOnly = false;

  if (!isSMFHeaderValid(data, offset)) {
    LOG_DEBUG('Valid SMF header not available');
    return null;
  }
  var pos = offset;

    // Reading fixed header block (12 bytes)
  var word1 = strToInt32(data.substr(pos, 4));
  var headerLen = strToUInt32(data.substr(pos + 4, 4));
  var word3 = strToUInt32(data.substr(pos + 8, 4));

  var smfHeader = new SMFHeader();
  smfHeader.smf_di = bits(word1, 31, 1);
  smfHeader.smf_elidingEligible = bits(word1, 30, 1);
  smfHeader.smf_dto = bits(word1, 29, 1);
  smfHeader.smf_adf = bits(word1, 28, 1);
  smfHeader.smf_deadMessageQueueEligible = bits(word1, 27, 1);
  smfHeader.smf_version = bits(word1, 24, 3);
  smfHeader.smf_uh = bits(word1, 22, 2);
  smfHeader.smf_protocol = bits(word1, 16, 6);
  smfHeader.smf_priority = bits(word1, 12, 4);
  smfHeader.smf_ttl = bits(word1, 0, 8);

  var payloadLen = word3 - headerLen;
  if (payloadLen < 0) {
    LOG_ERROR('SMF parse error: lost framing');
    return null; // SMF parse error: lost framing
  }
  smfHeader.setMessageSizes(headerLen, payloadLen);
  if (readHeaderOnly) {
    return smfHeader;
  }
  pos += 12;

  // Reading variable-length params
  var end = offset + headerLen;
  while (pos < end) {
    var paramByte1 = data.charCodeAt(pos);
    ++pos;

    var prmUh = bits(paramByte1, 6, 2);
    var paramIsLightweight = (bits(paramByte1, 5, 1) !== 0);
    if (paramIsLightweight) {
      // LIGHTWEIGHT param
      var lwpType = bits(paramByte1, 2, 3);
      var lwpLen = bits(paramByte1, 0, 2) + 1;
      var lwpValueLen = lwpLen - 1;
      if (lwpLen <= 0) {
        LOG_ERROR('Invalid lightweight parameter length');
        return null; // Invalid parameter
      }

      switch (lwpType) {
        case SMFParameterType.LIGHT_CORRELATION:
          smfHeader.pm_corrtag = strToInt24(data.substr(pos, 3));
          break;
        case SMFParameterType.LIGHT_TOPIC_NAME_OFFSET:
          {
            var parsedQueueOffsets = ParamParse.parseTopicQueueOffsets(data, pos);
            smfHeader.pm_queue_offset = parsedQueueOffsets[0];
            smfHeader.pm_queue_len = parsedQueueOffsets[1];
            break;
          }
        case SMFParameterType.LIGHT_QUEUE_NAME_OFFSET:
          {
            var parsedTopicOffsets = ParamParse.parseTopicQueueOffsets(data, pos);
            smfHeader.pm_topic_offset = parsedTopicOffsets[0];
            smfHeader.pm_topic_len = parsedTopicOffsets[1];
            break;
          }
        case SMFParameterType.LIGHT_ACK_IMMEDIATELY:
          smfHeader.pm_ad_ackimm = !!data.charCodeAt(pos);
          break;
        default:
          if (prmUh === 0) {
            // Ignore, and silently discard the parameter.
            LOG_TRACE(("Unhandled LIGHTWEIGHT parameter type: " + lwpType + " UH is " + prmUh + " discarding parameter."));
          } else {
            // Ignore, and silently discard the entire message.
            LOG_TRACE(("Unhandled LIGHTWEIGHT parameter type: " + lwpType + " UH is " + prmUh + " discarding message."));
            smfHeader.discardMessage = true;
          }
          break;
      }
      pos += lwpValueLen;
    } else {
      // REGULAR encoded param
      var pStart = pos;
      var pType = bits(paramByte1, 0, 5);
      if (pType === 0) {
        break; // PADDING (break while: header finished)
      }

      var pLen = data.charCodeAt(pos);
      pos++;
      var pValueLen = (void 0);
      if (pLen === 0) {
        // extended-length parameter (32-bit)
        pLen = strToUInt32(data.substr(pos, 4));
        pos += 4;
        pValueLen = pLen - 6;
      } else {
        pValueLen = pLen - 2;
      }

      if (pLen <= 0) {
        LOG_ERROR(("Invalid regular parameter length " + pLen + "/" + pValueLen + " with suspect type " + (SMFParameterType.describe(pType)) + " at parameter at position " + pStart));
        return null; // Invalid parameter
      }

      switch (pType) {
        case SMFParameterType.PUBLISHER_ID:
          smfHeader.pm_ad_publisher_id = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.PUBLISHER_MSGID:
          smfHeader.pm_ad_publishermsgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.MESSAGEPRIORITY:
          smfHeader.pm_msg_priority = data.charCodeAt(pos);
          break;
        case SMFParameterType.USERDATA:
          smfHeader.pm_userdata = data.substr(pos, pValueLen);
          break;
        case SMFParameterType.USERNAME:
          // only useful on API -> router
          smfHeader.pm_username = base64Decode(data.substr(pos, pValueLen));
          break;
        case SMFParameterType.PASSWORD:
          // only useful on API -> router
          smfHeader.pm_password = base64Decode(data.substr(pos, pValueLen));
          break;
        case SMFParameterType.RESPONSE:
          {
            var parsedResponse = ParamParse.parseResponseParam(data, pos, pValueLen);
            smfHeader.pm_respcode = parsedResponse[0];
            smfHeader.pm_respstr = parsedResponse[1];
            break;
          }
        case SMFParameterType.SUB_ID_LIST:
        case SMFParameterType.GENERIC_ATTACHMENT:
        case SMFParameterType.BINARY_ATTACHMENT:
          LOG_INFO('Skipping deprecated parameter type');
          // deprecated
          break;
        case SMFParameterType.DELIVERY_MODE:
          // DeliveryMode is DIRECT unless the AD flag is set. The
          // deliveryMode parameter (and all other guaranteed messaging
          // parameters may be present in demoted messages reflecting how
          // the message was published.
          // IF ever solClientJS must support the horror that is cut-through
          // persistence, then we must defer setting deliveryMode back to
          // DIRECT until the session decides whether it is a true direct
          // message or a cut-through direct message.  But until that is
          // forced upon us, the cleanest place to set deliveryMode is always
          // here in the parser.
          if (smfHeader.smf_adf) {
            smfHeader.pm_deliverymode = ParamParse.parseDeliveryMode(data, pos);
          }
          break;
        case SMFParameterType.ASSURED_MESSAGE_ID:
          smfHeader.pm_ad_msgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.ASSURED_PREVMESSAGE_ID:
          smfHeader.pm_ad_prevmsgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.ASSURED_REDELIVERED_FLAG:
          smfHeader.pm_ad_redelflag = true;
          break;
        case SMFParameterType.AD_TIMETOLIVE:
          smfHeader.pm_ad_ttl = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.AD_TOPICSEQUENCE_NUMBER:
          smfHeader.pm_ad_topicSequenceNumber = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.MESSAGE_CONTENT_SUMMARY:
          {
            var contentSummary = ParamParse.parseContentSummary(data, pos, pValueLen);
            if (!contentSummary) {
              LOG_ERROR(("Invalid message content summary at " + pos + ", len " + pValueLen));
              return false; // invalid message content summary parameter
            }
            smfHeader.pm_content_summary = contentSummary;
            break;
          }
        case SMFParameterType.ASSURED_FLOWID:
          smfHeader.pm_ad_flowid = strToUInt32(data.substr(pos, 4));
          break;
        case SMFParameterType.TR_TOPICNAME:
          // copy bytes. Don't strip null terminator
          smfHeader.pm_tr_topicname_bytes = data.substr(pos, pValueLen);
          break;
        case SMFParameterType.AD_FLOWREDELIVERED_FLAG:
          smfHeader.pm_ad_flowredelflag = true;
          break;
        default:
          if (prmUh === 0) {
            // Ignore, and silently discard the parameter.
            LOG_TRACE(("Unhandled SMF parameter type: " + pType + " UH is " + prmUh + " discarding parameter."));
          } else {
            // Ignore, and silently discard the entire message.
            LOG_TRACE(("Unhandled SMF parameter type: " + pType + " UH is " + prmUh + " discarding message."));
            smfHeader.discardMessage = true;
          }
          break;
      } // end param type switch block

      pos += pValueLen;
    } // end (regular param)
  } // end while

  return smfHeader;
}

var ParseSMF = {
  isSMFHeaderAvailable: isSMFHeaderAvailable,
  isSMFHeaderValid: isSMFHeaderValid,
  isSMFAvailable: isSMFAvailable,
  parseSMFAt: parseSMFAt,
};

module.exports.ParseSMF = ParseSMF;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(0);
var BidiMap = ref.BidiMap;

var PriorityUserCosMap = (function (BidiMap) {
  function PriorityUserCosMap() {
    BidiMap.call(this, [MessageLib.MessageUserCosType.COS1, 0],
          [MessageLib.MessageUserCosType.COS2, 1],
          [MessageLib.MessageUserCosType.COS3, 2]);
  }

  if ( BidiMap ) PriorityUserCosMap.__proto__ = BidiMap;
  PriorityUserCosMap.prototype = Object.create( BidiMap && BidiMap.prototype );
  PriorityUserCosMap.prototype.constructor = PriorityUserCosMap;

  return PriorityUserCosMap;
}(BidiMap));

module.exports.PriorityUserCosMap = PriorityUserCosMap;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(79);
var SMFSMPMessageType = ref$2.SMFSMPMessageType;
var ref$3 = __webpack_require__(13);
var SMPMessage = ref$3.SMPMessage;

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

var SMP = {
  parseSMPAt: function parseSMPAt(data, offset) {
    if ((offset + 6) > data.length) {
                // not enough data
      LOG_DEBUG('Not enough data to read an SMP message.');
      return false;
    }
    var pos = offset;
    var onebyte = strToInt8(data.substr(pos, 1));
    pos++;

            // var msgUh = bits(onebyte, 7, 1);
    var msgType = bits(onebyte, 0, 7);
    var smpMsg = new SMPMessage();

    if (!(msgType === SMFSMPMessageType.ADDSUBSCRIPTION ||
          msgType === SMFSMPMessageType.REMSUBSCRIPTION)) {
      LOG_DEBUG(("Found unsupported SMP messageType " + msgType));
      return false; // unsupported type
    }

    var msgLength = strToUInt32(data.substr(pos, 4));
    pos += 4;
    if ((offset + msgLength) > data.length) {
                  // not enough data
      LOG_DEBUG(("Invalid declared length of " + msgLength + ", unable to read SMP message."));
      return false;
    }
    var msgFlags = strToInt8(data.substr(pos, 1));
    pos++;

    smpMsg.msgType = msgType;
    smpMsg.smpFlags = msgFlags;
    smpMsg.encodedUtf8Subscription = data.substr(pos, msgLength - 6); // 6 is the base len
    return smpMsg;
  },

  encSmp: function encSmp(smpMsg) {
    if (!(smpMsg.msgType === SMFSMPMessageType.ADDSUBSCRIPTION ||
          smpMsg.msgType === SMFSMPMessageType.REMSUBSCRIPTION)) {
      LOG_DEBUG(("Unsupported SMP message for encoding: " + smpMsg));
      return false;
    }

    var data = [];
    var onebyte = 0;
    onebyte = setBits(onebyte, 1, 7, 1);
    onebyte = setBits(onebyte, smpMsg.msgType, 0, 7);
    data.push(int8ToStr(onebyte));
    data.push(int32ToStr(6 + smpMsg.encodedUtf8Subscription.length)); // length
    data.push(int8ToStr(smpMsg.smpFlags));
    data.push(smpMsg.encodedUtf8Subscription);
    return data.join('');
  },
};

module.exports.SMP = SMP;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(0);
var Lazy = ref$1.Lazy;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(131);
var SMFTransportSessionMessageType = ref$3.SMFTransportSessionMessageType;
var ref$4 = __webpack_require__(13);
var TransportSMFMessage = ref$4.TransportSMFMessage;

var bits = Bits.get;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int32ToStr = Convert.int32ToStr;
var lazyValue = Lazy.lazyValue;

// ========== TSSMF ==========
function remains(data, offset) {
  return data.length - offset;
}

function parseTsSmfHdrAt(data, offset, smfheader) {
  var pos = offset;
  if (remains(data, pos) < 10) {
    LOG_ERROR('TsSmf parse failed: not enough data, expected at least 10B');
    return false;
  }

  var transportSMFMessage = new TransportSMFMessage();
  transportSMFMessage.smfHeader = smfheader;
  var twobyte = strToInt16(data.substr(pos, 2));
  pos += 2;
  transportSMFMessage.uh = bits(twobyte, 15, 1);
  transportSMFMessage.messageType = bits(twobyte, 8, 7);
  var tsHdrLen = bits(twobyte, 0, 8);
  transportSMFMessage.tsHeaderLength = tsHdrLen;
  transportSMFMessage.sessionId = data.substr(pos, 8);
  pos += 8;

  if (transportSMFMessage.messageType ===
      SMFTransportSessionMessageType.CREATE_RESP) {
    // parse extra chunk: routerTag
    var rtrTagLen = strToInt8(data.substr(pos, 1));
    pos++;
    if (remains(data, pos) < rtrTagLen) {
      LOG_ERROR(("TsSmf parse failed: not enough data for RouterTag, expected " + rtrTagLen + "B"));
      return false;
    }
    transportSMFMessage.routerTag = data.substr(pos, rtrTagLen);
    pos += rtrTagLen;
  }

  // FFWD any remaining TsSmf padding?
  pos = offset + tsHdrLen;

  // Length of encapsulated message payload:
  // the SMF msg payload length - bytes consumed in TsSmf

  if (smfheader.payloadLength === 0xffffffff) {
    // special "streaming" unknown-length header
    transportSMFMessage.payloadLength = smfheader.payloadLength;
  } else {
    transportSMFMessage.payloadLength = smfheader.payloadLength - tsHdrLen;
  }
  return transportSMFMessage; // Header with no payload field
}

// Generates an SMF header up to, but not including the the total length
// This is fixed for all client generated transport session messages
var tsHeaderPreLength = lazyValue(function () { return (
  int32ToStr(0x03140001) +  // SMF version, TransportSession, TTL
  int32ToStr(12)            // Header length
); });

var tsDestroyHeaderPreSid = lazyValue(function () { return (
  tsHeaderPreLength.value + // Header up to the message length field
  int32ToStr(22) +          // Total length
  int16ToStr(0x820a)        // msgType(destroy), length
); });

var tsCreateHeader = lazyValue(function () { return (
  tsHeaderPreLength.value + // Header up to the message length field
  int32ToStr(22) +          // Total length
  int16ToStr(0x800a) +      // msgType(create), length
  int32ToStr(0) +           // Session ID (first half)
  int32ToStr(0)             // Session ID (second half)
); });

var tsDataTokenPreSid = lazyValue(function () { return (
  int32ToStr(0x03940001) +
  int32ToStr(12) +
  int32ToStr(22) +
  int16ToStr(0x850a)
); });

var tsDataStreamTokenPreSid = lazyValue(function () { return (
  int32ToStr(0x03940001) +
  int32ToStr(12) +
  int32ToStr(24) +
  int16ToStr(0x860c)
); });

// Generate a full Transport Session Create header
function genTsCreateHeader() {
  return tsCreateHeader.value;
}

// Generate a full Transport Session Destroy header
function genTsDestroyHeader(sid) {
  return (
    tsDestroyHeaderPreSid.value +
    sid                       // Session ID
  );
}

// Generate a data token message
function genTsDataTokenMsg(sid) {
  return (
    tsDataTokenPreSid.value +
    sid
  );
}

// Generate a STREAMING data token message
function genTsDataStreamTokenMsg(sid, paddingBytes) {
  return (
    tsDataStreamTokenPreSid.value +
    sid +
    ((paddingBytes && paddingBytes > 0) ? int16ToStr(paddingBytes) : int16ToStr(0x0000))
  );
}

function genTsDataMsgHeaderParts(sid) {
  return [
    (int32ToStr(0x03940001) + int32ToStr(12)),
    (int16ToStr(0x840a) + sid) ];
}

function parseTsSmfMsgAt(data, offset, smfheader) {
  var transportSMFMessage = parseTsSmfHdrAt(data, offset, smfheader);
  if (!transportSMFMessage) {
    return null;
  }

    // need to FF to pos
  var pos = offset + transportSMFMessage.tsHeaderLength;

    // Length of encapsulated message payload:
    // the SMF msg payload length - bytes consumed in TsSmf
  if (remains(data, pos) < transportSMFMessage.payloadLength) {
    LOG_ERROR(("Couldn't read full encapsulated TsSmf payload, expected " + (transportSMFMessage.payloadLength) + "B"));
    return null;
  }

  transportSMFMessage.payload = data.substr(pos, transportSMFMessage.payloadLength); // router tag
  return transportSMFMessage;
}

var Transport = {
  genTsCreateHeader: genTsCreateHeader,
  genTsDestroyHeader: genTsDestroyHeader,
  genTsDataTokenMsg: genTsDataTokenMsg,
  genTsDataStreamTokenMsg: genTsDataStreamTokenMsg,
  genTsDataMsgHeaderParts: genTsDataMsgHeaderParts,
  parseTsSmfHdrAt: parseTsSmfHdrAt,
  parseTsSmfMsgAt: parseTsSmfMsgAt,
};

module.exports.Transport = Transport;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var SMFUH = {
  IGNORE: 0x0,
  REJECT: 0x2,
};

module.exports.SMFUH = Enum.new(SMFUH);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFAdProtocolMessageType = {
  OPENPUBFLOW:      0x00,
  // INTERROUTERACK:          0x01,
  // INTERROUTERHANDSHAKEACK: 0x02,
  CLIENTACK:        0x03,
  BIND:             0x04,
  UNBIND:           0x05,
  UNSUBSCRIBE:      0x06,
  CLOSEPUBFLOW:     0x07,
  CREATE:           0x08,
  DELETE:           0x09,
  // FLOWRECOVER:  0x0a,
  TRANSACTIONCTRL:  0x0b,
  FLOWCHANGEUPDATE: 0x0c,
  // EXTERNALACK:      0x0d,
  XACTRL:           0x0e,
  CLIENTNACK:       0x0f,
  // TXNCTRL:          0x10,
};

module.exports.SMFAdProtocolMessageType = Enum.new(SMFAdProtocolMessageType);


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFAdProtocolParam = {
  LASTMSGIDSENT:                           0x01,
  LASTMSGIDACKED:                          0x02,
  WINDOW:                                  0x03,
  TRANSPORT_PRIORITY:                      0x04,
  APPLICATION_ACK:                         0x05,
  FLOWID:                                  0x06,
  QUEUENAME:                               0x07,
  DTENAME:                                 0x08,
  TOPICNAME:                               0x09,
  FLOWNAME:                                0x0a,
  EP_DURABLE:                              0x0b,
  ACCESSTYPE:                              0x0c,
  SELECTOR:                                0x0d,
  TRANSPORT_WINDOW:                        0x0e,
  LINGER_OPTION:                           0x0f,
  LASTMSGIDRECEIVED:                       0x10,
  EP_ALLOTHER_PERMISSION:                  0x11,
  FLOWTYPE:                                0x12,
  EP_QUOTA:                                0x13,
  EP_MAX_MSGSIZE:                          0x14,
  GRANTED_PERMISSIONS:                     0x15,
  EP_RESPECTS_TTL:                         0x16,
  TRANSACTION_CTRL_MESSAGE_TYPE:           0x17,
  TRANSACTED_SESSION_ID:                   0x18,
  TRANSACTED_SESSION_NAME:                 0x19,
  TRANSACTION_ID:                          0x1a,
  TRANSACTED_SESSION_STATE:                0x1b,
  TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:  0x1c,
  TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:     0x1d,
  TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:     0x1e,
  NOLOCAL:                                 0x1f,
  ACTIVE_FLOW_INDICATION:                  0x20,
  WANT_FLOW_CHANGE_NOTIFY:                 0x21,
  EP_BEHAVIOUR:                            0x22,
  PUBLISHER_ID:                            0x23,
  APPLICATION_PUB_ACK:                     0x24,
  NUM_MESSAGES_SPOOLED:                    0x25,
  CUT_THROUGH:                             0x26,
  PUBLISHER_FLAGS:                         0x27,
  APP_MSG_ID_TYPE:                         0x28,
  QUEUE_ENDPOINT_HASH:                     0x29,
  MAX_REDELIVERY:                          0x2a,
  PAYLOAD:                                 0x2b,
  ENDPOINT_ID:                             0x2c,
  ACK_SEQUENCE_NUMBER:                     0x2d,
  ACK_RECONCILE_REQUEST:                   0x2e,
  START_OF_ACK_RECONCILE:                  0x2f,
  TIMESTAMP:                               0x30,
  MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW: 0x31,
};

module.exports.SMFAdProtocolParam = Enum.new(SMFAdProtocolParam);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFClientCtrlMessageType = {
  LOGIN:  0x00,
  UPDATE: 0x01,
};

module.exports.SMFClientCtrlMessageType = Enum.new(SMFClientCtrlMessageType);


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFClientCtrlParam = {
  SOFTWAREVERSION:              0x00,
  SOFTWAREDATE:                 0x01,
  PLATFORM:                     0x02,
  USERID:                       0x03,
  CLIENTDESC:                   0x04,
  CLIENTNAME:                   0x05,
  MSGVPNNAME:                   0x06,
  DELIVERTOONEPRIORITY:         0x07,
  P2PTOPIC:                     0x08,
  ROUTER_CAPABILITIES:          0x09,
  VRIDNAME:                     0x0a,
  PHYSICALROUTERNAME:           0x0c,
  BRIDGE_MSG_VPN_NAME:          0x0d,
  BRIDGE_ROUTER_NAME:           0x0e,
  NO_LOCAL:                     0x0f,
  BRIDGE_VERSION:               0x10,
  AUTHENTICATION_SCHEME:        0x11,
  CONNECTION_TYPE:              0x12,
  ROUTER_CAPABILITIES_EXTENDED: 0x13,
};

module.exports.SMFClientCtrlParam = Enum.new(SMFClientCtrlParam);


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFSMPMessageTypeFlags = {
  FLAG_FILTER:                1,
  FLAG_PERSIST:               2,
  SMF_SMP_FLAG_TOPIC:         4,
  SMF_SMP_FLAG_RESPREQUIRED:  8,
  SMF_SMP_FLAG_DELIVERALWAYS: 16,
};

module.exports.SMFSMPMessageTypeFlags = Enum.new(SMFSMPMessageTypeFlags);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFTransportSessionMessageType = {
  CREATE:            0,
  CREATE_RESP:       1,
  DESTROY:           2,
  DESTROY_RESP:      3,
  DATA:              4,
  DATA_TOKEN:        5,
  DATA_STREAM_TOKEN: 6,
};

module.exports.SMFTransportSessionMessageType = Enum.new(SMFTransportSessionMessageType);


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/**
 * This callback is called by a cache session when a cache request
 * completes.
 *
 * @callback solace.CacheCBInfo.cacheRequestCallback
 * @function
 * @param {Number} requestID The ID of the request on which the event is notified.
 * @param {solace.CacheRequestResult} result The result of the cache request.
 * @param {Object} userObject The user object provided.
 */


/**
 * @classdesc
 * Encapsulates a {@link solace.CacheSession}'s request listener callback function and
 * optional application-specified context object.
 *
 * Instances of this class are required as a parameter to
 * {@link solace.CacheSession#sendCacheRequest} when creating a CacheSession request.
 *
 * @memberof solace
 */
var CacheCBInfo = function CacheCBInfo(cacheCBFunction, userObject) {
  /**
   * The function that will be called by the cache session when a request
   * completes.
   * @type {solace.CacheCBInfo.cacheRequestCallback}
   */
  this.cacheCBFunction = cacheCBFunction;

  /**
   * The user context object that will be supplied to the callback function
   * when the cache request completes.
   * @type {object}
   */
  this.userObject = userObject;
};

/**
 * @returns {solace.CacheCBInfo.cacheRequestCallback} The callback function
 * @private
 */
CacheCBInfo.prototype.getCallback = function getCallback () {
  return this.cacheCBFunction;
};

/**
 * @returns {*} The user context object, if any
 * @private
 */
CacheCBInfo.prototype.getUserObject = function getUserObject () {
  return this.userObject;
};

module.exports.CacheCBInfo = CacheCBInfo;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * solace.CacheLiveDataAction
 * Enumeration of CacheLiveDataAction values, specifying how the CacheSession should handle
 * live data associated with a cache request in progress.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheLiveDataAction = {
  /**
   * @type {Number}
   * @description End the cache request when live data arrives that matches the topic.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
  FULFILL:   1,
  /**
   * @type {Number}
   * @description Queue arriving live data that matches the topic, until the cache request
   * completes. Note that wildcard cache requests must always be {@link
   * solace.CacheLiveDataAction.FLOW_THRU}.
   */
  QUEUE:     2,
  /**
   * @type {Number}
   * @description Continue the outstanding cache request while allowing live data to flow through to
   * the application.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
  FLOW_THRU: 3,
};

module.exports.CacheLiveDataAction = Enum.new(CacheLiveDataAction);


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. A CacheRequestResult object is
 * provided on the callback (see {@link solace.CacheCBInfo.cacheRequestCallback} when a cache
 * request completes.</b>
 *
 * An object that indicates the termination of a cache request, and provides details how it
 * concluded.
 * @memberof solace
 * @hideconstructor
 */
var CacheRequestResult = function CacheRequestResult(rc, subcode, topic, error) {
  this._returnCode = rc;
  this._subcode = subcode;
  this._topic = topic;
  this._error = error;
};

/**
 * Gets the return code from the cache request result.
 *
 * @returns {solace.CacheReturnCode} The return code associated with the result of
 * the request.
 */
CacheRequestResult.prototype.getReturnCode = function getReturnCode () {
  return this._returnCode;
};

/**
 * Gets the return subcode from the cache request result.
 *
 * @returns {solace.CacheReturnSubcode} A subcode that gives more detail than
 * {@link CacheRequestResult#getReturnCode} about the result of the request.
 */
CacheRequestResult.prototype.getReturnSubcode = function getReturnSubcode () {
  return this._subcode;
};

/**
 * Gets the topic object associated with the cache request.
 *
 * @returns {solace.Destination} The topic destination supplied for the cache request.
 */
CacheRequestResult.prototype.getTopic = function getTopic () {
  return this._topic;
};


/**
 * Gets the error, if any, associated with the returned result.
 *
 * @returns {String} The error associated with the returned result.
 */
CacheRequestResult.prototype.getError = function getError () {
  return this._error;
};

module.exports.CacheRequestResult = CacheRequestResult;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(81);
var CacheContext = ref.CacheContext;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;

var CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;

/**
 * @private
 */
var CacheRequest = function CacheRequest(cacheSession, cacheMessageType, requestID, cbInfo, liveDataAction, topic, cacheName) {
  this.cacheSession = cacheSession;
  this.cacheMessageType = cacheMessageType;
  this.requestID = requestID;
  this.cbInfo = cbInfo;
  this.liveDataAction = liveDataAction;
  this.topic = topic;
  this.cacheName = cacheName;

  this.subscriptionWaiting = null;
  this.replyReceived = false;
  this.dataReceived = false;
  this.isSuspect = false;

  this.correlationID = "" + CACHE_REQUEST_PREFIX + (CacheContext.cacheRequestCorrelationId++);

  this.childRequests = [];
  this.parentRequest = null;

  this.queuedLiveData = [];
  this.liveDataFulfilled = false;

  this.timeoutHandle = null;
};

/**
 * @returns {CacheRequest} The root cache request in the current request tree
 * @private
 */
CacheRequest.prototype.getRootRequest = function getRootRequest () {
  if (!this.parentRequest) {
    return this;
  }
  return this.parentRequest.getRootRequest();
};

/**
 * @param {CacheRequest} childIn A request to make a descendant of this node in the request tree
 * @private
 */
CacheRequest.prototype.addChild = function addChild (childIn) {
  if (!(childIn instanceof CacheRequest)) {
    throw new Error(("Invalid child " + childIn));
  }
  if (childIn === this) {
    throw new Error('Constructing circular child reference');
  }
  var child = childIn;
  child.parentRequest = this;
  this.childRequests.push(child);
};

/**
 * @param {CacheRequest} childIn A request to remove as a descendant of this node
 * @private
 */
CacheRequest.prototype.removeChild = function removeChild (childIn) {
  if (childIn === this) {
    throw new Error('Attempting to deconstruct invalid circular child reference');
  }
  var child = childIn;
  var childIndex = this.childRequests.indexOf(child);
  if (childIndex === -1) {
    LOG_DEBUG(("Child " + child + " not found in " + (this)));
  }
  this.childRequests.splice(childIndex, 1);
  child.parentRequest = null;
};

/**
 * @private
 */
CacheRequest.prototype.collapse = function collapse () {
  var parentRequest = this.parentRequest;
  parentRequest.isSuspect = parentRequest.isSuspect || this.isSuspect;
  parentRequest.dataReceived = parentRequest.dataReceived || this.dataReceived;
  parentRequest.removeChild(this);
};

/**
 * @private
 */
CacheRequest.prototype.cancel = function cancel () {
    var this$1 = this;

  if (this.parentRequest) {
    this.collapse();
  }

  while (this.childRequests.length) {
    var child = this$1.childRequests.shift();
    if (child.childRequests) {
      child.cancel();
    }
    this$1.removeChild(child);
  }

  this.clearRequestTimeout();
};

/**
 * @returns {Number} The ID of this request
 * @private
 */
CacheRequest.prototype.getRequestID = function getRequestID () {
  return this.requestID;
};


/**
 * @returns {CacheCBInfo} The callback object for this request
 * @private
 */
CacheRequest.prototype.getCBInfo = function getCBInfo () {
  return this.cbInfo;
};

/**
 * @returns {Topic} The topic for this request
 * @private
 */
CacheRequest.prototype.getTopic = function getTopic () {
  return this.topic;
};


/**
 * @returns {CacheLiveDataAction} The live data action for this request
 * @private
 */
CacheRequest.prototype.getLiveDataAction = function getLiveDataAction () {
  return this.liveDataAction;
};

/**
 * @param {function({solace.CacheRequest})} cacheSessionTimeoutCB Callback to notify on timeout
 * @param {Number} timeoutMsec Timeout in milliseconds
 * @private
 */
CacheRequest.prototype.startRequestTimeout = function startRequestTimeout (cacheSessionTimeoutCB, timeoutMsec) {
    var this$1 = this;

  this.timeoutHandle = setTimeout(function () {
    cacheSessionTimeoutCB(this$1);
  }, timeoutMsec);
};

/**
 * @private
 */
CacheRequest.prototype.clearRequestTimeout = function clearRequestTimeout () {
  if (this.timeoutHandle === null || this.timeoutHandle === undefined) {
    return;
  }

  LOG_DEBUG(("Clearing timeout for " + (this)));
  clearTimeout(this.timeoutHandle);
  this.timeoutHandle = null;
};

/**
 * Returns a string representing the request.
 * @returns {String} A brief description of this object
 */
CacheRequest.prototype.toString = function toString () {
  return ("CacheRequest[correlationID=" + (this.correlationID) + ",requestID=" + (this.requestID) + ",cacheName=" + (this.cacheName) + ",topic=" + (this.topic.getName()) + "]");
};

/**
 * @private
 */
CacheRequest.VERSION = 1;

/**
 * @private
 */
CacheRequest.DEFAULT_REPLY_SIZE_LIMIT = 1000000;

/**
 * @private
 */
CacheRequest.REPLY_SIZE_LIMIT = CacheRequest.DEFAULT_REPLY_SIZE_LIMIT;

module.exports.CacheRequest = CacheRequest;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of CacheReturnCode types.  The method {@link solace.CacheRequestResult#getReturnCode}
 * returns on of these basic results of a cache request.  More details are available in the
 * associated {@link solace.CacheReturnSubcode}, retrieved by
 * {@link solace.CacheRequestResult#getReturnSubcode}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheReturnCode = {
  /**
   * @type {Number}
   * @description The cache request succeeded.  See the subcode for more information.
   */
  OK:         1,
  /**
   * @type {Number}
   * @description The cache request was not processed.  See the subcode for more information.
   */
  FAIL:       2,
  /**
   * @type {Number}
   * @description The cache request was processed but could not be completed.  See the subcode for
   * more information.
   */
  INCOMPLETE: 3,
};

module.exports.CacheReturnCode = Enum.new(CacheReturnCode);


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of CacheReturnSubcode types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheReturnSubcode = {
  /**
   * @type {Number}
   * @description
   * The cache request completed successfully.
   */
  REQUEST_COMPLETE:            0,
  /**
   * @type {Number}
   * @description
   * The cache request completed when live data arrived on the topic requested.
   */
  LIVE_DATA_FULFILL:           1,
  /**
   * @type {Number}
   * @description
   * The cache instance or session returned an error response to the cache request.
   */
  ERROR_RESPONSE:              2,
  /**
   * @type {Number}
   * @description
   * The cache request failed because the {@link Session} used to construct it has been
   * disposed.
   */
  INVALID_SESSION:             3,
  /**
   * @type {Number}
   * @description
   * The cache request failed because the request timeout expired.
   */
  REQUEST_TIMEOUT:             4,
  /**
   * @type {Number}
   * @description
   * The cache request was made on the same topic as an existing request, and
   * {@link CacheLiveDataAction.FLOW_THRU} was not set.
   */
  REQUEST_ALREADY_IN_PROGRESS: 5,
  /**
   * @type {Number}
   * @description
   * The cache reply returned no data.
   */
  NO_DATA:                     6,
  /**
   * @type {Number}
   * @description
   * The cache reply returned suspect data.
   */
  SUSPECT_DATA:                7,
  /**
   * @type {Number}
   * @description
   * The request was terminated because the cache session was disposed.
   */
  CACHE_SESSION_DISPOSED:      8,
  /**
   * @type {Number}
   * @description
   * The request was terminated because the subscription request for the specified topic failed.
   */
  SUBSCRIPTION_ERROR:          9,
};

module.exports.CacheReturnSubcode = Enum.new(CacheReturnSubcode);


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * @classdesc
 *
 * Encapsulates the properties of a cache session.
 *
 * @memberof solace
 *
 */
var CacheSessionProperties = function CacheSessionProperties(cacheName, maxAgeSec, maxMessages, timeoutMsec) {
  /**
   * @type {String}
   *
   * @description A property that specifies the cache name to which CacheSession operations should
   * be sent.
   */
  this.cacheName = cacheName;

  /**
   * @type {Number}
   *
   * @description The maximum allowable message age in seconds to deliver in response to cache
   * requests.0 means no restriction on age.
   *
   * @default 0
   */
  this.maxAgeSec = maxAgeSec || 0;

  /**
   * @type {Number}
   *
   * @description The maximum number of messages per Topic to deliver in response to cache
   * requests.0 means no restriction on the number of messages.
   *
   * @default 1
   */
  this.maxMessages = (maxMessages === null || maxMessages === undefined) ? 1 : maxMessages;

  /**
   * @type {Number}
   *
   * @description The timeout for a cache request, in milliseconds.The valid range for this
   * property is >= 3000.
   *
   * @default 10000
   */
  this.timeoutMsec = timeoutMsec || 10000;

  /**
   * @private
   * @type {Boolean}
   * @description Whether to include other clusters in the request.
   * @default true
   */
  this.includeOtherClusters = true;

  /**
   * @private
   */
  this.cachePrefix = '#P2P/CACHEINST/';
};

/**
 * Gets the cache name to which {@link solace.CacheSession} requests should be sent, for
 * sessions constructed using these properties.
 *
 * @returns {String} The cache name.
 */
CacheSessionProperties.prototype.getCacheName = function getCacheName () {
  return this.cacheName;
};

/**
 * Sets the cache name to which requests should be sent. Cannot be null or blank.
 * @param {String} value The cache name to which requests should be sent.
 */
CacheSessionProperties.prototype.setCacheName = function setCacheName (value) {
  this.cacheName = value;
};

/**
 * Gets the maximum allowable message age for messages to be delivered in response to a request
 * made on a {@link solace.CacheSession} that was constructed using these properties.0 means no
 * restriction on age.
 *
 * @returns {Number} The maximum allowable message age to be returned by an associated {@link
 * solace.CacheSession}, or 0 for no restriction.
 */
CacheSessionProperties.prototype.getMaxMessageAgeSec = function getMaxMessageAgeSec () {
  return this.maxAgeSec;
};

/**
 * Sets the maximum allowable message age. 0 means no restriction on age.
 *
 * @param {Number} value The maximum allowable message age, or 0 for no restriction.
 */
CacheSessionProperties.prototype.setMaxMessageAgeSec = function setMaxMessageAgeSec (value) {
  this.maxAgeSec = value;
};

/**
 * Gets the maximum count of messages to be delivered, per {@link solace.Destination}, in
 * response to a request issued on a {@link solace.CacheSession} constructed using these
 * properties.0 means no restriction on the number of messages.
 *
 * @returns {Number} The maximum number of messages per Topic to deliver, or 0 for no restriction.
 */
CacheSessionProperties.prototype.getMaxMessages = function getMaxMessages () {
  return this.maxMessages;
};

/**
 * Sets the maximum count of messages to be delivered per {@link solace.Destination} in response
 * to a cache request. 0 means no restriction.
 *
 * @param {Number} value The maximum count of messages to deliver, or 0 for no restriction.
 */
CacheSessionProperties.prototype.setMaxMessages = function setMaxMessages (value) {
  this.maxMessages = value;
};

/**
 * Gets the timeout for requests issued on a {@link solace.CacheSession} constructed
 * using these properties.
 ** The valid range is >= 3000.
 *
 * @returns {Number} The timeout, in milliseconds, for cache session requests.
 */
CacheSessionProperties.prototype.getTimeoutMsec = function getTimeoutMsec () {
  return this.timeoutMsec;
};

/**
 * Sets the timeout for requests.
 ** The valid range is >= 3000.
 * @param {Number} value The timeout for requests.
 */
CacheSessionProperties.prototype.setTimeoutMsec = function setTimeoutMsec (value) {
  this.timeoutMsec = value;
};

module.exports.CacheSessionProperties = CacheSessionProperties;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(286);
var SolclientSessionLib = __webpack_require__(21);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_WARN = ref$1.LOG_WARN;

/**
 * Node TLS socket option generation factored out from WS transport, shared with Tcp transport.
 * Internal mixin class, not intended to be publicly visible.
 * @private
 */

var NodeTLSOptsMixin = function NodeTLSOptsMixin () {};

NodeTLSOptsMixin.prototype.checkCertificateCNs = function checkCertificateCNs (host, cert) {
  if (this._props.sslTrustedCommonNameList && this._props.sslTrustedCommonNameList.length > 0) {
    // no Closure Compiler externs for certificates
    LOG_DEBUG('server cert:', cert);
    var subject = cert['subject']; // eslint-disable-line dot-notation
    var valid = false;
    if (subject) {
      var cn = subject['CN']; // eslint-disable-line dot-notation
      valid = this._props.sslTrustedCommonNameList.some(function (name) { return name.toLowerCase() === cn.toLowerCase(); }
      );
    }
    if (!valid) {
      var error = new Error('Server certificate not trusted - no common name match');
      error.reason = 'Server certificate not trusted - no common name match';
      error.host = host;
      error.cert = cert;
      return error;
    }
  }
  return undefined;
};

/**
 * Create the TLS options object used in wss:// and tcps:// connection establishment.
 * The same options are needed by the ws and tls socket constructors.
 * @returns {Object} WebSocket/TLSSocket options object
 * @private
 */
NodeTLSOptsMixin.prototype.createTLSOptions = function createTLSOptions () {
  /* eslint-disable dot-notation */
  var props = this._props;
  var options = {};
  var useClientCert = (
    props.authenticationScheme === SolclientSessionLib.AuthenticationScheme.CLIENT_CERTIFICATE
  );

  // available tls options:
  //pfx, key, passphrase, cert, ca, ciphers, rejectUnauthorized,
  //secureProtocol, secureOptions, checkServerIdentity

  // default to allow all version of SSL during negotiation but exclude SSLv2 and SSLv3
  options['secureProtocol'] = 'SSLv23_method';
  var constMap = SolclientSessionLib.SessionProperties.SslProtocolExcludeConstantMap;
  options['secureOptions'] = constMap['sslv2'] | constMap['sslv3'];
  (props.sslExcludedProtocols || []).forEach(function (protocol) {
    options['secureOptions'] |= constMap[protocol.toLowerCase()];
  });

  if (props.sslCipherSuites) {
    var ciphers = props.sslCipherSuites.split(',');
    var trimmed = ciphers.map(function (cipher) { return cipher.trim(); });
    options['ciphers'] = trimmed.join(':');
  } else {
    options['ciphers'] = props.sslCipherSuites;
  }

  options['rejectUnauthorized'] = props.sslValidateCertificate;

  // only set checkServerIdentity callback if rejectUnauthorized
  if (options['rejectUnauthorized'] && Array.isArray(props.sslTrustedCommonNameList)) {
    options['checkServerIdentity'] = this.checkCertificateCNs.bind(this);
  }

  // only set trust stores and and checkServerIdentity callback
  // if rejectUnauthorized is true or authClientCert
  if ((options['rejectUnauthorized'] || useClientCert) &&
    props.sslTrustStores && props.sslTrustStores.length) {
    var tsContents = [];
    props.sslTrustStores.forEach(function (tsFile) {
      try {
        tsContents.push(fs.readFileSync(tsFile));
      } catch (e) {
        LOG_WARN(("Failed to load trust store " + tsFile), e.message);
        LOG_TRACE('Error details:', e.stack || e);
        throw new OperationError(("Failed to load trust store " + tsFile),
          ErrorSubcode.FAILED_LOADING_TRUSTSTORE,
          e);
      }
    });
    options['ca'] = tsContents;
  }


  if (useClientCert) {
    if (props.sslPfx) {
      try {
        options['pfx'] = fs.readFileSync(props.sslPfx);
        options['passphrase'] = props.sslPfxPassword;
      } catch (e) {
        LOG_WARN(("Failed to load pfx file " + (props.sslPfx)), e.message);
        LOG_TRACE('Error details:', e.stack || e);
        throw new OperationError(("Failed to load pfx " + (props.sslPfx)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
    if (props.sslPrivateKey) {
      try {
        options['key'] = fs.readFileSync(props.sslPrivateKey);
        options['passphrase'] = props.sslPrivateKeyPassword;
      } catch (e) {
        LOG_WARN(("Failed to load private key " + (props.sslPrivateKey)), e.message);
        LOG_TRACE('Error details:', e.stack || e);
        throw new OperationError(("Failed to load private key " + (props.sslPrivateKey)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
    if (props.sslCertificate) {
      try {
        options['cert'] = fs.readFileSync(props.sslCertificate);
      } catch (e) {
        LOG_WARN(("Failed to load certificate file " + (props.sslCertificate)), e.message);
        LOG_TRACE('Error details:', e.stack || e);
        throw new OperationError(("Failed to load certificate " + (props.sslCertificate)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
  }
  return options;
  /* eslint-enable dot-notation */
};

module.exports.NodeTLSOptsMixin = NodeTLSOptsMixin;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;

var SMFClient = (function () {
  if (typeof navigator !== 'undefined') {
    /* eslint-env browser */
    if (navigator.appVersion.indexOf('MSIE 9.') !== -1) {
      return __webpack_require__(238).StringSMFClient;
    }
  }
  /* eslint-env shared-browser-node */
  return __webpack_require__(237).BufferSMFClient;
})();

SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG = BaseSMFClient.SMF_MAX_CORRELATION;

module.exports.SMFClient = SMFClient;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * @private
 * @constructor
 */
var TransportClientStats = function TransportClientStats() {
  this.bytesWritten = 0;
  this.msgWritten = 0;
};

module.exports.TransportClientStats = TransportClientStats;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var Base64 = ref.Base64;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var LOG_WARN = ref$1.LOG_WARN;
var LOG_ERROR = ref$1.LOG_ERROR;
var ref$2 = __webpack_require__(245);
var sendXhrBinary = ref$2.sendXhrBinary;
var sendXhrText = ref$2.sendXhrText;
var ref$3 = __webpack_require__(4);
var StringBuffer = ref$3.StringBuffer;
var TimingBucket = ref$3.TimingBucket;
var ref$4 = __webpack_require__(17);
var TransportReturnCode = ref$4.TransportReturnCode;
var ref$5 = __webpack_require__(143);
var XHRFactory = ref$5.XHRFactory;

var arrayBufferToString = Convert.arrayBufferToString;

var SOL_CONNECTION_DEBUG = false;

/**
 * A URI starting with a "/" is a "path-absolute" URI, and those aren't
 * allowed to have a query component (starting with "?").
 *
 * If an origin isn't defined in the url, tack on the one from the page.
 *
 * @param {URL} url The URL to connect to
 * @returns {URL} Adjusted URL if incoming URL was relative
 * @private
 */
function prependOrigin(url) {
  if (!url.match(/^(http|ws)(s?):/i) && window.location && window.location.origin) {
    return window.location.origin + ((url.charAt(0) !== '/') ? '/' : '') + url;
  }
  return url;
}

function getTs() {
  return new Date().getTime();
}

var Stats = function Stats() {
  this.WaitedToken = new TimingBucket('WaitedToken', 100);
  this.HadToken = new TimingBucket('HadToken', 100);
  this.ReturnedToken = new TimingBucket('ReturnedToken', 100);
};
Stats.prototype.toString = function toString () {
  var s = '';
  [this.WaitedToken, this.HadToken, this.ReturnedToken].forEach(function (b) {
    if (b && b.bucketCount() > 0) {
      s += (b.name) + " >> " + b + "\n";
    }
  });
  return s;
};

/**
 * @classdesc
 * This class contains all state for a single HTTP connection (XHR).
 *
 * @private
 */
var HTTPConnection = function HTTPConnection(url, base64Enc, streamProgressEvents, rxDataCb,
            connectionErrorCb, contentType, connectionClose) {
  this.Options = {
    url: prependOrigin(url),
    contentType: contentType,
    base64Enc: base64Enc,
    streamProgressEvents: streamProgressEvents,
    connectionClose: connectionClose,
  };

  this._streamProgressBytes = 0;
  this._xhr = null;
  this._rxDataCb = rxDataCb;
  this._connErrorCb = connectionErrorCb;
  this._reqActive = false;
  this._REQCOUNTER = 0;
  this._REQBASE = Math.floor(Math.random() * 1000);

  this._xhr = XHRFactory.create();
  // older browser ie9
  this._handleAbortedReq = !HTTPConnection.browserSupportsXhrBinary();

  this.stats = new Stats();
};

HTTPConnection.prototype.recStat = function recStat (s) {
  if (!SOL_CONNECTION_DEBUG) {
    return;
  }
  var stats = this.stats;
  if (s === 'GotToken') {
    stats.LastGotToken = getTs();
    if (stats.LastSendMsg) {
      var waitedTok = stats.LastGotToken - stats.LastSendMsg;
      stats.WaitedToken.log(waitedTok);
      if (waitedTok > 100) {
        LOG_WARN(("Abnormally long waitToken, last request: " + (this._REQBASE) + "_" + (this._REQCOUNTER)));
      }
    }
  }
  if (s === 'SendMsg') {
    stats.LastSendMsg = getTs();
    var hadToken = stats.LastSendMsg - stats.LastGotToken;
    stats.HadToken.log(hadToken);
  }
  if (s === 'GotData') {
    stats.LastGotData = getTs();
  }
  if (s === 'ReturnToken') {
    stats.LastReturnToken = getTs();
    if (stats.LastGotData) {
      var returnedToken = stats.LastReturnToken - stats.LastGotData;
      stats.ReturnedToken.log(returnedToken);
    }
  }
};

/*
 * Send data over the connection - this requires a send token
 */
HTTPConnection.prototype.send = function send (data, attempt, maxRetry) {
    var this$1 = this;
    if ( attempt === void 0 ) attempt = 0;
    if ( maxRetry === void 0 ) maxRetry = 1;

  if (attempt > 0) {
    this._xhr.abort();
    this._xhr = XHRFactory.create();
  }
  this._xhr.open('POST', this.Options.url, true);

  this._streamProgressBytes = 0;
  // We pass the write data to the CB so we can retry when it mysteriously fails.
  this._xhr.onreadystatechange = function () { return this$1.xhrStateChange(data, attempt, maxRetry); };

  this._reqActive = true;

  if (SOL_CONNECTION_DEBUG) {
    this._REQCOUNTER++;
    this._xhr.setRequestHeader('sol-request-track', ((this._REQBASE) + "_" + (this._REQCOUNTER)));
  }
  if (this.Options.base64Enc) {
    sendXhrText(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
  } else {
    sendXhrBinary(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
  }
  this.recStat('SendMsg');
};


// XmlHTTPRequest Callback
HTTPConnection.prototype.xhrStateChange = function xhrStateChange (sentdata, attempt, maxRetry) {
  var readyState = this._xhr.readyState;
  var RS_LOADING = this._xhr.LOADING;
  var RS_DONE = this._xhr.DONE;

  if (!((this.Options.streamProgressEvents && readyState === RS_LOADING)
        || readyState === RS_DONE)) {
    // we proceed with notifications if we're LOADING and we requested streaming events,
    // or we're DONE.
    return;
  }

  if (!this._reqActive) {
        // request aborted, DO NOT propagate event
    return;
  }

  var status = null;
  if (this._handleAbortedReq) {
    // To avoid the following IE9 error when request is aborted by server or client and
    // application tries to access any property in the XHR other than readyState whose value is
    // 4 (XMLHTTPRequest.DONE):
    // - The data necessary to complete this operation is not yet available
    // See https://groups.google.com/forum/#!topic/websync/ysBEvtvMyb0 for details
    // _requestActive is used to handle client initiated abort, but it does not handle
    // the case when the request is aborted on the server side or proxy server
    try {
      status = this._xhr.status;
    } catch (e) {
      LOG_INFO(("Error trying to access status in XHR due to request aborted: " + (e.message)));
      return;
    }
  } else {
    status = this._xhr.status;
  }

  if (status === 200 || status === 304) {
    // Success status code
    var data = null;
    if (this._xhr.responseType && this._xhr.responseType === 'arraybuffer') {
      data = arrayBufferToString(this._xhr.response);
    } else {
      data = this._xhr.responseText;
    }
    data = data.substring(this._streamProgressBytes, data.length);
    this._streamProgressBytes += data.length;

    if (data.length === 0 && readyState === RS_LOADING) {
      // we are streaming LOADING events but have no data
      return;
    }

    if (this.Options.base64Enc) {
      try {
        data = Base64.decode(data);
      } catch (e) {
        // Failed the decode - call the error callback
        LOG_ERROR(("Data decode error on: " + data));
        LOG_ERROR(("Data decode error is: " + (e.message)));
        this._rxDataCb(TransportReturnCode.DATA_DECODE_ERROR, data);
        return;
      }
    } else {
      // take lower-8 bits
      var decodedData = [];
      var dataLength = data.length;
      for (var i = 0; i < dataLength; i++) {
        decodedData.push(String.fromCharCode(data.charCodeAt(i) & 0xFF));
      }
      data = decodedData.join('');
    }
    if (readyState === RS_DONE) {
      // MUST do this BEFORE the callback invocation, because the callback can trigger a new send.
      this._reqActive = false;
    }
    this._rxDataCb(TransportReturnCode.OK, data);
    if (readyState === RS_DONE && data.length > 0) {
      this._rxDataCb(TransportReturnCode.OK, ''); // indicate end of stream
    }

    return;
  }

  // Failure status code.
  var statusText = this._xhr.statusText;
  var responseText = '';
  if (this._xhr.responseType && this._xhr.responseType === 'arraybuffer') {
    responseText = arrayBufferToString(this._xhr.response);
  } else {
    responseText = this._xhr.responseText || '';
  }

  var responseTextLen = responseText.length;
  var requestUrl = this.Options.url;
  var sentdataLen = sentdata ? sentdata.length : 0;
  var ref = DebugLib.Debug;
    var formatDumpBytes = ref.formatDumpBytes;
  var responseTextDump = formatDumpBytes(
    responseText.substr(0, Math.min(responseTextLen, 64)), true, 0);
  var sentTextDump = formatDumpBytes(
    (sentdata || '').substr(0, Math.min(sentdataLen, 256)), true, 0);
  if (true) {
    var stmt = new StringBuffer(
      ("Http request failed.  url=" + requestUrl + ", status=" + status + ", statusText=" + statusText + ", "),
      ("responseText length=" + responseTextLen + ", "),
      'responseText (first 64 bytes or fewer)=\n',
      (responseTextDump + ", "),
      ("XHR errorCode=" + (this._xhr._error ? this._xhr._error.code : '') + ", "),
      ("attempt=" + attempt + ", reqActive=" + (this._reqActive) + ", readyState=" + readyState + ", "),
      ("sent data length=" + sentdataLen + ", "),
      'sent data (first 256 bytes or fewer)=\n',
      ("" + sentTextDump)).toString();
    LOG_DEBUG(stmt);
  }

  var nextMaxRetry = maxRetry;
  if (this._reqActive
        && status !== 400
        && responseText.length === 0
        && (attempt === 0 || attempt < nextMaxRetry)) {
    LOG_DEBUG(("XHR failed while request active, will retry send, retry=" + (attempt + 1)));
      // RETRY (could be a transient browser connection problem)
    this.send(sentdata, attempt + 1, nextMaxRetry);
  } else {
    this._reqActive = false;
    this._connErrorCb(
        status,
        new StringBuffer(
          ("HTTP request failed(status=" + status + " statusText=" + statusText + ", "),
          ("responseText length=" + responseTextLen + ", responseText[0..64]=\n"),
          responseTextDump,
          ("XHR errorCode=" + (this._xhr._error ? this._xhr._error.code : '') + ")")).toString());
  }
};

HTTPConnection.prototype.isUsingBase64 = function isUsingBase64 () {
  return this.Options.base64Enc;
};

// This function will abort the current xhr request if it is active
HTTPConnection.prototype.abort = function abort () {
    // mark request as inactive, so we won't process statechange events
  this._reqActive = false;
  if (this._xhr && this._xhr.abort) {
    this._xhr.abort();
  }
};

/**
 * Check if we can try binary XHR on this browser.
 * @returns {Boolean} `true` if XHR binary should work; `false` otherwise
 * @static
 */
HTTPConnection.browserSupportsXhrBinary = function browserSupportsXhrBinary () {
  return sendXhrBinary !== sendXhrText;
};

/**
 * Check if browser supports streaming responses (progressive reading of XHR).
 * @returns {Boolean} `true` if feature was detected, `false` otherwise
 * @static
 */
HTTPConnection.browserSupportsStreamingResponse = function browserSupportsStreamingResponse () {
  var xhr = XHRFactory.create();
  // A conforming XHR2 implementation must include progress events.
  // Can we assume that the event property will be null instead of undefined?
  // A conforming XHR2 implementation must also include withCredentials.
  var check = xhr && xhr.onprogress === null; // xhr.withCredentials === false;
  LOG_DEBUG(("http browserStreamingCheck - if XMLHTTPRequest supported and XMLHTTPRequest support onprogress: " + check));
  return check;
};

module.exports.HTTPConnection = HTTPConnection;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(33);
var TransportError = ref$1.TransportError;

/* eslint-env browser */
var XHRFactory = {
  /**
   * Creates an XHR object.
   *
   * @param {Boolean} [allowFail=false] If `true`, return null on failure; otherwise throw.
   * @throws {TransportError}
   * @returns {XMLHttpRequest} The new XHR object
   */
  create: function create(allowFail) {
    if ( allowFail === void 0 ) allowFail = false;

    var xhr = typeof XMLHttpRequest !== 'undefined' ? new XMLHttpRequest() : null;
    if (!allowFail && !xhr) {
      throw new TransportError('Failed to create an XMLHTTPRequest',
                                 ErrorSubcode.CREATE_XHR_FAILED);
    }
    return xhr;
  },
};

module.exports.XHRFactory = XHRFactory;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of Web Transport events.
 * @enum {string}
 * @namespace
 * @memberof solace
 * @private
 */
var WebTransportEvent = {
  /**
   * The Session Layer has issued a connect request
   */
  CONNECT:          'Connect',
  /**
   * The Session Layer has issued a destroy request
   */
  DESTROY:          'Destroy',
  /**
   * A downgrade request has been received from an FSM.
   */
  DOWNGRADE:        'Downgrade',
  /**
   * The underlying transport has been destroyed. Seen in
   * response to calling destroy() and in some cases when
   * the transport is destroyed by the peer.
   */
  DESTROYED_NOTICE: 'DestroyedNotice',
  /**
   * The underlying transport timed out in its connection attempt.
   * The managing component should abort this connection attempt
   * and begin a downgrade if available.
   */
  CONNECT_TIMEOUT:  'ConnectTimeout',
  /**
   * The underlying transport is active and ready for traffic.
   */
  UP_NOTICE:        'UpNotice',
  /**
   * The transport encountered an error sending data.
   */
  SEND_ERROR:       'SendError',
};

module.exports.WebTransportEvent = Enum.new(WebTransportEvent);


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_TRACE = ref.LOG_TRACE;
var ref$1 = __webpack_require__(46);
var TransportBase = ref$1.TransportBase;
var ref$2 = __webpack_require__(141);
var TransportClientStats = ref$2.TransportClientStats;
var ref$3 = __webpack_require__(17);
var TransportReturnCode = ref$3.TransportReturnCode;
var ref$4 = __webpack_require__(34);
var TransportSessionState = ref$4.TransportSessionState;

var MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS = 4000;

/**
 * Base class for web related transports
 * @extends TransportBase
 * @private
 */
var WebTransportSessionBase = (function (TransportBase) {
  function WebTransportSessionBase(url, eventCB, client, props) {
    // instanitate instance properties defined in TransportBase
    TransportBase.call(this, url, eventCB, client, props);

    /**
     * @type {Number}
     */
    this._connectTimeout = props.transportDowngradeTimeoutInMsecs;

    /**
     * @type {?number}
     */
    this._connectTimer = null;

    /**
     * @type {TransportClientStats}
     */
    this._clientstats = new TransportClientStats();

    /**
     * Maximum amount of send data than can be queued
     * @type {Number}
     */
    this._sendBufferMaxSize = props.sendBufferMaxSize;

    /**
     * Maximum payload chunk size in web transport
     * @type {Number}
     */
    this._maxPayloadBytes = props.maxWebPayload;

    /**
     * Queue to hold data to be sent to the Solace Message Router when we get back a
     * data token
     * @type {array}
     */
    this._queuedData = [];

    /**
     * Number of bytes of queued data
     * @type {Number}
     */
    this._queuedDataSize = 0;

    /**
     * Remember if we have to send an event when there is room in the queue
     * @type {Boolean}
     */
    this._canSendNeeded = false;

    /**
     * @type {TransportSessionState}
     */
    this._state = TransportSessionState.DOWN;

    /**
     * Any connection error that needs to be propagated up
     * @type {?Error}
     */
    this._connError = null;
  }

  if ( TransportBase ) WebTransportSessionBase.__proto__ = TransportBase;
  WebTransportSessionBase.prototype = Object.create( TransportBase && TransportBase.prototype );
  WebTransportSessionBase.prototype.constructor = WebTransportSessionBase;

  // override
  WebTransportSessionBase.prototype.getClientStats = function getClientStats () {
    return this._clientstats;
  };

  WebTransportSessionBase.prototype.createConnectTimeout = function createConnectTimeout () {
    var this$1 = this;

    if (this._connectTimeout > 0) {
      this._connectTimer = setTimeout(function () {
        this$1.connectTimerExpiry();
      }, this._connectTimeout);
    }
  };

  WebTransportSessionBase.prototype.cancelConnectTimeout = function cancelConnectTimeout () {
    if (this._connectTimer) {
      clearTimeout(this._connectTimer);
      this._connectTimer = null;
    }
  };

  /* override me */
  WebTransportSessionBase.prototype.connectTimerExpiry = function connectTimerExpiry () { // eslint-disable-line class-methods-use-this
    return undefined;
  };

  WebTransportSessionBase.prototype.allowEnqueue = function allowEnqueue (datalen) {
      // Bug 32006: if there's no queued data, we always accept at least one message, even if it
      // exceeds the sendBufferMaxSize.
      // If we reject enqueueing something too large because we already have queued data,
      // that guarantees when the data is flushed we will emit the alertOnDequeue event.
    return (this._queuedDataSize === 0 ||
            ((datalen + this._queuedDataSize) <= this._sendBufferMaxSize));
  };

  WebTransportSessionBase.prototype.enqueueFailNoSpace = function enqueueFailNoSpace () {
    this._canSendNeeded = true;
    return TransportReturnCode.NO_SPACE;
  };

  /* override me */
  WebTransportSessionBase.prototype.flush = function flush (callback) { // eslint-disable-line class-methods-use-this
    callback();
  };

  WebTransportSessionBase.prototype.getQueuedDataToSend = function getQueuedDataToSend () {
    var this$1 = this;

    // Track messages dequeued.
    var data = '';

    // Start by trying to fill a complete payload.
    var bytesAllowed = this._maxPayloadBytes;
    LOG_TRACE(("getQueuedDataToSend: bytesAllowed=" + bytesAllowed + ", bufferedAmount=" + (this.getBufferedAmount ? this.getBufferedAmount() : 'undefined')));
    if (this.getBufferedAmount) {
      bytesAllowed = this._maxPayloadBytes - this.getBufferedAmount();
      if (bytesAllowed <= 0) {
        LOG_DEBUG(("$$ bytesAllowed=" + bytesAllowed + ", maxPayloadBytes=" + (this._maxPayloadBytes) + ", bufferedAmount=" + (this.getBufferedAmount())));
        if (false) {
          this._bufferedAmountQueryIntervalDelayMultiplier *= 2;
        }
        return data;
      }
      if (false) {
        this._bufferedAmountQueryIntervalDelayMultiplier = 1;
      }
    }

    if (this._queuedDataSize > bytesAllowed) {
      var payloadSize = bytesAllowed;
      // Slow path: dequeue and append until we fill the payload.
      while (payloadSize && this._queuedDataSize) {
        // Is this element larger than the payload?
        var elem = this$1._queuedData[0];
        var elemLength = elem.length;
        if (elemLength > payloadSize) {
          // This element is larger than the payload.
          data += elem.substr(0, payloadSize);
          this$1._queuedData[0] = elem.substr(payloadSize);

          // The rest of the payload space was consumed.
          this$1._queuedDataSize -= payloadSize;
          payloadSize = 0;
        } else {
          data += this$1._queuedData.shift();
          payloadSize -= elemLength;
          this$1._queuedDataSize -= elemLength;
          this$1._clientstats.msgWritten++;
        }
      }
    } else {
      // Shortcut: use the whole buffer, increase the message sent count by the length of the size
      // queue, and reset the buffer.
      data = this._queuedData.join('');
      this._clientstats.msgWritten += this._queuedData.length;

      this._queuedData = [];
      this._queuedDataSize = 0;
    }

    LOG_DEBUG(("Sending " + (data.length) + " bytes from queued data"));
    return data;
  };

  return WebTransportSessionBase;
}(TransportBase));

module.exports.WebTransportSessionBase = WebTransportSessionBase;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_WARN = ref.LOG_WARN;
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(4);
var ArrayUtils = ref$1.ArrayUtils;
var ref$2 = __webpack_require__(3);
var Convert = ref$2.Convert;
var Hex = ref$2.Hex;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var ref$4 = __webpack_require__(0);
var mixin = ref$4.mixin;
var ref$5 = __webpack_require__(33);
var TransportError = ref$5.TransportError;
var ref$6 = __webpack_require__(17);
var TransportReturnCode = ref$6.TransportReturnCode;
var ref$7 = __webpack_require__(47);
var TransportSessionEvent = ref$7.TransportSessionEvent;
var ref$8 = __webpack_require__(24);
var TransportSessionEventCode = ref$8.TransportSessionEventCode;
var ref$9 = __webpack_require__(34);
var TransportSessionState = ref$9.TransportSessionState;
var ref$10 = __webpack_require__(253);
var WebSocketCloseCodes = ref$10.WebSocketCloseCodes;
var ref$11 = __webpack_require__(145);
var WebTransportSessionBase = ref$11.WebTransportSessionBase;

var stringToArrayBuffer = Convert.stringToArrayBuffer;
var formatHexString = Hex.formatHexString;
var includes = ArrayUtils.includes;

/* eslint-env browser */
// closure mangles window.WebSocket
var globalContext = (typeof window === 'undefined' ? global : window);
var MyWebSocket = globalContext.WebSocket;
if (true) {
  /* eslint-disable no-global-assign */
  /* eslint-disable global-require */
  MyWebSocket = /** @type {WebSocket} */ (__webpack_require__(292));
  /* eslint-enable no-global-assign */
  /* eslint-enable global-require */
}
/* eslint-env shared-browser-node */

function adaptURL(url) {
  var v = url.match(/(ws|http)(s?:\/\/.+)/);
  return ("ws" + (v[2]));
}


/**
 * @classdesc
 * @private
 * @memberof solace
 */
var WebSocketTransportSession = (function (WebTransportSessionBase) {
  function WebSocketTransportSession(url, eventCB, client, props) {
    WebTransportSessionBase.call(this, url, eventCB, client, props);
    /**
     * @type {String}
     */
    this._url = adaptURL(url);

    /**
     * @type {?WebSocket}
     */
    this._socket = null;

    /**
     * @type {?string}
     */
    this._sessionId = new Date().getTime();

    if (false) {
      /**
       * @type {Number}
       */
      this._bufferedAmountQueryIntervalInMsecs = props.bufferedAmountQueryIntervalInMsecs;
      /**
       * @type {?number}
       */
      this._bufferedAmountQueryTimer = null;
      /**
       * @type {Number}
       */
      this._bufferedAmountQueryIntervalDelayMultiplier = 1;
    }
  }

  if ( WebTransportSessionBase ) WebSocketTransportSession.__proto__ = WebTransportSessionBase;
  WebSocketTransportSession.prototype = Object.create( WebTransportSessionBase && WebTransportSessionBase.prototype );
  WebSocketTransportSession.prototype.constructor = WebSocketTransportSession;


  /**
   * @private
   */
  WebSocketTransportSession.prototype.onOpen = function onOpen () {
    this.cancelConnectTimeout();
    this._state = TransportSessionState.SESSION_UP;
      // Send the event to the application letting it know that the session is up
    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.UP_NOTICE,
              'Connected',
              0,
              null,
              this._sessionId));
  };

  /**
   * @param {Event} event The websocket event causing the close
   * @private
   */
  WebSocketTransportSession.prototype.onClose = function onClose (event) {
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_TRACE('WebSocket transport is being destroyed, ignore error');
      return;
    }
    var msgBuf = [];
    var code = WebSocketCloseCodes[event.code] || WebSocketCloseCodes[0];
    msgBuf.push(((event.code) + " " + (code.name) + " (" + (code.description) + ")"));
    if (event.wasClean !== undefined) {
      msgBuf.push(("clean closure: " + (event.wasClean)));
    }
    if (event.reason) {
      msgBuf.push(("reason: " + (event.reason)));
    }
    var msg = msgBuf.join(', ');
    LOG_DEBUG(("WebSocket transport connection is closed " + msg));
    LOG_TRACE(("Event { type: " + (event.type) + " wasClean: " + (event.wasClean) + " code: " + (event.code) + " reason: " + (event.reason) + " }"));
    this._state = TransportSessionState.CONNECTION_FAILED;
    this.destroy(("Connection closed: " + msg), ErrorSubcode.COMMUNICATION_ERROR);
  };

  WebSocketTransportSession.prototype.onDrain = function onDrain () {
    LOG_TRACE('Drained socket');
    this.maybeEmitCanSend();
    this.maybeEmitFlush();
  };

  WebSocketTransportSession.prototype.onBufferedAmountPoll = function onBufferedAmountPoll () {
    if (this.getBufferedAmount() === 0) {
      this.onDrain();
    } else if (this.scheduleQuery) {
      this.scheduleQuery();
    }
  };

  /**
   * @param {TransportSessionEvent} event The event causing the error
   * @private
   */
  WebSocketTransportSession.prototype.onError = function onError (event) {
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_DEBUG('WebSocket transport is being destroyed, ignore error');
      return;
    }
    var msg = (event.message) ? ((": " + (event.message))) : '';
    LOG_DEBUG(("WebSocket transport connection error " + msg));
    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.SEND_ERROR,
              ("Connection error" + msg),
              null,
              ErrorSubcode.CONNECTION_ERROR, null));
  };

  /**
   * @param {TransportSessionEvent} event The data event
   * @private
   */
  WebSocketTransportSession.prototype.onMessage = function onMessage (event) {
    if (this._client) {
      this._client.rxDataArrayBuffer(event.data);
    }
  };

  /**
   * @override
   * @private
   */
  WebSocketTransportSession.prototype.connectTimerExpiry = function connectTimerExpiry () {
    LOG_DEBUG('WebSocket transport connect timeout');
    this.state = TransportSessionState.CONNECTION_FAILED;
    this._eventCB(new TransportSessionEvent(
      TransportSessionEventCode.CONNECT_TIMEOUT,
      'Connection timed out',
      null,
      ErrorSubcode.TIMEOUT
    ));
  };

  /**
   * @override
   * @private
   */
  WebSocketTransportSession.prototype.connect = function connect () {
    if (this._state !== TransportSessionState.DOWN) {
      LOG_ERROR(("Invalid state for operation: " + (TransportSessionState.nameOf(this._state))));
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (!this._url) {
      LOG_WARN('Cannot connect to null URL');
      return TransportReturnCode.CONNECTION_ERROR;
    }
    if (this._socket) {
      this.onError('Socket already connected');
    }

    LOG_DEBUG('Establishing WebSocket transport session');
    try {
      this.createConnectTimeout();
      this._state = TransportSessionState.WAITING_FOR_CREATE;
      if (true && !this._socketOptions) {
        LOG_DEBUG('Creating Node websocket options');
        this._socketOptions = this.createWebSocketOptions();
      }
      LOG_DEBUG('Constructing socket');
      if (false) {
        /**
         * @type {WebSocket}
         */
        this._socket = new MyWebSocket(this._url, 'smf.solacesystems.com');
      } else {
        this._socket = new MyWebSocket(this._url, 'smf.solacesystems.com', this._socketOptions);
        this._socket.ondrain = this.onDrain.bind(this);
      }
      // Closure is generally faster than bind
      LOG_TRACE('Assigning properties to socket');
      // Closure using Browser profile to avoid mangling this
      this._socket.binaryType = 'arraybuffer';
      this._socket.onopen = this.onOpen.bind(this);
      this._socket.onmessage = this.onMessage.bind(this);
      this._socket.onclose = this.onClose.bind(this);
      this._socket.onerror = this.onError.bind(this);
      LOG_TRACE('Prepared socket');
    } catch (error) {
      LOG_DEBUG(("Error connecting: " + (error.message)));
      LOG_TRACE('Error details', error.stack || error);
      this._state = TransportSessionState.CONNECTION_FAILED;
      this.cancelConnectTimeout();
      if (error instanceof TransportError) {
        this._connError = error;
      } else {
        throw new TransportError(("Could not create WebSocket: " + (error.message)),
                                 error.subcode || ErrorSubcode.CONNECTION_ERROR);
      }
      return TransportReturnCode.CONNECTION_ERROR;
    }

    LOG_DEBUG('WebSocket is connecting');
    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @param {String} data The binary string data to send.
   * @param {Boolean} [force=false] If true, send even if buffer is full.
   */
  WebSocketTransportSession.prototype.send = function send (data, force) {
    var this$1 = this;
    if ( force === void 0 ) force = false;

    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    var dataLen = data.length;
    var bufferAllow = (this._sendBufferMaxSize - this.getBufferedAmount()) >= 0;
    // LOG_DEBUG('Websocket send:', dataLen, force, bufferAllow);
    if (!(force || bufferAllow)) {
      this._canSendNeeded = true;
      if (this.scheduleQuery) { this.scheduleQuery(); }
      return TransportReturnCode.NO_SPACE;
    }

    // LOG_TRACE(`websocket.send: len=${data.length}`);
    // Slice messages per maxPayloadBytes
    var maxPayloadBytes = this._maxPayloadBytes;
    var ab = stringToArrayBuffer(data);
    if (dataLen > maxPayloadBytes) {
      for (var i = 0; i < dataLen; i += maxPayloadBytes) {
        this$1._socket.send(ab.slice(i, i + maxPayloadBytes));
      }
    } else {
      this._socket.send(ab);
    }
    // LOG_TRACE(`websocket.send: after send getBufferedAmount=${this.getBufferedAmount()}`);
    this._clientstats.bytesWritten += dataLen;
    ++this._clientstats.msgWritten;
    return TransportReturnCode.OK;
  };

  /**
   * @returns {Number} The number of already buffered bytes in this transport.
   * @private
   */
  WebSocketTransportSession.prototype.getBufferedAmount = function getBufferedAmount () {
    // Access as string property because this is a defineProperty on node websocket,
    // meaning it is not mangled by Closure Compiler
    return this._socket ? this._socket['bufferedAmount'] : 0; // eslint-disable-line dot-notation
  };

  /**
   * @override
   */
  WebSocketTransportSession.prototype.flush = function flush (callback) {
    this._flushCallback = callback;
    this.maybeEmitFlush();
  };

  WebSocketTransportSession.prototype.maybeEmitCanSend = function maybeEmitCanSend () {
    if (this._canSendNeeded && this.getBufferedAmount() < this._sendBufferMaxSize) {
      LOG_TRACE('Transport emitting CAN_ACCEPT_DATA');
      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '', null, 0, this._sessionId));
    }
  };

  WebSocketTransportSession.prototype.maybeEmitFlush = function maybeEmitFlush () {
    if (!this._flushCallback) { return; }
    if (false) {
      // Ensure we have a query scheduled, but don't interrupt a query in progress
      if (!this._bufferedAmountQueryTimer) {
        this.scheduleQuery();
      }
      return;
    }

    // Node is automatically flushed by socket.end(), which is called in non-error cases
    LOG_DEBUG('Transport emitting FLUSH');
    var cb = this._flushCallback;
    this._flushCallback = null;
    cb();
  };

  /**
   * @override
   */
  WebSocketTransportSession.prototype.destroy = function destroy (message, subcode) {
    // We can destroy (and get a notice) even if the socket is freshly created.
    // But this will only work once.
    if (this._state !== TransportSessionState.DOWN) {
      LOG_DEBUG(("Destroy WebSocket transport: " + message));

      // Set state for connection teardown.
      this._state = TransportSessionState.WAITING_FOR_DESTROY;

      if (this._socket) {
        this._socket.close();
        this._socket.onopen = null;
        this._socket.onmessage = null;
        this._socket.onclose = null;
        this._socket.onerror = function onerrorStub() { }; // Prevent unhandled errors
        this._socket = null;
      }

      if (this._connectTimer) {
        clearTimeout(this._connectTimer);
        this._connectTimer = undefined;
      }

      if (false) {
        this.cancelQuery();
        this._bufferedAmountQueryIntervalDelayMultiplier = 1;
      }

      this._canSendNeeded = false;

      this._state = TransportSessionState.DOWN;

      this._client = null; // Don't accept data.
    }
    // always send a DESTROYED_NOTICE in response to a destroy() even
    // if we think the transport is already destroyed
    if (this._eventCB) {
      // Fire this *almost* instantly, but follow the HTTP
      // transport pattern by guaranteeing an async callback.
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                              message || 'Session is destroyed',
                                              null,
                                              subcode || 0,
                                              this._sessionId));
      // Release references to other components
      this._eventCB = null;
    }

    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @returns {String} A description of this object.
   */
  WebSocketTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "WebSocketTransportSession; sid=" + (formatHexString(this._sessionId));
    return str;
  };

  WebSocketTransportSession.browserSupportsBinaryWebSockets = function browserSupportsBinaryWebSockets () {
    LOG_DEBUG('websocket browserSupportBinaryCheck - ' +
              'if WebSocket, ArrayBuffer and Uint8Array are supported');

    var exists = ['function', 'object'];
    if (!includes(exists, typeof MyWebSocket) ||
        !includes(exists, typeof ArrayBuffer) ||
        !includes(exists, typeof Uint8Array)) {
      LOG_DEBUG('websocket browserSupportBinaryCheck: false - some required classes not supported');
      return false;
    }

    LOG_DEBUG('websocket browserSupportBinaryCheck - if WebSocket supports binaryType');
    if ('binaryType' in MyWebSocket.prototype) {
      LOG_DEBUG('websocket browserSupportBinaryCheck: true - WebSocket supports binaryType');
      return true;
    }

    LOG_DEBUG('websocket browserSupportBinaryCheck: false - WebSocket does not support binaryType');
    return false;
  };

  return WebSocketTransportSession;
}(WebTransportSessionBase));

if (false) {
  mixin(WebSocketTransportSession, (function () {
    function WebSocketTransportSessionBrowser () {}

    WebSocketTransportSessionBrowser.prototype.scheduleQuery = function scheduleQuery () {
      var this$1 = this;

      var bufferedAmount = this.getBufferedAmount();
      if (bufferedAmount > 0 && this._bufferedAmountQueryIntervalInMsecs > 0) {
        this.cancelQuery();
        if (this._bufferedAmountQueryIntervalDelayMultiplier > 1) {
          LOG_DEBUG(("$$ schedule bufferedAmount query timer in " + (this._bufferedAmountQueryIntervalInMsecs *
                    this._bufferedAmountQueryIntervalDelayMultiplier) + " ms"));
        }
        var timeout = this._bufferedAmountQueryIntervalInMsecs *
                        this._bufferedAmountQueryIntervalDelayMultiplier;
        this._bufferedAmountQueryTimer = setTimeout(function () {
          this$1.cancelQuery();
          try {
            this$1.onBufferedAmountPoll();
          } catch (e) {
            LOG_ERROR(("Error occurred in onBufferedAmountPoll: " + (e.message)));
            LOG_TRACE('Error details:', e.stack || e);
          }
        }, timeout);
      }
    };

    WebSocketTransportSessionBrowser.prototype.cancelQuery = function cancelQuery () {
      if (this._bufferedAmountQueryTimer) {
        clearTimeout(this._bufferedAmountQueryTimer);
        this._bufferedAmountQueryTimer = null;
      }
    };

    return WebSocketTransportSessionBrowser;
  }()));
} else {
  // Node TLS socket options formulation shared with TCP transport
  // eslint-disable-next-line global-require
  var ref$12 = __webpack_require__(139);
  var NodeTLSOptsMixin = ref$12.NodeTLSOptsMixin;
  mixin(WebTransportSessionBase, NodeTLSOptsMixin);
  // Node-specific methods of this class go here
  mixin(WebTransportSessionBase, (function () {
    function WebTransportSessionBaseNode () {}

    WebTransportSessionBaseNode.prototype.createWebSocketOptions = function createWebSocketOptions () {
      if (this._ssl) {
        var options = this.createTLSOptions();
        // use custom agent for client certificate support, ssl resume session support
        // eslint-disable-next-line dot-notation
        options['agent'] = SolclientFactoryLib.SolclientFactory.wsSslAgent;
        LOG_DEBUG('WebSocket options', options);
        return options;
      }
      return {};
    };

    return WebTransportSessionBaseNode;
  }()));
}

module.exports.WebSocketTransportSession = WebSocketTransportSession;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * This class is used to efficiently concatenate strings.
 * @private
 */
var StringBuffer = function StringBuffer() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  this.clear();
  (ref = this).append.apply(ref, args);
  var ref;
};

/**
 * Appends the given strings to the buffer
 *
 * @param {...*} args Objects to add to the buffer. These are immediately
 *                  coerced to strings.
 * @returns {StringBuffer} this
 */
StringBuffer.prototype.append = function append () {
    var this$1 = this;
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  [].concat( args ).forEach(function (arg) {
    this$1.buffer[this$1.index++] = String(arg);
  });
  return this;
};

/**
 * Resets the buffer.
 */
StringBuffer.prototype.clear = function clear () {
  this.buffer = [];
  this.index = 0;
};

/**
 * Returns the buffer as a string. Additional concatenations and renderings
 * can be performed.
 * @returns {String} The buffer's contents concatenated to a string.
 */
StringBuffer.prototype.toString = function toString () {
  return this.buffer.join('');
};

module.exports.StringBuffer = StringBuffer;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(263);
var BaseChecks = ref.BaseChecks;

/**
 *
 * Generates a then closure.
 *
 * @param {Boolean} doOp Whether the returned then function should call its argument.
 * @returns {Object} An object { then(fn, elseFn=undefined) }. If doOp was true, then(fn) will
 *                      call fn. If not, elseFn will be called if supplied.
 * @private
 */
function thenGen(doOp) {
  return {
    then: doOp ? function (f) { return f(); } : function (_, elseFn) { return elseFn(); },
  };
}

/**
 *
 * none, anything, boolean, ... @returns {Boolean}
 * when(condition) @returns then(fn, elseFn) => if condition fn() else elseFn && elseFn()
 * unless(condition, else) @returns then(fn, elseFn) => if !condition fn() else elseFn && elseFn
 * whenNone, whenAnything, whenBoolean, ... @returns {function} then(fn, elseFn)
 * unlessNone, unlessAnything, unlessBoolean ... @returns {function} unless(fn, elseFn)
 * @private
 */
var Check = (function () {
  var result = Object.assign({}, BaseChecks);
  result.when = function (condition) { return thenGen(condition); };
  result.unless = function (condition) { return thenGen(!condition); };
  return result;
})();

module.exports.Check = Check;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = require("clone");

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = require("long");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * <h1> Overview </h1>
 *
 * This is the Solace Corporation Messaging API for JavaScript. Concepts defined in this API are
 * similar to those defined in other Solace Messaging APIs for Java, C, and .NET.
 *
 * <h1> Concepts </h1>
 *
 * Some general concepts:
 *
 * <li> All function calls are non-blocking; confirmation, if requested, is returned to the calling
 * client application in the form of callbacks. </li>
 *
 */

/* eslint-disable sort-requires/sort-requires */

// ----------------------------- Polyfills -----------------------------------
// Include compatibility entry points here. These are expected to modify the
// global environment.
if (false ||
    global && global.process && global.process.version < 'v6.0') {
  /* eslint-disable global-require */
  // Select es6 shims required by the API for older browsers and Node
  __webpack_require__(268);
  __webpack_require__(269);
  __webpack_require__(270);
  __webpack_require__(271);
  __webpack_require__(272);
  __webpack_require__(273);
  __webpack_require__(274);
  __webpack_require__(275);
  __webpack_require__(276);
  __webpack_require__(277);
  __webpack_require__(278);
  __webpack_require__(279);
  __webpack_require__(280);
  __webpack_require__(281);

  __webpack_require__(158);
  /* eslint-enable global-require */
}
__webpack_require__(282);
__webpack_require__(283);
// ---------------------------------------------------------------------------

// -------------------------- Solclient Factory ------------------------------
// Load me before the rest of the API as a plug-in point for modules
var FactoryLib = __webpack_require__(9);
// ---------------------------------------------------------------------------

var SolclientFactory = FactoryLib.SolclientFactory;
var SolclientFactoryProfiles = FactoryLib.SolclientFactoryProfiles;
var SolclientFactoryProperties = FactoryLib.SolclientFactoryProperties;

var ref = __webpack_require__(3);
var Long = ref.Long;
var ref$1 = __webpack_require__(5);
var Destination = ref$1.Destination;
var DestinationType = ref$1.DestinationType;
var Topic = ref$1.Topic;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var NotImplementedError = ref$2.NotImplementedError;
var OperationError = ref$2.OperationError;
var RequestError = ref$2.RequestError;
var RequestEventCode = ref$2.RequestEventCode;
var ref$3 = __webpack_require__(0);
var makeIterator = ref$3.makeIterator;
var ref$4 = __webpack_require__(1);
var ConsoleLogImpl = ref$4.ConsoleLogImpl;
var LogImpl = ref$4.LogImpl;
var LogLevel = ref$4.LogLevel;
var ref$5 = __webpack_require__(16);
var Message = ref$5.Message;
var MessageCacheStatus = ref$5.MessageCacheStatus;
var MessageDeliveryModeType = ref$5.MessageDeliveryModeType;
var MessageDumpFlag = ref$5.MessageDumpFlag;
var MessageType = ref$5.MessageType;
var MessageUserCosType = ref$5.MessageUserCosType;
var ref$6 = __webpack_require__(99);
var MessageConsumer = ref$6.MessageConsumer;
var MessageConsumerAcknowledgeMode = ref$6.MessageConsumerAcknowledgeMode;
var MessageConsumerEventName = ref$6.MessageConsumerEventName;
var MessageConsumerProperties = ref$6.MessageConsumerProperties;
var ref$7 = __webpack_require__(29);
var MessagePublisherAcknowledgeMode = ref$7.MessagePublisherAcknowledgeMode;
var MessagePublisherProperties = ref$7.MessagePublisherProperties;
var ref$8 = __webpack_require__(18);
var AbstractQueueDescriptor = ref$8.AbstractQueueDescriptor;
var QueueAccessType = ref$8.QueueAccessType;
var QueueDescriptor = ref$8.QueueDescriptor;
var QueueDiscardBehavior = ref$8.QueueDiscardBehavior;
var QueuePermissions = ref$8.QueuePermissions;
var QueueProperties = ref$8.QueueProperties;
var QueueType = ref$8.QueueType;
var ref$9 = __webpack_require__(10);
var SDTField = ref$9.SDTField;
var SDTFieldType = ref$9.SDTFieldType;
var SDTMapContainer = ref$9.SDTMapContainer;
var SDTStreamContainer = ref$9.SDTStreamContainer;
var SDTUnsupportedValueError = ref$9.SDTUnsupportedValueError;
var SDTValueErrorSubcode = ref$9.SDTValueErrorSubcode;
var ref$10 = __webpack_require__(21);
var AuthenticationScheme = ref$10.AuthenticationScheme;
var CapabilityType = ref$10.CapabilityType;
var MessageRxCBInfo = ref$10.MessageRxCBInfo;
var MutableSessionProperty = ref$10.MutableSessionProperty;
var Session = ref$10.Session;
var SessionEvent = ref$10.SessionEvent;
var SessionEventCBInfo = ref$10.SessionEventCBInfo;
var SessionEventCode = ref$10.SessionEventCode;
var SessionProperties = ref$10.SessionProperties;
var SessionState = ref$10.SessionState;
var ref$11 = __webpack_require__(80);
var CacheCBInfo = ref$11.CacheCBInfo;
var CacheLiveDataAction = ref$11.CacheLiveDataAction;
var CacheRequestResult = ref$11.CacheRequestResult;
var CacheReturnCode = ref$11.CacheReturnCode;
var CacheReturnSubcode = ref$11.CacheReturnSubcode;
var CacheSession = ref$11.CacheSession;
var CacheSessionProperties = ref$11.CacheSessionProperties;
var ref$12 = __webpack_require__(19);
var StatType = ref$12.StatType;
var ref$13 = __webpack_require__(23);
var TransportError = ref$13.TransportError;
var TransportProtocol = ref$13.TransportProtocol;
var ref$14 = __webpack_require__(4);
var Version = ref$14.Version;

// --------------------------- Internal API -- do not use --------------------
// Load me last. I disappear in production mode
var _internal = __webpack_require__(157);
// ---------------------------------------------------------------------------


/**
 * @namespace
 * @public
 */
var solace = {
  AbstractQueueDescriptor: AbstractQueueDescriptor,
  AuthenticationScheme: AuthenticationScheme,
  CacheCBInfo: CacheCBInfo,
  CacheLiveDataAction: CacheLiveDataAction,
  CacheRequestResult: CacheRequestResult,
  CacheReturnCode: CacheReturnCode,
  CacheReturnSubcode: CacheReturnSubcode,
  CacheSession: CacheSession,
  CacheSessionProperties: CacheSessionProperties,
  CapabilityType: CapabilityType,
  ConsoleLogImpl: ConsoleLogImpl,
  Destination: Destination,
  DestinationType: DestinationType,
  ErrorSubcode: ErrorSubcode,
  LogImpl: LogImpl,
  LogLevel: LogLevel,
  Long: Long,
  Message: Message,
  MessageCacheStatus: MessageCacheStatus,
  MessageConsumer: MessageConsumer,
  MessageConsumerAcknowledgeMode: MessageConsumerAcknowledgeMode,
  MessageConsumerEventName: MessageConsumerEventName,
  MessageConsumerProperties: MessageConsumerProperties,
  MessageDeliveryModeType: MessageDeliveryModeType,
  MessageDumpFlag: MessageDumpFlag,
  MessagePublisherAcknowledgeMode: MessagePublisherAcknowledgeMode,
  MessagePublisherProperties: MessagePublisherProperties,
  MessageRxCBInfo: MessageRxCBInfo,
  MessageType: MessageType,
  MessageUserCosType: MessageUserCosType,
  MutableSessionProperty: MutableSessionProperty,
  NotImplementedError: NotImplementedError,
  OperationError: OperationError,
  QueueAccessType: QueueAccessType,
  QueueDescriptor: QueueDescriptor,
  QueueDiscardBehavior: QueueDiscardBehavior,
  QueuePermissions: QueuePermissions,
  QueueProperties: QueueProperties,
  QueueType: QueueType,
  RequestError: RequestError,
  RequestEventCode: RequestEventCode,
  SDTField: SDTField,
  SDTFieldType: SDTFieldType,
  SDTMapContainer: SDTMapContainer,
  SDTStreamContainer: SDTStreamContainer,
  SDTUnsupportedValueError: SDTUnsupportedValueError,
  SDTValueErrorSubcode: SDTValueErrorSubcode,
  Session: Session,
  SessionEvent: SessionEvent,
  SessionEventCBInfo: SessionEventCBInfo,
  SessionEventCode: SessionEventCode,
  SessionProperties: SessionProperties,
  SessionState: SessionState,
  SolclientFactory: SolclientFactory,
  SolclientFactoryProfiles: SolclientFactoryProfiles,
  SolclientFactoryProperties: SolclientFactoryProperties,
  StatType: StatType,
  Topic: Topic,
  TransportError: TransportError,
  TransportProtocol: TransportProtocol,
  Version: Version,

  makeIterator: makeIterator,

  _internal: _internal, //
};

Object.assign(module.exports, solace);


/***/ }),
/* 152 */
/***/ (function(module, exports) {

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

// It has been modified by me (Edward Funnekotter) to improve its
// efficiency

// It has been modified by me (Justin Bowes) to avoid using it whenever
// possible in favour of browser or buffer implementations.

var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var ENC_LUT = [
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 99, -1, -1, 99, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  99, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, 62, -1, -1, -1, 63,
  52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, -1, -1, -1, 64, -1, -1,

    // 64
  -1, 0, 1, 2, 3, 4, 5, 6,
  7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, -1, -1, -1, -1, -1,
  -1, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48,
  49, 50, 51, -1, -1, -1, -1, -1,

    // 128
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,

    // 192
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1];

var DecodeError = (function (Error) {
  function DecodeError () {
    Error.apply(this, arguments);
  }if ( Error ) DecodeError.__proto__ = Error;
  DecodeError.prototype = Object.create( Error && Error.prototype );
  DecodeError.prototype.constructor = DecodeError;

  

  return DecodeError;
}(Error));

var LegacyEncoder = {
  /**
   * Encodes a string in base64
   * @param {String} input The string to encode in base64.
   * @returns {String} base64 encoded input
   * @private
   */
  base64_encode: function base64_encode(input) {
    var output = '';
    var i = 0;
    do {
      var chr1 = input.charCodeAt(i++);
      var chr2 = input.charCodeAt(i++);
      var chr3 = input.charCodeAt(i++);

      var enc1 = chr1 >> 2;
      var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
      var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
      var enc4 = chr3 & 63;

      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }

      output += KEY_STR.charAt(enc1);
      output += KEY_STR.charAt(enc2);
      output += KEY_STR.charAt(enc3);
      output += KEY_STR.charAt(enc4);
    } while (i < input.length);

    return output;
  },

  /**
   * Decodes a base64 string.
   * @param {String} input The base64 string to decode.
   * @returns {String} binary output
   * @private
   */
  base64_decode: function base64_decode(input) {
    var output = '';
    var i = 0;

    do {
      while (ENC_LUT[input.charCodeAt(i)] > 64) {
        i++;
      }
      var enc1 = ENC_LUT[input.charCodeAt(i++)];
      var enc2 = ENC_LUT[input.charCodeAt(i++)];
      var enc3 = ENC_LUT[input.charCodeAt(i++)];
      var enc4 = ENC_LUT[input.charCodeAt(i++)];

      if (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0) {
        // Invalid character in base64 text
        // alert("enc at " + i + ": " + enc1 + ", " + enc2 + ", " + enc3 + ", " + enc4);
        throw new DecodeError('Invalid base64 character');
      }

      var chr1 = (enc1 << 2) | (enc2 >> 4);
      var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      var chr3 = ((enc3 & 3) << 6) | enc4;

      output += String.fromCharCode(chr1);

      if (enc3 !== 64) {
        output += String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output += String.fromCharCode(chr3);
      }
    } while (i < input.length - 3);

    return output;
  },
};

var isNode = typeof window === 'undefined'; // !node
var hasBuffer = typeof Buffer !== 'undefined';
var hasBlob = typeof Blob !== 'undefined'; // !node, !ie9
var BufferEncoder = (hasBuffer && (hasBlob || isNode))
  ? {
    base64_encode: function (str) { return Buffer.from(str, 'binary').toString('base64'); },
    base64_decode: function (str) { return Buffer.from(str, 'base64').toString('binary'); },
  }
  : {};
/* eslint-env browser */
/* eslint-disable dot-notation */
var WindowEncoder = (typeof window !== 'undefined')
  ? {
    base64_encode: window['btoa'] ? function (b) { return window['btoa'](b); } : null,
    base64_decode: window['atob'] ? function (a) { return window['atob'](a); } : null,
  }
  : {};
/* eslint-enable dot-notation */

var Base64 = {
  encode: (WindowEncoder.base64_encode ||
           BufferEncoder.base64_encode ||
           LegacyEncoder.base64_encode),
  decode: (WindowEncoder.base64_decode ||
           BufferEncoder.base64_decode ||
           LegacyEncoder.base64_decode),
};

module.exports.Base64 = Base64;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

var Bits = {
  get: function get(val, shift, numBits) {
    return (val >>> shift) & ((0x01 << numBits) - 1);
  },

  set: function set(dataIn, val, shift, numBits) {
    var curMask = (1 << numBits) - 1;
    var shiftedVal = (val & curMask) << shift;
    var data = dataIn & ~(curMask << shift);
    return (data | shiftedVal);
  },
};

module.exports.Bits = Bits;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Long = __webpack_require__(150);

/**
 * @module
 * ===========================================================================
 * Convert
 *
 * This collection of functions performs all required string to number and number to string
 * conversions
 * ============================================================================
 * @private
 */

var TWO_ZEROES_STR = String.fromCharCode(0, 0);
var THREE_ZEROES_STR = String.fromCharCode(0, 0, 0);
var FOUR_ZEROES_STR = String.fromCharCode(0, 0, 0, 0);

var BYTEARRAY_CONVERT_CHUNK = 8192;
var UNSIGNED_LSHIFT_24 = (256 * 256 * 256);

var ARRAY_BUFFER_CONVERT_CHUNK = 32768;

function stringToUint8Array(data) {
  var dataLength = data.length;
  var arrayBuf = new ArrayBuffer(dataLength);
  var uint8Array = new Uint8Array(arrayBuf, 0, dataLength);
  for (var i = 0; i < dataLength; i++) {
    uint8Array[i] = data.charCodeAt(i);
  }
  return uint8Array;
}

function arrayBufferToString(ab) {
  if (!ab) { return ''; }
  var len = ab.byteLength;
  var u8 = new Uint8Array(ab);
  if (len < ARRAY_BUFFER_CONVERT_CHUNK) {
    return String.fromCharCode.apply(null, u8);
  }

  var k = 0;
  var r = '';
  while (k < len) {
    // slice is clamped, inclusive of startIndex, exclusive of lastIndex
    r += String.fromCharCode.apply(null, u8.subarray(k, k + ARRAY_BUFFER_CONVERT_CHUNK));
    k += ARRAY_BUFFER_CONVERT_CHUNK;
  }
  return r;
}

function stringToArrayBuffer(str) {
  return stringToUint8Array(str).buffer;
}

function int8ToStr(int8) {
  return String.fromCharCode(int8 & 0xff);
}

function int16ToStr(int16) {
  return (
      String.fromCharCode((int16 >> 8) & 0xff) +
      String.fromCharCode(int16 & 0xff)
  );
}

function int24ToStr(int24) {
  return (
      String.fromCharCode((int24 >> 16) & 0xff) +
      String.fromCharCode((int24 >> 8) & 0xff) +
      String.fromCharCode(int24 & 0xff)
  );
}

function int32ToStr(int32) {
  // It is expected that there are a lot of small numbers
  // being converted, so it is worth doing a few checks for
  // efficiency (on firefox it is about 3 times quicker for small numbers
  // to do the check - it is 2 times quicker for chrome)

  if (int32 === 0) { return FOUR_ZEROES_STR; }
  if (int32 > 0) {
    if (int32 < 256) {
      return THREE_ZEROES_STR + String.fromCharCode(int32);
    }
    if (int32 < 65536) {
      return TWO_ZEROES_STR + String.fromCharCode(int32 >> 8) + String.fromCharCode(int32 & 0xff);
    }
  }

  return (
      String.fromCharCode((int32 >> 24) & 0xff) +
      String.fromCharCode((int32 >> 16) & 0xff) +
      String.fromCharCode((int32 >> 8) & 0xff) +
      String.fromCharCode(int32 & 0xff)
  );
}

function int64ToStr(int64) {
  if (typeof int64 !== 'number') {
    return int32ToStr(int64.high) + int32ToStr(int64.low);
  }

  // It is expected that there are a lot of small numbers
  // being converted, so it is worth doing a few checks for
  // efficiency (on firefox it is about 3 times quicker for small numbers
  // to do the check - it is 2 times quicker for chrome)
  if (int64 >= 0) {
    if (int64 < 256) {
      return FOUR_ZEROES_STR + THREE_ZEROES_STR + String.fromCharCode(int64);
    }
    if (int64 < 65536) {
      return FOUR_ZEROES_STR + TWO_ZEROES_STR +
        String.fromCharCode(int64 >> 8) + String.fromCharCode(int64 & 0xff);
    }
    if (int64 < 4294967296) {
      return FOUR_ZEROES_STR + (String.fromCharCode((int64 >> 24) & 0xff) +
        String.fromCharCode((int64 >> 16) & 0xff) +
        String.fromCharCode((int64 >> 8) & 0xff) +
        String.fromCharCode(int64 & 0xff));
    }
  }
  return String.fromCharCode((int64 >> 56) & 0xFF) +
        String.fromCharCode((int64 >> 48) & 0xFF) +
        String.fromCharCode((int64 >> 40) & 0xFF) +
        String.fromCharCode((int64 >> 32) & 0xFF) +
        String.fromCharCode((int64 >> 24) & 0xff) +
        String.fromCharCode((int64 >> 16) & 0xff) +
        String.fromCharCode((int64 >> 8) & 0xff) +
        String.fromCharCode(int64 & 0xff);
}

function byteArrayToStr(byteArray) {
  var len = byteArray.length;
  if (len < BYTEARRAY_CONVERT_CHUNK) {
    return String.fromCharCode.apply(null, byteArray);
  }

  var k = 0;
  var r = '';

  while (k < len) {
    // slice is clamped, inclusive of startIndex, exclusive of lastIndex
    r += String.fromCharCode.apply(null, byteArray.slice(k, k + BYTEARRAY_CONVERT_CHUNK));
    k += BYTEARRAY_CONVERT_CHUNK;
  }

  return r;
}

function strToByteArray(str) {
  var result = [];
  var i;
  for (i = 0; i < str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}

function strToHexArray(str) {
  function toHex(c) {
    return c.charCodeAt(0).toString(16);
  }
  return Array.prototype.map.call(str.split(''), toHex);
}

function strToInt8(data) {
  return data.charCodeAt(0) & 0xff;
}

function strToInt16(data) {
  return (
      (data.charCodeAt(0) << 8) +
      (data.charCodeAt(1))
  );
}

function strToInt24(data) {
  return (
      (data.charCodeAt(0) << 16) +
      (data.charCodeAt(1) << 8) +
      (data.charCodeAt(2))
  );
}

function strToInt32(data) {
    // SIGNED integer
  return (
      (data.charCodeAt(0) << 24) +
      (data.charCodeAt(1) << 16) +
      (data.charCodeAt(2) << 8) +
      (data.charCodeAt(3))
  );
}

function strToUInt32(data) {
  // WARNING: you cannot use a << 24 to shift a byte into
  // a 32-bit string, because all shifts in JS are signed
  return (
      (data.charCodeAt(0) * UNSIGNED_LSHIFT_24) +
      (data.charCodeAt(1) << 16) +
      (data.charCodeAt(2) << 8) +
      (data.charCodeAt(3))
  );
}

function strToUInt64(data) {
  return Long.fromBits(strToUInt32(data.substr(4, 4)),
                       strToUInt32(data.substr(0, 4)),
                       true);
}

function ucs2ToUtf8(ucs2) {
  return unescape(encodeURIComponent(ucs2));
}

function utf8ToUcs2(utf8) {
  return decodeURIComponent(escape(utf8));
}

var Convert = {
  arrayBufferToString: arrayBufferToString,
  stringToArrayBuffer: stringToArrayBuffer,
  stringToUint8Array: stringToUint8Array,

  int8ToStr: int8ToStr,
  strToInt8: strToInt8,

  int16ToStr: int16ToStr,
  strToInt16: strToInt16,

  int24ToStr: int24ToStr,
  strToInt24: strToInt24,

  int32ToStr: int32ToStr,
  strToInt32: strToInt32,
  strToUInt32: strToUInt32,

  int64ToStr: int64ToStr,
  strToUInt64: strToUInt64,

  byteArrayToStr: byteArrayToStr,
  strToByteArray: strToByteArray,

  strToHexArray: strToHexArray,

  ucs2ToUtf8: ucs2ToUtf8,
  utf8ToUcs2: utf8ToUcs2,
};

module.exports.Convert = Convert;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

function numToHex(n) {
  if (typeof n !== 'number') {
    return '';
  }
  var s = n.toString(16);
  return (s.length < 2) ? ("0" + s) : s;
}


function formatHexString(obj) {
  if (typeof obj === 'number') {
    return ("0x" + (numToHex(obj)));
  }

  if (typeof obj === 'object' && Array.isArray(obj)) {
    return obj.map(numToHex).join();
  }

  if (typeof obj === 'string') {
    return Array.prototype.map.call(obj, function (_, i) { return numToHex(obj.charCodeAt(i)); }).join('');
  }

  return null;
}

var Hex = {
  formatHexString: formatHexString,
};

module.exports.Hex = Hex;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

module.exports.Long = __webpack_require__(150);


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * SolclientJS internal API for white-box integration testing
 * @private
 */

/* eslint-disable sort-requires/sort-requires */

var Convert = __webpack_require__(3);
var Debug = __webpack_require__(14);
var Destination = __webpack_require__(5);
var Error = __webpack_require__(2);
var ESKit = __webpack_require__(0);
var Factory = __webpack_require__(9);
var FSM = __webpack_require__(15);
var Log = __webpack_require__(1);
var Message = __webpack_require__(16);
var Publisher = __webpack_require__(29);
var SDT = __webpack_require__(10);
var Session = __webpack_require__(21);
var SMF = __webpack_require__(8);
var SolcacheSession = __webpack_require__(80);
var TestEnv = __webpack_require__(161);
var Transport = __webpack_require__(23);
var Util = __webpack_require__(4);
var Validate = __webpack_require__(7);

module.exports = {
  Convert: Convert,
  Debug: Debug,
  Destination: Destination,
  Error: Error,
  ESKit: ESKit,
  Factory: Factory,
  FSM: FSM,
  Log: Log,
  Message: Message,
  Publisher: Publisher,
  SDT: SDT,
  Session: Session,
  SMF: SMF,
  SolcacheSession: SolcacheSession,
  TestEnv: TestEnv,
  Transport: Transport,
  Util: Util,
  Validate: Validate,
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// Modify the Node (or emulated Node) environment so that
// we can use non-deprecated syntax.

var util = __webpack_require__(6);

if (util.inspect.custom === undefined) {
  // Inspect will use customInspect (deprecated) or a method with this name.
  // We can just define the name to be equal to 'inspect' for compatibility
  // if there is no such symbol.
  util.inspect.custom = 'inspect';
}


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
// Do late binding for these debug utilities to break cyclic dependencies.

var PRINTABLE_LUT = (function () {
  var tmp = [];
  for (var c = 0; c < 256; ++c) {
    tmp[c] = (c < 33 || c > 126) ? '.' : String.fromCharCode(c);
  }
  return tmp;
})();

var SPACER = '   ';
var UNPRINTABLE = '.';


function formatDumpBytes(data, showDecode, leftPadding) {
  var ref = __webpack_require__(4);
  var StringBuffer = ref.StringBuffer;
  var StringUtils = ref.StringUtils;
  var isEmpty = StringUtils.isEmpty;
  var padLeft = StringUtils.padLeft;
  var padRight = StringUtils.padRight;

  if (isEmpty(data)) {
    return null;
  }
  var output = new StringBuffer();
  var ascii = new StringBuffer();
  var line = new StringBuffer();
  var lineBytes = 0;
  var asciiOffset = 54;

  for (var i = 0, dataLen = data.length; i < dataLen; ++i) {
    var ccode = data.charCodeAt(i);
    line.append(padLeft(ccode.toString(16), 2, '0'), ' ');
    ascii.append(PRINTABLE_LUT[ccode] || UNPRINTABLE);
    lineBytes++;

    if (lineBytes === 8) {
      line.append(SPACER);
    }

    if (lineBytes === 16 || i === data.length - 1) {
      if (leftPadding > 0) {
        output.append(padRight('', leftPadding, ' '));
      }

      output.append(padRight(line.toString(), asciiOffset, ' '));

      if (showDecode) {
        output.append(ascii);
      }

      output.append('\n');
      line.clear();
      ascii.clear();
      lineBytes = 0;
    }
  }

  return output.toString();
}

function parseSMFStream(data) {
  var ref = __webpack_require__(8);
  var decodeCompoundMessage = ref.Codec.Decode.decodeCompoundMessage;
  var ref$1 = __webpack_require__(1);
  var LOG_WARN = ref$1.LOG_WARN;
  var LOG_ERROR = ref$1.LOG_ERROR;

  if (data === null) {
    LOG_ERROR('data null in debugParseSmfStream');
    return;
  }
  var pos = 0;
  LOG_WARN(("parseSMFStream(): Starting parse, length " + (data.length)));
  while (pos < data.length) {
    var incomingMsg = decodeCompoundMessage(data, pos);
    var smf = incomingMsg ? incomingMsg.smfHeader : null;
    if (!(incomingMsg && smf)) {
      // couldn't decode! Lost SMF framing.
      LOG_WARN("parseSMFStream(): couldn't decode message.");
      LOG_WARN(("Position: " + pos + " length: " + (data.length)));
      return;
    }

    LOG_WARN((">> Pos(" + pos + ") Protocol " + (smf.smf_protocol) + ", Length: " + (smf.messageLength)));
    pos += smf.messageLength;
  }
}

var Debug = {
  formatDumpBytes: formatDumpBytes,
  parseSMFStream: parseSMFStream,
};

module.exports.Debug = Debug;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(25);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(26);
var DestinationUtil = ref$1.DestinationUtil;
var ref$2 = __webpack_require__(86);
var Queue = ref$2.Queue;
var ref$3 = __webpack_require__(87);
var Topic = ref$3.Topic;

var QUEUE_PREFIX = '#P2P/QUE/';
var QUEUE_PREFIX_LEN = QUEUE_PREFIX.length;
var TEMPORARY_QUEUE_PREFIX = '#P2P/QTMP/';

function createDestinationFromName(networkTopicName, networkTopicBytes) {
  if ( networkTopicBytes === void 0 ) networkTopicBytes = undefined;

  if (networkTopicName === null || networkTopicName.length === 0) {
    return null;
  }

  var spec = {
    name:  networkTopicName,
    bytes: networkTopicBytes || DestinationUtil.encodeBytes(networkTopicName),
  };
  if (networkTopicName[0] === '#') {
    if (networkTopicName.startsWith(QUEUE_PREFIX)) {
      var offset = QUEUE_PREFIX_LEN;
      spec.name = networkTopicName.substr(offset);
      spec.type = DestinationType.QUEUE;
      spec.offset = offset;
      return new Queue(spec);
    } else if (networkTopicName.startsWith(TEMPORARY_QUEUE_PREFIX)) {
      spec.name = networkTopicName;
      spec.type = DestinationType.TEMPORARY_QUEUE;
      spec.offset = 0;
      return new Queue(spec);
    }
  }
  return new Topic(spec);
}

function createDestinationFromBytes(networkTopicBytes) {
  if (networkTopicBytes === null || networkTopicBytes.length === 0) {
    return null;
  }

  var networkTopicName = DestinationUtil.decodeBytes(networkTopicBytes);
  return createDestinationFromName(networkTopicName, networkTopicBytes);
}

var DestinationFromNetwork = {
  createDestinationFromBytes: createDestinationFromBytes,
  createDestinationFromName: createDestinationFromName,
};

module.exports.DestinationFromNetwork = DestinationFromNetwork;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

function apiEnv(envObject) {
  if (true) {
    throw new Error('Test environment will not override build environment');
  }
  global.BUILD_ENV = Object.assign({}, envObject, { TEST: true });
  return global.BUILD_ENV;
}

if (true) {
  apiEnv.target = function () { return apiEnv(); };
} else {
  var configs = {
    node: {
      TARGET_NAME: 'node',
      TARGET_NODE: true,
    },
    browser: {
      TARGET_NAME:    'browser',
      TARGET_BROWSER: true,
    },
    debug: {
      MODE_NAME:    'debug',
      MODE_DEBUG:   true,
      MODE_RELEASE: false,
    },
    release: {
      MODE_NAME:    'release',
      MODE_DEBUG:   false,
      MODE_RELEASE: true,
    },
  };

  apiEnv.target = function named() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var objects = args.map(function (arg) {
      if (typeof arg === 'string') {
        var obj = configs[arg];
        if (!obj) {
          throw new Error(("Environment " + arg + " is not defined; use " + (Object.keys(configs).join(', '))));
        }
        return obj;
      } else if (arg && typeof arg === 'object') {
        return arg;
      }

      throw new Error(("Unrecognized argument " + arg));
    });
    return apiEnv(Object.assign.apply(Object, objects));
  };
}
module.exports = apiEnv;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(51);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(0);
var makeMap = ref$1.makeMap;

/* eslint-disable max-len */

var SC = ErrorSubcode;

var ROOT_MAPPING = makeMap(
  400, makeMap(
    'client name parse error', SC.CLIENT_NAME_INVALID,
    'document is too large', SC.MESSAGE_TOO_LARGE,
    'inactivity timeout', SC.INACTIVITY_TIMEOUT,
    'max num subscriptions exceeded', SC.SUBSCRIPTION_TOO_MANY,
    'message too long', SC.MESSAGE_TOO_LARGE,
    'nolocal discard', SC.NOLOCAL_DISCARD,
    'not enough space', SC.OUT_OF_RESOURCES,
    'subscription already exists', SC.SUBSCRIPTION_ALREADY_PRESENT,
    'subscription attributes conflict with existing subscription', SC.SUBSCRIPTION_ATTRIBUTES_CONFLICT,
    'subscription not found', SC.SUBSCRIPTION_NOT_FOUND,
    'subscription parse error', SC.SUBSCRIPTION_INVALID,
    'topic parse error', SC.INVALID_TOPIC_SYNTAX,
    'unknown transport session identifier', SC.UNKNOWN_TRANSPORT_SESSION_ID,
    'xml parse error', SC.XML_PARSE_ERROR
  ),
  401, makeMap(
    '', SC.LOGIN_FAILURE
  ),
  403, makeMap(
    'basic authentication is shutdown', SC.BASIC_AUTHENTICATION_IS_SHUTDOWN,
    'client certificate authentication is shutdown', SC.CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN,
    'client name already in use', SC.CLIENT_NAME_ALREADY_IN_USE,
    'client username is shutdown', SC.CLIENT_USERNAME_IS_SHUTDOWN,
    'dynamic clients not allowed', SC.DYNAMIC_CLIENTS_NOT_ALLOWED,
    'invalid virtual router address', SC.INVALID_VIRTUAL_ADDRESS,
    'forbidden', SC.CLIENT_ACL_DENIED,
    'message vpn not allowed', SC.MESSAGE_VPN_NOT_ALLOWED,
    'publish acl denied', SC.PUBLISH_ACL_DENIED,
    'replication is standby', SC.REPLICATION_IS_STANDBY,
    'selector does not match', SC.SELECTOR_DOES_NOT_MATCH,
    'subscription acl denied', SC.SUBSCRIPTION_ACL_DENIED,
    'subscription does not match', SC.SUBSCRIPTION_DOES_NOT_MATCH
  ),
  404, makeMap(
    '', SC.LOGIN_FAILURE
  ),
  503, makeMap(
    'low priority msg congestion', SC.LOW_PRIORITY_MSG_CONGESTION,
    'message vpn unavailable', SC.MESSAGE_VPN_UNAVAILABLE,
    'replication is standby', SC.REPLICATION_IS_STANDBY,
    'service unavailable', SC.GM_UNAVAILABLE,
    'spool over quota', SC.SPOOL_OVER_QUOTA,
    'subscriber delete in progress', SC.CLIENT_DELETE_IN_PROGRESS,
    'too many clients', SC.TOO_MANY_CLIENTS,
    'too many connections for vpn', SC.TOO_MANY_CLIENTS,
    'max message usage exceeded', SC.MAX_MESSAGE_USAGE_EXCEEDED
  ),
  507, makeMap(
    'ad not ready', SC.GM_NOT_READY
  )
);

var AD_MAPPING = makeMap(
  'PARENT', ROOT_MAPPING,
  400, makeMap(
    'already bound', SC.ALREADY_BOUND,
    'endpoint already exists', SC.ENDPOINT_ALREADY_EXISTS,
    'endpoint property mismatch', SC.ENDPOINT_PROPERTY_MISMATCH,
    'invalid durable topic endpoint name', SC.INVALID_DTE_NAME,
    'invalid selector', SC.INVALID_SELECTOR,
    'invalid topic name', SC.INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT,
    'queue not found', SC.QUEUE_NOT_FOUND,
    'quota out of range', SC.QUOTA_OUT_OF_RANGE,
    'unknown flow name', SC.UNKNOWN_FLOW_NAME,
    'unsubscribe not allowed', SC.UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND
  ),
  403, makeMap(
    'permission not allowed', SC.PERMISSION_NOT_ALLOWED
  ),
  503, makeMap(
    'durable topic endpoint shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'endpoint shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'max clients exceeded for durable topic endpoint', SC.MAX_CLIENTS_FOR_TE,
    'max clients exceeded for queue', SC.MAX_CLIENTS_FOR_QUEUE,
    'no more non-durable queue or topic endpoint', SC.NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT,
    'no subscription match', SC.NO_SUBSCRIPTION_MATCH,
    'queue shutdown', SC.QUEUE_SHUTDOWN,
    'te shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'unknown durable topic endpoint', SC.UNKNOWN_TOPIC_ENDPOINT_NAME,
    'unknown queue', SC.UNKNOWN_QUEUE_NAME
  )
);

function getSubcodeMappingInner(root, respErrorCode, respStr) {
  if (respErrorCode === 200) {
    // success response, error subcode is 0 -  transport session use 0 as OK
    return 0;
  }
  var codeMap = root[respErrorCode] || {};
  var searchKey = (respStr || '').toLowerCase();
  var foundKey = Object.keys(codeMap)
    .find(function (mapKey) { return mapKey === searchKey || searchKey.indexOf(mapKey) >= 0; });

  if (foundKey) {
    return codeMap[foundKey];
  }

  if (codeMap['']) {
    return codeMap[''];
  }

  /* eslint-disable dot-notation */
  // Don't access string keys via dot properties
  if (root['PARENT']) {
    return getSubcodeMappingInner(root['PARENT'], respErrorCode, respStr);
  }
  /* eslint-enable dot-notation */

  return undefined;
}

function getSubcodeMapping(root, respErrorCode, respStr) {
  var result = getSubcodeMappingInner(root, respErrorCode, respStr);
  if (result === undefined) {
    return SC.UNKNOWN_ERROR;
  }
  return result;
}

/**
 * @classdesc
 * Return {ErrorSubcode} based on response code and response string
 * from the router.
 * @private
 */
var ErrorResponseSubcodeMapper = {
  /**
   * @param {Number} respErrorCode The response code (an HTTP-like integer) to use in the lookup.
   * @param {String} respStr The response string to use in the lookup.
   * @returns {solace.ErrorSubcode} The subcode found, or ErrorSubcode.UNKNOWN_ERROR if not found.
   * @static
   * @private
   */
  getErrorSubcode: function getErrorSubcode(respErrorCode, respStr) {
    return getSubcodeMapping(ROOT_MAPPING, respErrorCode, respStr);
  },

  getADErrorSubcode: function getADErrorSubcode(respErrorCode, respStr) {
    return getSubcodeMapping(AD_MAPPING, respErrorCode, respStr);
  },
};

module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(52);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown when calling an API that has not been implemented.
 * @hideconstructor
 * @extends {solace.SolaceError}
 *
 * @memberof solace
 */
var NotImplementedError = (function (SolaceError) {
  function NotImplementedError(message) {
    SolaceError.call(this, 'NotImplementedError', message || '', NotImplementedError);
  }

  if ( SolaceError ) NotImplementedError.__proto__ = SolaceError;
  NotImplementedError.prototype = Object.create( SolaceError && SolaceError.prototype );
  NotImplementedError.prototype.constructor = NotImplementedError;

  return NotImplementedError;
}(SolaceError));

module.exports.NotImplementedError = NotImplementedError;



/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(51);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(88);
var OperationError = ref$1.OperationError;
var ref$2 = __webpack_require__(89);
var RequestEventCode = ref$2.RequestEventCode;


var SUBCODE_FROM_EC = {};
SUBCODE_FROM_EC[RequestEventCode.REQUEST_ABORTED] = ErrorSubcode.SESSION_NOT_CONNECTED;
SUBCODE_FROM_EC[RequestEventCode.REQUEST_TIMEOUT] = ErrorSubcode.TIMEOUT;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a request failure event; request failure events are passed to the application
 * event handling callback provided when sending the request {@link solace.Session#sendRequest}
 * @memberof solace
 * @extends solace.OperationError
 * @hideconstructor
 */
var RequestError = (function (OperationError) {
  function RequestError(message, eventCode, correlationKey, reason) {
    OperationError.call(this, message, SUBCODE_FROM_EC[eventCode], reason);
    /**
     * The name of the error.
     * @name solace.RequestError#name
     * @type {Constant}
     * @description 'RequestError'
     */
    this.name = 'RequestError';
    this._eventCode = eventCode;
    this._correlationKey = correlationKey;
  }

  if ( OperationError ) RequestError.__proto__ = OperationError;
  RequestError.prototype = Object.create( OperationError && OperationError.prototype );
  RequestError.prototype.constructor = RequestError;

  var prototypeAccessors = { requestEventCode: {},errorSubcode: {} };

  /**
   * @type {solace.SessionEventCode}
   * @name solace.RequestError#requestEventCode
   * @description A code that provides more information about the error event.
   */
  prototypeAccessors.requestEventCode.get = function () {
    return this._requestEventCode;
  };

  /**
   * @deprecated Use {@link solace.RequestError#subcode}
   * @type {?solace.ErrorSubcode}
   * @description if applicable, an error subcode. Defined in {@link ErrorSubcode}
   */
  prototypeAccessors.errorSubcode.get = function () {
    return OperationError.prototype.subcode;
  };

  RequestError.prototype[util.inspect.custom] = function () {
    var superObj = OperationError.prototype[util.inspect.custom] ? OperationError.prototype[util.inspect.custom].call(this) : {};
    return Object.assign(superObj, {
      'requestEventCode': RequestEventCode.describe(this.requestEventCode),
      'infoStr':          this.infoStr,
      'correlationKey':   this.correlationKey,
    });
  };

  RequestError.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( RequestError.prototype, prototypeAccessors );

  return RequestError;
}(OperationError));

module.exports.RequestError = RequestError;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/* eslint-disable no-nested-ternary */

function defaultComparator(a, b) {
  var astr = String(a);
  var bstr = String(b);
  return astr > bstr ? 1 : (astr < bstr ? -1 : 0);
}

function insertOrdered(array, element, comparator) {
  if ( comparator === void 0 ) comparator = defaultComparator;

  var result = [].concat( array );
  return this.inplaceInsertOrdered(result, element, comparator);
}

function inplaceInsertOrdered(array, element, comparator) {
  if ( comparator === void 0 ) comparator = defaultComparator;

  var index = 0;
  var min = 0;
  var max = array.length;
  // Optimize for empty array
  if (max > 0) {
    // Optimize for append
    if (comparator(element, array[max - 1]) > 0) {
      index = max;
    } else {
      // Binary search
      index = (min + max) >> 1; // math.floor((min + max) / 2)
      while (max > min) {
        if (comparator(element, array[index]) < 0) {
          max = index;
        } else {
          min = index + 1;
        }
        index = (min + max) >> 1; // math.floor((min + max) / 2)
      }
    }
  }
  array.splice(index, 0, element);
}

module.exports = {
  ArrayOperations: {
    defaultComparator: defaultComparator,
    insertOrdered: insertOrdered,
    inplaceInsertOrdered: inplaceInsertOrdered,
  },
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var assert;

/**
 * Browsers and Node share a common console.assert interface, console.assert(assertion, ...);
 * In Node, console.assert throws AssertionError if its assertion is falsy.
 * In browsers, they print to the console.
 * Extend browser behaviour to also throw.
 */

if (true) {
  var internalAssert;
  if (true) {
    // eslint-disable-next-line no-console
    internalAssert = console.assert;
  } else {
    internalAssert = function browserAssert(assertion) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      if (!assertion) {
        throw new Error(("Assertion error: " + (typeof assertion) + " " + assertion + " (" + (args.join(' ')) + ")"));
      }
    };
  }
  // Now, wrap the assert in a catch and rethrow to give us a single place
  // to set assert breakpoints.
  assert = function outerAssert() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    try {
      internalAssert.apply(void 0, args);
    } catch (e) {
      // if (BUILD_ENV.MODE_DEBUG) debugger;
      throw (e);
    }
  };
} else {
  // In production mode, asserts are generally disabled.
  assert = function () {};
}

module.exports.assert = assert;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/**
 * @private
 */
var BidiMap = function BidiMap() {
  var this$1 = this;
  var pairs = [], len = arguments.length;
  while ( len-- ) pairs[ len ] = arguments[ len ];

  this.forward = new Map();
  this.reverse = new Map();
  pairs.forEach(function (p) {
    this$1.setValues(p[0], p[1]);
  });
};

/**
 * Sets the key => value and value => key relationships for the supplied parameters.
 *
 * Method name is #set, not #put, for alignment with ES map method names.
 * @param {*} key The key for the forward mapping (value in the reverse mapping)
 * @param {*} value The value for the forward mapping (key in the reverse mapping)
 */
BidiMap.prototype.setValues = function setValues (key, value) {
  this.forward.set(key, value);
  this.reverse.set(value, key);
};

module.exports.BidiMap = BidiMap;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

function enumName(instance, keys, value) {
  var matches = keys.filter(function (k) { return instance[k] === value; });
  return matches.length ? matches[0] : null;
}

function enumValues(instance, keys) {
  return Array.from(new Set(keys.map(function (k) { return instance[k]; })));
}

/**
 * The base for all enumerated types. Provides common functionality such as
 * collections of keys and values, reverse mapping, and readable descriptions. Also
 * supports overriding the canonical key-value mapping to maintain readability in
 * minified environments.
 *
 * @mixin
 * @memberof solace
 */
var Enum = function Enum(values) {
  Object.defineProperties(this, {
    _canonical: {
      value:      null,
      enumerable: false,
      writable:   true,
      configurable: true,
    },
  });
  this._setCanonical(values);
};

var prototypeAccessors = { names: {},values: {},isEnum: {} };

/**
 * Resets the canonical key value mapping for the enumeration. Using this method,
 * you add additional sets of keys that map to the same values, and specify that
 * these new keys take precedence for reverse mapping. Any older set of keys is made
 * non-canonical and non-enumerable.
 *
 * @example
 * const c = new Enum({ HELLO: 'world' });
 * c._setCanonical({ MAD: 'world' });
 * c.nameOf('world') === 'MAD'; // true
 *
 * @param {Object} values The new key-value mapping to add to the object and set as canonical.
 * @param {Boolean} final Whether this enumeration should accept further reconfiguration.
 * @private
 */
Enum.prototype._setCanonical = function _setCanonical (values, final) {
    var this$1 = this;
    if ( final === void 0 ) final = false;

  this._canonical = Object.assign({}, values);
  Object.keys(this).forEach(function (key) {
    var descriptor = Object.getOwnPropertyDescriptor(this$1, key);
    if (descriptor.value !== undefined) {
      Object.defineProperty(this$1, key, {
        enumerable: false,
        writable:   true,
        configurable: true,
        value:      descriptor.value,
      });
    }
  });
  Object.keys(values).forEach(function (key) {
    Object.defineProperty(this$1, key, {
      enumerable: true,
      writable:   !final,
      configurable: !final,
      value:      values[key],
    });
  });
};

/**
 * Create a human-readable string describing the given enumeration value. This
 * result is informational and may vary between SDK versions.
 *
 * Currently, it either returns the value provided (if the associated key is
 * the same), or a string of the form `key (value)`.
 *
 * @example
 * console.log(new Enum({ ANSWER: 42 }).describe(42)); // ANSWER (42)
 * console.log(new Enum({ ECHO: 'ECHO' })).describe('ECHO'); // ECHO
 *
 * @param {any} enumValue The value on which to perform reverse mapping.
 * @param {String} [noneValue=''] The string to return if the enumeration value is
 *  undefined or null.
 * @param {String} [unknownValue='<unknown>'] The string to return if the enumeration
 *  value was not found in any of the canonical keys.
 * @returns {String} A human-readable description of the reverse mapping for the value.
 */
Enum.prototype.describe = function describe (enumValue, noneValue, unknownValue) {
    if ( noneValue === void 0 ) noneValue = '<none>';
    if ( unknownValue === void 0 ) unknownValue = '<unknown>';

  if (enumValue === null || enumValue === undefined) { return noneValue; }
  var name = enumName(this._canonical,
                        Object.keys(this._canonical || {}),
                        enumValue)
               || unknownValue;
  return name === enumValue ? name : (name + " (" + enumValue + ")");
};

/**
 * Returns the canonical name in this enumeration for the given value. This function is
 * designed to facilitate reflection, whereas for display
 *
 * @param {any} enumValue The value for which to get the enumeration key.
 * @returns {String} The name for the given value.
 */
Enum.prototype.nameOf = function nameOf (enumValue) {
  return enumName(this._canonical, Object.keys(this._canonical || {}), enumValue);
};

/**
 * Returns all canonical names/keys in this enumeration.
 *
 * @readonly
 * @returns {Array.<String>} All canonical names in this enumeration.
 */
prototypeAccessors.names.get = function () {
  return Object.keys(this._canonical || {});
};

/**
 * Returns all values assigned to canonical keys in this enumeration.
 *
 * @readonly
 * @returns {Array} All values defined for enumeration keys.
 */
prototypeAccessors.values.get = function () {
  return enumValues(this._canonical, Object.keys(this._canonical || {}));
};

/**
 * A property returning true to faciliate duck-typing with {solace.Enum} objects.
 *
 * @readonly
 * @returns {Boolean} true This is an enumeration.
 */
prototypeAccessors.isEnum.get = function () { // eslint-disable-line class-methods-use-this
  return true;
};

/**
 * Returns the name of an enuerated value given the
 * enumeration and the value.
 *
 * @param {Object} instance The enumeration instance.
 * @param {*} value The value for which to return the key name.
 * @returns {String} The key name for the given enumeration value.
 */
Enum.nameOf = function nameOf (instance, value) {
  return instance.nameOf(value);
};

/**
 * Returns values defined on this enumeration for the given keys. To get the enumeration keys,
 * use {@link Object#keys}.
 * @param {Object} instance The enumeration on which to return values.
 * @returns {Array} The values defined on the given enumeration.
 **/
Enum.values = function values (instance) {
  return instance.values();
};

/**
 * Alternate construction method for enumerations.
 *
 * @static
 * @param {Object} values Initial key-value mapping
 * @returns {solace.Enum} A new enumeration instance
 * @private
 */
Enum.new = function new$1 (values) {
  return new Enum(values);
};

/**
 * Constructs a private enumeration in which the values are equal to the keys.
 *
 * @static
 * @param {Array.<String>} strings Key names. The values will be equal to the keys.
 * @returns {solace.Enum} An enumeration instance of the given strings
 * @private
 */
Enum.ofStrings = function ofStrings (strings) {
  var map = {};
  strings.forEach(function (s) {
    map[s] = s;
  });
  return Enum.new(map);
};

/**
 * Constructs an enumeration in which each key is assigned a distinct integer value.
 * Enums created this way are subject to renumbering if keys are reordered.
 *
 * @static
 * @param {Array.<String>} keys Key names. The values will be sequential from zero.
 * @returns {solace.Enum} An enumeration instance of the given values
 * @private
 */
Enum.ofNumbers = function ofNumbers (keys) {
  var map = {};
  keys.forEach(function (key, index) {
    map[key] = index;
  });
  return Enum.new(map);
};

Object.defineProperties( Enum.prototype, prototypeAccessors );

module.exports.Enum = Enum;


/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * An object managing a traversal of an Array-like object.
 *
 * @memberof solace
 * @property {function} deref Returns the value the iterator is
 *      referencing.
 * @property {function} incr Increments the iterator's reference in the
 *      iterator's data set.
 * @property {function} end Tests whether the iterator is at the end of
 *      the data set.  This MUST return false when calling deref() or
 *      incr().
 * @private
 */
var Iterator = function Iterator(arr, start, end) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = arr.length;

  /**
   * The array being iterated.
   * @type {Array}
   * @private
   */
  this._arr = arr;
  /**
   * The current index of the enumeration.
   * @private
   * @type {Number}
   */
  this._index = start;
  /**
   * The exclusive end index, or the length, of the array.
   * @type {Number}
   */
  this._end = end;
};

/**
 * Returns the element at the iterator's position.
 * @returns {Object} The array element at the current position.
 */
Iterator.prototype.deref = function deref () {
  return this._arr[this._index];
};

/**
 * Increments the iterator.
 * @returns {Number} The new position of the iterator.
 */
Iterator.prototype.incr = function incr () {
  return ++this._index;
};

/**
 * Reports whether the iterator has completed its iteration.
 * @returns {Boolean} True if the iterator has reached the end of the iteration.
 */
Iterator.prototype.end = function end () {
  return this._index >= this._end;
};

/**
 * Creates an iterator to forward iterate over a specific contiguous
 * section of an array, specifically in the range [start, end)
 *
 * @param {Array} arr The array to iterate over
 * @param {Number} [start=0] The first item the iterator should
 *dereference
 * @param {Number} [end=arr.length] One beyond the last item in the array
 *that the iterator should dereference.
 * @returns {solace.Iterator} An iterator to the specified set of data.
 */
Iterator.makeIterator = function makeIterator (arr, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = arr.length;

  return new Iterator(arr, start, end);
};

// Expose both the static constructor function and the class.
module.exports.Iterator = Iterator;


/***/ }),
/* 170 */
/***/ (function(module, exports) {


// Avoid closure compiler nonsense
module.exports.makeMap = function makeMap() {
  var keyValuePairs = [], len = arguments.length;
  while ( len-- ) keyValuePairs[ len ] = arguments[ len ];

  var result = {};
  for (var i = 0; i < keyValuePairs.length; i += 2) {
    result[keyValuePairs[i]] = keyValuePairs[i + 1];
  }
  return result;
};


/***/ }),
/* 171 */
/***/ (function(module, exports) {

var Mixin = {
  /**
   * @param  {Object} target The class to augment
   * @param  {Object} add The class to mix in.
   * @returns {Object} The augmented class
   */
  mixin: function mixin(target, add) {
    var targetProto = target.prototype;
    var addProto = add.prototype;
    Object.getOwnPropertyNames(addProto).forEach(function (name) {
      if (name === 'constructor') { return; }
      Object.defineProperty(targetProto, name, Object.getOwnPropertyDescriptor(addProto, name));
    });
    return target;
  },
};

module.exports.Mixin = Mixin;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(90);
var Lazy = ref.Lazy;

var lazyProperty = Lazy.lazyProperty;

function traversePath(commonSource, keySource, pathArr) {
  return pathArr.reduce(function (source, value) {
    if (typeof value === 'string') {
      return source[value];
    }
    return value;
  }, keySource);
}

/**
 * @classdesc
 * Deferred resolution for imports. A heavyweight method of breaking circular dependencies.
 * Each specified key (see below) is resolved once by a function that lazily evaluates a
 * path.
 * <pre>
 * const resolved = new Resolver({
 *  foo: [FooLib, 'fooContainer'],        // Resolves foo from FooLib.fooContainer.foo lazily
 *  bar: ['foo'],                         // Resolves bar from previously defined foo lazily
 *  'baz,quux': [FooLib, 'bazsAndQuuxes'] // baz = FooLib.bazsAndQuuxes.baz,
 *                                        // quux = FooLib.bazsAndQuuxes.quux
 * });
 * </pre>
 * In most cases this is equivalent to using FooLib.fooContainer.foo, et cetera, directly.
 * Prefer that approach unless the dependencies are deeply hierarchical. Prefer the Resolver
 * when one-time evaluation and aliasing a path makes the code more DRY and readable.
 * @private
 */
var Resolver = function Resolver(options, source) {
  var this$1 = this;

  // For every key...
  Object.keys(options).forEach(function (compoundKey) {
    // Split out key names if multiple were provided
    compoundKey.split(',').map(function (k) { return k.trim(); }).forEach(function (key) {
      // Build a path array. The key name is the implicit last element.
      var rawPath = options[compoundKey];
      var path = typeof rawPath === 'string' ? rawPath.split('.') : rawPath;
      var pathArr = (Array.isArray(path) ? path : [path]).concat(key);
      // Create a defer for this key.
      lazyProperty(this$1, key, function () { return traversePath(source, this$1, pathArr); });
    });
  });
};

Resolver.resolve = function resolve (options, source) {
  return new Resolver(options, source);
};


module.exports.Resolver = Resolver;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/* eslint-disable no-restricted-syntax */

function isSuperset(set, subset) {
  return Array.from(subset).every(function (elem) { return set.has(elem); });
}

function inplaceUnion(setA, setB) {
  setB.forEach(function (elem) {
    setA.add(elem);
  });
  return setA;
}

function union(setA, setB) {
  return inplaceUnion(new Set(setA), setB);
}

function inplaceIntersection(setA, setB) {
  setA.forEach(function (elem) {
    if (!setB.has(elem)) {
      setA.delete(elem);
    }
  });
  return setA;
}

function intersection(setA, setB) {
  return new Set(Array.from(setA).filter(function (elem) { return setB.has(elem); }));
}

function inplaceDifference(setA, setB) {
  setB.forEach(function (elem) {
    setA.delete(elem);
  });
  return setA;
}

function difference(setA, setB) {
  return new Set(Array.from(setA).filter(function (elem) { return !setB.has(elem); }));
}

module.exports = {
  SetOperations: {
    inplaceDifference: inplaceDifference,
    inplaceIntersection: inplaceIntersection,
    inplaceUnion: inplaceUnion,
    isSuperset: isSuperset,
    difference: difference,
    intersection: intersection,
    union: union,
  },
}
;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var NodeEventEmitter = __webpack_require__(285).EventEmitter;
var ref = __webpack_require__(4);
var ArrayUtils = ref.ArrayUtils;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;
var ref$2 = __webpack_require__(1);
var LOG_WARN = ref$2.LOG_WARN;

var flatten = ArrayUtils.flatten;
var includes = ArrayUtils.includes;
var NODE_DEFAULT_EVENTS = ['error', 'newListener', 'removeListener'];
var BLACKLIST_DIRECT = ['newListener', 'removeListener'];

function buildFilter(emits) {
  if (typeof emits === 'function') { return function (k) { return includes(NODE_DEFAULT_EVENTS, k) || emits(k); }; }
  if (!Array.isArray(emits)) { return null; }
  var emitSet = new Set(flatten(emits));
  NODE_DEFAULT_EVENTS.forEach(function (el) { return emitSet.add(el); });
  var emitArray = Array.from(emitSet);
  return function (k) { return includes(emitArray, k); };
}

var DISABLED_ACTIONS = {
  ignore: function ignore() {},
  fail: function fail() {
    throw new Error('Emitter disabled');
  },
};

var EventEmitter = (function (NodeEventEmitter) {
  function EventEmitter(options) {
    NodeEventEmitter.call(this);
    var ref = options || {};
    var direct = ref.direct;
    var emits = ref.emits;
    var unsafe = ref.unsafe;
    var formatEventName = ref.formatEventName;
    this.formatEventName = formatEventName || (function (name) { return name; });

    // Direct mode path:
    //  emit --> (direct emit || bareEmit).
    var bareEmit = this.emit.bind(this);
    this._installDirectFilter(direct, bareEmit);

    // Indirect mode path:
    //  verifier -> error handlers -> emit --> bareEmit
    this._installErrorHandlers(unsafe);
    this._installEmitVerifier();

    this._listenerVerificationFilter = buildFilter(emits);
    this._emits = emits;
  }

  if ( NodeEventEmitter ) EventEmitter.__proto__ = NodeEventEmitter;
  EventEmitter.prototype = Object.create( NodeEventEmitter && NodeEventEmitter.prototype );
  EventEmitter.prototype.constructor = EventEmitter;

  var prototypeAccessors = { isDirect: {} };

  EventEmitter.prototype._installDirectFilter = function _installDirectFilter (direct, bareEmit) {
    var this$1 = this;

    if (!direct) { return; }
      // Direct mode class instance modifications

    if (includes(BLACKLIST_DIRECT, direct)) {
      throw new OperationError(
        ("Cannot configure listener collection events [" + (BLACKLIST_DIRECT.join(', ')) + "] as direct"),
        ErrorSubcode.INTERNAL_ERROR);
    }

    // The default direct emitter is the base emitter. Skip any overrides we installed.
    this._defaultEmitDirect = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return bareEmit.apply(void 0, [ direct ].concat( args ));
    };

    // Initally not direct for 0 listeners
    this.emitDirect = this._defaultEmitDirect;
    this._directEventName = direct;

    this.on = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.on.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, true, listener);
      return ret;
    };

    this.addListener = function (eventName, listener) { return this$1.on(eventName, listener); };

    this.once = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.once.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, false);
      return ret;
    };

    this.prependListener = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.prependListener.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, true, listener);
      return ret;
    };

    this.prependOnceListener = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.prependOnceListener.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, false);
      return ret;
    };

    this.removeAllListeners = function (eventName) {
      var ret = NodeEventEmitter.prototype.removeAllListeners.call(this$1, eventName);
      if ((eventName === this$1._directEventName) || (eventName === undefined)) {
        this$1.emitDirect = this$1._defaultEmitDirect;
      }
      return ret;
    };

    this.removeListener = function (eventName, listener) {
      var ret = NodeEventEmitter.prototype.removeListener.call(this$1, eventName, listener);
      if ((eventName === this$1._directEventName) && (this$1.listenerCount(eventName) === 0)) {
        this$1.emitDirect = this$1._defaultEmitDirect;
      }
      return ret;
    };

    this.directListenerCount = function () { return this$1.listenerCount(this$1._directEventName); };

    this.setOnFirstDirectListener = function (firstDirect) {
      this$1._onFirstDirectListener = firstDirect;
    };
  };

  EventEmitter.prototype._setEmitDirect = function _setEmitDirect (eventName, onListener, listener) {
    if (eventName !== this._directEventName) {
      return;
    }

    if (onListener && (this.directListenerCount() === 1)) {
      this.emitDirect = listener;
    } else {
      this.emitDirect = this._defaultEmitDirect;
    }

    if ((this.directListenerCount() === 1) && (this._onFirstDirectListener !== undefined)) {
      this._onFirstDirectListener();
    }
  };

  EventEmitter.prototype._verifyListenerEvent = function _verifyListenerEvent (event) {
    if (!this._listenerVerificationFilter) { return; }

    if (event === undefined || event === null) {
      this.throwInternal(
          new OperationError(("Emitter rejects listener for no-name event: " + event),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE));
    }
    if (!this._listenerVerificationFilter(event)) {
      this.throwInternal(
        new OperationError(("Emitter rejects listeners for " + event + ", emits " + (this._emits)),
                            ErrorSubcode.PARAMETER_OUT_OF_RANGE));
    }
  };

  EventEmitter.prototype._installEmitVerifier = function _installEmitVerifier () {
    var this$1 = this;

    if (true) {
      // Debug mode: always add assert for empty event name
      var emitBase = this.emit.bind(this);
      this.emit = function (name) {
        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

        if (name === undefined || name === null) {
          this$1.throwInternal(new OperationError(("Emitter rejects no-name event: " + name)));
        }
        emitBase.apply(void 0, [ name ].concat( args ));
      };
    }
  };

  EventEmitter.prototype._installErrorHandlers = function _installErrorHandlers (unsafe) {
    var this$1 = this;

    if (unsafe) {
      // If unsafe, there's no try/catch/emit so throwInternal just throws
      this.throwInternal = function (err) { throw err; };
      return;
    }

    // Install try/catch/emit-as-event if not unsafe mode.
    // Introduces throwInternal, which sets the _internalError flag restore
    // orignal throw-to-emitter functionality in case of internal error

    var emitBase = this.emit.bind(this);

    this.throwInternal = function throwInternal(err) {
      this._internalError = true;
      throw err;
    };

    this.emit = function (name) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      try {
        emitBase.apply(void 0, [ name ].concat( args ));
      } catch (ex) {
        if (this$1._internalError) {
          this$1._internalError = undefined;
          throw ex; // rethrow
        }

        var err = (ref = this$1).formatErrorEvent.apply(ref, [ ex, name ].concat( args ));
        try {
          LOG_WARN(("Listener for '" + (err.info.event.formattedName) + "' threw exception, dispatching to 'error'"));
          emitBase('error', err);
        } catch (innerEx) {
          LOG_WARN("Listener for 'error' threw exception:", innerEx, '\nOriginal exception:', ex);
        }
      }
      var ref;
    };
  };

  prototypeAccessors.isDirect.get = function () {
    return this.emitDirect && (this.emitDirect !== this._defaultEmitDirect);
  };

  EventEmitter.prototype.formatErrorEvent = function formatErrorEvent (ex, name) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

    var formattedName = this.formatEventName(name);
    return Object.assign(new OperationError(
      ("Unhandled error in event handler for '" + formattedName + "'"),
      ErrorSubcode.CALLBACK_ERROR,
      ("On event: " + ([name ].concat( args)) + " " + ex)
    ), {
      stack: ex.stack,
      info:  {
        event: { name: name, formattedName: formattedName, args: args },
        error: ex,
      },
    });
  };

  EventEmitter.prototype.disableEmitter = function disableEmitter () {
    this._defaultEmitDirect = DISABLED_ACTIONS.ignore;
    // If this is a direct-enabled emitter, this will also cause emitDirect to be set to
    // _defaultEmitDirect, which is now DISALBED_ACTIONS.ignore.
    this.removeAllListeners();
    this.emit = DISABLED_ACTIONS.ignore;
    // Freeze listeners by first disabling remove, then add.
    this.addListener('removeListener', DISABLED_ACTIONS.fail);
    this.addListener('newListener', DISABLED_ACTIONS.fail);
  };

  Object.defineProperties( EventEmitter.prototype, prototypeAccessors );

  return EventEmitter;
}(NodeEventEmitter));

module.exports.EventEmitter = EventEmitter;


/***/ }),
/* 175 */
/***/ (function(module, exports) {

/**
 * @private
 */
var Timer = function Timer(cancel) {
  var this$1 = this;

  this.cancel = function () {
    this$1.cancel = function () {}; // change to no-op
    cancel();
  };
};

/**
 * @static
 * @param {Number} interval The interval for the timer, in milliseconds.
 * @param {function} onInterval The function to invoke on expiration.
 * @param {any} [args] Any arguments to pass to the onExpire callback.
 * @returns {Timer} A new timer object.
 */
Timer.newInterval = function newInterval (interval, onInterval) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

  var timerRef = setInterval.apply(void 0, [ onInterval, interval ].concat( args ));
  return new Timer(function () { return clearInterval(timerRef); });
};

/**
 * @static
 * @param {Number} timeout The timeout for the timer, in milliseconds.
 * @param {function} onExpire The function to invoke on expiration.
 * @param {any} [args] Any arguments to pass to the onExpire callback.
 * @returns {Timer} A new timer object.
 */
Timer.newTimeout = function newTimeout (timeout, onExpire) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

  var timerRef = setTimeout.apply(void 0, [ onExpire, timeout ].concat( args ));
  return new Timer(function () { return clearTimeout(timerRef); });
};

module.exports.Timer = Timer;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(92);
var FactoryProfile = ref$1.FactoryProfile;
var SolclientFactoryProfiles = ref$1.SolclientFactoryProfiles;
var ref$2 = __webpack_require__(7);
var Parameter = ref$2.Parameter;
var ref$3 = __webpack_require__(91);
var ProfileBinding = ref$3.ProfileBinding;
var ref$4 = __webpack_require__(93);
var SolclientFactoryProperties = ref$4.SolclientFactoryProperties;

var factoryState = {
  initializeCount: 0,
  initializers:    [],
};
/**
 * @global
 * @name solClientJS
 * @description
 * <b>solClientJS</b> is a full functioned Solace Messaging API written entirely in JavaScript.
 * Applications using the <i>solClientJS</i> API can access all the features of a
 * Solace Message Router.
 *
 * The API is intended for use by applications written in JavaScript, targetting
 * either <b>NODE</b> or a traditional web browser.
 *
 * All classes, objects, methods of the API are encapsulated in the {@link solace} namespace.
 * The starting point for all applications is {@link solace.SolclientFactory}. This factory object
 * generates the {@link solace.Session} for connecting to the Solace Message Router.
 * {@link solace.SolclientFactory} also generates the {@link solace.Message} object
 * which enncapsulates the messages and {@link solace.Destination} the application will use
 * to send and receive data.
 * @summary The Solace Message Router Messaging API for Javascript.
 */

/**
 * A singleton used as the main factory for the messaging APIs. The very first operation by
 * any application must be to initialize the API:
 * * @link solace.SolclientFactory#init}
 *
 * <i>SolclientFactory</i> provides methods to construct:
 * * {@link solace.Session}
 * * {@link solace.Message}
 * * {@link solace.Destination}
 *
 * Additionally <i>SolclientFactory</i> manages the
 * logging level in the API.
 * @namespace
 * @public
 * @memberof solace
 */
var SolclientFactory = {

  /**
   * Adds a function to be called on factory initialization
   * @param {function(factoryProps, factoryState)} func initializer function to be called
   * @internal
   */
  addInitializer: function addInitializer(func) {
    factoryState.initializers.push(func);
  },

  /**
   * @param {function} func function to wrap
   * @returns {function} new factory method
   * @internal
   */
  createFactory: function createFactory(func) {
    return function factoryMethod() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (factoryState.initializeCount === 0) {
        throw new OperationError('SolclientFactory not initialized', ErrorSubcode.INVALID_OPERATION);
      }
      return func.apply(void 0, args);
    };
  },

  /**
   * Initialize global properties. This function must be called before any other API call is made.
   *
   * Note: After the first call to this method, subsequent calls have no effect.
   *
   * @param {solace.SolclientFactoryProperties} [factoryProps] The initialization properties for
   *  the factory, if required.
   * @param {solace.LogImpl} [factoryProps.logger] A logging implementation
   * @param {solace.LogLevel}[factoryProps.logLevel] The logging level to use
   *  for filtering log events.
   * @param {solace.SolclientFactoryProfiles}
   *  [factoryProps.profile=solace.SolclientFactoryProfiles.version7]
   *     The factory profile. This class cannot be created by an API user; choose one of the static
   *     instances from {@link solace.SolclientFactoryProfiles}.
   * @throws {solace.OperationError} Invalid logger implementation
   * @returns {solace.SolclientFactory} For method chaining
   */
  init: function init(factoryProps) {
    var this$1 = this;

    if (factoryState.initializeCount > 0) {
      return this;
    }

    var props = new SolclientFactoryProperties(factoryProps);
    var profile = factoryProps && factoryProps.profile || SolclientFactoryProfiles.version7;
    Parameter.isInstanceOf('factoryProps.profile', profile, FactoryProfile);
    ProfileBinding.value = profile;

    factoryState.initializers.forEach(function (initializer) {
      initializer.call(this$1, props, factoryState);
    });
    ++factoryState.initializeCount;

    if ((factoryProps !== undefined) && (factoryProps !== null)) {
      // Factory should not depend on other packages at file scope
      // eslint-disable-next-line global-require
      var ref = __webpack_require__(1);
      var LOG_DEBUG = ref.LOG_DEBUG;
      LOG_DEBUG('Factory properties:\n', factoryProps);
    }
    return this;
  },

  /**
   * @private
   */
  reset: function reset() {
    factoryState.initializeCount = 0;
  },


  /**
   * @returns {Number} Count of factory initializations.
   *    Nonzero means cannot be initialized again.
   * @internal
   */
  _getInitializeCount: function _getInitializeCount() {
    return factoryState.initializeCount;
  },

  /**
   * @private
   * @name solace.SolclientFactory.profiles
   * @type {solace.SolclientFactoryProfiles}
   * @readonly
   * @description The collection of {@link solace.FactoryProfile}. See a description of
   * each in {@link solace.SolclientFactoryProfiles}.
   */
  get profiles() {
    return SolclientFactoryProfiles;
  },
};

module.exports.SolclientFactory = SolclientFactory;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var NotImplementedError = ref.NotImplementedError;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(35);
var EventEmitter = ref$1.EventEmitter;
var ref$2 = __webpack_require__(94);
var FlowOperation = ref$2.FlowOperation;
var ref$3 = __webpack_require__(1);
var LogFormatter = ref$3.LogFormatter;
var ref$4 = __webpack_require__(95);
var PrivateFlowEventName = ref$4.PrivateFlowEventName;
var ref$5 = __webpack_require__(19);
var Stats = ref$5.Stats;

// Unless flow is disposed, these operations are always allowed
var ALWAYS_OPS = [
  FlowOperation.DISPOSE,
  FlowOperation.GET_STATS,
  FlowOperation.GET_PROPERTIES,
  FlowOperation.RESET_STATS ];


/**
 * @classdesc Flow
 * * <b>This class is not exposed for construction by API users.</b>
 * A Flow is an abstract base class. A Flow represents a guaranteed message connection to the
 * Solace Message Router. There may be many Guaranteed Message
 * Consumers on a {@link solace.Session}, each
 * instantiated as a {@link solace.MessageConsumer}.
 * @memberof solace
 * @extends {solace.EventEmitter}
 * @private
 */
var Flow = (function (EventEmitter) {
  function Flow(flowProperties, sessionInterfaceFactory, emitterOptions) {
    var emitterOptionsFull = Object.assign({}, emitterOptions);
    emitterOptionsFull.emits = (emitterOptionsFull.emits || []).concat(
      PrivateFlowEventName.values
    );
    EventEmitter.call(this, emitterOptionsFull);
    var sessionInterface = sessionInterfaceFactory(this);
    var self = this;
    this.logger = new LogFormatter(function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return [("[session=" + (sessionInterface.sessionIdHex) + "]"), ("[flow=" + (self.flowIdDec) + "]") ].concat( args);
    });
    this.log = this.logger.wrap(this.log, this);
    this._disposed = false;
    this._userDisconnected = true;
    this._properties = flowProperties;
    this._sessionInterface = sessionInterface;
    this._stats = new Stats(sessionInterface);
    this._privateEventEmitter = new EventEmitter(emitterOptionsFull);
  }

  if ( EventEmitter ) Flow.__proto__ = EventEmitter;
  Flow.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Flow.prototype.constructor = Flow;

  var prototypeAccessors = { canAck: {},disposed: {},flowIdDec: {},flowId: {},session: {},userDisconnected: {} };

  // Private event emitter functions, hidden from the public interface.
  Flow.prototype._emit = function _emit (type) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    (ref = this._privateEventEmitter).emit.apply(ref, [ type ].concat( args ));
    (ref$1 = this).emit.apply(ref$1, [ type ].concat( args ));
    var ref;
    var ref$1;
  };
  Flow.prototype._on = function _on (type, listener) {
    this._privateEventEmitter.on(type, listener);
  };
  Flow.prototype._once = function _once (type, listener) {
    this._privateEventEmitter.once(type, listener);
  };
  Flow.prototype._removeListener = function _removeListener (type, listener) {
    this._privateEventEmitter.removeListener(type, listener);
  };

  /**
   * Clears all statistics for this Guaranteed Message Connection. All previous Guaranteed
   * Message Connection statistics are lost
   * when this is called.
   * @throws {solace.OperationError}
   *  * if the Message Consumer is disposed. subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  Flow.prototype.clearStats = function clearStats () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE('Clearing stats');
    this._operationCheck(FlowOperation.RESET_STATS);
    this._stats.resetStats();
  };

  /**
   * Establish a Guaranteed Messaging connection.
   * The Messge Consumer may immediately begin emitting events. The application is expected to
   * add listeners for events on this Message Consumer before calling this method.
   */
  Flow.prototype.connect = function connect () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Connecting');
    this.userDisconnected = false;
    this._operationCheck(FlowOperation.CONNECT);
  };

  /**
   * Disposes the Guaranteed Message connection, removing all listeners and releasing references.
   */
  Flow.prototype.dispose = function dispose () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;
    // The session may dispose the publisher or consumer, so be tolerant of
    // multiple attempts to do so.
    if (this._disposed) {
      LOG_TRACE('Ignoring #dispose on disposed Guaranteed Message connection');
      return;
    }
    LOG_TRACE('Disposing');

    this._operationCheck(FlowOperation.DISPOSE);

    this._properties = null;
    this._userDisconnected = true;
    this._disposed = true;
    var terminate = function () {
      this$1._emit(this$1.getDisposedEvent());
      this$1.disableEmitter();
      this$1._privateEventEmitter.disableEmitter();
      LOG_DEBUG('Disposed');
    };
    if (this._fsm.isRunning()) {
      // Guard this in a timeout
      var terminateWithRunningFSM = function () {
        this$1._fsm.terminateFsm();
        terminate();
      };
      try {
        // Attempt to terminate synchronously
        // May throw if called from an event dispatch
        terminateWithRunningFSM();
      } catch (e) {
        // Terminate asynchronously
        setImmediate(function () { return terminateWithRunningFSM(); });
      }
    } else {
      terminate();
    }
  };

  /**
   * Disconnects the Message Consumer in such a way that it can be reconnected.
   */
  Flow.prototype.disconnect = function disconnect () {
    this._operationCheck(FlowOperation.DISCONNECT);
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Disconnecting');
    this.userDisconnected = true;
  };

  /**
   *
   * Begins a disconnect that is not user-initiated.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
  Flow.prototype._disconnectSession = function _disconnectSession () {
    this._operationCheck(FlowOperation.DISCONNECT);
  };

  /**
   * Gets the event to be returned when the Consumer or Publisher is disposed.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
  Flow.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Abstract method');
  };

  /**
   * Creates and returns copy of the properties for this object.
   * @returns {?} The properties object
   * @internal
   */
  Flow.prototype.getProperties = function getProperties () {
    this._operationCheck(FlowOperation.GET_PROPERTIES);
    return this._properties.clone();
  };

  /**
   * Returns a statistic for this Guaranteed Message connection.
   *
   * @param {solace.StatType} statType The statistic to return.
   * @returns {Number} The value for the statistic.
   */
  Flow.prototype.getStat = function getStat (statType) {
    this._operationCheck(FlowOperation.GET_STATS);
    return this._stats.getStat(statType);
  };

  /**
   * @param {AdMessage} message The message to be handled by this Consumer or Publisher
   * @private
   */
  Flow.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Guaranteed Message Connection does not implement a control message handler', message);
  };

  /**
   * @param {StatType} statType The stat to increment
   * @param {Number} [value] The value to add to the statistic.
   * @private
   */
  Flow.prototype.incStat = function incStat (statType, value) {
    this._stats.incStat(statType, value);
  };

  /**
   * @param {any} event The event to be handled by this objects's FSM
   * @private
   */
  Flow.prototype.processFSMEvent = function processFSMEvent (event) {
    this._fsm.processEvent(event);
  };

  /**
   * @returns {String} An inspection of this object's properties
   * @private
   */
  Flow.prototype[util.inspect.custom] = function () {
    return {
      'flowId': this.flowIdDec,
    };
  };

  /**
   * @returns {String} A description of this Guaranteed Message Connection
   */
  Flow.prototype.toString = function toString () {
    return this.inspect();
  };

  /**
   * @returns {Boolean} Whether this Publisher or Consumer can be connected.
   * @readonly
   * @private
   */
  prototypeAccessors.canAck.get = function () {
    return !this.disposed;
  };

  /**
   * Returns true if this Guaranteed Message Consumer was disposed.
   */
  prototypeAccessors.disposed.get = function () {
    return this._disposed;
  };

  prototypeAccessors.flowIdDec.get = function () {
    return this.flowId || '(N/A)';
  };

  /**
   * @returns {Number} The ID for this flow
   * @readonly
   * @private
   */
  prototypeAccessors.flowId.get = function () { // eslint-disable-line class-methods-use-this
    return new NotImplementedError('Flow does not implement ID accessor');
  };

  /**
   * @returns {solace.Session} The owning session for this MessageConsumer.
   * @readonly
   */
  prototypeAccessors.session.get = function () {
    return this._session;
  };

  prototypeAccessors.userDisconnected.get = function () {
    return this._userDisconnecte;
  };
  prototypeAccessors.userDisconnected.set = function (value) {
    this._userDisconnected = value;
  };

  /**
   * @param {FlowOperation} operation The operation to check
   * @returns {Boolean} `true` if the operation is allowed.
   * @throws {@link solace.OperationError} if the operation is not allowed.
   * @private
   */
  Flow.prototype._operationCheck = function _operationCheck (operation) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE(("Checking operation " + (FlowOperation.describe(operation))));
    if (this._disposed) {
      throw new OperationError('Operation is invalid for Message Consumer in disposed state',
                               ErrorSubcode.INVALID_OPERATION);
    }

    // Any read-only operation is always valid unless the object was disposed
    // (which purges properties)
    if (ALWAYS_OPS.some(function (v) { return v === operation; })) { return true; }

    if (operation === FlowOperation.DISCONNECT && this._isDisconnected()) {
      throw new OperationError(
        'Operation is invalid for Message Consumer in disconnected state',
        ErrorSubcode.INVALID_OPERATION
      );
    }

    // TODO: additional validation
    // const fsmState = this._fsm.getCurrentState().getName();
    return undefined;
  };

  Flow.prototype._isDisconnected = function _isDisconnected () { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Flow#_isDisconnected not implemented');
  };

  Object.defineProperties( Flow.prototype, prototypeAccessors );

  return Flow;
}(EventEmitter));

module.exports.Flow = Flow;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

/**
 * @classdesc
 * This object type represents an entryPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the entryPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @extends FsmObject
 * @private
 */
var EntryPoint = (function (FsmObject) {
  function EntryPoint(spec) {
    FsmObject.call(this, { name: spec.entryPointName });

    var innerState;
    this.impl = this.impl || {};
    // The outer portion of the entryPoint accepts incoming transitions before
    // entering the entryPoint's state.  Then the entryPoint's state is
    // entered through the use of the outerEntryPoint's initial transition.
    this.impl.outerState = new StateLib.State({
      name:          ((spec.state.getName()) + " outerEntryPoint: " + (spec.entryPointName)),
      parentContext: spec.state.getParent(),
    }).initial(function () { return spec.state.transitionTo(innerState); });

    // The job of the inner portion of the entryPoint is to follow a
    // transition as specified by the application's reaction function.
    innerState = new StateLib.State({
      name:          ((spec.state.getName()) + " innerEntryPoint: " + (spec.entryPointName)),
      parentContext: spec.state,
    }).initial(spec.func);
  }

  if ( FsmObject ) EntryPoint.__proto__ = FsmObject;
  EntryPoint.prototype = Object.create( FsmObject && FsmObject.prototype );
  EntryPoint.prototype.constructor = EntryPoint;

  /**
   * @returns {fsm.State} The destination state for a transition to the
   *      EntryPoint.
   */
  EntryPoint.prototype.getDestState = function getDestState () {
    return this.impl.outerState;
  };

  return EntryPoint;
}(FsmObject));

module.exports.EntryPoint = EntryPoint;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

var FsmEvent = (function (FsmObject) {
	function FsmEvent () {
		FsmObject.apply(this, arguments);
	}if ( FsmObject ) FsmEvent.__proto__ = FsmObject;
	FsmEvent.prototype = Object.create( FsmObject && FsmObject.prototype );
	FsmEvent.prototype.constructor = FsmEvent;

	

	return FsmEvent;
}(FsmObject));

module.exports.FsmEvent = FsmEvent;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

/**
 * @classdesc
 * This object type represents an exitPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the exitPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @private
 */
var ExitPoint = (function (FsmObject) {
  function ExitPoint(spec) {
    FsmObject.call(this, { name: spec.exitPointName });

    var outerState;
    // The inner portion of the exitPoint accepts incoming transitions before
    // exiting the exitPoint's state.  Then the exitPoint's state is exited
    // through the use of the innerExitPoint's initial transition.
    this.impl.innerState = new StateLib.State({
      name:          ((spec.state.getName()) + " innerExitPoint: " + (spec.exitPointName)),
      parentContext: spec.state,
    }).initial(function () { return spec.state.transitionTo(outerState); });

        // The job of the outer portion of the exitPoint is to follow a
        // transition as specified by the application's reaction function.
    outerState = new StateLib.State({
      name:          ((spec.state.getName()) + " outerExitPoint: " + (spec.exitPointName)),
      parentContext: spec.state.getParent(),
    }).initial(spec.func);
  }

  if ( FsmObject ) ExitPoint.__proto__ = FsmObject;
  ExitPoint.prototype = Object.create( FsmObject && FsmObject.prototype );
  ExitPoint.prototype.constructor = ExitPoint;

  ExitPoint.prototype.getDestState = function getDestState () {
    return this.impl.innerState;
  };

  return ExitPoint;
}(FsmObject));

module.exports.ExitPoint = ExitPoint;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(27);
var State = ref$1.State;
var ref$2 = __webpack_require__(96);
var StateContext = ref$2.StateContext;

/**
 * @classdesc
 * This is a state machine that can host states.  States themselves can also
 * host inner states in a hierarchical manner.  This class also provides the
 * basic interface for manipulating the current state via processing of
 * events, and querying the current state through 'getActiveState' methods.
 *
 * @private
 * @memberof solace
 */
var StateMachine = (function (StateContext) {
  function StateMachine(spec) {
    var this$1 = this;

    if (spec.parentContext) {
      throw new Error(("State machine cannot have parent state: " + (spec.parentContext)));
    }
    StateContext.call(this, spec);
    this.impl.ancestorList = [this];
    this.impl.eventQueue = [];
    this.impl.finalState = new State({ name: 'impl.final', parentContext: this });
    this.impl.handleUncaughtException = function (ev, exc) {
      LOG_ERROR(("Uncaught exception in " + (this$1) + " while processing " + ev + ": " + (exc.stack)));
      return this$1.terminate();
    };
  }

  if ( StateContext ) StateMachine.__proto__ = StateContext;
  StateMachine.prototype = Object.create( StateContext && StateContext.prototype );
  StateMachine.prototype.constructor = StateMachine;

  /**
   * This method enqueues the given function, and begins execution of queued functions if
   * they aren't already executing.
   * @param {Function} func The function to enqueue and execute.
   * @returns {Boolean} `true` if the supplied function has completed; false if it was deferred.
   */
  StateMachine.prototype.process = function process (func) {
    var this$1 = this;

    var ref = this;
    var impl = ref.impl;
    var eventQueue = impl.eventQueue;

    eventQueue.push(func);
    if (impl.processingEvents) {
      return false;
    }
    impl.processingEvents = true;

    while (eventQueue.length) {
      var evt = eventQueue.shift();
      evt.apply(this$1);
    }

    impl.processingEvents = false;
    this._onEventCompletion();
    return true;
  };

  /**
   * This method starts a state machine after it has been created and states
   * have been associated and configured any time getCurrentState() returns
   * undefined.  This would be after initial creation and after the state
   * machine has terminated (i.e. transitioned to the final state).
   */
  StateMachine.prototype.start = function start () {
    var this$1 = this;

    if (this.getCurrentState()) {
      throw new Error(("Cannot start " + (this.getName()) + "; it is already started."));
    }

    this.process(function () {
      var result = this$1.onInitial();

      // A state machine's onInitial must specify a destState, the state
      // cannot be the state machine itself, and the state must have the
      // state machine as the top ancestor.
      if (result.destState === undefined) {
        throw new Error(("Missing destination state from initial transition for " + (this$1)));
      }

      if (result.destState === this$1) {
        throw new Error(("Destination state for initial transition for " + (this$1) + " cannot be the FSM."));
      }

      var destAncestorList = result.destState.getAncestorList();
      if (destAncestorList[0] !== this$1) {
        throw new Error(("Invalid destination state (" + (result.destState) + ") from initial transition for state machine (" + (this$1) + "); destState ancestor (" + (destAncestorList[0]) + ")"));
      }

      this$1.impl.currentState = this$1.processReactionResult(result);
    });
  };

  /**
   * Used to query whether the state machine is currently running
   * @returns {Boolean} `true` if the state machine is processing events; false otherwise.
   */
  StateMachine.prototype.isRunning = function isRunning () {
    return this.impl.processingEvents;
  };

  /**
   * This is the main function to invoke an FSM with an event.
   * @param {FsmEvent} evt The event to be processed by the FSM.
   */
  StateMachine.prototype.processEvent = function processEvent (evt) {
    var this$1 = this;

    var ref = this;
    var impl = ref.impl;
    if (!this.process(function () {
      this$1.log(("Processing event " + evt));
      var result;
      if (impl.currentState) {
        try {
          result = impl.currentState.handleEvent(evt);
          impl.currentState = impl.currentState.processReactionResult(result, evt);
        } catch (exc) {
          this$1.log(("Caught exception " + exc + ", continuing"));
          result = impl.handleUncaughtException.call(impl.currentState,
                                                     evt,
                                                     exc);
          impl.currentState = impl.currentState.processReactionResult(result, evt);
        }
      }
    })) {
      // Didn't run immediately
      this.log(("Deferring event " + evt));
    }
  };

  /**
   * Terminates the FSM by transitioning the FSM to its final state. After
   * this returns, the FSM may be started again with @link start.  This method
   * should only be called externally from the FSM, not from within a reaction.
   * To terminate the FSM within a reaction, use the
   * {@link StateContext.ReactionResult} returned by {@link State#terminate}.
   */
  StateMachine.prototype.terminateFsm = function terminateFsm () {
    var this$1 = this;

    var curState = this.getCurrentState();
    if (!curState) {
      return;
    }
    if (this.impl.processingEvents) {
      throw new Error('Cannot terminate state machine while FSM is processing ' +
            'events. To terminate the FSM from within a reaction, return ' +
            'State~terminate() from a reaction.');
    }
    this.process(function () {
      var result = curState.terminate();
      this$1.impl.currentState = curState.processReactionResult(result);
    });
  };

  /**
   * This should only be called from within the context of a reaction
   * function, which is to say a function called by the FSM infrastructure
   * that returns {@link StateContext~ReactionResult}.  The purpose of this
   * function is to set a function to be called after the currently
   * executing event is completely handled, which includes the execution of
   * any events that have been or will be queued as a result of processing
   * the current event.
   *
   * Typical uses of this would be to set a function that does one of:
   * 1. Throws an exception to the caller.
   * 2. Calls an application callback.
   * @param {Function} postEventAction function to call when the FSM has finished
   *  processing events.  The context (i.e. 'this') will be the FSM when it
   *  is called.
   */
  StateMachine.prototype.setPostEventAction = function setPostEventAction (postEventAction) {
    if (!this.impl.processingEvents) {
      throw new Error('Cannot set post event hook unless FSM is processing events.');
    }
    if (!postEventAction || typeof postEventAction !== 'function') {
      // TBD: Do we need to allow clearing of the hook?  Not that
      // I'm aware of for the known use cases.  If we want to allow
      // it, I propose adding a 'clearPostEventAction' rather than
      // allowing null or undefined as the argument.
      throw new Error(("postEventAction must be a function; got (" + postEventAction + ")"));
    }
    this.impl.postEventAction = postEventAction.bind(this);
  };

  /**
   * Called by the FSM when it finishes processing events.  If a
   * postEventAction had been set, it will be called, then cleared.
   * @private
   */
  StateMachine.prototype._onEventCompletion = function _onEventCompletion () {
    var action = this.impl.postEventAction;
    if (action) {
      this.impl.postEventAction = undefined;
      this.log('Running post event action');
      action.apply(this);
    }
  };

  /**
   * Returns the innermost active state.
   *
   * If regions were implemented, this would return an iterator to innermost
   * active states.
   *
   * @returns {StateContext} The innermost active state.
   */
  StateMachine.prototype.getCurrentState = function getCurrentState () {
    return this.impl.currentState;
  };

  /**
   * Gets an active state by name.  Returns undefined if the named state is
   * not currently active.
   *
   * Note the returned state may not be the innermost state as returned by
   * {@link StateMachine#getCurrentState}.  If the innermost active state is not
   * returned, the returned state is guaranteed to contain the innermost active
   * state.
   *
   * @param {String} name The name of the state to be retrieved.
   * @returns {?StateContext} The state with the specified name, if the
   *      state is active; undefined otherwise.  Note the returned state may not
   *      be the innermost active state.
   */
  StateMachine.prototype.getActiveState = function getActiveState (name) {
    var activeStates = this.impl.currentState.getAncestorList();
    // Don't include the first ancestor in the loop since it is the state
    // machine itself, not a state.
    for (var i = 1; i < activeStates.length; ++i) {
      if (activeStates[i].getName() === name) {
        return activeStates[i];
      }
    }
    return undefined;
  };

  /**
   * Checks if the named state is currently active.
   * @param {String} name The name of the state to be queried.
   * @returns {Boolean} Whether or not the named state is active.
   */
  StateMachine.prototype.isStateActive = function isStateActive (name) {
    return this.getActiveState(name) !== undefined;
  };

  /**
   * Allows a reaction to be registered for unhandled events in the FSM.  The
   * default reaction is to log the unhandled event at debug and remain in the
   * current state with no other side effects.
   * @param {StateContext.reactionCallback} r The reaction to be invoked when an
   *      event is unhandled by the FSM.
   * @returns {StateMachine} This StateMachine object.
   */
  StateMachine.prototype.unhandledEventReaction = function unhandledEventReaction (r) {
    if (typeof r !== 'function') {
      throw new Error(("In " + (this) + ": unhandled event reaction must be a function; got " + r));
    }
    this.impl.handleUnhandledEvent = r.bind(this);
    return this;
  };

  /**
   * This allows a reaction to be registered for uncaught exceptions while
   * processing events.  Generally, it is preferred to catch exceptions from
   * within reaction functions.  However, this is a good way to safeguard
   * against missed exceptions.  Usually an error should be logged here,
   * which is the default behaviour.
   *
   * Also note that this is only called for either:
   * - an exception thrown from an event reaction;
   * - an exception thrown from a transition action
   * If exceptions are thrown from within state entry, exit, initials, etc,
   * this function is not invoked.  These functions may end up getting
   * invoked from the transition taken as a result of the exception in the
   * first place.  The generate another exception would be difficult to
   * handle in a sensible way.  Users of this infrastructure must always
   * catch exceptions from these functions.
   *
   * @param {fsm.StateContext.reactionCallback} r The reaction to be
   *      invoked when an exception has not been caught by another of the
   *      FSM's reactionCallbacks.  When this function is invoked, 'this'
   *      will be the FSM's current state.
   * @returns {StateMachine} `this`, for method chaining.
   */
  StateMachine.prototype.uncaughtExceptionReaction = function uncaughtExceptionReaction (r) {
    if (typeof r !== 'function') {
      throw new Error(("In " + (this) + ": Uncaught exception reaction must be a function; got " + r));
    }
    this.impl.handleUncaughtException = r;
    return this;
  };

  /**
   * Used by the implementation to get the final state.  This should never be
   * used by applications.  Their only need to reference this state should be
   * indirectly via the {@link State#terminate} function.
   * @returns {State} The FSM's final state, which is a hidden implementation
   *      detail of the FSM.
   * @protected
   */
  StateMachine.prototype.getFinalState = function getFinalState () {
    return this.impl.finalState;
  };

  return StateMachine;
}(StateContext));

module.exports.StateMachine = StateMachine;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(97);
var LogImpl = ref.LogImpl;

var STUB = function () { return undefined; };

function generateLogHeader(levelStr) {
  var date = new Date();
  var levelStrPadding = ' '.repeat(6 - levelStr.length);
  var YY = String(date.getFullYear());
  var MM = String(date.getMonth() + 1);
  var DD = String(date.getDate());
  var hh = String(date.getHours());
  var mm = String(date.getMinutes());
  var ss = String(date.getSeconds());
  var ms = String(date.getMilliseconds());

  YY = '0'.repeat(4 - YY.length) + YY;
  MM = MM.length < 2 ? ("0" + MM) : MM;
  DD = DD.length < 2 ? ("0" + DD) : DD;
  hh = hh.length < 2 ? ("0" + hh) : hh;
  mm = mm.length < 2 ? ("0" + mm) : mm;
  ss = ss.length < 2 ? ("0" + ss) : ss;
  ms = ms.length < 3 ? ("0" + ms) : ms;
  ms = ms.length < 3 ? ("0" + ms) : ms; // twice: pad to 3

  return [(YY + "-" + MM + "-" + DD + " " + hh + ":" + mm + ":" + ss + "." + ms), ("" + levelStr + levelStrPadding)];
}

/**
 * @classdesc
 * A log implementation that uses the global or window console.
 *
 * This is the default log implementation used by the API if no logger was
 * supplied via {@link solace.SolclientFactoryProperties}.
 *
 * @memberof solace
 * @private
 */
var ConsoleLogImpl = (function (LogImpl) {
  function ConsoleLogImpl(consoleIn) {
    /**
     * Logs the given arguments at TRACE level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#trace
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _trace = STUB;

    /**
     * Logs the given arguments at DEBUG level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#debug
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _debug = STUB;

    /**
     * Logs the given arguments at INFO level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#info
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _info = STUB;

    /**
     * Logs the given arguments at WARN level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.warn
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#warn
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _warn = STUB;


    /**
     * Logs the given arguments at ERROR level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#error
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _error = STUB;

    /**
     * Logs the given arguments at FATAL level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#fatal
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _fatal = STUB;

    var console = consoleIn || (
      typeof window === 'undefined'
        /* eslint-env node */ ? global
        /* eslint-env browser */ : window
      ).console;
    /* eslint-env shared-node-browser */

    if (console && (console.log || console.warn)) {
      /* eslint-disable no-console */
      // Where console.log is supported, it is preferred over console.debug
      // https://developer.mozilla.org/en-US/docs/DOM/console
      // console methods in IE9 are object, not function, unfortunately
      //
      // Also, console.trace outputs a stack trace on some platforms.  So we
      // use the same underlying logger as debug for trace to avoid the
      // excessive verbosity that would result.
      if (console.log && console.log !== undefined) {
        _trace = Function.prototype.bind.call(console.log, console);
        _debug = Function.prototype.bind.call(console.log, console);
      } else if (console.debug && typeof console.debug === 'function') {
        _trace = Function.prototype.bind.call(console.debug, console);
        _debug = Function.prototype.bind.call(console.debug, console);
      }

      // Where console.info exists, it is preferred. Otherwise, fall back to
      // console.log.
      if (console.info && console.info !== undefined) {
        _info = Function.prototype.bind.call(console.info, console);
      } else {
        _info = Function.prototype.bind.call(console.log, console);
      }

      // Where console.warn exists, it is preferred. Otherwise, fall back to
      // console.log.
      if (console.warn && console.warn !== undefined) {
        _warn = Function.prototype.bind.call(console.warn, console);
      } else {
        _warn = Function.prototype.bind.call(console.log, console);
      }

      // Where console.error exists, it is preferred. Otherwise, fall back to
      // console.log.
      //
      // console.fatal is not present in any known console implementation. Use
      // console.error or console.log.
      if (console.error && console.error !== undefined) {
        _error = Function.prototype.bind.call(console.error, console);
        _fatal = Function.prototype.bind.call(console.error, console);
      } else {
        _error = Function.prototype.bind.call(console.log, console);
        _fatal = Function.prototype.bind.call(console.log, console);
      }

      /* eslint-enable no-console */
    } // else no console implementation was found, so the default (stub) is used for each level.

    LogImpl.call(this, function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 _trace.apply(void 0, generateLogHeader('TRACE').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _debug.apply(void 0, generateLogHeader('DEBUG').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _info.apply(void 0, generateLogHeader('INFO').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _warn.apply(void 0, generateLogHeader('WARN').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _error.apply(void 0, generateLogHeader('ERROR').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _fatal.apply(void 0, generateLogHeader('FATAL').concat( args )); });
  }

  if ( LogImpl ) ConsoleLogImpl.__proto__ = LogImpl;
  ConsoleLogImpl.prototype = Object.create( LogImpl && LogImpl.prototype );
  ConsoleLogImpl.prototype.constructor = ConsoleLogImpl;

  return ConsoleLogImpl;
}(LogImpl));

module.exports.ConsoleLogImpl = ConsoleLogImpl;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(98);
var LogLevel = ref.LogLevel;

var state = {
  impl:  null,
  level: LogLevel.INFO,
};

var LogBinding = {
  getImpl: function getImpl() {
    return state.impl;
  },

  setImpl: function setImpl(impl) {
    state.impl = impl;
  },

  getLogLevel: function getLogLevel() {
    return state.level;
  },

  setLogLevel: function setLogLevel(level) {
    state.level = level;
  },
};

module.exports.GlobalBinding = LogBinding;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;
var assert = ref.assert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;

/**
 * @private
 */
var ApplicationAckState = Enum.new({
  UNACKED:        'UNACKED',
  ACKED_NOT_SENT: 'ACKED_NOT_SENT',
  ACKED_SENT:     'ACKED_SENT',
});

// For the ring buffer update index, we have two key-value options:
//  Map() - generally faster where supported
//  Object - seems to automatically coerce keys to string, which is what we want in this case
// By using Map and explicly creating a .key attribute and using it whenever possible,
// we should get performance that is no worse than Object, which may have to perform that
// coercion more often.

/**
 * @private
 */
var ApplicationAck = function ApplicationAck(id, state) {
  if (id) {
    this.exists = true;
    this.id = id;
    this.key = id.toString();
    this.state = state || ApplicationAckState.UNACKED;
  } else {
    this.exists = false;
  }
};

ApplicationAck.prototype.set = function set (id, state) {
  this.exists = true;
  this.id = id;
  this.key = id.toString();
  this.state = state || ApplicationAckState.UNACKED;
};

ApplicationAck.prototype.clear = function clear () {
  this.exists = false;
  this.id = null;
  this.key = null;
  this.state = null;
};

/**
 * @private
 */
var ApplicationAckRingBuffer = function ApplicationAckRingBuffer(size) {
  LOG_DEBUG('Creating application ack ring buffer with size ', size, ' retained size', size - 1);
  assert(size >= 2); // one always free doesn't work with < 2 elements
  this._size = size;
  this._insertIndex = 0;
  /**
   * @property {Array.<?ApplicationAck>}
   */
  this._buffer = Array(size).fill(null).map(function () { return new ApplicationAck(); });
  /**
   * @property {Map.<String, Number>}
   */
  this._index = new Map();
};

var prototypeAccessors = { length: {} };

/**
 * @param {Long} id The id of the new entry
 * @param {function(ApplicationAck)} beforeEvictCallback Call this before operation completes
 * @returns {any} Return value of beforeEvictCallback
 * @private
 */
ApplicationAckRingBuffer.prototype.insert = function insert (id, beforeEvictCallback) {
  assert(beforeEvictCallback);
  assert(id);

  var size = this._size;
  var buffer = this._buffer;
  var index = this._index;
  var insertIndex = this._insertIndex;

  /*
   * Because of the postprocessing step, we are not re-entrant safe. It is expected
   * that we are called from TCP -> Transport -> Session -> acceptMessage().
   * This assert verifies that the postprocess cleanup has happened.
   */
  assert(!buffer[insertIndex].exists, 'Invariant not enforced (before): insert index not empty');

  // First, insert.
  var inserting = buffer[insertIndex];
  inserting.set(id, ApplicationAckState.UNACKED);
  index.set(inserting.key, insertIndex);

  var evictingIndex = (insertIndex + 1) % size;
  var evicting = buffer[evictingIndex];
  var result;
  try {
    result = beforeEvictCallback(evicting.exists ? evicting : null);
  } finally {
    // Always clean up to keep the RB in a consistent state.
    // If inProgressCallback threw, this runs before the exception propagates.

    // Update insert index for next operation.
    this._insertIndex = (insertIndex + 1) % size;

    if (evicting.exists) {
      index.delete(evicting.key);
      evicting.clear();
    }
  }

  assert(!buffer[this._insertIndex].exists, 'Invariant not enforced (after): insert index not empty');
  return result;
};

/**
 * Returns the number of elements in this ringbuffer. Will increase to
 * one less than the size provided to the constructor as the buffer is used.
 *
 * @readonly
 * @memberof ApplicationAckRingBuffer
 */
prototypeAccessors.length.get = function () {
  return this._index.size;
};

/**
 * Returns the first element in the ring buffer.
 *
 * This could be called from the evict callback, so insert needs to be sure
 * that internal state is correct for that scenario.
 *
 * The expected case is that the first element is at insertIndex + 1, but if the
 * buffer has not been filled yet, we will iterate the buffer and skip nonexistent
 * elements to find it.
 *
 * This is a little inefficient until we have received this._size messages, but after
 * that it is more efficient than maintaining a read pointer.
 *
 * @returns {?ApplicationAck} The first ack in the buffer.
 */
ApplicationAckRingBuffer.prototype.front = function front () {
  if (this.length === 0) { return null; }

  var buffer = this._buffer;
  var insertIndex = this._insertIndex;
  var size = this._size;
  var firstIndex = (insertIndex + 1) % size;
  // Cannot assert invariant here: insert is usually in progress.

  // Buffer full case
  if (buffer[firstIndex].exists) { return buffer[firstIndex]; }

  // Not yet filled case
  // The last checked element for the iteration is the start point,
  //plus size, a full lap including the start index,
  //minus 1, to exclude the start
  //minus 1, to exclude the invariant null entry
  for (var rawIndex = firstIndex, lastIndex = firstIndex + size - 1;
       rawIndex <= lastIndex;
       ++rawIndex) {
    var readIndex = rawIndex % size;
    var element = buffer[readIndex];
    if (element.exists) {
      return element;
    }
  }

  // Buffer is completely empty
  assert(this._index.size === 0, '#front() failed so buffer must be empty');
  return null;
};

/**
 * Rather than implementing the iterator protocol, which requires Symbol support,
 * we'll implement a forEach that behaves as though this is an array.
 *
 * @param {function(ApplicationAppState, index, collection)} callback The iteration callback
 */
ApplicationAckRingBuffer.prototype.forEach = function forEach (callback) {
    var this$1 = this;

  if (this.length === 0) { return; }

  var buffer = this._buffer;
  var size = this._size;
  var index = 0;

  for (var rawIndex = this._insertIndex + 1, lastIndex = this._insertIndex + size;
       rawIndex <= lastIndex;
       ++rawIndex) {
    var readIndex = rawIndex % size;
    var element = buffer[readIndex];
    if (element.exists) {
      callback(element, index++, this$1);
    }
  }

  assert(index > 0, 'Not empty but did not dispatch');
};

/**
 * @param {Long} id The ID to update
 * @param {ApplicationAckState} state The new state for the ID
 * @private
 */
ApplicationAckRingBuffer.prototype.updateAckState = function updateAckState (id, state) {
  var key = id.toString(); assert(this._index.has(key), 'Ack key not found');
  var buffer = this._buffer;
  var updateIndex = this._index.get(key);
  var existing = buffer[updateIndex]; assert(existing, 'Ack key has no entry');
  existing.state = state;
};

/**
 * @param {Long} id The ID to look up
 * @returns {Boolean} `true` if this ID exists in the ringbuffer
 */
ApplicationAckRingBuffer.prototype.has = function has (id) {
  var key = id.toString();
  return this._index.has(key);
};

Object.defineProperties( ApplicationAckRingBuffer.prototype, prototypeAccessors );

Object.assign(module.exports, {
  ApplicationAckState: ApplicationAckState,
  ApplicationAck: ApplicationAck,
  ApplicationAckRingBuffer: ApplicationAckRingBuffer,
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(101);
var MessageConsumer = ref$1.MessageConsumer;
var ref$2 = __webpack_require__(28);
var MessageConsumerEventName = ref$2.MessageConsumerEventName;

var ConsumerFlows = function ConsumerFlows() {
  this._allFlows = new Set();
  // Flows by id (UP)
  this._flowsById = {};
};

var prototypeAccessors = { flows: {} };

ConsumerFlows.prototype.add = function add (flow) {
    var this$1 = this;

  assert(flow instanceof MessageConsumer, 'Flow was not a consumer');
  if (this._allFlows.has(flow)) {
    return flow;
  }

  var flowUp = function () {
    // Don't worry about flow collisions -- the router assigned the new flow to the same ID
    // so it won't address the old flow. Retain the old flow in _allFlows and make sure we
    // dispose the right flow.
    this$1._flowsById[flow.flowId] = flow;
  };
  var flowDisposed = function () {
    var flowId = flow.flowId;
    this$1._allFlows.delete(flow);
    var flowById = this$1._flowsById[flowId];
    // If this test fails, the router reassigned the flow ID, and we were only keeping the
    // _allFlows set reference for blanket cleanup.
    if (flowById === flow) {
      delete this$1._flowsById[flowId];
    }
    // Flow will be disposed and this will happen automatically
  };

  flow._on(MessageConsumerEventName.UP, flowUp);
  flow._on(MessageConsumerEventName.DISPOSED, flowDisposed);

  this._allFlows.add(flow);
  return flow;
};

prototypeAccessors.flows.get = function () {
  return Array.from(this._allFlows);
};

ConsumerFlows.prototype.getFlowById = function getFlowById (flowId) {
  return this._flowsById[flowId];
};

ConsumerFlows.prototype.disposeAll = function disposeAll () {
  this._allFlows.forEach(function (flow) { return flow.dispose(); });
};

Object.defineProperties( ConsumerFlows.prototype, prototypeAccessors );

module.exports.ConsumerFlows = ConsumerFlows;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(184);
var ApplicationAck = ref.ApplicationAck;
var ApplicationAckRingBuffer = ref.ApplicationAckRingBuffer;
var ApplicationAckState = ref.ApplicationAckState;
var ref$1 = __webpack_require__(0);
var assert = ref$1.assert;
var ref$2 = __webpack_require__(21);
var CapabilityType = ref$2.CapabilityType;
var ref$3 = __webpack_require__(54);
var ConsumerFSMEvent = ref$3.ConsumerFSMEvent;
var ref$4 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$4.ConsumerFSMEventNames;
var ref$5 = __webpack_require__(187);
var ConsumerStateNames = ref$5.ConsumerStateNames;
var ref$6 = __webpack_require__(5);
var DestinationFromNetwork = ref$6.DestinationFromNetwork;
var DestinationType = ref$6.DestinationType;
var Queue = ref$6.Queue;
var Topic = ref$6.Topic;
var ref$7 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$7.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$7.ErrorSubcode;
var OperationError = ref$7.OperationError;
var ref$8 = __webpack_require__(1);
var LogFormatter = ref$8.LogFormatter;
var ref$9 = __webpack_require__(3);
var Long = ref$9.Long;
var ref$10 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$10.MessageConsumerAcknowledgeMode;
var ref$11 = __webpack_require__(28);
var MessageConsumerEventName = ref$11.MessageConsumerEventName;
var ref$12 = __webpack_require__(189);
var MessageDispatcher = ref$12.MessageDispatcher;
var ref$13 = __webpack_require__(36);
var PrivateFlowEventName = ref$13.PrivateFlowEventName;
var ref$14 = __webpack_require__(18);
var QueueAccessType = ref$14.QueueAccessType;
var QueueDescriptor = ref$14.QueueDescriptor;
var QueueType = ref$14.QueueType;
var ref$15 = __webpack_require__(15);
var State = ref$15.State;
var StateMachine = ref$15.StateMachine;
var ref$16 = __webpack_require__(19);
var Stats = ref$16.Stats;
var ref$17 = __webpack_require__(19);
var StatType = ref$17.StatType;
var ref$18 = __webpack_require__(35);
var Timer = ref$18.Timer;
var ref$19 = __webpack_require__(190);
var TransportAcks = ref$19.TransportAcks;
var TransportAckResult = ref$19.TransportAckResult;

var RING_BUFFER_SIZE = 512;
var ZERO_APP_ACK = new ApplicationAck(Long.UZERO, ApplicationAckState.ACKED_SENT);

var ConsumerFSM = (function (StateMachine) {
  function ConsumerFSM(ref) {
    var this$1 = this;
    if ( ref === void 0 ) ref = {};
    var name = ref.name;
    var consumer = ref.consumer;
    var sessionInterface = ref.sessionInterface;
    var properties = ref.properties;

    StateMachine.call(this, { name: name });

    var fsm = this;
    var formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        ("[session=" + (sessionInterface.sessionIdHex) + "]"),
        ("[message-consumer-fsm=" + (consumer.flowIdDec) + "]") ].concat( args );
    };
    var logger = this.logger = new LogFormatter(formatter);
    var LOG_TRACE = logger.LOG_TRACE;
    var LOG_DEBUG = logger.LOG_DEBUG;
    var LOG_INFO = logger.LOG_INFO;
    var LOG_WARN = logger.LOG_WARN;
    var LOG_ERROR = logger.LOG_ERROR;
    this.log = logger.wrap(this.log, this);

    var autoAck = properties.acknowledgeMode === MessageConsumerAcknowledgeMode.AUTO;

    this._consumer = consumer;
    this._sessionInterface = sessionInterface;

    this._acknowledgeTimeoutInMsecs = properties.acknowledgeTimeoutInMsecs;
    this._acknowledgeThreshold = properties.acknowledgeThreshold;

    this._bindTimeoutInMsecs = properties.connectTimeoutInMsecs;

    this._localPreferredWindowSize = properties.windowSize;
    this._localMaxWindowSize = properties.windowSize;

    this._messageDispatch = new MessageDispatcher({ emitter: consumer, autoAck: autoAck, logger: logger });

    this._stats = new Stats();

    this._resetRemoteConnectionState();
    this._resetLocalConnectionState();

    //**********************************************************************************************
    // A bit of infrastructure around post-event actions, which includes maintaining a queue of
    // pending actions, and some logic to pre-process the actions before performing them.

    // These should not be the same as any MessageConsumerEventName value or they will collide in
    // the actionLocations object during event pre-processing.
    var emitEventActionType = 'EMIT';
    var startDispatchActionType = 'DISPATCH';
    var stopDispatchActionType = 'NO_DISPATCH';

    var postEventActions = [];
    function preprocessPostEventActions(startIndex) {
      // first pre-process post event actions.  This isn't an exhaustive search of every possible
      // combination of event sequences, as many are practically impossible, and therefore
      // impossible to test.  We only handle sequences that are known to be possible.  If there
      // are other sequences that need to be considered, we can add processing for them when we
      // know they are possible.
      LOG_TRACE(("Pre-processing post event action list @" + startIndex), postEventActions);
      var actionLocations = {};
      postEventActions.forEach(function (action, i, arr) {
        function cancelAction(firstActionName, cancellingActionName) {
          if (actionLocations[firstActionName] === undefined) {
            return;
          }
          var firstLocation = actionLocations[firstActionName];
          LOG_TRACE(("Cancelling post event action " + firstActionName + "@" + firstLocation + " with " + cancellingActionName + "@" + i));
          actionLocations[firstActionName] = undefined;
          arr[firstLocation] = null;
          arr[i] = null;
        }
        if ((i < startIndex) || (!action)) {
          LOG_TRACE(("Skip n/a action@" + i + ", start: " + startIndex + ", action:"), action);
          return;
        }
        switch (action.type) {
          case emitEventActionType:
            switch (action.data) {
              case MessageConsumerEventName.UP:
              case MessageConsumerEventName.ACTIVE:
                actionLocations[action.data] = i;
                break;

              case MessageConsumerEventName.DOWN:
              case MessageConsumerEventName.DOWN_ERROR:
                cancelAction(MessageConsumerEventName.UP, action.data);
                break;

              case MessageConsumerEventName.INACTIVE:
                cancelAction(MessageConsumerEventName.ACTIVE, action.data);
                break;

              default:
                LOG_ERROR(("Unexpected event in post-event action: " + (action.data)));
                break;
            }
            break;

          case startDispatchActionType:
            actionLocations[action.type] = i;
            break;

          case stopDispatchActionType:
            cancelAction(startDispatchActionType, action.type);
            break;

          default:
            break;
        }
      });
    }

    function processPostEventActions() {
      var this$1 = this;

      var preprocessedActions = 0;
      var i;

      // Now we've pre-processed the list, execute any remaining non-null entries.  We don't use a
      // foreach loop since foreach won't include elements added after processing has started.  This
      // can occur if a callback causes more postEventActions to be added.
      LOG_TRACE('Executing post event action list', postEventActions);
      for (i = 0; i < postEventActions.length; ++i) {
        if (preprocessedActions < postEventActions.length) {
          preprocessPostEventActions(i);
          preprocessedActions = postEventActions.length;
        }
        var action = postEventActions[i];
        LOG_TRACE(("Action " + i + ":"), action);
        if (!action) {
          continue;
        }
        switch (action.type) {
          case emitEventActionType:
            consumer._emit(action.data);
            break;

          case stopDispatchActionType:
            // We don't actually do the stop here -- it is always done when this is enqueued.
            // The reason for enqueuing this event is to that it can cencel a startDispatch, if
            // present.
            break;

          case startDispatchActionType:
            this$1.requestStartDispatchFSM();
            break;

          default:
            LOG_ERROR(("Unhandled post event action type: " + (action.type)));
            break;
        }
      }
      postEventActions = [];
    }

    function addPostEventAction(type, data) {
      var newEvent;
      if (data !== undefined) {
        newEvent = { type: type, data: data };
      } else {
        newEvent = { type: type };
      }
      postEventActions.push(newEvent);
      LOG_TRACE(("Added post event action " + (postEventActions.length) + ":"), newEvent);
      if (postEventActions.length === 1) {
        fsm.setPostEventAction(processPostEventActions);
      }
    }

    var addEventToEmit = function (event) {
      if (!properties.activeIndicationEnabled) {
        if ((event === MessageConsumerEventName.INACTIVE) ||
            (event === MessageConsumerEventName.ACTIVE)) {
          LOG_TRACE(("Skip emitting " + event + " due to disabled flow active indications"));
          return;
        }
      }
      addPostEventAction(emitEventActionType, event);
    };
    var requestStartDispatch = function () {
      addPostEventAction(startDispatchActionType);
    };
    var requestStopDispatch = function () {
      // We do the stop inline, then add a post-event action so that it can have the effect of
      // cancelling a previous start.  It will not execute the stop when processed however since we
      // have already done it here.
      this$1.requestStopDispatchFSM();
      addPostEventAction(stopDispatchActionType);
    };

    this._addEventToEmit = addEventToEmit;
    this._requestStartDispatch = requestStartDispatch;
    this._requestStopDispatch = requestStopDispatch;

    // End of post-event action infrastructure
    //**********************************************************************************************

    // FSM config
    this.unhandledEventReaction(function onUnhandledEvent(event) {
      switch (event.getName()) {
        case ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED:
          LOG_INFO('VirtualRouter name change: clearing all acknowledgement state');
          fsm._resetRemoteConnectionState();
          return this;
        case ConsumerFSMEventNames.FLOW_UNBOUND:
          LOG_INFO('Received unsolicited unbind. Flow may be manually reconnected.');
          return this.transitionToUnbound(MessageConsumerEventName.DOWN_ERROR);
        case ConsumerFSMEventNames.DISPOSE:
          fsm._dispose();
          return fsm.getCurrentState().terminate();
        default:
          LOG_TRACE(("Ignoring event " + (event.getName()) + " in state " + (this.getCurrentState().getName())));
          return this;
      }
    });

    this.initial(function onInitial() {
      return this.transitionTo(fsm.Unbound, function (context) {
        LOG_DEBUG(("Starting " + (context.getStateMachine().getName())));
      });
    });

    /*
      We don't transition directly from Unbound to BindSent.
      We need the following events:
       * FLOW_OPEN
       * SESSION_UP
      (The session ensures we get SESSION_UP or SESSION_UP_NO_AD if we are created
      and there is a session already up.)
      The Unbound base state implements transitions to its wait state children:
       * FLOW_OPEN -> AwaitSessionUp
       * SESSION_UP -> AwaitFlowOpen
      It also has the following transitions that pull the FSM out of its children
      and back to itself:
       * FLOW_CLOSE
       * SESSION_DOWN
      The child states can override these with internal transitions.
     */
    this.Unbound = new State({
      name:          ConsumerStateNames.UNBOUND,
      parentContext: fsm,
    }, {
      emitDisabledEvent: function emitDisabledEvent() {
        consumer._emit(MessageConsumerEventName.GM_DISABLED);
      },
    })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSesssionDisconnect() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp); // Enter child state
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
        var this$1 = this;

        if (fsm._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
          return this.transitionTo(fsm.Unbound.AwaitFlowOpen); // Enter child state
        }
        LOG_WARN(("Consumer is not supported by router for this client on sessionId 0x" + (fsm._sessionInterface.sessionIdHex)));
        // Act as if the child state handled this
        return this.internalTransition(function () { return this$1.emitDisabledEvent(); });
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP_NO_AD, function onSessionUpNoAD() {
        var this$1 = this;

        // Act as if the child state handled this
        return this.internalTransition(function () { return this$1.emitDisabledEvent(); });
      })
      .exit(function () {
        fsm.bindRetryCount = properties.bindRetryCount;
      });

    /*
      In this state, we have received FLOW_OPEN, but no SESSION_UP.
      SESSION_DOWN does not cancel this wait, so we must override the
      parent and explicitly do nothing.
    */
    this.Unbound.AwaitSessionUp = new State({
      name:          ConsumerStateNames.UNBOUND_AWAIT_SESSION_UP,
      parentContext: this.Unbound,
    }, {
      emitBindWaiting: function emitBindWaiting() {
        consumer._emit(PrivateFlowEventName.BIND_WAITING);
      },
    })
      .entry(function onEntry() {
        this.emitBindWaiting();
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.internalTransition(); // Don't exit; continue waiting
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        return this.internalTransition(); // Don't exit; continue waiting
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
        return this.transitionTo(fsm.BindSent); // OK to bind
      });

    /*
      In this state, we have received SESSION_UP but not FLOW_OPEN.
      If we get FLOW_OPEN, attempt to bind. Any other event is handled
      by the parent.
     */
    this.Unbound.AwaitFlowOpen = new State({
      name:          ConsumerStateNames.UNBOUND_AWAIT_FLOWOPEN,
      parentContext: this.Unbound,
    })
      .reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
        return this.transitionTo(fsm.BindSent); // OK to bind
      });

    this.BindSent = new State({
      name:          ConsumerStateNames.BIND_SENT,
      parentContext: fsm,
    }, {
      emitBindFailed: function emitBindFailed(error) {
        assert(error instanceof OperationError);
        consumer._emit(MessageConsumerEventName.CONNECT_FAILED_ERROR, error);
      },
      sendBindRequest: function sendBindRequest() {
        var correlationTag = sessionInterface.getCorrelationTag();
        var transportAcks = fsm._transportAcks;

        fsm._endpointEnsure();
        var endpoint = fsm._endpoint;
        var subscription = fsm._subscription;

        var message = SMFLib.AdProtocolMessage.getOpenMessageConsumer(
          properties.queueDescriptor,
          properties.queueProperties,
          endpoint,
          subscription,
          correlationTag,
          properties.windowSize,
          properties.noLocal,
          properties.activeIndicationEnabled,
          transportAcks.lastAcked,
          transportAcks.lastReceived);
        sessionInterface.sendControl(message);
        sessionInterface.enqueueRequest(correlationTag,
                                        this.handleBindTimeout.bind(this),
                                        fsm._bindTimeoutInMsecs,
                                        null,
                                        this.handleBindResponse.bind(this));
        LOG_TRACE('Sent consumer bind request with arguments', [
          properties.queueDescriptor,
          properties.queueProperties,
          endpoint,
          subscription,
          correlationTag,
          properties.windowSize,
          properties.noLocal,
          properties.activeIndicationEnabled,
          transportAcks.lastAcked,
          transportAcks.lastReceived]);
      },
      cancelBindRequestTimer: function cancelBindRequestTimer() {
        this.bindRequestTimer.cancel();
      },
      handleBindTimeout: function handleBindTimeout() {
        LOG_INFO('Bind timeout');
        fsm.processEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.BIND_TIMEOUT }));
      },
      handleBindResponse: function handleBindResponse(msg) {
        if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.BIND) {
          // TODO: more useful action here?
          LOG_INFO(("Unexpected message type in bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))));
          return fsm.processEvent(
            new ConsumerFSMEvent(
              { name: ConsumerFSMEventNames.FLOW_FAILED },
              new OperationError(("Unexpected bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))),
                                 ErrorSubcode.PROTOTOCOL_ERROR)));
        }

        var header = msg.smfHeader;
        var responseCode = header.pm_respcode;

        if (responseCode === null) {
          // Drop message and increment stats. Flow will time out
          this._consumer.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          LOG_DEBUG(("Drop Open-Publisher-Flow Request message on sessionId 0x" + (this._sessionInterface.sessionIdHex)));
          return undefined;
        }

        if (responseCode !== 200) {
          var description = header.pm_respstr;
          var errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode,
                                                                            description);
          LOG_DEBUG('Flow failed:', responseCode, description, ErrorSubcode.describe(errorSubcode));
          return fsm.processEvent(new ConsumerFSMEvent(
              { name: ConsumerFSMEventNames.FLOW_FAILED },
              new OperationError(description, errorSubcode, { responseCode: responseCode })));
        }

        var accessTypeOrDefault = function (x) { return (x === undefined ? QueueAccessType.EXCLUSIVE : x); };

        var attrs = {
          lastMsgIdAcked:       msg.getLastMsgIdAcked(),
          flowId:               msg.getFlowId(),
          accessType:           accessTypeOrDefault(msg.getAccessType()),
          topicEndpointBytes:   msg.getTopicEndpointBytes(),
          grantedPermissions:   msg.getGrantedPermissions(),
          respectsTTL:          msg.getRespectsTTL(),
          activeFlow:           msg.getActiveFlow(),
          wantFlowChangeNotify: msg.getWantFlowChangeNotify(),
          discardBehavior:      msg.getQueueDiscardBehavior(),
          endpointId:           msg.getEndpointId(),
          maxUnackedMessages:   msg.getMaxUnackedMessages(),
        };
        LOG_DEBUG('BIND response attributes:', attrs);

        Object.assign(consumer, {
          accessType:           attrs.accessType,
          queueDiscardBehavior: attrs.discardBehavior,
          endpointId:           attrs.endpointId,
          respectsTTL:          attrs.respectsTTL,
          flowId:               attrs.flowId,
          permissions:          attrs.grantedPermissions,
          wantFlowChangeNotify: attrs.wantFlowChangeNotify,
        });

        if (attrs.topicEndpointBytes && attrs.topicEndpointBytes.length) {
          attrs.endpoint = DestinationFromNetwork.createDestinationFromBytes(
            attrs.topicEndpointBytes);
          LOG_DEBUG('Overwriting local endpoint:', fsm._endpoint, 'with remote:', attrs.endpoint);
          fsm._endpoint = attrs.endpoint;
          var consumerProperties = fsm._consumer._properties;
          consumerProperties.queueDescriptor = new QueueDescriptor({
            name:    attrs.endpoint.name,
            type:    consumerProperties.queueDescriptor.type,
            durable: consumerProperties.queueDescriptor.durable,
          });
        }

        Object.assign(fsm, {
          _active:           attrs.activeFlow,
          _remoteWindowSize: attrs.maxUnackedMessages,
        });

        if (Long.UZERO.eq(fsm._transportAcks.lastAcked)) {
          fsm._transportAcks.lastAcked = attrs.lastMsgIdAcked || Long.UZERO;
        } else {
          LOG_DEBUG(("Retaining last acked/last received: " + (fsm._transportAcks)));
        }

        return fsm.processEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_UP }));
      },
    })
      .entry(function onEntry() {
        this.sendBindRequest();
        this.bindRequestTimer = Timer.newTimeout(consumer._properties.connectTimeoutInMsecs,
                                                 this.handleBindTimeout);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp,
                                 function () { return fsm._addEventToEmit(MessageConsumerEventName.DOWN); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(fsm.UnbindSent);
      })
      .reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
        var this$1 = this;

        if (fsm.bindRetryCount) {
          return this.externalTransitionTo(fsm.BindSent, function () { return --fsm.bindRetryCount; });
        }
        return this.transitionTo(fsm.Unbound,
                                 function () { return this$1.emitBindFailed(
                                    new OperationError('Bind failed due to timeout',
                                                       ErrorSubcode.TIMEOUT)); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
        var this$1 = this;

        // Act like a newly created flow
        return this.transitionTo(fsm.Unbound, function () { return this$1.emitBindFailed(evt.details); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
        return this.transitionTo(fsm.FlowUp);
      })
      .exit(function onExit() {
        this.cancelBindRequestTimer();
      });

    var flowUpFSM = this.FlowUp = new State({
      name:          ConsumerStateNames.FLOW_UP,
      parentContext: fsm,
    })
      .initial(
        function onInitial() {
          return this.transitionTo(fsm._active === 0
            ? flowUpFSM.XferInactive
            : flowUpFSM.Xfer);
        }
      )
      .entry(function () {
        fsm._addEventToEmit(MessageConsumerEventName.UP);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDisconnect() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp,
                                 function () { return fsm._addEventToEmit(MessageConsumerEventName.DOWN); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        // Acks will be sent by UnbindSent
        return this.transitionTo(fsm.UnbindSent);
      });

    flowUpFSM.Xfer = new State({
      name:          ConsumerStateNames.FLOW_UP_XFER,
      parentContext: flowUpFSM,
    })
      .entry(function () {
        fsm._addEventToEmit(MessageConsumerEventName.ACTIVE);
        fsm._sendAcks(true);
        fsm._requestStartDispatch();
      })
      .exit(function () {
        fsm._addEventToEmit(MessageConsumerEventName.INACTIVE);
        fsm._requestStopDispatch();
      })
      // Here we send acks on disconnect.  Acks for the FLOW_CLOSE event are coupled to the sending
      // of the unbind.
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        fsm._sendAcks(true);            // send acks, then...
        return this.eventUnhandled();   // let the parent state handle the remaining steps.
      });

    flowUpFSM.XferInactive = new State({
      name:          ConsumerStateNames.FLOW_UP_XFER_INACTIVE,
      parentContext: flowUpFSM,
    })
      .reaction(ConsumerFSMEventNames.FLOW_ACTIVE_IND, function onFlowActiveIndication() {
        return this.transitionTo(flowUpFSM.Xfer);
      });

    this.UnbindSent = new State({
      name:          ConsumerStateNames.UNBIND_SENT,
      parentContext: fsm,
    }, {

      sendUnbindRequest: function sendUnbindRequest() {
        var this$1 = this;

        // Don't do this on entry to UNBIND, do it when the user
        // wants to unbind
        fsm._endpointClear();

        var correlationTag = sessionInterface.getCorrelationTag();
        var message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(consumer.flowId,
                                                                         correlationTag);
        sessionInterface.sendControl(message);
        sessionInterface.enqueueRequest(
          correlationTag,
          function () { return this$1.handleUnbindTimeout(); },
          properties.connectTimeoutInMsecs,
          null,
          function (response) { return this$1.handleUnbindResponse(response); });
        LOG_DEBUG('Sent consumer unbind request with arguments',
                  {
                    flowId: consumer.flowId,
                    correlationTag: correlationTag,
                  });
      },

      handleUnbindTimeout: function handleUnbindTimeout() {
        LOG_INFO('Unbind timeout');
        return fsm.processEvent(
          new ConsumerFSMEvent({ name: ConsumerFSMEventNames.UNBIND_TIMEOUT })
        );
      },

      handleUnbindResponse: function handleUnbindResponse(msg) {
        if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.UNBIND) {
          LOG_INFO(("Unexpected message type in bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))));
        }
        return fsm.processEvent(
          new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_UNBOUND })
        );
      },

    })
      .entry(function onEntry() {
        this.sendUnbindRequest();
      })
      .reaction(ConsumerFSMEventNames.UNBIND_TIMEOUT, function onUnbindTimeout() {
        return this.externalTransitionTo(fsm.UnbindSent);
      })
      // The choice point will emit on this transition, not on exit, which is OK:
      // we don't want to repeatedly dispatch "unbound" when the unbinds are timing out
      .reaction(ConsumerFSMEventNames.FLOW_UNBOUND,
                function () { return fsm.transitionToUnbound(MessageConsumerEventName.DOWN); });
  }

  if ( StateMachine ) ConsumerFSM.__proto__ = StateMachine;
  ConsumerFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  ConsumerFSM.prototype.constructor = ConsumerFSM;

  var prototypeAccessors = { maxWindowSize: {},windowSize: {},maxPendingAcks: {} };

  /**
   *
   * @param {solace.Message} message The message being accepted by the flow.
   * @returns {Boolean} True if the message was accepted.
   * @private
   */
  ConsumerFSM.prototype.acceptMessage = function acceptMessage (message) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var messageID = message.getGuaranteedMessageId();
    var idstr = messageID.toString();
    var consumer = this._consumer;

    if (!this._fsmDispatch) {
      // We're disconnecting. Drop the message.
      LOG_TRACE('Dropping message because this flow cannot acknowledge it');
      consumer.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
      return false;
    }

    var transportAcks = this._transportAcks;
    var ackResult = transportAcks.tryReceive(messageID,
                                               message.getGuaranteedPreviousMessageId());
    var transportAckRequired = transportAcks.acksPending > this.maxPendingAcks;
    switch (ackResult) {
      case TransportAckResult.OK:
        break; // carry on
      case TransportAckResult.DUPLICATE:
        consumer.incStat(StatType.RX_DISCARD_DUPLICATE);
        // Two options here: could check membership in the ringbuffer,
        // or could check whether the ID is less than ringbuffer.front().
        // Untested assumption: arithmetic comparison on boxed Long at front()
        // is more computationally expensive than native Map() lookup.
        if (!this._applicationAcks.has(messageID) &&
            !this._oldUnacked.has(idstr)) {
          LOG_TRACE('Will application ack unknown duplicate ID', idstr);
          this._sendAck([[messageID, messageID]]);
        } else if (transportAckRequired) {
          this._sendAcks(transportAckRequired);
        } else {
          // if we are receiving dups we should make sure we send
          // and ack in case we don't receive any non duplicates
          // and we don't receive enough duplicates to exceed
          // maxPendingAcks.  Eventually we would but only after
          // the  router retransmitted many times.
          this._setTransportAckTimer();
        }
        return false;
      case TransportAckResult.OUT_OF_ORDER:
        consumer.incStat(StatType.RX_DISCARD_OUT_OF_ORDER);
        return false;
      default:
        assert(false, 'Unhandled transport ack result', ackResult);
        return false;
    }

    return this._applicationAcks.insert(messageID, function (evicting) {
      var applicationAckRequired = false;
      if (evicting) {
        switch (evicting.state) {
          case ApplicationAckState.UNACKED:
            this$1._oldUnacked.add(evicting.key);
            break;
          case ApplicationAckState.ACKED_NOT_SENT:
            applicationAckRequired = true;
            break;
          case ApplicationAckState.ACKED_SENT:
            // OK to evict
            break;
          default:
            assert(false,
                   'Unhandled application ack state',
                   ApplicationAckState.describe(evicting.state));
        }
      }

      this$1._messageDispatch.push(message);

      if (transportAckRequired || applicationAckRequired) {
        LOG_TRACE('Need to send acks:',
                  'transport', transportAckRequired,
                  'application', applicationAckRequired);
        this$1._sendAcks(transportAckRequired);
      } else {
        this$1._setTransportAckTimer();
      }

      return true;
    });
  };

  ConsumerFSM.prototype.applicationAck = function applicationAck (messageId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    var idstr = messageId.toString();
    this._consumer.incStat(StatType.RX_ACKED);

    // Was the message old, and demoted to _oldUnacked?
    if (this._oldUnacked.delete(idstr)) { // True if idstr was member
      // It was old. Ack immediatesly.
      LOG_TRACE('Application acking old message immediately');
      this._sendAck([[messageId, messageId]]);
      return;
    }

    // We can't regress the ack_state this way; message.acknowledge() throws if called
    // more than once.
    this._applicationAcks.updateAckState(messageId, ApplicationAckState.ACKED_NOT_SENT);
    this._setTransportAckTimer();
  };

  ConsumerFSM.prototype.getDestination = function getDestination () {
    this._endpointEnsure();
    return this._destination;
  };

  ConsumerFSM.prototype.isDisconnected = function isDisconnected () {
    if (!this.getCurrentState()) { return true; }
    return (
      this.getActiveState(ConsumerStateNames.UNBOUND) ||
      this.getActiveState(ConsumerStateNames.UNBOUND_AWAITING_FLOWOPEN)
    );
  };

  ConsumerFSM.prototype.requestStartDispatchUser = function requestStartDispatchUser () {
    this._userDispatch = true;
    this.applyStartDispatch();
  };

  ConsumerFSM.prototype.requestStartDispatchFSM = function requestStartDispatchFSM () {
    this._fsmDispatch = true;
    this.applyStartDispatch();
  };

  ConsumerFSM.prototype.applyStartDispatch = function applyStartDispatch () {
    if (this._userDispatch && this._fsmDispatch) {
      this.log(("Starting message dispatch (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
      this._messageDispatch.start();
      this._localMaxWindowSize = this._localPreferredWindowSize;
      this._sendAcks(true);
    } else {
      this.log(("Not starting message dispatch (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    }
  };

  ConsumerFSM.prototype.transitionToUnbound = function transitionToUnbound (eventName) {
    var this$1 = this;

    var consumer = this._consumer;
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    LOG_TRACE('Flow down, user disconnected?', consumer.userDisconnected);

    return this.transitionTo(this.Unbound.AwaitFlowOpen, function () { return this$1._addEventToEmit(eventName); });
  };

  ConsumerFSM.prototype.requestStopDispatchUser = function requestStopDispatchUser () {
    this._userDispatch = false;
    this.log(("Stop dispatch user (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    this._messageDispatch.stop();
  };

  ConsumerFSM.prototype.requestStopDispatchFSM = function requestStopDispatchFSM () {
    this._fsmDispatch = false;
    this.log(("Stop dispatch FSM (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    this._sendAcks(true);
  };

  ConsumerFSM.prototype._clearTransportAckTimer = function _clearTransportAckTimer () {
    if (!this._transportAckTimer) { return; }

    clearTimeout(this._transportAckTimer);
    this._transportAckTimer = null;
  };

  ConsumerFSM.prototype._dispose = function _dispose () {
    this._clearTransportAckTimer();
    this._endpointClear();
    this._destination = undefined;
    this._unacked = null;
    this._messageDispatch = null;
    this._transportAcks = null;
    this._consumer = null;
    this._sessionInterface = null;
  };

  ConsumerFSM.prototype._endpointClear = function _endpointClear () {
    this._endpoint = undefined;
    this._subscription = undefined;
  };

  ConsumerFSM.prototype._endpointEnsure = function _endpointEnsure () {
    if (this._endpoint) {
      // The endpoint, destination and any possible topic subscription are generated
      // at the same time. Use the presence of the endpoint to determine whether
      // any of this has already been done.
      return;
    }

    var sessionInterface = this._sessionInterface;
    var properties = this._consumer._properties;
    var queueDescriptor = properties.queueDescriptor;

    var destination;
    var endpoint;
    var subscription;
    if (queueDescriptor.type === QueueType.QUEUE) {
      // The publish destination needs a prefix. Create a destination from
      // the descriptor, then derive the endpoint name from that.
      destination = sessionInterface.createDestinationFromDescriptor(queueDescriptor);

      // The bind target is the queue name encoded as though a topic -- no prefix
      // Use the offset information to build a bind target
      endpoint = new Queue({
        name:   destination.name,
        type:   DestinationType.QUEUE,
        offset: 0,
        bytes:  destination.bytes.substr(destination.offset),
      });

      subscription = undefined;
    } else {
      // QueueType.TOPIC_ENDPOINT
      endpoint = queueDescriptor.name
        ? sessionInterface.createDestinationFromDescriptor(queueDescriptor)
        : new Topic({ name: '\0?', offset: 0, bytes: '\0' });
      subscription = properties.topicEndpointSubscription ||
        sessionInterface.createTemporaryDestination(DestinationType.TOPIC);
      destination = subscription;
    }

    // Using Object.assign to enforce the invariant that these three properties are set together
    // or not at all.
    Object.assign(this, {
      _destination:  destination,
      _endpoint:     endpoint,
      _subscription: subscription,
    });

    // Update the properties object (if TTMP, we may modify it again)
    properties.queueDescriptor = new QueueDescriptor({
      name:    endpoint.name,
      type:    queueDescriptor.type,
      durable: queueDescriptor.durable,
    });
  };

  ConsumerFSM.prototype._resetLocalConnectionState = function _resetLocalConnectionState () {
    Object.assign(this, {
      _remoteWindowSize: 0,
      _active:           undefined,
      _fsmDispatch:      false,
      _userDispatch:     true, // User flow is initially started
    });
  };

  ConsumerFSM.prototype._resetRemoteConnectionState = function _resetRemoteConnectionState () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    LOG_TRACE('Initializing transport acks');
    this._transportAcks = new TransportAcks();

    LOG_TRACE('Initializing application acks');
    this._applicationAcks = new ApplicationAckRingBuffer(RING_BUFFER_SIZE);
    this._oldUnacked = new Set();
  };

  /**
   * Sends a single ack.
   *
   * @param {Array.<ackpair>} applicationAcks The application ack ranges to send
   * @memberof ConsumerFSM
   * @private
   */
  ConsumerFSM.prototype._sendAck = function _sendAck (applicationAcks) {
    var transportAck = SMFLib.AdProtocolMessage.getAck(
      this._consumer.flowId,
      this._transportAcks.lastReceived,
      this.windowSize,
      applicationAcks);
    this._sessionInterface.sendControl(transportAck); // Must succeed or throw
  };

  /**
   * Adds the current ack ranges to an accumulator. Call this for each applicationAck.
   * When a range ends (we receive an unacked), or we are explictly flushing
   * (applicationAck === null), we convert the accumulator to acks, send them, update state,
   * and reset accumulators.
   *
   * This should be called at least once with the last invocation having ackRange = null.
   * This invokes the flush path, which is necessary if any ranges were in progress,
   * and this is the only path that repects the forceTransportAck flag.
   *
   * @param {Object} acksPendingState State associated with this activity
   * @param {ApplicationAck} applicationAck The ack to process for ack ranges.
   *    If `null`, any pending acks are flushed and a transport ack is sent, if
   *    required.
   * @private
   */
  ConsumerFSM.prototype._addAckToRanges = function _addAckToRanges (acksPendingState, applicationAck) {
    var this$1 = this;
    if ( applicationAck === void 0 ) applicationAck = null;

    var currentRange = acksPendingState.currentRange;
    var ackRanges = acksPendingState.ackRanges;

    if (applicationAck && applicationAck.state !== ApplicationAckState.UNACKED) {
      currentRange.push(applicationAck);
      return; // Wait for end of range or flush
    }

    // We received an UNACKED or a null ack (flush). Complete this range.
    if (currentRange.length) {
      ackRanges.push(currentRange);
    }

    // If we're flushing or we've hit the protocol limit for ranges in a single ack,
    // we send ack messages, update ack states and clear the accumulator.
    // This condition will be true at least once (must flush at the end).
    if (applicationAck === null ||
        ackRanges.length === SMFLib.AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
      // Reduce each range to a first and last ID.
      var bareRanges = ackRanges.map(function (range) { return [range[0].id, range[range.length - 1].id]; });

      if (bareRanges.length || acksPendingState.forceTransportAck) {
        // We send the ranges. This could throw.
        var ref = this.logger;
        var LOG_TRACE = ref.LOG_TRACE;
        this._sendAck(bareRanges);
        // Warning: this log statement reduces debug performance by 25%!
        LOG_TRACE(
          'Sent ack: ',
          ("Transport ack: " + (this._transportAcks.lastReceived)),
          ("Application acks: " + (bareRanges.length
            ? bareRanges.map(function (g) { return ("[" + (g[0]) + ".." + (g[1]) + "]"); })
            : '[]'))
        );
        // If the intent was to force a transport ack, that condition is fulfilled.
        this._transportAcks.setAcked();
        acksPendingState.forceTransportAck = false;
      }

      // Since the range send succeeded, update the ack states.
      ackRanges.forEach(function (ackRange) {
        ackRange.forEach(function (ack) {
          if (ack.state !== ApplicationAckState.ACKED_SENT) {
            this$1._applicationAcks.updateAckState(ack.id,
                                                 ApplicationAckState.ACKED_SENT);
          }
        });
      });

      // Clear the main accumulator since it has hit the wire.
      acksPendingState.ackRanges = [];
    }
    // Clear the accumulator for this range.
    acksPendingState.currentRange = [];
  };

  /**
   * Sends acknowledgements, along with a window update for this flow.
   *
   * @param {Boolean} forceTransportAck `true` sends transport ack even if no acks pending
   * @private
   */
  ConsumerFSM.prototype._sendAcks = function _sendAcks (forceTransportAck) {
    var this$1 = this;
    if ( forceTransportAck === void 0 ) forceTransportAck = false;

    this._clearTransportAckTimer();

    var applicationAcks = this._applicationAcks;
    var transportAcks = this._transportAcks;

    // This state is temporary and shared with the ack generating function.
    var acksPendingState = {
      forceTransportAck: forceTransportAck || (transportAcks.acksPending > 0),
      ackRanges:         [],
      currentRange:      [],
    };

    // If the first ringbuffer ack state is acked and there are no unacked before this,
    // we can create an ack range that includes zero.
    // If the first ringbuffer ack state is unacked, we can say nothing about the
    // range before the first acked ID in the ringbuffer.
    var front = this._applicationAcks.front();
    if (this._oldUnacked.size === 0 && front && front.state !== ApplicationAckState.UNACKED) {
      // State is acked_sent so we don't try to update the ring buffer.
      this._addAckToRanges(acksPendingState, ZERO_APP_ACK);
      // We know that front will be added to this range by the iteration.
    }

    // Build ack ranges using the accumulator
    applicationAcks.forEach(function (ack) { return this$1._addAckToRanges(acksPendingState, ack); });
    // Flush the last pending ack range.
    this._addAckToRanges(acksPendingState);

    // On successful exit, we've sent and cleared all accumulators, and we've sent
    // a transport ack if we were supposed to do that.
    assert(acksPendingState.forceTransportAck === false);
    assert(acksPendingState.currentRange.length === 0);
    assert(acksPendingState.ackRanges.length === 0);
  };

  ConsumerFSM.prototype._setTransportAckTimer = function _setTransportAckTimer () {
    var this$1 = this;

    if (this._transportAckTimer) { return; }
    if (this._consumer.disposed) { return; }
    this._transportAckTimer = setTimeout(
      function () { return this$1._sendAcks(true); },
      this._acknowledgeTimeoutInMsecs
    );
  };

  prototypeAccessors.maxWindowSize.get = function () {
    return Math.min(this._localMaxWindowSize,
                    this._remoteWindowSize || Number.POSITIVE_INFINITY);
  };

  prototypeAccessors.windowSize.get = function () {
    return this.maxWindowSize - this._messageDispatch.length;
  };

  prototypeAccessors.maxPendingAcks.get = function () {
    return this.windowSize * this._consumer._properties.acknowledgeThreshold / 100.0;
  };

  Object.defineProperties( ConsumerFSM.prototype, prototypeAccessors );

  return ConsumerFSM;
}(StateMachine));

module.exports.ConsumerFSM = ConsumerFSM;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var ConsumerStateNames = {
  UNBOUND:                  'UNBOUND',
  UNBOUND_AWAIT_SESSION_UP: 'UNBOUND_AWAIT_SESSION_UP',
  UNBOUND_AWAIT_FLOWOPEN:   'UNBOUND_AWAIT_FLOWOPEN',
  UNBOUND_AWAIT_ANY:        'UNBOUND_AWAIT_ANY',
  BIND_SENT:                'BIND_SENT',
  FLOW_UP:                  'FLOW_UP',
  FLOW_UP_XFER:             'FLOW_UP_XFER',
  FLOW_UP_XFER_INACTIVE:    'FLOW_UP_XFER_INACTIVE',
  UNBIND_SENT:              'UNBIND_SENT',
};

module.exports.ConsumerStateNames = Enum.new(ConsumerStateNames);


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(18);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var QueueDescriptor = ref.QueueDescriptor;
var QueueDescriptorValidator = ref.QueueDescriptorValidator;
var QueueProperties = ref.QueueProperties;
var QueuePropertiesValidator = ref.QueuePropertiesValidator;
var QueueType = ref.QueueType;
var ref$1 = __webpack_require__(4);
var APIPropertiesValidators = ref$1.APIPropertiesValidators;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$3.MessageConsumerAcknowledgeMode;
var ref$4 = __webpack_require__(2);
var OperationError = ref$4.OperationError;
var ErrorSubcode = ref$4.ErrorSubcode;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valInstance = APIPropertiesValidators.valInstance;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;
var valTopicStringOrEmpty = APIPropertiesValidators.valTopicStringOrEmpty;

function valTopicEndpointSubscription(typeDesc, instance) {
  if (instance.queueDescriptor.getType() === QueueType.TOPIC_ENDPOINT) {
    if (instance.queueDescriptor.isDurable()) {
      if (!instance.topicEndpointSubscription) {
        throw new OperationError('topicEndpointSubscription must be set when queueDescriptor ' +
                                'refers to a durable topic endpoint',
                                ErrorSubcode.PARAMETER_CONFLICT);
      }
    }
  } else if (instance.topicEndpointSubscription) {
    // is QueueType.QUEUE
    throw new OperationError('topicEndpointSubscription is set, but queueDescriptor ' +
                              'refers to a queue that is not of type QueueType.TOPIC_ENDPOINT',
                              ErrorSubcode.PARAMETER_CONFLICT);
  }
}

var MessageConsumerPropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'MessageConsumerProperties', instance);
    if (!(instance.queueDescriptor instanceof AbstractQueueDescriptor ||
          instance.queueDescriptor instanceof QueueDescriptor)) {
      throw new OperationError('MessageConsumerProperties validation: queue descriptor must be ' +
                                'an AbstractQueueDescriptor or a QueueDescriptor',
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    QueueDescriptorValidator.validate(instance.queueDescriptor);

    if (instance.queueProperties) {
      if (instance.queueDescriptor.durable) {
        throw new OperationError('queueProperties cannot be set unless queueDescriptor refers to ' +
                                 'a temporary queue',
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
      v('queueProperties', [valInstance, QueueProperties, 'QueueProperties']);
      QueuePropertiesValidator.validate(instance.queueProperties);
      if (Check.something(instance.queueProperties.accessType)) {
        throw new OperationError('queueProperties cannot specify accessType in creation of a ' +
                                 'temporary queue',
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
    }

    // Validate TE subscription
    if (instance.queueDescriptor.type === QueueType.TOPIC_ENDPOINT) {
      // QueueType.TOPIC_ENDPOINT
      if (instance.queueDescriptor.durable && !instance.topicEndpointSubscription) {
        throw new OperationError('topicEndpointSubscription must be set for durable ' +
                                       'topic endpoints',
                                       ErrorSubcode.PARAMETER_CONFLICT);
      }
    } else if (instance.topicEndpointSubscription) {
      throw new OperationError('topicEndpointSubscription cannot be set unless ' +
                               'descriptor.type is TOPIC_ENDPOINT',
                               ErrorSubcode.PARAMETER_CONFLICT);
    }

    v('connectTimeoutInMsecs', [valNumber], [valRange, 50, Number.MAX_VALUE]);
    v('connectAttempts', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('topicEndpointSubscription', [valTopicEndpointSubscription], [valTopicStringOrEmpty]);

    v('acknowledgeMode', [valIsMember, MessageConsumerAcknowledgeMode, 'MessageConsumerAcknowledgeMode']);
    v('acknowledgeTimeoutInMsecs', [valNumber], [valRange, 20, 1500]);
    v('acknowledgeThreshold', [valNumber], [valRange, 1, 75]);
    v('activeIndicationEnabled', [valBoolean]);
    v('noLocal', [valBoolean]);
    v('windowSize', [valNumber], [valRange, 1, 255]);

    if (instance.activeIndicationEnabled &&
      instance.queueDescriptor.type !== QueueType.QUEUE) {
      throw new OperationError(
        'MessageConsumerProperties validation: activeIndicationEnabled may only be true for ' +
        'QUEUE destinations',
        ErrorSubcode.PARAMETER_CONFLICT
      );
    }
  },
};

module.exports.MessageConsumerPropertiesValidator = MessageConsumerPropertiesValidator;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(28);
var MessageConsumerEventName = ref.MessageConsumerEventName;

function formatEventName(x) {
  return ("MessageConsumerEventName." + (MessageConsumerEventName.describe(x)));
}

var MessageDispatcher = function MessageDispatcher(ref) {
  if ( ref === void 0 ) ref = {};
  var emitter = ref.emitter;
  var autoAck = ref.autoAck;
  var logger = ref.logger;

  Object.assign(this, {
    emitter: emitter,
    queue:  [],
    dispatch: true,
    formatEventName: formatEventName,
    logger: logger,
  });
  this._dispatchOne = autoAck ? this._dispatchOneAutoAck : this._dispatchOneBare;
  this.emitter.setOnFirstDirectListener(this._onFirstMessageListener.bind(this));
  // Although a listener may not be available, we set it to true so that we detect a transition to
  // false when we attempt to dispatch the first message, which will generate a log that
  // dispatching is stopped due to a missing listener.
  this._availableListener = true;
};

var prototypeAccessors = { length: {} };

MessageDispatcher.prototype.start = function start () {
  this.dispatch = true;
  this._flush();
};

MessageDispatcher.prototype.stop = function stop () {
  this.dispatch = false;
};

prototypeAccessors.length.get = function () {
  return this.queue.length;
};

MessageDispatcher.prototype.push = function push (message) {
  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
  this.queue.push(message);

  if (this.dispatch) {
    this._flush();
  } else {
    LOG_TRACE(("Dispatch disabled, message " + (message.getGuaranteedMessageId()) + " queued locally"));
  }
};

MessageDispatcher.prototype._onFirstMessageListener = function _onFirstMessageListener () {
  var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
  if (!this._availableListener) {
    LOG_DEBUG(("Message listener available for dispatcher, " + (this.queue.length) + " messages queued"));
    LOG_DEBUG(("Dispatcher started and connected: " + (this.dispatch ? 'true' : 'false')));
    this._availableListener = true;
  }
  this._flush();
};

MessageDispatcher.prototype._flush = function _flush () {
    var this$1 = this;

  var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
  // Check whether dispatch enabled for every element,
  // to handle when #stop is called from a message handler
  while (this.queue.length && this.dispatch && (this.emitter.directListenerCount() > 0)) {
    this$1._dispatchOne(this$1.queue.shift());
  }

  if (this.queue.length && this.dispatch &&
      (this.emitter.directListenerCount() === 0) && this._availableListener) {
    LOG_DEBUG('Message dispatching stopped: No message listener registered');
    this._availableListener = false;
  }
};

MessageDispatcher.prototype._dispatchOneAutoAck = function _dispatchOneAutoAck (message) {
  var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
  // Set the current outbound message, dispatch it, and clear the current outbound message
  var caught = null;

  // Auto-ack unless the receiver throws.
  caught = this._dispatchOneBare(message);
  // Outside of exception block because we want to throw normally from message.acknowledge()
  if (caught) {
    LOG_WARN(("Suppressing message acknowledgement for message " + (message.getGuaranteedMessageId()) + " because client threw exception from listener"), caught);
  } else {
    // Did the user manually ack for some reason?
    if (message.isAcknowledged) {
      LOG_WARN(("Consumer configured to auto-acknowledge messages, but message " + (message.getGuaranteedMessageId()) + " was application acknowledged"));
      return;
    }
    message.acknowledge(); // No, so ack the message
  }
};

MessageDispatcher.prototype._dispatchOneBare = function _dispatchOneBare (message) {
  var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
  var caught;
  // Requires the emitter's direct option to be MessageConsumerEventName.MESSAGE
  if (this.listenerCount === 0) {
    LOG_WARN(("No listeners to dispatch message " + (message.getGuaranteedMessageId())));
  }
  // Since _dispatchOneBare uses emitDirect, this behaviour is not affected by the presence
  // of an 'error' handler.
  try {
    this.emitter.emitDirect(message);
  } catch (ex) {
    // User code threw an exception
    caught = this.emitter.formatErrorEvent(ex, MessageConsumerEventName.MESSAGE, message);
    // Also propagating to the common error handler
    this.emitter.emit('error', caught);
  }
  return caught;
};

Object.defineProperties( MessageDispatcher.prototype, prototypeAccessors );

module.exports = { MessageDispatcher: MessageDispatcher };


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var Enum = ref.Enum;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;

var TransportAckResult = Enum.new({
  OK:           0,
  DUPLICATE:    1,
  OUT_OF_ORDER: 2,
});

var TransportAcks = function TransportAcks(id) {
  if ( id === void 0 ) id = 0;

  var base = typeof id === 'number' ? Long.fromNumber(id, true) : Long.fromValue(id);
  this.lastAcked = base;
  this._acksPending = 0;
};

var prototypeAccessors = { acksPending: {},lastAcked: {},lastReceived: {} };

TransportAcks.prototype.tryReceive = function tryReceive (messageID, prevMessageID) {
  if (this._lastReceived.lt(prevMessageID)) {
    LOG_DEBUG(("Rejecting out of order message: " + prevMessageID + " (last received: " + (this._lastReceived) + ")"));
    return TransportAckResult.OUT_OF_ORDER;
  }
  if (this._lastReceived.gte(messageID)) {
    LOG_DEBUG(("Rejecting duplicate message: " + messageID + " (last received: " + (this._lastReceived) + ")"));
    // duplicate messages indicate the router is retransmitting because it expects a transport ack
    this._acksPending++;
    return TransportAckResult.DUPLICATE;
  }
  LOG_TRACE(("Accepting message: " + messageID));
  this._lastReceived = messageID;
  this._acksPending++;
  return TransportAckResult.OK;
};

TransportAcks.prototype.setAcked = function setAcked () {
  this._lastAcked = Long.fromValue(this._lastReceived);
  this._acksPending = 0;
};

prototypeAccessors.acksPending.get = function () {
  return this._acksPending;
};

prototypeAccessors.lastAcked.get = function () {
  return this._lastAcked;
};

/**
 * Resets the beginning of the ack sequence to the given value.
 * @param {Long} value The value to set as last acknowledged ID.
 */
prototypeAccessors.lastAcked.set = function (value) {
  LOG_TRACE('Setting last acked:', value.toString());
  Object.assign(this, {
    _lastAcked:  Long.fromValue(value),
    _lastReceived: Long.fromValue(value),
  });
};

prototypeAccessors.lastReceived.get = function () {
  return this._lastReceived;
};

TransportAcks.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( TransportAcks.prototype, prototypeAccessors );

module.exports = {
  TransportAcks: TransportAcks,
  TransportAckResult: TransportAckResult,
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(3);
var Long = ref.Long;

var DEFAULTS = {
  _lastAcked: Long.fromNumber(0, true),
  _lastSent:  Long.fromNumber(0, true),
  _next:      Long.fromNumber(1, true),
};

var longToString = function (v) { return v.toString(10); };

var MessageIds = function MessageIds(attrs) {
  Object.assign(this, DEFAULTS, attrs);
};

var prototypeAccessors = { lastAcked: {},lastSent: {},next: {} };

prototypeAccessors.lastAcked.get = function () {
  return this._lastAcked;
};
prototypeAccessors.lastAcked.set = function (value) {
  this._lastAcked = Long.fromValue(value);
};

prototypeAccessors.lastSent.get = function () {
  return this._lastSent;
};
MessageIds.prototype.setLastSent = function setLastSent (id) {
  this._lastSent = Long.fromValue(id);
  this._next = this._lastSent.add(1);
};

prototypeAccessors.next.get = function () {
  return this._next;
};

MessageIds.prototype[util.inspect.custom] = function () {
  return {
    'lastAcked': longToString(this.lastAcked),
    'lastSent':longToString(this.lastSent),
    'next':    longToString(this.next),
  };
};

MessageIds.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( MessageIds.prototype, prototypeAccessors );

module.exports.MessageIds = MessageIds;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$1.MessagePublisherAcknowledgeMode;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;


var MessagePublisherPropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'MessagePublisherProperties', instance);
    v('enabled', [valBoolean]);
    v('windowSize', [valNumber], [valRange, 1, 255]);
    v('acknowledgeTimeoutInMsecs', [valNumber], [valRange, 20, 60000]);
    v('acknowledgeMode', [valIsMember, MessagePublisherAcknowledgeMode, 'MessagePublisherAcknowledgeMode']);
    v('connectRetryCount', [valNumber], [valRange, 0, Number.MAX_VALUE]);
    v('connectTimeoutInMsecs', [valNumber], [valRange, 50, Number.MAX_VALUE]);
  },
};

module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var util = __webpack_require__(6);
var ref = __webpack_require__(36);
var Flow = ref.Flow;
var PrivateFlowEventName = ref.PrivateFlowEventName;
var ref$1 = __webpack_require__(1);
var LogFormatter = ref$1.LogFormatter;
var ref$2 = __webpack_require__(55);
var MessagePublisherEventName = ref$2.MessagePublisherEventName;
var ref$3 = __webpack_require__(102);
var MessagePublisherProperties = ref$3.MessagePublisherProperties;
var ref$4 = __webpack_require__(194);
var PublisherFSM = ref$4.PublisherFSM;
var ref$5 = __webpack_require__(57);
var PublisherFSMEvent = ref$5.PublisherFSMEvent;
var ref$6 = __webpack_require__(56);
var PublisherFSMEventNames = ref$6.PublisherFSMEventNames;

var ref$7 = new LogFormatter();
var LOG_WARN = ref$7.LOG_WARN;

var MessagePublisher = (function (Flow) {
  function MessagePublisher(ref) {
    if ( ref === void 0 ) ref = {};
    var properties = ref.properties;
    var sessionInterfaceFactory = ref.sessionInterfaceFactory;

    var applyProperties = new MessagePublisherProperties(properties);
    Flow.call(this, applyProperties, sessionInterfaceFactory, {
      direct: MessagePublisherEventName.ACKNOWLEDGED_MESSAGE,
      emits:  MessagePublisherEventName.values, // super adds MessageConsumerEventName
    });
    this._fsm = this._makeFSM();
    var logger = new LogFormatter();
    logger.formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        '[message-publisher]' ].concat( args );
    };
    this.log = logger.wrap(this.log, this);

    // Doesn't emit anything unless started; won't start unless bindWaiting
    this._bindWaiting = true;

    this.on(PrivateFlowEventName.BIND_WAITING, this._onBindWaiting.bind(this));
    this.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, this._onBindFailed.bind(this));
    this.on(MessagePublisherEventName.DOWN, this._onDown.bind(this));
    this.on(MessagePublisherEventName.UP, this._onUp.bind(this));
  }

  if ( Flow ) MessagePublisher.__proto__ = Flow;
  MessagePublisher.prototype = Object.create( Flow && Flow.prototype );
  MessagePublisher.prototype.constructor = MessagePublisher;

  var prototypeAccessors = { flowId: {},name: {},publisherId: {},properties: {} };

  MessagePublisher.prototype._onBindFailed = function _onBindFailed () {
    this._bindWaiting = false;
  };

  MessagePublisher.prototype._onBindWaiting = function _onBindWaiting () {
    this._bindWaiting = true;
  };

  MessagePublisher.prototype._onDown = function _onDown () {
    this._bindWaiting = false;
  };

  MessagePublisher.prototype._onUp = function _onUp () {
    this._bindWaiting = false;
  };

  /**
   * @override
   * @private
   */
  MessagePublisher.prototype._makeFSM = function _makeFSM () {
    return new PublisherFSM({
      publisher:        this,
      name:             'PublisherFSM',
      sessionInterface: this._sessionInterface,
      properties:       this._properties,
    });
  };

  /**
   * @returns {Long} The flow ID of this flow
   */
  prototypeAccessors.flowId.get = function () {
    return this._flowId;
  };
  /**
   * @param {Long} value The flow ID for this flow
   * @private
   */
  prototypeAccessors.flowId.set = function (value) {
    this._flowId = value;
  };

  /**
   * @returns {String} The publisher name set for this flow
   */
  prototypeAccessors.name.get = function () {
    return this._flowName;
  };
  /**
   * @param {String} value The name to set on this flow
   * @private
   */
  prototypeAccessors.name.set = function (value) {
    this._flowName = value;
  };

  /**
   * @returns {Number} The publisher ID set on this flow
   */
  prototypeAccessors.publisherId.get = function () {
    return this._publisherId;
  };
  /**
   * @param {Number} value The publisher ID to set on this flow
   */
  prototypeAccessors.publisherId.set = function (value) {
    this._publisherId = value;
  };

  /**
   * @readonly
   * @returns {solace.MessagePublisherProperties} A clone of the publisher's properties.
   */
  prototypeAccessors.properties.get = function () {
    return this._properties.clone();
  };

  /**
   *
   * @override
   * @memberof MessagePublisher
   */
  MessagePublisher.prototype.connect = function connect () {
    Flow.prototype.connect.call(this);
    if (!this._fsm.getCurrentState()) {
      this._fsm.start();
    }
  };

  /**
   * Application has disconnected the session, so
   * disconnects the Guaranteed Message Publisher.
   * @private
   */
  MessagePublisher.prototype._disconnectSession = function _disconnectSession () {
    Flow.prototype._disconnectSession.call(this);
    this.processFSMEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_CLOSE }));
  };

  /**
   * @returns {solace.MessagePublisherEventName} The name of the disposed event for this flow
   * @private
   */
  MessagePublisher.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    return MessagePublisherEventName.DISPOSED;
  };

  /**
   * Handles an incoming ACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @private
   */
  MessagePublisher.prototype.handleAck = function handleAck (id) {
    this.processFSMEvent(new PublisherFSMEvent(
      { name: PublisherFSMEventNames.ACK },
      { ack: id }
    ));
  };

  /**
   * Handles an incoming NACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @param {AdCtrlMessage} ctrlMessage The NACK message
   * @private
   */
  MessagePublisher.prototype.handleNack = function handleNack (id, ctrlMessage) {
    this.processFSMEvent(new PublisherFSMEvent(
      { name: PublisherFSMEventNames.ACK },
      { nack: id, ctrlMessage: ctrlMessage }
    ));
  };

  /**
   * @override
   */
  MessagePublisher.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) {
    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.CLIENTACK:
        {
          var id = message.getLastMsgIdAcked();
          if (message.smfHeader.pm_respcode > 299) {
            this.handleNack(id, message);
          } else {
            this.handleAck(id);
          }
          break;
        }
      case SMFAdProtocolMessageType.CLIENTNACK:
        {
          var id$1 = message.getLastMsgIdAcked();
          this.handleNack(id$1, message);
          break;
        }
      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
        this.processFSMEvent(new PublisherFSMEvent(
          { name: PublisherFSMEventNames.FLOW_UNBOUND })
        );
        break;
      default:
        LOG_WARN(("Dropping unhandled AD control message for " + (this)),
                 SMFAdProtocolMessageType.describe(msgType));
    }
  };

  /**
   * Prepares an AD message for publishing on this flow.
   * @param {Message} dataMsg The message to be prepared for publishing.
   * @returns {TransportReturnCode} transport level returnCode
   * @private
   */
  MessagePublisher.prototype.prepareAdMessageAndSend = function prepareAdMessageAndSend (dataMsg) {
    return this._fsm.prepareAdMessageAndSend(dataMsg);
  };

  MessagePublisher.prototype.isBindWaiting = function isBindWaiting () {
    return this._bindWaiting;
  };

  /**
   * @returns {String} Formatted inspector output
   * @private
   */
  MessagePublisher.prototype[util.inspect.custom] = function () {
    return Object.assign(Flow.prototype[util.inspect.custom].call(this), {
      'name':        this.name,
      'publisherId': this.publisherId,
    });
  };

  /**
   * @override
   */
  MessagePublisher.prototype.toString = function toString () {
    return util.inspect(this);
  };

  /**
   * Disposes the FSM associated with this flow.
   *
   * @private
   */
  MessagePublisher.prototype._disposeFSM = function _disposeFSM () {
    this.processFSMEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.DISPOSE }));
  };

  MessagePublisher.prototype._isDisconnected = function _isDisconnected () {
    return this._fsm.isDisconnected();
  };

  Object.defineProperties( MessagePublisher.prototype, prototypeAccessors );

  return MessagePublisher;
}(Flow));

module.exports.MessagePublisher = MessagePublisher;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LogFormatter = ref$1.LogFormatter;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;
var ref$3 = __webpack_require__(191);
var MessageIds = ref$3.MessageIds;
var ref$4 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$4.MessagePublisherAcknowledgeMode;
var ref$5 = __webpack_require__(55);
var MessagePublisherEventName = ref$5.MessagePublisherEventName;
var ref$6 = __webpack_require__(36);
var PrivateFlowEventName = ref$6.PrivateFlowEventName;
var ref$7 = __webpack_require__(57);
var PublisherFSMEvent = ref$7.PublisherFSMEvent;
var ref$8 = __webpack_require__(56);
var PublisherFSMEventNames = ref$8.PublisherFSMEventNames;
var ref$9 = __webpack_require__(195);
var PublisherStateNames = ref$9.PublisherStateNames;
var ref$10 = __webpack_require__(15);
var State = ref$10.State;
var StateMachine = ref$10.StateMachine;
var ref$11 = __webpack_require__(19);
var StatType = ref$11.StatType;
var ref$12 = __webpack_require__(23);
var TransportReturnCode = ref$12.TransportReturnCode;

var ConnectReason = {
  INIT:     0, // never connected: message renumbering required
  RESUME:   1, // connected before
  FAILOVER: 2, // after a DR failover: message renumbering and message republish event required
};

var PublisherFSM = (function (StateMachine) {
  function PublisherFSM(ref) {
    if ( ref === void 0 ) ref = {};
    var publisher = ref.publisher;
    var name = ref.name;
    var sessionInterface = ref.sessionInterface;
    var properties = ref.properties;

    StateMachine.call(this, { name: name });
    /** @type {MessagePublisher} */
    var fsm = this;
    var currentState = function () {
      var state = fsm.getCurrentState();
      return state ? state.getName() : '<not running>';
    };
    this.logger = new LogFormatter(function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
      ("[session=" + (sessionInterface.sessionIdHex) + "]"),
      ("[message-publisher-fsm=" + (publisher.flowIdDec) + "]"),
      ("[" + (currentState()) + "]") ].concat( args );
    });
    this.log = this.logger.wrap(this.log, this);
    var ref$1 = this.logger;
    var LOG_TRACE = ref$1.LOG_TRACE;
    var LOG_DEBUG = ref$1.LOG_DEBUG;
    var LOG_INFO = ref$1.LOG_INFO;

    Object.assign(this, {
      _publisher:                 publisher,
      _acknowledgeMode:           properties.acknowledgeMode,
      _acknowledgeTimeoutInMsecs: properties.acknowledgeTimeoutInMsecs,
      _sessionInterface:          sessionInterface,
      _windowSize:                properties.windowSize,
      _stateEvents:               [],
    });
    // The publisher is not even constructed when publisherProperties.enabled is false
    // so we could just set _guaranteedEnabled to true, but lets be thorough as at
    // some point we may want to have sendADMessage() be responsible for throwing all
    // errors. As it is, when publisher properties enabled is false, the session-fsm
    // throws an error and when the message-spool is shutdown (close-flow received) the
    // publisher-fsm thtows and error.
    this._guaranteedEnabled = properties.enabled;
    this._sendWindow = properties.windowSize;
    this._resetConnectedInfo();
    this._notifiedWindowClosed = false;
    // We need a boolean to track the transport flow
    // controlled state. prepareAdMessageAndSend is called by the
    // session to prepare a message for publish and we
    // need to return whether or not we are flow controlled
    // without invoking the FSM or calling methods on the
    // FSM.
    // We consider all down states and all resending states equal
    // to flow-controlled as in all states me must queue the message
    // to the unacked list and not attempt to send directly.
    // This is strictly a performance issue.
    this._transportFlowControlled = true;

    this.initial(function onInitial() {
      return this.transitionTo(fsm.PublisherUnbound,
                               function (context) {
                                 LOG_TRACE(("Starting " + (context.getStateMachine().getName())));
                               }
      );
    });

    fsm.unhandledEventReaction(function onUnhandledEvent(event) {
      switch (event.getName()) {
        case PublisherFSMEventNames.FLOW_UNBOUND:
          // the router has closed the flow, likely due to operator
          // shutdown on the message spool. Throw on any attempt
          // to publish
          this._guaranteedEnabled = false;
          this._publisher.emit(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN);
          return this.transitionTo(
            fsm.PublisherUnbound,
            function (context) {
              LOG_TRACE(("Received close publisher for " + (context.getStateMachine().getName())));
            });
        case PublisherFSMEventNames.DISPOSE:
          LOG_TRACE('Received dispose request');
          break;
        case PublisherFSMEventNames.TRANSPORT_FULL:
          LOG_TRACE('Received TRANSPORT_FULL');
          break;
        case PublisherFSMEventNames.CAN_SEND:
          // This is ok because the session just sends the publisher CAN_SEND whenever received
          // from transport, even if the publisher is not in use, or hasn't caused the flow control
          LOG_TRACE('Received CAN_SEND when not flow controlled');
          break;
        default:
          LOG_TRACE(("Ignoring event " + (event.getName())));
      }
      return this;
    });

    fsm.PublisherUnbound = new State({
      name:          PublisherStateNames.UNBOUND,
      parentContext: fsm,
    }, {
      emitDownAndBindWaiting: function emitDownAndBindWaiting() {
        LOG_TRACE('Emit down and bind waiting');
        publisher.emit(MessagePublisherEventName.DOWN);
        publisher.emit(PrivateFlowEventName.BIND_WAITING);
      },
    })
      .entry(function onEntry() {
        this.emitDownAndBindWaiting();
        fsm._bindRetryCount = properties.bindRetryCount;
      })
      .reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbind() {
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.SESSION_UP, function onSessionUp() {
        return this.transitionTo(fsm.PublisherOpenFlowSent);
      });

    fsm.PublisherOpenFlowSent = new State({
      name:          PublisherStateNames.OPENFLOWSENT,
      parentContext: fsm,
    }, {
      emitOpenFlowFailedError: function emitOpenFlowFailedError(details) {
        publisher.emit(MessagePublisherEventName.CONNECT_FAILED_ERROR, details);
      },
      /**
       * @param {AdProtocolMessage} adpMsg An OPENFLOW response.
       * @description Handle an incoming Guaranteed Messaging Protocol Message.
       * @returns {?} The result of processing an event, or null if no event was dispatched.
       * @private
       */
      handleOpenFlowResponse: function handleOpenFlowResponse(adpMsg) {
        var smfRespHeader = adpMsg.smfHeader;
        var respCode = smfRespHeader.pm_respcode;
        /*
         * Assured Control Protocol messages are received on publisher and consumer flows. The
         * message types for each are unique, so we can determine whether it is a publisher or
         * consumer by message type.  A specific publisher or consumer is found by the flowId, or
         * by the correlation tag in the case of OPEN-FLOW (publisher) or BIND (consumer) responses.
         */
        if (adpMsg.msgType !== SMFLib.SMFAdProtocolMessageType.OPENPUBFLOW) {
          return fsm.processEvent(new PublisherFSMEvent(
              { name: PublisherFSMEventNames.FLOW_FAILED },
              {
                returnCode:  respCode,
                description: ("Unexpected response: " + (SMFLib.SMFAdProtocolMessageType.describe(adpMsg.msgType))),
              }
          ));
        }

        /*
         * The response code will indicate whether we create a PUB_FLOW_UP (200 OK) event
         * or a PUB_FLOW_FAIL (any other response) event, or treat this as an invalid
         * message (received a OPEN-PUB-FLOW request).
         */

        if (respCode === null) {
          // Drop message and increment stats
          publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          LOG_DEBUG(("Drop Open-Publisher-Flow Request message on sessionId 0x" + (sessionInterface.sessionIdHex)));
          return null;
        }

        if (respCode !== 200) {
          var respStr = smfRespHeader.pm_respstr;
          var mappedSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respStr);
          return fsm.processEvent(new PublisherFSMEvent(
            { name: PublisherFSMEventNames.FLOW_FAILED },
            {
              subcode:     mappedSubcode,
              returnCode:  respCode,
              description: respStr,
            })
          );
        }

        LOG_TRACE('Handling OPENPUBFLOW message');

        // typical response: { lastmsgidacked window flowid flowname publisher_id }

        var lastMsgIDAcked = adpMsg.getLastMsgIdAcked();
        var window = adpMsg.getWindow();
        var flowId = adpMsg.getFlowId();
        var flowName = adpMsg.getFlowName();
        var publisherId = adpMsg.getPublisherId();

        LOG_DEBUG(("OPENPUBFLOW response attributes: lastMsgIDAcked=" + lastMsgIDAcked + " window=" + window + " flowId=" + flowId + " flowName=" + flowName + " publisherId=" + publisherId));

        LOG_TRACE(("Local before handling response: " + (fsm._messageIds)));

        if (window === undefined) {
          return fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  { description: 'Window parameter not found' })
          );
        }
        if (window > this._windowSize) {
          return fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  { description: 'Invalid window negotiation' })
          );
        }
        // reduce sendWindow by the size of unAckedList but do not reduce below zero
        fsm._sendWindow = window - fsm._unackedList.length;
        if (fsm._sendWindow < 0) { fsm._sendWindow = 0; }

        // update publisher info before renumbering
        Object.assign(fsm._publisher, {
          name: flowName,
          flowId: flowId,
          publisherId: publisherId,
        });
        // we may have been disabled by a previous closeFlow messsage, now that
        // we know hte message spool is enabled again, set _guaranteedEnabled back
        // to true
        fsm._guaranteedEnabled = true;

        if ((fsm._connectReason === ConnectReason.INIT) ||
          (fsm._connectReason === ConnectReason.FAILOVER)) {
          // reset 'lastSent' before renumbering
          fsm._messageIds.setLastSent(lastMsgIDAcked);

          LOG_DEBUG(("Renumbering unacked/unsent messages: fsm._messageIds=" + (fsm._messageIds) + ", lastMsgIDAcked=" + lastMsgIDAcked + ", type=" + (fsm._connectReason)));
          if (fsm._connectReason === ConnectReason.FAILOVER) {
            publisher.emit(MessagePublisherEventName.FLOW_NAME_CHANGED, {
              messages: [].concat( fsm._unackedList ),
              count:    fsm._unackedList.length,
            });
          }
          fsm._connectReason = ConnectReason.RESUME;
          fsm._unackedList.forEach(function (message) {
            var oldId = message.getGuaranteedMessageId();
            fsm._renumber(message);
            LOG_TRACE(("Renumbering message ID: from " + oldId + " to " + (message.getGuaranteedMessageId())));
            fsm._messageIds.setLastSent(message.getGuaranteedMessageId());
          });
        } else {
          // the flowId changes on every open Flow so set it properly in the unacked List
          // if the router has enabled 'Allow Unknown Publisher Flow' the publisherId can
          // change too.  It's quuestionable what we do here at all, but to be compatible with
          // other APIs, set the publisherID just in case.
          // TODO: revisit this code in the next release, we could have the getter for
          // publisherID retrieve it from the flow (as CCSMP does) at encoding time and
          // avoid this. In the minimum consider gathering these setters into a function
          // that is invoked both here and by 'renumber'
          fsm._unackedList.forEach(function (message) {
            message.setFlowId(flowId);
            message.setPublisherId(publisher.publisherId);
            LOG_TRACE(("Set FlowId to " + flowId + " in msg# " + (message.getGuaranteedMessageId())));
          });
        }

        if (fsm._unackedList.length) {
          fsm._handleAck(lastMsgIDAcked, false, adpMsg, true);
          // the starting point for retransmitting.  If lastMsgIdAcked doesn't
          // ack anything this does not get updates, causing us to possible send
          // messages out of order, or not start sending at all
          fsm._firstUnackedToSend = fsm._unackedList[0];
        } else {
          fsm._messageIds.lastAcked = Long.fromValue(lastMsgIDAcked);
        }
        LOG_TRACE(("Local after applying lastMsgIDAcked: " + (fsm._messageIds)));

        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_UP }));
      },
      /**
       * @returns {?} The result of processing an BIND_TIMEOUT event
       * @private
       */
      handleOpenFlowTimeout: function handleOpenFlowTimeout() {
        LOG_INFO('Open publisher connection timeout');
        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.BIND_TIMEOUT }));
      },
      handleUnknownFlowName: function handleUnknownFlowName() {
        LOG_INFO('Flow name unknown, republish required');
        // Don't send the FLOW_NAME_CHANGED message yet -- it specifically indicates
        // that duplicate messages should be expected. Wait until the flow is successfully
        // connected and messages are being renumbered.
        fsm._resetConnectedInfo(true);
        return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
      },
      /**
       * Send a Publisher Open Flow Request.
       * @private
       */
      sendOpenFlow: function sendOpenFlow() {
        var this$1 = this;

        var correlationTag = sessionInterface.getCorrelationTag();
        var openPubFlowMsg = SMFLib.AdProtocolMessage.getOpenMessagePublisher(
          fsm._messageIds.lastAcked,
          fsm._messageIds.lastSent,
          properties.windowSize,
          fsm._publisher._flowName,
          correlationTag
        );
        sessionInterface.sendControl(openPubFlowMsg);
        sessionInterface.enqueueRequest(correlationTag,
                                        function () { return this$1.handleOpenFlowTimeout(); },
                                        properties.connectTimeoutInMsecs,
                                        null,
                                        function (rxMsgObj) { return this$1.handleOpenFlowResponse(rxMsgObj); });
        LOG_TRACE('Sent open publisher connection');
      },
    })
      .entry(function onEntry() {
        this.sendOpenFlow();
      })
      .reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(fsm.PublisherCloseFlowSent);
      })
      .reaction(PublisherFSMEventNames.FLOW_UP, function onFlowUp() {
        return this.transitionTo(fsm.PublisherUp);
      })
      .reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.BIND_TIMEOUT, function onOpenFlowTimeout() {
        if (fsm._bindRetryCount > 0) {
          fsm._bindRetryCount--;
          return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
        }
        this.emitOpenFlowFailedError({
          subcode:     ErrorSubcode.TIMEOUT,
          description: 'Open publisher connection failed due to timeout',
        });
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.FLOW_FAILED, function onFlowFailed(pEvent) {
        var subcode = pEvent.subcode;
        var returnCode = pEvent.returnCode;
        var description = pEvent.description;
        switch (pEvent.subcode) {
          case ErrorSubcode.UNKNOWN_FLOW_NAME:
            // DR or long HA failover
            return this.handleUnknownFlowName();
          // case ErrorSubcode.GM_NOT_READY: Fail the session
          default:
            this.emitOpenFlowFailedError({
              event: pEvent,
              subcode: subcode,
              returnCode: returnCode,
              description: description,
            });
            // Otherwise, the flow is invalid
            fsm._resetConnectedInfo();
        }
        return this.transitionTo(fsm.PublisherUnbound);
      });

    fsm.PublisherCloseFlowSent = new State({
      name:          PublisherStateNames.CLOSEFLOWSENT,
      parentContext: fsm,
    }, {
      handleCloseFlowResponse: function handleCloseFlowResponse(response) {
        var smfRespHeader = response.smfHeader;
        var respCode = smfRespHeader.pm_respcode;

        if (response.msgType !== SMFLib.SMFAdProtocolMessageType.CLOSEPUBFLOW) {
          return fsm.processEvent(new PublisherFSMEvent(
            { name: PublisherFSMEventNames.FLOW_FAILED },
            {
              returnCode:  respCode,
              description: ("Unexpected response: " + (SMFLib.SMFAdProtocolMessageType.describe(response.msgType))),
            }));
        }

        if (respCode === null) {
          // Drop message  and increment stats
          publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          LOG_DEBUG(("Drop Close-Publisher-Flow Request message on sessionId 0x" + (sessionInterface.sessionIdHex)));
          return null;
        }

        if (respCode !== 200) {
          fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  {
                                    returnCode:  respCode,
                                    description: smfRespHeader.pm_respstr,
                                  }));
        }

        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_UNBOUND }));
      },

      handleCloseFlowTimeout: function handleCloseFlowTimeout() {
        LOG_INFO('Close publisher connection timeout.');
        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.UNBIND_TIMEOUT }));
      },

      sendCloseFlow: function sendCloseFlow() {
        var this$1 = this;

        var correlationTag = sessionInterface.getCorrelationTag();
        var closePubFlowMsg = SMFLib.AdProtocolMessage.getCloseMessagePublisher(
          fsm._publisher.flowId,
          correlationTag
        );
        sessionInterface.sendControl(closePubFlowMsg);
        sessionInterface.enqueueRequest(correlationTag,
                                        function () { return this$1.handleCloseFlowTimeout(); },
                                        properties.connectTimeoutInMsecs,
                                        null,
                                        function (rxMsgObj) { return this$1.handleCloseFlowResponse(rxMsgObj); });
        LOG_TRACE('Sent close publisher connection');
      },
    })
      .entry(function onEntry() {
        this.sendCloseFlow();
        return this;
      })
      .reaction(PublisherFSMEventNames.ACK, function onAck(event) {
        fsm._handleAckEvent(event);
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbound() {
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.FLOW_FAILED, function onCloseFlowFailed(/*pEvent*/) {
        this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.UNBIND_TIMEOUT, function onCloseFlowTimeout() {
        return this.transitionTo(fsm.PublisherCloseFlowSent);
      });

    fsm.PublisherUp = new State({
      name:          PublisherStateNames.UP,
      parentContext: fsm,
    }, {
      emitFlowUp: function emitFlowUp() {
        publisher.emit(MessagePublisherEventName.UP);
      },
    })
      .initial(function initial() {
        return this.transitionTo(
          fsm._unackedList.length
            ? fsm.PublisherRetransmitting
            : fsm.PublisherDataXfer
        );
      })
      .entry(function onEntry() {
        var this$1 = this;

        // The state isn't changed on entry, so don't emit yet.
        LOG_DEBUG('Flow is UP');
        fsm._scheduleStateEvents(fsm.PublisherUp, function () { return this$1.emitFlowUp(); });
        return this;
      })
      .reaction(PublisherFSMEventNames.ACK, function onAck(event) {
        LOG_DEBUG('Ack received');
        fsm._handleAckEvent(event);
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.ACK_TIMEOUT, function onAckTimeout() {
        // the starting point when we get the CAN_SEND
        fsm._firstUnackedToSend = fsm._unackedList[0];
        return this.transitionTo(fsm.PublisherRetransmitting);
      })
        .reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
          return this.transitionTo(fsm.PublisherCloseFlowSent);
        })
        .reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
          return this.transitionTo(fsm.PublisherUnbound);
        })
        .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onWindowClosed() {
          return this.internalTransition();
        });

    fsm.PublisherDataXfer = new State({
      name:          PublisherStateNames.DATA_XFER,
      parentContext: fsm.PublisherUp,
    })
      .entry(function () {
        // publisher is up and capable of sending GM messages directly from the application
        fsm._transportFlowControlled = false;
        // TODO: We don't need a CAN_SEND if we're going to emit a FLOW_UP,
        // but we need a better way to manage these deferred events.
        fsm._scheduleStateEvents(fsm.PublisherDataXfer, function () { return fsm._maybeEmitCanSend(); });
      })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        return this.transitionTo(fsm.PublisherFlowControlled);
      })
      .exit(function () {
        // publisher cannot send messages to transport and must queue in unAckedList until
        // re-entering PublisherDataXfer
        // set a FSM boolean that is checked in prepareADMessageAndSend() we
        // need to avoid FSM interactions on the fast path so resort to
        // this boolean.
        fsm._transportFlowControlled = true;
      });

    fsm.PublisherFlowControlled = new State({
      name:          PublisherStateNames.FLOW_CONTROLLED,
      parentContext: fsm.PublisherUp,
    })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        // Unusual event, as only the FSM can send messages when we're in flow-controlled state
        LOG_INFO('Attempt to send while flow controlled');
        // Fall out and do the action for PublisherUp
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.CAN_SEND, function onCanSend() {
        //
        // start sending from tune unAcked list.
        return this.transitionTo(fsm.PublisherRetransmitting);
      });

    fsm.PublisherRetransmitting = new State({
      name:          PublisherStateNames.RETRANSMITTING,
      parentContext: fsm.PublisherUp,
    }, {
      retransmit: function retransmit() {
        try {
          fsm._resendFromUnacked();
        } catch (ex) {
          // Resend failed:
          if (ex instanceof OperationError && ex.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
            LOG_DEBUG('Publisher resendFromUnacked blocked due to insufficient space, wait for CAN_SEND');
            fsm.processEvent(
              new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
          } else {
            // send failed.  Fail the publisher
            LOG_INFO(("Publisher resendFromUnacked failed: " + ex));
            fsm.processEvent(
              new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED }));
          }
        }
      },
    })
      .entry(function onEntry() {
        this.retransmit();
      })
      .reaction(PublisherFSMEventNames.RESEND_COMPLETE, function onResendComplete() {
        return this.transitionTo(fsm.PublisherDataXfer);
      })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        // Transport flow controlled while resending/recovering from flow control. Go
        // to flow controlled state and wait for CAN_SEND
        LOG_DEBUG(("Transport full while retransmitting, unacked remaining: " + (fsm._unackedList.length)));
        // Fall out and do the action for PublisherUp
        return this.transitionTo(fsm.PublisherFlowControlled);
      });
  }

  if ( StateMachine ) PublisherFSM.__proto__ = StateMachine;
  PublisherFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  PublisherFSM.prototype.constructor = PublisherFSM;

  PublisherFSM.prototype.isDisconnected = function isDisconnected () {
    if (!this.getCurrentState()) { return true; }
    return !!this.getActiveState(PublisherStateNames.UNBOUND);
  };

  /**

   * Prepare and send a Guaranteed Message. This method updates FSM variables including
   * lastSendMessage.
   *
   * @private
   * @param {Message} dataMsg The message to prepare
   * @returns {TransportReturnCode} return the status from the transport send
   */
  PublisherFSM.prototype.prepareAdMessageAndSend = function prepareAdMessageAndSend (dataMsg) {
    if (!this._guaranteedEnabled) {
      throw new OperationError('Session does not provide Guaranteed Message Publish capability',
        ErrorSubcode.GM_UNAVAILABLE,
        'close flow received from message-router');
    }
    if (this._sendWindow <= 0) {
      this._publisher.incStat(StatType.TX_WINDOW_CLOSED);
      this._notifiedWindowClosed = true;
      throw new OperationError(
        'Guaranteed Message Window Closed',
        ErrorSubcode.INSUFFICIENT_SPACE
      );
    }

    var unackedList = this._unackedList;
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;

    --this._sendWindow;

    this._renumber(dataMsg);
    var dupMsg = dataMsg.clone();
    unackedList.push(dupMsg);
    // Update the messgeIds, lastSend/next values only on a successful send or enqueue,
    // from this point on we will return OK from this send method.
    var msgId = dupMsg.getGuaranteedMessageId();
    this._messageIds.setLastSent(msgId);
    LOG_TRACE(("Prepare and send AD message ID = " + msgId + ", \n      unackedListSize = " + (unackedList.length) + ", sendWindow = " + (this._sendWindow)));
    // Note that the transport sender can be flow controlled at the transport
    // level, which means the message should not be sent. So simply return
    // We also consider set-up/down-states as _transportFlowControlled. We must be up
    // and not retransmitting to
    // send directly from application space.
    if (this._transportFlowControlled) {
      // we may receive acknowledgements while transport flow controlled which can
      // cause our firstUnAckedToSend to become undefined, if this is the first message
      // queued in that case, set firstUnAckedToSend
      if (this._firstUnackedToSend === undefined) {
        this._firstUnackedToSend = dupMsg;
      }
      return TransportReturnCode.OK;
    }
    // We use the session sendToTransport directly which may throw or  otherwise
    // return an error. If so, catch the eror and remove the message from the unackedlist
    // before rethrowing the error.
    var returnCode;
    try {
      returnCode = this._sessionInterface.sendToTransport(dupMsg);
      if (returnCode !== TransportReturnCode.OK) {
        if (returnCode === TransportReturnCode.NO_SPACE) {
          returnCode = TransportReturnCode.OK;
          this._firstUnackedToSend = dupMsg;  // the starting point when we get the CAN_SEND
          this.processEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
        } else {
          //
          LOG_DEBUG(("prepareAdMessageAndSend: saw returnCode = " + returnCode));
        }
      } else {
        // The message has successfully been sent once. Set the redelivered flag in case we need to
        // resend it later.
        dupMsg.setRedelivered(true);
      }
      // TBD: Should we start AckTimer when flow controlled?
      this._startAckTimer();
    } catch (ex) {
      if (ex instanceof OperationError) {
        LOG_DEBUG(("prepareAdMessageAndSend: caught OperationError: " + (ErrorSubcode.describe(ex.subcode)) + " - " + (ex.message)));
        // OperationErrors are encoding or other errors caused by the field contents the
        // application has set on the message.  So we throw the error back at the
        // application after undoing the queueing operations.
        unackedList.pop();
        this._messageIds.setLastSent(dupMsg.getGuaranteedPreviousMessageId());
        ++this._sendWindow;
        throw (ex);
      } else {
        LOG_DEBUG(("prepareAdMessageAndSend: caught " + (ex.message)));
      }
    }
    return TransportReturnCode.OK;
  };

  PublisherFSM.prototype._handleAckEvent = function _handleAckEvent (event) {
    this._publisher.incStat(StatType.TX_ACKS_RXED);
    this._handleAck(event.ack || event.nack, !!event.nack, event.ctrlMessage);
  };

  PublisherFSM.prototype._handleAck = function _handleAck (id, nack, ctrlMessage, openFlow) {
    var this$1 = this;
    if ( ctrlMessage === void 0 ) ctrlMessage = undefined;
    if ( openFlow === void 0 ) openFlow = false;

    var ref = this;
    var messageIds = ref._messageIds;
    var unackedList = ref._unackedList;
    var ref$1 = this.logger;
    var LOG_DEBUG = ref$1.LOG_DEBUG;
    var LOG_INFO = ref$1.LOG_INFO;

    if (messageIds.lastAcked.gte(id)) {
      if (openFlow) {
        LOG_DEBUG(("Implicit acks up to date: remote ack for " + id + ", local ids " + (this._messageIds)));
      } else {
        LOG_INFO(("Dropping ack: remote ack for " + id + ", local ids " + (this._messageIds)));
      }
      return;
    }

    var reportAcked = [];

    // Assumption: the unacked message list is in increasing order of message ID.
    // The assured message ID should be automatically generated, immutable and
    // monotonically increasing.

    // While the acked ID is greater than an element at the beginning of the unacked list...
    while (unackedList.length &&
           id.gte(unackedList[0].getGuaranteedMessageId())) {
      // That unacked message is now acked. Shift it off and append to list of acked.
      reportAcked.push(unackedList.shift());
    }

    // if we have removed the firstUnacked, reset it to the beginning of the list
    if (unackedList.indexOf(this._firstUnackedToSend) === -1) {
      this._firstUnackedToSend = unackedList[0];
    }


    // Recover some window space from the acked IDs.
    this._sendWindow += reportAcked.length;
    LOG_DEBUG('Send window size is now', this._sendWindow);


    // The last acked ID is now the one we received.
    // Don't let an exception in event dispatching prevent this from being set -- do it now.
    messageIds.lastAcked = id;

    // If we're NACKing, it's only the last message.
    var reportNacked = nack ? reportAcked.pop() : null;

    // Any ACKs?
    // reportAcked is constant from here on
    var numAcked = reportAcked.length;
    if (numAcked) {
      if (this._acknowledgeMode === MessagePublisherAcknowledgeMode.PER_MESSAGE) {
        LOG_DEBUG(("Ack received: lastAckedMsgId=" + id + ", numAckedMsgs=" + numAcked + ", numUnackedMsgs=" + (unackedList.length)));
        for (var i = 0; i < numAcked; ++i) {
          this$1._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, reportAcked[i]);
        }
      } else {
        var lastAckedMessage = reportAcked[numAcked - 1];
        LOG_DEBUG(("Acking single message with ID " + (lastAckedMessage.getGuaranteedMessageId()) + " from router ack on " + id));
        this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, lastAckedMessage);
      }
    }

    // Terminating NACK?
    if (reportNacked) {
      LOG_DEBUG(("Nacking single message with ID " + (reportNacked.getGuaranteedMessageId()) + " from router ack on " + id));
      this._publisher.emit(MessagePublisherEventName.REJECTED_MESSAGE, reportNacked, ctrlMessage);
    }

    LOG_DEBUG('Unacked messages remaining: ', unackedList.length);

    if (unackedList.length) {
      // There are more messages to be acked. Reset the ack timer.
      this._resetAckTimer();
    } else {
      this._clearAckTimer();
    }
    //
    // send can-send to applicatino if necessary.
    this._maybeEmitCanSend();
  };

  PublisherFSM.prototype._maybeEmitCanSend = function _maybeEmitCanSend () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    if (!this._notifiedWindowClosed) { return; }
    if (this._sendWindow === 0) {
      // Should log this since it is called AFTER the state change
      LOG_TRACE('Suppressing CAN_SEND with zero window available');
      return;
    }
    this._notifiedWindowClosed = false; // Set before emitting in case we re-enter
    this._publisher.emit(MessagePublisherEventName.CAN_SEND);
  };

  PublisherFSM.prototype._resendFromUnacked = function _resendFromUnacked () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    var LOG_DEBUG = ref.LOG_DEBUG;
    // We choose to start the ack timer after the message resend. The resend could
    // take longer than the ack timeout in poor conditions.
    //
    // If any message is successfully resent, we need to restart the ack timer,
    // even if we are throwing.
    var list = this._unackedList;
    var resendIndex = list.indexOf(this._firstUnackedToSend);
    if (resendIndex === -1) {
      // first Unacked may be null if all have been resent alreadygrunt -
      // in which case the list  should be empty
      if (this._firstUnackedToSend) {
        LOG_ERROR(("Could not find first Unacked Messages in unacked message list: msgId = " + (this._firstUnackedToSend.getGuaranteedMessageId)));
      }
      if (list.length === 0) {
        // Nothing to resend: return to DataXfer
        LOG_DEBUG(("Nothing to resend: " + (this._messageIds.toString())));
        this.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.RESEND_COMPLETE })
        );
      }
      return;
    }
    LOG_DEBUG(("Resending unacked messages from " + resendIndex + " to " + (list.length - 1) + ": "),
              list.map(function (m) { return m.getGuaranteedMessageId().toString(); }));
    while (resendIndex < list.length) {
      if (list[resendIndex].getPublisherId() !== this$1._publisher.publisherId) {
        LOG_ERROR(("Resending on invalid publisherId '" + (list[resendIndex].getPublisherId()) + "'when it should be '" + (this$1._publisher.publisherId) + "'"));
      }
      var returnCode = this$1._sessionInterface.sendData(list[resendIndex]);
      if (returnCode === TransportReturnCode.NO_SPACE) {
        // the starting point when we get the CAN_SEND from the transport
        this$1._firstUnackedToSend = list[resendIndex];
        LOG_DEBUG('Publisher sendMessage blocked due to insufficient space, wait for CAN_SEND');
        this$1.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
        return;
      }
      if (returnCode !== TransportReturnCode.OK) {
        // session-FSM is already processing the error
        return;
      }
      // The message has successfullly been sent once. Set the redelivered flag in case we need to
      // resend it later
      list[resendIndex].setRedelivered(true);
      resendIndex++;
      this$1._startAckTimer();
    }
    // Resend successful: return to DataXfer
    LOG_DEBUG(("Resend complete: " + (this._messageIds.toString())));
    this.processEvent(
      new PublisherFSMEvent({ name: PublisherFSMEventNames.RESEND_COMPLETE })
    );
  };

  PublisherFSM.prototype._resetConnectedInfo = function _resetConnectedInfo (failover) {
    if ( failover === void 0 ) failover = false;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Resetting connected flow info');

    if (this._ackTimer) { this._clearAckTimer(); }

    Object.assign(this, {
      _messageIds: new MessageIds(),
    });

    Object.assign(this._publisher, {
      publisherId: undefined,
      flowId:      undefined,
      flowName:    null,
    });

    if (failover) {
      this._connectReason = ConnectReason.FAILOVER;
    } else {
      // Full reset
      this._unackedList = [];
      this._connectReason = ConnectReason.INIT;
    }
  };

  PublisherFSM.prototype._clearAckTimer = function _clearAckTimer () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE(("Clear ack timer " + (this._ackTimer ? this._ackTimer : 'undefined or null or zero')));
    if (!this._ackTimer) { return; }
    clearTimeout(this._ackTimer);
    this._ackTimer = null;
  };

  PublisherFSM.prototype._emitStateEvents = function _emitStateEvents () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE('Emitting deferred state events');
    while (this._stateEvents.length) {
      var pair = this$1._stateEvents.shift();
      var state = pair[0];
      var event = pair[1];
      // If the state requesting this event is still active...
      if (this$1.getActiveState(state.getName())) {
        // then do its action
        event.apply(state);
      }
    }
  };

  /**
   * @private
   */
  PublisherFSM.prototype._handleAckTimeout = function _handleAckTimeout () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE('Ack Timeout');
    this._ackTimer = null;
    this._publisher.incStat(StatType.TX_ACK_TIMEOUT);
    this.processEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.ACK_TIMEOUT }));
  };

  /**
   * If the remote flow changes, any remote state applied to the unacked messages needs to
   * be reapplied.
   *
   * @param {solace.Message} message The message to renumber.
   * @private
   */
  PublisherFSM.prototype._renumber = function _renumber (message) {
    var messageIds = this._messageIds;
    var current = messageIds.next;
    message.setGuaranteedPreviousMessageId(messageIds.lastSent);
    message.setGuaranteedMessageId(current);

    var publisher = this._publisher;
    message.setFlowId(publisher.flowId);
    message.setPublisherId(publisher.publisherId);
  };

  PublisherFSM.prototype._resetAckTimer = function _resetAckTimer () {
    this._clearAckTimer();
    this._startAckTimer();
  };

  PublisherFSM.prototype._scheduleStateEvents = function _scheduleStateEvents (state, event) {
    var this$1 = this;

    this._stateEvents.push([state, event]);
    this._setPostEventAction(function () { return this$1._emitStateEvents(); }, 'Emit state events');
  };

  PublisherFSM.prototype._setPostEventAction = function _setPostEventAction (action, desc) {
    var this$1 = this;
    if ( desc === void 0 ) desc = 'No action';

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;
    if (this._postEventAction && this._postEventAction.desc === desc) {
      LOG_DEBUG('Keeping same post event action');
      return;
    }

    if (this._postEventAction && this._postEventAction.desc) {
      LOG_WARN(("Replacing post event action " + (this._postEventAction.desc) + " with " + desc));
    }
    this._postEventAction = { action: action || (function () {}), desc: desc };
    this.setPostEventAction(function () {
      this$1._postEventAction.action();
      this$1._postEventAction = null;
    });
  };

  /**
   * @private
   */
  PublisherFSM.prototype._startAckTimer = function _startAckTimer () {
    var this$1 = this;

    // const { LOG_TRACE } = this.logger;
    // LOG_TRACE(`Start ack timer ${this._ackTimer ? this._ackTimer : 'undefined or null or zero'
    //           }: ${this._acknowledgeTimeoutInMsecs} ms`);
    if (this._ackTimer) { return; }
    this._ackTimer = setTimeout(function () { return this$1._handleAckTimeout(); },
                                this._acknowledgeTimeoutInMsecs);
  };

  return PublisherFSM;
}(StateMachine));

module.exports.PublisherFSM = PublisherFSM;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * @enum {string}
 * State names on the Publisher FSM
 ********************************************************************************/
var PublisherStateNames = {
  UNBOUND:         'PublisherUnbound',
  OPENFLOWSENT:    'PublisherOpenFlowSent',
  UP:              'PublisherUp',
  FAILED:          'PublisherFailed',
  CLOSEFLOWSENT:   'PublisherCloseFlowSent',
  DATA_XFER:       'PublisherDataXfer',
  FLOW_CONTROLLED: 'MessagePublisherFlowControlled',
  RETRANSMITTING:  'PublisherRetransmitting',
};

module.exports.PublisherStateNames = Enum.new(PublisherStateNames);


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var clone = __webpack_require__(149);
var ref = __webpack_require__(10);
var SDTCodec = ref.Codec;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(5);
var Destination = ref$2.Destination;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(1);
var LOG_DEBUG = ref$4.LOG_DEBUG;
var ref$5 = __webpack_require__(58);
var MessageCacheStatus = ref$5.MessageCacheStatus;
var ref$6 = __webpack_require__(59);
var MessageDeliveryModeType = ref$6.MessageDeliveryModeType;
var ref$7 = __webpack_require__(40);
var MessageDumpFlag = ref$7.MessageDumpFlag;
var ref$8 = __webpack_require__(60);
var MessageDumpUtil = ref$8.MessageDumpUtil;
var ref$9 = __webpack_require__(104);
var MessageType = ref$9.MessageType;
var ref$10 = __webpack_require__(61);
var MessageUserCosType = ref$10.MessageUserCosType;
var ref$11 = __webpack_require__(7);
var Parameter = ref$11.Parameter;
var ref$12 = __webpack_require__(10);
var SDTField = ref$12.SDTField;
var SDTFieldType = ref$12.SDTFieldType;
var SDTMapContainer = ref$12.SDTMapContainer;

var utf8ToUcs2 = Convert.utf8ToUcs2;
var isBoolean = Parameter.isBoolean;
var isEnumMember = Parameter.isEnumMember;
var isInstanceOf = Parameter.isInstanceOf;
var isInstanceOfOrNothing = Parameter.isInstanceOfOrNothing;
var isNumberOrNothing = Parameter.isNumberOrNothing;
var isStringOrNothing = Parameter.isStringOrNothing;

// When a message is cloned for sending,
// * We assume that it may NOT include circular references.
//   These are also unsupported in the encoder.
// * We assume that all properties to be cloned are enumerable.
//   This has significant (~10% AD send rate) performance impact.

var MESSAGE_CLONE_OPTIONS = { circular: false, includeNonEnumerable: false };

/**
 * Function called on construct/reset. Sets the initial values for fields that have them.
 * @param {Message} message The message to initialize
 * @internal
 */
function initMessage(message) {
  message._deliveryMode = MessageDeliveryModeType.DIRECT;
  message._userCos = MessageUserCosType.COS1;
  message._cacheStatus = MessageCacheStatus.LIVE;
  message._priority = undefined;
}

/**
 * Function called on reset only. Clears every field in the message. Call #initMessage
 * to set initial values.
 * @param {Message} message The message to clear
 * @internal
 */
function clearMessage(message) {
  var fields = Object.keys(message);
  fields.forEach(function (f) { return delete message[f]; });
}

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactory.createMessage}</b>
 * <p>
 * A message is a container that can be used to store and send messages to and from the
 * Solace Message Router.
 *
 * Applications manage the lifecycle of a message; a message is created by calling
 * {@link solace.SolclientFactory.createMessage} and is freed by dereferencing it.
 *
 * API operations that cache or mutate messages always take a copy. A message may
 * be created, mutated by the API user, and sent multiple times.
 *
 * The Message Object provides methods to manipulate the common Solace
 * message header fields that are optionally sent in the binary metadata
 * portion of the Solace message.
 *
 * Applications can also use the structured data API {@link solace.Message#setSdtContainer}
 * to add containers (maps or streams) and their fields to the binary payload or
 * to the User Property map contained within the binary metadata.
 *
 * This does not prevent applications from ignoring these
 * methods and sending payload in the binary payload as an opaque binary field for
 * end-to-end communications
 *
 * @memberof solace
 */
var Message = function Message() {
  initMessage(this);
};

var prototypeAccessors = { isAcknowledged: {},binaryMetadataChunk: {},smfHeader: {},hasAutoSequenceNumber: {},hasAutoSenderTimestamp: {} };

/**
 * Gets the payload type ({@link solace.MessageType}) of the message. A message has a
 * structured payload if one was attached via {@link solace.Message#setSdtContainer} otherwise
 * if the payload is attached via {@link Message@setBinaryAttachment} then it
 * is unstructured ((@link solace.MessageType#BINARY})
 *
 * @returns {solace.MessageType} The structured payload type.
 * @default {solace.MessageType.BINARY}
 */
Message.prototype.getType = function getType () {
  return this._messageType || MessageType.BINARY; // This is OK; BINARY === 0.
};

/**
 * Sets the application-provided message ID.
 * @param {?String} value The new value for the application-provided message ID.
 */
Message.prototype.setApplicationMessageId = function setApplicationMessageId (value) {
  this._applicationMessageId = isStringOrNothing('applicationMessageId', value);
};

/**
 * Gets the application-provided message ID.
 * @returns {?String} The application provided message ID.
 */
Message.prototype.getApplicationMessageId = function getApplicationMessageId () {
  return this._applicationMessageId;
};

/**
 * Sets the application message type. This value is used by applications
 * only, and is passed through the API and Solace Message Router untouched.
 * @param {?String} value The application message type.
 */
Message.prototype.setApplicationMessageType = function setApplicationMessageType (value) {
  this._applicationMessageType = isStringOrNothing('applicationMessageType', value);
};

/**
 * Gets the application message type. This value is used by applications
 * only, and is passed through the API and Solace Message Router untouched.
 * @returns {?String} The application message type.
 */
Message.prototype.getApplicationMessageType = function getApplicationMessageType () {
  return this._applicationMessageType;
};

/**
 * Gets the binary attachment part of the message. The binary attachment
 * is returned as a string, wherein each character has a code in the range
 * 0-255 representing the value of a single received byte at that position.
 *
 * @returns {?String} A string representing the binary attachment.
 */
Message.prototype.getBinaryAttachment = function getBinaryAttachment () {
  return this._binaryAttachment;
};

/**
 * Sets the binary attachment part of the message. The binary attachment
 * must be a string, wherein each character has a code in the range 0-255
 * representing exactly one byte in the attachment. When this method is
 * used, the message payload type is {@link solace.MessageType#BINARY}
 * See {solace.Message#getType}.
 *
 * Applications may set the binary attachment to NULL or undefined to
 * remove the binary attachment and create a message with no payload.
 *
 * @param {?String} value Sets the binary attachment part of the message.
 */
Message.prototype.setBinaryAttachment = function setBinaryAttachment (value) {
  this._setBinaryAttachment(isStringOrNothing('binaryAttachment', value));
  this._messageType = MessageType.BINARY;
};
Message.prototype._setBinaryAttachment = function _setBinaryAttachment (value) {
  this._binaryAttachment = value;
};

/**
 * Given a Message containing a cached message, return the cache Request Id that
 * the application set in the call to {@link solace.CacheSession#sendCacheRequest}.
 *
 * @returns {?Number} The request ID of the cache request associated with this message.
 */
Message.prototype.getCacheRequestId = function getCacheRequestId () {
  return this._cacheRequestId;
};

/**
 * @private
 * @param {Number} cacheRequestID The cache request ID associated with this message
 */
Message.prototype._setCacheRequestID = function _setCacheRequestID (cacheRequestID) {
  this._cacheRequestId = cacheRequestID;
};

/**
 * Gets the correlation ID.The message Correlation Id
 * is carried in the Solace message headers unmodified by the API and
 * the Solace Message Router. This field may be used for peer-to-peer
 * message synchronization and is commonly used for correlating
 * a request to a reply. See {@link solace.Session#sendRequest}.
 * @returns {?String} The correlation ID associated with the message.
 */
Message.prototype.getCorrelationId = function getCorrelationId () {
  return this._correlationId;
};

/**
 * Sets the correlation ID. The message Correlation Id
 * is carried in the Solace message headers unmodified by the API and
 * the Solace Message Router. This field may be used for peer-to-peer
 * message synchronization and is commonly used for correlating
 * a request to a reply. See {@link solace.session#sendRequest}.
 * @param {?String} value The correlation ID to associate with the message.
 */
Message.prototype.setCorrelationId = function setCorrelationId (value) {
  this._correlationId = isStringOrNothing('correlationId', value);
};

/**
 * Gets the correlation Key. A correlation key is used to correlate
 * a message with its acknowledgement or rejection. The correlation key is an object that is
 * passed back to the client during the router acknowledgement or rejection.
 *
 * The correlation key is a local reference
 * used by applications generating Guaranteed messages. Messages that are
 * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key.
 * @returns {?Object} The correlation Key associated with the message,
 * or <code>null</code>, if unset.
 */
Message.prototype.getCorrelationKey = function getCorrelationKey () {
  return this._correlationKey || null;
};

/**
 * Sets the correlation Key. A correlation key is used to correlate
 * a message with its acknowledgement or rejection. The correlation key is an object that is
 * passed back to the client during the router acknowledgement or rejection.
 *
 * The correlation key is a local reference
 * used by applications generating Guaranteed Messages. Messages that are
 * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key. If this
 * method is used, the correlation information is returned
 * when the {@link solace.SessionEventCode#event:ACKNOWLEDGED_MESSAGE} event
 * is later received for an acknowledged message or when the
 * {@link solace.SessionEventCode#event:REJECTED_MESSAGE_ERROR} is received for a rejected
 * message.
 *
 * The API only maintains a reference to the passed object.If the application requires the
 * contents are unmodified for proper correlation, then it is the application's responsibility
 * to ensure the contents of the object are not modified.
 *
 * Important: <b>The Correlation Key is not included in the
 * transmitted message and is only used with the local API</b>
 * @param {Object} value The correlation Key to associate with the message.
 */
Message.prototype.setCorrelationKey = function setCorrelationKey (value) {
  this._correlationKey = value;
};

/**
 * Gets whether the message is configured for delivering to one client only.
 * @returns {Boolean} indicates whether the message is configured for
 * delivering to one client only.
 */
Message.prototype.isDeliverToOne = function isDeliverToOne () {
  return this._deliverToOne || false;
};

/**
 * Sets whether the message is configured for delivering to one client only.
 * @param {Boolean} value whether the message is configured for delivering to one client only.
 */
Message.prototype.setDeliverToOne = function setDeliverToOne (value) {
  this._setDeliverToOne(this._deliverToOne = isBoolean('deliverToOne', value));
};
Message.prototype._setDeliverToOne = function _setDeliverToOne (value) {
  this._deliverToOne = value;
};

/**
 * Gets the delivery mode of the message.
 * @returns {solace.MessageDeliveryModeType} representing the delivery mode of the message.
 */
Message.prototype.getDeliveryMode = function getDeliveryMode () {
  return this._deliveryMode;
};

/**
 * Sets the delivery mode of the message.
 * @param {solace.MessageDeliveryModeType} value The message delivery mode.
 */
Message.prototype.setDeliveryMode = function setDeliveryMode (value) {
  this._setDeliveryMode(isEnumMember('deliveryMode', value, MessageDeliveryModeType));
};
Message.prototype._setDeliveryMode = function _setDeliveryMode (value) {
  this._deliveryMode = value;
};

/**
 * Gets the destination to which the message was published.
 * @returns {?Destination} The destination to which a message was published.
 */
Message.prototype.getDestination = function getDestination () {
  return this._destination;
};

/**
 * Sets the destination ({@link solace.DestinationType#topic} or
 * {@link solace.DestinationType#queue}) to publish the message to.
 * @param {Destination} value The destination to publish the message to.
 */
Message.prototype.setDestination = function setDestination (value) {
  this._setDestination(isInstanceOf('destination', value, Destination));
};
Message.prototype._setDestination = function _setDestination (value) {
  this._destination = value;
};

/**
 * Indicates whether one or more messages have been discarded prior
 * to the current message. This indicates congestion discards only and
 * is not affected by message eliding.
 * @returns {Boolean} Returns true if one or more messages have been
 * discarded prior to the current message; otherwise, it returns false.
 */
Message.prototype.isDiscardIndication = function isDiscardIndication () {
  return this._discardIndication || false;
};

/**
 * @private
 * @param {Boolean} value The new value for discard indication
 */
Message.prototype.setDiscardIndication = function setDiscardIndication (value) {
  this._setDiscardIndication(isBoolean('discardIndication', value));
};
Message.prototype._setDiscardIndication = function _setDiscardIndication (value) {
  this._discardIndication = value;
};

/**
 * Returns whether the message is eligible for eliding.
 * <p>
 * Message eliding enables filtering of data to avoid transmitting
 * every single update to a subscribing client.
 * <p>
 * This property does not indicate whether the message was elided.
 *
 * @returns {Boolean} indicates whether the message is eligible for eliding.
 */
Message.prototype.isElidingEligible = function isElidingEligible () {
  return this._elidingEligible || false;
};

/**
 * Sets whether the message is eligible for eliding.
 * <p>
 * Message eliding enables filtering of data to avoid transmitting
 * every single update to a subscribing client.
 * <p>
 * This property does not indicate whether the message was elided.
 *
 * @param {Boolean} value sets whether the message is eligible for eliding.
 */
Message.prototype.setElidingEligible = function setElidingEligible (value) {
  this._setElidingEligible(isBoolean('setElidingEligible', value));
};
Message.prototype._setElidingEligible = function _setElidingEligible (value) {
  this._elidingEligible = value;
};

/// ---------------------------------------------------------
// * Internal use only methods on the message, for fields set by the internal
// * publisher
/// ---------------------------------------------------------

/**
 * @returns {Number} The publisher ID
 * @private
 */
Message.prototype.getPublisherId = function getPublisherId () {
  return this._publisherId;
};
/**
 * @param {Number} valueThe publisher ID to set
 * @private
 */
Message.prototype.setPublisherId = function setPublisherId (value) {
  this._publisherId = value;
};

/**
 * @returns {Number} The publisher message ID
 * @private
 */
Message.prototype.getPublisherMessageId = function getPublisherMessageId () {
  return this._publisherMsgId;
};
/**
 * @param {Number} value The publisher message ID to set
 * @private
 */
Message.prototype.setPublisherMessageId = function setPublisherMessageId (value) {
  this._publisherMsgId = value;
};

/// -------------------------------------------------------------
// * User-settable properties for publishing
/// -------------------------------------------------------------

/**
 * @returns {Number} The Guaranteed Message TTL, in milliseconds.
 */
Message.prototype.getTimeToLive = function getTimeToLive () {
  return this._timeToLive;
};
/**
 * @param {Number} value The Guaranteed Message TTL to set, in milliseconds.
 *
 * The time to live is the number of milliseconds the message may be stored on the
 * Solace Message Router before the message is discarded or moved to a Dead Message
 * Queue. See {@link solace.Message.setDMQEligible}.
 *
 * Setting the Time To Live to zero disables TTL for the message.
 *
 * This property is only valid for Guaranteed messages (Persistent and Non-Persistent).
 * It has no effect when used in conjunction with other message types unless the message
 * is promoted by the appliance to a Guaranteed message.
 *
 * The maxium allowed time to live is 3.1536E11 (315360000000) which is
 * approximately 10 years.
 */
Message.prototype.setTimeToLive = function setTimeToLive (value) {
  var MAX_MESSAGE_TTL_MS = (10 * 365 * 24 * 60 * 60 * 1000); // approximately 10 years

  // Allow parser and initializer to set timeToLive to undefined
  if (value === null || value === undefined) {
    this._timeToLive = value;
    return;
  }
  if (typeof value !== 'number' || isNaN(value)) {
    throw new OperationError('Invalid type for time to live',
      ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (value < 0 || value > MAX_MESSAGE_TTL_MS) {
    throw new OperationError('Invalid time to live value',
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  this._timeToLive = value;
};

/**
 * @returns {?Number} The Guaranteed Message expiration value.
 * The expiration time is the UTC time
 * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
 * message is to expire.
 */
Message.prototype.getGMExpiration = function getGMExpiration () {
  return this._expiration;
};
/**
 * Set the expiration time field. The expiration time is the UTC time
 * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
 * message is to expire. The expiration time is carried in the message when set to
 * a non-zero value. Expiration time is not included when this value is set to zero or
 * undefined
 *
 * The message expiration time is carried to clients that receive the message
 * unmodified and does not effect the life cycle of the message. Use
 * {@link solace.Message#setTimeToLive} to enforce message expiry in the network.
 *
 * @param {?Number} value The new Guaranteed Message expiration value
 */
Message.prototype.setGMExpiration = function setGMExpiration (value) {
  this._expiration = isNumberOrNothing('GMExpiration', value);
};

/**
 * @returns {Boolean} Whether this message is Guaranteed Message DMQ eligible
 */
Message.prototype.isDMQEligible = function isDMQEligible () {
  return this._dmqEligible || false;
};
/**
 * @param {Boolean} value The new value for Guaranteed Message DMQ (Dead Message Queue) Eligible.
 * When this property is set, when the message expires in the network
 * the message is saved on a appliance dead message queue. Otherwise the expired message is
 * discarded. See {@link solace.Message#setTimeToLive}.
 */
Message.prototype.setDMQEligible = function setDMQEligible (value) {
  this._setDMQEligible(isBoolean('DMQEligible', value));
};
Message.prototype._setDMQEligible = function _setDMQEligible (value) {
  this._dmqEligible = value;
};

/// ---------------------------------------------------------
// * Internal use only methods on the message, for fields set by the consumer flow
/// ---------------------------------------------------------

/**
 * @returns {Long} The ID of the flow that received this message
 * @private
 */
Message.prototype.getFlowId = function getFlowId () {
  return this._flowId;
};
/**
 * @param {Long} value The flow ID that received this message
 * @private
 */
Message.prototype.setFlowId = function setFlowId (value) {
  this._flowId = value;
};

/**
 * @returns {Long} The Guaranteed Message prevMsgId
 * @private
 */
Message.prototype.getGuaranteedPreviousMessageId = function getGuaranteedPreviousMessageId () {
  return this._guaranteedPrevMsgId;
};
/**
 * @param {Long} value The Guaranteed Message prevMsgId to set
 * @private
 */
Message.prototype.setGuaranteedPreviousMessageId = function setGuaranteedPreviousMessageId (value) {
  this._guaranteedPrevMsgId = value;
};

/// ---------------------------------------------------------
// * Properties set by the Message Consumer
/// ---------------------------------------------------------

/**
 * @returns {?solace.MessageConsumer} The associated Message Consumer, if received by a consumer
 */
Message.prototype.getMessageConsumer = function getMessageConsumer () {
  return this._consumer;
};
/**
 * @param {solace.MessageConsumer} value The Message Consumer to associate with this message
 * @private
 */
Message.prototype.setMessageConsumer = function setMessageConsumer (value) {
  this._consumer = value;
};

/**
 * Returns the Guaranteed Message MessageID for this message.
 * @returns {?Long} The Guaranteed Message MessageID assigned to this message
 *by the router.
 */
Message.prototype.getGuaranteedMessageId = function getGuaranteedMessageId () {
  return this._guaranteedMsgId;
};
/**
 * @param {Long} value The Guaranteed Message msgId to set
 * @private
 */
Message.prototype.setGuaranteedMessageId = function setGuaranteedMessageId (value) {
  this._guaranteedMsgId = value;
};

/**
 * Returns the Topic Sequence Number.If there is no topic sequence number
 * undefined is returned.
 * @returns {?Long} The Topic Sequence number assigned to this message by the Message Router.
 */
Message.prototype.getTopicSequenceNumber = function getTopicSequenceNumber () {
  return this._topicSequenceNumber;
};

/**
 * @param {Long} topicSeqNo The Topic Sequence Number to set
 * @private
 */
Message.prototype.setTopicSequenceNumber = function setTopicSequenceNumber (topicSeqNo) {
  this._topicSequenceNumber = topicSeqNo;
};
/**
 * Acknowledges this message.
 *
 * If the {@link solace.MessageConsumer} on which this message was received is configured to use
 * {@link solace.MessageConsumerAckMode.CLIENT}, then when a message is received by an
 * application, the application must call this method to explicitly acknowledge reception of the
 * message. This frees local and router resources associated with an unacknowledged message.
 *
 * The API does not send acknowledgments immediately. It stores the state for
 * acknowledged messages internally and acknowledges messages, in bulk, when a
 * threshold or timer is reached.
 *
 * @throws {@link solace.OperationError}
 ** if this message was not received via Guaranteed Message;
 *  subcode: {@link solace.ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH}
 ** if the associated {@link solace.Session} is not connected;
 *  subcode: {@link solace.ErrorSubcode.SESSION_NOT_CONNECTED}
 ** if the associated {@link solace.MessageConsumer} is not connectedl
 *  subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
 */
Message.prototype.acknowledge = function acknowledge () {
  if (this._acked) {
    throw new OperationError('Message can only be acknowledged once',
      ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
  }
  if (this._deliveryMode === MessageDeliveryModeType.DIRECT) {
    throw new OperationError('Cannot acknowledge a DIRECT message',
      ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
  }
  if (!this._consumer) {
    throw new OperationError('Cannot acknowledge a locally-created message',
      ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
  }
  if (!this._consumer._sessionInterface.canAck) {
    throw new OperationError('Cannot acknowledge using associated session',
      ErrorSubcode.SESSION_NOT_CONNECTED);
  }
  if (!this._consumer.canAck) {
    throw new OperationError('Cannot acknowledge using associated Message Consumer',
      ErrorSubcode.INVALID_OPERATION);
  }
  this._consumer.applicationAck(this._guaranteedMsgId);
  this._acked = true;
};

/**
 * Returns whether acknowledge() has been called on this message.
 *
 * @readonly
 */
prototypeAccessors.isAcknowledged.get = function () {
  return this._acked || false;
};

/**
 * Test if the Acknowledge Immediately message property is set or not.
 * When the Acknowledge Immediately property is set to true on an outgoing
 * Guaranteed Message,
 * it indicates that the Solace Message Router should Acknowledge this message
 * immediately upon receipt.
 *
 * This property, when set by a publisher, may or may not be removed by the
 * Solace Message Router prior to delivery to a consumer, so message consumers
 * must not expect the property value indicates how the message was
 * originally published
 * @returns {Boolean} Whether this message was set to acknowledge immediately.
 */
Message.prototype.isAcknowledgeImmediately = function isAcknowledgeImmediately () {
  return this._ackImmediately || false;
};
/**
 * Set the optional Acknoweledge Immediately message property.
 * When the Acknowledge Immediately property is set to true on an outgoing Guaranteed Message,
 * it indicates that the Solace Message Router should acknoweledge this message
 * immediately upon receipt. By default the property is set to false on newly created messages.
 *
 * This property, when set by a publisher, may or may not be removed by the appliance
 * prior to delivery to a consumer, so message consumers must not expect the property value
 * indicates how the message was originally published. Therefore if a received message
 * is forwarded by the application, the Acknowledge Immediately property should be
 * explicitly set to the desired value (true or false).
 *
 * Setting this property on an outgoing direct message has no effect.
 *
 * @param {Boolean} value Whether to acknowledge this message immediately.
 */
Message.prototype.setAcknowledgeImmediately = function setAcknowledgeImmediately (value) {
  this._setAcknowledgeImmediately(isBoolean('acknowledgeImmediately', value));
};
Message.prototype._setAcknowledgeImmediately = function _setAcknowledgeImmediately (value) {
  this._ackImmediately = value;
};

/**
 * Gets the cache status of this message.
 *
 * @returns {?solace.MessageCacheStatus} The cache status of this message. The status
 * will be MessageCacheStatus.LIVE unless the message was returned in a
 * reply to a cache request.
 */
Message.prototype.getCacheStatus = function getCacheStatus () {
  return this._cacheStatus;
};

/**
 * @param {solace.MessageCacheStatus} cacheStatus The new cache status for this message
 * @private
 */
Message.prototype._setCacheStatus = function _setCacheStatus (cacheStatus) {
  this._cacheStatus = cacheStatus;
};

/**
 * Returns whether the message's reply field is set, indicating
 * that this message is a reply to a previous request. See {@link solace.Session#sendRequest}.
 * @returns {Boolean} Indicates the state of the reply field.
 */
Message.prototype.isReplyMessage = function isReplyMessage () {
  return this._replyMessage || false;
};

/**
 * Indicates whether the message has been marked as redelivered by the Solace Message Router.
 * @returns {Boolean} Indicates whether the redelivered flag is set.
 */
Message.prototype.isRedelivered = function isRedelivered () {
  return this._redelivered || false;
};
/**
 * @param {Boolean} value The redelivered flag
 * @private
 */
Message.prototype.setRedelivered = function setRedelivered (value) {
  this._redelivered = value;
};

/**
 * Sets the <i>reply</i> field of the message.
 * @param {Boolean} value Sets whether to flag the message as a reply.
 */
Message.prototype.setAsReplyMessage = function setAsReplyMessage (value) {
  this._replyMessage = isBoolean('asReplyMessage', value);
};

/**
 * Gets the receive timestamp (in milliseconds, from midnight, January 1, 1970 UTC).
 * @returns {?Number} The receive timestamp, if set.
 */
Message.prototype.getReceiverTimestamp = function getReceiverTimestamp () {
  return this._receiverTimestamp;
};

/**
 * Gets the replyTo destination
 * @returns {?solace.Destination} The value of the replyTo destination, if set.
 */
Message.prototype.getReplyTo = function getReplyTo () {
  return this._replyTo;
};

/**
 * Sets the replyTo destination
 * @param {solace.Destination} value The replyTo destination.
 */
Message.prototype.setReplyTo = function setReplyTo (value) {
  this._replyTo = isInstanceOfOrNothing('replyTo', value, Destination);
};

/**
 * Returns the Sender's ID.
 * @returns {?String} The Sender's ID, if set.
 */
Message.prototype.getSenderId = function getSenderId () {
  return this._senderId;
};

/**
 * Sets the Sender ID for the message
 * @param {String} value The Sender ID for the message.
 */
Message.prototype.setSenderId = function setSenderId (value) {
  this._senderId = isStringOrNothing('senderId', value);
};

/**
 * Gets the send timestamp (in milliseconds, from midnight, January 1,
 * 1970 UTC).
 * @returns {?Number} The send timestamp, if set.
 */
Message.prototype.getSenderTimestamp = function getSenderTimestamp () {
  return this._senderTimestamp;
};

/**
 * Sets the send timestamp (in milliseconds, from midnight, January 1,
 * 1970 UTC). This field can be generated automatically during message
 * publishing, but it will not be generated if previously set to a non-null value by this method.
 * See {@link solace.SessionProperties#generateSendTimestamps}.
 *
 * An application that publishes the same {@link solace.Messsage} multiple times and
 * also wants generted timestamps on each messages, should set the sender timestamp
 * to undefined after each call to {@link solace.Session#send}.
 * @param {?Number} value The value to set as the send timestamp.
 */
Message.prototype.setSenderTimestamp = function setSenderTimestamp (value) {
  this._senderTimestamp = isNumberOrNothing('senderTimestamp', value);
};

/**
 * Gets the sequence number.
 * <p>
 * This is an application-defined field,
 * see <code>{@link solace.Message#setSequenceNumber}()</code>.
 * @returns {?Number} The sequence number, if set
 */
Message.prototype.getSequenceNumber = function getSequenceNumber () {
  return this._sequenceNumber;
};

/**
 * Sets the application-defined sequence number. If the sequence number
 * is not set, or set to undefined, and {@link solace.SessionProperties#generateSequenceNumber}
 * is true, then a sequence number is automatically generated for each sent message.
 * @param {?Number} value The sequence number.
 */
Message.prototype.setSequenceNumber = function setSequenceNumber (value) {
  this._sequenceNumber = isNumberOrNothing('sequenceNumber', value);
  this._autoSequenceNumber = false;
};

/**
 * Gets the Class of Service (CoS) value for the message.
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.{@link solace.MessageUserCosType.COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @returns {solace.MessageUserCosType} The COS value.
 */
Message.prototype.getUserCos = function getUserCos () {
  return this._userCos;
};

/**
 * Gets the Message Priority Parameter (JMS Priority) value for the message.
 * Numerical values between 0 and 255 are valid return values,
 * undefined means the parameter is not present.
 *
 * If destination queues and topic endpoints for this message
 * are configured to respect message priority,
 * the values 0 through 9 can be used to affect the priority
 * of delivery to consumers of those queues or topic endpoints.
 * For the purposes of prioritized message delivery,
 * values larger than 9 are treated the same as 9.
 *
 * @returns {?Number} The Message Priority Parameter value.
 */
Message.prototype.getPriority = function getPriority () {
  return this._priority;
};

/**
 * Sets the Class of Service (CoS) value for the message.
 *
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.{@link solace.MessageUserCosType#COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType#COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @param {solace.MessageUserCosType} value The COS value.
 * @default {solace.MessageUserCosType#COS1}
 */
Message.prototype.setUserCos = function setUserCos (value) {
  this._setUserCos(isEnumMember('userCos', value, MessageUserCosType));
};
Message.prototype._setUserCos = function _setUserCos (value) {
  this._userCos = value;
};

/**
 * Sets the Message Priority Parameter (JMS Priority) value for the message.
 * Numerical values between 0 and 255 are accepted,
 * use undefined to unset.
 *
 * If destination queues and topic endpoints for this message
 * are configured to respect message priority,
 * the values 0 through 9 can be used to affect the priority
 * of delivery to consumers of those queues or topic endpoints.
 * For the purposes of prioritized message delivery, values larger than 9
 * are treated the same as 9.
 *
 * @param {?Number} value The priority value.
 */
Message.prototype.setPriority = function setPriority (value) {
  if (value === undefined || value === null) {
    this._setPriority(undefined);
    return;
  }
  if (typeof value !== 'number' || isNaN(value)) {
    throw new OperationError('Invalid type for message priority',
      ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (value < 0 || value > 255) {
    throw new OperationError('Invalid priority value',
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  this._setPriority(value);
};

Message.prototype._setPriority = function _setPriority (value) {
  this._priority = value;
};

/**
 * Gets the user data part of the message.
 * @returns {String} The user data part of the message, if set.
 */
Message.prototype.getUserData = function getUserData () {
  return this._userData;
};

/**
 * Sets the user data part of the message.
 * @param {String} value The user data part of the message.
 */
Message.prototype.setUserData = function setUserData (value) {
  this._setUserData(isStringOrNothing('userData', value));
};
Message.prototype._setUserData = function _setUserData (value) {
  this._userData = value;
};

/**
 * Gets the XML content part of the message.
 * Notice that the content is encoded as UTF-8 characters,
 * it needs to be decoded as JavaScript surrogate pair: decodeURIComponent(escape(value))
 * @returns {?String} The XML content part of the message, if set.
 */
Message.prototype.getXmlContent = function getXmlContent () {
  return this._xmlContent;
};

/**
 * Gets the XML content part of the message decoded from UTF-8 encoding of the characters.
 * @returns {?String} The XML content part of the message. Returns <code>null</code> if not
 * present.
 */
Message.prototype.getXmlContentDecoded = function getXmlContentDecoded () {
  return this._xmlContent ? utf8ToUcs2(this._xmlContent) : this._xmlContent;
};

/**
 * Sets the XML content part of the message.
 * The content is encoded by replacing each instance of certain characters
 * by one, two, three, or four escape sequences representing the
 * UTF-8 encoding of the character.
 * @param {String} value The XML content part of the message.
 */
Message.prototype.setXmlContent = function setXmlContent (value) {
  var setValue = isStringOrNothing('xmlContent', value);
  this._xmlContent = setValue ? unescape(encodeURIComponent(setValue)) : setValue;
};

/**
 * Internal set for the XML content part of the message.
 * @param {String} value The XML content part of the message.
 * @private
 */
Message.prototype._setXmlContentInternal = function _setXmlContentInternal (value) {
  this._xmlContent = isStringOrNothing('xmlContentInternal', value);
};

/**
 * Sets the message's XML metadata section.
 * @param {String} value The XML metadata.
 */
Message.prototype.setXmlMetadata = function setXmlMetadata (value) {
  this._setXmlMetadata(isStringOrNothing('xmlMetadata', value));
};
Message.prototype._setXmlMetadata = function _setXmlMetadata (value) {
  this._xmlMetadata = value;
};

/**
 * Gets the message's XML metadata section.
 * @returns {?String} The XML metadata, if set.
 */
Message.prototype.getXmlMetadata = function getXmlMetadata () {
  return this._xmlMetadata;
};

/**
 * @private
 */
prototypeAccessors.binaryMetadataChunk.get = function () {
  return this._binaryMetaChunk || null;
};
/**
 * @param {?String} meta The meta chunk to set
 * @private
 */
prototypeAccessors.binaryMetadataChunk.set = function (meta) {
  this._binaryMetaChunk = meta;
};

/**
 * @private
 */
prototypeAccessors.smfHeader.get = function () {
  return this._smfHeader;
};
/**
 * @param {SMFHeader} val The SMF header to set
 * @private
 */
prototypeAccessors.smfHeader.set = function (val) {
  this._smfHeader = val;
};

/**
 * @private
 */
prototypeAccessors.hasAutoSequenceNumber.get = function () {
  return this._autoSequenceNumber || false;
};
/**
 * @param {Boolean} value Value to set
 * @private
 */
prototypeAccessors.hasAutoSequenceNumber.set = function (value) {
  this._autoSequenceNumber = value;
};

/**
 * @private
 */
prototypeAccessors.hasAutoSenderTimestamp.get = function () {
  return this._autoSenderTimestamp || false;
};
/**
 * @param {Number} value Value to set
 * @private
 */
prototypeAccessors.hasAutoSenderTimestamp.set = function (value) {
  this._autoSenderTimestamp = value;
};

/**
 * Gets the user property map carried in the message binary metadata.
 *
 * @returns {?solace.SDTMapContainer} The user properties map, if set.
 */
Message.prototype.getUserPropertyMap = function getUserPropertyMap () {
  return this._userPropertyMap;
};

/**
 * Allows users to specify their own user properties to be carried
 * in the message binary metadata separate from the payload.
 * @param {?SDTMapContainer} value The user property map.
 */
Message.prototype.setUserPropertyMap = function setUserPropertyMap (value) {
  this._userPropertyMap = isInstanceOfOrNothing('userPropertyMap', value, SDTMapContainer);
};

/**
 * Makes this message a strutured data message by assigning it a
 * structured data type (SDT) container payload (such as a
 * {@link solace.SDTMapContainer}, {@link solace.SDTStreamContainer}
 * or a {@link solace.SDTFieldType.String}, which is transported in the binary attachment field.
 *
 * Assigning a SDT container updates the message's Type property to
 * the appropriate value.
 *
 * The container argument must be a {@link solace.SDTField} with a type
 * of {@link solace.SDTFieldType.MAP}, {@link solace.SDTFieldType.STREAM},
 * or {@link solace.SDTFieldType.STRING}.
 *
 * @param {?solace.SDTField} container The SDTField container to send in this message.
 */
Message.prototype.setSdtContainer = function setSdtContainer (container) {
  var structuredContainer = isInstanceOfOrNothing('sdtContainer', container, SDTField);
  if (structuredContainer === null || structuredContainer === undefined) {
    // clear
    this._structuredContainer = null;
    this.setBinaryAttachment(null);
    return;
  }

  this._setBinaryAttachment(null);
  var sdtType = structuredContainer.getType();
  switch (sdtType) {
    case SDTFieldType.MAP:
      this._messageType = MessageType.MAP;
      break;
    case SDTFieldType.STREAM:
      this._messageType = MessageType.STREAM;
      break;
    case SDTFieldType.STRING:
      this._messageType = MessageType.TEXT;
      break;
    default:
      throw new OperationError('Invalid parameter: expected SDTField Type of ' +
        'MAP, STREAM, or STRING.',
        ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  this._structuredContainer = structuredContainer;
};

/**
 * Gets the message's structured data container, if this is a structured data message.
 *
 * @returns {SDTField|null} A field with a payload of {String}, {@link SDTMapContainer},
 * or {@link SDTStreamContainer} if one was set in the message; otherwise, null.
 */
Message.prototype.getSdtContainer = function getSdtContainer () {
  var msgType = this.getType();
  var binaryAttachment = this.getBinaryAttachment();
  var binaryAttachmentLength = binaryAttachment ? binaryAttachment.length : 0;

  if (msgType === MessageType.BINARY) {
    LOG_DEBUG(("getSdtContainer returned null, reason: msgType=" + msgType));
    return null;
  }

  // MAP, STREAM or TEXT
  // Use cached structured container if available
  if (typeof this._structuredContainer !== 'undefined') {
    return this._structuredContainer;
  }

  if (binaryAttachmentLength === 0) {
    LOG_DEBUG(("getSdtContainer returned null, reason: len=" + binaryAttachmentLength));
    this._structuredContainer = null;
  } else {
    // Last resort: Decode binary attachment.
    // Cache structured container for later access
    this._structuredContainer = SDTCodec.parseSingleElement(binaryAttachment, 0);
  }


  return this._structuredContainer;
};

/**
 * Produces a human-readable dump of the message's properties and
 * contents. Applications must not parse the output, as its format is
 * not a defined part of the API and subject to change.
 *
 * <p>
 * Output can be controlled by the <code>flags</code> parameter. The values are:
 * <ul>
 * <li>{@link MessageDumpFlag.MSGDUMP_BRIEF} Display only the length of the
 *                        binary attachment, xml attachment, and user property map
 * <li>{@link MessageDumpFlag.MSGDUMP_FULL} Display the entire message.
 * </ul>
 * </p>
 *
 * @param {Number} [flags]Optional flags controlling the output, such as whether
 *                        to include verbose (binary dump) information
 * @returns {String} A string representation of the message.
 */
Message.prototype.dump = function dump (flags) {
    if ( flags === void 0 ) flags = MessageDumpFlag.MSGDUMP_FULL;

  var validFlags = isEnumMember('flags', flags, MessageDumpFlag);
  return MessageDumpUtil.dump(this, validFlags);
};

/**
 * Clones the message
 * @returns {Message} A clone of this message
 * @private
 */
Message.prototype.clone = function clone$1 () {
  return clone(this, MESSAGE_CLONE_OPTIONS);
};

/**
 * Releases all memory associated with this message. All values are reinitialized
 * to defaults. The message is no longer associated with any session or consumer.
 */
Message.prototype.reset = function reset () {
  clearMessage(this);
  initMessage(this);
};

Object.defineProperties( Message.prototype, prototypeAccessors );

module.exports.Message = Message;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(106);
var QueueDescriptor = ref$1.QueueDescriptor;
var ref$2 = __webpack_require__(65);
var QueueType = ref$2.QueueType;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valTopicString = APIPropertiesValidators.valTopicString;


var QueueDescriptorValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'QueueDescriptor', instance);
    if (instance instanceof QueueDescriptor) {
      v('name', [valTopicString]);
    } // else is abstract; don't check name
    v('type', [valIsMember, QueueType, 'QueueType']);
    v('durable', [valBoolean]);
  },
};

module.exports.QueueDescriptorValidator = QueueDescriptorValidator;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(62);
var QueueAccessType = ref$1.QueueAccessType;
var ref$2 = __webpack_require__(63);
var QueueDiscardBehavior = ref$2.QueueDiscardBehavior;
var ref$3 = __webpack_require__(64);
var QueuePermissions = ref$3.QueuePermissions;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;


var QueuePropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'QueueProperties', instance);
    // TODO: refactor to better code to handle optional parameters
    if (instance.permissions) {
      v('permissions', [valIsMember, QueuePermissions, 'QueuePermissions']);
    }
    if (instance.accessType) {
      v('accessType', [valIsMember, QueueAccessType, 'QueueAccessType']);
    }
    if (instance.quotaMB) {
      v('quotaMB', [valNumber], [valRange, 0, Number.POSITIVE_INFINITY]);
    }
    if (instance.maxMessageSize) {
      v('maxMessageSize', [valNumber], [valRange, 0, Number.POSITIVE_INFINITY]);
    }
    v('respectsTTL', [valBoolean]);
    if (instance.discardBehavior) {
      v('discardBehavior', [valIsMember, QueueDiscardBehavior, 'QueueDiscardBehavior']);
    }
    if (instance.maxMessageRedelivery) {
      v('maxMessageRedelivery', [valNumber], [valRange, 0, 255]);
    }
  },
};

module.exports.QueuePropertiesValidator = QueuePropertiesValidator;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(62);
var QueueAccessType = ref$2.QueueAccessType;
var ref$3 = __webpack_require__(63);
var QueueDiscardBehavior = ref$3.QueueDiscardBehavior;
var ref$4 = __webpack_require__(64);
var QueuePermissions = ref$4.QueuePermissions;

var DEFAULTS = {
  permissions:          undefined,
  accessType:           undefined,
  quotaMB:              undefined,
  maxMessageSize:       undefined,
  respectsTTL:          false,
  discardBehavior:      undefined,
  maxMessageRedelivery: undefined,
};

/**
 * @classdesc
 * Represents a queue properties object. May be passed in to
 * {@link solace.Session#createMessageConsumer} when creating a
 * {@link solace.MessageConsumer} object.  Upon creation of a queue, undefined queue
 * properties are set to default values chosen by the router.
 *
 * @memberof solace
 */
var QueueProperties = (function (APIProperties) {
  function QueueProperties(options) {
    APIProperties.call(this, DEFAULTS, options);
  }

  if ( APIProperties ) QueueProperties.__proto__ = APIProperties;
  QueueProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  QueueProperties.prototype.constructor = QueueProperties;

  var prototypeAccessors = { permissions: {},accessType: {},quotaMB: {},maxMessageSize: {},respectsTTL: {},discardBehavior: {},maxMessageRedelivery: {} };

  /**
   * Gets/sets permissions for this queue.
   *
   * When creating a temporary queue, these are the permissions that apply
   * to all other users; the user creating the temporary queue is always
   * granted DELETE permissions.
   *
   * @type {solace.QueuePermissions}
   * @default undefined
   */
  prototypeAccessors.permissions.get = function () {
    return this._permissions;
  };
  prototypeAccessors.permissions.set = function (newValue) {
    this._permissions = newValue;
  };

  /**
   * Gets/sets the access type for this queue.
   *
   * This parameter must NOT be set when creating a temporary queue via
   * {@link solace.Session#createMessageConsumer}. Such a queue has its
   * access type determined by the remote message router.
   *
   * @type {solace.QueueAccessType}
   * @default undefined
   */
  prototypeAccessors.accessType.get = function () {
    return this._accessType || DEFAULTS.accessType;
  };
  prototypeAccessors.accessType.set = function (newValue) {
    this._accessType = newValue;
  };

  /**
   * Gets/sets the quota, in megabytes, for this queue.
   *  * The allowed values are (0 <= quotaMB) || undefined.
   *  * A value of 0 configures the queue to act as a Last-Value-Queue (LVQ), where the router
   *    enforces a Queue depth of one, and only the most current message is spooled by the
   *    queue. When a new message is received, the current queued message is first
   *    automatically deleted from the queue, then the new message is spooled.
   * @type {?Number}
   * @default undefined
   */
  prototypeAccessors.quotaMB.get = function () {
    return this._quotaMB;
  };
  prototypeAccessors.quotaMB.set = function (newValue) {
    this._quotaMB = newValue;
  };

  /**
   * Gets/sets the maximum message size, in bytes, for any single message spooled on this queue.
   * @type {Number}
   * @default undefined
   */
  prototypeAccessors.maxMessageSize.get = function () {
    return this._maxMessageSize;
  };
  prototypeAccessors.maxMessageSize.set = function (newValue) {
    this._maxMessageSize = newValue;
  };

  /**
   * Gets/sets whether this queue respects Time To Live on messages.
   * @type {Boolean}
   * @default false
   */
  prototypeAccessors.respectsTTL.get = function () {
    return Check.boolean(this._respectsTTL) ? this._respectsTTL : DEFAULTS.respectsTTL;
  };
  prototypeAccessors.respectsTTL.set = function (newValue) {
    this._respectsTTL = newValue;
  };

  /**
   * Gets/sets the discard behavior for this queue.
   * @type {solace.QueueDiscardBehavior}
   * @default {solace.QueueDiscardBehavior.NOTIFY_SENDER_OFF}
   */
  prototypeAccessors.discardBehavior.get = function () {
    return this._discardBehavior || QueueDiscardBehavior.NOTIFY_SENDER_OFF;
  };
  prototypeAccessors.discardBehavior.set = function (newValue) {
    this._discardBehavior = newValue;
  };

  /**
   * Gets/sets the maximum number of times to attempt message redelivery for this queue.
   *  * The valid range is 0 <= maxMessageRedelivery <= 255
   *  * A value of 0 means retry forever.
   * @type {Number}
   * @default undefined
   */
  prototypeAccessors.maxMessageRedelivery.get = function () {
    return this._maxMessageRedelivery;
  };
  prototypeAccessors.maxMessageRedelivery.set = function (newValue) {
    this._maxMessageRedelivery = newValue;
  };

  QueueProperties.prototype[util.inspect.custom] = function () {
    return {
      'permissions':     QueuePermissions.describe(this.permissions),
      'accessType':      QueueAccessType.describe(this.accessType),
      'quotaMB':         this.quotaMB,
      'maxMessageSize':  this.maxMessageSize,
      'respectsTTL':     this.respectsTTL,
      'discardBehavior': this.discardBehaviour
                            ? QueueDiscardBehavior.describe(this.discardBehavior)
                            : 'undefined',
      'maxMessageRedelivery': this.maxMessageRedelivery,
    };
  };

  QueueProperties.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( QueueProperties.prototype, prototypeAccessors );

  return QueueProperties;
}(APIProperties));

module.exports.QueueProperties = QueueProperties;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(66);
var EncodeSingleElement = ref.EncodeSingleElement;
var ref$1 = __webpack_require__(67);
var IEEE754LIB = ref$1.IEEE754LIB;
var ref$2 = __webpack_require__(69);
var ParseSingleElement = ref$2.ParseSingleElement;

var encodeSingleElement = EncodeSingleElement.encodeSingleElement;
var parseSingleElement = ParseSingleElement.parseSingleElement;

var Codec = {
  encodeSingleElement: encodeSingleElement,
  parseSingleElement: parseSingleElement,
  IEEE754LIB: IEEE754LIB,
};

module.exports.Codec = Codec;


/***/ }),
/* 201 */
/***/ (function(module, exports) {


var EncodeInteger = {

  int48ToStr: function int48ToStr(vIn) {
    var v = vIn;
    var bytes = [];
    for (var i = 0; i < 6; i++) {
      var byteI = (v % 256);
      v = Math.floor(v / 256);
      bytes.push(String.fromCharCode(byteI));
    }
    bytes.reverse();
    return bytes.join('');
  },

};

module.exports.EncodeInteger = EncodeInteger;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var EncodeSingleElementLib = __webpack_require__(66);
var UtilLib = __webpack_require__(4);
var ref = __webpack_require__(107);
var EncodeHeader = ref.EncodeHeader;
var ref$1 = __webpack_require__(30);
var SDTDataTypes = ref$1.SDTDataTypes;
var ref$2 = __webpack_require__(41);
var SDTMapContainer = ref$2.SDTMapContainer;

var encodeHeader = EncodeHeader.encodeHeader;

var EncodeMap = {
  /**
   * Encodes an SDT map.
   * @param  {Object} sdtmap The map to parse
   * @returns {String}        The map in binary string format
   */
  encodeMap: function encodeMap(sdtmap) {
    var buf = [];
    if (!(sdtmap instanceof SDTMapContainer)) {
      return null; // skip!
    }
    var keys = sdtmap.getKeys();
    var sdtfield = null;
    var strKeyField = null;
    var strKeyName = null;
    var i;
    for (i = 0; i < keys.length; i++) {
      sdtfield = sdtmap.getField(keys[i]);
      if (sdtfield) {
        // === KEY ===
        strKeyName = UtilLib.StringUtils.nullTerminate(keys[i]);
        strKeyField = encodeHeader(SDTDataTypes.String, strKeyName.length);
        strKeyField += strKeyName;
        buf.push(strKeyField);

        // === VALUE ===
        EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
      }
    } // end iter over keys
    return buf.join('');
  },
};

module.exports.EncodeMap = EncodeMap;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var EncodeSingleElementLib = __webpack_require__(66);
var ref = __webpack_require__(42);
var SDTStreamContainer = ref.SDTStreamContainer;

var EncodeStream = {
  encodeStream: function encodeStream(sdtstream) {
    var buf = [];
    if (!(sdtstream instanceof SDTStreamContainer)) {
      return null; // skip!
    }
    var sdtfield = null;
    while (sdtstream.hasNext()) {
      sdtfield = sdtstream.getNext();
      if (sdtfield) {
        EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
      }
    } // end iter over stream entries
    return buf.join('');
  },
};

module.exports.EncodeStream = EncodeStream;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(5);
var DestinationFromNetwork = ref.DestinationFromNetwork;
var DestinationType = ref.DestinationType;
var Queue = ref.Queue;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var ref$2 = __webpack_require__(70);
var SDTDestType = ref$2.SDTDestType;
var ref$3 = __webpack_require__(12);
var SDTField = ref$3.SDTField;
var ref$4 = __webpack_require__(11);
var SDTFieldType = ref$4.SDTFieldType;
var ref$5 = __webpack_require__(5);
var Topic = ref$5.Topic;

var ParseDestination = {
  parseDestination: function parseDestination(data) {
    var destType = data.charCodeAt(0);
    var destBytes = data.substr(1);
    // first try to create a destination from the string, this handles strings with
    // the preamble ('#P2P/QUE' or '#P2P/TQUE').
    var destination = DestinationFromNetwork.createDestinationFromBytes(destBytes);
    if (SDTDestType[destination.type] !== destType) {
      // SDT destination type does not match the string format. This means either:
      //    * that the string contains a queue preamble and the type is topic,
      //      so just make it a topic
      //    * that the type is queue and the string does not have the preamble, which means we
      //      should construct a queue.
      if (SDTDestType[DestinationType.QUEUE] === destType) {
        destination = Queue.createFromLocalName(destBytes);
      } else if (SDTDestType[DestinationType.TOPIC] === destType) {
        LOG_DEBUG(("Found and allowed SDT field with  destination type " + destType + " when decoding " + destBytes + " to " + (destination.type)));
        //
        // override the format and set destType as specified in the SMF (i.e. TOPIC)
        destination = new Topic(destBytes);
      } else {
        LOG_INFO(("Drop SDT field with invalid destination type " + destType + " when decoding " + destBytes + " to " + (destination.type)));
        return null;
      }
    }
    return SDTField.create(SDTFieldType.DESTINATION, destination);
  },
};

module.exports.ParseDestination = ParseDestination;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(67);
var IEEE754LIB = ref.IEEE754LIB;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;

var ParseFloat = {
  parseFloatField: function parseFloatField(bytes) {
    switch (bytes.length) {
      case 4:
        return SDTField.create(SDTFieldType.FLOATTYPE, IEEE754LIB.fromIEEE754Single(bytes));
      case 8:
        return SDTField.create(SDTFieldType.DOUBLETYPE, IEEE754LIB.fromIEEE754Double(bytes));
      default:
        return SDTField.create(SDTFieldType.UNKNOWN, bytes);
    }
  },
};

module.exports.ParseFloat = ParseFloat;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var ParseSingleElementLib = __webpack_require__(69);
var ref = __webpack_require__(1);
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(68);
var ParseFieldHeader = ref$1.ParseFieldHeader;
var ref$2 = __webpack_require__(30);
var SDTDataTypes = ref$2.SDTDataTypes;
var ref$3 = __webpack_require__(12);
var SDTField = ref$3.SDTField;
var ref$4 = __webpack_require__(11);
var SDTFieldType = ref$4.SDTFieldType;
var ref$5 = __webpack_require__(41);
var SDTMapContainer = ref$5.SDTMapContainer;

var ParseMap = {
  parseMapAt: function parseMapAt(data, offset, datalen) {
    var mapObj = new SDTMapContainer();
    var pos = offset;
    while (pos < offset + datalen) {
      // === key field ===
      var keyFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      pos += keyFieldHeader[3]; // consumed bytes
      // pos now points to start of string
      if (keyFieldHeader[0] !== SDTDataTypes.String) {
        // Fail!
        LOG_ERROR("Error parsing SDTMAP, expected to find a string field as map key, and didn't");
        return SDTField.create(SDTFieldType.MAP, null);
      }
      var keyString = data.substr(pos, keyFieldHeader[2] - 1);
      pos += keyFieldHeader[2];

      // === value field ===
      // pos now points to start of next value
      var valueFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      var valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(data, pos);
      pos += valueFieldHeader[1]; // declared field length
      if (valueField) {
        mapObj.addField(keyString, valueField);
      }
    }
    return SDTField.create(SDTFieldType.MAP, mapObj);
  },
};

module.exports.ParseMap = ParseMap;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var ParseSingleElementLib = __webpack_require__(69);
var ref = __webpack_require__(68);
var ParseFieldHeader = ref.ParseFieldHeader;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;
var ref$3 = __webpack_require__(42);
var SDTStreamContainer = ref$3.SDTStreamContainer;

var ParseStream = {
  parseStreamAt: function parseStreamAt(data, offset, datalen) {
    var streamObj = new SDTStreamContainer();
    var pos = offset;
    while (pos < offset + datalen) {
      var valueFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      var valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(data, pos);
      pos += valueFieldHeader[1]; // declared field length
      if (valueField) {
        streamObj.addField(valueField);
      }
    }
    return SDTField.create(SDTFieldType.STREAM, streamObj);
  },
};

module.exports.ParseStream = ParseStream;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var SDTMapContainerLib = __webpack_require__(41);
var SDTStreamContainerLib = __webpack_require__(42);
var ValidateLib = __webpack_require__(7);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(11);
var SDTFieldType = ref$1.SDTFieldType;

var baseTypes = (function () {
  var result = [];
  result[SDTFieldType.BOOL] = 'boolean';
  result[SDTFieldType.UINT8] = 'number';
  result[SDTFieldType.INT8] = 'number';
  result[SDTFieldType.UINT16] = 'number';
  result[SDTFieldType.INT16] = 'number';
  result[SDTFieldType.UINT32] = 'number';
  result[SDTFieldType.INT32] = 'number';
  result[SDTFieldType.UINT64] = 'number';
  result[SDTFieldType.INT64] = 'number';
  result[SDTFieldType.WCHAR] = 'string';
  result[SDTFieldType.STRING] = 'string';
  result[SDTFieldType.BYTEARRAY] = 'string';
  result[SDTFieldType.FLOATTYPE] = 'number';
  result[SDTFieldType.DOUBLETYPE] = 'number';
  return result;
})();

function failInvalidParameter(valueType) {
  return new OperationError(
            ("Invalid SDT type:value combination, expected value type " + valueType),
            ErrorSubcode.PARAMETER_INVALID_TYPE);
}

function validateSdtField(type, value) {
  if (baseTypes[type]) {
    if ((baseTypes[type] === 'boolean' && typeof value !== 'boolean') ||
            (baseTypes[type] === 'number' && typeof value !== 'number') ||
            (baseTypes[type] === 'string' && typeof value !== 'string')) {
      return failInvalidParameter(baseTypes[type]);
    }
  }
  if (type === SDTFieldType.MAP &&
      !ValidateLib.Check.instanceOf(value, SDTMapContainerLib.SDTMapContainer)) {
    return failInvalidParameter('SDTMapContainer');
  }
  if (type === SDTFieldType.STREAM &&
      !ValidateLib.Check.instanceOf(value, SDTStreamContainerLib.SDTStreamContainer)) {
    return failInvalidParameter('SDTStreamContainer');
  }
  if (type === SDTFieldType.DESTINATION &&
      !ValidateLib.Check.instanceOf(value, DestinationLib.Destination)) {
    return failInvalidParameter('Destination');
  }
  return null;
}

module.exports.validateSdtField = validateSdtField;


/***/ }),
/* 209 */
/***/ (function(module, exports) {

var CorrelatedRequest = function CorrelatedRequest(correlationTag, timer, correlationKey, respRecvdCallback) {
  this.correlationTag = correlationTag;
  this.timer = timer;
  this.correlationKey = correlationKey;
  this.respRecvdCallback = respRecvdCallback;
};

module.exports.CorrelatedRequest = CorrelatedRequest;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(43);
var CapabilityType = ref.CapabilityType;

module.exports.DefaultCapabilities = {
  createDefaultCapabilities: function createDefaultCapabilities() {
    var defaultCapabilities = {};
    defaultCapabilities[CapabilityType.GUARANTEED_MESSAGE_CONSUME] = true;
    defaultCapabilities[CapabilityType.GUARANTEED_MESSAGE_PUBLISH] = true;
    return defaultCapabilities;
  },
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var Process = ref.Process;

var C_2_32 = Math.pow(2, 32);

function leftPad(str, len) {
  return '0'.repeat(len - str.length) + str;
}

function generateRandomId() {
  var rand = (Math.random() * C_2_32).toFixed(0);
  return leftPad(rand.toString(), 10);
}

/**
 * @private
 */
var GlobalContext = {

  sessionCounter: 0,
  idCounter:      0,

  RandId: generateRandomId(),

  NextSessionCounter: function NextSessionCounter() {
    var count = ++this.sessionCounter;
    return leftPad(count.toString(), 4);
  },

  NextId: function NextId() {
    return ++this.idCounter;
  },

  GenerateClientName: function GenerateClientName() {
    var product = Process.product;
    var platform = Process.platform;
    var result = product + "/" + platform + "/" + (this.RandId) + "/" + (this.NextSessionCounter());
    return result;
  },

  GenerateUserIdentification: function GenerateUserIdentification() {
    var product = Process.product;
    var platform = Process.platform;
    return (product + "/" + platform + "/" + (this.RandId));
  },

  GenerateClientDescription: function GenerateClientDescription() {
    return ("solclientjs/" + (Process.description)).substring(0, 254);
  },
};

module.exports.GlobalContext = GlobalContext;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var ref$1 = __webpack_require__(4);
var parseURL = ref$1.parseURL;

var hostListDNSFilter;
if (true) {
  /* eslint-env node */
  /* eslint-disable global-require */
  var dns = __webpack_require__(284);
  /* eslint-enable global-require */

  // util.promisify is Node 8. This converts an (err, result) callback to a promise.
  // The purpose is to allow us to use Promise.all, which deals with waiting until
  // all promises are resolved, and returning the results in correctly ordered array.
  var dnsLookupPromise = function (url, options) { return new Promise(function (resolve) {
    var host = parseURL(url).hostname;
    LOG_TRACE('looking up', url, '=>', host);
    dns.lookup(host, options, function (error, result) {
      LOG_TRACE('DNS result', error, result);
      return error === null
        ? resolve({ url: url, host: host, address: result, resolved: true })
        : resolve(
          { url: url,
            host: host,
            resolved: true,
            error:    {
              code:     error['code'], // eslint-disable-line dot-notation
              errno:    error['errno'], // eslint-disable-line dot-notation
              hostname: error['hostname'], // eslint-disable-line dot-notation
              syscall:  error['syscall'], // eslint-disable-line dot-notation
            },
          });
    });
  }); };

  /**
   * Resolution calls back with an array of the following:
   * `{ url: 'http://example.com/foo', host: 'example.com', address: '10.0.0.1', resolved: true }`
   * or, on error
   * `{ url: 'http://example.com/foo', host: 'example.com', resolved: true, error: {
   *    code: 'ENOTFOUND', errno: 'ENOTFOUND', syscall: 'getaddrinfo'
   *  } }`
   *
   * If resolution could not be performed, because of platform limitations, the callback receives
   * the following:
   * `{ url: 'http://example.com/foo', host: 'example.com', address: 'example.com', resolved: false }`
   *
   * Even if no DNS lookup is performed, the function can still fail if an invalid URL is provided.
   *
   * The function always calls back asynchronously.
   *
   * @param {Array.<String>} urls Array of URLs to resolve
   * @param {function} cb A function called back with results as described above
   * @private
   */
  hostListDNSFilter = function hostListDNSFilterNode(urls, cb) {
    var promises = urls.map(function (url) { return dnsLookupPromise(
      url,
      { 'verbatim': true }
    ); });
    // Call back (null, [{host:, address:}, ...]) if all successful
    // Call back (err, undefined) fast if any error
    Promise.all(promises).then(function (resolved) { return cb(null, resolved); }).catch(function (err) { return cb(err); });
  };
} else {
  /* eslint-env browser */
  // Create an always-async callback that allows all hosts.
  hostListDNSFilter = function (urls, cb) { return setImmediate(function () {
    try {
      var result = urls.map(function (url) {
        var host = parseURL(url).host;
        return { url: url, host: host, address: host, resolved: false };
      });
      return cb(null, result);
    } catch (e) {
      return cb(e);
    }
  }); };
}

module.exports.hostListDNSFilter = hostListDNSFilter;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(212);
var hostListDNSFilter = ref$1.hostListDNSFilter;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;
var ref$3 = __webpack_require__(4);
var parseURL = ref$3.parseURL;

function parseURLs(rawURLs) {
  if (Array.isArray(rawURLs)) {
    return rawURLs.map(function (rawURL) { return parseURL(rawURL); });
  }
  return parseURLs(rawURLs.split(/[,;]/));
}

/*
 *   "When using a host list, each time the API works through the host list without establishing
 *    a connection is considered an connect retry."
 *   SESSION_CONNECT_RETRIES: "When using a host list, this property defines how many times to
 *    try to connect or reconnect to a single host before moving to the next host in the list."
 *   Details: http://docs.solace.com/Solace-Messaging-APIs/Configuring-Connection-T.htm
*/

// In general:
// * set initial state to invalid so that we begin needing a transition.
// * preincrement all try counts on transition.
// Specifics:
// * Select try count for entire list based on whether we were connected.
// * Try count per host is the same for both connect and reconnect.
// * When the host changes, the waitTime is 0.
// * Overriding the above, when the host pointer wraps to 0, the waitTime is nonzero.

var HostInfo = function HostInfo(props) {
  if ( props === void 0 ) props = { url: null, waitTime: 0 };

  Object.assign(this, props);
};

/**
 * @private
 */
var HostList = function HostList(ref) {
  if ( ref === void 0 ) ref = {};
  var url = ref.url;
  var connectRetries = ref.connectRetries;
  var reconnectRetries = ref.reconnectRetries;
  var connectRetriesPerHost = ref.connectRetriesPerHost;
  var reconnectRetryWaitInMsecs = ref.reconnectRetryWaitInMsecs;

  Object.assign(this, {
    hosts: parseURLs(url).map(function (e) { return e.href; }),

    // How many times will we traverse the host list without success?
    // Try to connect one more than the 'retryCount' because we always try once.
    connectTryCount: (connectRetries === -1
      ? Number.POSITIVE_INFINITY
      : connectRetries + 1
    ),

    // How many times will we traverse the host list after success?
    reconnectTryCount: (reconnectRetries === -1
      ? Number.POSITIVE_INFINITY
      : reconnectRetries
    ),

    // A value of –1 in the next assignements means retry forever - "null" will mean that
    // try to connect one more than the 'retryCount' because we always try once.
    connectTryCountPerHost: (connectRetriesPerHost === -1
      ? Number.POSITIVE_INFINITY
      : connectRetriesPerHost + 1
    ),

    // How long do we wait before reattempting the same host or wrapping around the list?
    reconnectRetryWaitInMsecs: reconnectRetryWaitInMsecs,

    // Mutating operations affect only this.
    _mutableState: {},

    logger: new LogFormatter('[host-list]'),
  });

  assert(this.hosts.length >= 1);
  assert(this.connectTryCount >= 1);
  assert(this.reconnectTryCount >= 0);
  assert(this.connectTryCountPerHost >= 1);
};

var prototypeAccessors = { connectWaitTimeInMsecs: {} };

/**
 * Call before first getNextHost() to validate that at least one URL contains a reachable
 * hostname.
 * @param {function(Error)} callback The callback to invoke when DNS resolution completes
 */
HostList.prototype.resolveHosts = function resolveHosts (callback) {
    var this$1 = this;

  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_WARN = ref.LOG_WARN;
  hostListDNSFilter(this.hosts, function (err, resolved) {
    // Exit immediately if the filter threw.
    if (err) { return callback(err); }
    assert(resolved.length === this$1.hosts.length, 'Resolve did not return a result for all hosts');

    LOG_TRACE('Resolve result', resolved);
    var succeeded = 0;
    resolved.forEach(function (result) {
      if (result.address) {
        ++succeeded;
      }
      if (!result.resolved) {
        // Only log if the lookup was actually performed
        return;
      }
      if (result.address) {
        LOG_TRACE('DNS resolve OK:    ', result.address, 'for', result.url);
      } else {
        LOG_WARN('DNS resolve FAILED:', result.error.code,
                 ((result.error.syscall) + "('" + (result.error.hostname) + "')"), 'for', result.url);
      }
    });
    return callback(succeeded === 0 ? 'All hosts failed DNS resolution' : null);
  });
};

/**
 * @param {Object} state Properties for host selection logic
 * @memberof HostList
 */
HostList.prototype.reset = function reset (state) {
    if ( state === void 0 ) state = { wasConnected: false, disconnected: false };

  // On reset, we always return to the beginning of the host list.
  // This facilitates DR recovery by returning to the primary router.
  // Set an invalid initial state that will trigger our first try.
  Object.assign(this._mutableState, {
    wasConnected: state.wasConnected,
    disconnected: state.disconnected,
    hostPointer:0,
    hostTries:  0,
    listTries:  1,
    exhausted:  false,
    lastHostInfo: new HostInfo(),
  });
};

/**
 * !returns {HostInfo} Connection information for the next host.
 * @returns {String} The URL for the next host
 * @memberof HostList
 */
HostList.prototype.getNextHost = function getNextHost () {
  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

  var state = this._mutableState;
  var wasConnected = state.wasConnected;
  var lastHostInfo = state.lastHostInfo;

  assert(lastHostInfo, 'Next host request with no prior host info -- did you call reset()?');
  // Using a try/finally as a "goto end" to always log final state. Exceptions not expected
  // here, although if an assertion fails, the finally log should be helpful.
  try {
    // If this was passed into reset, the session is telling us to enforce no more hosts.
    if (state.disconnected) {
      LOG_TRACE('Host list set to disconnected, providing null next host');
      return null;
    }

    // If exhausted, this function has returned a null url already.
    assert(!state.exhausted, 'Next host request after host list exhausted');

    // Pull immutable properties from the instance
    var properties = Object.assign({
      hosts:      this.hosts,
      hostTriesMax: this.connectTryCountPerHost,
      listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount,
    });

    LOG_TRACE('Getting next host\n', 'properties', properties, '\nstate', state);
    LOG_TRACE('Last host', lastHostInfo);

    // Initial state was valid. This is a host try. Increment.
    ++state.hostTries;
    if (state.hostTries > properties.hostTriesMax) {
      // Increment host pointer, possibly putting it out of bounds.
      LOG_TRACE(("Exhausted " + (state.hostTries) + " host tries for host " + (lastHostInfo.url) + "."));
      ++state.hostPointer;
      // If the host pointer is out of bounds, we are beginning a new list try.
      // It was either set out of bounds deliberately by reset() or it was
      // incremented out of bounds above.
      if (state.hostPointer >= properties.hosts.length) {
        // This is a new list try.
        ++state.listTries;
        if (state.listTries > properties.listTriesMax) {
          // Beginning this list try has exceeded our inclusive max. The host list is
          // exhausted.
          LOG_TRACE(("Exhausted host list at " + (properties.listTriesMax) + " traversals."));
          state.exhausted = true;
        } else {
          // Resetting the host pointer to begin this list try.
          LOG_TRACE(("Host list try (" + (state.listTries) + "/" + (properties.listTriesMax) + ")"));
          state.hostPointer = 0;
          state.hostTries = 1; // this is the first try for this host
        }
      } else {
        state.hostTries = 1; // this is the first try for this host
      }
    } else {
      // Continue with this host.
      LOG_TRACE(("Host try (" + (state.hostTries) + "/" + (properties.hostTriesMax) + ")"));
    }

    if (state.exhausted) {
      LOG_TRACE('All hosts exhausted');
      return null;
    }

    // Beyond this point, expect a valid host to be returned.

    var url = properties.hosts[state.hostPointer];
    assert(url, ("No host at the host pointer! " + (properties.hosts) + "[" + (state.hostPointer) + "]"));

    // Wait time conditions:
    // 1. On a new list (invalid lastHostInfo), zero waitTime.
    var isNewList = lastHostInfo.url === null;
    // 2a. On a new host, zero waitTime...
    var isNewHost = lastHostInfo.url !== url;
    // 2b. ...unless we are just restarting the list.
    var didJustFinishList = lastHostInfo.url !== url && state.hostPointer === 0;
    // (2b negates 2a for a new list)

    var waitTime = (isNewList || (isNewHost && !didJustFinishList))
      ? 0
      : this.reconnectRetryWaitInMsecs;

    // Session FSM was intended to use all of these, but handles its own events presently
    // and expects waitTime to be a property of the list that mutates per host, so that is
    // what is done.
    var hostInfo = new HostInfo({
      url: url,
      waitTime: waitTime,
    });

    // Set last host for next time, and return
    LOG_TRACE('Returning host from', hostInfo);
    state.lastHostInfo = hostInfo;
    return hostInfo.url;
  } finally {
    LOG_TRACE('Final list state\n', state);
  }
};

prototypeAccessors.connectWaitTimeInMsecs.get = function () {
  assert(this._mutableState.lastHostInfo.url, 'Getting connectWaitTimeInMsecs having never called getNextHostInfo');
  return this._mutableState.lastHostInfo.waitTime;
};

HostList.prototype.currentHostToString = function currentHostToString () {
  var state = this._mutableState;
  var wasConnected = state.wasConnected;
  // Pull immutable properties from the instance
  var properties = Object.assign({
    hosts:      this.hosts,
    hostTriesMax: this.connectTryCountPerHost,
    listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount,
  });
  // host pointer is zero based index into the host list
  // so translate it to a human readable index
  var hostNumber = state.hostPointer + 1;
  return ("host '" + (state.lastHostInfo.url) + "' (host " + hostNumber + " of " + (properties.hosts.length) + ")(host connection attempt " + (state.hostTries) + " of " + (properties.hostTriesMax) + ")(total " + (wasConnected ? 'reconnection' : 'connection') + " attempt " + (state.listTries) + " of " + (properties.listTriesMax) + ")");
};

Object.defineProperties( HostList.prototype, prototypeAccessors );

module.exports.HostList = HostList;


/***/ }),
/* 214 */
/***/ (function(module, exports) {

/**
 * @private
 */
var OutstandingDataRequest = function OutstandingDataRequest(correlationId, timer, replyReceivedCBFunction, reqFailedCBFunction, userObject) {
  this.correlationId = correlationId;
  this.timer = timer;
  this.replyReceivedCBFunction = replyReceivedCBFunction;
  this.reqFailedCBFunction = reqFailedCBFunction;
  this.userObject = userObject;
};

module.exports.OutstandingDataRequest = OutstandingDataRequest;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var ConsumerLib = __webpack_require__(99);
var PublisherLib = __webpack_require__(29);
var SMFLib = __webpack_require__(8);
var SolclientFactoryLib = __webpack_require__(9);
var TransportLib = __webpack_require__(23);

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(43);
var CapabilityType = ref$1.CapabilityType;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(209);
var CorrelatedRequest = ref$3.CorrelatedRequest;
var ref$4 = __webpack_require__(5);
var Destination = ref$4.Destination;
var ref$5 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$5.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$5.ErrorSubcode;
var OperationError = ref$5.OperationError;
var ref$6 = __webpack_require__(15);
var FsmEvent = ref$6.FsmEvent;
var State = ref$6.State;
var StateMachine = ref$6.StateMachine;
var ref$7 = __webpack_require__(3);
var Hex = ref$7.Hex;
var ref$8 = __webpack_require__(1);
var LogFormatter = ref$8.LogFormatter;
var ref$9 = __webpack_require__(16);
var Message = ref$9.Message;
var MessageDeliveryModeType = ref$9.MessageDeliveryModeType;
var ref$10 = __webpack_require__(113);
var P2PUtil = ref$10.P2PUtil;
var ref$11 = __webpack_require__(73);
var SessionEvent = ref$11.SessionEvent;
var ref$12 = __webpack_require__(44);
var SessionEventCode = ref$12.SessionEventCode;
var ref$13 = __webpack_require__(72);
var SessionEventName = ref$13.SessionEventName;
var ref$14 = __webpack_require__(115);
var SessionFSMEvent = ref$14.SessionFSMEvent;
var ref$15 = __webpack_require__(75);
var SessionRequestType = ref$15.SessionRequestType;
var ref$16 = __webpack_require__(116);
var SessionStateName = ref$16.SessionStateName;
var ref$17 = __webpack_require__(19);
var StatType = ref$17.StatType;
var StatsByMode = ref$17.StatsByMode;
var ref$18 = __webpack_require__(4);
var StringUtils = ref$18.StringUtils;
var ref$19 = __webpack_require__(219);
var SubscriptionUpdateTimeoutMessages = ref$19.SubscriptionUpdateTimeoutMessages;

var formatHexString = Hex.formatHexString;
var stripNullTerminate = StringUtils.stripNullTerminate;
var STAT_TX_BYMODE_BYTES = StatsByMode.STAT_TX_BYMODE_BYTES;
var STAT_TX_BYMODE_MSGS = StatsByMode.STAT_TX_BYMODE_MSGS;
var STAT_RX_BYMODE_BYTES = StatsByMode.STAT_RX_BYMODE_BYTES;
var STAT_RX_BYMODE_MSGS = StatsByMode.STAT_RX_BYMODE_MSGS;
var STAT_TX_BYMODE_REDELIVERED = StatsByMode.STAT_TX_BYMODE_REDELIVERED;
var STAT_TX_BYMODE_BYTES_REDELIVERED = StatsByMode.STAT_TX_BYMODE_BYTES_REDELIVERED;

/**
 * @param {SessionProperties} sessionProperties The shared reference to the properties of the
 *  owning session
 * @param {Session} session The session owning this FSM
 * @extends StateMachine
 * @private
 */
var SessionFSM = (function (StateMachine) {
  function SessionFSM(sessionProperties, session, stats, hosts) {
    var this$1 = this;

    StateMachine.call(this, { name: 'SessionFSM' });
    var fsm = this;
    var logFormatter = function logFormatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        ("[session-fsm=" + (fsm.sessionIdHex || '(N/A)') + "]"),
        ("[" + (fsm.getCurrentStateName()) + "]") ].concat( args );
    };
    var logger = this.logger = new LogFormatter(logFormatter);
    var LOG_TRACE = logger.LOG_TRACE;
    var LOG_DEBUG = logger.LOG_DEBUG;
    var LOG_INFO = logger.LOG_INFO;
    this.log = logger.wrap(this.log, this);
    this._sessionProperties = sessionProperties;
    this._session = session;
    this._sessionStatistics = stats;
    this._hosts = hosts;
    this._consumers = new ConsumerLib.ConsumerFlows();
    // This is a function that generates this interface. It takes the flow as a construction
    // parameter, and for some methods, produces a partial application using that flow.
    this._flowInterfaceFactory = function (flow) { return ({
      getCorrelationTag:               this$1.getCorrelationTag.bind(this$1),
      incStat:                         this$1.incStat.bind(this$1),
      sendData:                        function (message) { return this$1.send(message, flow, false); },
      sendToTransport:                 function (message) { return this$1.sendToTransport(message, flow, false); },
      sendControl:                     function (message) { return this$1.send(message, flow, true); },
      enqueueRequest:                  this$1.enqueueOutstandingCorrelatedReq.bind(this$1),
      createDestinationFromDescriptor: session.createDestinationFromDescriptor.bind(session),
      createTemporaryDestination:      session.createTemporaryDestination.bind(session),
      isCapable:                       session.isCapable.bind(session),
      getCapability:                   session.getCapability.bind(session),

      get sessionIdHex() {
        return fsm.sessionIdHex;
      },
      get canAck() {
        return session.canAck;
      },
    }); };

    this.clearCurrentError();

    this.initial(function onInitial() {
      return this.transitionTo(fsm.SessionDisconnected,
                               function (context) { return context.getStateMachine().reset(); });
    });

    /**
     * Handles events in the unhandledEventHandler callback
     * @param {SessionFSMEvent} sEvent
     * @private
     */
    this.unhandledEventReaction(function onUnhandledEvent(sEvent) {
      var curState = fsm.getCurrentState();
      switch (sEvent.getName()) {
        case SessionEventName.CREATE_SUBSCRIBER:
          // CREATE_SUBSCRIBER is only handled in CONNECTED state.
          // In all other states we just add the consumer to our
          // list of unbound consumers that need to be bound when
          // the session up occurs.
          assert(fsm._consumers, 'collection has lifetime of FSM instance');
          fsm._consumers.add(sEvent.guaranteedFlowObject);
          return this;
        case SessionEventName.DISPOSE:
          LOG_DEBUG('Handling DISPOSE');
          return curState.terminate(function () { return fsm.disposeInternal(); });
        case SessionEventName.FLOW_UP:
          LOG_DEBUG(("Ignoring FLOW_UP event from " + (sEvent.guaranteedFlowObject)));
          return this;
        default:
          LOG_TRACE(("Ignoring event " + (sEvent.getName()) + " in state " + (fsm.getCurrentStateName())));
          return this;
      }
    });

    this.SessionConnecting = new State({
      name:          SessionStateName.CONNECTING,
      parentContext: fsm,
    }, {
      //
      //  handleTransportDestroyed is called in response to TRANSPORT_DESTROYED
      //  event and if transport create throws an exception. In both case there is
      //  no underlying transport and the FSM must move on to the next host.
      handleTransportDestroyed: function handleTransportDestroyed() {
        fsm._currentHost = fsm._hosts.getNextHost();
        if (fsm._currentHost === null) {
          return this.transitionToExitPoint(fsm.SessionConnecting, 'ErrorExit');
        }

        var ref = fsm._hosts;
        var connectWaitTimeInMsecs = ref.connectWaitTimeInMsecs;
        LOG_TRACE(("Wait time for this host is " + connectWaitTimeInMsecs));
        if (connectWaitTimeInMsecs > 0) {
          fsm._connectWaitTimer = setTimeout(function () {
            fsm.processEvent(new SessionFSMEvent({ name: SessionEventName.CONNECT_WAIT_TIMEOUT }));
          }, connectWaitTimeInMsecs);
          return this.transitionTo(fsm.WaitingForInterConnectTimeout);
        }
        return this.transitionTo(fsm.WaitingForTransport);
      },
    })
      .entry(function () {
        fsm.setConnectTimer();
      })
      .entryPoint('DisconnectTransport', function onDisconnectTransport() {
        fsm._hosts.reset({ wasConnected: undefined, disconnected: true });
        //
        // Set the error event, as we have reset the
        // host list with disconnected:true, we always take the
        // errorExit path to DISCONNECTED state after this entryPoint.
        //
        fsm._connectFailEvent = SessionEventCode.DISCONNECTED;
        fsm._connectSuccessEvent = SessionEventCode.DISCONNECTED;
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .entryPoint('ReconnectTransport', function onReconnectTransport() {
        //
        // Set the error event, this is only used
        // if we take the errorExit path
        //
        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
        fsm._connectSuccessEvent = SessionEventCode.RECONNECTED_NOTICE;
        // Should we try to reconnect?
        var disconnected = fsm._sessionProperties._reconnectRetries === 0;
        fsm._hosts.reset({ wasConnected: true, disconnected: disconnected });
        if (!disconnected) {
          // workaround to make sure session state is changed to connecting when
          // application gets the session event
          // positional parameters for SessionEvent constructor
          // make sure we get the args and err setup now as by the time
          // the postEventAction runs currentError will be reset.
          var err = fsm._currentError || {};
          var args = [err.eventText,    // infoString
            err.responseCode,             // responseCode
            err.errorSubcode,             // errorSubcode
            undefined,                    // correlationKey ... N/A
            err.eventReason];             // eventReason
          fsm.setPostEventAction(function () {
            fsm.setConnectTimer();
            fsm.emitSessionEvent(SessionEvent.build.apply(SessionEvent, [ SessionEventCode.RECONNECTING_NOTICE ].concat( args )));
          });
        }
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .initial(function () {
        fsm.clearCurrentError();
        //
        // Set the error event this is only used
        // if we take the errorExit path
        //
        fsm._connectFailEvent = SessionEventCode.CONNECT_FAILED_ERROR;
        fsm._connectSuccessEvent = SessionEventCode.UP_NOTICE;

        // Perform host resolution (guaranteed async; replaces a postEventAction)
        // Do not perform host list operations until this completes (moved to callback)
        fsm._hosts.resolveHosts(function (err) {
          if (!fsm._hosts) {
            LOG_TRACE('Ignoring host filter fail because session was disposed');
            return null;
          }
          if (err) {
            LOG_TRACE('DNS filter failed:', err);
            fsm.setCurrentError({
              errorSubcode: ErrorSubcode.UNRESOLVED_HOSTS,
              eventText:    err,
            });
            fsm._hosts.reset({ disconnected: true });
            return this$1.processEvent(new SessionFSMEvent({ name: SessionEventName.EXCEPTION }));
          }

          // Now that the host list has been scanned, we can reset and get next host
          fsm._hosts.reset({ wasConnected: false });
          fsm._currentHost = fsm._hosts.getNextHost();
          return this$1.processEvent(new SessionFSMEvent(
            { name: SessionEventName.DNS_RESOLUTION_COMPLETE }
          ));
        });
        return this$1.transitionTo(fsm.WaitingForDNS);
      })
      .reaction(SessionEventName.DNS_RESOLUTION_COMPLETE, function onDNSComplete() {
        return this.transitionTo(fsm.WaitingForTransport);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* event */) {
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      })
      .reaction(SessionEventName.CONNECT_TIMEOUT, function onConnectTimeout(/* event */) {
        fsm.setCurrentError({
          errorSubcode: ErrorSubcode.TIMEOUT,
          eventText:    'Connect timeout',
        });
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
        // TODO: I think EXCEPTION events never carry extra error information
        // as setCurrentError is already called.
        fsm.setCurrentError(errEvent);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        LOG_DEBUG('TRANSPORT_DESTROYED event');
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .exit(function () {
        fsm.clearConnectTimer();
        if (fsm._connectWaitTimer) {
          clearTimeout(fsm._connectWaitTimer);
          fsm._connectWaitTimer = null;
        }
      })
      .exitPoint('ConnectedExit', function (/* event */) {
        // Normal exit to TransportUp.
        // We need to notify the application they are connected. Use postEventAction to make sure
        // session state has already changed to TransportUp when application gets the callback.
        // Use _connectSuccessEvent to send RECONNECTED vs UP depending on entry point.
        // TODO: what text to include with event, currently text is different for
        // connect vs reconnect. We should store with as part of _connectSuccessEvent in
        // the entry point.
        fsm.setPostEventAction(function () {
          fsm.emitSessionEvent(SessionEvent.build(fsm._connectSuccessEvent,
                                                  ("'" + (fsm._hosts.currentHostToString()) + "'"),
                                                  200, 0, null, null));
        });
        // Clear current error as we have successfully connected or
        // reconnected.
        fsm.clearCurrentError();
        return this$1.transitionTo(fsm.SessionTransportUp);
      })
      .exitPoint('ErrorExit', function onExit(/* event */) {
        // Notify the application they are disconnected. Use postEventAction to make sure session
        // state has already changed to disconnected when application gets the callback.
        fsm.setPostEventAction(function () {
          var err = fsm._currentError || {};
          // positional parameters for SessionEvent constructor
          var args = [err.eventText,    // infoString
            err.responseCode,             // responseCode
            err.errorSubcode,             // errorSubcode
            undefined,                    // correlationKey ... N/A
            err.eventReason];             // eventReason
          fsm.emitSessionEvent(SessionEvent.build.apply(SessionEvent, [ fsm._connectFailEvent ].concat( args )));
        });
        return this.transitionTo(fsm.SessionDisconnected);
      });

    this.WaitingForDNS = new State({
      name:          SessionStateName.WAITING_FOR_DNS,
      parentContext: fsm.SessionConnecting,
    });

    this.DestroyingTransport = new State({
      name:          SessionStateName.DESTROYING_TRANSPORT,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        LOG_DEBUG('Connecting, disposing transport');
        // TODO: is there a string or subCode that can be captured here
        fsm.destroyTransportSession('Disconnecting session', 0);
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        return fsm.SessionConnecting.handleTransportDestroyed.call(this);
      });

    this.WaitingForInterConnectTimeout = new State({
      name:          SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT,
      parentContext: fsm.SessionConnecting,
    })
      .reaction(SessionEventName.CONNECT_WAIT_TIMEOUT, function onConnectWaitTimeout(/*event*/) {
        return this.transitionTo(fsm.WaitingForTransport);
      });

    this.WaitingForTransport = new State({
      name:          SessionStateName.WAITING_FOR_TRANSPORT,
      parentContext: fsm.SessionConnecting,
    })
      .initial(function () {
        var errorMessage = 'Cannot establish transport session: creation failed';
        fsm.setConnectTimer();
        fsm.clearCurrentError();
        try {
          fsm.initTransport();
        } catch (e) {
          this$1.setCurrentError({
            eventText:    e.message === errorMessage ? errorMessage : (errorMessage + ": " + (e.message)),
            errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
            eventReason:  e });
            // TODO:  how do we handle a transition in an entry point
            // and should we reference fsm.SessionConnecting directly or via
            // parentContext? or by var set in parentContext
          return fsm.SessionConnecting.handleTransportDestroyed.call(this$1);
        }
        return this$1.transitionTo(fsm.WaitingForTransportUp);
      });

    this.WaitingForTransportUp = new State({
      name:          SessionStateName.WAITING_FOR_TRANSPORT_UP,
      parentContext: this.WaitingForTransport,
    })
      .initial(function () {
        var errorMessage = 'Cannot establish transport session: connection failed';
        try {
          var returnCode = fsm._transport.connect();
          if (returnCode !== TransportLib.TransportReturnCode.OK) {
            throw new OperationError(
              errorMessage,
              ErrorSubcode.CONNECTION_ERROR,
              TransportLib.TransportReturnCode.describe(returnCode)
            );
          }
          LOG_DEBUG(("Attempting to connect session '" + (fsm.sessionId) + "' to " + (fsm._hosts.currentHostToString())));
        } catch (e) {
          this$1.setCurrentError({
            eventText:    e.message === errorMessage ? errorMessage : (errorMessage + ": " + (e.message)),
            errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
            eventReason:  e });
          // TODO:  how do we handle a transition in an entry point
          // and should we reference fsm.SessionConnecting directly or via
          // parentContext? or by var set in parentContext
          return fsm.SessionConnecting.handleTransportDestroyed.call(this$1);
        }
        return this$1;
      })
      .reaction(SessionEventName.TRANSPORT_UP, function onTransportUp(sEvent) {
        fsm.sessionId = sEvent.sessionId || '';
        var returnCode = fsm.sendClientCtrlLogin();
        if (returnCode === TransportLib.TransportReturnCode.OK) {
          return this.transitionTo(fsm.WaitingForLogin);
        }
        // TODO: capture a subCode from the transport
        var err = {
          eventText:    'Failed to send Client Control Login',
          errorSubcode: ErrorSubcode.LOGIN_FAILURE,
          responseCode: 400,
        };
        fsm.setCurrentError(err);
        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.WaitingForLogin = new State({
      name:          SessionStateName.WAITING_FOR_LOGIN,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        fsm.setClientCtrlTimer();
      })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL, function onClientCtrl(sEvent) {
        var clientCtrlMsg = sEvent.smfMsg;
        var response = clientCtrlMsg.getResponse();
        var respCode = response.responseCode;
        var err = {
          responseCode: respCode,
        };
        fsm._responseCode = respCode;
        if (respCode === 200) {
          if (fsm.checkNoLocal(clientCtrlMsg)) {
            fsm.updateReadonlySessionProps(clientCtrlMsg);
            return this.transitionTo(fsm.ReapplyingSubscriptions);
          }
          Object.assign(err, {
            eventText:    'No Local is not supported by the Solace Message Router',
            errorSubcode: ErrorSubcode.NO_LOCAL_NOT_SUPPORTED,
          });
        } else {
          Object.assign(err, {
            eventText:    response.responseString,
            errorSubcode: ErrorResponseSubcodeMapper.getErrorSubcode(respCode,
                                                                     response.responseString),
          });
        }
        LOG_TRACE('ClientCtrl error', err);
        fsm.setCurrentError(err);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.DOWNGRADE_TIMEOUT, function onDowngradeTimeout(/* event */) {
        if (fsm._transport.requestDowngrade('ClientCtrl timeout', ErrorSubcode.TIMEOUT) === false) {
          fsm.setCurrentError({
            eventText:    'ClientCtrl timeout',
            errorSubcode: ErrorSubcode.TIMEOUT,
          });
          return this.transitionTo(fsm.DestroyingTransport);
        }
        // Don't recreate the transport, just try to connect it
        LOG_TRACE('Downgrade accepted, returning to WaitingForTransportUp');
        return this.transitionTo(fsm.WaitingForTransportUp);
      })
      .exit(function () {
        fsm.clearClientCtrlTimer();
      });

    this.ReapplyingSubscriptions = new State({
      name:          SessionStateName.REAPPLYING_SUBSCRIPTIONS,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        LOG_DEBUG('ReapplyingSubscriptions: entry');
        fsm.copySubscriptionCacheKeys();
      })
      .initial(function onInitial() {
        if (fsm.reapplySubscriptions() === true) {
          // all subscriptions applied and waiting for a subscription confirm
          return this.transitionTo(fsm.WaitForSubConfirm);
        }
        // flow controlled while reapplying
        return this.transitionTo(fsm.WaitForCanAcceptData);
      })
      .reaction(SessionEventName.SUBSCRIBE_TIMEOUT, function onSubscribeTimeout() {
        var respText = 'Subscription timeout while reapplying';
        var subcode = ErrorSubcode.TIMEOUT;
        fsm.setCurrentError({
          eventText:    respText,
          errorSubcode: subcode,
        });
        return this.transition(fsm.DestroyingTransport);
      })
      .exit(function onExit() {
        fsm.clearSubscriptionCacheKeys();
        return this;
      });

    this.WaitForSubConfirm = new State({
      name:          SessionStateName.WAITING_FOR_SUBCONFIRM,
      parentContext: fsm.ReapplyingSubscriptions,
    })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        // process rxMsgObj
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;
        if (respCode !== 200) {
          var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
          LOG_DEBUG("Waiting for subscription confirmation, got " + respCode + " (" + errorSubcode + ") " +
                    "'" + respText + "' on subscription " + subscriptionStr);
          fsm.setCurrentError({
            eventText:    respText,
            responseCode: respCode,
            errorSubcode: errorSubcode,
          });
          return this.transitionTo(fsm.DestroyTransport);
        }

        if (fsm._session.canConnectPublisher &&
            fsm._defaultPublisher &&
            fsm._defaultPublisher.isBindWaiting()) {
          return this.transitionTo(fsm.WaitingForMessagePublisher);
        }
        return this.transitionToExitPoint(fsm.SessionConnecting, 'ConnectedExit');
      });

    this.WaitForCanAcceptData = new State({
      name:          SessionStateName.WAITING_FOR_CAN_ACCEPT_DATA,
      parentContext: fsm.ReapplyingSubscriptions,
    })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        // process rxMsgObj
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;
        // We are not expecting a SMP response as we have not sent a request-confirm
        // so this is almost assuredly an error response to a subscription add
        // check respCode anyway.  if its '200 OK' just ignore it.
        if (respCode !== 200) {
          var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
          LOG_DEBUG("Waiting for can accept data, got " + respCode + " (subcode " + errorSubcode + ") " +
            "'" + respText + "' on subscription " + subscriptionStr);
          fsm.setCurrentError({
            eventText:    respText,
            responseCode: respCode,
            errorSubcode: errorSubcode,
          });
          return this.transitionTo(fsm.DestroyingTransport);
        }
        // unexpected 200 OK repsonse, log it and continue
        LOG_INFO(("Unexpected 200 OK response to subscription add for " + subscriptionStr));
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onTransportCanAcceptData() {
        if (fsm.reapplySubscriptions() === true) {
          // all subscriptions applied and waiting for a subscription confirm
          return this.transitionTo(fsm.WaitForSubConfirm);
        }
        // flow controlled while reapplying
        return this.internalTransition(null);
      });

    this.WaitingForMessagePublisher = new State({
      name:          SessionStateName.WAITING_FOR_PUBFLOW,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        // Inform the publisher that the session is up and the flow establishment can begin.
        fsm._defaultPublisher.connect();
        fsm.sendPublisherSessionUpEvent(fsm._defaultPublisher);
      })
      .reaction(SessionEventName.FLOW_UP, function onEvent() {
        LOG_TRACE(("Flow up " + (this)));
        if (!fsm._defaultPublisher.isBindWaiting()) {
          LOG_TRACE('Publisher up');
          return this.transitionToExitPoint(fsm.SessionConnecting, 'ConnectedExit');
        }
        LOG_TRACE('Waiting for more publishers');
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.FLOW_FAILED, function onEvent(sEvent) {
        // TODO: LOGIN_FAILURE for flow failed? Credentials disallow GM publishing?
        fsm.setCurrentError({
          eventText:    ("Guaranteed Message Publisher Failed: " + (sEvent.eventText)),
          errorSubcode: ErrorSubcode.LOGIN_FAILURE,
        });
        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.SessionTransportUp = new State({
      name:          SessionStateName.TRANSPORT_UP,
      parentContext: fsm,
    })
      .entry(function onEntry() {
        return this;
      })
      .initial(function onInitial() {
        if (fsm._session.canConnectConsumer) {
          // Inform the subscribers that the session is up and the flow establishment can begin.
          fsm._consumers.flows.forEach(function (consumer) { return fsm.sendConsumerSessionUpEvent(consumer); });
        }
        return this.transitionTo(fsm.FullyConnected);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        return this.transitionTo(fsm.SessionDisconnecting);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(sEvent) {
        fsm.setCurrentError(sEvent);
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
        fsm.setCurrentError(sEvent);
        fsm.cleanupSession();
        LOG_TRACE('Reconnecting transport after SEND_ERROR (not fully connected)');
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sEvent) {
        fsm.setCurrentError(sEvent);
        LOG_DEBUG('Received unsolicited TRANSPORT_DESTROYED event while transport is up');
        LOG_TRACE(("TRANSPORT_DESTROYED details: " + sEvent));
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;

        fsm.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, undefined, false);
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onCanAcceptData(sEvent) {
        // Notify client for republishing
        var sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA,
                                                '', null, 0, null, sEvent.toString());
        fsm.emitSessionEvent(sessionEvent);
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.CREATE_SUBSCRIBER, function onCreateSubscriber(sEvent) {
        // Inform the consumer that the session is up and the flow establishment can begin.
        var consumer = fsm._consumers.add(sEvent.guaranteedFlowObject);
        fsm.sendConsumerSessionUpEvent(consumer);
        return this;
      })
      .exit(function onExit() {
        fsm.clearKeepAlive();
        return this;
      });

    this.FullyConnected = new State({
      name:          SessionStateName.FULLY_CONNECTED,
      parentContext: fsm.SessionTransportUp,
    })
      .entry(function () {
        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
        fsm.scheduleKeepAlive();
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
        fsm.setCurrentError(sEvent);
        LOG_TRACE('Disconnecting transport after SEND_ERROR when fully connected');
        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.SessionDisconnected = new State({
      name:          SessionStateName.DISCONNECTED,
      parentContext: fsm,
    })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        fsm.setPostEventAction(function () {
          fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.DISCONNECTED));
        });

        return this.internalTransition(null);
      })
      .reaction(SessionEventName.CONNECT, function onConnect(/* sEvent */) {
        return this.transitionTo(fsm.SessionConnecting);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(/* sEvent */) {
        // do nothing
        return this.internalTransition(null);
      });
    this.SessionDisconnecting = new State({
      name:          SessionStateName.DISCONNECTING,
      parentContext: fsm,
    })
      .initial(function () {
        LOG_DEBUG(("Disconnecting session " + fsm));
        return this$1.transitionTo(fsm.DisconnectingFlows);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
        //
        // As we are in disconnecting state we have initiated the
        // disconnect and need to preserve the error subcode that
        // we set before destroying the transport. The transport, having
        // no error, will usually return a subcode of zero here.
        //
        // This only changes the eventCode, not the subcode. Other properties
        // are preserved.
        //
        fsm.setCurrentError({ errEvent: errEvent });
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(/* sEvent */) {
        LOG_DEBUG('Received unsolicited TRANSPORT_DESTROYED while disconnecting transport');
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      });

    this.DisconnectingFlows = new State({
      name:          SessionStateName.DISCONNECTING_FLOWS,
      parentContext: fsm.SessionDisconnecting,
    }, {
      // Get all flows to disconnect. This will need to be called at least once.
      gatherPendingFlows: function gatherPendingFlows() {
        var this$1 = this;

        var MessageConsumerEventName = ConsumerLib.MessageConsumerEventName;
        var MessagePublisherEventName = PublisherLib.MessagePublisherEventName;

        // Don't re-enter synchronously to look for new flows.
        // Flows disconnect synchronously when they are already disconnected.
        // If this is the case, they throw; they do not emit an event.
        // If a consumer flow is up, it will immediately emit a BIND_WAITING event and we
        // handle that.
        // Since we know that flow#_disconnectSession neither creates a new flow
        // nor calls a user callback that could do so, we need not look for new
        // flows that were created.
        assert(!this.isGathering);
        this.isGathering = true;

        var adaptedListenForDestroy = function (flow, installfn, downEvents) {
          assert(flow, 'Trying to listen to undefined flow');
          // If we already know about this flow, skip it.
          if (this$1.known.has(flow)) { return; }
          LOG_TRACE(("Adding pending flow " + flow));
          this$1.known.add(flow);
          this$1.pending.add(flow);
          var onFlowDown = function () {
            LOG_TRACE(("Removing flow from pending " + flow));
            downEvents.forEach(function (event) { return flow._removeListener(event, onFlowDown); });
            this$1.pending.delete(flow);
            if (!this$1.isGathering) { this$1.checkPendingFlows(); }
          };
          downEvents.forEach(function (event) { return installfn.call(flow, event, onFlowDown); });
          try {
            flow._disconnectSession(); // Session has been disconnected by user
          } catch (ex) {
             // Synchronously down
            LOG_TRACE('Flow disconnect threw');
            onFlowDown();
          }
        };

        if (fsm._defaultPublisher) {
          adaptedListenForDestroy(fsm._defaultPublisher,
                                  fsm._defaultPublisher.once,
                                  [MessagePublisherEventName.DOWN]);
        }
        if (fsm._consumers) {
          fsm._consumers.flows.forEach(function (flow) {
            adaptedListenForDestroy(flow,
                                    flow._once,
                                    [
                                      MessageConsumerEventName.DOWN,
                                      MessageConsumerEventName.DOWN_ERROR ]);
          });
        }

        this.isGathering = false;
      },
      // This function is called whenever a flow comes down, whether sync or async.
      // The body is wrapped in a basic debounce: if we are re-entering (synchronously),
      // no new flows will be added.
      checkPendingFlows: function checkPendingFlows() {
        LOG_TRACE('Waiting for disconnects on', this.pending);
        if (this.pending.size === 0) {
          // We are out of pending flows, but look for new flows that were just added
          this.gatherPendingFlows();
          // Were any flows just added?
          if (this.pending.size === 0) {
            this.proceed();
          }
        }
      },
      proceed: function proceed() {
        // All done!
        // Clear flow sets so they can be disposed
        this.known = null;
        this.pending = null;
        LOG_DEBUG('All flows disconnected');
        fsm.processEvent(new FsmEvent({ name: SessionEventName.FLOWS_DISCONNECTED }));
      },
    })
      .entry(function onEntry() {
        this.known = new Set();
        this.pending = new Set();
        this.checkPendingFlows();
      })
      .reaction(SessionEventName.FLOWS_DISCONNECTED, function onFlowsDisconnected() {
        return this.transitionTo(fsm.FlushingTransport);
      });

    this.FlushingTransport = new State({
      name:          SessionStateName.FLUSHING_TRANSPORT,
      parentContext: fsm.SessionDisconnecting,
    }, {
      flushTransport: function flushTransport() {
        var this$1 = this;

        fsm.cleanupSession();
        fsm.flushTransportSession(function () { return this$1.onTransportFlushed(); });
        this.sessionId = null;
      },
      onTransportFlushed: function onTransportFlushed() {
        fsm.processEvent(new FsmEvent({ name: SessionEventName.TRANSPORT_FLUSHED }));
      },
    })
      .entry(function onEntry() {
        LOG_DEBUG('Flushing transport');
        this.flushTransport();
      })
      .reaction(SessionEventName.TRANSPORT_FLUSHED, function onTransportFlushed() {
        LOG_DEBUG('Handle Transport Flushed');
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      });
  }

  if ( StateMachine ) SessionFSM.__proto__ = StateMachine;
  SessionFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  SessionFSM.prototype.constructor = SessionFSM;

  var prototypeAccessors = { sessionIdHex: {} };

  /**
   * @param {Destination} destination The topic to add
   * @private
   */
  SessionFSM.prototype.addToSubscriptionCache = function addToSubscriptionCache (destination) {
    if (Check.nothing(destination) || !this._subscriptionCache) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var key = destination.name;
    if (this._subscriptionCache[key] === null ||
        this._subscriptionCache[key] === undefined) {
      LOG_DEBUG(("Cache subscription " + key));
      this._subscriptionCache[key] = destination;
      LOG_DEBUG('Increment cache count');
      this._subscriptionCacheCount++;
    } else {
      LOG_DEBUG(("Cache subscription " + key));
      this._subscriptionCache[key] = destination;
    }
  };

  /**
   * @param {String} correlationTag The tag of the request to cancel
   * @returns {CorrelatedRequest} The cancelled request
   * @private
   */
  SessionFSM.prototype.cancelOutstandingCorrelatedReq = function cancelOutstandingCorrelatedReq (correlationTag) {
    if (Check.nothing(correlationTag) || !this._correlatedReqs) {
      return null;
    }
    var req = this._correlatedReqs[correlationTag];
    if (req === null || req === undefined) {
      return null;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    LOG_DEBUG(("Cancel outstanding ctrl request correlationTag=" + correlationTag));
    if (req.timer) {
      clearTimeout(req.timer);
      req.timer = null;
    }
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag), e);
    }
    return req;
  };


  /**
   * @private
   */
  SessionFSM.prototype.cleanupSession = function cleanupSession () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Clean up session');

    var ConsumerFSMEvent = ConsumerLib.ConsumerFSMEvent;
    var ConsumerFSMEventNames = ConsumerLib.ConsumerFSMEventNames;

    if (this._correlatedReqs) {
      Object.keys(this._correlatedReqs).forEach(function (key) { return this$1.cancelOutstandingCorrelatedReq(key); });
    }

    this.clearConnectTimer();
    this.clearClientCtrlTimer();
    this.clearKeepAlive();
    this._consumers.flows.forEach(function (consumer) {
      consumer.processFSMEvent(
        new ConsumerFSMEvent({ name: ConsumerFSMEventNames.SESSION_DOWN })
      );
    });
    if (this._defaultPublisher) {
      this._defaultPublisher.processFSMEvent(
        new PublisherLib.PublisherFSMEvent({
          name: PublisherLib.PublisherFSMEventNames.SESSION_DOWN,
        })
      );
    }
    this._session.cleanupSession();
  };

  /**
   * @private
   */
  SessionFSM.prototype.clearClientCtrlTimer = function clearClientCtrlTimer () {
    if (!this._clientCtrlTimer) {
      return;
    }

    clearTimeout(this._clientCtrlTimer);
    this._clientCtrlTimer = null;
  };


  /**
   * @private
   */
  SessionFSM.prototype.clearConnectTimer = function clearConnectTimer () {
    if (!this._connectTimer) {
      return;
    }

    clearTimeout(this._connectTimer);
    this._connectTimer = undefined;
  };

  /**
   * Cancel keep alive task
   * @private
   */
  SessionFSM.prototype.clearKeepAlive = function clearKeepAlive () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;

    if (this._keepAliveTimer) {
      LOG_DEBUG('Cancel keepalive timer');
      clearInterval(this._keepAliveTimer);
      this._keepAliveTimer = null;
    }

    this.resetKeepAliveCounter();
  };


  /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to parse
   * @returns {Boolean} true if No Local is supported by the router
   * @private
   */
  SessionFSM.prototype.checkNoLocal = function checkNoLocal (clientCtrlMsg) {
    var noLocalSupported = true;
    if (this._sessionProperties.noLocal === true) {
      var caps = clientCtrlMsg.getRouterCapabilities();
      if (!caps) {
        noLocalSupported = false;
      } else {
        // Guard for undefined OR non-boolean capability
        noLocalSupported = (typeof caps[CapabilityType.NO_LOCAL] === 'boolean') ? caps[CapabilityType.NO_LOCAL] : false;
      }
    }
    return noLocalSupported;
  };

  /**
   * Clears the current error exit information for the FSM.
   */
  SessionFSM.prototype.clearCurrentError = function clearCurrentError () {
    this._currentError = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.clearSubscriptionCacheKeys = function clearSubscriptionCacheKeys () {
    this._subscriptionCacheKeys = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.copySubscriptionCacheKeys = function copySubscriptionCacheKeys () {
    // reapply subscriptions if applicable
    this.clearSubscriptionCacheKeys();
    this._subscriptionCacheKeys = Object.keys(this._subscriptionCache || {});

    // Add the P2P Inbox subscription, so the subscriptionCache always has
    // at least one subscription.
    var p2pTopic = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
    this._subscriptionCacheKeys.push(p2pTopic);
  };

  SessionFSM.prototype.createMessagePublisher = function createMessagePublisher () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    if (!this._sessionProperties.publisherProperties.enabled) {
      LOG_DEBUG('Publisher is disabled');
      return;
    }

    var MessagePublisher = PublisherLib.MessagePublisher;
    var MessagePublisherEventName = PublisherLib.MessagePublisherEventName;
    var publisher = new MessagePublisher({
      properties:              this._sessionProperties.publisherProperties,
      sessionInterfaceFactory: this._flowInterfaceFactory,
    });
    publisher.on(
      MessagePublisherEventName.UP,
      function () { return this$1.processEvent(new SessionFSMEvent(
        { name: SessionEventName.FLOW_UP },
        { guaranteedFlowObject: publisher })); });
    publisher.on(
      MessagePublisherEventName.CONNECT_FAILED_ERROR,
      function (event) { return this$1.processEvent(
        new SessionFSMEvent(
          { name: SessionEventName.FLOW_FAILED },
          {
            guaranteedFlowObject: publisher,
            event: event,
            eventText:            event.description,
          })); });

    publisher.on(MessagePublisherEventName.REJECTED_MESSAGE, function (message, ctrlMessage) {
      var header = ctrlMessage.smfHeader;
      var respCode = header.pm_respcode;
      var respText = header.pm_respstr;
      var errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respText);
      var event = SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR,
                                       respText,
                                       respCode,
                                       errorSubcode,
                                       message.getCorrelationKey());
      event['message'] = message; // eslint-disable-line dot-notation
      this$1.emitSessionEvent(event);
    });
    publisher.on(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, function (message) {
      var event = SessionEvent.build(SessionEventCode.ACKNOWLEDGED_MESSAGE,
                                       'Message(s) acknowledged',
                                       undefined,
                                       0,
                                       message.getCorrelationKey());
      event['message'] = message; // eslint-disable-line dot-notation
      this$1.emitSessionEvent(event);
    });
    publisher.on(MessagePublisherEventName.FLOW_NAME_CHANGED, function (data) {
      var messages = data.messages;
      var count = data.count;
      if (count > 0) {
        var event = SessionEvent.build(SessionEventCode.REPUBLISHING_UNACKED_MESSAGES,
                                         "Republishing " + count + " messages due to " +
          'Guaranteed Message Publisher failed to reconnect');
        event['messages'] = messages; // eslint-disable-line dot-notation
        event['count'] = count; // eslint-disable-line dot-notation
        this$1.emitSessionEvent(event);
      }
    });
    publisher.on(MessagePublisherEventName.CAN_SEND, function () {
      this$1.emitSessionEvent(
        SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA,
                           (publisher + " window is now open and can send")));
    });
    publisher.on(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN, function () {
      this$1.emitSessionEvent(
        SessionEvent.build(
          SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN,
          'Guaranteed Message Publishing shut down'));
    });
    this._defaultPublisher = publisher;
  };

  SessionFSM.prototype.sendConsumerSessionUpEvent = function sendConsumerSessionUpEvent (consumer) {
    var ConsumerFSMEvent = ConsumerLib.ConsumerFSMEvent;
    var ConsumerFSMEventNames = ConsumerLib.ConsumerFSMEventNames;
    var isAD = this._session.canConnectConsumer;
    var event = new ConsumerFSMEvent({
      name: isAD
        ? ConsumerFSMEventNames.SESSION_UP
        : ConsumerFSMEventNames.SESSION_UP_NO_AD,
    });
    event.guaranteedFlowObject = consumer;
    consumer.processFSMEvent(event);
  };

  SessionFSM.prototype.sendPublisherSessionUpEvent = function sendPublisherSessionUpEvent (publisher) {
    var isAD = this._session.canConnectPublisher;
    var event = new PublisherLib.PublisherFSMEvent({
      name: isAD
        ? PublisherLib.PublisherFSMEventNames.SESSION_UP
        : PublisherLib.PublisherFSMEventNames.SESSION_UP_NO_AD,
    });
    event.guaranteedFlowObject = publisher;
    publisher.processFSMEvent(event);
  };

  /**
   * Creates a Guaranteed Messaging Subscriber.
   *
   * @param {Object|MessageConsumerProperties} properties Properties for the flow.
   *  Expected fields: {@link solace.MessageConsumerProperties}
   * @returns {solace.MessageConsumer} The newly constructed consumer
   * @private
   */
  SessionFSM.prototype.createMessageConsumer = function createMessageConsumer (properties) {
    var MessageConsumer = ConsumerLib.MessageConsumer;
    var consumer = new MessageConsumer({
      properties: properties,
      sessionInterfaceFactory: this._flowInterfaceFactory,
    });
    var info = { guaranteedFlowObject: consumer };
    // Will be added to the guaranteed flow collection by dispatching
    this.processEvent(
      new SessionFSMEvent({ name: SessionEventName.CREATE_SUBSCRIBER }, info)
    );
    return consumer;
  };

  /**
   * @param {String} msg The status message for the operation
   * @param {Subcode} subcode The subcode reason for the operation
   * @private
   */
  SessionFSM.prototype.destroyTransportSession = function destroyTransportSession (msg, subcode) {
    if (Check.nothing(this._transport)) {
      // Just send the event
      this.processEvent(
        new SessionFSMEvent({ name: SessionEventName.TRANSPORT_DESTROYED })
      );
      return;
    }
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    LOG_DEBUG('Destroy transport session');

    var returnCode = this._transport.destroy(msg, subcode);
    this._smfClient = null;

    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      LOG_ERROR(("Failed to destroy transport session, return code: " + (TransportLib.TransportReturnCode.describe(returnCode))));
    }
  };


  /**
   * Release all resources associated with the session.
   * @private
   */
  SessionFSM.prototype.disposeInternal = function disposeInternal () {
    var this$1 = this;

    if (this._disposed) {
      return;
    }

    var operations = {
      'transport': function () {
        this$1.destroyTransportSession('Disposing', 0);
        this$1._transport = null;
        this$1._smfClient = null;
      },
      'session': function () {
        this$1.cleanupSession();
        this$1._session = null;
        this$1._sessionProperties = null;
        this$1._correlatedReqs = null;
        this$1._flowInterfaceFactory = null;
      },
      'statistics': function () {
        if (this$1._sessionStatistics) {
          this$1._sessionStatistics.resetStats();
          this$1._sessionStatistics = null;
        }
        this$1._kaStats = null;
      },
      'subscription cache': function () {
        if (this$1._subscriptionCache) {
          Object.keys(this$1._subscriptionCache).forEach(
            function (key) { return this$1.removeFromSubscriptionCache(key); }
          );
          this$1._subscriptionCache = null;
        }
        this$1.clearSubscriptionCacheKeys();
        this$1._subscriptionCacheCount = 0;
      },
      'MessagePublishers': function () {
        if (this$1._defaultPublisher) {
          this$1._defaultPublisher.dispose();
          this$1._defaultPublisher = null;
        }
      },
      'MessageConsumers': function () {
        this$1._consumers.disposeAll();
        this$1._consumers = null;
      },
      'host list': function () {
        this$1._currentHost = null;
        this$1._hosts = null;
      },
    };

    Object.keys(operations).forEach(function (operationKey) {
      var ref = this$1.logger;
      var LOG_TRACE = ref.LOG_TRACE;
      var LOG_INFO = ref.LOG_INFO;
      var operation = operations[operationKey];
      try {
        LOG_TRACE(("Dispose: " + operationKey));
        operation();
        LOG_TRACE(("Dispose: " + operationKey + " succeeded"));
      } catch (ex) {
        LOG_INFO(("Dispose: " + operationKey + " failed:"), ex, '...continuing');
      }
    });
    this._disposed = true;
  };

  SessionFSM.prototype.emitSessionEvent = function emitSessionEvent (event) {
    // Don't log here; callee does it
    this._session.sendEvent(event);
  };

  /**
   * @param {Number} correlationTag The correlation tag
   * @param {function} reqTimeoutCb The timeout callback
   * @param {Number} reqTimeout The timeout in milliseconds
   * @param {Object} correlationKey The correlation key
   * @param {function} respRecvCallback The success callback
   * @private
   */
  SessionFSM.prototype.enqueueOutstandingCorrelatedReq = function enqueueOutstandingCorrelatedReq (correlationTag,
                                  reqTimeoutCb,
                                  reqTimeout,
                                  correlationKey,
                                  respRecvCallback) {
    if (Check.nothing(correlationTag)) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG(("Enqueue outstanding ctrl request correlationTag=" + correlationTag));
    var timer = null;
    if (reqTimeoutCb) {
      timer = setTimeout(reqTimeoutCb, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
    }

    var outstandingReq = new CorrelatedRequest(correlationTag,
      timer,
      correlationKey,
      respRecvCallback);
    this._correlatedReqs[correlationTag] = outstandingReq;
  };

  /**
   * @param {String} errorEventText Description of the error
   * @param {ErrorSubcode} errorSubcode Subcode for the error
   * @param {String} [eventReason] The reason for the error
   * @returns {undefined}
   * @memberof SessionFSM
   * @private
   */
  SessionFSM.prototype.errorInFsm = function errorInFsm (errorEventText, errorSubcode, eventReason) {
    if ( eventReason === void 0 ) eventReason = null;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var sEvent = new SessionFSMEvent({ name: SessionEventName.EXCEPTION });
    LOG_DEBUG(("Handling error in FSM: " + errorEventText + " " + (eventReason && eventReason.stack)));
    this.setCurrentError({
      eventText: errorEventText,
      errorSubcode: errorSubcode,
      eventReason: eventReason,
    });
    return this.processEvent(sEvent);
  };

  SessionFSM.prototype.flushTransportSession = function flushTransportSession (callback) {
    if (this._transport) {
      this._transport.flush(callback);
    } else {
      callback();
    }
  };

  /**
   * TODO:  This should probably be a static method on smf not necessarily instantiated in every
   * smfClient.  Look into adding correlation tag when objects are create
   * (AdProtocolMsg, clientCtrlMsg) then retrieving it from those objects.
   * Re: tags created in messages; do we really want to decrease performance of message generation?
   * Those message types do not necessarily require correlation tags. Could generate when required
   * based on message object subtype (e.g. OPENFLOW).
   * @returns {Number} The next correlation tag
   * @private
   */
  SessionFSM.prototype.getCorrelationTag = function getCorrelationTag () {
    return this._smfClient.nextCorrelationTag();
  };

  /**
   * Get current state name
   * @returns {String} The name of the current state, or SessionStateName.DISPOSED if the
   *  FSM is terminated
   * @private
   */
  SessionFSM.prototype.getCurrentStateName = function getCurrentStateName () {
    var currentState = this.getCurrentState();

    if (!currentState) { return null; }
    if (currentState === this.getFinalState()) { return SessionStateName.DISPOSED; }
    return this.getCurrentState().getName();
  };

  /**
   * Returns the value of a given {@link StatType}.
   *
   * @param {StatType} statType The statistic to query.
   * @returns {?Number} The value for the given stat, if available
   * @private
   */
  SessionFSM.prototype.getStat = function getStat (statType) {
    if (this._sessionStatistics === undefined) {
      return undefined;
    }
    //
    // TX_TOTAL_DATA_MSGS and TX_TOTAL_DATA_BYTES are summary counters
    // These stats are calculated as the sum of DIRECT/PERSISTENT/NONPERSISTENT
    // counters.  This is by design since day one.  As such they do not include
    // the count of redelivered messages/bytes as TX_PERSISTENT_MSGS and TX_NONPERSISTENT_MSGS
    // only includes the counts of messages successfully delivered. This is not consistent
    // with receive stats but it is what it is. This definition is consistent with the other
    // existing APIs (CCSMP and JCSMP).
    //
    if (statType === StatType.TX_TOTAL_DATA_MSGS) {
      return this._sessionStatistics.getStat(StatType.TX_DIRECT_MSGS) +
        this._sessionStatistics.getStat(StatType.TX_PERSISTENT_MSGS) +
        this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_MSGS);
    } else if (statType === StatType.TX_TOTAL_DATA_BYTES) {
      return this._sessionStatistics.getStat(StatType.TX_DIRECT_BYTES) +
        this._sessionStatistics.getStat(StatType.TX_PERSISTENT_BYTES) +
        this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_BYTES);
    }
    return this._sessionStatistics.getStat(statType);
  };

  /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} The current status of the transport
   */
  SessionFSM.prototype.getTransportInfo = function getTransportInfo () {
    if (Check.nothing(this._transport)) {
      return 'Not connected.';
    }
    return this._transport.getInfoStr();
  };

  /**
   * Handle an AD CTRL message given the message, its header, and the previously-identified
   * candidate flow, which is used if the message has no correlation tag.
   *
   * @param {AdProtocolMessage} message The message to handle
   * @param {SMFHeader} header The header of the message
   * @returns {SessionFSM} This FSM.
   * @private
   */
  SessionFSM.prototype.handleADCtrlMessage = function handleADCtrlMessage (message, header) {
    var flowId = message.getFlowId();
    var respText = header.pm_respstr;
    var correlationTag = header.pm_corrtag;
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;

    if (correlationTag) {
      // Correlation tag is non-null
      // Session handles correlated request-reply
      this.updateRxStats(message);

      LOG_DEBUG(("Handle SMF response for correlationTag " + correlationTag));
      // find matching correlationTag to cancel timer
      var cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
      if (Check.nothing(cancelledRequest)) {
        return this.errorInFsm(("Cannot find matching request for response: " + respText),
                               ErrorSubcode.INTERNAL_ERROR);
      }

      if (cancelledRequest.respRecvdCallback) {
        // call callback referenced by cancelledRequest
        // login or update property
        cancelledRequest.respRecvdCallback(message, cancelledRequest);
        return this;
      }

      LOG_DEBUG(("Dropping ADCTRL message due to mismatched correlation tag " + correlationTag));
      this.incStat(StatType.RX_REPLY_MSG_DISCARD);
      return this;
    }

    // Unsolicited control message
    var flow;
    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.CLIENTACK:
      case SMFAdProtocolMessageType.CLIENTNACK:
      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
        if (this._defaultPublisher.flowId === flowId) {
          flow = this._defaultPublisher;
        } // else drop.
        break;
      default:
        flow = this._consumers.getFlowById(flowId);
    }

    if (flow && !flow.disposed) {
      // Found a matching flow
      this.updateRxStats(message, flow);
      flow.handleUncorrelatedControlMessage(message);
      return this;
    }

    // No matching flow
    var response = message.getResponse();
    var rc = response ? ("\"" + (response.responseCode) + " " + (response.responseString) + "\" ") : '';
    LOG_WARN(
      ("Dropping ADCTRL." + (SMFLib.SMFAdProtocolMessageType.describe(message.msgType)) + " " + rc + "for unknown flow " + flowId)
    );
    this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);

    return this;
  };

  /**
   * @param {solace.Message} message The AD data message to handle
   * @param {SMFHeader} header The header for the message
   * @returns {MessageConsumer} The flow that handled the message, or `null`
   * @private
   */
  SessionFSM.prototype.handleADTrMessage = function handleADTrMessage (message, header) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var flowId = header.pm_ad_flowid;
    // Get a flow from that ID if possible.
    var flow = this._consumers.getFlowById(flowId);
    if (!flow || flow.disposed) {
      LOG_DEBUG('Dropped incoming AD message for ' +
                (flow ? 'disposed' : 'unknown') + " flow ID " + flowId);
      this.updateRxStats(message, this._sessionStatistics);
      this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
      return null;
    }
    this.updateRxStats(message, flow);
    flow.handleDataMessage(message);
    return flow;
  };

  /**
   * @param {String} correlationTag The correlation tag for the timed out subscription request
   * @param {String} [timeoutMsg] The reason for the timeout
   * @private
   */
  SessionFSM.prototype.handleApiSubscriptionTimeout = function handleApiSubscriptionTimeout (correlationTag, timeoutMsg) {
    // remove request from queue
    if (this._correlatedReqs[correlationTag] === undefined ||
        this._correlatedReqs[correlationTag] === null) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    LOG_DEBUG(((timeoutMsg || 'Subscription timeout') + " for correlationTag=" + correlationTag));
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag + ", exception: " + (e.message)));
    }
  };

  /**
   * @param {ClientCtrlMessage} message The message to handle
   * @param {SMFHeader} header The header from the message
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleClientCtrlMessage = function handleClientCtrlMessage (message, header) {
    var correlationTag;
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    this.updateRxStats(message);
    if (message.msgType === SMFLib.SMFClientCtrlMessageType.LOGIN) {
      // Currently, login requests don't use a correlation tag.
      // Using here a fake internal one to match the request.
      correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
      LOG_DEBUG('Handle SMF response for ClientCTRL Login');
    } else {
      correlationTag = header.pm_corrtag;
      LOG_DEBUG(("Handle SMF response for correlationTag " + correlationTag));
    }
    // find matching correlationTag to cancel timer
    var cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
    if (Check.nothing(cancelledRequest)) {
      var respText = header.pm_respstr;
      return this.errorInFsm(("Cannot find matching request for response: " + respText),
                             ErrorSubcode.INTERNAL_ERROR);
    } else if (cancelledRequest.respRecvdCallback) {
      // call callback referenced by cancelledRequest
      // login or update property
      return cancelledRequest.respRecvdCallback(message);
    }

    LOG_DEBUG(("Dropping ClientCtrl message due to mismatched correlation tag " + correlationTag));
    return this.incStat(StatType.RX_REPLY_MSG_DISCARD);
  };

  /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to handle
   * @private
   */
  SessionFSM.prototype.handleClientCtrlResponse = function handleClientCtrlResponse (clientCtrlMsg) {
    var sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL });
    sEvent.smfMsg = clientCtrlMsg;
    this.processEvent(sEvent);
  };

  /**
   * @private
   */
  SessionFSM.prototype.handleClientCtrlTimeout = function handleClientCtrlTimeout () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('ClientCtrl timeout for session');
    var sEvent = new SessionFSMEvent({ name: SessionEventName.DOWNGRADE_TIMEOUT });
    this.processEvent(sEvent);
  };


  /**
   * @private
   */
  SessionFSM.prototype.handleConnectTimeout = function handleConnectTimeout () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    LOG_DEBUG('Connection timeout. Disconnecting');
    var sEvent = new SessionFSMEvent({ name: SessionEventName.CONNECT_TIMEOUT });
    this.processEvent(sEvent);
  };

  /**
   * Handle control request timeout
   * @param {String} correlationTag The correlation tag for the timed out operation
   * @param {String} timeoutMsg The message associated with the timeout
   * @private
   */
  SessionFSM.prototype.handleUpdatePropertyTimeout = function handleUpdatePropertyTimeout (correlationTag, timeoutMsg) {
    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    // remove request from queue
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag + ", exception: " + (e.message)));
    }

    // notify client
    var sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                            timeoutMsg,
                                            null,
                                            ErrorSubcode.TIMEOUT,
                                            null,
                                            null);
    this.sendEvent(sessionEvent);
  };

  /**
   * @param {SMFHeader} header The header from the rejected message
   * @private
   */
  SessionFSM.prototype.handleRejectedTrMessage = function handleRejectedTrMessage (header) {
    // It is trmsg response. For direct message, it must be a failure response
    var respCode = header.pm_respcode;
    var respText = header.pm_respstr;
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
    this.emitSessionEvent(SessionEvent.build(
      SessionEventCode.REJECTED_MESSAGE_ERROR,
      respText,
      respCode,
      errorSubcode)
    );
  };

  /**
   * @param {solace.Message} message The SMF message to handle
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleSMFMessage = function handleSMFMessage (message) {
    try {
      // Stats for this message might affect both the session and the flow. Need to
      // determine where the message is handled before handling stats.
      // Some ADCTRL messages have no flow ID but only a correlation tag.
      // These are OPENFLOW and we count them as handled by the session.

      var header = message.smfHeader;

      if (header.discardMessage) {
        // UH==2 on an unknown parameter
        if (this._sessionStatistics) {
          this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
        }
        // do nothing.
        return null;
      }

      // Each message type handler must call this.updateRxStats(message, target).
      // The direct/TRmsg path includes the call here in the switch.
      switch (header.smf_protocol) {
        case SMFLib.SMFProtocol.TRMSG:
          if (header.smf_adf) {
            return this.handleADTrMessage(message, header);
          }
          this.updateRxStats(message, this._sessionStatistics);
          return header.pm_respcode === 0
            ? this._session.handleDataMessage(message)
            : this.handleRejectedTrMessage(header);

        case SMFLib.SMFProtocol.ADCTRL:
          return this.handleADCtrlMessage(message, header);

        case SMFLib.SMFProtocol.CLIENTCTRL:
          return this.handleClientCtrlMessage(message, header);

        case SMFLib.SMFProtocol.SMP:
          return this.handleSMPMessage(message, header);

        case SMFLib.SMFProtocol.KEEPALIVE:
        case SMFLib.SMFProtocol.KEEPALIVEV2:
          // do nothing
          return null;

        default:
          return this.handleUnknownProtocolMessage(message, header);
      }
    } catch (e) {
      var ref = this.logger;
      var LOG_ERROR = ref.LOG_ERROR;
      LOG_ERROR(("Exception in handleSMFMessage, exception: " + (e.stack)));
      return this.errorInFsm(("Exception in handleSMFMessage: " + (e.message)),
                             e.subcode || ErrorSubcode.INTERNAL_ERROR,
                             e);
    }
  };

  /**
   * @param {TransportError} transportError The SMF parsing error passed from the transport
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleSMFParseError = function handleSMFParseError (transportError) {
    // fatal connection error

    // notify client
    return this.errorInFsm(transportError,
                           ErrorSubcode.PROTOCOL_ERROR); // TODO: should this be PARSE_FAILURE
  };

  SessionFSM.prototype.handleSMPMessage = function handleSMPMessage (message, header) {
    this.updateRxStats(message);

    // find matching correlationTag to cancel timer
    var cancelledRequest = this.cancelOutstandingCorrelatedReq(header.pm_corrtag || '');
    /*
     * If we find the correlationTag and it has a callback associated with it
     * then call that callback.  It is likely calling back straight to the application
     * due to a call to session.subscribe() or session.unsubscribe() or
     * session.updateProperty().
     * Otherwise just send a TRANSPORT_PROTOCOL_SMP event to the FSM.
     */
    if (Check.nothing(cancelledRequest) || Check.nothing(cancelledRequest.respRecvdCallback)) {
      /*
       * correlation tag not found, probably an error response to a subscription
       * request that did not request-confirm,  or it could be one of the
       * FSM generated subscriptions and the callback is the anonymous function
       * in state WaitingForSubConfirmm
       */
      var sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_PROTOCOL_SMP });
      sEvent.smfMsg = message;
      return this.processEvent(sEvent);
    }

    // calling through the callback, this should  be a callback in the _session for
    // applicated generated subscribe/unsubscribe/updateProperty(clientName)
    return cancelledRequest.respRecvdCallback(message, cancelledRequest);
  };

  /**
   * @param {Number} respCode The router response code
   * @param {String} respText The router response text
   * @param {String} subscriptionStr The subscription cache key
   * @param {CorrelatedRequest} request The associated request
   * @param {Boolean} confirm Whether the user wanted confirmation for the request
   * @private
   */
  SessionFSM.prototype.handleSubscriptionUpdateError = function handleSubscriptionUpdateError (respCode, respText, subscriptionStr, request, confirm) {
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);

    //
    // if it is a not-found or already-present error, it does not affect our subscription
    // cache, otherwise remove it from the cache.
    //
    if (!(errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT ||
      errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND)) {
      // remove from cache
      this.removeFromSubscriptionCache(subscriptionStr);
    }

    //
    // notify the client
    //
    this._session.handleSubscriptionUpdateError(respCode,
                                                respText,
                                                subscriptionStr,
                                                request,
                                                confirm);
  };

  /**
   * @param {String} correlationTag The correlation tag for the timed out request
   * @private
   */
  SessionFSM.prototype.handleSubscriptionTimeout = function handleSubscriptionTimeout (correlationTag) {
    // remove request from queue
    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag), e);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.SUBSCRIBE_TIMEOUT });
    this.processEvent(sEvent);
  };

  /**
   * @param {TransportSessionEvent} transportEvent The event to handle
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleTransportEvent = function handleTransportEvent (transportEvent) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;
    var infoStr = transportEvent.getInfoStr() || '';
    LOG_DEBUG(("Receive transport event: " + transportEvent));

    var sEvent;

    switch (transportEvent.getTransportEventCode()) {
      case TransportLib.TransportSessionEventCode.UP_NOTICE:
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_UP });
        sEvent.sessionId = transportEvent.getSessionId();
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.DESTROYED_NOTICE:
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_DESTROYED });
        sEvent.sessionId = transportEvent.getSessionId();
        sEvent.eventText = infoStr;
        sEvent.errorSubcode = transportEvent.getSubcode();
        sEvent.eventReason = transportEvent;
        this._smfClient = null; // calling reset does nothing useful here
        this._transport = null; // transport has been destroyed
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.CAN_ACCEPT_DATA:
        //
        // unblock the publisher too
        this.GuaranteedFlowControlledRelief();
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_CAN_ACCEPT_DATA });
        sEvent.sessionId = transportEvent.getSessionId();
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.SEND_ERROR:
        sEvent = new SessionFSMEvent({ name: SessionEventName.SEND_ERROR });
        sEvent.sessionId = transportEvent.getSessionId();
        sEvent.eventText = transportEvent.getInfoStr();
        sEvent.errorSubcode = transportEvent.getSubcode();
        sEvent.eventReason = transportEvent;
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.DATA_DECODE_ERROR:
      case TransportLib.TransportSessionEventCode.PARSE_FAILURE:
        // fatal connection error
        return this.errorInFsm(transportEvent.getInfoStr(),
                               transportEvent.getSubcode());
      default:
        LOG_WARN('Received unknown transport session event', transportEvent);
    }

    return true;
  };

  /**
   * @param {BaseMessage|Message} message The message to handle
   * @param {SMFHeader} [header] The SMF header from the message, if available
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleUnknownProtocolMessage = function handleUnknownProtocolMessage (message, header) {
    var ref = this.logger;
    var LOG_INFO = ref.LOG_INFO;
    var LOG_ERROR = ref.LOG_ERROR;
    // unknown protocol
    this.updateRxStats(message);
    if (header && header.smf_protocol === SMFLib.SMFProtocol.TSESSION) {
      // change state
      LOG_ERROR(("Received transport session message instead of SMF message, protocol 0x" + (formatHexString(header.smf_protocol))));
      LOG_ERROR(("Transport MessageType=" + (message.messageType) + ", target sessionId=" + (formatHexString(message.sessionId))));
      // notify client
      return this.errorInFsm('Received message with unknown protocol',
                             ErrorSubcode.PARSE_FAILURE);
    }

    // Drop message of unknown protocol and increment stats
    if (this._sessionStatistics) {
      this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
    }
    LOG_INFO(("Drop message with unknown protocol 0x" + (formatHexString(header.smf_protocol))));
    return null;
  };


  /**
   * Increments a session statistic
   *
   * @param {StatType} statType The key to increment
   * @param {?Number} value The amount to increment the value by
   * @returns {?Number} The new value for the statistic
   * @private
   */
  SessionFSM.prototype.incStat = function incStat (statType, value) {
    return this._sessionStatistics ? this._sessionStatistics.incStat(statType, value) : undefined;
  };

  /**
   * @private
   */
  SessionFSM.prototype.initTransport = function initTransport () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var host = this._currentHost;
    LOG_DEBUG(("Creating transport session " + host));
    this._kaStats = { lastMsgWritten: 0, lastBytesWritten: 0 };

    this._smfClient = new TransportLib.SMFClient(
      function (rxData) { return this$1.handleSMFMessage(rxData); },
      function (rxError) { return this$1.handleSMFParseError(rxError); },
      this
    );

    this._transport = TransportLib.TransportFactory.createTransport(
      host,
      function (transportEvent) { return this$1.handleTransportEvent(transportEvent); },
      this._smfClient,
      this._sessionProperties.clone(),
      function () { return this$1.sessionIdHex; }
    );
    this.injectTransportInterceptor(this._transportInterceptor);
  };

  /**
   * Installs a transport interceptor for the current and any future transports.
   *
   * The object methods .installed(instance) and .removed(instance) will be called if present, with
   * the transport instance as a parameter.
   *
   * To stop using transport interceptors, supply a null interceptor argument.
   *
   * @param {Object} interceptor An object given access to the internals of the transport instance.
   * @private
   */
  SessionFSM.prototype.injectTransportInterceptor = function injectTransportInterceptor (interceptor) {
    this._transportInterceptor = interceptor;
    if (this._transport) {
      this._transport.setInterceptor(interceptor);
    }
  };

  /**
   * Call from keep alive scheduled task
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.keepAliveTimeout = function keepAliveTimeout () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_INFO = ref.LOG_INFO;
    LOG_TRACE('KeepAlive timeout');

    // session is in connected state but hasn't received keep alive response
    // Less than or equal to because this is the number of *already sent* KAs
    if (this._keepAliveCounter >= this._sessionProperties.keepAliveIntervalsLimit) {
      LOG_INFO(("Exceed maximum keep alive intervals limit " + (this._sessionProperties.keepAliveIntervalsLimit)));
      // stop timers
      LOG_DEBUG('Stop keep alive timer');
      if (this._keepAliveTimer) {
        clearInterval(this._keepAliveTimer);
      }

      // change session state
      return this.errorInFsm('Exceed maximum keep alive intervals limit',
                             ErrorSubcode.KEEP_ALIVE_FAILURE);
    }

    LOG_TRACE('About to send keep alive');

    var clientStats = this._transport.getClientStats();
    var prestatMsgWritten = clientStats.msgWritten;
    var prestatBytesWritten = clientStats.bytesWritten;

    var kaMsg = new SMFLib.KeepAliveMessage();
    var returnCode = this.send(kaMsg, null, true);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      /*
       * TransportReturnCode.NO_SPACE is not possible.
       * Send is called with the forceAllowEnqueue parameter.
       * So whatever error is returned is fatal
       */
      return this.errorInFsm('Cannot send keep alive message',
                             ErrorSubcode.KEEP_ALIVE_FAILURE);
    }

    // We need to avoid incrementing the KA counter if we're in the process of
    // sending a huge message and we've had no opportunity to write a KA message.
    // Detection: last KA's snapshot of messages written is unchanged, but number of bytes
    // written has gone up.
    if (this._kaStats.lastMsgWritten === prestatMsgWritten &&
      this._kaStats.lastBytesWritten < prestatBytesWritten) {
      LOG_DEBUG('Keep alive sent',
                'Not incrementing keep alive counter due to large message send',
                ("KA count = " + (this._keepAliveCounter))
      );
    } else {
      this._keepAliveCounter++;
      LOG_TRACE(("Last message written: " + (this._kaStats.lastMsgWritten)));
      LOG_TRACE(("Last bytes written: " + (this._kaStats.lastBytesWritten)));
      LOG_TRACE(("Keep alive sent, increment keep alive counter, keep alive count = " + (this._keepAliveCounter)));
    }
    this._kaStats.lastBytesWritten = clientStats.bytesWritten;
    this._kaStats.lastMsgWritten = clientStats.msgWritten;

    return true;
  };

  /**
   * Prepares a message for sending and then invoke the transport
   * send method. For guaranteed messages, pass the transport send
   * method to the publisher so it can be invoked from there and errors
   * handled within the publisher FSM.
   * @param {BaseMessage} message The message to prepare.
   * @private
   */
  SessionFSM.prototype.prepareAndSendMessage = function prepareAndSendMessage (message) {
    if (message instanceof Message) {
      var returnCode;
      // Delegate message preparation where appropriate
      var deliveryMode = message.getDeliveryMode();
      switch (deliveryMode) {

        case MessageDeliveryModeType.DIRECT:
          if (!this._transport) { return; }
          returnCode = this.sendToTransport(message);
          break;

        case MessageDeliveryModeType.PERSISTENT:
        case MessageDeliveryModeType.NON_PERSISTENT:
          if (!this._defaultPublisher) {
            var reason = this._session.adLocallyDisabled
                ? 'locally disabled'
                : 'remotely unsupported';
            throw new OperationError('Session does not provide Guaranteed Message Publish capability',
                                       ErrorSubcode.GM_UNAVAILABLE,
                                       reason);
          } else {
            if (this._gmSendDisallowed) { this._gmSendDisallowed(); } // throws if present
            returnCode = this._defaultPublisher.prepareAdMessageAndSend(message);
          }
          break;

        default: {
          var ref = this.logger;
          var LOG_ERROR = ref.LOG_ERROR;
          LOG_ERROR('Unhandled message delivery mode', MessageDeliveryModeType.describe(deliveryMode));
        }
      }

      if (returnCode !== TransportLib.TransportReturnCode.OK) {
        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
          // Must be DIRECT message because the Publisher handles NO_SPACE returnCode
          // internally
          throw new OperationError('Cannot send message - no space in transport',
            ErrorSubcode.INSUFFICIENT_SPACE,
            TransportLib.TransportReturnCode.describe(returnCode));
        }

        // This is a fatal session error
        this.setCurrentError(new OperationError('Cannot send message',
            ErrorSubcode.INVALID_OPERATION,
            TransportLib.TransportReturnCode.describe(returnCode)));
        this.processEvent(new SessionFSMEvent({ name: SessionEventName.EXCEPTION }));
      }
    }
  };

  SessionFSM.prototype.GuaranteedFlowControlledRelief = function GuaranteedFlowControlledRelief () {
    if (this._defaultPublisher) {
      this._defaultPublisher.processFSMEvent(
        new PublisherLib.PublisherFSMEvent({
          name: PublisherLib.PublisherFSMEventNames.CAN_SEND }));
    }
  };
  /**
   * Reapply subscriptions.
   * @returns {Boolean} True if all subscriptions were reapplied. False if WOULD_BLOCK.
   * @private
   */
  SessionFSM.prototype.reapplySubscriptions = function reapplySubscriptions () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var createTopicDestination = SolclientFactoryLib.SolclientFactory.createTopicDestination;
    LOG_DEBUG(("Reapplying subscriptions, count=" + (this._subscriptionCacheKeys.length)));
    // add subscriptions and ask for confirm on last one

    if (!this._subscriptionCacheKeys) {
      // Nothing to do
      return true;
    }

    try {
      while (this._subscriptionCacheKeys.length) {
        //
        // The key is the the topic string (topic.getName()).
        // sendSubscribe() requires a destination, so we encode it here.
        //
        // on entry to reapplySubscriptions we added the P2P topic to
        // subscriptionCacheKeys but there is no corresponding entry in
        // _subscriptionCache so we no longer use the key to index that actual
        // cache.
        // If it becomes necesary to pass the Topic object to sendSubscribe in a
        // a future enhancement (perhaps to remember flags like request-confirm) then
        // this logic here needs to be revisisted.
        var key = this$1._subscriptionCacheKeys.shift();
        var requestConfirmation = this$1._subscriptionCacheKeys.length === 0;
        var topicDestination = createTopicDestination(key);
        var rc = this$1.sendSubscribe(topicDestination,
                                      requestConfirmation,
                                      null,
                                      this$1._sessionProperties.readTimeoutInMsecs,
                                      null);
        if (rc !== TransportLib.TransportReturnCode.OK) {
          this$1.errorInFsm(
            ("Error occurred sending subscription: " + (TransportLib.TransportReturnCode.describe(rc))),
            ErrorSubcode.INTERNAL_ERROR  // TODO: better subcode
          );
        }
      }
    } catch (e) {
      if (e instanceof OperationError && e.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
        LOG_DEBUG('Apply subscriptions blocked due to insufficient space, wait for can accept data event');
        return false;
      }
      this.errorInFsm(("Unexpected expection occurred while reapplying subscriptions: " + e),
                      e.subcode || ErrorSubcode.INTERNAL_ERROR,
                      e);
    }
    return true;    // sent all subscriptions
  };


  /**
   * @param {Destination} topic The topic to remove from the subscription cache
   * @returns {?Destination} The value in the subscription cache at that key
   * @private
   */
  SessionFSM.prototype.removeFromSubscriptionCache = function removeFromSubscriptionCache (topic) {
    if (Check.nothing(topic) || !this._subscriptionCache) {
      return null;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    var key = (topic instanceof Destination) ? topic.name : topic;
    LOG_DEBUG(("Remove subscription " + key));
    var sub = this._subscriptionCache[key];
    if (sub === undefined || sub === null) {
      return null;
    }

    try {
      var result = delete this._subscriptionCache[key];
      if (!result) {
        LOG_ERROR(("Cannot remove subscription " + key));
      } else {
        this._subscriptionCacheCount--;
      }
    } catch (e) {
      LOG_ERROR(("Cannot remove subscription " + key), e);
    }
    return sub;
  };


  /**
   * Reset the FSM state and release all objects. This method is called once from
   * SessionFSM.onInitial
   * @private
   */
  SessionFSM.prototype.reset = function reset () {
    this.resetStats();

    /**
     * The following fields are disposed when disconnect is called
     * and recreated when connect is called again.
     */
    this.sessionId = null;

    // Need to reschedule keepAliveTimer when some other write operation happens
    this._keepAliveTimer = null;
    this.resetKeepAliveCounter();
    this._correlatedReqs = {};

    this._disposed = false;

    this._smfClient = null;
    this._kaStats = { lastMsgWritten: 0, lastBytesWritten: 0 };

    /**
     * The following fields are destroyed when dispose is called
     * and cannot be reinitialized.
     */
    this._subscriptionCache = null;
    this._subscriptionCacheKeys = null;
    this._subscriptionCacheCount = 0;
    if (this._sessionProperties.reapplySubscriptions) {
      this._subscriptionCache = {};
    }

    // When negotiating the initial transport, we can fail and transparently reconnect.
    // this.resetTransportProtocolHandler();
    // this._lastKnownGoodTransport = null;

    // event and error information
    this._eventCode = null;
    this._responseCode = null;
    this.eventText = null;
    this.errorSubcode = null;
    this.eventReason = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.resetKeepAliveCounter = function resetKeepAliveCounter () {
    // Reset the KA counter. Called by the SMFClient on each SMF chunk received (whether full
    // message or not).
    this._keepAliveCounter = 0;
  };

  /**
   * @returns {?} The result of calling resetStats().
   * @private
   */
  SessionFSM.prototype.resetStats = function resetStats () {
    return this._sessionStatistics ? this._sessionStatistics.resetStats() : undefined;
  };


  /**
   * Schedule keep alive task
   * @private
   */
  SessionFSM.prototype.scheduleKeepAlive = function scheduleKeepAlive () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    var ref$1 = this._sessionProperties;
    var keepAliveIntervalInMsecs = ref$1.keepAliveIntervalInMsecs;
    if (keepAliveIntervalInMsecs === 0) {
      // Keepalives disabled
      return;
    }

    if (this._keepAliveTimer) {
      clearInterval(this._keepAliveTimer);
    }

    this._keepAliveTimer = setInterval(function () {
      try {
        this$1.keepAliveTimeout();
      } catch (e) {
        LOG_ERROR('Error occurred in keepAliveTimeout', e);
      }
    }, keepAliveIntervalInMsecs);

    LOG_DEBUG(("Create Keepalive timer " + (this._keepAliveTimer)));
  };

  /**
   * Provide a method for the session object to use to send
   * messages to the transport.  This method is only used internally by
   * the FSM.  The session send() API should invoke sendToTransport() directly
   * so errors are thrown back to the application.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.send = function send (message, statTarget, forceAllowEnqueue) {
    if ( statTarget === void 0 ) statTarget = this._sessionStatistics;
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    try {
      return this.sendToTransport(message, statTarget, forceAllowEnqueue);
    } catch (ex) {
      var ref = this.logger;
      var LOG_TRACE = ref.LOG_TRACE;
      // The send operation threw (or we threw locally), which is always a SessionException.
      LOG_TRACE(("Error sending message: " + (ex.message) + ": " + (ex.stack)));
      this.errorInFsm(("Send operation failed: " + (ex.message)),
                      ex.subcode || ErrorSubcode.CONNECTION_ERROR);
    }
    return TransportLib.TransportReturnCode.CONNECTION_ERROR;
  };

  /**
   * Provide a method for the session object to use to send
   * messages to the transport.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendToTransport = function sendToTransport (message, statTarget, forceAllowEnqueue) {
    if ( statTarget === void 0 ) statTarget = this._sessionStatistics;
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var returnCode = TransportLib.TransportReturnCode.CONNECTION_ERROR;

    if (!this._transport) {
      throw new OperationError('Transport has been destroyed', ErrorSubcode.INTERNAL_ERROR);
    }
    var content = SMFLib.Codec.Encode.encodeCompoundMessage(message);
    returnCode = this._transport.send(content, forceAllowEnqueue);
    switch (returnCode) {
      case TransportLib.TransportReturnCode.OK:
        this.updateTxStats(message, statTarget);
        break;
      case TransportLib.TransportReturnCode.NO_SPACE:
        if (!forceAllowEnqueue) {
          // This is allowed.
          break;
        }
      // Else fall through
      default:
        throw new OperationError(("Transport returned " + (TransportLib.TransportReturnCode.describe(returnCode))),
          ErrorSubcode.INTERNAL_ERROR);
    }

    return returnCode;
  };


  /**
   * Initiates the ClientCtrl handshake, called from transportSessionEvent callback
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendClientCtrlLogin = function sendClientCtrlLogin () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;

    // Don't use the correlation tag. For Login only, the router won't return it.
    var clientCtrlMsg = SMFLib.ClientCtrlMessage.getLogin(this._sessionProperties);
    var returnCode = this.send(clientCtrlMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      this._responseCode = null;
      this.eventReason = null;
      // notify client
      if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
        this.eventText = 'Cannot send client control - no space in transport';
        this.errorSubcode = ErrorSubcode.INSUFFICIENT_SPACE;
      } else {
        LOG_DEBUG(("Cannot send client ctrl, return code " + (TransportLib.TransportReturnCode.describe(returnCode))));
        this.eventText = 'Cannot send client ctrl';
        this.errorSubcode = ErrorSubcode.INVALID_OPERATION;
      }
    } else {
      // enqueue outstanding request, use a fake correlation tag for Login only
      var correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
      LOG_DEBUG(("Using internally correlationTag=" + correlationTag + " for tracking ClientCTRL Login"));
      this.enqueueOutstandingCorrelatedReq(correlationTag,
                                           null,
                                           null,
                                           null,
                                           function (rxMsgObj) { return this$1.handleClientCtrlResponse(rxMsgObj); });

      LOG_DEBUG('Sent client ctrl');
    }
    return returnCode;
  };

  /**
   *
   * Internal method for sending subscriptions from SessionConnecting state (reapply or P2P-inbox)
   *
   * @param {Destination} topic The topic to subscribe
   * @param {Boolean} requestConfirmation If true, expect a reply on success also
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on reply received
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendSubscribe = function sendSubscribe (topic, requestConfirmation, correlationKey, requestTimeout, respRecvdCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    assert(topic instanceof Destination, 'sendSubscribe requires a Destination, not a string');
    LOG_DEBUG('Sending subscribe: ', topic, requestConfirmation, correlationKey);
    var correlationTag = this.getCorrelationTag();
    var smpMsg = SMFLib.SMPMessage.getSubscriptionMessage(correlationTag,
                                                            topic,
                                                            true, // set add == true
                                                            requestConfirmation);
    assert(smpMsg.encodedUtf8Subscription, 'Encoded SMP message was invalid');
    var returnCode = this.send(smpMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      LOG_DEBUG('Subscribe failed', TransportLib.TransportReturnCode.describe(returnCode));
      return returnCode;
    }
    if (requestConfirmation) {
      this.enqueueOutstandingCorrelatedReq(
        correlationTag,
        function () { return this$1.handleSubscriptionTimeout(correlationTag); },
        requestTimeout || this._sessionProperties.readTimeoutInMsecs,
        correlationKey,
        respRecvdCallback);
    }
    return returnCode;
  };

  /**
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to change
   * @param {?} newValue The new value for the property
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendUpdateProperty = function sendUpdateProperty (mutableSessionProperty,
                     newValue,
                     correlationKey,
                     requestTimeout,
                     respRecvdCallback) {
    var this$1 = this;

    var correlationTag = this._smfClient.nextCorrelationTag();
    var smpMsg = SMFLib.ClientCtrlMessage.getUpdate(mutableSessionProperty,
                                                      newValue,
                                                      correlationTag);

    var returnCode = this.send(smpMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      return returnCode;
    }

    this.enqueueOutstandingCorrelatedReq(
      correlationTag,
      function () { return this$1.handleUpdatePropertyTimeout(correlationTag); },
      requestTimeout || this._sessionProperties.readTimeoutInMsecs,
      correlationKey,
      respRecvdCallback);
    return returnCode;
  };

  /**
   * @private
   */
  SessionFSM.prototype.setClientCtrlTimer = function setClientCtrlTimer () {
    var this$1 = this;

    this.clearClientCtrlTimer();

    this._clientCtrlTimer = setTimeout(function () { return this$1.handleClientCtrlTimeout(); },
                                       this._sessionProperties.transportDowngradeTimeoutInMsecs);
  };

  /**
   * @private
   */
  SessionFSM.prototype.setConnectTimer = function setConnectTimer () {
    var this$1 = this;

    this.clearConnectTimer();
    // The hosts lists provides the wait time for inter-host timeouts.
    // This timeout is for the entire list.
    // TODO: connectTimeoutInMsecs was specifically described as the timeout for "a given host",
    // with a timeout of 8 seconds, which appears inappropriate given its use here.
    this._connectTimer = setTimeout(function () { return this$1.handleConnectTimeout(); },
                                    this._sessionProperties.connectTimeoutInMsecs);
  };

  /**
   * Sets the error exit information for the FSM.
   *
   * This applies key-value pairs from properties to the current error object,
   * but does not allow overwriting and does not allow assignment of null or undefined values.
   *
   * Only the following fields are relevant, any other fields transferred to currentError by this
   * method are eventually ignored:
   *    * eventText
   *    * responseCode
   *    * errorSubcode
   *    * eventReason
   *
   * See SessionConnecting exitPoint 'errorExit'. This is the only place the information in
   * currentError is extracted.
   *
   * Could be implemented as `
   * this._currentError = Object.assign({}, filter(properties), this._currentError)
   * `
   * where `filter` is a key-value filter that works as described above.
   *
   * @param {Object} source An object with properties to be applied
   */
  SessionFSM.prototype.setCurrentError = function setCurrentError (source) {
    var target = this._currentError || {};
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    Object.keys(source).forEach(function (key) {
      if (source[key] === null || source[key] === undefined) { return false; }
      if (target[key] !== null && target[key] !== undefined) {
        LOG_TRACE(("Attempt to overwrite property {key=" + key + ", current value=" + (target[key]) + ", incoming value=" + (source[key]) + "}"));
        return false;
      }
      target[key] = source[key];
      return true;
    });
    this._currentError = target;
  };


  /**
   * Send a subscribe or unsubscribe request on behalf of the API.
   * @param {Destination} subject The target for the update
   * @param {Boolean} requestConfirmation Request a success message if true
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout in milliseconds
   * @param {SessionRequestType} requestType The request type
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.subscriptionUpdate = function subscriptionUpdate (subject,
                     requestConfirmation,
                     correlationKey,
                     requestTimeout,
                     requestType,
                     respRecvdCallback) {
    var this$1 = this;

    var timeoutMsg =
      SubscriptionUpdateTimeoutMessages[requestType] ||
      SubscriptionUpdateTimeoutMessages.default;
    var isSMP = (requestType !== SessionRequestType.REMOVE_DTE_SUBSCRIPTION);
    var add = (requestType === SessionRequestType.ADD_SUBSCRIPTION ||
      requestType === SessionRequestType.ADD_P2PINBOX);
    var correlationTag = this.getCorrelationTag();

    var generateMessage = isSMP
      ? SMFLib.SMPMessage.getSubscriptionMessage
      : SMFLib.AdProtocolMessage.getDTEUnsubscribeMessage;
    var msg = generateMessage(correlationTag,
                                subject,
                                add,
                                requestConfirmation);
    var returnCode = this.send(msg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      return returnCode;
    }

    if (requestConfirmation) {
      this.enqueueOutstandingCorrelatedReq(
        correlationTag,
        function () { return this$1.handleApiSubscriptionTimeout(correlationTag,
                                                timeoutMsg); },
        requestTimeout || this._sessionProperties.readTimeoutInMsecs,
        correlationKey,
        respRecvdCallback);
    }
    if (requestType === SessionRequestType.ADD_SUBSCRIPTION &&
      this._sessionProperties.reapplySubscriptions) {
      this.addToSubscriptionCache(subject);
    } else if (requestType === SessionRequestType.REMOVE_SUBSCRIPTION &&
      this._sessionProperties.reapplySubscriptions) {
      this.removeFromSubscriptionCache(subject);
    }
    return returnCode;
  };

  /**
   * @param {BaseMessage|Message} smfMessage The message received
   * @param {Stats} [target] The statistics target to update, default is session stats
   * @private
   */
  SessionFSM.prototype.updateRxStats = function updateRxStats (smfMessage, target) {
    if ( target === void 0 ) target = this._sessionStatistics;

    if (!target) {
      return;
    }
    var smfHeader = smfMessage.smfHeader;
    if (!smfHeader) {
      return;
    }
    var deliveryMode = smfHeader.pm_deliverymode || 0;
    var msgStatKey = STAT_RX_BYMODE_MSGS[deliveryMode];
    var bytesStatKey = STAT_RX_BYMODE_BYTES[deliveryMode];
    var msgLength = smfHeader.messageLength;

    switch (smfHeader.smf_protocol) {
      case SMFLib.SMFProtocol.TRMSG:
        if (smfHeader.pm_respcode === 0) {
          target.incStat(StatType.RX_TOTAL_DATA_MSGS);
          target.incStat(msgStatKey);
          target.incStat(StatType.RX_TOTAL_DATA_BYTES, msgLength);
          target.incStat(bytesStatKey, msgLength);
          if (smfHeader.smf_di) {
            target.incStat(StatType.RX_DISCARD_MSG_INDICATION);
          }
        }
        break;
      case SMFLib.SMFProtocol.CLIENTCTRL:
      case SMFLib.SMFProtocol.SMP:
      case SMFLib.SMFProtocol.KEEPALIVE:
      case SMFLib.SMFProtocol.KEEPALIVEV2:
      case SMFLib.SMFProtocol.ADCTRL:
        target.incStat(StatType.RX_CONTROL_MSGS);
        target.incStat(StatType.RX_CONTROL_BYTES, msgLength);
        break;
      default:
    }
  };

  /**
  * @param {BaseMessage|Message} smfMessage The message sent
  * @param {Stats} [target] The statistics target to update, default is session stats
  * @private
  */
  SessionFSM.prototype.updateTxStats = function updateTxStats (smfMessage, target) {
    if ( target === void 0 ) target = this._sessionStatistics;

    if (!target) {
      return;
    }
    if (smfMessage.getReplyTo !== undefined && smfMessage.getReplyTo()) {
      // update stats
      target.incStat(StatType.TX_REQUEST_SENT);
    }
// TODOD:  Why do we have to get SmfHeader? Can't we can smfMessage.getDeliveryMode();
    var smfHeader = smfMessage.smfHeader;
    if (!smfHeader) {
      return;
    }

    var deliveryMode = smfHeader.pm_deliverymode || 0;
    var msgStatKey = STAT_TX_BYMODE_MSGS[deliveryMode];
    var bytesStatKey = STAT_TX_BYMODE_BYTES[deliveryMode];
    //
    // If this is a Guaranteed Message we may need to further refine the stats by the redelivered
    // status
    if (deliveryMode !== MessageDeliveryModeType.DIRECT) {
      if (smfMessage.isRedelivered()) {
        msgStatKey = STAT_TX_BYMODE_REDELIVERED[deliveryMode];
        bytesStatKey = STAT_TX_BYMODE_BYTES_REDELIVERED[deliveryMode];
      }
    }
    var msgLength = smfHeader.messageLength;

    switch (smfHeader.smf_protocol) {
      case SMFLib.SMFProtocol.TRMSG:
        target.incStat(msgStatKey);
        target.incStat(bytesStatKey, msgLength);
        break;
      case SMFLib.SMFProtocol.CLIENTCTRL:
      case SMFLib.SMFProtocol.SMP:
      case SMFLib.SMFProtocol.KEEPALIVE:
      case SMFLib.SMFProtocol.KEEPALIVEV2:
      case SMFLib.SMFProtocol.ADCTRL:
        target.incStat(StatType.TX_CONTROL_MSGS);
        target.incStat(StatType.TX_CONTROL_BYTES, msgLength);
        break;
      default:
    }
  };

  /**
   * @param {ClientCtrlMessage} clientCtrlRespMsg The client control message with props
   * @private
   */
  SessionFSM.prototype.updateReadonlySessionProps = function updateReadonlySessionProps (clientCtrlRespMsg) {
    var props = this._sessionProperties; // Modify session properties in place

    props._setVpnNameInUse(clientCtrlRespMsg.getVpnNameInUseValue() || '');
    var oldVirtualRouterName = props.virtualRouterName;
    var newVirtualRouterName = clientCtrlRespMsg.getVridInUseValue() || '';
    props._setVirtualRouterName(newVirtualRouterName);
    if (oldVirtualRouterName !== '' && oldVirtualRouterName !== newVirtualRouterName) {
      this.handleVirtualRouterNameChange(oldVirtualRouterName, newVirtualRouterName);
    }

    // The Solace Message Router login response should always contain a P2P topic for this client
    // name. If it doesn't that's an error (and we store "").
    props._setP2pInboxBase(clientCtrlRespMsg.getP2PTopicValue() || '');
    props._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(props.p2pInboxBase));
    this._session.updateCapabilities(clientCtrlRespMsg.getRouterCapabilities());

    // Create and cache a guard for GM sending.
    var gmCap = this._session._getCapability(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
    this._gmSendDisallowed = (typeof gmCap === 'boolean' && !gmCap)
      ? function () {
        throw new OperationError(
        'Sending guaranteed message is not allowed by router for this client',
        ErrorSubcode.INVALID_OPERATION,
        null);
      }
      : null;
  };

  SessionFSM.prototype.handleVirtualRouterNameChange = function handleVirtualRouterNameChange (oldName, newName) {
    if (this._consumers) {
      this._consumers.flows.forEach(function (consumer) { return consumer.onVRNChanged(); });
    }
    this.emitSessionEvent(
      SessionEvent.build(SessionEventCode.VIRTUALROUTER_NAME_CHANGED,
                         ("Virtual router name is changed from " + oldName + " to " + newName),
                         null,
                         0,
                         null,
                         null));
  };

  /**
   * @returns {String} The session's ID in hexadecimal format
   * @private
   */
  prototypeAccessors.sessionIdHex.get = function () {
    return this.sessionId && formatHexString(this.sessionId) || 'N/A';
  };

  Object.defineProperties( SessionFSM.prototype, prototypeAccessors );

  return SessionFSM;
}(StateMachine));

module.exports.SessionFSM = SessionFSM;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionOperation = {
  CONNECT:         'CONNECT',
  DISCONNECT:      'DISCONNECT',
  CTRL:            'CTRL',
  SEND:            'SEND',
  QUERY_OPERATION: 'QUERY_OPERATION',
};

module.exports.SessionOperation = Enum.new(SessionOperation);


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var PublisherLib = __webpack_require__(29);
var SessionPropertiesLib = __webpack_require__(74);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var parseURL = ref.parseURL;
var ref$1 = __webpack_require__(71);
var AuthenticationScheme = ref$1.AuthenticationScheme;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(1);
var LOG_WARN = ref$4.LOG_WARN;
var ref$5 = __webpack_require__(23);
var TransportProtocol = ref$5.TransportProtocol;

var validateInstance = APIPropertiesValidators.validateInstance;
var valArrayIsMember = APIPropertiesValidators.valArrayIsMember;
var valArrayOfString = APIPropertiesValidators.valArrayOfString;
var valBoolean = APIPropertiesValidators.valBoolean;
var valLength = APIPropertiesValidators.valLength;
var valNotEmpty = APIPropertiesValidators.valNotEmpty;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;
var valString = APIPropertiesValidators.valString;
var valStringOrArray = APIPropertiesValidators.valStringOrArray;

var ALLOWED_PROTOCOLS = ['http:', 'https:', 'ws:', 'wss:', 'tcp:', 'tcps:'];

function valClientName(typeDesc, instance, name) {
  // valString and valLength(160) have already been called.
  var error =
    SMFLib.ClientCtrlMessage.validateClientName(
      instance[name],
      function (errorMessage) { return new OperationError((typeDesc + " validation: Property '" + name + "': " + errorMessage),
                           ErrorSubcode.PARAMETER_OUT_OF_RANGE); });
  if (error) {
    throw error;
  }
}

function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
  var val = instance[key];
  if (allowNull && val === null) { return; }
  if (typeof (val) !== 'undefined' && !enumInstance.values.some(function (v) { return v === val; })) {
    throw new OperationError((typeDesc + " validation: Property '" + key + "' must be a member of " + enumName),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
}

function valSslExcludedProtocols(typeDesc, instance, name) {
  var val = instance[name];
  if (Check.array(val)) {
    if (val.length > 0) {
      var supported = SessionPropertiesLib.SessionProperties.SUPPORTED_SSL_PROTOCOLS;
      val.forEach(function (protocol) {
        var prtcl = protocol.toLowerCase();
        if (supported.indexOf(prtcl) < 0) {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' contains unsupported protocol: " + protocol),
                                    ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      });
    }
  }
}

function valSslCipherSuites(typeDesc, instance, name) {
  var val = instance[name];
  if (val && Check.string(val) && !Check.empty(val)) {
    var ciphers = val.split(',');
    var supported = SessionPropertiesLib.SessionProperties.SUPPORTED_CIPHER_SUITES;
    ciphers.forEach(function (cipher) {
      if (supported.indexOf(cipher.trim()) < 0) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' contains unsupported cipher suite: '" + cipher + "'"),
                        ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
    });
  }
}

// maximum number of common names is 16
function valSslTrustedCommonNameList(typeDesc, instance, name) {
  var val = instance[name];
  if (Check.something(val) && Check.array(val) && val.length > 16) {
    throw new OperationError((typeDesc + " validation: Property '" + name + "' length exceeds limit of 16"),
                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
}

function valUrlList(typeDesc, instance, name) {
  var val = instance[name];
  var valArray = typeof val === 'string' ? val.split(',') : val;
  if (!Check.array(valArray)) {
    throw new OperationError((typeDesc + " validation: Property '" + name + "' not an array or comma-delimited string"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  valArray.forEach(function (el) {
    var url = null;
    try {
      url = parseURL(el);
    } catch (ex) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' contained an invalid URL: " + el),
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    if (!Check.included(url.protocol, ALLOWED_PROTOCOLS)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' contained a URL'" + (url.href) + "' with an invalid protocol: '" + (url.protocol) + "'"),
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  });
}

function isHttpTransport(transportProtocol) {
  return (transportProtocol && (
          transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING ||
          transportProtocol === TransportProtocol.HTTP_BINARY ||
          transportProtocol === TransportProtocol.HTTP_BASE64));
}

function validatePropsSupportedByTransport(transportProtocol, nonHttpPropsSet) {
  if (nonHttpPropsSet.length > 0 && isHttpTransport(transportProtocol)) {
    var propNames = nonHttpPropsSet.length <= 5 ? nonHttpPropsSet : nonHttpPropsSet.slice(0, 5);
    throw new OperationError(("SessionProperties validation: properties that are not supported by transport protocol " + transportProtocol + " have been set: " + propNames), ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
}

function useSsl(instance, name) {
  var val = instance[name];
  if (val instanceof Array) {
    // host list is used, iterate to find at least one entry
    var arrayLength = val.length;
    for (var i = 0; i < arrayLength; i++) {
      var currententry = val[i];
      if (Check.string(currententry) && currententry.match(/^(https|wss|tcps):/i)) {
        return true;
      }
    }
    return false;
  }
  return (Check.string(val) && val.match(/^(https|wss|tcps):/i));
}

var SessionPropertiesValidator = {
  validate: function validate(props) {
    // Validation rules: same as JCSMP
    var v = validateInstance.bind(null, 'SessionProperties', props);
    v('url', [valNotEmpty], [valStringOrArray], [valUrlList]);
    v('userName', [valString], [valLength, 189]);
    v('password', [valString], [valLength, 128]);
    v('clientName', [valString], [valLength, 160], [valClientName]);
    v('applicationDescription', [valString], [valLength, 254]);
    v('vpnName', [valString], [valLength, 32]);
    v('connectTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('connectRetriesPerHost', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('connectRetries', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('reconnectRetries', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('reconnectRetryWaitInMsecs', [valNumber], [valRange, 0, 60000]);
    v('readTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('sendBufferMaxSize', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('maxWebPayload', [valNumber], [valRange, 100, Number.MAX_VALUE]);
    if (false) {
      v('bufferedAmountQueryIntervalInMsecs', [valNumber], [valRange, 4, Number.MAX_VALUE]);
    }
    v('generateSendTimestamps', [valBoolean]);
    v('generateReceiveTimestamps', [valBoolean]);
    v('includeSenderId', [valBoolean]);
    v('keepAliveIntervalInMsecs', [valNumber], [valRange, 0, Number.MAX_VALUE]);
    v('keepAliveIntervalsLimit', [valNumber], [valRange, 3, Number.MAX_VALUE]);
    v('generateSequenceNumber', [valBoolean]);
    v('subscriberLocalPriority', [valNumber], [valRange, 1, 4]);
    v('subscriberNetworkPriority', [valNumber], [valRange, 1, 4]);
    v('ignoreDuplicateSubscriptionError', [valBoolean]);
    v('ignoreSubscriptionNotFoundError', [valBoolean]);
    v('reapplySubscriptions', [valBoolean]);
    v('noLocal', [valBoolean]);
    v('transportDowngradeTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);

    if (props.transportProtocol && props.webTransportProtocolList) {
      throw new OperationError("SessionProperties validation: Property 'transportProtocol' and " +
                               "'webTransportProtocolList' cannot be set at the same time",
                               ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    if (props.webTransportProtocolList !== null && props.webTransportProtocolList !== undefined) {
      if (!Array.isArray(props.webTransportProtocolList)) {
        throw new OperationError("Property 'webTransportProtocolList' must be an array if set",
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (props.webTransportProtocolList.length === 0) {
        throw new OperationError("Property 'webTransportProtocolList' must be non-empty if set",
                                 ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
    }

    v('authenticationScheme', [valIsMember, AuthenticationScheme, 'AuthenticationScheme', false]);
    var useClientCert = props.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
    if (!useSsl(props, 'url') && useClientCert) {
      throw new OperationError("SessionProperties validation: Property 'authenticationScheme' cannot be set to client certificate " +
                               'for unsecured sessions', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }

    if (true) {
      // should not happen since transportProtocol and webTransportProtocolList are not public
      if (Check.something(props.transportProtocol) &&
          props.transportProtocol !== TransportProtocol.WS_BINARY) {
        throw new OperationError("SessionProperties validation: properties 'transportProtocol' " +
                                 'can only be WS_BINARY',
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (Check.something(props.webTransportProtocolList)) {
        if (!Check.array(props.webTransportProtocolList)) {
          throw new OperationError('SessionProperties validation: Property ' +
                                   "'webTransportProtocolList' should be type Array",
                                   ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
        if (props.webTransportProtocolList.length !== 1 ||
            props.webTransportProtocolList[0] !== TransportProtocol.WS_BINARY) {
          throw new OperationError('SessionProperties validation: properties ' +
                                   "'webTransportProtocolList' can only contain element WS_BINARY",
                                   ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
      }

      v('sslExcludedProtocols', [valArrayOfString], [valSslExcludedProtocols]);
      v('sslCipherSuites', [valString], [valSslCipherSuites]);
      v('sslValidateCertificate', [valBoolean]);

      if (props.sslValidateCertificate || useClientCert) {
        v('sslTrustStores', [valArrayOfString]);
        v('sslTrustedCommonNameList', [valArrayOfString], [valSslTrustedCommonNameList]);
      }

      if (useClientCert) {
        v('sslPfx', [valString]);
        v('sslPfxPassword', [valString]);
        v('sslPrivateKey', [valString]);
        v('sslPrivateKeyPassword', [valString]);
        v('sslCertificate', [valString]);
        // either sslPfx or sslPrivateKey and sslCertificate must be specified,
        // but not at the same time
        var sslPfxSet = Check.something(props.sslPfx) && props.sslPfx.length;
        var sslPrivateKeySet = (
          Check.something(props.sslPrivateKey) &&
          props.sslPrivateKey.length
        );
        var sslCertSet = (
          Check.something(props.sslCertificate) &&
          props.sslCertificate.length
        );
        if (!sslPfxSet && !sslPrivateKeySet && !sslCertSet) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Either property 'sslPfx', or 'sslPrivateKey' and 'sslCertificate' " +
                                   'must be set when authenticationScheme is client certificate',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
        if (sslPfxSet && (sslPrivateKeySet || sslCertSet)) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Property 'sslPfx' can only be set when 'sslPrivateKey' and 'sslCertificate' " +
                                   'are not set',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
        if ((sslPrivateKeySet && !sslCertSet) || (!sslPrivateKeySet && sslCertSet)) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Property 'sslPrivateKey' and 'sslCertificate' " +
                                   'must be set at the same time',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      }
    }

    v('transportProtocol', [valIsMember, TransportProtocol, 'TransportProtocol', true]);
    v('webTransportProtocolList',
      [valArrayIsMember, TransportProtocol, 'TransportProtocol',
        true, false, false]);

    validatePropsSupportedByTransport(props.transportProtocol,
                                      props.nonHTTPTransportPropsSet);

    if (props.publisherProperties) {
      PublisherLib.MessagePublisherPropertiesValidator.validate(props.publisherProperties);
    }

    // Non-errors

    var recommendedMin = props.defaultConnectTimeoutInMsecs;
    var connectTimeout = props.connectTimeoutInMsecs;
    var transportCount = props.webTransportProtocolList
      ? props.webTransportProtocolList.length
      : 1;
    if (transportCount > 1 && connectTimeout < recommendedMin) {
      LOG_WARN(
        "Connect timeout of " + connectTimeout + " msecs is less than default and recommended " +
        "minimum of " + recommendedMin + " msecs for current transport selection. Transport " +
        'downgrades may not complete.');
    }
  },
};

module.exports.SessionPropertiesValidator = SessionPropertiesValidator;



/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var MessageLib = __webpack_require__(16);
var SolclientFactoryLib = __webpack_require__(9);
var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(80);
var CacheSession = ref$1.CacheSession;
var CACHE_REQUEST_PREFIX = ref$1.CACHE_REQUEST_PREFIX;
var ref$2 = __webpack_require__(43);
var CapabilityType = ref$2.CapabilityType;
var ref$3 = __webpack_require__(7);
var Check = ref$3.Check;
var Parameter = ref$3.Parameter;
var ref$4 = __webpack_require__(210);
var DefaultCapabilities = ref$4.DefaultCapabilities;
var ref$5 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$5.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$5.ErrorSubcode;
var OperationError = ref$5.OperationError;
var RequestEventCode = ref$5.RequestEventCode;
var ref$6 = __webpack_require__(35);
var EventEmitter = ref$6.EventEmitter;
var ref$7 = __webpack_require__(211);
var GlobalContext = ref$7.GlobalContext;
var ref$8 = __webpack_require__(213);
var HostList = ref$8.HostList;
var ref$9 = __webpack_require__(1);
var LogFormatter = ref$9.LogFormatter;
var ref$10 = __webpack_require__(111);
var MessageRxCBInfo = ref$10.MessageRxCBInfo;
var ref$11 = __webpack_require__(112);
var MutableSessionProperty = ref$11.MutableSessionProperty;
var ref$12 = __webpack_require__(214);
var OutstandingDataRequest = ref$12.OutstandingDataRequest;
var ref$13 = __webpack_require__(113);
var P2PUtil = ref$13.P2PUtil;
var ref$14 = __webpack_require__(18);
var QueueDescriptor = ref$14.QueueDescriptor;
var QueueType = ref$14.QueueType;
var ref$15 = __webpack_require__(10);
var SDTField = ref$15.SDTField;
var SDTFieldType = ref$15.SDTFieldType;
var ref$16 = __webpack_require__(73);
var SessionEvent = ref$16.SessionEvent;
var ref$17 = __webpack_require__(114);
var SessionEventCBInfo = ref$17.SessionEventCBInfo;
var ref$18 = __webpack_require__(44);
var SessionEventCode = ref$18.SessionEventCode;
var ref$19 = __webpack_require__(72);
var SessionEventName = ref$19.SessionEventName;
var ref$20 = __webpack_require__(215);
var SessionFSM = ref$20.SessionFSM;
var ref$21 = __webpack_require__(115);
var SessionFSMEvent = ref$21.SessionFSMEvent;
var ref$22 = __webpack_require__(216);
var SessionOperation = ref$22.SessionOperation;
var ref$23 = __webpack_require__(74);
var SessionProperties = ref$23.SessionProperties;
var ref$24 = __webpack_require__(217);
var SessionPropertiesValidator = ref$24.SessionPropertiesValidator;
var ref$25 = __webpack_require__(75);
var SessionRequestType = ref$25.SessionRequestType;
var ref$26 = __webpack_require__(117);
var SessionState = ref$26.SessionState;
var ref$27 = __webpack_require__(116);
var SessionStateName = ref$27.SessionStateName;
var ref$28 = __webpack_require__(19);
var Stats = ref$28.Stats;
var StatType = ref$28.StatType;
var ref$29 = __webpack_require__(4);
var StringUtils = ref$29.StringUtils;
var ref$30 = __webpack_require__(23);
var TransportCapabilities = ref$30.TransportCapabilities;
var TransportProtocol = ref$30.TransportProtocol;
var TransportReturnCode = ref$30.TransportReturnCode;

function transportProtocolDefaultList() {
  var ProfileBinding = SolclientFactoryLib.ProfileBinding;

  if (true) {
    return [TransportProtocol.WS_BINARY];
  }

  var result = [];
  if (TransportCapabilities.web.webSocket()) {
    result.push(TransportProtocol.WS_BINARY);
  }
  var profile = ProfileBinding.value;
  if (profile.cometEnabled) {
    if (TransportCapabilities.web.xhrBinary()) {
      if (TransportCapabilities.web.streaming()) {
        result.push(TransportProtocol.HTTP_BINARY_STREAMING);
      }
      result.push(TransportProtocol.HTTP_BINARY);
    }
    result.push(TransportProtocol.HTTP_BASE64);
  }
  return result;
}

function isValidADTransport(transportProtocol) {
  return (transportProtocol && (
          transportProtocol !== TransportProtocol.HTTP_BINARY_STREAMING &&
          transportProtocol !== TransportProtocol.HTTP_BINARY &&
          transportProtocol !== TransportProtocol.HTTP_BASE64));
}

function formatEventName(eventName) {
  return ("SessionEventCode." + (SessionEventCode.describe(eventName)));
}

/**
 * @private
 */
var SOLCLIENT_REQUEST_PREFIX = '#REQ';

/**
 * A callback that returns replies to requests sent via {@link solace.Session#sendRequest}.
 * The replyReceivedCallback <b>must</b> be provided to the API as the third argument of
 * {@link solace.Sesssion#sendRequest}.
 * @callback
 * @function
 * @name solace.Session.replyReceivedCallback
 * @param {solace.Session} session The session object that received the reply.
 * @param {solace.Message} message The reply message received.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */

/**
 * A callback that returns errors associated with requests sent via
 * {@link solace.Session#sendRequest}. The replyReceivedCallback <b>must</b> be
 * provided to the API as the fourth argument of
 * {@link solace.Sesssion#sendRequest}
 * @callback
 * @function
 * @name solace.Session.requestFailedCallback
 * @param {solace.Session} session The session object associated with the event.
 * @param {solace.RequestError} error The event associated with the failure.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * Applications must use {@link solace.SolclientFactory.createSession} to create a session.
 *
 * Represents a client Session.
 *
 * Session provides these major functions:
 *  * Subscriber control, such as updating subscriptions;
 *  * Publishes both Direct and Guaranteed Messages to the router;
 *  * Receives direct messages from the router.
 *
 * The Session object is an
 * {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}, and will emit
 * events with event names from {@link solace.SessionEventCode} when Session events occur.
 * Each session event can be subscribed using {@link solace.Session#on} with the corresponding
 * {@link solace.SessionEventCode}. If any of the registered event listeners throw an exception,
 * the exception will be emitted on the 'error' event.
 *
 * @fires solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
 * @fires solace.SessionEventCode#CAN_ACCEPT_DATA
 * @fires solace.SessionEventCode#CONNECT_FAILED_ERROR
 * @fires solace.SessionEventCode#DISCONNECTED
 * @fires solace.SessionEventCode#DOWN_ERROR
 * @fires solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
 * @fires solace.SessionEventCode#MESSAGE
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_ERROR
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_OK
 * @fires solace.SessionEventCode#RECONNECTED_NOTICE
 * @fires solace.SessionEventCode#RECONNECTING_NOTICE
 * @fires solace.SessionEventCode#REJECTED_MESSAGE_ERROR
 * @fires solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
 * @fires solace.SessionEventCode#SUBSCRIPTION_ERROR
 * @fires solace.SessionEventCode#SUBSCRIPTION_OK
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
 * @fires solace.SessionEventCode#UP_NOTICE
 * @fires solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
 *
 * @memberof solace
 */
var Session = (function (EventEmitter) {
  function Session(properties, messageCallback, eventCallback) {
    EventEmitter.call(this, {
      emits:  SessionEventCode.values,
      direct: SessionEventCode.MESSAGE,
      formatEventName: formatEventName,
    });
    var self = this;
    this.logger = new LogFormatter();
    this.logger.formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [("[session=" + (self._sessionFSM ? self._sessionFSM.sessionIdHex : '(N/A)') + "]") ].concat( args);
    };
    if ((properties !== undefined) && (properties !== null)) {
      var ref = this.logger;
      var LOG_DEBUG = ref.LOG_DEBUG;
      LOG_DEBUG('Session properties:\n', properties);
    }

    var sessionProperties = new SessionProperties(properties);

    // Callbacks to client application.
    // Get/set for these is private, so they can only be changed in-API (e.g. by CacheSession)
    // The user-supplied one cannot be changed.
    // The configuration of the exceptions generated by these needs to match EventEmitter, so that
    // the handleGenericErrorEvent above can behave consistently
    this._messageCallbackInfo = this.wrapMessageCallback(messageCallback);
    this._eventCallbackInfo = this.wrapEventCallback(eventCallback);

    // client name generation is applicable
    if (Check.empty(sessionProperties.clientName)) {
      // Auto-gen clientName
      sessionProperties.clientName = GlobalContext.GenerateClientName();
    }

    // generate userIdentification
    sessionProperties._setUserIdentification(GlobalContext.GenerateUserIdentification());

    // client description generation is applicable
    if (Check.empty(sessionProperties.applicationDescription)) {
      // Auto-gen applicationDescription
      sessionProperties.applicationDescription = GlobalContext.GenerateClientDescription();
    }

    // Set webTransportProtocolList after validation so we're not basing it on an
    // invalid transport selection...so we're not checking transportProtocol/
    // webTransportProtocolList except for parameter conflict.

    // Now that we have touched up the properties as much as possible, validate
    // This also validates the subordinate MessagePublisherProperties
    SessionPropertiesValidator.validate(sessionProperties);

    // We want a protocol list, but historically we also accept a single protocol.
    // Create a web transport protocol list from the transport protocol
    // option if that is all that was set. (If both were set, we failed validation)
    if (Check.nothing(sessionProperties.webTransportProtocolList)) {
      // Create a fallback list that starts with the selected protocol.
      // If the selected protocol is not in the fallback list, it is not
      // a valid protocol for the platform so return an empty list.
      var selectedProtocol = sessionProperties.transportProtocol;
      var defaultList = transportProtocolDefaultList();
      var sliceIndex = selectedProtocol ? defaultList.indexOf(selectedProtocol) : 0;
      if (sliceIndex < 0) {
        // The user explicitly selected a protocol that wasn't valid
        throw new OperationError(("Selected transport protocol " + (TransportProtocol.describe(selectedProtocol)) + " is disabled or invalid for this platform"),
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
      // Slice index is valid
      sessionProperties.webTransportProtocolList = defaultList.slice(sliceIndex);

      if (sessionProperties.webTransportProtocolList.length === 0) {
        // Even before AD restrictions, no valid protocols.
        // User error.
        throw new OperationError(("No usable transport protocol or fallback from " + (TransportProtocol.describe(selectedProtocol))),
          ErrorSubcode.PARAMETER_CONFLICT);
      }

      // Check that the generated list is compatible with AD.
      var validForAD = sessionProperties.webTransportProtocolList.filter(function (x) { return isValidADTransport(x); });
      if (validForAD.length === 0) {
        this._adDisabledReason = 'Guaranteed messaging not compatible with any available ' +
          "transport protocol: " + (sessionProperties.webTransportProtocolList.map(function (k) { return TransportProtocol.describe(k); }).join(', '));
      }

      // Don't fold this into the check below -- for that one, every
      // protocol must be valid because the user explicitly requested all of them.
      // In this case, we ensure that at least one of our generated list is valid.
      if (sessionProperties.publisherProperties.enabled) {
        if (this._adDisabledReason) {
          throw new OperationError(
            'Invalid transport protocol(s) for session with Guaranteed Messaging Publisher',
            ErrorSubcode.PARAMETER_CONFLICT,
            this._adDisabledReason
          );
        }
        // AD was not disabled by having no protocols available
        sessionProperties.webTransportProtocolList = validForAD;
      }
      // A valid protocol list is ready to use.
    } else {
      // User provided transport protocol list
      // Check for parameter conflict between session and publisher
      // Already checked these for parameter conflict; only one will be set
      // Already checked that user list was not empty
      var transportProtocols = sessionProperties.webTransportProtocolList;
      var validForAD$1 = transportProtocols.every(isValidADTransport);
      if (!validForAD$1) {
        var invalid = transportProtocols.filter(function (x) { return !isValidADTransport(x); });
        this._adDisabledReason = "Guaranteed messaging incompatible with selected transport protocols: " + (invalid.map(function (k) { return TransportProtocol.describe(k); }).join(', '));
        if (sessionProperties.publisherProperties.enabled) {
          throw new OperationError(
            'Invalid transport protocol(s) for session with Guaranteed Messaging Publisher',
            ErrorSubcode.PARAMETER_CONFLICT,
            this._adDisabledReason
          );
        }
      }
    }


    // Assign the final properties and start the state machine.
    this._sessionProperties = sessionProperties;
    this._sessionStats = new Stats();
    this._hosts = new HostList(sessionProperties);
    this._sessionFSM = new SessionFSM(
      this._sessionProperties,
      this,
      this._sessionStats,
      this._hosts
    );
    this._sessionFSM.start();
    this._sessionFSM.createMessagePublisher();

    /**
     * The following fields are destroyed when disconnect is called
     * and recreated when connect is called again.
     * @private
     */
    this._outstandingDataReqs = {};
    this._capabilities = DefaultCapabilities.createDefaultCapabilities();
    this._seqNum = 1;
  }

  if ( EventEmitter ) Session.__proto__ = EventEmitter;
  Session.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Session.prototype.constructor = Session;

  var prototypeAccessors = { canAck: {},adLocallyDisabled: {},canConnectConsumer: {},canConnectPublisher: {},disposed: {} };

  /**
   * Connects the session to the Solace Message Router as configured in
   * the {@link solace.SessionProperties#url}.
   *
   * When the session is successfully connected to the Solace Message Router, the
   * {@link solace.SessionEventCode#UP_NOTICE} event is emitted if a listener has been registered.
   *
   * If {@link solace.SessionProperties#reapplySubscriptions} is set to true, this operation
   * re-registers previously registered subscriptions. The connected session event
   * ({@link solace.SessionEventCode#event:UP_NOTICE}) is emitted only when all the subscriptions
   * are successfully added to the router.
   *
   * If the API is unable to connect within {@link solace.SessionProperties#connectTimeoutInMsecs}
   * or due to login failures, the session's state transitions back to 'disconnected' and an event
   * is generated.
   *
   * **Note:** Before the session's state transitions to 'connected', a client
   * application cannot use the session; any attempt to call functions will throw
   * {@link solace.OperationError}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed, already connected or connecting.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the underlying transport cannot be established.
   *   Subcode: {@link solace.ErrorSubcode.CONNECTION_ERROR}.
   */
  Session.prototype.connect = function connect () {
    var result = this.allowOperation(SessionOperation.CONNECT);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.CONNECT });
    this._sessionFSM.processEvent(sEvent);
  };

  /**
   * @returns {Boolean} True if the session can be used to acknolwedge a message
   * @readonly
   * @private
   */
  prototypeAccessors.canAck.get = function () {
    var this$1 = this;

    /*
     * If the user wants to ack a message, it was received on a session (else ack will throw),
     * and so we know that the session was connected at some point.
     *
     * If the session is in any of the following states, we know it is either connecting or
     * connected.
     *
     * Since we know the session was previously connected, this implies the session is either
     * RECONNECTING or connected.
     *
     * We allow acks when the session is reconnecting or connected.
     *
     * TODO: Optimistically, we allow acks on a disconnecting session, on the theory that it
     * will be reconnectable.
     */
    var statesCanAck = [
      SessionStateName.CONNECTING,
      SessionStateName.TRANSPORT_UP,
      SessionStateName.DISCONNECTING ];
    // Allow ack if there is some acceptable state name such that getActiveState returns the state.
    return statesCanAck.some(function (stateName) { return !!this$1._sessionFSM.getActiveState(stateName); });
  };

  /**
   * Disconnects the session. The session attempts to disconnect cleanly, concluding all operations
   * in progress. The disconnected session event {@link solace.SessionEventCode#event:DISCONNECTED}
   * is emitted when these operations complete and the session has completely disconnected.
   *
   * @throws {solace.OperationError} if the session is disposed, or has never been connected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.disconnect = function disconnect () {
    var result = this.allowOperation(SessionOperation.DISCONNECT);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.DISCONNECT });
    this._sessionFSM.processEvent(sEvent);
  };

  /**
   * Release all resources associated with the session.
   * It is recommended to call disconnect() first for proper handshake with the message-router.
   */
  Session.prototype.dispose = function dispose () {
    var this$1 = this;

    if (this._disposed) { return; }

    setImmediate(function () {
      this$1._sessionFSM.processEvent(
        new SessionFSMEvent({ name: SessionEventName.DISPOSE })
      ); // yield for disconnect if any
      this$1._sessionFSM.terminateFsm();
      this$1.disableEmitter();
      this$1._disposed = true;
    });
  };

  /**
   * Subscribe to a topic, optionally requesting a confirmation from the router.
   *
   * If requestConfirmation is set to true:
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is
   * added successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   * The returned string is in the format of "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to add.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object} correlationKey If specified, and if requestConfirmation is true, this value is
   *                                echoed in the session event within {@link SessionEvent}.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.subscribe = function subscribe (topic, requestConfirmation, correlationKey, requestTimeout) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('topic', topic, DestinationLib.Destination);
    topic.validate();
    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
      throw new OperationError(("Topic is required for subscribe; " + (DestinationLib.DestinationType.describe(topic.getType()))),
                               ErrorSubcode.INVALID_TOPIC_SYNTAX);
    }

    Parameter.isBooleanOrNothing('requestConfirmation', requestConfirmation);
    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    this._sessionFSM.subscriptionUpdate(
      topic,
      !!requestConfirmation,
      correlationKey,
      requestTimeout,
      SessionRequestType.ADD_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleSubscriptionUpdateResponse(rxMsgObj,
                                              cancelledRequest,
                                              requestConfirmation); });
  };

  /**
   * Unsubscribe from a topic, and optionally request a confirmation from the router.
   *
   * If requestConfirmation is set to true, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is removed
   * successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}. The returned
   * string is in the format "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to remove.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object} correlationKey If <code>null</code> or undefined, a Correlation Key is not set
   *                                in the confirmation session event.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.unsubscribe = function unsubscribe (topic, requestConfirmation, correlationKey, requestTimeout) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('topic', topic, DestinationLib.Destination);
    topic.validate();
    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
      throw new OperationError(("Topic is required for unsubscribe; " + (DestinationLib.DestinationType.describe(topic.getType()))),
                               ErrorSubcode.INVALID_TOPIC_SYNTAX);
    }

    Parameter.isBooleanOrNothing('requestConfirmation', requestConfirmation);
    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    this._sessionFSM.subscriptionUpdate(
      topic,
      !!requestConfirmation,
      correlationKey,
      requestTimeout,
      SessionRequestType.REMOVE_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleSubscriptionUpdateResponse(rxMsgObj,
                                              cancelledRequest,
                                              requestConfirmation); });
  };

  /**
   * Request that a Durable Topic Endpoint stop receiving data on a topic. Unsubscribe
   * requests are only allowed by the router when no clients are bound to the DTE.
   * If the unubscribe request is successful, the DTE will stop attracting messages,
   * and all messages spooled to the DTE will be deleted.
   *
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK} is generated when the
   * subscription is removed successfully; otherwise,
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR} is generated.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   *
   * @param {solace.AbstractQueueDescriptor|solace.QueueDescriptor} queueDescriptor A description
   *  of the queue to which the topic is subscribed.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.unsubscribeDurableTopicEndpoint = function unsubscribeDurableTopicEndpoint (queueDescriptor) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    // emulate subscription
    var destination = this.createDestinationFromDescriptor(
      QueueDescriptor.createFromSpec(queueDescriptor));
    var requestConfirmation = true;
    this._sessionFSM.subscriptionUpdate(
      destination,
      requestConfirmation,
      undefined,
      undefined,
      SessionRequestType.REMOVE_DTE_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleDTEUnsubscribeResponse(rxMsgObj,
                                          cancelledRequest); });
  };


  /**
   * Modify a session property after creation of the session.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to modify.
   * @param {Object} newValue The new property value.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, it
   *                                overwrites readTimeoutInMsecs
   * @param {Object} correlationKey If specified, this value is echoed in the session event within
   *                                {@link SessionEvent} property in {@link SessionProperties}
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.updateProperty = function updateProperty (mutableSessionProperty, newValue, requestTimeout, correlationKey) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var Topic = DestinationLib.Topic;

    LOG_TRACE('Updating property ', mutableSessionProperty, newValue);

    Parameter.isEnumMember('mutableSessionProperty', mutableSessionProperty, MutableSessionProperty);

    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    var sessionEvent;
    /*
     Response CB to the CLIENTCTRL UPDATE response

     This is pretty complicated: we define the whole process in here
     using callbacks to preserve state such as the correlationKey of the user
     request.
     That is, this entire multi-step process executes under the context of that one call to
     updateProperty with a single correlationKey value.
     */
    var responseCallback = function (respMsg) {
      var response = respMsg.getResponse();
      if (response.responseCode === 200) {
        if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
          // update property and notify client
          this$1._sessionProperties.applicationDescription = newValue;
          sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                            response.responseString,
                                            response.responseCode,
                                            0,
                                            correlationKey,
                                            null);
          this$1.sendEvent(sessionEvent);
        } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
          // replace P2P subscription: REM and ADD
          var oldP2pTopicName = P2PUtil.getP2PTopicSubscription(
            this$1._sessionProperties.p2pInboxBase);
          var oldP2pTopic = Topic.createFromName(oldP2pTopicName);

          var newP2pTopicName = P2PUtil.getP2PTopicSubscription(
            respMsg.getP2PTopicValue());
          var newP2pTopic = Topic.createFromName(newP2pTopicName);

          var afterAddCallback = function (smpResp) {
            var resp = smpResp.getResponse();
            if (resp.responseCode === 200) {
              // notify client
              this$1._sessionProperties._setP2pInboxBase(respMsg.getP2PTopicValue() || '');
              this$1._sessionProperties._setP2pInboxInUse(
                P2PUtil.getP2PInboxTopic(this$1._sessionProperties.p2pInboxBase));
              this$1._sessionProperties.clientName = newValue;
              sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                                resp.responseString,
                                                resp.responseCode,
                                                0,
                                                correlationKey,
                                                null);
              this$1.sendEvent(sessionEvent);
            } else {
              var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode,
                                                                              resp.responseString);
              if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT &&
                              this$1._sessionProperties.ignoreDuplicateSubscriptionError) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  0,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_TOO_MANY) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  errorSubcode,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  ErrorSubcode.SUBSCRIPTION_ERROR_OTHER,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              }
            }
          };

          var afterRemoveCallback = function (smpResp) {
            var resp = smpResp.getResponse();
            if (resp.responseCode === 200) {
              // second add new P2P
              this$1._sessionFSM.subscriptionUpdate(newP2pTopic,
                                                  true,       // request confirm
                                                  correlationKey,
                                                  this$1._sessionProperties.readTimeoutInMsecs,
                                                  SessionRequestType.ADD_P2PINBOX,
                                                  afterAddCallback);
            } else {
              var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode,
                                                                              resp.responseString);
              if (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND &&
                  this$1._sessionProperties.ignoreSubscriptionNotFoundError) {
                // add new P2P anyway: the error is simply the old P2P
                // was not found on remove.  It's notable though.
                this$1._sessionFSM.subscriptionUpdate(newP2pTopic,
                                                    true,       // request confirm
                                                    correlationKey,
                                                    this$1._sessionProperties.readTimeoutInMsecs,
                                                    SessionRequestType.ADD_P2PINBOX,
                                                    afterAddCallback);
              } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  errorSubcode,
                                                  null,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  ErrorSubcode.SUBSCRIPTION_ERROR_OTHER,
                                                  null,
                                                  null);
                this$1.sendEvent(sessionEvent);
              }
            }
          };

          // first remove old P2P
          this$1._sessionFSM.subscriptionUpdate(oldP2pTopic,
                                              true,       // request confirm
                                              correlationKey,
                                              this$1._sessionProperties.readTimeoutInMsecs,
                                              SessionRequestType.REMOVE_P2PINBOX,
                                              afterRemoveCallback);
        }
      } else {
        // notify client error
        var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(response.responseCode,
                                                                        response.responseString);
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          response.responseString,
                                          response.responseCode,
                                          errorSubcode,
                                          correlationKey,
                                          null);
        this$1.sendEvent(sessionEvent);
      }
    }; // end CB (response to UPDATE request)

    var returnCode = this._sessionFSM.sendUpdateProperty(mutableSessionProperty,
                                                           newValue,
                                                           correlationKey,
                                                           requestTimeout,
                                                           responseCallback);
    if (returnCode !== TransportReturnCode.OK) {
          // do not change session state

      if (returnCode === TransportReturnCode.NO_SPACE) {
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          'Property update failed - no space in transport',
                                          null,
                                          ErrorSubcode.INSUFFICIENT_SPACE,
                                          null,
                                          null);
      } else {
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          'Property update failed',
                                          null,
                                          ErrorSubcode.INVALID_OPERATION,
                                          null,
                                          null);
      }
      this.sendEvent(sessionEvent);
    }
  };

  /**
   * Publish (send) a message over the session. The message is sent to its set destination.
   *
   * This method is used for sending both direct and Guaranteed Messages.  If the message's
   * {@link solace.MessageDeliveryModeType} is {@link solace.MessageDeliveryModeType.DIRECT}, the
   * message is a direct message; otherwise, it is a guaranteed message.
   *
   * @param {solace.Message} message The message to send. It must have a destination set.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.send = function send (message) {
    var result = this.allowOperation(SessionOperation.SEND, message);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('message', message, MessageLib.Message);
    this.validateAndSendMessage(message);
  };

  /**
   * Sends a request using user-specified callback functions.
   * <br>
   * <strong>Note:</strong>
   * The API sets the correlationId and replyTo fields of the message being sent;
   * this overwrites any existing correlationId and replyTo values on the message.
   *
   * @param {solace.Message} message The request message to send.
   * @param {Number} [timeout] The timeout value (in milliseconds). The minimum value is 100 msecs.
   * @param {solace.Session.replyReceivedCallback} [replyReceivedCBFunction] The callback to notify
   *    when a reply is received.
   * @param {solace.Session.requestFailedCallback} [requestFailedCBFunction] The callback to notify
   *    when the request failed.
   * @param {Object} [userObject] An optional correlation object to use in the response callback.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.sendRequest = function sendRequest (message,
              timeout,
              replyReceivedCBFunction,
              requestFailedCBFunction,
              userObject
              ) {
    if ( timeout === void 0 ) timeout = undefined;
    if ( replyReceivedCBFunction === void 0 ) replyReceivedCBFunction = undefined;
    if ( requestFailedCBFunction === void 0 ) requestFailedCBFunction = undefined;
    if ( userObject === void 0 ) userObject = undefined;

    var result = this.allowOperation(SessionOperation.SEND, message);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('message', message, MessageLib.Message);
    Parameter.isNumberOrNothing('timeout', timeout);
    Parameter.isRangeCompareOrNothing('timeout', timeout, '>=', 100);
    Parameter.isFunctionOrNothing('replyReceivedCBFunction', replyReceivedCBFunction);
    Parameter.isFunctionOrNothing('requestFailedCBFunction', requestFailedCBFunction);

    // set correlationId and replyTo fields if not set by the application
    var correlationId = message.getCorrelationId();
    if (correlationId === null || correlationId === undefined) {
      message.setCorrelationId(SOLCLIENT_REQUEST_PREFIX + GlobalContext.NextId());
    }
    var replyTo = message.getReplyTo();
    if (replyTo === null || replyTo === undefined) {
      var replyToTopic = DestinationLib.Topic.createFromName(
        this._sessionProperties.p2pInboxInUse);
      message.setReplyTo(replyToTopic);
    }

    this.validateAndSendMessage(message);

      // enqueue request
    this.enqueueOutstandingDataReq(message.getCorrelationId(),
                                   requestFailedCBFunction,
                                   timeout,
                                   replyReceivedCBFunction,
                                   userObject);
  };

  /**
   * Sends a reply message to the destination specified in messageToReplyTo.
   *
   * If `messageToReplyTo` is non-null:
   *  * {@link solace.Message#getReplyTo} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setDestination} on `replyMessage`, unless `replyTo` is null.
   *  * {@link solace.Message#setCorrelationId} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setCorrelationId} on `replyMessage`, unless `correlationId` is null.
   *
   * If `messageToReplyTo` is null, the application is responsible for setting
   * the `destination` and `correlationId` on the `replyMessage`.
   *
   * @param {solace.Message} messageToReplyTo The message to which a reply will be sent.
   * @param {solace.Message} replyMessage The reply to send.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.sendReply = function sendReply (messageToReplyTo, replyMessage) {
    var result = this.allowOperation(SessionOperation.SEND, replyMessage);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isInstanceOfOrNothing('messageToReplyTo', messageToReplyTo, MessageLib.Message);
    Parameter.isInstanceOf('replyMessage', replyMessage, MessageLib.Message);

    replyMessage.setAsReplyMessage(true);
    if (messageToReplyTo) {
      replyMessage.setCorrelationId(messageToReplyTo.getCorrelationId());
      var replyTo = messageToReplyTo.getReplyTo();
      if (replyTo === null || replyTo === undefined) {
        throw new OperationError('ReplyTo destination may not be null.',
                                 ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
      replyMessage.setDestination(messageToReplyTo.getReplyTo());
    }
    this.validateAndSendMessage(replyMessage);
  };

  /**
   * Returns the value of a given {@link solace.StatType}.
   *
   * @param {solace.StatType} statType The statistic to query.
   * @returns {Number} The value of the requested statistic.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the StatType is invalid.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   */
  Session.prototype.getStat = function getStat (statType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isEnumMember('statType', statType, StatType);
    return this._sessionFSM.getStat(statType);
  };

  /**
   * Reset session statistics to initial values.
   *
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.resetStats = function resetStats () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    this._sessionFSM.resetStats();
  };

  /**
   * Returns a clone of the properties for this session.
   *
   * @returns {solace.SessionProperties} A clone of this session's properties.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.getSessionProperties = function getSessionProperties () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    var properties = this._sessionProperties.clone();
    var sessionState = this.getSessionState();
    if ((sessionState !== SessionStateName.DISCONNECTED) && this._sessionFSM._transport) {
      properties._setWebTransportProtocolInUse(this._sessionFSM._transport.getTransportProtocol());
    }

    return properties;
  };

  /**
   * Check the value of a boolean router capability.
   *
   * This function is a shortcut for {@link solace.Session#getCapability}. It performs the same
   * operation, but instead of returning a {@link solace.SDTField} wrapping a capability value, it
   * just returns the boolean value.
   *
   *  Attempting to query a non-boolean capability will return `null`.
   *
   * @param {solace.CapabilityType} capabilityType The capability to check.
   *
   * @returns {Boolean} the value of the capability queried.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
  Session.prototype.isCapable = function isCapable (capabilityType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isNumber('capabilityType', capabilityType);

    var caps = this._capabilities;
    if (!caps) {
      return false;
    }

    // Guard for undefined OR non-boolean capability
    return (typeof caps[capabilityType] === 'boolean') ? caps[capabilityType] : false;
  };

  /**
   * Get the value of an router capability, or null if unknown. This function must
   * be called after connecting the session.
   *
   * SDT Type conversions:
   *
   *  * {string} values are returned as {@link solace.SDTFieldType.STRING}.
   *  * {boolean} values are returned as {@link solace.SDTFieldType.BOOL}.
   *  * All numeric values are returned as {@link solace.SDTFieldType.INT64}.
   *
   * @param {solace.CapabilityType} capabilityType The router capability to query.
   * @returns {solace.SDTField} The result of the capability query.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed
   *    Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
  Session.prototype.getCapability = function getCapability (capabilityType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isNumber('capabilityType', capabilityType);

    var val = this._getCapability(capabilityType);
    if (typeof val === 'boolean') {
      return SDTField.create(SDTFieldType.BOOL, val);
    }
    if (typeof val === 'number') {
      return SDTField.create(SDTFieldType.INT64, val);
    }
    if (typeof val === 'string') {
      return SDTField.create(SDTFieldType.STRING, val);
    }

    return null;
  };

  Session.prototype._getCapability = function _getCapability (capabilityType) {
    var caps = this._capabilities;
    if (!caps) { return null; }

    var value = caps[capabilityType];
    return (value === undefined) ? null : value;
  };

  /**
   * Returns the session's state. This is a third-choice method to determine session
   * state; the first is notifications on FSM transitions, and the second choice is
   * the finer-grained states of the FSM that are used in this mapping.
   *
   * @returns {SessionState} The current state of the session.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * @internal
   */
  Session.prototype.getSessionState = function getSessionState () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sessionStateName = this.getFSMState();
    switch (sessionStateName) {
      case SessionStateName.FULLY_CONNECTED:
        return SessionState.CONNECTED;
      case SessionStateName.DISCONNECTING:
        return SessionState.DISCONNECTING;
      case SessionStateName.DISCONNECTED:
        return SessionState.DISCONNECTED;
      case SessionStateName.SESSION_ERROR:
        return SessionState.SESSION_ERROR;
      case SessionStateName.CONNECTING:
      case SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT:
      case SessionStateName.WAITING_FOR_DNS:
      case SessionStateName.WAITING_FOR_TRANSPORT_UP:
      case SessionStateName.WAITING_FOR_SESSION_UP:
      case SessionStateName.WAITING_FOR_LOGIN:
      case SessionStateName.WAITING_FOR_P2PINBOX_REG:
      case SessionStateName.WAITING_FOR_PUBFLOW:
      case SessionStateName.REAPPLYING_SUBSCRIPTIONS:
        return SessionState.CONNECTING;
      default:
        {
          // State names unaccounted for --
          // WAITING_FOR_SUBCONFIRM
          // WAITING_FOR_CAN_ACCEPT_DATA
          // DISCONNECTING_FLOWS
          // FLUSHING_TRANSPORT
          // DESTROYING_TRANSPORT
          // RECONNECTING
          // TRANSPORT_FAIL
          //
          // TODO: Adjust strategy. Use StateMachine#isStateActive on key parent states,
          // instead of having to enumerate all child states.ant
          var ref = this.logger;
          var LOG_INFO = ref.LOG_INFO;
          LOG_INFO(("Unmapped session state " + (SessionStateName.describe(sessionStateName))));
          return null;
        }
    }
  };

  /**
   * Gets the fine grained state name from the session FSM.
   * @returns {solace.SessionStateName} The FSM state name
   * @private
   */
  Session.prototype.getFSMState = function getFSMState () {
    return this._sessionFSM.getCurrentStateName();
  };

  /**
   * Creates a {@link solace.CacheSession} object that uses this Session to service its
   * cache requests.
   *
   * It should be disposed when the application no longer requires a CacheSession, by calling
   * {@link solace.CacheSession#dispose}.
   *
   * @param {solace.CacheSessionProperties} properties The properties for the cache session.
   *
   * @returns {solace.CacheSession} The newly created cache session.
   *
   * @throws {solace.OperationError} if a CacheSession is already associated with this Session.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  Session.prototype.createCacheSession = function createCacheSession (properties) {
    return new CacheSession(properties, this, {
      // bind instead of arrow func for varargs
      // due to bublé transpiler bug
      incStat: this._sessionFSM.incStat.bind(this._sessionFSM),
    });
  };

  /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The following
   * must be true in order to create a MessageConsumer:
   *  * The transport protocol list does not contain any HTTP transport protocols. See
   *    {@link solace.SessionProperties#transportProtocol} and
   *    {@link solace.FactoryProfile#cometEnabled}
   *  * The Solace Messaging Router must support Guaranteed Messaging
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} when Guaranteed Message Consume is not
   *    supported on this session.
   * @target browser
   */
  /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The Solace
   * Messaging Router must support Guaranteed Messaging.
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} if Guaranteed Message Consume is not supported on this session.
   * @target node
   */
  Session.prototype.createMessageConsumer = function createMessageConsumer (consumerProperties) {
    if (this._adDisabledReason) {
      throw new OperationError('Session does not provide MessageConsumer capability',
                               ErrorSubcode.GM_UNAVAILABLE,
                               this._adDisabledReason);
    }
    if ((consumerProperties !== undefined) && (consumerProperties !== null)) {
      var ref = this.logger;
      var LOG_DEBUG = ref.LOG_DEBUG;
      LOG_DEBUG('createMessageConsumer - Consumer properties:\n', consumerProperties);
    }
    return this._sessionFSM.createMessageConsumer(consumerProperties);
  };

  /**
   * Creates a publishing destination from a queue descriptor.
   *
   * A MessageConsumer is the only object that has any business
   * doing this, but it should not be concerned with the internals
   * which depend on the session.
   *
   * @param {AbstractQueueDescriptor|QueueDescriptor} queueDescriptor The consumer's descriptor
   * @returns {Destination} A destination that publishes to the descriptor.
   * @memberof Session
   * @private
   */
  Session.prototype.createDestinationFromDescriptor = function createDestinationFromDescriptor (queueDescriptor) {
    var DestinationType = DestinationLib.DestinationType;
    var Queue = DestinationLib.Queue;
    var Topic = DestinationLib.Topic;

    var destinationType = DestinationType.TOPIC;
    if (queueDescriptor.type === QueueType.QUEUE) {
      destinationType = queueDescriptor.durable
        ? DestinationType.QUEUE
        : DestinationType.TEMPORARY_QUEUE;
    }

    var name = queueDescriptor.name || null;

    if (queueDescriptor.durable) {
      assert(name, 'Durable endpoint with generated name is not a valid configuration');
      var factoryMethod = queueDescriptor.getType() === QueueType.QUEUE
        ? Queue.createFromLocalName
        : Topic.createFromName;
      return factoryMethod(name);
    }

    return this.createTemporaryDestination(destinationType, name);
  };

  /**
   * Creates a temporary destination.
   * @param {DestinationType} destinationType Type of destination
   * @param {String} [name] Name if any
   * @returns {Destination} Temporary destination
   * @private
   */
  Session.prototype.createTemporaryDestination = function createTemporaryDestination (destinationType, name) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var DestinationFromNetwork = DestinationLib.DestinationFromNetwork;
    var DestinationUtil = DestinationLib.DestinationUtil;
    // TRANSPORT_UP is chosen because this is when the session tells subscribers
    // that they may begin connecting
    var vrn = this.getSessionProperties().virtualRouterName;
    if (!this.isCapable(CapabilityType.TEMPORARY_ENDPOINT) ||
        vrn === null || vrn === undefined || vrn.length === 0) {
      throw new OperationError(
        'Attempt to generate temporary destination or endpoint without suitable session',
        ErrorSubcode.INVALID_OPERATION);
    }
    // Non-durable case; avoid re-prefixing
    var localName = name && name.startsWith('#P2P')
      ? name
      : DestinationUtil.createTemporaryName(destinationType, vrn, name);
    LOG_TRACE('Generated name:', localName);
    return DestinationFromNetwork.createDestinationFromName(localName);
  };

  /**
   * @param {solace.SessionEvent} sessionEvent The event to send
   * @private
   */
  Session.prototype.sendEvent = function sendEvent (sessionEvent) {
    if (!sessionEvent) { return; }
    if (this._disposed) { return; }

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    LOG_TRACE(("Sending event " + sessionEvent));
    this._eventCallbackInfo.sessionEventCBFunction(this,
                                                   sessionEvent,
                                                   this._eventCallbackInfo.userObject);
  };

  /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} A description of the current session's transport.
   */
  Session.prototype.getTransportInfo = function getTransportInfo () {
    return this._sessionFSM.getTransportInfo();
  };

  /**
   * @param {Object} interceptor The transport interceptor to set
   * @private
   */
  Session.prototype.injectTransportInterceptor = function injectTransportInterceptor (interceptor) {
    this._sessionFSM.injectTransportInterceptor(interceptor);
  };

  /**
   * @param {solace.SessionOperation} operationEnum the id of the operation
   * @param {solace.Message} message The message to send
   * @returns {?String} error message if not allowed; otherwise null
   * @private
   */
  Session.prototype.allowOperation = function allowOperation (operationEnum, message) {
    if (!this._sessionFSM) { return false; }
    var allow = true;
    var sessionStateName = this._sessionFSM.getCurrentStateName();

    if (sessionStateName === SessionStateName.DISPOSED) {
      allow = false;
    } else if (Check.anything(operationEnum)) {
      switch (operationEnum) {
        case SessionOperation.CONNECT:
          if (sessionStateName !== SessionStateName.NEW &&
              sessionStateName !== SessionStateName.DISCONNECTED) {
            allow = false;
          }
          break;
        case SessionOperation.DISCONNECT:
          if (sessionStateName === SessionStateName.NEW) {
            allow = false;
          }
          break;
        case SessionOperation.SEND:
        case SessionOperation.CTRL:
          allow =
            ((sessionStateName === SessionStateName.FULLY_CONNECTED) ||
            (message && (message.getDeliveryMode() !== MessageLib.MessageDeliveryModeType.DIRECT)));
          break;

        case SessionOperation.QUERY_OPERATION:
          allow = true;
          break;
        default:
          allow = false;
      }
    } else {
      allow = false;
    }

    if (allow) {
      return null;
    }

    return ("Cannot perform operation " + operationEnum + " while in state " + sessionStateName);
  };

  /**
   * @param {smf.ClientCtrlMessage} routerCapabilities The message containing the router caps
   * @private
   */
  Session.prototype.updateCapabilities = function updateCapabilities (routerCapabilities) {
    this._capabilities = routerCapabilities;
  };

  /**
   * @param {solace.Message} message The message to send
   * @private
   */
  Session.prototype.validateAndSendMessage = function validateAndSendMessage (message) {
    // Sanity checks on the message before attempting to send it
    //  * do we have a destination?
    var sendDest = message.getDestination();
    if (Check.nothing(sendDest) || Check.empty(sendDest.getName())) {
      throw new OperationError('Message must have a valid Destination', ErrorSubcode.TOPIC_MISSING);
    }

    var senderTimestamp = message.getSenderTimestamp();
    var noSenderTimestamp = senderTimestamp === null || senderTimestamp === undefined;
    if (this._sessionProperties.generateSendTimestamps &&
        (noSenderTimestamp || message.hasAutoSenderTimestamp)) {
      var now = new Date();
      message.setSenderTimestamp(now.getTime());
      message.hasAutoSenderTimestamp = true;
    }
    var sequenceNumber = message.getSequenceNumber();
    var noSequenceNumber = sequenceNumber === null || sequenceNumber === undefined;
    if (this._sessionProperties.generateSequenceNumber &&
        (noSequenceNumber || message.hasAutoSequenceNumber)) {
      message.setSequenceNumber(this._seqNum++);
      message.hasAutoSequenceNumber = true;
    }
    var senderId = message.getSenderId();
    var noSenderId = senderId === null || senderId === undefined;
    if (this._sessionProperties.includeSenderId && noSenderId) {
      message.setSenderId(this._sessionProperties.clientName);
    }

    // Allow the FSM and its delegates to prepare and send the message
    // This may mutate the delegates, so we need to validate first
    // this may throw if the message is guaranteed and the window is closed.
    // If this returns true, the message can be sent to the transport
    // (always true for direct messages whne there is a transport). If
    // this returns false, the message has been prepared and queued for
    // transport but may not be sent now.
    this._sessionFSM.prepareAndSendMessage(message);
  };

  /**
   * @param {String} correlationId The internal correlation ID for the message
   * @param {function(...[*])} reqFailedCb The callback on request failure
   * @param {Number} reqTimeout The request timeout in ms
   * @param {function(*)} replyRecvdCb The callback on reply received
   * @param {Object} userObject A user object to pass back to the callback (legacy)
   * @private
   */
  Session.prototype.enqueueOutstandingDataReq = function enqueueOutstandingDataReq (correlationId, reqFailedCb, reqTimeout, replyRecvdCb, userObject) {
    var this$1 = this;

    if (Check.none(correlationId)) {
      return;
    }
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_ERROR = ref.LOG_ERROR;

    // empty string is valid
    LOG_TRACE(("Enqueue outstanding data request correlationId=" + correlationId));
    var timer = setTimeout(function () {
      this$1._sessionFSM.incStat(StatType.TX_REQUEST_TIMEOUT);
                  // remove request from queue
      try {
        var result = delete this$1._outstandingDataReqs[correlationId];
        if (!result) {
          LOG_ERROR(("Cannot delete data request " + correlationId));
        }
      } catch (e) {
        LOG_ERROR(("Cannot delete data request " + correlationId), e);
      }

      if (Check.anything(reqFailedCb)) {
        var requestEvent = SessionEvent.build(RequestEventCode.REQUEST_TIMEOUT,
                                                'Request timeout',
                                                correlationId);

        reqFailedCb(this$1, requestEvent, userObject);
      }
    }, reqTimeout || this._sessionProperties.readTimeoutInMsecs);

    var outstandingReq = new OutstandingDataRequest(correlationId,
                                                      timer,
                                                      replyRecvdCb,
                                                      reqFailedCb,
                                                      userObject);
    this._outstandingDataReqs[correlationId] = outstandingReq;
  };

  /**
   * @param {String} correlationId The internal ID of the request to cancel
   * @returns {OutstandingDataRequest} The request that was cancelled, if any
   * @private
   */
  Session.prototype.cancelOutstandingDataReq = function cancelOutstandingDataReq (correlationId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_ERROR = ref.LOG_ERROR;

    if (Check.none(correlationId) || !this._outstandingDataReqs) {
      return null;
    }

    var req = this._outstandingDataReqs[correlationId];
    if (req === undefined || req === null) {
      return null;
    }
    LOG_TRACE(("Cancel outstanding data request correlationId=" + correlationId));
    if (req.timer) {
      clearTimeout(req.timer);
      req.timer = null;
    }

    try {
      var result = delete this._outstandingDataReqs[correlationId];
      if (!result) {
        LOG_ERROR(("Cannot delete data request " + correlationId));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete data request " + correlationId), e);
    }
    return req;
  };

  /**
   * @private
   */
  Session.prototype.cleanupSession = function cleanupSession () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    if (this._outstandingDataReqs) {
      LOG_TRACE('Cancel all outstanding data requests');
      Object.keys(this._outstandingDataReqs).forEach(function (key) {
        var dataReq = this$1.cancelOutstandingDataReq(key);
        if (dataReq && dataReq.reqFailedCBFunction) {
          var requestEvent = SessionEvent.build(RequestEventCode.REQUEST_ABORTED,
                                                  'Request aborted',
                                                  key);
          dataReq.reqFailedCBFunction(this$1, requestEvent, dataReq.userObject);
        }
      });
    }
  };

  /**
   * @param {Message} dataMessageIn The received direct TRmsg
   * @private
   */
  Session.prototype.handleDataMessage = function handleDataMessage (dataMessageIn) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_INFO = ref.LOG_INFO;
    var dataMessage = dataMessageIn;
    if (this._sessionProperties.generateReceiveTimestamps) {
      var now = new Date();
      dataMessage._receiverTimestamp = now.getTime();
    }

    if (dataMessage.isReplyMessage()) {
      var correlationId = dataMessage.getCorrelationId();
      if (Check.anything(correlationId)) {
        var dataReq = this.cancelOutstandingDataReq(correlationId);
        if (dataReq !== null) {
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_RECVED);
          LOG_TRACE('Calling application replyReceivedCallback');
          dataReq.replyReceivedCBFunction(this, dataMessage, dataReq.userObject);
          LOG_TRACE('application replyReceivedCallback returns');
          return;
        }

        if (correlationId.startsWith(SOLCLIENT_REQUEST_PREFIX)) {
            // if a reply message doesn't have outstanding request and correlationId
            // starts with #REQ it is assumed to be a delayed reply and has to be discarded
          LOG_INFO('DROP: Discard reply message due to missing outstanding request');
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
          return;
        }

        if (correlationId.startsWith(CACHE_REQUEST_PREFIX) &&
              !(CacheSession && this._messageCallbackInfo.userObject instanceof CacheSession)) {
          // If it's a cache message, only pass it along if the listener is a cache message
          // listener. The listener may drop it and increment the DISCARD stat if no
          // cache session recognizes the reply.
          LOG_INFO('DROP: Discard cache reply due to no cache session active');
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
          return;
        }
      }
    }

    // notify client message callback
    LOG_TRACE('Calling application messageCallback');
    this._messageCallbackInfo.messageRxCBFunction(this,
                                                  dataMessage,
                                                  this._messageCallbackInfo.userObject);
    LOG_TRACE('application messageCallback returns');
  };

  /**
   * Callback function for subscribe/unsubscribe response
   * @param {solace.SMPMessage} smpMsg The SMP response to the subscription request
   * @param {CorrelatedRequest} request The originating request object
   * @param {Boolean} requestConfirm Whether the user asked for confirmation on the request
   * @private
   */
  Session.prototype.handleSubscriptionUpdateResponse = function handleSubscriptionUpdateResponse (smpMsg, request, requestConfirm) {
    var response = smpMsg.getResponse();
    var responseCode = response.responseCode;
    var responseString = response.responseString;
    var correlationKey = request.correlationKey;
    // If we don't request confirmation, the router doesn't send one for the OK case,
    // so we don't need to guard for that.
    // The router always replies on SUBSCRIPTION_ERROR, so we track whether confirmation
    // was requested and suppress the reply in certain cases.
    if (responseCode === 200) {
      // notify client
      var sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK,
                                              responseString,
                                              responseCode,
                                              0,
                                              correlationKey,
                                              null);
      this.sendEvent(sessionEvent);
    } else {
      var subscriptionStr = StringUtils.stripNullTerminate(smpMsg.encodedUtf8Subscription);
      this.handleSubscriptionUpdateError(responseCode,
                                         responseString,
                                         subscriptionStr,
                                         correlationKey,
                                         requestConfirm);
    }
  };

  /**
   * Callback function for DTE unsubscribe response
   *
   * @param {solace.AdMessage} adCtrlMessage The Guaranteed Message Protocol
   *                           control response to the DTE unsub message
   * @param {CorrelatedRequest} request The originating request object
   * @private
   */
  Session.prototype.handleDTEUnsubscribeResponse = function handleDTEUnsubscribeResponse (adCtrlMessage, request) {
    var response = adCtrlMessage.getResponse();
    var responseCode = response.responseCode;
    var responseString = response.responseString;
    var correlationKey = request.correlationKey;
    var eventCode = responseCode === 200
      ? SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK
      : SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR;
    var subcode = responseCode === 200
      ? 0
      : ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode,
                                                     responseString);
    this.sendEvent(SessionEvent.build(eventCode,
                                      responseString,
                                      responseCode,
                                      subcode,
                                      correlationKey
    ));
  };

  /**
   * @param {Number} respCode The returned response code
   * @param {String} respText The returned response text
   * @param {String} subscriptionStr The requested topic name
   * @param {*} correlationKey The user-supplied correlation key
   * @param {Boolean} requestConfirm Whether confirmation was requested on subscription
   * @private
   */
  Session.prototype.handleSubscriptionUpdateError = function handleSubscriptionUpdateError (respCode,
                                respText,
                                subscriptionStr,
                                correlationKey,
                                requestConfirm) {
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
    if ((errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT &&
         this._sessionProperties.ignoreDuplicateSubscriptionError) ||
        (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND &&
          this._sessionProperties.ignoreSubscriptionNotFoundError)) {
      if (requestConfirm) {
        // notify client
        var sessionEvent = SessionEvent.build(
          SessionEventCode.SUBSCRIPTION_OK,
          respText,
          respCode,
          0,
          correlationKey,
          null
        );
        this.sendEvent(sessionEvent);
      }
    } else {
      // notify client
      var sessionEvent$1 = SessionEvent.build(
        SessionEventCode.SUBSCRIPTION_ERROR,
        respText,
        respCode,
        errorSubcode,
        correlationKey,
        ("Topic: " + subscriptionStr)
      );
      this.sendEvent(sessionEvent$1);
    }
  };

  /**
   * @returns {SessionEventCBInfo} The session's event callback
   * @private
   */
  Session.prototype.getEventCBInfo = function getEventCBInfo () {
    return this._eventCallbackInfo;
  };

  /**
   * @param {SessionEventCBInfo} eventCBInfo The new event callback to set
   * @private
   */
  Session.prototype.setEventCBInfo = function setEventCBInfo (eventCBInfo) {
    this._eventCallbackInfo = eventCBInfo;
  };

  /**
   * @returns {MessageRxCBInfo} The session's message callback
   * @private
   */
  Session.prototype.getMessageCBInfo = function getMessageCBInfo () {
    return this._messageCallbackInfo;
  };

  /**
   * @param {MessageRxCBInfo} messageCBInfo The new message callback to set
   * @private
   */
  Session.prototype.setMessageCBInfo = function setMessageCBInfo (messageCBInfo) {
    this._messageCallbackInfo = messageCBInfo;
  };

  /**
   * @returns {String} The next correlation tag for this session.
   * @private
   */
  Session.prototype.getCorrelationTag = function getCorrelationTag () {
    return this._sessionFSM.getCorrelationTag();
  };

  /**
   * Wraps a SessionEventCBInfo or a bare function with an event emitting function.
   * @param {SessionEventCBInfo|function|undefined} eventCallback The callback to wrap
   * @returns {SessionEventCBInfo} A SessionEventCBInfo object that handles all callbacks.
   * @private
   */
  Session.prototype.wrapEventCallback = function wrapEventCallback (eventCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
    var eventCallbackInfo = (function () {
      if (!eventCallback) { return null; }
      if (eventCallback.sessionEventCBFunction) { return eventCallback; }
      return new SessionEventCBInfo(eventCallback);
    })();
    return new SessionEventCBInfo(function (session, sessionEvent, obj, rfu) {
      var sessionEventCode = sessionEvent.sessionEventCode;
      if (eventCallbackInfo) {
        try {
          eventCallbackInfo.sessionEventCBFunction(session, sessionEvent, obj, rfu);
        } catch (ex) {
          var error = Object.assign(new OperationError(
            ("Unhandled error in SessionEventRxCBInfo callback on sessionEventCode " + (SessionEventCode.describe(sessionEventCode))),
              ErrorSubcode.CALLBACK_ERROR,
              ("On event: " + ([sessionEventCode, sessionEvent, obj, rfu]) + " " + ex)
            ), {
              stack: ex.stack,
              info:  {
                event: {
                  name:          sessionEventCode,
                  formattedName: ("SessionEventCode." + (SessionEventCode.describe(sessionEventCode))),
                  args:          [sessionEvent, obj, rfu],
                },
                error: ex,
              },
            }
          );
          LOG_WARN(error.toString(), error.info);
        }
      }
      this$1.emit(sessionEventCode, sessionEvent);
    });
  };

  /**
   * Wraps a CBInfo or a bare function with an event emitting function.
   * @param {MessageCBInfo|function|undefined} messageCallback The callback to wrap
   * @returns {MessageCBInfo} A MessageCBInfo object that handles all callbacks.
   * @private
   */
  Session.prototype.wrapMessageCallback = function wrapMessageCallback (messageCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;

    var messageCallbackInfo = (function () {
      if (!messageCallback) { return null; }
      if (messageCallback.messageRxCBFunction) { return messageCallback; }
      return new MessageRxCBInfo(messageCallback);
    })();

    var formattedName = "SessionEventCode." + (SessionEventCode.describe(SessionEventCode.MESSAGE));
    var buildErrorEvent = function (ex, message, object) { return Object.assign(
      new OperationError(("Unhandled error in MessageRxCBInfo callback/handler for " + formattedName),
                         ErrorSubcode.CALLBACK_ERROR),
      {
        stack: ex.stack,
        info:  {
          event: {
            name: SessionEventCode.MESSAGE,
            formattedName: formattedName,
            args: [message, object],
          },
          error: ex,
        },
      }); };

    return new MessageRxCBInfo(function (session, message, object) {
      if (messageCallbackInfo) {
        try {
          messageCallbackInfo.messageRxCBFunction(session, message, object);
        } catch (ex) {
          var error = buildErrorEvent(ex, message, object).toString();
          LOG_WARN(error, error.info, ex);
        }
      }
      try {
        this$1.emitDirect(message);
      } catch (ex) {
        this$1.emit('error', buildErrorEvent(ex, message, object));
      }
    });
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.adLocallyDisabled.get = function () {
    return !!this._adDisabledReason;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.canConnectConsumer.get = function () {
    if (this.adLocallyDisabled) { return false; }
    if (this._capabilities) {
      return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME);
    }
    return undefined;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.canConnectPublisher.get = function () {
    if (this.adLocallyDisabled) { return false; }
    if (this._capabilities) {
      return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
    }
    return undefined;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.disposed.get = function () {
    return this._disposed;
  };

  Session.prototype[util.inspect.custom] = function () {
    return {
      'sessionId': this._sessionFSM && this._sessionFSM.sessionIdHex || '(N/A)',
      'transport': this.getTransportInfo(),
      'state':     SessionState.describe(this.getSessionState()),
    };
  };

  Session.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( Session.prototype, prototypeAccessors );

  return Session;
}(EventEmitter));

module.exports.Session = Session;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(75);
var SessionRequestType = ref.SessionRequestType;

module.exports = {
  SubscriptionUpdateTimeoutMessages: ( obj = {
    default:                                      'Request timeout',
  }, obj[SessionRequestType.ADD_SUBSCRIPTION] = 'Add subscription request timeout', obj[SessionRequestType.REMOVE_SUBSCRIPTION] = 'Remove subscription request timeout', obj[SessionRequestType.ADD_P2PINBOX] = 'Add P2P inbox subscription timeout', obj[SessionRequestType.REMOVE_P2PINBOX] = 'Remove P2P inbox subscription timeout', obj[SessionRequestType.REMOVE_DTE_SUBSCRIPTION] = 'Remove endpoint topic subscription', obj ),
};
var obj;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(45);
var ContentSummaryType = ref.ContentSummaryType;
var ref$1 = __webpack_require__(221);
var Decode = ref$1.Decode;
var ref$2 = __webpack_require__(222);
var Encode = ref$2.Encode;
var ref$3 = __webpack_require__(76);
var ParamParse = ref$3.ParamParse;
var ref$4 = __webpack_require__(121);
var ParseSMF = ref$4.ParseSMF;
var ref$5 = __webpack_require__(124);
var Transport = ref$5.Transport;

module.exports.ContentSummaryType = ContentSummaryType;
module.exports.Encode = Encode;
module.exports.Decode = Decode;
module.exports.ParamParse = ParamParse;
module.exports.ParseSMF = ParseSMF;
module.exports.Transport = Transport;



/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SolclientDestinationLib = __webpack_require__(5);
var SolclientMessageLib = __webpack_require__(16);
var SolclientSDTLib = __webpack_require__(10);
var ref = __webpack_require__(13);
var BinaryMetaBlock = ref.BinaryMetaBlock;
var KeepAliveMessage = ref.KeepAliveMessage;
var ref$1 = __webpack_require__(45);
var ContentSummaryType = ref$1.ContentSummaryType;
var ref$2 = __webpack_require__(3);
var Hex = ref$2.Hex;
var Long = ref$2.Long;
var ref$3 = __webpack_require__(0);
var Lazy = ref$3.Lazy;
var ref$4 = __webpack_require__(1);
var LogFormatter = ref$4.LogFormatter;
var ref$5 = __webpack_require__(118);
var parseAdpAt = ref$5.parseAdpAt;
var ref$6 = __webpack_require__(119);
var parseCCAt = ref$6.parseCCAt;
var ref$7 = __webpack_require__(121);
var ParseSMF = ref$7.ParseSMF;
var ref$8 = __webpack_require__(122);
var PriorityUserCosMap = ref$8.PriorityUserCosMap;
var ref$9 = __webpack_require__(22);
var SMFProtocol = ref$9.SMFProtocol;
var ref$10 = __webpack_require__(123);
var SMP = ref$10.SMP;
var ref$11 = __webpack_require__(124);
var Transport = ref$11.Transport;

var formatHexString = Hex.formatHexString;
var lazyValue = Lazy.lazyValue;
var parseSMFAt = ParseSMF.parseSMFAt;
var parseSMPAt = SMP.parseSMPAt;
var parseTsSmfMsgAt = Transport.parseTsSmfMsgAt;

var logger = new LogFormatter('[smf-decode]');
var LOG_TRACE = logger.LOG_TRACE;
var LOG_DEBUG = logger.LOG_DEBUG;
var LOG_ERROR = logger.LOG_ERROR;

var userCosForPriority = lazyValue(function () { return new PriorityUserCosMap().reverse; });

var BIN_STRUCTYPES = {
  0x0A: SolclientMessageLib.MessageType.MAP,
  0x0B: SolclientMessageLib.MessageType.STREAM,
  0x07: SolclientMessageLib.MessageType.TEXT,
};

function adaptBinaryMetaToMessage(binaryMeta, messageIn) {
  var message = messageIn;
  var messageSdt = SolclientSDTLib.Codec.parseSingleElement(binaryMeta.payload, 0);

  if (!(messageSdt && messageSdt.getType() === SolclientSDTLib.SDTFieldType.STREAM)) {
    return;
  }

  var sdtstream = messageSdt.getValue();
  var sdtfield = sdtstream.getNext();
  if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.BYTEARRAY) {
    // Preamble byte array is present
    var preambleByte0 = sdtfield.getValue().charCodeAt(0) & 0xFF;
    if ((preambleByte0 & 0x80) === 0) {
      // structured message: override default "BIN" message type
      message._messageType = (BIN_STRUCTYPES[preambleByte0 & 0x0F] ||
                              SolclientMessageLib.MessageType.BINARY);
    }
    if (sdtfield.getValue().length >= 1) {
      var preambleByte1 = sdtfield.getValue().charCodeAt(1) & 0xFF;
      message.setAsReplyMessage((preambleByte1 & 0x80) !== 0);
    }
  }

  sdtfield = sdtstream.getNext();
  if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.MAP) {
    var sdtMap = sdtfield.getValue();
    var p = sdtMap.getField('p');
    var h = sdtMap.getField('h');
    if (p) {
      message.setUserPropertyMap(p.getValue());
    }
    if (h) {
      var headerMap = h.getValue();
      var ci = headerMap.getField('ci');
      var mi = headerMap.getField('mi');
      var mt = headerMap.getField('mt');
      var rt = headerMap.getField('rt');
      var si = headerMap.getField('si');
      var sn = headerMap.getField('sn');
      var ts = headerMap.getField('ts');
      var ex = headerMap.getField('ex');
      if (ci) {
        message.setCorrelationId(ci.getValue());
      }
      if (mi) {
        message.setApplicationMessageId(mi.getValue());
      }
      if (mt) {
        message.setApplicationMessageType(mt.getValue());
      }
      if (rt) {
        message.setReplyTo(rt.getValue());
      }
      if (si) {
        message.setSenderId(si.getValue());
      }
      if (sn) {
        message.setSequenceNumber(sn.getValue());
      }
      if (ts) {
        message.setSenderTimestamp(ts.getValue());
      }
      if (ex) {
        message.setGMExpiration(ex.getValue());
      }
    }
  }
}


function adaptSmfToMessage(smfHeader, messageIn, stream, offset) {
  var message = messageIn;
  message._setDeliverToOne(!!smfHeader.smf_dto);
  message._setDeliveryMode(smfHeader.pm_deliverymode ||
                          SolclientMessageLib.MessageDeliveryModeType.DIRECT);
  if (smfHeader.pm_tr_topicname_bytes !== null) {
    message._setDestination(
      SolclientDestinationLib.DestinationFromNetwork.createDestinationFromBytes(
        smfHeader.pm_tr_topicname_bytes));
  }
  message._setDiscardIndication(!!smfHeader.smf_di);
  message._setElidingEligible(!!smfHeader.smf_elidingEligible);
  message._setDMQEligible(!!smfHeader.smf_deadMessageQueueEligible);
  message._setUserCos(userCosForPriority.value.get(smfHeader.smf_priority));
  message._setPriority(smfHeader.pm_msg_priority);
  if (smfHeader.pm_userdata) { message._setUserData(smfHeader.pm_userdata); }

  message.setRedelivered(!!smfHeader.pm_ad_redelflag || !!smfHeader.pm_ad_flowredelflag);

  message.setFlowId(smfHeader.pm_ad_flowid);
  message.setGuaranteedMessageId(smfHeader.pm_ad_msgid);
  message.setGuaranteedPreviousMessageId(smfHeader.pm_ad_prevmsgid);
  message.setPublisherId(smfHeader.pm_ad_publisherid);
  message.setPublisherMessageId(smfHeader.pm_ad_publishermsgid);
  message.setTopicSequenceNumber(smfHeader.pm_ad_topicSequenceNumber);

  if (Long.isLong(smfHeader.pm_ad_ttl)) {
    message.setTimeToLive(smfHeader.pm_ad_ttl.toNumber());
  } else {
    message.setTimeToLive(smfHeader.pm_ad_ttl);
  }

  // Copy content into fields (from input bytes)
  var payloadOffset = offset + smfHeader.headerLength;
  var cs = smfHeader.pm_content_summary;

  if (!(cs && cs.length)) {
    // No content-summary, assume binary attachment
    message._setBinaryAttachment(smfHeader.payloadLength > 0
                                ? stream.substr(payloadOffset, smfHeader.payloadLength)
                                : undefined);
    return;
  }

  for (var i = 0, n = cs.length; i < n; ++i) {
    var currentChunk = cs[i];
    var chunkData = stream.substr(payloadOffset + currentChunk.position, currentChunk.length);
    switch (currentChunk.type) {
      case ContentSummaryType.BINARY_ATTACHMENT:
        message._setBinaryAttachment(chunkData);
        break;
      case ContentSummaryType.BINARY_METADATA:
        {
          var binaryMeta = BinaryMetaBlock.fromEncodedSmf(chunkData);
          message.binaryMetadataChunk = binaryMeta;
          if (binaryMeta.type === 0) {
            // we have SDT JMS metadata
            adaptBinaryMetaToMessage(binaryMeta, message);
          }
          break;
        }
      case ContentSummaryType.XML_META:
        message._setXmlMetadata(chunkData);
        break;
      case ContentSummaryType.XML_PAYLOAD:
        message._setXmlContentInternal(chunkData);
        break;
      default:
        LOG_ERROR(("Unhandled ContentSummaryType: " + (ContentSummaryType.describe(currentChunk.type))));
    }
  }
}

function decodeCompoundMessage(data, pos) {
  var header = parseSMFAt(data, pos);
  if (!header) {
    LOG_DEBUG('decodeCompoundMessage: SMF parsing failed');
    return null;
  }

  // the parser determined there was a full SMF message
  var payloadPosition = pos + header.headerLength;
  var payloadLen = header.payloadLength;
  var message;
  switch (header.smf_protocol) {
    case SMFProtocol.TSESSION:
      message = parseTsSmfMsgAt(data, payloadPosition, header);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.TRMSG:
      message = new SolclientMessageLib.Message();
      message._smfHeader = header;
      adaptSmfToMessage(header, message, data, pos);
      LOG_TRACE('Decoded SMF message');
      return message;

    case SMFProtocol.ADCTRL:
      message = parseAdpAt(data, payloadPosition, payloadLen);
      if (!message) { break; }
      message.smfHeader = header;
      return message;

    case SMFProtocol.CLIENTCTRL:
      message = parseCCAt(data, payloadPosition, payloadLen);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.SMP:
      message = parseSMPAt(data, payloadPosition);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.KEEPALIVE:
    case SMFProtocol.KEEPALIVEV2:
      message = new KeepAliveMessage();
      message.smfHeader = header;
      LOG_TRACE('Decoded keep alive response');
      return message;

    default:
      LOG_ERROR("Unknown protocol: 0x" + (formatHexString(header.smf_protocol)) + ", " +
                "dump message content: \n" + (DebugLib.Debug.formatDumpBytes(data.substring(pos,
                                                              header.messageLength),
                                               true, 0)));
      break;
  }
  return null;
}

var Decode = {
  decodeCompoundMessage: decodeCompoundMessage,
};

module.exports.Decode = Decode;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(3);
var Base64 = ref.Base64;
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(13);
var BinaryMetaBlock = ref$1.BinaryMetaBlock;
var SMFHeader = ref$1.SMFHeader;
var SMPMessage = ref$1.SMPMessage;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(13);
var ClientCtrlMessage = ref$3.ClientCtrlMessage;
var KeepAliveMessage = ref$3.KeepAliveMessage;
var AdProtocolMessage = ref$3.AdProtocolMessage;
var ref$4 = __webpack_require__(10);
var SDTCodec = ref$4.Codec;
var ref$5 = __webpack_require__(120);
var ContentSummaryElement = ref$5.ContentSummaryElement;
var ref$6 = __webpack_require__(45);
var ContentSummaryType = ref$6.ContentSummaryType;
var ref$7 = __webpack_require__(5);
var DestinationType = ref$7.DestinationType;
var ref$8 = __webpack_require__(118);
var encAdp = ref$8.encAdp;
var ref$9 = __webpack_require__(119);
var encCC = ref$9.encCC;
var ref$10 = __webpack_require__(2);
var ErrorSubcode = ref$10.ErrorSubcode;
var OperationError = ref$10.OperationError;
var ref$11 = __webpack_require__(0);
var Lazy = ref$11.Lazy;
var ref$12 = __webpack_require__(1);
var LOG_TRACE = ref$12.LOG_TRACE;
var LOG_INFO = ref$12.LOG_INFO;
var ref$13 = __webpack_require__(76);
var ParamParse = ref$13.ParamParse;
var ref$14 = __webpack_require__(122);
var PriorityUserCosMap = ref$14.PriorityUserCosMap;
var ref$15 = __webpack_require__(10);
var SDTField = ref$15.SDTField;
var SDTFieldType = ref$15.SDTFieldType;
var SDTMapContainer = ref$15.SDTMapContainer;
var SDTStreamContainer = ref$15.SDTStreamContainer;
var ref$16 = __webpack_require__(78);
var SMFParameterType = ref$16.SMFParameterType;
var ref$17 = __webpack_require__(22);
var SMFProtocol = ref$17.SMFProtocol;
var ref$18 = __webpack_require__(123);
var SMP = ref$18.SMP;

var base64Encode = Base64.encode;
var setBits = Bits.set;
var int8ToStr = Convert.int8ToStr;
var int16ToStr = Convert.int16ToStr;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var int64ToStr = Convert.int64ToStr;
var lazyValue = Lazy.lazyValue;
var encContentSummary = ParamParse.encContentSummary;
var encDeliveryMode = ParamParse.encDeliveryMode;
var encLightSMFParam = ParamParse.encLightSMFParam;
var encodeSMFParam = ParamParse.encodeSMFParam;
var encodeSingleElement = SDTCodec.encodeSingleElement;
var encSmp = SMP.encSmp;

var priorityForUserCos = lazyValue(function () { return new PriorityUserCosMap().forward; });

function addContentElementToArrays(csumm, payloadArray, dataChunk, cstype) {
  if (Check.anything(dataChunk) && dataChunk.length > 0) {
    var cse = new ContentSummaryElement(cstype, NaN, dataChunk.length);
    csumm.push(cse);
    payloadArray.push(dataChunk);
  }
}

function addToMapIfPresent(headerMap, key, type, value) {
  if (Check.anything(value)) {
    headerMap.addField(key, SDTField.create(type, value));
  }
}

function adaptMessageToBinaryMeta(message) {
  // solace header map
  var headerMap = new SDTMapContainer();
  addToMapIfPresent(headerMap, 'ci', SDTFieldType.STRING, message.getCorrelationId());
  addToMapIfPresent(headerMap, 'mi', SDTFieldType.STRING, message.getApplicationMessageId());
  addToMapIfPresent(headerMap, 'mt', SDTFieldType.STRING, message.getApplicationMessageType());
  addToMapIfPresent(headerMap, 'rt', SDTFieldType.DESTINATION, message.getReplyTo());
  addToMapIfPresent(headerMap, 'si', SDTFieldType.STRING, message.getSenderId());
  addToMapIfPresent(headerMap, 'sn', SDTFieldType.INT64, message.getSequenceNumber());
  addToMapIfPresent(headerMap, 'ts', SDTFieldType.INT64, message.getSenderTimestamp());
  addToMapIfPresent(headerMap, 'ex', SDTFieldType.INT64, message.getGMExpiration());

  // container map: solace headers + user prop map
  var sdtMap = new SDTMapContainer();
  if (message.getUserPropertyMap()) {
    sdtMap.addField('p', SDTField.create(SDTFieldType.MAP, message.getUserPropertyMap()));
  }
  if (headerMap.getKeys().length > 0) {
    sdtMap.addField('h', SDTField.create(SDTFieldType.MAP, headerMap));
  }

  var encodedSdtPayload = null;
  var preambleByte0 = 0;
  switch (message.getType()) {
    case MessageLib.MessageType.BINARY:
      preambleByte0 |= 0x80;
      break;
    case MessageLib.MessageType.MAP:
      preambleByte0 |= 0x0A;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    case MessageLib.MessageType.STREAM:
      preambleByte0 |= 0x0B;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    case MessageLib.MessageType.TEXT:
      preambleByte0 |= 0x07;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    default:
      LOG_INFO(("Unhandled messageType: " + (message.getType())));
      break;
  }
  var preambleByte1 = message.isReplyMessage() ? 0x80 : 0;
  var sdtPreamble = SDTField.create(SDTFieldType.BYTEARRAY,
                                      String.fromCharCode(preambleByte0, preambleByte1));

  // Putting it all together: a stream with the preamble and map
  var sdtStreamContainer = new SDTStreamContainer();
  sdtStreamContainer.addField(sdtPreamble);
  sdtStreamContainer.addField(SDTField.create(SDTFieldType.MAP, sdtMap));

  var binaryMeta = new BinaryMetaBlock();
  binaryMeta.type = 0;
  binaryMeta.payload = encodeSingleElement(SDTField.create(SDTFieldType.STREAM,
                                                           sdtStreamContainer));
  message.binaryMetadataChunk = binaryMeta;
}


function adaptMessageToSmf(message, smfHeaderIn) {
  var smfHeader = smfHeaderIn;
  var deliveryMode = message.getDeliveryMode();

  smfHeader.smf_dto = message.isDeliverToOne();
  smfHeader.pm_deliverymode = deliveryMode;
  smfHeader.smf_adf = deliveryMode === MessageLib.MessageDeliveryModeType.DIRECT ? 0 : 1;
  smfHeader.smf_di = message.isDiscardIndication();
  smfHeader.smf_elidingEligible = message.isElidingEligible();
  smfHeader.smf_deadMessageQueueEligible = message.isDMQEligible();
  smfHeader.pm_ad_flowid = message.getFlowId();
  smfHeader.pm_ad_publisherid = message.getPublisherId();
  smfHeader.pm_ad_publishermsgId = message.getPublisherMessageId();
  smfHeader.pm_ad_msgid = message.getGuaranteedMessageId();
  smfHeader.pm_ad_prevmsgid = message.getGuaranteedPreviousMessageId();
  smfHeader.pm_ad_ttl = message.getTimeToLive();
  smfHeader.pm_ad_ackimm = message.isAcknowledgeImmediately();
  smfHeader.pm_ad_redelflag = message.isRedelivered();

  var dest = message.getDestination();
  if (dest) {
    smfHeader.pm_tr_topicname_bytes = dest.getBytes();
    if (dest.type === DestinationType.QUEUE ||
        dest.type === DestinationType.TEMPORARY_QUEUE) {
      var offset = dest.offset;
      smfHeader.pm_queue_len = smfHeader.pm_tr_topicname_bytes.length - offset;
      smfHeader.pm_queue_offset = offset;
    }
  }

  // Setup user properties, header properties, msgtype
  if (message.getCorrelationId() ||
      message.getApplicationMessageId() ||
      message.getApplicationMessageType() ||
      message.getReplyTo() ||
      message.getSenderId() ||
      message.getSequenceNumber() ||
      message.getSenderTimestamp() ||
      message.getUserPropertyMap() ||
      message.isReplyMessage() ||
      (message.getType() !== MessageLib.MessageType.BINARY)) {
    // add SDT binary metadata
    adaptMessageToBinaryMeta(message);
  }

  smfHeader.smf_priority = priorityForUserCos.value.get(message.getUserCos());

  if (message.getPriority() !== undefined
    && typeof message.getPriority() === 'number'
    && message.getPriority() <= 255
    && message.getPriority() >= 0) {
    smfHeader.pm_msg_priority = message.getPriority();
  } else {
    smfHeader.pm_msg_priority = null;
  }

  var userData = message.getUserData();
  smfHeader.pm_userdata = (userData === null || userData === undefined)
    ? null
    : message.getUserData();

  // Build array of ContentSummaryElements
  var csumm = [];
  var payload = [];
  addContentElementToArrays(csumm, payload,
                            message.getXmlMetadata(), ContentSummaryType.XML_META);
  addContentElementToArrays(csumm, payload,
                            message.getXmlContent(), ContentSummaryType.XML_PAYLOAD);
  addContentElementToArrays(csumm, payload,
                            message.getBinaryAttachment(), ContentSummaryType.BINARY_ATTACHMENT);

  var binaryMeta = message.binaryMetadataChunk;
  if (binaryMeta !== null) {
    var binaryMetaSMF = binaryMeta.asEncodedSmf();
    var MAX_24BITS = 16777215;
    if (binaryMetaSMF.length > MAX_24BITS) {
      LOG_TRACE(("binary-meta data (" + (binaryMetaSMF.length) + ") over the " + MAX_24BITS + " limit"));
      throw new OperationError(("binary-meta data (" + (binaryMetaSMF.length) + ") over the " + MAX_24BITS + " limit"), ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    } else {
      addContentElementToArrays(csumm, payload, binaryMetaSMF, ContentSummaryType.BINARY_METADATA);
    }
  }
  if (csumm.length === 0 ||
      (csumm.length === 1 && csumm[0].type === ContentSummaryType.BINARY_ATTACHMENT)) {
    // NULL or RAW payload (no content-summary)
    //  Was this here to invert the condition?
    // LOG_TRACE('NULL or RAW payload (no content-summary)');
  } else {
    smfHeader.pm_content_summary = csumm;
  }

  var payloadBytes = payload.join('');
  smfHeader.payload = payloadBytes;
}

/**
 * Creates an array of all values that fit in the given number of bits.
 * e.g. bitRange(1) => [0, 1], bitRange(2) => [0, 1, 2, 3]
 * @param {Number} bits The number of bits in the range
 * @returns {Number} All values that fit in that number of bits
 * @private
 */
var bitRange = function (bits) { return Array.from(Array(Math.pow(2, bits))).map(function (el, i) { return i; }); };
var maskValues = function (shift, bits) { return bitRange(bits).map(function (val) { return setBits(0, val, shift, bits); }); };
var DI_BIT = maskValues(31, 1);
var ELIDING_ELIGIBLE_BIT = maskValues(30, 1);
var DTO_BIT = maskValues(29, 1);
var ADF_BIT = maskValues(28, 1);
var DMQE_BIT = maskValues(27, 1);
var VERSION_BITS = maskValues(24, 3);
var UH_BITS = maskValues(22, 2);
var PROTOCOL_BITS = maskValues(16, 6);
var PRIORITY_BITS = maskValues(12, 4);
var TTL_BITS = maskValues(0, 8);
var QT_OFFSET_BYTES = maskValues(8, 8);
var QT_LEN_BYTES = maskValues(0, 8);

function encodeSMF(header) {
  // First 4 bytes: protocol, ttl, etc
  var w1 = 0;

  // PERF: single expression to make w1 const
  w1 |= DI_BIT[header.smf_di && 1 || 0];
  w1 |= ELIDING_ELIGIBLE_BIT[header.smf_elidingEligible && 1 || 0];
  w1 |= DTO_BIT[header.smf_dto && 1 || 0];
  w1 |= ADF_BIT[header.smf_adf && 1 || 0];
  w1 |= DMQE_BIT[header.smf_deadMessageQueueEligible && 1 || 0];
  w1 |= VERSION_BITS[header.smf_version || 0];
  w1 |= UH_BITS[header.smf_uh || 0];
  w1 |= PROTOCOL_BITS[header.smf_protocol || 0];
  w1 |= PRIORITY_BITS[header.smf_priority || 0];
  w1 |= TTL_BITS[header.smf_ttl || 0]; // PERF: or set w1 to ttl initially.

  var params = [];
  // Encode all standard SMF parameters
  // Topic name and queue/topic offsets are supposed to come first
  if (header.pm_tr_topicname_bytes) {
    params.push(encodeSMFParam(2, SMFParameterType.TR_TOPICNAME,
                               ("" + (header.pm_tr_topicname_bytes))));
  }
  if (header.pm_queue_len) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_QUEUE_NAME_OFFSET,
                                 int16ToStr(QT_OFFSET_BYTES[header.pm_queue_offset] |
                                            QT_LEN_BYTES[header.pm_queue_len])));
  }
  if (header.pm_topic_len) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_TOPIC_NAME_OFFSET,
                                 int16ToStr(QT_OFFSET_BYTES[header.pm_topic_offset] |
                                            QT_OFFSET_BYTES[header.pm_topic_len])));
  }

  if (header.pm_corrtag !== null && header.pm_corrtag !== undefined) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_CORRELATION,
                                 int24ToStr(header.pm_corrtag)));
  }
  if (header.pm_ad_ackimm) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_ACK_IMMEDIATELY,
                                 ''));
  }

  if (header.pm_msg_priority !== null) {
    params.push(encodeSMFParam(0, SMFParameterType.MESSAGEPRIORITY,
                               int8ToStr(header.pm_msg_priority)));
  }
  if (header.pm_userdata !== null && header.pm_userdata !== '') {
    params.push(encodeSMFParam(0, SMFParameterType.USERDATA,
                               header.pm_userdata));
  }
  if (header.pm_username) {
    // do a sloppy base64 (no newlines)
    params.push(encodeSMFParam(0, SMFParameterType.USERNAME,
                               base64Encode(header.pm_username)));
  }
  if (header.pm_password) {
    // do a sloppy base64 (no newlines)
    params.push(encodeSMFParam(0, SMFParameterType.PASSWORD,
                               base64Encode(header.pm_password)));
  }
  if (header.pm_respcode) {
    // not useful API->router
    params.push(encodeSMFParam(0, SMFParameterType.RESPONSE,
                               int32ToStr(header.pm_respcode) + header.pm_respstr));
  }

  if (header.pm_deliverymode !== null) {
    params.push(encodeSMFParam(0, SMFParameterType.DELIVERY_MODE,
                               encDeliveryMode(header.pm_deliverymode)));
  }

  if (header.pm_ad_msgid !== undefined) {
    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_MESSAGE_ID,
                               int64ToStr(header.pm_ad_msgid)));
    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_PREVMESSAGE_ID,
                               int64ToStr(header.pm_ad_prevmsgid)));
  }

  if (header.pm_ad_flowid) {
    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_FLOWID,
                               int32ToStr(header.pm_ad_flowid)));
  }

  // header.pm_ad_redelflag
  // Ad redelivered
  if (header.pm_ad_redelflag) {
    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_REDELIVERED_FLAG, undefined));
  }
  // header.pm_ad_flowredelflag

  if (header.pm_ad_ttl !== undefined) {
    params.push(encodeSMFParam(0, SMFParameterType.AD_TIMETOLIVE,
                               int64ToStr(header.pm_ad_ttl)));
  }

  // sequence number?

  if (header.pm_ad_publisherid) {
    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_ID,
                               int32ToStr(header.pm_ad_publisherid)));
  }

  if (header.pm_ad_publisherMsgId) {
    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_MSGID,
                               int64ToStr(header.pm_ad_publisherMsgId)));
  }

  // transactions: ackmessageid, transactionid, transactionflags

  if (header.pm_content_summary) {
    params.push(encodeSMFParam(2, SMFParameterType.MESSAGE_CONTENT_SUMMARY,
                               encContentSummary(header.pm_content_summary)));
  }
  // done common SMF parameters!

  // compute header size and full message size
  var encodedParams = params.join('');
  var hdrlen = 12 + encodedParams.length;
  var msglen = hdrlen + header.payloadLength;

  // ? Already encoded. Why bother?
  header.setMessageSizes(hdrlen, header.payloadLength);

  return (
    int32ToStr(w1) +
    int32ToStr(hdrlen) +
    int32ToStr(msglen) +
    encodedParams
  );
}

function encodeCompoundMessage(msg) {
  var payload = '';
  if (msg instanceof MessageLib.Message) {
    if (!msg.smfHeader) {
      msg.smfHeader = new SMFHeader(SMFProtocol.TRMSG, 255);
    }
    adaptMessageToSmf(msg, msg._smfHeader);
    payload = msg._smfHeader.payload;
  } else if (msg instanceof ClientCtrlMessage) {
    payload = encCC(msg);
  } else if (msg instanceof SMPMessage) {
    payload = encSmp(msg);
  } else if (msg instanceof KeepAliveMessage) {
    LOG_TRACE('Skipping retrieve payload as there is none in a KeepAliveMessage');
  } else if (msg instanceof AdProtocolMessage) {
    payload = encAdp(msg);
  }
  var header = msg.smfHeader;
  header.setPayloadSize(payload.length);
  var encodedHeader = encodeSMF(header);
  return encodedHeader + payload;
}

var Encode = {
  encodeCompoundMessage: encodeCompoundMessage,
  encodeSMF: encodeSMF,
};

module.exports.Encode = Encode;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Long = ref$1.Long;
var ref$2 = __webpack_require__(5);
var DestinationType = ref$2.DestinationType;
var ref$3 = __webpack_require__(1);
var LOG_TRACE = ref$3.LOG_TRACE;
var ref$4 = __webpack_require__(2);
var OperationError = ref$4.OperationError;
var ref$5 = __webpack_require__(18);
var QueueAccessType = ref$5.QueueAccessType;
var QueueDiscardBehavior = ref$5.QueueDiscardBehavior;
var ref$6 = __webpack_require__(18);
var QueuePermissions = ref$6.QueuePermissions;
var ref$7 = __webpack_require__(126);
var SMFAdProtocolMessageType = ref$7.SMFAdProtocolMessageType;
var ref$8 = __webpack_require__(127);
var SMFAdProtocolParam = ref$8.SMFAdProtocolParam;
var ref$9 = __webpack_require__(32);
var SMFHeader = ref$9.SMFHeader;
var ref$10 = __webpack_require__(77);
var SMFParameter = ref$10.SMFParameter;
var ref$11 = __webpack_require__(22);
var SMFProtocol = ref$11.SMFProtocol;
var ref$12 = __webpack_require__(125);
var SMFUH = ref$12.SMFUH;
var ref$13 = __webpack_require__(4);
var StringUtils = ref$13.StringUtils;

var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var strToUInt32 = Convert.strToUInt32;
var strToUInt64 = Convert.strToUInt64;

var stripNullTerminate = StringUtils.stripNullTerminate;

// QUEUENAME/TOPICNAME
var EndpointTypeToParam = {};
EndpointTypeToParam[DestinationType.TOPIC] = SMFAdProtocolParam.DTENAME;
EndpointTypeToParam[DestinationType.QUEUE] = SMFAdProtocolParam.QUEUENAME;

var QUEUE_PERMISSIONS_TO_BITS = {};
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.NONE] = 0x0000;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.READ_ONLY] = 0x0001;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.CONSUME] = 0x0003;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.MODIFY_TOPIC] = 0x0007;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.DELETE] = 0x000f;

var ACCESS_TYPE_INT_TO_ENUM = {
  0x01: QueueAccessType.EXCLUSIVE,
  0x02: QueueAccessType.NONEXCLUSIVE,
};

var DISCARD_ENUM_TO_VALUE = {};
DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF] = 0x01;
DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_ON] = 0x02;

/**
 * @internal
 */
var AdProtocolMessage = (function (BaseMessage) {
  function AdProtocolMessage(messageType, version) {
    if ( messageType === void 0 ) messageType = 0;
    if ( version === void 0 ) version = 3;

    BaseMessage.call(this, new SMFHeader(SMFProtocol.ADCTRL, 1));

    // Field: msgtype
    this.msgType = messageType;

    // Field: version
    this.version = version;
  }

  if ( BaseMessage ) AdProtocolMessage.__proto__ = BaseMessage;
  AdProtocolMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  AdProtocolMessage.prototype.constructor = AdProtocolMessage;

  AdProtocolMessage.prototype._readParameter = function _readParameter (paramtype, decoder) {
    if ( decoder === void 0 ) decoder = null;

    var param = this.getParameter(paramtype);
    if (param === undefined) { return undefined; }
    var value = param.getValue();
    return decoder ? decoder(value) : value;
  };

  /**
   * @returns {?QueueAccessType} The access type, if present
   */
  AdProtocolMessage.prototype.getAccessType = function getAccessType () {
    var param = this._readParameter(SMFAdProtocolParam.ACCESSTYPE, strToInt8);
    return ACCESS_TYPE_INT_TO_ENUM[param];
  };

  /**
   * @returns {?Boolean} The active flow indication, if present
   */
  AdProtocolMessage.prototype.getActiveFlow = function getActiveFlow () {
    return this._readParameter(SMFAdProtocolParam.ACTIVE_FLOW_INDICATION, strToInt8);
  };

  /**
   * @returns {?QueueDiscardBehavior} The discard behavior for the endpoint, if present
   */
  AdProtocolMessage.prototype.getQueueDiscardBehavior = function getQueueDiscardBehavior () {
    var param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16);
    // Get NotifySender flag
    var masked = (param & 0x3000) >> 12;
    if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF]) {
      return QueueDiscardBehavior.NOTIFY_SENDER_OFF;
    }
    return QueueDiscardBehavior.NOTIFY_SENDER_ON;
  };

  /**
   * @returns {?Number} The endpoint ID, if present
   */
  AdProtocolMessage.prototype.getEndpointId = function getEndpointId () {
    return this._readParameter(SMFAdProtocolParam.ENDPOINT_ID, strToUInt32);
  };

  /**
   * @returns {?Number} Whether endpoint respects TTL
   */
  AdProtocolMessage.prototype.getRespectsTTL = function getRespectsTTL () {
    return !!this._readParameter(SMFAdProtocolParam.EP_RESPECTS_TTL, strToInt8);
  };

  /**
   * @returns {?String} The router-assigned flow name, if present
   */
  AdProtocolMessage.prototype.getFlowName = function getFlowName () {
    return this._readParameter(SMFAdProtocolParam.FLOWNAME, stripNullTerminate);
  };

  /**
   * @returns {?Number} The router-assigned flow ID, if present
   */
  AdProtocolMessage.prototype.getFlowId = function getFlowId () {
    return this._readParameter(SMFAdProtocolParam.FLOWID, strToUInt32);
  };

  /**
   * @returns {?String} The UTF-8 encoded, null terminated endpoint name
   */
  AdProtocolMessage.prototype.getTopicEndpointBytes = function getTopicEndpointBytes () {
    return this._readParameter(SMFAdProtocolParam.DTENAME);
  };

  /**
   * @returns {?QueuePermissions} The granted permissions for the flow, if present
   */
  AdProtocolMessage.prototype.getGrantedPermissions = function getGrantedPermissions () {
    var permissions = this._readParameter(SMFAdProtocolParam.GRANTED_PERMISSIONS, strToUInt32);
    var result;
    Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(function (key) {
      if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
        result = key;
      }
    });
    return result;
  };

  /**
   * @returns {?Long} The last message ID acked, if present
   */
  AdProtocolMessage.prototype.getLastMsgIdAcked = function getLastMsgIdAcked () {
    return this._readParameter(SMFAdProtocolParam.LASTMSGIDACKED,
                               strToUInt64);
  };

  /**
   * @returns {?Long} The last message ID received, if present
   */
  AdProtocolMessage.prototype.getLastMsgIdReceived = function getLastMsgIdReceived () {
    return this._readParameter(SMFAdProtocolParam.LASTMSGIDRECEIVED,
                               strToUInt64);
  };

  /**
   * @returns {?Number} The publisher ID, if present
   */
  AdProtocolMessage.prototype.getPublisherId = function getPublisherId () {
    return this._readParameter(SMFAdProtocolParam.PUBLISHER_ID, strToUInt32);
  };

  /**
   * @returns {?Number} Whether we want flow change notifications, if present
   */
  AdProtocolMessage.prototype.getWantFlowChangeNotify = function getWantFlowChangeNotify () {
    return !!this._readParameter(SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, strToInt8);
  };

  /**
   * @returns {?Number} The Window parameter, if present
   */
  AdProtocolMessage.prototype.getWindow = function getWindow () {
    return this._readParameter(SMFAdProtocolParam.WINDOW, strToInt8);
  };

  /**
   * @returns {?Number} The max unacked messages parameter, if present
   */
  AdProtocolMessage.prototype.getMaxUnackedMessages = function getMaxUnackedMessages () {
    return this._readParameter(SMFAdProtocolParam.MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW,
                               strToUInt32);
  };

  /**
   * Creates a CLOSEPUBFLOW message
   * @param {Number} flowId The publisher flow to close
   * @param {Number} correlationTag The correlation tag for the request
   * @returns {AdProtocolMessage} The newly created message
   * @internal
   * @static
   */
  AdProtocolMessage.getCloseMessagePublisher = function getCloseMessagePublisher (flowId,
                                  correlationTag) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.CLOSEPUBFLOW);

    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.FLOWID,
                                          flowId));
    return message;
  };

  /**
   * Returns an AdProtocolMessage that describes a publisher open-flow request.
   * @static
   * @param {?Long} lastMsgIdAcked Last message ID acked, if re-opening
   * @param {?Long} lastMsgIdSent Last message ID sent, if re-opening
   * @param {Number} windowSize Desired window size
   * @param {String} flowName Last flow name in use, if re-opening
   * @param {Number} correlationTag Correlation tag for the request
   * @returns {solace.AdProtocolMessage} The OPENPUBFLOW message
   * @internal
   */
  AdProtocolMessage.getOpenMessagePublisher = function getOpenMessagePublisher (
            lastMsgIdAcked,
            lastMsgIdSent,
            windowSize,
            flowName,
            correlationTag) {
    var adMsg = new AdProtocolMessage(SMFAdProtocolMessageType.OPENPUBFLOW);

    var smfHeader = adMsg.smfHeader;
    smfHeader.pm_corrtag = correlationTag;

    if (lastMsgIdAcked !== undefined) {
      adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.LASTMSGIDACKED,
                                          lastMsgIdAcked));
    }
    if (lastMsgIdSent !== undefined) {
      adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.LASTMSGIDSENT,
                                          lastMsgIdSent));
    }

    adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                        SMFAdProtocolParam.WINDOW,
                                        windowSize));

    adMsg.addParameter(new SMFParameter(SMFUH.IGNORE,
                                        SMFAdProtocolParam.FLOWNAME,
                                        flowName || ''));

    LOG_TRACE(("Create open publisher: lastMsgIdAcked=" + lastMsgIdAcked + " lastMsgIdSent=" + lastMsgIdSent + " window=" + windowSize + " flowName=" + (flowName || '(null)')));

    return adMsg;
  };

  /**
   * Returns an AdProtocolMessage that describes a subscriber (MessageConsumer) bind request.
   * @static
   * @param {solace.QueueDescriptor} queueDescriptor The endpoint descriptor for the bind request
   * @param {?solace.QueueProperties} queueProperties The properties for the bind request
   * @param {solace.Destination} endpoint The endpoint for the bind request
   * @param {?solace.Topic} topicSubscription The topic endpoint
   * @param {String} correlationTag The correlation tag for the request
   * @param {Number} windowSize The desired window size
   * @param {Boolean} [noLocal=false] If true, local publisher messages are not delivered
   * @param {Boolean} [wantFlowChangeUpdate] default is true if destination is a {solace.Queue}
   * @param {Long} [lastMsgIdAcked=Long.UZERO] Last message ID acked, if re-binding
   * @param {Long} [lastMsgIdReceived=Long.UZERO] Last message ID received, if re-binding
   * @returns {solace.AdProtocolMessage} The BIND message
   * @internal
   */
  AdProtocolMessage.getOpenMessageConsumer = function getOpenMessageConsumer (queueDescriptor,
                                queueProperties,
                                endpoint,
                                topicSubscription,
                                correlationTag,
                                windowSize,
                                noLocal,
                                wantFlowChangeUpdate,
                                lastMsgIdAcked,
                                lastMsgIdReceived) {
    if ( lastMsgIdAcked === void 0 ) lastMsgIdAcked = Long.UZERO;
    if ( lastMsgIdReceived === void 0 ) lastMsgIdReceived = Long.UZERO;

    /*
    QUEUE FLOW                                      TE FLOW

    {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
    [Correlation Tag Parameter]                     [Correlation Tag Parameter]
    {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}

    {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
    ***                                             {AssuredCtrl TopicName Parameter}
    [AssuredCtrl Last Message Id Acked Parameter]   ***
    [AssuredCtrl Last Message Id Recv'd Parameter]  ***
    {AssuredCtrl Transport Window Size Parameter}   {AssuredCtrl Transport Window Size Parameter}
    [AssuredCtrl Durability Parameter]              [AssuredCtrl Durability Parameter]
    [AssuredCtrl Message Selector Parameter]        [AssuredCtrl Message Selector Parameter]
    [AssuredCtrl FlowType Parameter]                [AssuredCtrl FlowType Parameter]
    [AssuredCtrl Selector Parameter]                [AssuredCtrl Selector Parameter]
    [AssuredCtrl AllOthersPermissions Parameter]    [AssuredCtrl AllOthersPermissions Parameter]
    [AssuredCtrl EndpointQuotaMB Parameter]         [AssuredCtrl EndpointQuotaMB Parameter]
    [AssuredCtrl EndpointMaxMessageSize Parameter]  [AssuredCtrl EndpointMaxMessageSize Parameter]
    [AssuredCtrl TransactedSessionId Parameter]     [AssuredCtrl TransactedSessionId Parameter]
    [AssuredCtrl NoLocal Parameter]                 [AssuredCtrl NoLocal Parameter]
    [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
    [AssuredCtrl qEndpointBehaviourFlags Parameter] [AssuredCtrl qEndpointBehaviourFlags Parameter]
    [AssuredCtrl MaxRedelivery Parameter]           [AssuredCtrl MaxRedelivery Parameter]

    */
    var durable = queueDescriptor.durable;
    var endpointBytes = endpoint.bytes;
    var endpointType = endpoint.type;

    // {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
    // [Correlation Tag Parameter]                     [Correlation Tag Parameter]
    // {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.BIND);
    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    // {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
    var endpointTypeParam = EndpointTypeToParam[endpointType];
    if (endpointTypeParam === undefined) { throw new OperationError('Unknown destination type'); }
    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      endpointTypeParam,
      endpointBytes
    ));

    // ***                                             {AssuredCtrl TopicName Parameter}
    if (topicSubscription) {
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.TOPICNAME,
        topicSubscription.bytes
      ));
    }

    if (endpointType === DestinationType.QUEUE) {
      //     [AssuredCtrl Last Message Id Acked Parameter]   ***
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.LASTMSGIDACKED,
        lastMsgIdAcked
      ));
      //     [AssuredCtrl Last Message Id Recv'd Parameter]  ***
      message.addParameter(new SMFParameter(
        SMFUH.IGNORE,
        SMFAdProtocolParam.LASTMSGIDRECEIVED,
        lastMsgIdReceived
      ));
    }

    // {AssuredCtrl Transport Window Size Parameter}
    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.WINDOW,
      windowSize
    ));

    // [AssuredCtrl Durability Parameter]
    message.addParameter(new SMFParameter(
      SMFUH.IGNORE,
      SMFAdProtocolParam.EP_DURABLE,
      durable
    ));

    // Omit Message Selector
    // Omit FlowType, CONSUMER assumed (not BROWSER currently)
    // Omit TransactedSessionId

    if (queueProperties) {
      var discardBehavior = queueProperties.discardBehavior;
      var maxMessageRedelivery = queueProperties.maxMessageRedelivery;
      var maxMessageSize = queueProperties.maxMessageSize;
      var permissions = queueProperties.permissions;
      var quotaMB = queueProperties.quotaMB;
      var respectsTTL = queueProperties.respectsTTL;

      // [AssuredCtrl AllOthersPermissions Parameter]
      if (permissions && QUEUE_PERMISSIONS_TO_BITS[permissions]) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_ALLOTHER_PERMISSION,
          QUEUE_PERMISSIONS_TO_BITS[permissions]
        ));
      }

      // [AssuredCtrl EndpointQuotaMB Parameter]
      if (quotaMB !== null && quotaMB !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_QUOTA,
          quotaMB
        ));
      }

      // [AssuredCtrl EndpointMaxMessageSize Parameter]
      if (maxMessageSize !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_MAX_MSGSIZE,
          maxMessageSize
        ));
      }

      var flags = 0x0000;
      if (discardBehavior !== null && discardBehavior !== undefined) {
        var discardBehaviorValue = DISCARD_ENUM_TO_VALUE[discardBehavior];
        flags |= (discardBehaviorValue << 12);
        // Omit cutThrough, << 14
      }
      if (flags /* is nonzero */) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_BEHAVIOUR,
          flags
        ));
      }

      if (maxMessageRedelivery !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.MAX_REDELIVERY,
          maxMessageRedelivery
        ));
      }

      if (respectsTTL /* is true */) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_RESPECTS_TTL,
          0x1
        ));
      }
    }

    if (noLocal /* is true */) {
      // [AssuredCtrl NoLocal Parameter]
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.NOLOCAL,
        0x1
      ));
    }

    if (wantFlowChangeUpdate /* is true */) {
      // [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
      message.addParameter(new SMFParameter(
        SMFUH.IGNORE,
        SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY,
        0x1
      ));
    }

    return message;
  };

  /**
   * Creates an UNBIND request
   * @param {Number} flowId The flow ID to unbind
   * @param {Number} correlationTag The correlation tag for the request
   * @param {?Long} lastMessageIdAcked The last message ID marked as locally acked
   * @returns {AdProtocolMessage} The new UNBIND request
   * @static
   * @internal
   */
  AdProtocolMessage.getCloseMessageConsumer = function getCloseMessageConsumer (flowId,
                                 correlationTag) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);

    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.FLOWID,
                                          flowId));
    // linger: assume no

    return message;
  };

  AdProtocolMessage.getDTEUnsubscribeMessage = function getDTEUnsubscribeMessage (correlationTag,
                                  topic) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.UNSUBSCRIBE);
    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.DTENAME,
      topic.getBytes()
    ));

    return message;
  };

  /**
   * @param {Number} flowId The flow on which to acknowledge messages.
   * @param {?Long} [lastMessageIdAcked=undefined] The transport acknowledges receipt of all
   *  messages up to and including this ID.
   * @param {?Long} [windowSize=undefined] The size to which the flow window should be set.
   * @param {?Array.<Array.<Long>>} [applicationAckRanges=undefined] Low-high ID pairs of
   *  message IDs to acknowledge at the application level. To application ack a single message,
   *  pass `[ [singleMessageId, singleMessageId] ]`.
   * @returns {solace.AdProtocolMessage} A message containing the given parameters.
   * @internal
   * @static
   */
  AdProtocolMessage.getAck = function getAck (flowId,
                lastMessageIdAcked,
                windowSize,
                applicationAckRanges) {
    if ( lastMessageIdAcked === void 0 ) lastMessageIdAcked = undefined;
    if ( windowSize === void 0 ) windowSize = undefined;
    if ( applicationAckRanges === void 0 ) applicationAckRanges = undefined;

    var message = new AdProtocolMessage(SMFAdProtocolMessageType.CLIENTACK);

    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.FLOWID,
      flowId
    ));

    if (lastMessageIdAcked) {
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.LASTMSGIDACKED,
        lastMessageIdAcked
      ));
    }

    if (windowSize !== undefined && windowSize !== null) {
      // There are two windowSize options; we'll use the legacy one for smaller
      // window sizes
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        (windowSize <= 0xFF) ? SMFAdProtocolParam.WINDOW : SMFAdProtocolParam.TRANSPORT_WINDOW,
        windowSize
      ));
    }

    if (applicationAckRanges && applicationAckRanges.length) {
      if (applicationAckRanges.length > AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
        throw new OperationError('Application ack range count exceeds limit of 64');
      }
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.APPLICATION_ACK,
        applicationAckRanges // DANGER: this needs to be encoded immediately, or else deep-cloned
      ));
    }

    return message;
  };

  return AdProtocolMessage;
}(BaseMessage));

AdProtocolMessage.MAX_CLIENT_ACK_RANGES = 64;

module.exports.AdProtocolMessage = AdProtocolMessage;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;

var bits = Bits.get;
var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int24ToStr = Convert.int24ToStr;
var strToInt32 = Convert.strToInt32;

/**
 * @classdesc
 *
 * BinaryMetaBlock represents a binary metadata block in a TrMsg
 *
 * @private
 */
var BinaryMetaBlock = function BinaryMetaBlock(type, payload) {
  this.type = type;
  this.payload = payload;
};

BinaryMetaBlock.prototype.asEncodedSmf = function asEncodedSmf () {
  var smf = [];
  smf.push(int8ToStr(1));
  smf.push(int8ToStr(this.type));
  smf.push(int24ToStr(this.payload.length));
  smf.push(this.payload);
  return smf.join('');
};

BinaryMetaBlock.fromEncodedSmf = function fromEncodedSmf (strSmf, offset) {
    if ( offset === void 0 ) offset = 0;

  if ((strSmf.length - offset) < 6) {
    return null; // not enough data
  }
  var chunkCount = strToInt8(strSmf.substr(offset, 1));
  var fourbyte = strToInt32(strSmf.substr(offset + 1, 4));
  var type = bits(fourbyte, 24, 8);
  var payloadLen = bits(fourbyte, 0, 24);
  var payloadOffset = chunkCount * 4 + 1;
  var payload = strSmf.substr(offset + payloadOffset, payloadLen);
  return new BinaryMetaBlock(type, payload);
};


module.exports.BinaryMetaBlock = BinaryMetaBlock;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(21);
var AuthenticationScheme = ref.AuthenticationScheme;
var CapabilityType = ref.CapabilityType;
var MutableSessionProperty = ref.MutableSessionProperty;
var SessionProperties = ref.SessionProperties;
var ref$1 = __webpack_require__(31);
var BaseMessage = ref$1.BaseMessage;
var ref$2 = __webpack_require__(3);
var Bits = ref$2.Bits;
var Convert = ref$2.Convert;
var ref$3 = __webpack_require__(5);
var DestinationType = ref$3.DestinationType;
var DestinationUtil = ref$3.DestinationUtil;
var ref$4 = __webpack_require__(2);
var ErrorSubcode = ref$4.ErrorSubcode;
var OperationError = ref$4.OperationError;
var ref$5 = __webpack_require__(4);
var Process = ref$5.Process;
var StringUtils = ref$5.StringUtils;
var Version = ref$5.Version;
var ref$6 = __webpack_require__(128);
var SMFClientCtrlMessageType = ref$6.SMFClientCtrlMessageType;
var ref$7 = __webpack_require__(129);
var SMFClientCtrlParam = ref$7.SMFClientCtrlParam;
var ref$8 = __webpack_require__(32);
var SMFHeader = ref$8.SMFHeader;
var ref$9 = __webpack_require__(77);
var SMFParameter = ref$9.SMFParameter;
var ref$10 = __webpack_require__(22);
var SMFProtocol = ref$10.SMFProtocol;

var bits = Bits.get;
var setBits = Bits.set;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var strToInt32 = Convert.strToInt32;
var nullTerminate = StringUtils.nullTerminate;
var stripNullTerminate = StringUtils.stripNullTerminate;
var validateAndEncode = DestinationUtil.validateAndEncode;

var BOOLEAN_CAPS_BITS = [
  CapabilityType.JNDI,
  CapabilityType.COMPRESSION,
  CapabilityType.GUARANTEED_MESSAGE_CONSUME,
  CapabilityType.TEMPORARY_ENDPOINT,
  CapabilityType.GUARANTEED_MESSAGE_PUBLISH,
  CapabilityType.GUARANTEED_MESSAGE_BROWSE,
  CapabilityType.ENDPOINT_MGMT,
  CapabilityType.SELECTOR,
  CapabilityType.ENDPOINT_MESSAGE_TTL,
  CapabilityType.QUEUE_SUBSCRIPTIONS,
  null, // skip obsolete FLOW_RECOVER
  CapabilityType.SUBSCRIPTION_MANAGER,
  CapabilityType.MESSAGE_ELIDING,
  CapabilityType.TRANSACTED_SESSION,
  CapabilityType.NO_LOCAL,
  CapabilityType.ACTIVE_CONSUMER_INDICATION,
  CapabilityType.PER_TOPIC_SEQUENCE_NUMBERING,
  CapabilityType.ENDPOINT_DISCARD_BEHAVIOR,
  CapabilityType.CUT_THROUGH,
  null ];

/**
 * @classdesc ClientCtrlMessage
 * Represents a ClientCtrl request or reply message
 * @private
 */
var ClientCtrlMessage = (function (BaseMessage) {
  function ClientCtrlMessage(messageType) {
    if ( messageType === void 0 ) messageType = 0;

    BaseMessage.call(this, new SMFHeader(SMFProtocol.CLIENTCTRL, 1));

    // Field: msgtype
    this.msgType = messageType;

    // Field: version
    this.version = 1;
  }

  if ( BaseMessage ) ClientCtrlMessage.__proto__ = BaseMessage;
  ClientCtrlMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  ClientCtrlMessage.prototype.constructor = ClientCtrlMessage;

  ClientCtrlMessage.prototype.getP2PTopicValue = function getP2PTopicValue () {
    var p2pParam = this.getParameter(SMFClientCtrlParam.P2PTOPIC);
    if (!p2pParam) {
      return null;
    }
    return stripNullTerminate(p2pParam.getValue());
  };

  ClientCtrlMessage.prototype.getVpnNameInUseValue = function getVpnNameInUseValue () {
    var vpnParam = this.getParameter(SMFClientCtrlParam.MSGVPNNAME);
    if (!vpnParam) {
      return null;
    }
    return stripNullTerminate(vpnParam.getValue());
  };

  ClientCtrlMessage.prototype.getVridInUseValue = function getVridInUseValue () {
    var vridParam = this.getParameter(SMFClientCtrlParam.VRIDNAME);
    if (!vridParam) {
      return null;
    }
    return stripNullTerminate(vridParam.getValue());
  };

  ClientCtrlMessage.prototype.getUserIdValue = function getUserIdValue () {
    var userIdParam = this.getParameter(SMFClientCtrlParam.USERID);
    if (!userIdParam) {
      return null;
    }
    return stripNullTerminate(userIdParam.getValue());
  };

  ClientCtrlMessage.prototype.getRouterCapabilities = function getRouterCapabilities () {
    var caps = [];

    // Parse the composite capabilities parameter
    var capParam = this.getParameter(SMFClientCtrlParam.ROUTER_CAPABILITIES);
    if (capParam) {
      caps = ClientCtrlMessage.prmParseCapabilitiesValue(capParam.getValue(), caps);
    }

    // Parse out the router status strings
    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREVERSION);
    if (capParam) {
      caps[CapabilityType.PEER_SOFTWARE_VERSION] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREDATE);
    if (capParam) {
      caps[CapabilityType.PEER_SOFTWARE_DATE] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.PLATFORM);
    if (capParam) {
      caps[CapabilityType.PEER_PLATFORM] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.PHYSICALROUTERNAME);
    if (capParam) {
      caps[CapabilityType.PEER_ROUTER_NAME] = stripNullTerminate(capParam.getValue());
    }
    return caps;
  };


  ClientCtrlMessage.prmGetDtoPriorityValue = function prmGetDtoPriorityValue (dto) {
    if (dto.local === undefined || dto.network === undefined) {
      return false;
    }
    var twobyte = 0;
    twobyte = setBits(twobyte, dto.local, 8, 8);
    twobyte = setBits(twobyte, dto.network, 0, 8);
    return int16ToStr(twobyte);
  };

  ClientCtrlMessage.prmParseDtoPriorityValue = function prmParseDtoPriorityValue (strDtoPriority) {
    var dto = {};
    var twobyte = strToInt16(strDtoPriority.substr(0, 2));
    dto.local = bits(twobyte, 8, 8);
    dto.network = bits(twobyte, 0, 8);
    return dto;
  };

  /*
  strCapabilities: parameter value
  caps: an already existing hash array of CapabilityType
   */
  ClientCtrlMessage.prmParseCapabilitiesValue = function prmParseCapabilitiesValue (strCapabilities, capsIn) {
    var caps = capsIn;
    if (!(strCapabilities && caps)) {
      return false;
    }
    var CT = CapabilityType;
    var pos = 0;

    // parse boolean capabilities
    var boolCapCount = strToInt8(strCapabilities[pos]);
    ++pos;

    // The boolean caps are listed in order as in the documentation,
    // that is from MSB to LSB for each caps byte.
    var capsByte;
    for (var bitIndex = 0; bitIndex < boolCapCount; ++bitIndex) {
      var msbIndex = bitIndex & 0x7;
      if (msbIndex === 0) { // Consume a byte
        capsByte = strToInt8(strCapabilities[pos]);
        ++pos;
      }
      var capsKey = BOOLEAN_CAPS_BITS[bitIndex];
      if (!capsKey) { continue; } // We don't know about this cap
      // BOOLEAN_CAPS_BITS counts left to right,
      // so set caps bits from MSB (bit 7) to LSB (bit 0)
      caps[capsKey] = !!bits(capsByte, 7 - msbIndex, 1);
    }

    // parse non-boolean capabilities
    var sanityLoop = 500;
    for (var i = 0; pos < strCapabilities.length && i < sanityLoop; ++i) {
      var onebyte = strToInt8(strCapabilities[pos]); // type
      pos++;
      var capLen = strToInt32(strCapabilities.substr(pos, 4)) - 5;
      pos += 4;
      var strValue = strCapabilities.substr(pos, capLen);
      pos += capLen;
      switch (onebyte) {
        case 0x00:
          caps[CT.PEER_PORT_SPEED] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        case 0x01:
          caps[CT.PEER_PORT_TYPE] = (strValue.length === 1) ? strToInt8(strValue) : 0;
          break;
        case 0x02:
          caps[CT.MAX_GUARANTEED_MSG_SIZE] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        case 0x03:
          caps[CT.MAX_DIRECT_MSG_SIZE] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        default:
          // NOOP (unknown cap)
          break;
      }
    }
    return caps;
  };

  ClientCtrlMessage.getLogin = function getLogin (sprop, correlationTag) {
    if (!(sprop instanceof SessionProperties)) {
      return false;
    }

    var cc = new ClientCtrlMessage(SMFClientCtrlMessageType.LOGIN);
    var smfHeader = cc._smfHeader;
    var isClientCert = sprop.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
    smfHeader.pm_corrtag = correlationTag;
    if (sprop.password && !isClientCert) {
      smfHeader.pm_password = sprop.password;
    }
    if (sprop.userName) {
      smfHeader.pm_username = sprop.userName;
    }
    if (sprop.subscriberLocalPriority && sprop.subscriberNetworkPriority) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.DELIVERTOONEPRIORITY,
                                       ClientCtrlMessage.prmGetDtoPriorityValue({
                                         local:   sprop.subscriberLocalPriority,
                                         network: sprop.subscriberNetworkPriority })));
    }
    if (sprop.vpnName && sprop.vpnName.length > 0) {
      cc.addParameter(new SMFParameter(1,
                                       SMFClientCtrlParam.MSGVPNNAME,
                                       nullTerminate(sprop.vpnName)));
    }

    if (sprop.applicationDescription && sprop.applicationDescription.length > 0) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTDESC,
                                       nullTerminate(sprop.applicationDescription)));
    }

    if (sprop.userIdentification && sprop.userIdentification.length > 0) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.USERID,
                                       nullTerminate(sprop.userIdentification)));
    }

    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.CLIENTNAME,
                                     nullTerminate(sprop.clientName)));
    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.PLATFORM,
                                     nullTerminate(((Process.platform) + " - JS API (" + (Version.mode) + ")"))));

    if (sprop.noLocal) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.NO_LOCAL,
                                       '\x01'));
    }

    if (isClientCert) {
      cc.addParameter(new SMFParameter(1,
                                       SMFClientCtrlParam.AUTHENTICATION_SCHEME,
                                       '\x01'));
    }

    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.SOFTWAREDATE,
                                     nullTerminate(Version.formattedDate)));
    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.SOFTWAREVERSION,
                                     nullTerminate(Version.version)));
    return cc;
  };

  /**
   * Get a CC update message.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property to update
   * @param {String} newValue The new value for the property
   * @param {String} correlationTag The correlation tag for the request
   * @returns {ClientCtrlMessage} The new UPDATE message
   *
   * @private
   */
  ClientCtrlMessage.getUpdate = function getUpdate (mutableSessionProperty, newValue, correlationTag) {
    var cc = new ClientCtrlMessage(SMFClientCtrlMessageType.UPDATE);
    var smfHeader = cc.smfHeader;
    smfHeader.pm_corrtag = correlationTag;
    if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
      var appdesc = (newValue || '').toString().substr(0, 250);
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTDESC,
                                       nullTerminate(appdesc)));
    } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
      var error =
        ClientCtrlMessage.validateClientName(
          newValue,
          function (errorMessage) { return new OperationError(("Invalid clientName: " + errorMessage),
                               ErrorSubcode.PARAMETER_OUT_OF_RANGE); });
      if (error) {
        throw error;
      }
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTNAME,
                                       nullTerminate(newValue)));
    }
    return cc;
  };

  ClientCtrlMessage.validateClientName = function validateClientName (strName, exceptionCreator) {
    var encodeResult = validateAndEncode(DestinationType.TOPIC, strName, exceptionCreator);
    if (encodeResult.error) {
      return encodeResult.error;
    }
    // Add 1: bytes includes terminator, 160 excludes terminator
    if (encodeResult.bytes.length > 161) {
      return exceptionCreator('Client Name too long (max length: 160).');
    }
    return null;
  };

  return ClientCtrlMessage;
}(BaseMessage));


module.exports.ClientCtrlMessage = ClientCtrlMessage;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;
var ref$1 = __webpack_require__(32);
var SMFHeader = ref$1.SMFHeader;
var ref$2 = __webpack_require__(22);
var SMFProtocol = ref$2.SMFProtocol;

var KeepAliveMessage = (function (BaseMessage) {
  function KeepAliveMessage() {
    BaseMessage.call(this, new SMFHeader(SMFProtocol.KEEPALIVEV2, 2));
    this._smfHeader.smf_uh = 2;
  }

  if ( BaseMessage ) KeepAliveMessage.__proto__ = BaseMessage;
  KeepAliveMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  KeepAliveMessage.prototype.constructor = KeepAliveMessage;

  return KeepAliveMessage;
}(BaseMessage));

module.exports.KeepAliveMessage = KeepAliveMessage;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(31);
var BaseMessage = ref$1.BaseMessage;
var ref$2 = __webpack_require__(5);
var Destination = ref$2.Destination;
var ref$3 = __webpack_require__(32);
var SMFHeader = ref$3.SMFHeader;
var ref$4 = __webpack_require__(22);
var SMFProtocol = ref$4.SMFProtocol;
var ref$5 = __webpack_require__(79);
var SMFSMPMessageType = ref$5.SMFSMPMessageType;
var ref$6 = __webpack_require__(130);
var SMFSMPMessageTypeFlags = ref$6.SMFSMPMessageTypeFlags;

/**
 * Represents an SMP request or reply message
 * @memberof solace
 * @private
 */
var SMPMessage = (function (BaseMessage) {
  function SMPMessage() {
    BaseMessage.call(this, new SMFHeader(SMFProtocol.SMP, 1));

    // Field: msgtype
    this.msgType = 0;

    // Field: subscription string
    this.encodedUtf8Subscription = null;

    this.smpFlags = (0 | SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC); // default flags

    this._encodedQueueName = null; // unused in solclientjs
    this._encodedClientName = null; // unused in solclientjs
  }

  if ( BaseMessage ) SMPMessage.__proto__ = BaseMessage;
  SMPMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  SMPMessage.prototype.constructor = SMPMessage;

  SMPMessage.prototype.isFlag = function isFlag (flagMask) {
    return (this.smpFlags & flagMask);
  };

  SMPMessage.prototype.setFlag = function setFlag (flagMask, value) {
    if (value) {
      this.smpFlags |= flagMask;
    } else {
      this.smpFlags &= (~flagMask);
    }
  };

  SMPMessage.getSubscriptionMessage = function getSubscriptionMessage (correlationTag, topic, add, requestConfirm) {
    assert(topic instanceof Destination, 'Topics are not UCS-2 strings. Pass a Topic object.');
    var smp = new SMPMessage();
    smp.msgType = add
      ? SMFSMPMessageType.ADDSUBSCRIPTION
      : SMFSMPMessageType.REMSUBSCRIPTION;
    smp.encodedUtf8Subscription = topic.getBytes();
    assert(smp.encodedUtf8Subscription, 'Topic had no encoding');
    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
    if (requestConfirm) {
      smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
    }

    // Always put a correlation tag
    smp._smfHeader.pm_corrtag = correlationTag;
    return smp;
  };

  return SMPMessage;
}(BaseMessage));


module.exports.SMPMessage = SMPMessage;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;

/**
 * @classdesc
 * Transport SMF Message
 * @memberof solace
 * @private
 */
var TransportSMFMessage = (function (BaseMessage) {
  function TransportSMFMessage() {
    BaseMessage.call(this, null, null);
    this.uh = 0;
    this.messageType = null;
    this.sessionId = null;
    this.routerTag = null;
    this.payload = null;
    this.payloadLength = 0;
    this.tsHeaderLength = 0;
  }

  if ( BaseMessage ) TransportSMFMessage.__proto__ = BaseMessage;
  TransportSMFMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  TransportSMFMessage.prototype.constructor = TransportSMFMessage;

  return TransportSMFMessage;
}(BaseMessage));

module.exports.TransportSMFMessage = TransportSMFMessage;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var CacheGetResultCode = {
  INVALID: 0,
  OK:      1,
};

module.exports.CacheGetResultCode = Enum.new(CacheGetResultCode);


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(229);
var CacheGetResultCode = ref.CacheGetResultCode;

var DEFAULTS = {
  messageID:         null,
  version:           0,
  responseCode:      CacheGetResultCode.INVALID,
  responseString:    '',
  matchTopic:        '',
  sessionID:         null,
  isSuspect:         null,
  hasMore:           null,
  hasTimestamps:     null,
  replyTo:           null,
  messageStream:     null,
  clusterNameStream: null,
};

/**
 * @classdesc CacheGetResult encapsulates the result of a cache get request
 * @private
 */
var CacheGetResult = function CacheGetResult(options) {
  if ( options === void 0 ) options = DEFAULTS;

  Object.assign(this, options);
};

CacheGetResult.prototype.readFromStream = function readFromStream (stream) {
  this.messageID = stream.getNext().getValue();
  this.version = stream.getNext().getValue();
  this.responseCode = stream.getNext().getValue();
  this.responseString = stream.getNext().getValue();
  // SD claims instanceName is present here but empirically, it's not

  this.matchTopic = stream.getNext().getValue();
  this.sessionID = stream.getNext().getValue();
  this.isSuspect = stream.getNext().getValue();
  this.hasMore = stream.getNext().getValue();

  this.hasTimestamps = stream.getNext().getValue();

  if (stream.hasNext()) { // first stream
    this.messageStream = stream.getNext().getValue();
  }
  if (stream.hasNext()) { // if two streams, first was cluster name stream
    this.clusterNameStream = this.messageStream;
    this.messageStream = stream.getNext().getValue();
  }
};

module.exports.CacheGetResult = CacheGetResult;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var CacheRequestType = {
  INVALID:                       0,
  BULK_MSG:                      1,
  REGISTER_REQUEST:              2,
  REGISTER_RESPONSE:             3,
  HEARTBEAT_REQUEST:             4,
  HEARTBEAT_RESPONSE:            5,
  EVENT_NOTIFY:                  6,
  EVENT_ACK:                     7,
  ACTION_REQUEST:                8,
  ACTION_RESPONSE:               9,
  GET_REQUEST:                   10,
  GET_RESPONSE:                  11,
  GET_NEXT_REQUEST:              12,
  GET_NEXT_RESPONSE:             13,
  SET_REQUEST:                   14,
  SET_RESPONSE:                  15,
  GET_MSG_REQUEST:               16,
  GET_MSG_RESPONSE:              17,
  GET_NEXT_MSG_REQUEST:          18,
  GET_NEXT_MSG_RESPONSE:         19,
  UNREGISTER_IND:                20,
  BULK_SET_REQUEST:              21,
  BULK_SET_RESPONSE:             22,
  PURGE_MSG_SEQUENCE_REQUEST:    23,
  PURGE_MSG_SEQUENCE_RESPONSE:   24,
  GET_MSG_SEQUENCE_REQUEST:      25,
  GET_NEXT_MSG_SEQUENCE_REQUEST: 26,
  GET_TOPIC_INFO_REQUEST:        27,
  GET_TOPIC_INFO_RESPONSE:       28,
  READY_MARKER:                  29,
  GET_TOPIC_INFO_REQUEST_RANGE:  30,
  SYNC_READY_MARKER:             31,
  VACUUM_REQUEST:                32,
  VACUUM_RESPONSE:               33,
};

module.exports.CacheRequestType = Enum.new(CacheRequestType);


/***/ }),
/* 232 */
/***/ (function(module, exports) {

/**
 * A tuple associating subscriptions, correlation IDs and cache sessions.
 * @param {String} correlationID The correlation ID for this tuple
 * @param {Topic} topic The topic for this tuple
 * @param {CacheSession} cacheSession The cache session for this tuple
 * @private
 */
var CacheSessionSubscribeInfo = function CacheSessionSubscribeInfo(correlationID, topic, cacheSession) {
  Object.assign(this, {
    correlationID: correlationID,
    topic: topic,
    cacheSession: cacheSession,
  });
};

module.exports.CacheSessionSubscribeInfo = CacheSessionSubscribeInfo;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var SessionLib = __webpack_require__(21);
var SMFLib = __webpack_require__(8);
var StatType = __webpack_require__(19);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var LOG_WARN = ref$1.LOG_WARN;
var ref$2 = __webpack_require__(10);
var SDTField = ref$2.SDTField;
var SDTFieldType = ref$2.SDTFieldType;
var SDTStreamContainer = ref$2.SDTStreamContainer;
var ref$3 = __webpack_require__(132);
var CacheCBInfo = ref$3.CacheCBInfo;
var ref$4 = __webpack_require__(81);
var CacheContext = ref$4.CacheContext;
var ref$5 = __webpack_require__(230);
var CacheGetResult = ref$5.CacheGetResult;
var ref$6 = __webpack_require__(133);
var CacheLiveDataAction = ref$6.CacheLiveDataAction;
var ref$7 = __webpack_require__(135);
var CacheRequest = ref$7.CacheRequest;
var ref$8 = __webpack_require__(134);
var CacheRequestResult = ref$8.CacheRequestResult;
var ref$9 = __webpack_require__(231);
var CacheRequestType = ref$9.CacheRequestType;
var ref$10 = __webpack_require__(136);
var CacheReturnCode = ref$10.CacheReturnCode;
var ref$11 = __webpack_require__(137);
var CacheReturnSubcode = ref$11.CacheReturnSubcode;
var ref$12 = __webpack_require__(138);
var CacheSessionProperties = ref$12.CacheSessionProperties;
var ref$13 = __webpack_require__(232);
var CacheSessionSubscribeInfo = ref$13.CacheSessionSubscribeInfo;
var ref$14 = __webpack_require__(5);
var Destination = ref$14.Destination;
var Topic = ref$14.Topic;

var CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;

var noOp = function () { return undefined; };

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.Session#createCacheSession}</b>
 * <p>
 * A session for performing cache requests.
 *
 * Applications must use {@link solace.Session#createCacheSession} to construct this class.
 *
 * The supplied {@link solace.CacheSessionProperties} will be copied. Subsequent modifications
 * to the passed properties will not modify the session. The properties may be reused.
 *
 * @memberof solace
 */
var CacheSession = function CacheSession(props, session, privateInterface) {
  CacheSession._validateProps(props);
  var properties = new CacheSessionProperties(props.cacheName,
                                                props.maxAgeSec,
                                                props.maxMessages,
                                                props.timeoutMsec);
  Object.assign(this,
                {
                  _outstandingRequests:        {},
                  _outstandingIDs:             {},
                  _disposed:                   false,
                  _nextMessageCallbackInfo:    null,
                  _nextSessionEventCallbackInfo: null,
                  _properties:                 properties,
                  _session:                    session,
                  _sessionIF:                  privateInterface,
                });
  this._connectToSession(session);
};

/**
 * @param {solace.Session} session The session to connect
 * @private
 */
CacheSession.prototype._connectToSession = function _connectToSession (session) {
    var this$1 = this;

  this._nextSessionEventCallbackInfo = session.getEventCBInfo();
  this._nextMessageCallbackInfo = session.getMessageCBInfo();
  session.setMessageCBInfo(new SessionLib.MessageRxCBInfo(function (_, message) {
    this$1._handleMessage(message);
  }, this));
  session.setEventCBInfo(this._createCompoundEventCB(this._nextSessionEventCallbackInfo));
};

/**
 * Takes the session's existing event callback and sets it as the next delegate in a
 * chain of responsibility. The next delegate could be the client application, or another
 * cache session.
 * @param {SessionEventCBInfo} nextDelegate The next event receiver in the chain
 * @returns {SessionEventCBInfo} An event receiver that delegates to the supplied receiver
 * @private
 */
CacheSession.prototype._createCompoundEventCB = function _createCompoundEventCB (nextDelegate) {
    var this$1 = this;

  return new SessionLib.SessionEventCBInfo(function (session, sessionEvent, userObject, rfuObject) {
    this$1._handleSessionEvent(nextDelegate, session, sessionEvent, userObject, rfuObject);
  }, null);
};

/**
 * Modified chain of responsibility. Handles the event, then passes the event to the next
 * delegate.
 * @param {SessionEventCBInfo} nextDelegate The next delegate to notify
 * @param {solace.Session} session The associated session
 * @param {SessionEvent} sessionEvent The session event to dispatch
 * @private
 */
CacheSession.prototype._handleSessionEvent = function _handleSessionEvent (nextDelegate, session, sessionEvent /*, userObject, rfuObject */) {
  var passEvent = this._processSessionEvent(session, sessionEvent);
  if (!passEvent) {
    return;
  }
  var cbUserObject = nextDelegate.userObject;
  if (!cbUserObject) {
    nextDelegate.sessionEventCBFunction(session, sessionEvent);
  } else {
    nextDelegate.sessionEventCBFunction(session, sessionEvent, cbUserObject);
  }
};

/**
 * @param {Message} message The message to forward
 * @private
 */
CacheSession.prototype._sendToNextDelegate = function _sendToNextDelegate (message) {
  var cbUserObject = this._nextMessageCallbackInfo.userObject;
  if (!cbUserObject) {
    this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message);
  } else {
    this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message, cbUserObject);
  }
};

/**
 * @param {solace.Session} session The associated session
 * @param {SessionEvent} event The event to process
 * @returns {Boolean} true if event should pass to next delegate
 * @private
 */
CacheSession.prototype._processSessionEvent = function _processSessionEvent (session, event) {
  switch (event.sessionEventCode) {
    case SessionLib.SessionEventCode.SUBSCRIPTION_ERROR:
    case SessionLib.SessionEventCode.SUBSCRIPTION_OK:
      return this._checkSubscriptionStatus(event);
    case SessionLib.SessionEventCode.DOWN_ERROR:
      this.dispose();
      return true;
    default:
      LOG_TRACE(("Unhandled session event: " + (event.sessionEventCode)));
      return true;
  }
};

/**
 * @param {SessionEvent} event The event to check
 * @returns {Boolean} `true` if event should pass to next delegate
 * @private
 */
CacheSession.prototype._checkSubscriptionStatus = function _checkSubscriptionStatus (event) {
  // Incremental checks for whether this is our subscription.
  if ((event.correlationKey === null || event.correlationKey === undefined) ||
      (!(event.correlationKey instanceof CacheSessionSubscribeInfo)) ||
      (event.correlationKey.cacheSession !== this)) {
    return true;
  }
  var request = this._getOutstandingRequest(event.correlationKey.correlationID);
  if (!request) {
    LOG_WARN(("No request found for subscription success on " + (event.correlationKey.topic)));
    return true;
  }
  if (event.sessionEventCode === SessionLib.SessionEventCode.SUBSCRIPTION_OK) {
    this._handleSubscriptionSuccess(request, event.correlationKey.topic);
    return false;
  }
  this._handleSubscriptionError(request, event);
  return false;
};

/**
 * @param {CacheRequest} requestIn The cache on which to register success
 * @param {Topic} topic The topic on which to issue the request.
 * @private
 */
CacheSession.prototype._handleSubscriptionSuccess = function _handleSubscriptionSuccess (requestIn /*, topic */) {
  // Null out this field and check completion status.
  var request = requestIn;
  request.subscriptionWaiting = null;
  this._startCacheRequest(request);
};

/**
 * @param {CacheRequest} request The cache request on which to register failure
 * @private
 */
CacheSession.prototype._handleSubscriptionError = function _handleSubscriptionError (request/*, event */) {
  this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.SUBSCRIPTION_ERROR);
};

/**
 * @param {CacheRequest} request The cache request on which to check completion
 * @private
 */
CacheSession.prototype._checkRequestCompletion = function _checkRequestCompletion (request) {
  if (request.childRequests.length) {
    // Not finished with spawned child requests.
    LOG_DEBUG(("Awaiting termination of " + (request.childRequests.length) + " children"));
    return;
  }
  if (request.subscriptionWaiting) {
    // Waiting for confirmation of subscription to a topic.
    LOG_DEBUG('Awaiting subscription');
    return;
  }
  if (request.timeoutHandle !== null && (!request.replyReceived)) {
    LOG_DEBUG('Awaiting timeout');
    return;
  }
  if (request.parentRequest) {
    // We're no longer waiting for a child to complete.
    var parent = request.parentRequest;
    request.cancel();
    this._unregisterRequest(request);
    this._checkRequestCompletion(parent);
    return;
  }

  // This is a parent request and it is done.
  var code;
  var subcode;
  if (request.isSuspect) {
    code = CacheReturnCode.INCOMPLETE;
    subcode = CacheReturnSubcode.SUSPECT_DATA;
  } else if (request.dataReceived) {
    code = CacheReturnCode.OK;
    if (request.liveDataFulfilled) {
      subcode = CacheReturnSubcode.LIVE_DATA_FULFILL;
    } else {
      subcode = CacheReturnSubcode.REQUEST_COMPLETE;
    }
  } else if (request.replyReceived) {
    code = CacheReturnCode.INCOMPLETE;
    subcode = CacheReturnSubcode.NO_DATA;
  } else {
    throw new Error('Sanity: should never happen');
  }
  this._terminateRequest(request, code, subcode);
};

/**
 * @param {CacheRequest} parentRequest The parent node for the new request
 * @param {CacheGetResult} cacheGetResult The result of this request
 * @private
 */
CacheSession.prototype._sendSeeOther = function _sendSeeOther (parentRequest, cacheGetResult) {
  var clusterName = cacheGetResult.clusterNameStream.getNext().getValue();
  // var root = parentRequest.getRootRequest();
  LOG_DEBUG(("See Other for " + clusterName + ". Sending child request"));
  var childRequest = new CacheRequest(this,
                                        CacheRequestType.GET_MSG_REQUEST,
                                        parentRequest.requestID,
                                        new CacheCBInfo(noOp, null),
                                        parentRequest.liveDataAction,
                                        parentRequest.topic,
                                        clusterName);
  // Add this request to its parent
  parentRequest.addChild(childRequest);
  // Start the request
  this._registerRequest(childRequest);
  childRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                                   this._properties.timeoutMsec);
  this._startCacheRequest(childRequest, // request to send
                          null, // no session ID
                          null, // no specific instance target
                          true); // don't return other clusters
};

/**
 * @param {CacheRequest} parentRequest The parent node for the new request
 * @param {CacheGetResult} cacheGetResult The result of this request
 * @private
 */
CacheSession.prototype._sendGetNext = function _sendGetNext (parentRequest, cacheGetResult) {
  LOG_DEBUG('Cache result has more, sending GET_NEXT_MSG_REQUEST as child');
  var nextRequest = new CacheRequest(this,
                                       CacheRequestType.GET_NEXT_MSG_REQUEST,
                                       parentRequest.requestID,
                                       new CacheCBInfo(noOp, null),
                                       parentRequest.liveDataAction,
                                       parentRequest.topic,
                                       parentRequest.cacheName);
  // Set up parent-child relationship
  parentRequest.addChild(nextRequest);
  // Start the request
  this._registerRequest(nextRequest);
  nextRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                                  this._properties.timeoutMsec);
  this._startCacheRequest(nextRequest, // request to send
                          cacheGetResult.sessionID, // supplied session ID
                          cacheGetResult.replyTo); // supplied cache instance target
};

/**
 * @param {Message} message The message to inspect and handle
 * @private
 */
CacheSession.prototype._handleMessage = function _handleMessage (message) {
    var this$1 = this;

  // Determine if the message is associated with one of this session's requests
  var correlationID = message.getCorrelationId();
  var request = correlationID === null || correlationID === undefined
    ? null
    : this._outstandingRequests[correlationID];

  // This could be live data on a relevant topic.Check that.
  if (!request) {
    if (this._relevantLiveData(message)) {
      this._sendToNextDelegate(message);
    }
    return;
  }

  // It's ours!
  LOG_DEBUG(("Processing reply to " + request));
  // bug 36404: We have a response. Cancel the timeout for this request.
  request.clearRequestTimeout();
  var streamField = message.getSdtContainer();
  var stream = streamField && streamField.getValue();
  if (!stream) {
    LOG_INFO(
      ("Invalid message format for cache response: no SDT container (" + streamField + ") or stream (" + stream + ")"));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
  }
  // The session will never see this reply, so we need to update the stats
  // from here.
  this._incStat(StatType.RX_REPLY_MSG_RECVED);
  request.replyReceived = true;

  // If the request was fulfilled by live data, discard the reply and stop processing
  // the response.
  if (request.getRootRequest().liveDataFulfilled) {
    this._incStat(StatType.CACHE_REQUEST_FULFILL_DISCARD_RESPONSE);
    this._checkRequestCompletion(request);
    return;
  }

  if (!stream) {
    LOG_INFO('Invalid cache response did not fulfill request. Skipping response processing');
    return;
  }

  try {
    // Fill the result object with values from the result stream.
    var result = new CacheGetResult();
    result.readFromStream(stream);
    result.replyTo = message.getReplyTo();
    if (result.responseString) {
      LOG_DEBUG(("Cluster response: " + (result.responseString)));
    }
    // Apply the isSuspect flag. Don't clear it if the result is already suspect.
    request.isSuspect = request.isSuspect || result.isSuspect;
    // Get any inner messages.
    var messages = CacheSession._decodeMessageStream(request, result);
    // Update statistics.
    this._incStat(StatType.RX_CACHE_MSG, messages.length);
    // If we have more results to come, send a get next request.
    if (result.hasMore) {
      this._sendGetNext(request, result);
    }
    // If we have more clusters to visit, send requests to those clusters.
    if (result.clusterNameStream) {
      LOG_DEBUG('Receiving cluster stream');
      while (result.clusterNameStream.hasNext()) {
        this$1._sendSeeOther(request, result);
      }
    }
    // Forward any retrieved messages.
    if (messages) {
      messages.forEach(function (m) {
        this$1._sendToNextDelegate(m);
      });
    }
    this._checkRequestCompletion(request);
  } catch (exception) {
    LOG_INFO(("Invalid message format for cache response: " + (exception.stack)));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
  }
};

/**
 * @param {Message} message The message to inspect and handle
 * @returns {Boolean} `true` if the next delegate should handle this message
 * @private
 */
CacheSession.prototype._relevantLiveData = function _relevantLiveData (message) {
    var this$1 = this;

  // If the next message processor does not belong to a cache
  // session, and this is a CRQ message, suppress it.
  if (message.getCorrelationId() &&
      message.getCorrelationId().startsWith(CACHE_REQUEST_PREFIX) &&
      !(this._nextMessageCallbackInfo.userObject instanceof CacheSession)) {
    LOG_WARN('DROP: Dropping CRQ reply due to no remaining Cache Session processors on message ' +
             'callback chain');
    this._incStat(StatType.RX_REPLY_MSG_DISCARD);
    return false;
  }
  // Otherwise, assume the message should flow through.
  // If all _performLiveDataAction calls return true, we return true;
  return Object.keys(this._outstandingRequests).every(function (checkCID) { return this$1._performLiveDataAction(this$1._outstandingRequests[checkCID], message); });
};

/**
 * @param {CacheRequest} requestIn The cache request for which to perform the action
 * @param {Message} message The message to process on the request
 * @returns {Boolean} true if message should flow through after action.
 * @private
 */
CacheSession.prototype._performLiveDataAction = function _performLiveDataAction (requestIn, message) {
  var request = requestIn;
  request.dataReceived = true;
  switch (request.liveDataAction) {
    case CacheLiveDataAction.QUEUE:
      request.queuedLiveData.push(message);
      return false;

    case CacheLiveDataAction.FULFILL:
      if (!request.liveDataFulfilled) {
        this._fulfillRequest(request);
      }
      return true;

    default:
      return true;
  }
};

/**
 * @param {CacheRequest} requestIn The request to fulfill
 * @private
 */
CacheSession.prototype._fulfillRequest = function _fulfillRequest (requestIn) {
  var request = requestIn;
  request.liveDataFulfilled = true;
  this._trackCompletionStats(CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL);
  // We have more work to do here -- we need to return the live data first.
  // Schedule the notification for later.
  setTimeout(function () {
    CacheSession._notifyCallback(request,
                                 CacheReturnCode.OK,
                                 CacheReturnSubcode.LIVE_DATA_FULFILL,
                                 request.getTopic(),
                                 null);
  }, 0);
};

/**
 * Disposes the session.No cache requests will be sent by this CacheSession after it is
 * _disposed.
 *
 * Any subsequent operations on the session will throw {OperationError}.
 *
 * Any pending operations will immediately terminate, returning
 * * {@link solace.CacheRequestResult}
 *   * #returnCode === {@link solace.CacheReturnCode.INCOMPLETE}
 *   * #subcode === {@link solace.CacheReturnSubcode.CACHE_SESSION_DISPOSED}
 * @throws {solace.OperationError} if the CacheSession is already _disposed.
 */
CacheSession.prototype.dispose = function dispose () {
    var this$1 = this;

  var toTerminate = Object.keys(this._outstandingRequests)
    .map(function (correlationID) { return this$1._outstandingRequests[correlationID]; })
    .filter(function (request) { return request instanceof CacheRequest; });
  toTerminate.forEach(function (request) {
    this$1._terminateRequest(request,
                           CacheReturnCode.INCOMPLETE,
                           CacheReturnSubcode.CACHE_SESSION_DISPOSED);
  });
  this._outstandingRequests = [];
  // Restore original listeners
  this._session.setEventCBInfo(this._nextSessionEventCallbackInfo);
  this._session.setMessageCBInfo(this._nextMessageCallbackInfo);
  // Set _disposed
  this._disposed = true;
};

/**
 * Gets the cache session properties.
 *
 * @returns {solace.CacheSessionProperties} The properties for the session.
 * @throws {solace.OperationError} if the CacheSession is disposed.
 */
CacheSession.prototype.getProperties = function getProperties () {
  return this._properties;
};

/**
 * Issues an asynchronous cache request. The result of the request will be returned via the
 * listener. Messages returned as a result of issuing the request will be returned to the
 * application via the {@link solace.MessageRxCBInfo} associated with this
 * {@link solace.CacheSession}'s {@link solace.Session}
 *
 * @param {Number} requestID The application-assigned ID number for the request.
 * @param {solace.Destination} topic The topic destination for which the cache request will be
 *  made.
 * @param {Boolean} subscribe If true, the session will subscribe to the given {Topic}, if it is
 * not already subscribed, before performing the cache request.
 * @param {solace.CacheLiveDataAction} liveDataAction The action to perform when the
 *  {@link solace.CacheSession} receives live data on the given topic.
 * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
 *
 * @throws {solace.OperationError} In the following cases:
 * * If the CacheSession is disposed.
 *  Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
 * * If one or more parameters were invalid.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}
 * * If the supplied topic and live data action cannot be combined.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 * * If the supplied topic or live data action cannot be used given the current outstanding
 *  requests.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 */
CacheSession.prototype.sendCacheRequest = function sendCacheRequest (requestID, topic, subscribe, liveDataAction, cbInfo) {
    var this$1 = this;

  if (arguments.length !== 5) {
    throw new OperationError(("sendCacheRequest() invoked with an illegal argument count of " + (arguments.length)));
  }
  if (typeof subscribe !== 'boolean') {
    throw new OperationError(
      ("Invalid subscribe flag argument, should be a boolean but was " + (typeof subscribe)));
  }
  if (typeof requestID !== 'number' || Number.isNaN(requestID)) {
    throw new OperationError('Invalid requestID', ErrorSubcode.PARAMETER_INVALID_TYPE, null);
  }
  if (this._outstandingIDs[requestID]) {
    throw new OperationError('Request already in progress with this requestID');
  }
  if (!(topic instanceof Destination)) {
    throw new OperationError('Invalid topic', ErrorSubcode.PARAMETER_INVALID_TYPE, (typeof topic));
  }
  topic.validate();
  if (!(liveDataAction === CacheLiveDataAction.FLOW_THRU || liveDataAction ===
      CacheLiveDataAction.FULFILL || liveDataAction === CacheLiveDataAction.QUEUE)) {
    throw new OperationError('Invalid live data action', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if (topic.isWildcarded() && liveDataAction !== CacheLiveDataAction.FLOW_THRU) {
    throw new OperationError('Wildcarded topic not supported for this live data action',
      ErrorSubcode.PARAMETER_CONFLICT);
  }
  if (!(cbInfo instanceof CacheCBInfo)) {
    throw new OperationError('Callback info was not an instance of CacheCBInfo');
  }
  if (this._disposed) {
    CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL,
                                      CacheReturnSubcode.CACHE_SESSION_DISPOSED, topic,
                                      'Cache request failed: the cache session is disposed.');
    return;
  }
  if (this._session._disposed) {
    CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL,
                                      CacheReturnSubcode.INVALID_SESSION, topic,
                                      'Cache request failed: the session is disposed.');
    return;
  }

  var request = new CacheRequest(this,
    CacheRequestType.GET_MSG_REQUEST,
    requestID,
    cbInfo,
    liveDataAction,
    topic,
    this._properties.cacheName);

  var matchingRequestKeys = Object.keys(this._outstandingRequests).filter(function (key) { return this$1._outstandingRequests[key].topic.getName() === topic.getName(); });

  if (matchingRequestKeys.length) {
    // Topic name matches mean a conflict unless both requests are FLOW_THRU
    var conflictKeys = (
      liveDataAction !== CacheLiveDataAction.FLOW_THRU
        ? matchingRequestKeys
        : matchingRequestKeys.filter(function (k) { return this$1._outstandingRequests[k].liveDataAction !== CacheLiveDataAction.FLOW_THRU; }));
    if (conflictKeys.length) {
      var conflictRequest = this._outstandingRequests[conflictKeys[0]];
      LOG_WARN(("Existing request " + conflictRequest + " conflicts. Rejecting request " + request));
       // Register this request so that it is not dismissed as an orphan.
      this._registerRequest(request);
      this._terminateRequest(request,
                             CacheReturnCode.FAIL,
                             CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS);
      return;
    }
  }

  this._registerRequest(request);
  request.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                              this._properties.timeoutMsec);
  if (subscribe) {
    var waitingForSubscribeInfo = new CacheSessionSubscribeInfo(request.correlationID, topic,
      this);
    request._subscriptionWaiting = waitingForSubscribeInfo;
    this._session.subscribe(topic, true, waitingForSubscribeInfo);
    return;
  }
  this._startCacheRequest(request);
};

/**
 * @param {solace.Session} session The session associated with the request
 * @param {SessionEvent} sessionEvent The session event
 * @param {CacheRequest} userObject The user-specified context object
 * @private
 */
CacheSession.prototype._handleCacheRequestFailed = function _handleCacheRequestFailed (session, sessionEvent, userObject /*, rfuObject */) {
  this._terminateRequest(userObject.getRequestID(),
                         CacheReturnCode.FAIL,
                         CacheReturnSubcode.ERROR_RESPONSE);
};

/**
 * @param {CacheRequest} request The new request to register
 * @private
 */
CacheSession.prototype._registerRequest = function _registerRequest (request) {
  this._outstandingRequests[request.correlationID] = request;
  if (!request.parentRequest) {
    this._outstandingIDs[request.requestID] = request;
  }
};

/**
 * @param {Number} correlationID The ID of an existing request
 * @returns {CacheRequest} The existing request with the given ID
 * @private
 */
CacheSession.prototype._getOutstandingRequest = function _getOutstandingRequest (correlationID) {
  return this._outstandingRequests[correlationID];
};

/**
 *
 * @param {CacheRequest} request The request to start
 * @param {?Number} sessionID Only when returned from a cache instance as part of a
 * previous message
 * @param {?Topic} destination Only when required by a cache reply
 * @param {?Boolean} suppressClusters True when other clusters should be excluded from
 * the response, as in a request resulting from a "see other"
 * @private
 */
CacheSession.prototype._startCacheRequest = function _startCacheRequest (request, sessionID, destination, suppressClusters) {
  var message = new MessageLib.Message();

  // Prepare message
  message.setCorrelationId(request.correlationID);
  if (destination) {
    message.setDestination(destination);
  } else {
    message.setDestination(
      Topic.createFromName(this._properties.cachePrefix + request.cacheName));
  }
  message.setReplyTo(Topic.createFromName(this._session.getSessionProperties().p2pInboxInUse));
  message.setDeliverToOne(request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST);

  // Prepare stream container
  var stream = new SDTStreamContainer();
  stream.addField(SDTFieldType.UINT32, request.cacheMessageType);
  stream.addField(SDTFieldType.UINT32, CacheRequest.VERSION);
  stream.addField(SDTFieldType.STRING, request.topic.getName());
  stream.addField(SDTFieldType.UINT32, CacheRequest.REPLY_SIZE_LIMIT);

  if (typeof sessionID === 'number') {
    LOG_DEBUG(("Including session ID: " + sessionID));
    stream.addField(SDTFieldType.UINT32, sessionID);
  }

  stream.addField(SDTFieldType.UINT32, this._properties.maxMessages);
  stream.addField(SDTFieldType.UINT32, this._properties.maxAgeSec);
  if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
    stream.addField(SDTFieldType.BOOL,
                    this._properties.includeOtherClusters && (!suppressClusters));
  }

  stream.addField(SDTFieldType.BOOL, false); // includeTimestamps, 6.17.1
  if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
    stream.addField(SDTFieldType.UINT32, Math.round(this._properties.timeoutMsec / 1000));
  }

  // Load stream container
  message.setSdtContainer(SDTField.create(SDTFieldType.STREAM, stream));
  try {
    LOG_DEBUG(("Sending " + request));
    this._session.send(message);

    if (!request.parentRequest) { // Don't count child requests in CACHE_REQUEST_SENT total
      this._incStat(StatType.CACHE_REQUEST_SENT);
    }
  } catch (e) {
    LOG_INFO(("Failed to send request: " + (e.message)));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE, e);
  }
};

/**
 * Increments a stat.
 * @param{String} statType The stat to increment
 * @param{Number} value  The amount by which to increment the state
 * @private
 */
CacheSession.prototype._incStat = function _incStat (statType, value) {
  if (!this._session) {
    LOG_DEBUG("Can't log stat: session is disposed");
    return;
  }
  if (!this._sessionIF) {
    LOG_INFO("Can't log stat: session statistics not available");
    return;
  }
  this._sessionIF.incStat(statType, value);
};

/**
 * Unregisters the given request.
 * @param{CacheRequest} request The request to unreguster
 * @private
 */
CacheSession.prototype._unregisterRequest = function _unregisterRequest (request) {
  delete this._outstandingRequests[request.correlationID];
  delete this._outstandingIDs[request.requestID];
};

/**
 * @param {CacheReturnCode} returnCode The return code for this completion
 * @param {CacheReturnSubcode} subcode The subcode for this completion
 * @private
 */
CacheSession.prototype._trackCompletionStats = function _trackCompletionStats (returnCode, subcode) {
  switch (returnCode) {
    case CacheReturnCode.OK:
      this._incStat(StatType.CACHE_REQUEST_OK_RESPONSE);
      if (subcode === CacheReturnSubcode.LIVE_DATA_FULFILL) {
        this._incStat(StatType.CACHE_REQUEST_LIVE_DATA_FULFILL);
      }
      break;
    case CacheReturnCode.INCOMPLETE:
      this._incStat(StatType.CACHE_REQUEST_INCOMPLETE_RESPONSE);
      break;
    case CacheReturnCode.FAIL:
      this._incStat(StatType.CACHE_REQUEST_FAIL_RESPONSE);
      break;
    default:
      throw new Error('Sanity: no return code supplied');
  }
};

/**
 * @param {CacheRequest} requestIn The request to terminate
 * @param {CacheReturnCode} returnCode The return code for this operation
 * @param {CacheReturnSubcode} subcode The subcode for this operation
 * @param {Error} error Any error associated with this operation
 * @private
 */
CacheSession.prototype._terminateRequest = function _terminateRequest (requestIn, returnCode, subcode, error) {
    var this$1 = this;

  var request = requestIn.getRootRequest();
  if (!this._outstandingRequests[request.correlationID]) {
    // Request is unknown or was previously terminated
    return;
  }
  var cbInfo = request.cbInfo;
  if (!cbInfo) {
    LOG_WARN(("No callback info provided for " + request + ". Cannot notify"));
    return; // Cannot continue
  }
  var callback = cbInfo.getCallback();
  if (!callback) {
    LOG_WARN(("No callback provided for " + request + ". Cannot notify"));
    return; // Cannot continue
  }
  var topic = request.getTopic();
  if (!topic) {
    LOG_WARN(("No topic provided for " + request));
  }
  request.queuedLiveData.forEach(function (data) { return this$1._sendToNextDelegate(data); });

  // Unregister before callback so that the client application can treat the request ID
  // as "freed" and reuse it
  request.cancel();
  this._unregisterRequest(request);

  if (!request.liveDataFulfilled) {
    // All of this has already been done on fulfill.
    this._trackCompletionStats(returnCode, subcode);
    CacheSession._notifyCallback(request, returnCode, subcode, topic, error);
  }
};

/**
 * @param {CacheRequest} requestIn The request with a result to decode
 * @param {CacheGetResult} result The result to decode
 * @returns {Array.<Message>} The messages contained in the result
 * @private
 */
CacheSession._decodeMessageStream = function _decodeMessageStream (requestIn, result) {
  if (!result.messageStream) {
    return [];
  }

  LOG_DEBUG('Receiving messages');
  var messages = [];
  var request = requestIn;
  while (result.messageStream.hasNext()) {
    request.dataReceived = true;
    var data = result.messageStream.getNext().getValue();
    var innerMessage = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
    if (!innerMessage) {
      continue;
    }
    var cacheStatus = result.isSuspect
      ? MessageLib.MessageCacheStatus.SUSPECT
      : MessageLib.MessageCacheStatus.CACHED;
    innerMessage._setCacheStatus(cacheStatus);
    innerMessage._setCacheRequestID(request.requestID);
    messages.push(innerMessage);
  }
  LOG_DEBUG(((messages.length) + " cached messages received"));
  return messages;
};

/**
 * Closure call context; `this` will be redefined
 * @param {CacheRequest} cacheRequest The request that timed out
 * @private
 */
CacheSession._handleCacheRequestTimeout = function _handleCacheRequestTimeout (cacheRequest) {
  var context = cacheRequest.cacheSession;
  if (!context._getOutstandingRequest(cacheRequest.correlationID)) {
    LOG_INFO(("Timeout for " + cacheRequest + " was not unregistered. Ignoring"));
    // already completed
    return;
  }

  // bug 36404: Cache request timeout is to be interpreted as timeout per session request-reply,
  // not timeout per cache request-reply.
  // Implementation: Timeouts on parent requests are cancelled when a child request is spawned.
  // Timeouts on child requests cause the root request to fail.
  LOG_INFO(("Request " + cacheRequest + " timed out"));
  context._terminateRequest(cacheRequest.getRootRequest(), CacheReturnCode.INCOMPLETE,
                            CacheReturnSubcode.REQUEST_TIMEOUT);
};


/**
 * @param {CacheRequest} request The request that is notifying
 * @param {CacheReturnCode} returnCode The return code for the notification
 * @param {CacheReturnSubcode} subcode The subcode for the notification
 * @param {Destination} topic The topic associated with the notification
 * @param {Error} error Any error associated with the notification
 * @private
 */
CacheSession._notifyCallback = function _notifyCallback (request, returnCode, subcode, topic, error) {
  var cbInfo = request.cbInfo;
  var callback = cbInfo.getCallback();
  callback(request.requestID,
           new CacheRequestResult(returnCode, subcode, topic, error),
           cbInfo.getUserObject());
};

/**
 * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
 * @param {Number} requestID The application-assigned ID number for the request
 * @param {CacheReturnCode} returnCode The return code for the notification
 * @param {CacheReturnSubcode} subcode The subcode for the notification
 * @param {Destination} topic The topic associated with the notification
 * @param {Error} error Any error associated with the notification
 * @private
 */
CacheSession._notifyCallbackError = function _notifyCallbackError (cbInfo, requestID, returnCode, subcode, topic, error) {
  var callback = cbInfo.getCallback();
  callback(requestID,
           new CacheRequestResult(returnCode, subcode, topic, error),
           cbInfo.getUserObject());
};

/**
 * Validates the cache session properties.
 * @param {solace.CacheSessionProperties} props The properties to validate
 * @private
 */
CacheSession._validateProps = function _validateProps (props) {
  if ((typeof (props.cacheName) !== 'string')) {
    throw new OperationError('Invalid parameter type for cacheName', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  // Create from name will throw if the cacheName is invalid.This performs more checking than
  // the legacy API did, but I think it is all justified as we shouldn't be able to use anything
  // that would be rejected here as a cacheName.
  if (Topic.createFromName(props.cacheName).isWildcarded()) {
    throw new OperationError(
      ("Invalid cacheName '" + (props.cacheName) + "'. The cacheName cannot be wildcarded"),
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.maxAgeSec) !== 'number')) {
    throw new OperationError('Invalid parameter type for maxAgeSec', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.maxAgeSec < 0) {
    throw new OperationError('Invalid value for maxAgeSec; must be >= 0', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.maxMessages) !== 'number')) {
    throw new OperationError('Invalid parameter type for maxMessages', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.maxMessages < 0) {
    throw new OperationError('Invalid value for maxMessages; must be >= 0', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.timeoutMsec) !== 'number')) {
    throw new OperationError('Invalid parameter type for timeoutMsec', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.timeoutMsec < 3000) {
    throw new OperationError('Invalid value for timeoutMsec; must be >= 3000', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
};

module.exports.CacheSession = CacheSession;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(82);
var StatType = ref.StatType;

module.exports = {
  StatsByMode: {
    STAT_TX_BYMODE_MSGS: [
      StatType.TX_DIRECT_MSGS,
      StatType.TX_PERSISTENT_MSGS,
      StatType.TX_NONPERSISTENT_MSGS ],
    STAT_TX_BYMODE_BYTES: [
      StatType.TX_DIRECT_BYTES,
      StatType.TX_PERSISTENT_BYTES,
      StatType.TX_NONPERSISTENT_BYTES ],
    STAT_TX_BYMODE_REDELIVERED: [
      StatType.TX_DIRECT_MSGS,     // unused placeholder, direct messsages are not redelivered
      StatType.TX_PERSISTENT_REDELIVERED,
      StatType.TX_NONPERSISTENT_REDELIVERED ],
    STAT_TX_BYMODE_BYTES_REDELIVERED: [
      StatType.TX_DIRECT_BYTES,     // unused placeholder, direct messsages are not redelivered
      StatType.TX_PERSISTENT_BYTES_REDELIVERED,
      StatType.TX_NONPERSISTENT_BYTES_REDELIVERED ],
    STAT_RX_BYMODE_MSGS: [
      StatType.RX_DIRECT_MSGS,
      StatType.RX_PERSISTENT_MSGS,
      StatType.RX_NONPERSISTENT_MSGS ],
    STAT_RX_BYMODE_BYTES: [
      StatType.RX_DIRECT_BYTES,
      StatType.RX_PERSISTENT_BYTES,
      StatType.RX_NONPERSISTENT_BYTES ],
  },
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(35);
var EventEmitter = ref.EventEmitter;
var ref$1 = __webpack_require__(82);
var StatType = ref$1.StatType;

/**
 * @private
 */
var Stats = (function (EventEmitter) {
  function Stats(parent) {
    var this$1 = this;

    EventEmitter.call(this);

    this._parent = parent;
    this._statsMap = [];
    StatType.values.forEach(function (value) {
      this$1._statsMap[value] = 0;
    });
  }

  if ( EventEmitter ) Stats.__proto__ = EventEmitter;
  Stats.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Stats.prototype.constructor = Stats;

  Stats.prototype.resetStats = function resetStats () {
    this.emit('reset');
    // The stat types are sequential, so .fill(0) would work, but the API design
    // doesn't really guarantee this so overwriting every existing index is safer.
    this._statsMap = this._statsMap.map(function () { return 0; });
  };

  Stats.prototype.incStat = function incStat (statType, value) {
    if ( value === void 0 ) value = 1;

    // should we validate statType?
    this._statsMap[statType] += value;
    if (this._parent) {
      this._parent.incStat(statType, value);
    }
  };

  Stats.prototype.getStat = function getStat (statType) {
    return this._statsMap[statType];
  };

  return Stats;
}(EventEmitter));

module.exports.Stats = Stats;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {


// eslint-disable-next-line global-require
var BufferImpl = Buffer || __webpack_require__(266).Buffer;

function newBuffer(size) {
  /* eslint-env shared-browser-node */
  if (BufferImpl.allocUnsafe) { return BufferImpl.allocUnsafe(size); }
  if (BufferImpl.alloc) { return BufferImpl.alloc(size); }
  return new BufferImpl(size);
}

/**
 * @internal
 */
var BufferDataQueue = function BufferDataQueue(maxSize) {
  var _buffer = newBuffer(maxSize);
  var _position = 0;
  var _remaining = 0;

  // Functions that directly access the buffer are declared in the constructor.
  // This removes _buffer from inspection scope and lets the class be debuggable.

  /**
   * Creates a slice (view) of the buffer with the given size. If the read
   * overlaps the end of the buffer, the buffer is compacted, invalidating
   * all previous peekViews.
   *
   * Contents of views should be copied by the caller if they are to be retained,
   * before any other buffer operation is performed.
   *
   * @param {Number} size Bytes to view
   * @returns {?Buffer} if there was enough data to peek, or `null`
   */
  this.peekView = function peekView(size) {
    if (size > _remaining) { return null; }
    if (_position + size > maxSize) { this.compact(); }
    var linearEnd = _position + size;
    return _buffer.slice(_position, linearEnd);
  };

  this.advance = function advance(size) {
    _remaining -= size;
    _position += size;
  };

  this.remaining = function remaining() {
    return _remaining;
  };

  /**
   * Puts bytes from a source buffer into the internal buffer.Compacts the buffer
   * if needed.Returns if the operation was successful.put() will fail if the
   * internal buffer (after compaction) does not have space to hold the source
   * buffer.
   *
   * This operation can invalidate previous views.
   *
   * @param {Buffer} dataIn Source data
   * @returns {Boolean} `true` if all bytes were inserted
   */
  this.put = function put(dataIn) {
    var buffer = BufferDataQueue.adaptData(dataIn);
    var size = buffer.length;

    if (_remaining + size >= maxSize) { return false; }
    if (_position + _remaining + size >= maxSize) { this.compact(); }

    buffer.copy(_buffer, _position + _remaining);
    _remaining += size;

    return true;
  };


  this.reset = function reset() {
    _position = 0;
    _remaining = 0;
  };

  /**
   * Shifts the remaining data so that it is aligned at zero.
   */
  this.compact = function compact() {
    _buffer.copy(_buffer, 0, _position, _position + _remaining);
    _position = 0;
  };
};

/**
 * Peeks a specified length and formats it as a string. This operation can invalidate
 * previous views.
 *
 * @param {Number} size The number of bytes to peek
 * @param {String} [encoding='binary'] The encoding for the string to be returned
 * @returns {?String} The decoded string
 */
BufferDataQueue.prototype.peekString = function peekString (size, encoding) {
    if ( encoding === void 0 ) encoding = 'binary';

  var target = this.peekView(size);
  return target ? target.toString(encoding) : null;
};

/**
 * Creates a slice (view) of the buffer with the given size. If the read
 * overlaps the end of the buffer, the buffer is compacted, invalidating
 * all previous peekViews. The bytes are consumed.
 *
 * Contents of views should be copied by the caller if they are to be retained,
 * before any other buffer operation is performed.
 *
 * @param {Number} size Bytes to copy
 * @returns {?Buffer} if there was enough data to peek, or `null`
 */
BufferDataQueue.prototype.getView = function getView (size) {
  var target = this.peekView(size);
  if (target) { this.advance(size); }
  return target;
};

/**
 * Gets a specified length and formats it as a string. This operation can invalidate
 * previous views.
 *
 * @param {Number} size The number of bytes to consume
 * @param {String} [encoding='binary'] The encoding for the string to be returned
 * @returns {?String} The decoded string if there was enough data to consumer, or `null`
 */
BufferDataQueue.prototype.getString = function getString (size, encoding) {
    if ( encoding === void 0 ) encoding = 'binary';

  var target = this.getView(size);
  return target ? target.toString(encoding) : null;
};

/**
 * Adapt incoming data to the format expected by this.put().
 * @param {*} data The data to adapt.
 * @returns {Buffer} The adapted data.
 */
BufferDataQueue.adaptData = function adaptData (data) {
  if (data instanceof Buffer) { return data; }
  if (data instanceof ArrayBuffer) { return new Buffer(data); }
  return Buffer.from(data);
};

module.exports.BufferDataQueue = BufferDataQueue;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;
var ref$1 = __webpack_require__(236);
var BufferDataQueue = ref$1.BufferDataQueue;
var ref$2 = __webpack_require__(3);
var Convert = ref$2.Convert;
var Hex = ref$2.Hex;
var ref$3 = __webpack_require__(1);
var LogFormatter = ref$3.LogFormatter;

var stringToUint8Array = Convert.stringToUint8Array;
var formatHexString = Hex.formatHexString;

var SMF_LOST_FRAMING_THRESHOLD = 80000000;

var ref$4 = new LogFormatter('[buffer-smf-client]');
var LOG_TRACE = ref$4.LOG_TRACE;
var LOG_ERROR = ref$4.LOG_ERROR;

// ----------------------------------------------------------------------------
// These functions properly belong in a binary SMF decoder package
// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

function makeHeaderbuffer(ringbuffer) {
  if (ringbuffer.remaining() < 12) { return null; }
  return ringbuffer.peekView(12);
}

function isHeaderbufferValid(headerbuffer) {
  var version = headerbuffer[0] & 0x7;
  if (version !== 3) {
    LOG_ERROR(("Invalid smf version in smf header, version=" + version));
    return false;
  }
  return true;
}

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

function makeMessagebuffer(headerbuffer, ringbuffer) {
  var messageLen = headerbuffer.readUInt32BE(8);
  var remaining = ringbuffer.remaining();
  if (messageLen > remaining) { return null; }
  return ringbuffer.peekView(messageLen);
}

function logPeekBuffer(buffer) {
  LOG_ERROR(("First 64 bytes (or fewer) of incoming buffer: \n" + (DebugLib.Debug.formatDumpBytes(buffer.peekString(Math.min(buffer.remaining(), 64)), true, 0))));
}

/**
 * Interact with underlying transport to send and receive SMF messages
 * @private
 */
var BufferSMFClient = (function (BaseSMFClient) {
  function BufferSMFClient(rxSmfCB, rxMessageErrorCB, session) {
    BaseSMFClient.call(this, rxSmfCB, rxMessageErrorCB, session);
    this._incomingBuffer = new BufferDataQueue(SMF_LOST_FRAMING_THRESHOLD);
  }

  if ( BaseSMFClient ) BufferSMFClient.__proto__ = BaseSMFClient;
  BufferSMFClient.prototype = Object.create( BaseSMFClient && BaseSMFClient.prototype );
  BufferSMFClient.prototype.constructor = BufferSMFClient;

  BufferSMFClient.prototype.reset = function reset () {
    BaseSMFClient.prototype.reset.call(this);
    // Called from super constructor, so guard this
    if (this._incomingBuffer) { this._incomingBuffer.reset(); }
  };

  /**
   * @param {String} data Incoming data as binary string
   */
  BufferSMFClient.prototype.rxDataString = function rxDataString (data) {
    this._rxDataCB(Buffer.from(stringToUint8Array(data)));
  };

  /**
   * @param {ArrayBuffer} data Incoming data
   */
  BufferSMFClient.prototype.rxDataArrayBuffer = function rxDataArrayBuffer (data) {
    this._rxDataCB(Buffer.from(data));
  };

  /**
   * @param {Buffer} data Incoming data
   */
  BufferSMFClient.prototype.rxDataBuffer = function rxDataBuffer (data) {
    this._rxDataCB(data);
  };

  /**
   * Invoked by transport session. Handles multiple SMF messages in input, as well as defragmenting
   * partial SMF messages. The state we keep is in this._incomingBuffer.
   * @param {Buffer} data The binary data to decode
   */
  BufferSMFClient.prototype._rxDataCB = function _rxDataCB (data) {
    var this$1 = this;

    var buffer = this._incomingBuffer;
    if (this._session) {
      LOG_TRACE('Reset KeepAliveCounter');
      // each incoming data chunk resets KA counter
      this._session.resetKeepAliveCounter();
    }

    // Add incoming data to the buffer. In node, this is only one copy:
    // wrapping ArrayBuffer in Buffer creates a view of the underlying allocation.
    var putSuccess = buffer.put(data);
    var remaining = buffer.remaining();

    if (!putSuccess) {
      // 80 megabytes - lost SMF framing: may never complete
      logPeekBuffer(buffer);
      this._rxMessageErrorCB(("Buffer overflow (length: " + remaining + ")"));
      this._incomingBuffer.reset();
    }

    var headerbuffer;
    while (remaining > 0) {
      headerbuffer = makeHeaderbuffer(buffer);
      if (!headerbuffer) { break; } // no header yet

      if (!isHeaderbufferValid(headerbuffer)) {
        // Throw away the buffer and bail out
        LOG_ERROR("BufferSMFClient._rxDataCB(): couldn't decode message due to invalid smf header");
        logPeekBuffer(buffer);
        this$1._incomingBuffer.reset();
        this$1._rxMessageErrorCB('Error parsing incoming SMF - invalid SMF header detected');
        return;
      }

      var messageBuffer = makeMessagebuffer(headerbuffer, buffer);
      if (!messageBuffer) {
        break; // no full message
      }

      LOG_TRACE('BufferSMFClient incoming buffer has a full SMF message');
      var binaryString = messageBuffer.toString('binary');
      var incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(binaryString, 0);
      if (incomingMsg && incomingMsg.smfHeader) {
        buffer.advance(incomingMsg.smfHeader.messageLength);
        this$1._rxSmfCB(incomingMsg); // hand over to core API callback
      } else {
        // couldn't decode! Lost SMF framing.
        // throw away the buffer and bail out
        var sessionId = this$1._session ? this$1._session._sessionId : null;
        var sessionIdHex = sessionId ? formatHexString(sessionId) : 'N/A';
        LOG_ERROR(("BufferSMFClient._rxDataCB(): couldn't decode message (sessionId=" + sessionIdHex + ")"));
        logPeekBuffer(buffer);
        this$1._incomingBuffer.reset();
        this$1._rxMessageErrorCB('Error parsing incoming SMF');
        return;
      }
      remaining = buffer.remaining();
    }

    if (remaining) {
      // We have a partial header, or a valid header and a partial message.
      LOG_TRACE(("BufferSMFClient message chunk of " + remaining + " bytes: partial message kept in incoming buffer"));
      // partial message remaining: keep it in incoming buffer
    } else {
      LOG_TRACE('BufferSMFClient clear incoming buffer');
      // clear incoming buffer
      this._incomingBuffer.reset();
    }
  };

  return BufferSMFClient;
}(BaseSMFClient));

module.exports.BufferSMFClient = BufferSMFClient;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;

var arrayBufferToString = Convert.arrayBufferToString;
var formatHexString = Hex.formatHexString;

var SMF_LOST_FRAMING_THRESHOLD = 80000000;

var ref$3 = new LogFormatter('[string-smf-client]');
var LOG_DEBUG = ref$3.LOG_DEBUG;
var LOG_ERROR = ref$3.LOG_ERROR;

/**
 * Interact with underlying transport to send and receive SMF messages
 * @private
 */
var StringSMFClient = (function (BaseSMFClient) {
  function StringSMFClient () {
    BaseSMFClient.apply(this, arguments);
  }

  if ( BaseSMFClient ) StringSMFClient.__proto__ = BaseSMFClient;
  StringSMFClient.prototype = Object.create( BaseSMFClient && BaseSMFClient.prototype );
  StringSMFClient.prototype.constructor = StringSMFClient;

  StringSMFClient.prototype.reset = function reset () {
    BaseSMFClient.prototype.reset.call(this);
    this._incomingBuffer = '';
  };

  /**
   * @param {String} data Incoming data
   */
  StringSMFClient.prototype.rxDataString = function rxDataString (data) {
    this._rxDataCB(data);
  };

  /**
   * @param {String} data Incoming data
   */
  StringSMFClient.prototype.rxDataArrayBuffer = function rxDataArrayBuffer (data) {
    this._rxDataCB(arrayBufferToString(data));
  };

  /**
   * @param {Buffer} data incoming data
   */
  StringSMFClient.prototype.rxDataBuffer = function rxDataBuffer (data) {
    this._rxDataCB(data.toString());
  };

  /**
   * Invoked by transport session. Handles multiple SMF messages in input, as well as defragmenting
   * partial SMF messages. The state we keep is in this._incomingBuffer.
   * @param {String} data The binary data to decode
   */
  StringSMFClient.prototype._rxDataCB = function _rxDataCB (data) {
    var this$1 = this;

    if (this._session) {
      LOG_DEBUG('Reset KeepAliveCounter');
      // each incoming data chunk resets KA counter
      this._session.resetKeepAliveCounter();
    }
    if (this._incomingBuffer.length === 0) {
      // optimization: set reference (cheaper than append)
      this._incomingBuffer = data;
    } else {
      // append to existing data
      this._incomingBuffer += data;
      if (this._incomingBuffer.length > SMF_LOST_FRAMING_THRESHOLD) {
        // sanity check
        // 80 megabytes - lost SMF framing: may never complete
        LOG_ERROR(("First 64 bytes (or fewer) of incoming buffer: \n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substr(0, 64), true, 0))));
        this._rxMessageErrorCB(("Buffer overflow (length: " + (this._incomingBuffer.length) + ")"));
        this._incomingBuffer = '';
      }
    }

    var pos = 0;
    while ((pos < this._incomingBuffer.length) &&
          (SMFLib.Codec.ParseSMF.isSMFAvailable(this._incomingBuffer, pos))) {
      LOG_DEBUG('StringSMFClient incoming buffer has a full SMF message');

      var incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(this$1._incomingBuffer, pos);
      if (incomingMsg && incomingMsg.smfHeader) {
        pos += incomingMsg.smfHeader.messageLength;
        this$1._rxSmfCB(incomingMsg); // hand over to core API callback
      } else {
        // couldn't decode! Lost SMF framing.
        var sessionId = this$1._session ? this$1._session._sessionId : null;
        var sessionIdHex = sessionId ? formatHexString(sessionId) : 'N/A';
        LOG_ERROR(("StringSMFClient.rxDataCB(): couldn't decode message (sessionId=" + sessionIdHex + "), dumping buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this$1._incomingBuffer.substr(pos), true, 0))));
        this$1._incomingBuffer = '';
        this$1._rxMessageErrorCB(("Error parsing incoming SMF at position " + pos));
        return; // throw away all we have for now
      }
    }

    if (pos < this._incomingBuffer.length) {
      LOG_DEBUG(("StringSMFClient message chunk of " + (data.length) + " bytes: partial message kept in incoming buffer"));
      // isSMFHeaderValid calls isSMFHeaderAvailable
      // PERF
      if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(this._incomingBuffer, pos) &&
          (!SMFLib.Codec.ParseSMF.isSMFHeaderValid(this._incomingBuffer, pos))) {
        LOG_ERROR("StringSMFClient.rxDataCB(): couldn't decode message due to invalid smf header, dump " +
                  "first 64 bytes (or fewer) of buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(pos, 64), true, 0)));
        this._incomingBuffer = '';
        this._rxMessageErrorCB(("Error parsing incoming SMF at position " + pos + " - invalid SMF header detected"));
        return; // throw away all we have for now
      }
      // partial message remaining: keep it in incoming buffer
      var inBuffer = this._incomingBuffer;
      this._incomingBuffer = inBuffer.substr(pos, inBuffer.length - pos);
    } else {
      LOG_DEBUG('StringSMFClient clear incoming buffer');
      // clear incoming buffer
      this._incomingBuffer = '';
    }
  };

  return StringSMFClient;
}(BaseSMFClient));

module.exports.StringSMFClient = StringSMFClient;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(240);
var TcpTransportSession = ref.TcpTransportSession;

module.exports.TcpTransportSession = TcpTransportSession;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var net = __webpack_require__(288);
var tls = __webpack_require__(290);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(3);
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_WARN = ref$2.LOG_WARN;
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(0);
var mixin = ref$3.mixin;
var ref$4 = __webpack_require__(139);
var NodeTLSOptsMixin = ref$4.NodeTLSOptsMixin;
var ref$5 = __webpack_require__(4);
var parseURL = ref$5.parseURL;
var ref$6 = __webpack_require__(46);
var TransportBase = ref$6.TransportBase;
var ref$7 = __webpack_require__(141);
var TransportClientStats = ref$7.TransportClientStats;
var ref$8 = __webpack_require__(33);
var TransportError = ref$8.TransportError;
var ref$9 = __webpack_require__(17);
var TransportReturnCode = ref$9.TransportReturnCode;
var ref$10 = __webpack_require__(47);
var TransportSessionEvent = ref$10.TransportSessionEvent;
var ref$11 = __webpack_require__(24);
var TransportSessionEventCode = ref$11.TransportSessionEventCode;
var ref$12 = __webpack_require__(34);
var TransportSessionState = ref$12.TransportSessionState;


var formatHexString = Hex.formatHexString;

/**
 *
 * Tcp (smf) transport with TLS (tcps://) support.
 * Only works in node.js.
 * Modelled after the WebSocket transport mostly,
 * except there is no downgrade mechanism.
 * There is no separate "Transport" class
 * to manage the downgrade FSM:
 * The TransportSession is the Transport.

 * @private
 */
var TcpTransportSession = (function (TransportBase) {
  function TcpTransportSession(url, eventCB, client, props) {
    // instanitate instance properties defined in TransportBase
    TransportBase.call(this, url, eventCB, client, props);

    /**
     * @private
     * @type {TransportClientStats}
     */
    this._clientstats = new TransportClientStats();

    /**
     * Maximum amount of send data than can be queued.
     * NodeJS socket.write accepts all writes, growing a
     * user space buffer indefinitely.
     * The TCP transport (same as WS transport)
     * manages the size of that buffer to stay below this limit.
     * @private
     * @type {Number}
     */
    this._sendBufferMaxSize = props.sendBufferMaxSize;

    /*
     * When true, the upper layer was told NO_SPACE and must be notified
     * of the next "drained" event.
     * @private
     * @type {Boolean}
     */
    this._canSendNeeded = false;

    /*
     * One-shot flush callback.
     * Set on flush(), ran and cleared on socket drain event.
     * @private
     */
    this._flushCallback = null;

    /**
     * Flag to keep track of socket drained state:
     * Set to false when socket.write returns false,
     * (indicating user-space buffering)
     * Set to true on socket drain events.
     * (indicating the user space buffer has flushed to the OS.)
     * @type {Boolean}
     * @private
     */
    this._drained = true;

    /**
     * @type {TransportSessionState}
     * @private
     */
    this._state = TransportSessionState.DOWN;

    /**
     * @type {?Socket}
     * @private
     */
    this._socket = null;

    /**
     * Save the Event in the onError listener
     * Use it in onClose to populate the event.
     * (Tcp socket calls onError with the error then onClose.
     * WS socket calls only onClose and passes the error directly.)
     * @private
     * @type {?Error}
     */
    this._socketError = null;

    /**
     * @type {?string}
     * @private
     */
    this._sessionId = new Date().getTime();

    // Some whitebox tests expect a transport->transportSession nesting.
    this._transportSession = this;

    this._props.transportProtocol = null;
  }

  if ( TransportBase ) TcpTransportSession.__proto__ = TransportBase;
  TcpTransportSession.prototype = Object.create( TransportBase && TransportBase.prototype );
  TcpTransportSession.prototype.constructor = TcpTransportSession;

  /**
   * @override
   */
  TcpTransportSession.prototype.getClientStats = function getClientStats () {
    return this._clientstats;
  };

  /**
   * Extracts host and port from the router URL.
   * @private
   * @param {String} urlString the url
   * @returns {{String, Number}} host and port
   */
  TcpTransportSession.prototype.parseHostPort = function parseHostPort (urlString) {
    var port = null;
    var urlParsed = parseURL(urlString);
    if (urlParsed.protocol !== 'tcp:' && urlParsed.protocol !== 'tcps:') {
      // Should not happen.
      LOG_ERROR(("Tcp Transport: URL with unexpected scheme: " + (urlParsed.protocol)));
    }
    var host = urlParsed.hostname;
    port = urlParsed.port;
    if (port === null) {
      port = this._ssl ? 55443 : 55555;
    }
    // The rest of the URL (path, etc) is ignored.
    LOG_TRACE(("Parsing url " + urlString + " -> host: " + host + " , port: " + port));
    return { host: host, port: port };
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   * @param {Buffer} data the data
   */
  TcpTransportSession.prototype.onData = function onData (originalSocket, data) {
    // We do not collect Rx stats.
    if (originalSocket && originalSocket !== this._socket) {
      LOG_DEBUG('TcpTransportSession stray onData for previous socket, ignoring.');
      return;
    }
    if (this._client) {
      this._client.rxDataBuffer(data);
    }
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   * @param {Error} error the error
   */
  TcpTransportSession.prototype.onError = function onError (originalSocket, error) {
    if (originalSocket && originalSocket !== this._socket) {
      LOG_DEBUG('TcpTransportSession stray onError for previous socket, ignoring.');
      return;
    }
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_TRACE('Tcp transport is being destroyed, ignore error');
      return;
    }
    LOG_DEBUG(("Tcp transport connection error " + error));
    // net.socket invokes the error handler before the close handler.
    // Websocket does not, and that's what the upper layer expects.
    // Suppressing the "double tap" error events when connected,
    // saving the error for the onClose handler in _socketerror.
    if (this._state !== TransportSessionState.SESSION_UP) {
      this._eventCB(
        new TransportSessionEvent(
          TransportSessionEventCode.SEND_ERROR,
          ("Connection error" + error),
          null,
          ErrorSubcode.CONNECTION_ERROR, null));
    } else { // we rely on the close listener to notify the upper layer.
      this._socketError = error;
    }
  };

  /**
   * Socket callback.
   * Bind the socket argument to guard against stray invocations in a
   * quick connect()-destroy()-connect() scenario.
   * @private
   * @param {Socket} originalSocket original socket
   * @param {Boolean} hadError wheter there was an error
   */
  TcpTransportSession.prototype.onClose = function onClose (originalSocket, hadError) {
    //process.stdout.write('TCP transport onClose called.\n');
    if (originalSocket && originalSocket !== this._socket) {
      LOG_DEBUG('TcpTransportSession stray onClose for previous socket, ignoring.');
      return;
    }
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_TRACE('Tcp transport is being destroyed, ignore close');
      return;
    }
    var msg = hadError ? 'with error' : 'cleanly';
    var errorMsg = this._socketError && this._socketError.message;
    this._socketError = null; // clear on read.
    LOG_DEBUG(("Tcp transport connection is closed " + msg + ". Message: i" + errorMsg));
    //process.stdout.write(`Tcp transport connection is closed ${msg}. Message: ${errorMsg}`);
    this._state = TransportSessionState.CONNECTION_FAILED;
    this.destroy(("Connection closed " + msg + ". Message:" + errorMsg), ErrorSubcode.COMMUNICATION_ERROR);
  };

  /**
   * Callback for Socket.connect.
   * Bind the socket argument to guard against stray invocations in a
   * quick connect()-destroy()-connect() scenario.
   * @private
   * @param {Socket} originalSocket original socket
   */
  TcpTransportSession.prototype.onOpen = function onOpen (originalSocket) {
    LOG_TRACE('TcpTransportSession received socket open event.');
    if (originalSocket && originalSocket !== this._socket) {
      LOG_DEBUG('TcpTransportSession stray onOpen for previous socket, ignoring.');
      return;
    }
    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
      LOG_DEBUG(("TcpTransportSession stray onOpen when in state " + (this._state) + ", ignoring."));
      return;
    }
    this._state = TransportSessionState.SESSION_UP;
      // Send the event to the application letting it know that the session is up
    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.UP_NOTICE,
              'Connected',
              0,
              null,
              this._sessionId));
  };

  /**
   * Establish underlying transport.
   * @override
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.connect = function connect () {
    if (this._state !== TransportSessionState.DOWN) {
      LOG_ERROR(("Invalid state for operation: " + (TransportSessionState.nameOf(this._state))));
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (this._socket) {
      LOG_ERROR('TCP transport can not connect once _socket exists.');
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (!this._url) {
      LOG_WARN('Cannot connect to null URL');
      return TransportReturnCode.CONNECTION_ERROR;
    }

    LOG_DEBUG('Establishing Tcp transport session');
    try {
      this._state = TransportSessionState.WAITING_FOR_CREATE;
      var ref = this.parseHostPort(this._url);
      var host = ref.host;
      var port = ref.port;
      LOG_DEBUG('Constructing socket');
      // Luckily raw and tls sockets have the same API.
      if (!this._ssl) {
        this._socket = new net.Socket();
        this._socket.connect(
          port, host,
          this.onOpen.bind(this, this._socket)
        );
      } else {
        var tlsOptions = this.createTLSOptions();
        this._socket = tls.connect(
          port, host, tlsOptions
        );
        this._socket.on('secureConnect', this.onOpen.bind(this, this._socket));
      }
      LOG_TRACE('Assigning properties to socket');
      // WARNING!
      // This is the kind of thing that breaks on minification.
      // Re-run unit tests in production mode when changed:
      // grunt --gruntfile=Gruntfile_Production.js
      // When broken, consult the closure compiler exceptions file:
      // (sdk-root)/builder/template/-common/env/externs.js
      this._socket.on('data', this.onData.bind(this, this._socket));
      this._socket.on('error', this.onError.bind(this, this._socket));
      this._socket.on('close', this.onClose.bind(this, this._socket));
      this._socket.on('drain', this.onDrain.bind(this, this._socket));
      this._socket.setNoDelay(true);

      LOG_TRACE('Prepared socket');
    } catch (error) {
      LOG_DEBUG(("Error connecting: " + error));
      this._state = TransportSessionState.CONNECTION_FAILED;
      throw new TransportError(("Could not create Tcp socket: " + (error.message)),
        error.subcode || ErrorSubcode.CONNECTION_ERROR);
    }
    LOG_DEBUG('Tcp transport is connecting');
    return TransportReturnCode.OK;
  };

  /**
   * Destroy the underlying transport.
   * Returns transport return code.
   * @override
   * @param {?String} msg The message associated with this operation, if any.
   * @param {?ErrorSubcode} subcode The subcode associated with this operation, if any.
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.destroy = function destroy (msg, subcode) {
    if (this._state !== TransportSessionState.DOWN) {
      LOG_DEBUG(("Destroy Tcp transport: " + msg));

      // Set state for connection teardown.
      this._state = TransportSessionState.WAITING_FOR_DESTROY;

      if (this._socket) {
        var onerrorStub = function onerrorStub() { };
        this._socket.removeAllListeners('open');
        this._socket.removeAllListeners('data');
        this._socket.removeAllListeners('close');
        this._socket.removeAllListeners('drain');
        this._socket.removeAllListeners('error');
        this._socket.on('error', onerrorStub); // Prevent unhandled errors
        // Prefering destroy() over end() as it seems to
        // cancel pending callbacks like onOpen more reliably.
        //this._socket.destroy();
        this._socket.end();
        this._socket = null;
      }

      this._canSendNeeded = false;
      this._flushCallback = null;
      this._drained = true;
      this._state = TransportSessionState.DOWN;
      this._client = null; // Don't accept data.
    }

    // always send a DESTROYED_NOTICE in response to a destroy() even
    // if we think the transport is already destroyed
    LOG_TRACE(("Destroying TCP transport. msg: " + msg + " subcode: " + subcode));
    if (this._eventCB) {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                              msg || 'Session is destroyed',
                                              null,
                                              subcode || 0,
                                              this._sessionId));
      // Release references to other components
      this._eventCB = null;
    }
    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @description Intended for clean shutdowns.
   * Callback is invoked when all nodejs-buffered data
   * has been flushed to the OS socket.
   */
  TcpTransportSession.prototype.flush = function flush (callback) {
    if (this._drained) {
      LOG_DEBUG('Transport emitting FLUSH immediately.');
      callback();
    } else if (callback) {
      this._flushCallback = callback;
    }
    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @description Send encoded SMF message
   * Returns transport return code.
   * @param {String} message The encoded SMF message to send
   * @param {?Boolean} [forceAllowEnqueue=false] If true, do not fail due to transport buffer full
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.send = function send (message, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    // Limiting socket buffer size to _sendBufferMaxSize unless
    // the force flag was set
    // or the socket is drained, in which case any size message goes.
    if (forceAllowEnqueue
      || this._drained
      || this._socket.bufferSize + message.length <
      this._sendBufferMaxSize) {
      // _drained keeps track of "overflowing" writes.
      // nodejs never refuses a read but warns when it starts buffering.
      this._drained = this._socket.write(message, 'ascii');
      this._clientstats.bytesWritten += message.length;
      ++this._clientstats.msgWritten;
      return TransportReturnCode.OK;
    }
    // We'll unblock the user on the next onDrain.
    this._canSendNeeded = true;
    return TransportReturnCode.NO_SPACE;
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   */
  TcpTransportSession.prototype.onDrain = function onDrain (originalSocket) {
    if (originalSocket && originalSocket !== this._socket) {
      LOG_DEBUG('TcpTransportSession stray onDrain for previous socket, ignoring.');
      return;
    }
    this._drained = true;

    if (this._flushCallback) {
      LOG_DEBUG('Transport emitting FLUSH after drain.');
      var prevCallback = this._flushCallback;
      this._flushCallback = null;
      prevCallback();
    }

    if (this._canSendNeeded) {
      LOG_TRACE('Transport emitting CAN_ACCEPT_DATA');
      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '', null, 0, this._sessionId));
    }
  };

  /**
   * @override
   */
  TcpTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "TcpTransportSession; sid=" + (formatHexString(this._sessionId));
    return str;
  };

  return TcpTransportSession;
}(TransportBase));

mixin(TcpTransportSession, NodeTLSOptsMixin);

module.exports.TcpTransportSession = TcpTransportSession;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(84);
var WebTransportCapabilities = ref.WebTransportCapabilities;

var TransportCapabilities = {
  web: WebTransportCapabilities,
};

module.exports.TransportCapabilities = TransportCapabilities;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var TcpTransportsLib =  true ? __webpack_require__(239) : null;
var ref = __webpack_require__(84);
var WebTransport = ref.WebTransport;

var TransportFactory = {
  createTransport: function createTransport(host, eventCB, client, props, getId) {
    var url = host;
    Object.assign(props, {
      connectTimeoutInMsecs: 100000,  // TODO: can we eliminate this
    });
    // TCP transport is dictated by the URL (tcp:// or tcps://)
    // It is unaffected by the transportProtocol config parameter.
    if (TcpTransportsLib && url.trim().startsWith('tcp')) {
      return new TcpTransportsLib.TcpTransportSession(url, eventCB, client, props, getId);
    }
    return new WebTransport(url, eventCB, client, props, getId);
  },
};

module.exports.TransportFactory = TransportFactory;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var WebTransportsLib = __webpack_require__(84);
var ref = __webpack_require__(0);
var Lazy = ref.Lazy;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var ref$2 = __webpack_require__(46);
var TransportBase = ref$2.TransportBase;
var ref$3 = __webpack_require__(20);
var TransportProtocol = ref$3.TransportProtocol;

var lazyValue = Lazy.lazyValue;

// Define transportProtocol to transport mapping
var lutTransportProtocols = lazyValue(function () {
  var protocols = {};
  protocols[TransportProtocol.HTTP_BASE64] = WebTransportsLib.StateBase64;
  protocols[TransportProtocol.HTTP_BINARY] = WebTransportsLib.StateBinary;
  protocols[TransportProtocol.HTTP_BINARY_STREAMING] = WebTransportsLib.StateStreamingAndBinary;
  protocols[TransportProtocol.WS_BINARY] = WebTransportsLib.StateWebSocketBinary;
  return protocols;
});

/**
 * @classdesc
 * Handles web transport selection and downgrade without creating the actual transport
 * session object
 * @memberof solace
 * @private
 */
var TransportProtocolHandler = function TransportProtocolHandler(url, webTransportProtocolList) {
  var this$1 = this;

  var useSSL = TransportBase.useSsl(url);
  var transport = null;
  var downgradeTransport = null;
  webTransportProtocolList.slice().reverse().forEach(function (el) {
    var TransportConstructor = lutTransportProtocols.value[el];
    transport = new TransportConstructor(useSSL, this$1.switchState.bind(this$1), downgradeTransport);
    downgradeTransport = transport;
  });
  this._transport = transport;
  this._transport.onEnter();
};

TransportProtocolHandler.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._transport.getTransportProtocol();
};

TransportProtocolHandler.prototype.completeDowngrade = function completeDowngrade (err) {
  return this._transport.completeDowngrade(err);
};

TransportProtocolHandler.prototype.canCompleteDowngrade = function canCompleteDowngrade () {
  return (this._transport.getNextState() !== null);
};

TransportProtocolHandler.prototype.toString = function toString () {
  return this._transport.toString();
};

TransportProtocolHandler.prototype.switchState = function switchState (newState, reason) {
  LOG_TRACE(("Switching " + (this._transport) + " => " + newState + " (" + reason + ")"));
  this._transport = newState;
  newState.onEnter();
};

module.exports.TransportProtocolHandler = TransportProtocolHandler;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(7);
var Check = ref.Check;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var OperationError = ref$2.OperationError;
var ref$3 = __webpack_require__(142);
var HTTPConnection = ref$3.HTTPConnection;
var ref$4 = __webpack_require__(1);
var LogFormatter = ref$4.LogFormatter;
var ref$5 = __webpack_require__(140);
var SMFClient = ref$5.SMFClient;
var ref$6 = __webpack_require__(33);
var TransportError = ref$6.TransportError;
var ref$7 = __webpack_require__(20);
var TransportProtocol = ref$7.TransportProtocol;
var ref$8 = __webpack_require__(17);
var TransportReturnCode = ref$8.TransportReturnCode;
var ref$9 = __webpack_require__(47);
var TransportSessionEvent = ref$9.TransportSessionEvent;
var ref$10 = __webpack_require__(24);
var TransportSessionEventCode = ref$10.TransportSessionEventCode;
var ref$11 = __webpack_require__(34);
var TransportSessionState = ref$11.TransportSessionState;
var ref$12 = __webpack_require__(145);
var WebTransportSessionBase = ref$12.WebTransportSessionBase;

var int32ToStr = Convert.int32ToStr;
var strToByteArray = Convert.strToByteArray;
var strToHexArray = Convert.strToHexArray;
var formatHexString = Hex.formatHexString;

var ref$13 = new LogFormatter('[http-transport-session]');
var LOG_TRACE = ref$13.LOG_TRACE;
var LOG_DEBUG = ref$13.LOG_DEBUG;
var LOG_ERROR = ref$13.LOG_ERROR;
var LOG_INFO = ref$13.LOG_INFO;

/**
 * @private
 * @namespace Values for tracking current state of incoming streaming data
 */
var PacketReadState = {
  READING_HEADER: 0,
  STREAMING:      1,
};

/**
 * @private
 */
var MSIE_TRANSPORT_PADDING = 257;

function adaptURL(url) {
  var v = url.match(/(ws|http)(s?:\/\/.+)/);
  return ("http" + (v[2]));
}

/** ===========================================================================
 * HTTPTransportSession :
 *
 * This contains all data and code required to maintain HTTP transport sessions
 * with Solace routers
 * ============================================================================
 * @extends WebTransportSessionBase
 * @private
 */
var HTTPTransportSession = (function (WebTransportSessionBase) {
  function HTTPTransportSession(baseUrl, eventCB, client, props) {
    // Our internal data format (for now) is binary string, so we wrap the callback
    // in a function that does the required conversion to ArrayBuffer.
    WebTransportSessionBase.call(this, baseUrl,
          eventCB,
          client,
          props);

    // const self = this;
    // logger.formatter = function formatter(...args) {
    //   return [self.sessionIdHex, ...args];
    // };

    // Set to true if we have the data token that we need for sending data to the router
    this._haveToken = true;

    // Maximum payload chunk size in web transport
    this._confMaxWebPayload = props.maxWebPayload;
    this._maxPayloadBytes = 0;

    // Timer that will keep track of the destroy time
    this._destroyTimer = null;
    this._destroyTimeout = props.connectTimeoutInMsecs;

    // The URL used for create messages
    this._createUrl = adaptURL(baseUrl);

    // The URL used for all other messages - it will have the router tag appended
    // after the session has been created
    this._routerUrl = this._createUrl;

    // SMF client (instantiated after session is created)
    this._rxChannelClient = null;
    // Send data connection (instantiated after session is created)
    this._httpSendConn = null;

    // Receive data connection (instantiated after session is created)
    this._httpReceiveConn = null;

    // Data Token SMF header - this is preformatted for performance
    // It will be set after session is created
    this._smfDataTokenTSHeader = null;

    // Router Tag - a string that will be added to HTTP request URLs
    this._routerTag = '';

    // Session ID - 8-byte identifier that will associate this client
    // with client resources on the router
    this._sid = null;

    if (props.transportProtocol === null || props.transportProtocol === undefined) {
      throw new OperationError('transportProtocol is not set', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }

    this._transportProtocol = props.transportProtocol;
    this._useBinaryTransport = false;
    this._useStreamingTransport = false;
    this._streamingTransportPadding = 0;

    this._useBinaryTransport = (props.transportProtocol !== TransportProtocol.HTTP_BASE64);
    this._useStreamingTransport = (props.transportProtocol ===
                                   TransportProtocol.HTTP_BINARY_STREAMING);

    // extra state for STREAMING transport
    this._incomingBuffer = '';
    this._packetReadState = PacketReadState.READING_HEADER;

    var agent = navigator.userAgent || '';
    if (agent.match(/trident/i) || agent.match(/msie/i)) {
      this._streamingTransportPadding = MSIE_TRANSPORT_PADDING;
    }

    if (props.transportContentType === null || props.transportContentType === undefined) {
      throw new OperationError('transportContentType is not set', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    this._contentType = props.transportContentType;
  }

  if ( WebTransportSessionBase ) HTTPTransportSession.__proto__ = WebTransportSessionBase;
  HTTPTransportSession.prototype = Object.create( WebTransportSessionBase && WebTransportSessionBase.prototype );
  HTTPTransportSession.prototype.constructor = HTTPTransportSession;

  var prototypeAccessors = { sessionIdHex: {} };

  /**
   * @override
   */
  HTTPTransportSession.prototype.connectTimerExpiry = function connectTimerExpiry () {
    LOG_INFO('HTTP transport connect timeout');
    this.destroyCleanup('HTTP transport connect timeout', ErrorSubcode.TIMEOUT);
  };

  prototypeAccessors.sessionIdHex.get = function () {
    return (this._sid) ? formatHexString(this._sid) : '';
  };

  HTTPTransportSession.prototype.updateMaxWebPayload = function updateMaxWebPayload () {
    // 22 Bytes of TransportSMF wrapping overhead
    var trLessEncapSMF = this._confMaxWebPayload - 22;
    // Base64 has a 4:3 expansion
    this._maxPayloadBytes = this._useBinaryTransport
      ? trLessEncapSMF
      : Math.floor(trLessEncapSMF * 0.75);
  };

  /**
   * Connect transport session to router
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.connect = function connect () {
    // Check that we we are in an acceptable state for connection
    if (this._state !== TransportSessionState.DOWN) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    return this.connectInternal();
  };

  HTTPTransportSession.prototype.connectInternal = function connectInternal () {
    var this$1 = this;

    // Create the XHR to talk to the router
    this._connError = null;
    try {
      this._createConn = new HTTPConnection(this._createUrl,
                                            !(this._useBinaryTransport),
                                            false,
                                            function (rc, data) { return this$1.handleCreateResponse(rc, data); },
                                            function (rc, data) { return this$1.handleCreateConnFailure(rc, data); },
                                            this._contentType);
    } catch (e) {
      LOG_INFO(("Failed to create connection to router: " + (e.message)));
      this._connError = e;
      return TransportReturnCode.CONNECTION_ERROR;
    }
    if (Check.nothing(this._createConn)) {
      LOG_INFO('Failed to create connection to router');
      return TransportReturnCode.CONNECTION_ERROR;
    }

    // Get an SMF transport session create message
    var createMsg = SMFLib.Codec.Transport.genTsCreateHeader();

    // TODO: What is going on here?  If we are already waiting for create
    // TODO: we just skip starting the timer but other do everything else, overwriting
    // TODO: _createConn in the process with a new XMLHTTPRequest object?
    if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
      // already connecting (this is likely a retry with Base64 encoding)
      LOG_DEBUG('Connect attempt while in WAITING_FOR_CREATE (retry)');
    } else {
      this.createConnectTimeout();
      // Set the current state
      this._state = TransportSessionState.WAITING_FOR_CREATE;
    }

    // Send the create message to the router.  When the response is received, the
    // handleCreateResponse method will be called
    try {
      this._createConn.send(createMsg);
    } catch (connError) {
      LOG_DEBUG(("Error connecting: " + (connError.message)));
      LOG_TRACE('Error details:', connError.stack || connError);
      this._state = TransportSessionState.CONNECTION_FAILED;
      this.cancelConnectTimeout();
      if (connError instanceof TransportError) {
        this._connError = connError;
      } else {
        this._connError = new TransportError(
          ("Could not create HTTP transport session: " + (connError.message)),
          connError.subcode || ErrorSubcode.CONNECTION_ERROR);
      }
      return TransportReturnCode.CONNECTION_ERROR;
    }

    return TransportReturnCode.OK;
  };

  /**
   * Destroy transport session to router
   * @param {String} msg The message associated with the operation
   * @param {ErrorSubcode} subcode The subcode associated with the operation
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.destroy = function destroy (msg, subcode) {
    var this$1 = this;

    LOG_TRACE(("Destroy transport session when in state " + (this._state)));
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY ||
        this._state === TransportSessionState.DOWN) {
      // Nothing to do
      return TransportReturnCode.OK;
    }

    if (this._state === TransportSessionState.CONNECTION_FAILED ||
        this._state === TransportSessionState.WAITING_FOR_CREATE) {
      // The connections are in an unreliable state - we will just
      // kill our local object and let the router clean itself up with its inactivity timer
      LOG_DEBUG('The connection is in unreliable state, close transport');
      this.destroyCleanup(msg, subcode, true);
      return TransportReturnCode.OK;
    }

    LOG_DEBUG('Destroy transport session immediately');
    // Set the current state
    this._state = TransportSessionState.WAITING_FOR_DESTROY;

    // Abort any current requests for this session
    if (this._httpSendConn !== null) {
      LOG_DEBUG('Destroy transport session: abort sendConn');
      this._httpSendConn.abort();
    }
    if (this._httpReceiveConn !== null) {
      LOG_DEBUG('Destroy transport session: abort receiveConn');
      this._httpReceiveConn.abort();
    }

    // Start a timer
    this._destroyTimer = setTimeout(function () {
      this$1.destroyTimerExpiry();
    }, this._destroyTimeout);

    // Send the destroy message over new HTTPConnection to the router so that the async abort
    // can properly finish in the old _httpSendConn.
    // When the response is received, the handleDestroyResponse method will be called.
    this._httpSendConn = new HTTPConnection(
        this._routerUrl,
        !(this._useBinaryTransport), false,
        function (rc, data) { return this$1.handleRxDataToken(rc, data); }, // RxData callback
        function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
        this._contentType,
        true);

    // Get an SMF transport session destroy message
    var destroyMsg = SMFLib.Codec.Transport.genTsDestroyHeader(this._sid);

    LOG_TRACE(("destroy message: " + (strToHexArray(destroyMsg))));
    this._httpSendConn.send(destroyMsg);

    return TransportReturnCode.OK;
  };

  /**
   * Send data over the connection - this requires a send token
   * @param {String} dataIn The data to send
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, do not fail due to out of space
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.send = function send (dataIn, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var data = dataIn;
    // LOG_TRACE(`HTTPTransportSession:send ${data.length}, tx_queued:${this._queuedDataSize}`);
    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    // Check to see if we already have queued data
    if ((this._queuedData.length > 0) || (!this._haveToken)) {
      return this.enqueueData(data, forceAllowEnqueue);
    }

    // Check if we need to chop up the payload
    var remainder = null;
    if (data.length > this._maxPayloadBytes) {
      remainder = data.substr(this._maxPayloadBytes);
      data = data.substr(0, this._maxPayloadBytes);

      // If no space for remainder, return FAIL without sending anything.
      if (!this.allowEnqueue(remainder.length)) {
        return this.enqueueFailNoSpace();
      }

    // LOG_DEBUG("$$ send dataChunk:" + data.length + ", remainderChunk:" + remainder.length);
    }

    // We have the token, so send the data
    this._haveToken = false;

    var transportPacketLen = (this._smfDataTSHeaderParts[0].length + 4 +
                                this._smfDataTSHeaderParts[1].length + data.length);

    this._httpSendConn.send(this._smfDataTSHeaderParts[0] +
                            int32ToStr(transportPacketLen) +
                            this._smfDataTSHeaderParts[1] +
                            data);
    this._clientstats.bytesWritten += data.length;

    if (remainder) {
      // The message was partially sent. The message written count will be incremented
      // when its last bytes go out.
      return this.enqueueData(remainder, null);
    }

    // The whole message was sent.
    this._clientstats.msgWritten++;
    return TransportReturnCode.OK;
  };

  /**
   * Push data onto the pending send queue as long as it doesn't violate
   * the max stored message size
   * @param {String} data The data to enqueue
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, don't fail due to no space.
   * @returns {TransportReturnCode} The result of the operation.
   */
  HTTPTransportSession.prototype.enqueueData = function enqueueData (data, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var dataLen = data.length;

    // LOG_DEBUG("enqueueing data: " + data.length + ", queue depth: " + this._queuedDataSize);
    if (forceAllowEnqueue || this.allowEnqueue(dataLen)) {
      this._queuedDataSize += dataLen;
      this._queuedData.push(data);
    } else {
      return this.enqueueFailNoSpace();
    }

    return TransportReturnCode.OK;
  };

  /**
   * Set the data in the preformatted headers.  The headers are set up this way
   * for performance reasons
   * @param {String} sid The session ID to incorporate into the headers
   */
  HTTPTransportSession.prototype.initPreformattedHeaders = function initPreformattedHeaders (sid) {
    // _smfDataTSHeaderParts is a two entry array - one part before the total length
    // and the other after.  The total length is not known until actual data is sent
    this._smfDataTSHeaderParts = SMFLib.Codec.Transport.genTsDataMsgHeaderParts(sid);

    // _smfDataTokenTSHeader is a single header that all data-token messages require
    if (this._useStreamingTransport) {
      this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataStreamTokenMsg(
        sid,
        this._streamingTransportPadding);
    } else {
      this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataTokenMsg(sid);
    }
  };

  /**
   * @override
   */
  HTTPTransportSession.prototype.flush = function flush (callback) {
    if (this._queuedDataSize) {
      this._flushCallback = callback;
    } else {
      callback();
    }
  };

  /**
   * Check if there is any data waiting to be sent to the router.
   * If there is, send it.
   */
  HTTPTransportSession.prototype.sendQueuedData = function sendQueuedData () {
    if (this._queuedDataSize === 0) {
      return;
    }
    this._haveToken = false;
    var data = this.getQueuedDataToSend();
    var transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 +
                               this._smfDataTSHeaderParts[1].length + data.length;

    this._httpSendConn.send(this._smfDataTSHeaderParts[0] +
                            int32ToStr(transportPacketLen) +
                            this._smfDataTSHeaderParts[1] +
                            data);
    this._clientstats.bytesWritten += data.length;


    if (this._canSendNeeded) {
      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '',
                                  null,
                                  0,
                                  this._sid));
    }

    if (this._flushCallback) {
      var cb = this._flushCallback;
      this._flushCallback = null;
      cb();
    }
  };

  // Internal Callbacks

  // Called when a create response message has been received
  HTTPTransportSession.prototype.handleCreateResponse = function handleCreateResponse (tsRc, response) {
    var this$1 = this;

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY ||
        this._state === TransportSessionState.DOWN) {
      LOG_DEBUG('Received create response on a destroyed transport session, ignore');
      return;
    }

    // Was: stop the connect timer. We don't do that in this transport now.
    // We wait for the login response.

    // We know whether we're using Base64 or not, so update our max payload size.
    this.updateMaxWebPayload();

    if (tsRc !== TransportReturnCode.OK) {
      LOG_DEBUG(("Received create response with return code " + (TransportReturnCode.describe(tsRc))));
      if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
        this.destroyCleanup('Received data decode error on create session response', ErrorSubcode.DATA_DECODE_ERROR);
      } else {
        this.destroyCleanup('Failed to handle create session response', ErrorSubcode.CONNECTION_ERROR);
      }
      return;
    }

    if (response.length === 0) {
      return; // null read indicating end of stream
    }

    // Parse the Transport Session SMF
    var parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(response, 0);

    if (!parsedResponse) {
      LOG_ERROR('Could not parse create response as SMF. Destroying transport');
      this.destroyCleanup('Failed to parse create response message', ErrorSubcode.CONNECTION_ERROR);
      return;
    }

    var smfresponse = parsedResponse.getResponse();
    if (smfresponse.responseCode !== 200) {
      this.destroyCleanup(("Transport create request failed (" + (smfresponse.responseCode) + ", " + (smfresponse.responseString) + ")"),
                          ErrorSubcode.CONNECTION_ERROR);
      return;
    }

    this.cancelConnectTimeout();
    this._createConn.abort();
    this._createConn = null;
    this._state = TransportSessionState.SESSION_UP;
    this._sid = parsedResponse.sessionId;
    this._routerTag = parsedResponse.routerTag;

    // Trim any parameters off the create url before using it for the routerUrl
    this._routerUrl = this._createUrl.replace(/\?.*/, '');
    if (this._routerTag !== '') {
      this._routerUrl = this._routerUrl + this._routerTag;
    }

    this.initPreformattedHeaders(this._sid);
    var useBase64 = !this._useBinaryTransport;
    var useStreaming = this._useStreamingTransport;

    // Create the two connections to the router
    // By now, getXhrObj() should not throw any exception inside HTTPConnection constructor
    this._httpSendConn = new HTTPConnection(this._routerUrl, useBase64, false,
        function (rc, data) { return this$1.handleRxDataToken(rc, data); }, // RxData callback
        function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
        this._contentType);
    if (this._useStreamingTransport) {
      // When the transport is HTTP_BINARY_STREAMING the SMF encapsulation
      // is complete, the SMF header indicates a message length of 0xFFFFFFFF
      // and after decoding just the header alone the data is passed through
      // to the session layer, so we must use a simplified SMF parser and a
      // stateful data callback in that case.
      this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming,
            function (rc, data) { return this$1.handleRxStreaming(rc, data); }, // RxData Callback
            function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
            this._contentType,
            true);
    } else {
      // Create a SMF client for the Receive Data channel, when http is used.
      // SMF messages are encapsualated in a solace http-transport which is itself
      // encapsulated in SMF.  So create an SMF client that will callback with
      // an smfMessage construct to the HTTPTransportSession.
      this._rxChannelClient = new SMFClient(
            function (rxData) { return this$1.handleSmfMessage(rxData); },
            function (rxError) { return this$1.handleSmfParseError(rxError); },
            null);    // we don't have a 'session' for this client. It's just a parser.
      this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming,
            function (rc, data) { return this$1.handleRxData(rc, data); }, // RxData Callback
            function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
            this._contentType);
    }

    // Give the router the data token so that it will be able to send data
    this._httpReceiveConn.send(this._smfDataTokenTSHeader);

    // Send the event to the application letting it know that the session is up
    this._eventCB(
      new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE,
                                smfresponse.responseString,
                                smfresponse.responseCode,
                                0,
                                parsedResponse.sessionId));
  };

  // Called when receiving a destroy response
  HTTPTransportSession.prototype.handleDestroyResponse = function handleDestroyResponse (response) {
    LOG_DEBUG('Handle destroy response');
    // Stop the timer
    this.cancelDestroyTimeout();
    var innerResponse = response.getResponse();
    var responseString = innerResponse ? innerResponse.responseString : '';
    this.destroyCleanup(
      (responseString + " handled Destroy Response addressed to session " + (formatHexString(response.sessionId)) + ", on session " + (formatHexString(this._sid))),
      0);
  };

  HTTPTransportSession.prototype.handleSmfMessage = function handleSmfMessage (tsmsg) {
    var smfHeader = tsmsg.smfHeader;
    if (smfHeader.smf_protocol !== SMFLib.SMFProtocol.TSESSION) {
      this.handleSmfParseError(("Unexpected Message Prototcol (" + (smfHeader.smf_protocol) + ") on ReceiveData connection"));
      return;
    }

      // we have found a transport SMF, can we now read the Transport SMF chunk
    var data = tsmsg.payload;
    var TotalPayloadToRead = tsmsg.payloadLength;

    switch (tsmsg.messageType) {
      case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
        this.handleDestroyResponse(tsmsg);
        return;

      case SMFLib.SMFTransportSessionMessageType.DATA:
        if (tsmsg.sessionId !== this._sid) {
          // The router may have given us an error code; if so, include in the error message.
          var smfErrResponse = tsmsg.getResponse();
          var responseErrStr = smfErrResponse
              ? ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")"))
              : '';
          var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

          LOG_DEBUG(("HandleRxData Bad Session ID received in message. Expected: " + (strToByteArray(this._sid)) + ", Received: " + (strToByteArray(tsmsg.sessionId)) + responseErrStr));

          this._state = TransportSessionState.CONNECTION_FAILED;
          this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                        ("Session ID mismatch in data message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(tsmsg.sessionId)) + ", " + responseErrStr),
                        responseCode,
                        ErrorSubcode.PROTOCOL_ERROR, this._sid));
          return;
        }

        // pass-through encapsulated data to parent
        if (TotalPayloadToRead > 0) {
          this._client.rxDataString(data);
        }
        break;
      default:
        // Unexpected message type
        this.handleSmfParseError(("Unexpected message type (" + (tsmsg.messageType) + ") on ReceiveData connection"));
    }
  };

  HTTPTransportSession.prototype.handleSmfParseError = function handleSmfParseError () {
    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR,
        'Received data decode error', null,
        ErrorSubcode.DATA_DECODE_ERROR, this._sid));
  };

  // Called when data is received on the connection
  HTTPTransportSession.prototype.handleRxData = function handleRxData (tsRc, data) {
    if (this._httpReceiveConn === null || this._rxChannelClient === null) {
      if (this._state === TransportSessionState.DOWN) {
        LOG_DEBUG('Transport session is down, ignore data from receive connection');
      } else {
        LOG_ERROR(("Transport session is not in working state, state: " + (this._state)));
      }
      return;
    }

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_DEBUG('Transport session is being destroyed, ignore data from receive connection, ' +
               "dump first 64 bytes (or fewer) of data:\n" + (DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)));
      return;
    }

    this._httpReceiveConn.recStat('GotData');
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      LOG_DEBUG('Send write token to router');
      this._httpReceiveConn.send(this._smfDataTokenTSHeader);
    } else {
      this._rxChannelClient.rxDataString(data);
    } // end have data to process
  };

  // Called when data is received on a HTTP_BINARY_STREAMING connection
  HTTPTransportSession.prototype.handleRxStreaming = function handleRxStreaming (tsRc, data) {
    if (this._httpReceiveConn === null) {
      if (this._state === TransportSessionState.DOWN) {
        LOG_DEBUG('Transport session is down, ignore data from receive connection');
      } else {
        LOG_ERROR(("Transport session is not in working state, state: " + (this._state)));
      }
      return;
    }

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_DEBUG('Transport session is being destroyed, ignore data from streaming receive ' +
               "connection, dump first 64 bytes (or fewer) of data:\n" + (DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)));
      return;
    }

    this._httpReceiveConn.recStat('GotData');
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      LOG_TRACE('Send write token to router');
      this._packetReadState = PacketReadState.READING_HEADER;
      this._httpReceiveConn.send(this._smfDataTokenTSHeader);
      return;
    }

    // pass-through encapsulated data to parent
    if (this._packetReadState === PacketReadState.STREAMING) {
      this._client.rxDataString(data);
      return;
    }

    this._incomingBuffer += data;
    var smfheader = SMFLib.Codec.ParseSMF.parseSMFAt(this._incomingBuffer, 0, true);
    if (smfheader) {
        // we have a valid smf header, see if there is a transport header and session-id
      var tsmsg = SMFLib.Codec.Transport.parseTsSmfHdrAt(this._incomingBuffer,
                                                           smfheader.headerLength,
                                                           smfheader);
      if (!tsmsg) {
        // Not tsMsg but there is an smf header, just return until more data arrives
        return;
      }

      // We have the transport message header too, if it is a DATA message enter
      // STREAMING state
      switch (tsmsg.messageType) {
        case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
          this.handleDestroyResponse(tsmsg);
          return;

        case SMFLib.SMFTransportSessionMessageType.DATA:
          if (tsmsg.sessionId !== this._sid) {
            // The router may have given us an error code, if so, include in the error message.
            var smfErrResponse = tsmsg.getResponse();
            var responseErrStr = smfErrResponse
                ? ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")"))
                : '';
            var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

            LOG_DEBUG(("HandleRxData Bad Session ID received in message.  Expected: " + (strToByteArray(this._sid)) + ", Received: " + (strToByteArray(tsmsg.sessionId)) + responseErrStr));
            LOG_DEBUG(("First 64 bytes (or fewer) of message: " + (strToByteArray(data.substr(0, 64)))));

            this._state = TransportSessionState.CONNECTION_FAILED;
            this._eventCB(
              new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                                        ("Session ID mismatch in data message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(tsmsg.sessionId)) + ", " + responseErrStr),
                                        responseCode,
                                        ErrorSubcode.PROTOCOL_ERROR, this._sid));
            return;
          }
          // all is good. We can now STREAM the rest of the data until a empty message is received.
          this._packetReadState = PacketReadState.STREAMING;
          // pass-through any remaining data
          if (this._incomingBuffer.length > (smfheader.headerLength + tsmsg.tsHeaderLength)) {
            this._client.rxDataString(
              this._incomingBuffer.substr(smfheader.headerLength + tsmsg.tsHeaderLength));
          }
          this._incomingBuffer = '';
          return;

        default:
          // Unexpected message type
          throw new TransportError(("Unexpected message type (" + (tsmsg.messageType) + ") on ReceiveData connection"), 0);
      }
    } else if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(this._incomingBuffer, 0) &&
               !SMFLib.Codec.ParseSMF.isSMFHeaderValid(this._incomingBuffer, 0)) {
      // Probably lost framing
      LOG_ERROR(("Couldn't decode message due to invalid smf header, dump first 64 bytes (or fewer) of buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(0, 64), true, 0))));

      var errorInfo = 'Error parsing incoming message - invalid SMF header detected';
      this._state = TransportSessionState.CONNECTION_FAILED;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                                  errorInfo, null,
                                  ErrorSubcode.PROTOCOL_ERROR,
                                  null));
    }
  };

  // Called when data is received on the httpDataSend
  HTTPTransportSession.prototype.handleRxDataToken = function handleRxDataToken (tsRc, data) {
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      return; // handle End of Stream
    }

    var parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
    if (!parsedResponse) {
      if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
        this._state = TransportSessionState.CONNECTION_FAILED;
        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                'Failed to parse received data message', null,
                ErrorSubcode.PROTOCOL_ERROR, this._sid));
      } else {
        this.destroyCleanup('Failed to parse received data message', ErrorSubcode.PROTOCOL_ERROR);
      }
      return;
    }

    if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DESTROY_RESP) {
      this.handleDestroyResponse(parsedResponse);
      return;
    }

    if (parsedResponse.sessionId !== this._sid) {
        // The router may have given us an error code, if so, include in the error message.
      var smfErrResponse = parsedResponse.getResponse();
      var responseErrStr = smfErrResponse ?
            ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")")) :
            '';
      var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

      LOG_DEBUG(("HandleRxDataToken Bad SID received in message.  Expected: " + (strToByteArray(this._sid)) + ", Received: " + (strToByteArray(parsedResponse.sessionId)) + responseErrStr));
      LOG_DEBUG(("First 64 bytes (or fewer) of message: " + (strToByteArray(data.substr(0, 64)))));

      if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
        this._state = TransportSessionState.CONNECTION_FAILED;
        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                ("Session ID mismatch in response message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(parsedResponse.sessionId)) + ", " + responseErrStr),
                responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
      } else {
        this.destroyCleanup('Session ID mismatch in response message', ErrorSubcode.PROTOCOL_ERROR);
      }
      return;
    }

    if (parsedResponse.messageType ===
        SMFLib.SMFTransportSessionMessageType.DATA_TOKEN ||
        parsedResponse.messageType ===
        SMFLib.SMFTransportSessionMessageType.DATA_STREAM_TOKEN) {
      this._haveToken = true;
      this._httpSendConn.recStat('GotToken');
      // this._eventCB(
      //    new TransportSessionEvent(TransportSessionEventCode.NOTIFY_GOT_TOKEN, "", null, null));
      this.sendQueuedData();
    } else {
        // Unexpected message type
      throw (new TransportError(("Unexpected message type (" + (parsedResponse.messageType) + ") on SendData connection"), 0));
    }
  };

  HTTPTransportSession.prototype.handleRxError = function handleRxError (tsRc /*, data */) {
    LOG_INFO(("handleRxError, transport return code " + (TransportReturnCode.name(tsRc))));
    this._state = TransportSessionState.CONNECTION_FAILED;
    if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR,
            'Received data decode error', null,
            ErrorSubcode.DATA_DECODE_ERROR, this._sid));
    } else {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR,
            'Connection error',
            ErrorSubcode.CONNECTION_ERROR, this._sid));
    }
  };

  // Called when there is an error on a connection or the connection is aborted
  HTTPTransportSession.prototype.handleSendFailure = function handleSendFailure (status, msg) {
    // failed to send message, if it is a destroy message, just complete the destroy process\
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_INFO(("Connection destroy failure (" + msg + ") while in state " + (this._state)));
      this.destroyCleanup(("Connection destroy failure: " + msg), ErrorSubcode.CONNECTION_ERROR);
    } else {
      // Failed to send message, return error to upper layer which may  tear the session down
      LOG_INFO(("Connection failure (" + msg + ") while in state " + (this._state)));
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR,
            ("Connection error: " + msg), status,
            ErrorSubcode.CONNECTION_ERROR, this._sid));
    }
  };

  // Called when there is an error on a connection for a session create request
  HTTPTransportSession.prototype.handleCreateConnFailure = function handleCreateConnFailure (status, msg) {
    if (this._state === TransportSessionState.DOWN) {
      return;
    }

    LOG_INFO(("Connection create failure (" + msg + ") while in state " + (this._state)));
    this.destroyCleanup(("Connection create failure: " + msg), ErrorSubcode.CONNECTION_ERROR);
  };

  // Called when the destroy timer expires
  HTTPTransportSession.prototype.destroyTimerExpiry = function destroyTimerExpiry () {
    this.destroyCleanup('Destroy request timeout', ErrorSubcode.CONNECTION_ERROR);
  };

  HTTPTransportSession.prototype.cancelDestroyTimeout = function cancelDestroyTimeout () {
    if (this._destroyTimer) {
      clearTimeout(this._destroyTimer);
      this._destroyTimer = null;
    }
  };

  /**
   * Called after receiving ts destroy response from router
   * @param {String} infoStr The informational string to pass along
   * @param {ErrorSubcode} subcode The subcode associated with the event
   * @param {Boolean} asyncSendEvent If true, always send the event asynchronously.
   */
  HTTPTransportSession.prototype.destroyCleanup = function destroyCleanup (infoStr, subcode, asyncSendEvent) {
    var this$1 = this;

    LOG_DEBUG(("Destroy cleanup: " + infoStr));

    // Abort any current requests for this session
    if (this._createConn) {
      LOG_DEBUG('Destroy cleanup: Abort createConn');
      this._createConn.abort();
    }
    if (this._httpSendConn) {
      LOG_DEBUG('Destroy cleanup: Abort sendConn');
      this._httpSendConn.abort();
    }
    if (this._httpReceiveConn) {
      LOG_DEBUG('Destroy cleanup: Abort receiveConn');
      this._httpReceiveConn.abort();
    }

    // Clear most internal state
    this._createUrl = null;
    this._routerUrl = null;
    this._createConn = null;
    this._httpSendConn = null;
    this._httpReceiveConn = null;
    this._smfDataTokenTSHeader = null;
    this._rxChannelClient = null;
    this._routerTag = '';
    this._queuedData = [];
    this._queuedDataSize = 0;
    this._canSendNeeded = false;

    // Clear timers.
    this.cancelDestroyTimeout();
    this.cancelConnectTimeout();

    // Set final state
    this._state = TransportSessionState.DOWN;

    // Send the event to the application letting it know that the session is down
    var finalize = function () {
      // Check whether the callback was cleared before the timeout completes.
      if (this$1._eventCB) {
        this$1._eventCB(
            new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                      infoStr || 'Session is destroyed',
                                      null,
                                      subcode || 0,
                                      this$1._sid));
      }

      // release reference to smf client object
      this$1._client = null;
      // release reference to session object
      this$1._eventCB = null;
    };

    if (asyncSendEvent) {
      setTimeout(finalize, 0); // TODO: setImmediate
    } else {
      finalize();
    }
  };

  HTTPTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "HTTPTransportSession; sid=" + (formatHexString(this._sid)) + "; routerTag=" + (this._routerTag);
    return str;
  };

  Object.defineProperties( HTTPTransportSession.prototype, prototypeAccessors );

  return HTTPTransportSession;
}(WebTransportSessionBase));

module.exports.HTTPTransportSession = HTTPTransportSession;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Base64 = ref.Base64;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(143);
var XHRFactory = ref$1.XHRFactory;

var base64Encode = Base64.encode;
var stringToUint8Array = Convert.stringToUint8Array;

function sendXhrBinaryMSIE10(xhr, data, contentType) {
  xhr.responseType = 'arraybuffer';
  xhr.overrideMimeType((contentType + "; charset=x-user-defined"));
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(stringToUint8Array(data));
}

function sendXhrBinaryXHR2(xhr, data, contentType) {
  xhr.overrideMimeType((contentType + "; charset=x-user-defined"));
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(stringToUint8Array(data).buffer);
}

function sendXhrText(xhr, data, contentType, connClose) {
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(data === null || data === undefined ? data : base64Encode(data), connClose);
}

var sendXhrBinary = (function () {
  // Uint8Array is probably shimmed by core-js. We don't use window.Blob, but
  // it is a Working Draft, not  part of ES6, and not shimmed by core-js.
  // Therefore it makes a workable canary for IE10 detection.
  if (typeof window !== 'undefined' && window.Uint8Array && window.Blob /* !ie9 */) {
    var xhr = XHRFactory.create(true);
    if (xhr.responseType /* ie10 */) {
      return sendXhrBinaryMSIE10;
    }
    return sendXhrBinaryXHR2;
  }
  return sendXhrText;
})();

module.exports.sendXhrBinary = sendXhrBinary;
module.exports.sendXhrText = sendXhrText;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;

/**
 * @classdesc
 * HTTP Base64 transport
 * @memberof solace
 * @private
 */
var StateBase64 = (function (TSHState) {
  function StateBase64(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BASE64, exitCb, nextState);
  }

  if ( TSHState ) StateBase64.__proto__ = TSHState;
  StateBase64.prototype = Object.create( TSHState && TSHState.prototype );
  StateBase64.prototype.constructor = StateBase64;

  return StateBase64;
}(TSHState));

module.exports.StateBase64 = StateBase64;



/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * HTTP Binary transport
 * @memberof solace
 * @private
 */
var StateBinary = (function (TSHState) {
  function StateBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BINARY, exitCb, nextState);
  }

  if ( TSHState ) StateBinary.__proto__ = TSHState;
  StateBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateBinary.prototype.constructor = StateBinary;

  StateBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.xhrBinary();
  };

  return StateBinary;
}(TSHState));

module.exports.StateBinary = StateBinary;



/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * HTTP Binary Streaming transport
 * @memberof solace
 * @private
 */
var StateStreamingAndBinary = (function (TSHState) {
  function StateStreamingAndBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BINARY_STREAMING, exitCb, nextState);
  }

  if ( TSHState ) StateStreamingAndBinary.__proto__ = TSHState;
  StateStreamingAndBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateStreamingAndBinary.prototype.constructor = StateStreamingAndBinary;

  StateStreamingAndBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.streaming() && WebTransportCapabilities.xhrBinary();
  };

  return StateStreamingAndBinary;
}(TSHState));

module.exports.StateStreamingAndBinary = StateStreamingAndBinary;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * WebSocket transport
 * @memberof solace
 * @private
 */
var StateWebSocketBinary = (function (TSHState) {
  function StateWebSocketBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.WS_BINARY, exitCb, nextState);
  }

  if ( TSHState ) StateWebSocketBinary.__proto__ = TSHState;
  StateWebSocketBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateWebSocketBinary.prototype.constructor = StateWebSocketBinary;

  StateWebSocketBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.webSocket();
  };

  return StateWebSocketBinary;
}(TSHState));

module.exports.StateWebSocketBinary = StateWebSocketBinary;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {


var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(15);
var FsmEvent = ref$1.FsmEvent;
var State = ref$1.State;
var StateMachine = ref$1.StateMachine;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;
var ref$3 = __webpack_require__(17);
var TransportReturnCode = ref$3.TransportReturnCode;
var ref$4 = __webpack_require__(47);
var TransportSessionEvent = ref$4.TransportSessionEvent;
var ref$5 = __webpack_require__(24);
var TransportSessionEventCode = ref$5.TransportSessionEventCode;
var ref$6 = __webpack_require__(144);
var WebTransportEvent = ref$6.WebTransportEvent;
var ref$7 = __webpack_require__(251);
var WebTransportState = ref$7.WebTransportState;

var ref$8 = new LogFormatter();
var LOG_TRACE = ref$8.LOG_TRACE;
var LOG_DEBUG = ref$8.LOG_DEBUG;

var WebTransportFSM = (function (StateMachine) {
  function WebTransportFSM(transportIn, getId) {
    var this$1 = this;

    StateMachine.call(this, { name: 'WebTransportFSM' });
    var transport = transportIn;
    var fsm = this;
    var logger = new LogFormatter();
    logger.formatter = function logFormatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [("[web-transport-fsm=" + (getId()) + "]") ].concat( args);
    };
    this.log = logger.wrap(this.log, this);
    this.transport = transport;

    this.initial(function onInitial() {
      return this.transitionTo(
        this.WebTransportDown,
        function (context) {
          LOG_TRACE(("Starting " + (context.getStateMachine().getName())));
        });
    });

    this.unhandledEventReaction(function onUnhandledEvent(wEvent) {
      LOG_TRACE(("Ignoring event " + (wEvent.getName()) + " in state " + (this.getCurrentState().getName())));
      return this;
    });

    this.WebTransportDown = new State({
      name:          WebTransportState.DOWN,
      parentContext: this,
    })
      .reaction(WebTransportEvent.CONNECT, function onConnect(/* wEevent */) {
        return this.transitionTo(fsm.WebTransportConnecting);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });

    this.WebTransportConnecting = new State({
      name:          WebTransportState.CONNECTING,
      parentContext: this,
    })
      .entry(function () {
        try {
          var rc = transport.connectInternal();
          if (rc !== TransportReturnCode.OK) {
            var connError = transport.getConnError();
            var wEvent = new FsmEvent({ name: WebTransportEvent.DESTROY });
            wEvent._destroyMsg = connError ? connError.message : 'Error occurred while establishing transport';
            wEvent._subcode = connError ? connError.subcode : null;
            wEvent._eventReason = connError;
            return this$1.processEvent(wEvent);
          }
        } catch (e) {
          LOG_DEBUG(("transport.connectInternal threw: " + (e.message)));
          var wEvent$1 = new FsmEvent({ name: WebTransportEvent.DESTROY });
          wEvent$1._destroyMsg = e.message;
          wEvent$1._subcode = e.subcode ? e.subcode : ErrorSubcode.CONNECTION_ERROR;
          wEvent$1._eventReason = e;
          return this$1.processEvent(wEvent$1);
        }
        return undefined;
      })
      // Transport destroy is async, so in downgrade cases we need an event to start the downgrade
      // (and associated transport destroy) and one to complete it (DESTROYED_NOTICE).
      // These two events trigger downgrade: SEND_ERROR on connection (protocol issue) and
      // CONNECT_TIMEOUT (possible black hole proxy).
      .reaction(WebTransportEvent.SEND_ERROR, function (wEvent) {
        transport.notifyEvent(wEvent._transportEvent); // Give the session a chance to intervene
        return fsm.attemptDowngrade(wEvent._transportEvent);
      })
      .reaction(WebTransportEvent.CONNECT_TIMEOUT, function (e) { return fsm.attemptDowngrade(e._transportEvent); })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function (wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this$1.transitionTo(fsm.WebTransportDown);
      })
      .reaction(WebTransportEvent.UP_NOTICE, function onUpNotice(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportUp);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportDowngrading = new State({
      name:          WebTransportState.DOWNGRADING,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        LOG_DEBUG('Web transport: request downgrade');
        if (!transport.completeDowngrade()) {
          LOG_DEBUG('Web transport: connection error, no downgrade');
          transport.notifyEvent(wEvent._transportEvent);
          fsm.notifyDowngradeFailed();
          return this.transitionTo(fsm.WebTransportDown);
        }
        return this.transitionTo(fsm.WebTransportConnecting);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportUp = new State({
      name:          WebTransportState.UP,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DOWNGRADE, function (wEvent) { return fsm.attemptDowngrade(new TransportSessionEvent(wEvent._downgradeMsg, wEvent._subcode)); })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportDown);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      })
      .reaction(WebTransportEvent.SEND_ERROR, function onUpNotice(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportDestroying = new State({
      name:          WebTransportState.DESTROYING,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportDown);
      });
  }

  if ( StateMachine ) WebTransportFSM.__proto__ = StateMachine;
  WebTransportFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  WebTransportFSM.prototype.constructor = WebTransportFSM;


    /**
     * Attempt a downgrade. This is the procedure.
     * 1. Call this. If it returns true, wait for DESTROYED_NOTICE, then
     * 2. Call transport.completeDowngrade().
     * @param {TransportSessionEvent} tsEvent The event triggering the downgrade
     * @returns {Boolean} `true` if downgrade is starting (by destroying the transport)
     */
  WebTransportFSM.prototype.attemptDowngrade = function attemptDowngrade (tsEvent) {
    var infoStr = tsEvent.infoStr;
    var errorSubcode = tsEvent.errorSubcode;
    if (!this.transport.beginDowngrade(infoStr, errorSubcode)) {
      LOG_TRACE('Downgrade unavailable');
      this.transport.destroyInternal(infoStr, errorSubcode);
      this.transport.notifyEvent(tsEvent);
      return this.transitionTo(this.WebTransportDestroying);
    }
    LOG_TRACE('Downgrade available');
    return this.transitionTo(this.WebTransportDowngrading);
  };

  WebTransportFSM.prototype.notifyDowngradeFailed = function notifyDowngradeFailed () {
    LOG_TRACE('Notifying of downgrade failure');
    this.transport.notifyEvent(new TransportSessionEvent(TransportSessionEventCode.DOWNGRADE_FAILED,
                                  'Downgrade failed'));
  };

  return WebTransportFSM;
}(StateMachine));

module.exports.WebTransportFSM = WebTransportFSM;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

// WebTransport states, used by WebTransport
var WebTransportState = {
  DOWN:        'WebTransportDown',
  CONNECTING:  'WebTransportConnecting',
  DOWNGRADING: 'WebTransportDowngrading',
  DESTROYING:  'WebTransportDestroying',
  UP:          'WebTransportUp',
};

module.exports.WebTransportState = Enum.new(WebTransportState);


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(85);
var HTTPTransportSession = ref$1.HTTPTransportSession;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(15);
var FsmEvent = ref$3.FsmEvent;
var ref$4 = __webpack_require__(46);
var TransportBase = ref$4.TransportBase;
var ref$5 = __webpack_require__(20);
var TransportProtocol = ref$5.TransportProtocol;
var ref$6 = __webpack_require__(243);
var TransportProtocolHandler = ref$6.TransportProtocolHandler;
var ref$7 = __webpack_require__(17);
var TransportReturnCode = ref$7.TransportReturnCode;
var ref$8 = __webpack_require__(24);
var TransportSessionEventCode = ref$8.TransportSessionEventCode;
var ref$9 = __webpack_require__(146);
var WebSocketTransportSession = ref$9.WebSocketTransportSession;
var ref$10 = __webpack_require__(144);
var WebTransportEvent = ref$10.WebTransportEvent;
var ref$11 = __webpack_require__(250);
var WebTransportFSM = ref$11.WebTransportFSM;

/**
 * @classdesc
 * This class manages all the web based transport protocols.
 * <ul>
 *     <li>{@link TransportProtocol.HTTP_BASE64}
 *     <li>{@link TransportProtocol.HTTP_BINARY}
 *     <li>{@link TransportProtocol.HTTP_BINARY_STREAMING}
 *     <li>{@link TransportProtocol.WS_BINARY}
 * </ul>
 * @extends TransportBase
 * @private
 */
var WebTransport = (function (TransportBase) {
  function WebTransport(url, eventCB, client, props, getId) {
    TransportBase.call(this, url, eventCB, client, props);
    LOG_TRACE(("webTransportProtocolList " + (props.webTransportProtocolList)));
    this._transportHandler = new TransportProtocolHandler(url, props.webTransportProtocolList);
    this._webTransportFsm = new WebTransportFSM(this, getId);
    this._webTransportFsm.start();
  }

  if ( TransportBase ) WebTransport.__proto__ = TransportBase;
  WebTransport.prototype = Object.create( TransportBase && TransportBase.prototype );
  WebTransport.prototype.constructor = WebTransport;

  WebTransport.prototype.notifyEvent = function notifyEvent (event) {
    this._eventCB(event);
  };

  WebTransport.prototype.handleDestroyed = function handleDestroyed () {
    this._transportSession = null;
  };

  WebTransport.prototype.handleTransportEvent = function handleTransportEvent (transportEvent) {
    LOG_DEBUG(("Web transport receive transport event: " + transportEvent));
    var wEvent;
    switch (transportEvent.getTransportEventCode()) {
      case TransportSessionEventCode.UP_NOTICE:
        wEvent = new FsmEvent({ name: WebTransportEvent.UP_NOTICE });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.DESTROYED_NOTICE:
        this.handleDestroyed();
        wEvent = new FsmEvent({ name: WebTransportEvent.DESTROYED_NOTICE });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.SEND_ERROR:
        wEvent = new FsmEvent({ name: WebTransportEvent.SEND_ERROR });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.CONNECT_TIMEOUT:
        wEvent = new FsmEvent({ name: WebTransportEvent.CONNECT_TIMEOUT });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.DOWNGRADE_FAILED:
        this._lastDowngradeSucceeded = false;
        break;

      case TransportSessionEventCode.DOWNGRADE_SUCCEEDED:
        this._lastDowngradeSucceeded = true;
        break;

      default:
        // All other transport events have no effect on the web transport and are passed through
        this._eventCB(transportEvent);
    }
  };

  /**
   * @override
   */
  WebTransport.prototype.connect = function connect () {
    var wEvent = new FsmEvent({ name: WebTransportEvent.CONNECT });
    this._webTransportFsm.processEvent(wEvent);
    return TransportReturnCode.OK;
  };

  WebTransport.prototype.connectInternal = function connectInternal () {
    var this$1 = this;

    this._transportSession = null;
    var tpProtocol = this._transportHandler.getTransportProtocol();
    this._props.transportProtocol = tpProtocol;
    switch (tpProtocol) {
      case TransportProtocol.HTTP_BASE64:
      case TransportProtocol.HTTP_BINARY:
      case TransportProtocol.HTTP_BINARY_STREAMING:
        this._transportSession = new HTTPTransportSession(
          this._url,
          function (evt) { return this$1.handleTransportEvent(evt); },
          this._client,
          this._props
        );
        break;

      case TransportProtocol.WS_BINARY:
        this._transportSession = new WebSocketTransportSession(
          this._url,
          function (evt) { return this$1.handleTransportEvent(evt); },
          this._client,
          this._props
        );
        break;

      default:
        LOG_ERROR(("Web transport unrecognized TransportProtocol: " + tpProtocol));
        throw new OperationError(("No transport session provider for scheme: " + tpProtocol),
                                 ErrorSubcode.CONNECTION_ERROR,
                                 tpProtocol);
    }

    LOG_DEBUG(("Connect Transport " + tpProtocol));
    return this._transportSession.connect();
  };

  /**
   * @override
   */
  WebTransport.prototype.destroy = function destroy (msg, subcode) {
    var wEvent = new FsmEvent({ name: WebTransportEvent.DESTROY });
    wEvent._destroyMsg = msg;
    wEvent._subcode = subcode;
    this._webTransportFsm.processEvent(wEvent);
    return TransportReturnCode.OK;
  };

  /**
   * @param {String} msg The message associated with the downgrade
   * @param {ErrorSubcode} subcode The subcode associated with the downgrade
   * @returns {Boolean} `true` if there are downgrade options available. `false` otherwise.
   * @private
   */
  WebTransport.prototype.beginDowngrade = function beginDowngrade (msg, subcode) {
    if (this._transportHandler.canCompleteDowngrade()) {
      LOG_TRACE('Web transport downgrade');
      // Destroy the underlying transport session
      // This will asynchronously cause DESTROYED_NOTICE to be emitted.
      // The receiver can then call completeDowngrade, which will complete the downgrade.
      this.destroyInternal(msg, subcode);
      return true;
    }
    LOG_TRACE('Web transport downgrade rejected');
    return false;
  };

  WebTransport.prototype.completeDowngrade = function completeDowngrade () {
    if (!this._transportHandler.canCompleteDowngrade()) {
      return false;
    }
    return this._transportHandler.completeDowngrade();
  };

  WebTransport.prototype.destroyInternal = function destroyInternal (msg, subcode) {
    if (this._transportSession) {
      this._transportSession.destroy(msg, subcode);
    }
  };

  /**
   * @override
   */
  WebTransport.prototype.flush = function flush (callback) {
    return this._transportSession.flush(callback);
  };

  WebTransport.prototype.getConnError = function getConnError () {
    if (this._transportSession) {
      return this._transportSession._connError;
    }
    return null;
  };

  /**
   * @override
   */
  WebTransport.prototype.getInfoStr = function getInfoStr () {
    if (this._transportSession) {
      return this._transportSession.getInfoStr();
    }
    return 'Not connected.';
  };

  /**
   * @override
   */
  WebTransport.prototype.getTransportProtocol = function getTransportProtocol () {
    return this._transportHandler.getTransportProtocol();
  };

  /**
   * @override
   */
  WebTransport.prototype.getClientStats = function getClientStats () {
    if (this._transportSession) {
      return this._transportSession.getClientStats();
    }
    return null;
  };

  /**
   * @override
   */
  WebTransport.prototype.requestDowngrade = function requestDowngrade (msg, subcode) {
    LOG_TRACE('Creating downgrade request event');
    this._lastDowngradeSucceeded = undefined; // will be reset by handler for TS DOWNGRADE_ events
    var wEvent = new FsmEvent({ name: WebTransportEvent.DOWNGRADE });
    wEvent._downgradeMsg = msg;
    wEvent._subcode = subcode;
    this._webTransportFsm.processEvent(wEvent);
    return this._lastDowngradeSucceeded;
  };

  /**
   * @override
   */
  WebTransport.prototype.send = function send (message, forceAllowEnqueue) {
    return this._transportSession.send(message, forceAllowEnqueue);
  };

  return WebTransport;
}(TransportBase));

module.exports.WebTransport = WebTransport;


/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports.WebSocketCloseCodes = {
  0: {
    name:        'Unknown code',
    description: 'No status code was returned by the operation',
  },
  1000: {
    name:        'Normal Closure',
    description: 'The connection closed normally',
  },
  1001: {
    name:        'Going Away',
    description: 'The endpoint is going away due to a server failure or client navigation',
  },
  1002: {
    name:        'Protocol Error',
    description: 'A WebSocket protocol error occurred',
  },
  1003: {
    name:        'Unsupported Data',
    description: 'The endpoint cannot handle the specified data type',
  },
  1004: {
    name:        'Reserved',
    description: '',
  },
  1005: {
    name:        'No Status Recvd',
    description: 'Expected a status code but none was provided',
  },
  1006: {
    name:        'Abnormal Closure',
    description: 'No close frame was received before remote hangup',
  },
  1007: {
    name:        'Invalid Frame Payload Data',
    description: 'A message contained data inconsistent with its encoding',
  },
  1008: {
    name:        'Policy Violation',
    description: 'A message violated endpoint policy',
  },
  1009: {
    name:        'Message Too Big',
    description: 'A data frame was too large',
  },
  1010: {
    name:        'Missing Extension',
    description: 'The endpoint did not negotiate an expected extension',
  },
  1011: {
    name:        'Internal Error',
    description: 'The server encountered an unexpected condition that prevented it from fulfilling the request',
  },
  1012: {
    name:        'Service Restart',
    description: 'The server is restarting',
  },
  1013: {
    name:        'Try Again Later',
    description: 'The server is terminating the connection due to a temporary condition',
  },
  1014: {
    name:        'Bad Gateway',
    description: 'A gateway or proxy received an invalid response from the upstream server',
  },
  1015: {
    name:        'TLS Handshake',
    description: 'The connection was closed due to a failure to perform a TLS handshake',
  },
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(7);
var Check = ref.Check;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;

var APIPropertiesValidators = {
  validateInstance: function validateInstance(typeDesc, instance, name) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

    args.forEach(function (check) {
      var validator = check.shift();
      var validatorArgs = [typeDesc, instance, name ].concat( check);
      validator.apply(void 0, validatorArgs);
    });
  },

  valInstance: function valInstance(typeDesc, instance, name, typeInstance, typeInstanceDesc) {
    if (!Check.instanceOf(instance[name], typeInstance)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be instance of " + typeInstanceDesc));
    }
  },

  valNotEmpty: function valNotEmpty(typeDesc, instance, name) {
    if (Check.none(instance[name]) || instance[name] === '') {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot be empty."),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valLength: function valLength(typeDesc, instance, name, max) {
    if (Check.string(instance[name]) && instance[name].length > max) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' exceeded max length " + max),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valRange: function valRange(typeDesc, instance, name, min, max) {
    if (Check.number(instance[name]) && (instance[name] < min || instance[name] > max)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' out of range [" + min + "; " + max + "]."),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valString: function valString(typeDesc, instance, name) {
    if (!Check.string(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type string; was " + (typeof instance[name])),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valNumber: function valNumber(typeDesc, instance, name) {
    if (!Check.number(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type number; was " + (typeof instance[name])),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valBoolean: function valBoolean(typeDesc, instance, name) {
    var val = instance[name];
    if (!Check.boolean(val)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type boolean; was " + (typeof val)),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valIsMember: function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
    if ( allowNull === void 0 ) allowNull = false;

    var val = instance[key];
    if (allowNull && (val === null || val === undefined)) { return; }
    if (enumInstance.values.indexOf(val) >= 0) { return; }
    throw new OperationError((typeDesc + " validation: Property '" + key + "'=" + val + " must be a member of " + enumName),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
  },

  valStringOrArray: function valStringOrArray(typeDesc, instance, name) {
    var val = instance[name];
    if (typeof val !== 'string' && !Array.isArray(val)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be a string or array"),
                                ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valArrayIsMember: function valArrayIsMember(typeDesc, instance, name, enumInstance, enumName,
                   allowUndefined, allowEmpty, allowDuplicate) {
    var val = instance[name];
    if ((val === undefined || val === null)) {
      if (allowUndefined) {
        return;
      }
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }

    if (!Array.isArray(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
    if (!allowEmpty && instance[name].length === 0) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot be empty"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }

    instance[name].forEach(function (ele, index) {
      if (!enumInstance.values.includes(ele)) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' must be an array of " + enumName),
                                ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (!allowDuplicate) {
        if (instance[name].indexOf(ele, index + 1) >= 0) {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot have duplicate element value"),
                          ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      }
    });
  },

  valArrayOfString: function valArrayOfString(typeDesc, instance, name) {
    var val = instance[name];
    if (Check.something(val)) {
      if (!Array.isArray(val)) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                               ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      val.forEach(function (ele) {
        if (typeof ele !== 'string') {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' must be an array of string"),
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
      });
    }
  },

  valTopicString: function valTopicString(typedesc, instance, name) {
    // Pardon this late import. I need to break a circular dependency.
    // eslint-disable-next-line global-require
    var ref = __webpack_require__(5);
    var DestinationUtil = ref.DestinationUtil;
    var DestinationType = ref.DestinationType;
    module.exports.APIPropertiesValidators.valString(typedesc, instance, name);
    var val = instance[name];
    var result = DestinationUtil.validateAndEncode(DestinationType.TOPIC, val);
    if (result.error) {
      throw new OperationError(typedesc + " validation: Property '" + name + "' must be " +
                               "a valid topic string: " + (result.error),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valTopicStringOrEmpty: function valTopicStringOrEmpty(typedesc, instance, name) {
    var val = instance[name];
    if (val && val.length) {
      module.exports.APIPropertiesValidators.valTopicString(typedesc, instance, name);
    }
  },
};

module.exports.APIPropertiesValidators = APIPropertiesValidators;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var cloneObj = __webpack_require__(149);
var util = __webpack_require__(6);

var CLONE_CIRCULAR = false; // If true, handles circular references safely.
var CLONE_DEPTH = 1; // Don't deep-clone nested values.

/**
 * @memberof solace
 * @private
 */
var APIProperties = function APIProperties() {
  var options = [], len = arguments.length;
  while ( len-- ) options[ len ] = arguments[ len ];

  Object.assign.apply(Object, [ this ].concat( options ));
};

/**
 * Can be overridden.For instance sessionProperties
 * overrides this to suppress printing the password.
 * @returns {String} The string representation of this object
 * @private
 */
APIProperties.prototype.toString = function toString () {
  return util.inspect(this);
};

APIProperties.prototype.clone = function clone () {
  return cloneObj(this, CLONE_CIRCULAR, CLONE_DEPTH);
};

module.exports.APIProperties = APIProperties;


/***/ }),
/* 256 */
/***/ (function(module, exports) {

function flatten(array) {
  return array.reduce(function (acc, el) { return acc.concat(Array.isArray(el) ? flatten(el) : el); }, []);
}

function includes(array, el) {
  return array.some(function (v) { return v === el; });
}

module.exports.ArrayUtils = {
  flatten: flatten,
  includes: includes,
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {


var WINDOWS_VERSION_MAP = {
  '6.4':  '10.0',
  '6.3':  '8.1',
  '6.2':  '8',
  '6.1':  '7',
  '6.0':  'Vista',
  '5.2':  'Server 2003',
  '5.1':  'XP',
  '5.01': '2000 SP1',
  '5.0':  '2000',
  '4.0':  '4.0',
};

var NODE_OS_TYPES = {
  Darwin:     'OSX',
  Windows_NT: 'Windows',
};

var context = typeof window !== 'undefined' ? window : global;

var DEFAULT = {
};

var NODE_PROCESS = {
  product:  'solclientjs',
  platform: 'node',
  agent:    'node',
  process:  context.process,
};

// Worst case fallbacks
var BROWSER_PROCESS = {
  product:  'solclientjs',
  platform: 'unknown',
  agent:    'Gecko',
};

function getBrowserAgentInfo() {
  /* eslint-env browser */
  var navObj = typeof navigator !== 'undefined' ? navigator : null;
  if (!navObj) { return null; }
  var agentStr = navigator.userAgent;

  // Execute these regex checks against the user agent string in this order.
  // The earlier browsers have a lot of impersonation substrings in their user
  // agent list so we positively test for them before considering the browsers
  // that are frequently impersonated.
  var browsers = [
    ['edge', /Edge\/([0-9._]+)/],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9.]+)(?:\s|$)/],
    ['opera', /Opera\/([0-9.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9.]+)(:?\s|$)$/],
    ['ie', /Trident\/7\.0.*rv:([0-9.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9.]+);.*Trident\/[4-8].0/], // Edit: IE11 in IE9 emu mode uses Trident 8
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9.]+)/],
    ['android', /Android\s([0-9.]+)/],
    ['ios', /Version\/([0-9._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9._]+).*Safari/] ];

  var agentInfo = {
    browser:  { name: 'unknown', version: '0.0.0' },
    platform: { os: 'unknown', arch: 'unknown', version: 'unknown' },
  };

  var agentHas = function () {
    var strs = [], len = arguments.length;
    while ( len-- ) strs[ len ] = arguments[ len ];

    return strs.some(function (str) { return agentStr.indexOf(str) >= 0; });
  };
  var firstValue = function () {
    var vals = [], len = arguments.length;
    while ( len-- ) vals[ len ] = arguments[ len ];

    return vals.filter(Boolean).shift();
  };

  Object.assign(
    agentInfo, // start with fallbacks above
    // 1. Run the callback below for each browser name/regex-rule pair.
    // 2. Decompose the pair into variables called `key` and `rule`.
    browsers.map(function (ref) {
      var key = ref[0];
      var rule = ref[1];

      // 3. Skip if the rule doesn't match the user agent string.
      if (!rule.test(agentStr)) { return false; }
      // 4. Get the matches for the rule.
      var match = rule.exec(agentStr);
      // 5. Extract the version from match group 1.
      var versionStrs = match && match[1].split(/[._]/).slice(0, 3);
      // 6. Convert the version strings to numbers.
      var version = versionStrs.map(function (str) { return parseInt(str, 10); });
      // 7. Ensure our version tuple is length 3 by appending 0 elements.
      while (version.length < 3) { version.push(0); }
      // 8. Return an agentInfo object in the same form as above, consuming the version array.
      return { browser: { name: key, version: version.join('.') } };
    }).filter(Boolean).shift()); // 9. Filter out anything that returned `false` (#3)...
    // 10. ...and return the first element.

  // Now try to extract platform info
  var os = firstValue(
    agentHas('Windows Phone') && 'WindowsPhone',
    agentHas('Windows') && 'Windows',
    agentHas('Linux') && 'Linux',
    agentHas('like Mac OS X') && 'iOS',
    agentHas('OS X') && 'OSX',
    agentHas('Android', 'Adr') && 'Android',
    agentHas('BB10', 'RIM Tablet OS', 'BlackBerry') && 'BlackBerry'
  );
  var versionTests = {
    'Windows': function () { return firstValue(
      agentHas('Win16') && '3.1.1',
      agentHas('Windows CE') && 'CE',
      agentHas('Windows 95') && '4.00.950',
      agentHas('Windows 98; Win 9x 4.90') && '4.90',
      agentHas('Windows 98') && '4.10',
      (function () {
        // Look in the first set of parentheses for a version string key.
        // This will fail when Windows 16 comes out
        var parenParts = agentStr.match(/\(.+?\)/);
        var versionPart = parenParts[0];
        if (!versionPart) { return false; }
        var versionMatch = function (str) { return versionPart.indexOf(str) >= 0; };
        return firstValue.apply(void 0, Object.keys(WINDOWS_VERSION_MAP).map(function (k) { return versionMatch(k) && WINDOWS_VERSION_MAP[k]; }));
      })()
    ); },
    'OSX':        function () { return agentStr.match(/OS X ((\d+[._])+\d+)\b/)[1]; },
    'Linux':      function () { return ''; },
    'iOS':        function () { return agentStr.match(/OS ((\d+[._])+\d+) like Mac OS X/)[1]; },
    'Android':    function () { return agentStr.match(/(?:Android|Adr) ((\d+[._])+\d_)/)[1]; },
    'BlackBerry': function () { return agentStr.match(/(?:Version\/|RIM Tablet OS )((\d+\.)+\d+)/)[1]; },
  };
  var versionTest = versionTests[os];
  agentInfo.platform.os = os || 'Unknown';
  agentInfo.platform.version = (versionTest && versionTest() || '0.0.0').replace(/_/g, '.');
  return agentInfo;
}
/* eslint-env shared-browser-node */

try {
  if (context.navigator) {
    // These are historical defaults
    var safeEncode = function (str) { return str.replace(/[^a-zA-Z0-9_/.]/g, '-'); };
    Object.assign(BROWSER_PROCESS, {
      platform:    context.navigator.platform,
      agent:       context.navigator.product,
      description: safeEncode(context.navigator.userAgent),
      navigator:   context.navigator,
    });
    var browserAgentInfo = getBrowserAgentInfo();
    if (browserAgentInfo) {
      BROWSER_PROCESS.agent = safeEncode(((browserAgentInfo.browser.name) + "-" + (browserAgentInfo.browser.version)));
      BROWSER_PROCESS.platform = (BROWSER_PROCESS.agent) + "-" + (safeEncode(
        ((browserAgentInfo.platform.os) + "-" + (browserAgentInfo.platform.version))));
    }
  }
  if (context.process) {
    var os = __webpack_require__(289); // eslint-disable-line global-require
    var ostype = os.type();
    var osname = NODE_OS_TYPES[ostype] || ostype || 'unknown';
    var nodeVersionStr = "node-" + (process.version.substr(1));
    Object.assign(NODE_PROCESS, {
      platform:    (nodeVersionStr + "-" + osname + "-" + (os.release()) + "-" + (os.arch())),
      agent:       nodeVersionStr,
      description: nodeVersionStr,
    });
  }
} catch (ex) {
  // Fall back to defaults
}

var Process = Object.assign({}, DEFAULT,
                               false ? BROWSER_PROCESS : {},
                               true ? NODE_PROCESS : {});

module.exports.Process = Process;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(147);
var StringBuffer = ref.StringBuffer;

var PAD_LEFT = 0;
var PAD_RIGHT = 1;

var LUT_PRINTABLE = (function () {
  var tmp = [];
  for (var c = 0; c < 256; ++c) {
    tmp[c] = (c < 33 || c > 126) ? '.' : String.fromCharCode(c);
  }
  return tmp;
})();

function padLeftRight(str, minLen, padSide, padChar) {
  if ( padChar === void 0 ) padChar = ' ';

  if (typeof str !== 'string') {
    return str;
  }
  if (str.length >= minLen) {
    return str;
  }

  var buf = new StringBuffer();
  for (var i = 0; i < (minLen - str.length); i++) {
    buf.append(padChar.charAt(0));
  }
  switch (padSide) {
    case PAD_LEFT:
      return ("" + buf + str);
    case PAD_RIGHT:
      return ("" + str + buf);
    default:
      return str;
  }
}

function leastSpaces(length, line) {
  if (!line.length) { return length; }
  var spaces = line.match(/^\s*/)[0].length;
  return spaces < length ? spaces : length;
}

function capitalizeWord(str) {
  return ("" + (str.charAt(0).toUpperCase()) + (str.substr(1)));
}

/**
 * @private
 * @type {StringUtils}
 */
var StringUtils = {

  capitalize: function capitalize(str) {
    if (!(str && str.length)) {
      return str;
    }

    return str.split(' ').map(capitalizeWord).join(' ');
  },

  isEmpty: function isEmpty(str) {
    return (
      str === undefined ||
      str === null ||
      str.length === 0
    );
  },

  notEmpty: function notEmpty(str) {
    return !(this.isEmpty(str));
  },

  toSafeChars: function toSafeChars(str) {
    return str.replace(/[^a-zA-Z0-9_/.]/g, '');
  },

  padLeft: function padLeft(str, minLen, padChar) {
    return padLeftRight(str, minLen, PAD_LEFT, padChar);
  },

  padRight: function padRight(str, minLen, padChar) {
    return padLeftRight(str, minLen, PAD_RIGHT, padChar);
  },

  nullTerminate: function nullTerminate(str) {
    if (str === null || str === undefined) {
      throw new Error('non str in nullTerminate');
    }
    var lastChar = str.charCodeAt(str.length - 1);
    if (lastChar === 0) {
      return str;
    }
    return str + String.fromCharCode(0x00);
  },

  stripNullTerminate: function stripNullTerminate(str) {
    if (str === null || str === undefined) {
      throw new Error('null str in stripNullTerminate');
    }
    var lastChar = str.charCodeAt(str.length - 1);
    if (lastChar === 0) {
      return str.substr(0, str.length - 1);
    }
    return str;
  },

  hexdump: function hexdump(s) {
    var this$1 = this;

    var output = new StringBuffer();
    var printable = new StringBuffer();
    var spacer = function (pos) { return (pos === 8 || pos === 16 ? '  ' : ' '); };
    var linelen = 0;
    for (var i = 0, sLength = s.length; i < sLength; i++) {
      var ccode = s.charCodeAt(i);
      output.append(this$1.padLeft(ccode.toString(16), 2));
      printable.append(LUT_PRINTABLE[ccode] || '.');
      output.append(spacer(++linelen));

      if (i === s.length - 1) {
        // input finished: complete the line
        while (linelen < 16) {
          output.append(("  " + (spacer(++linelen))));
        }
      }

      if (linelen === 16) {
        output.append(printable.join(''));
        output.append('\n');
        linelen = 0;
        printable.clear();
      }
    }
    return output.toString();
  },

  /**
   * Use heredoc`....` to create multi-line heredoc strings. Leading blank lines are removed, as are
   * leading spaces, up to the number of spaces on the least-indented line.
   * @param {String} literals The document template
   * @param {...String} substitutions The substitutions to make in the document
   * @returns {String} The interpolated representation of the document
   */
  heredoc: function heredoc(literals) {
    var substitutions = [], len = arguments.length - 1;
    while ( len-- > 0 ) substitutions[ len ] = arguments[ len + 1 ];

    var subst = substitutions.concat( ['']);
    var lines = literals.map(function (k) { return k + subst.shift(); })
      .join('')
      .split(/\r?\n/);
    var spaces = lines.length === 1 ? 0 : lines.reduce(leastSpaces, Infinity);
    while (lines[0] === '') {
      lines.shift();
    }
    return lines.map(function (line) { return line.substring(spaces); }).join('\n');
  },
};

module.exports.StringUtils = StringUtils;


/***/ }),
/* 259 */
/***/ (function(module, exports) {

var TimingBucket = function TimingBucket(name, interval) {
  this.name = name;
  this.interval = interval;
  this.buckets = [];
};

var prototypeAccessors = { bucketCount: {} };

prototypeAccessors.bucketCount.get = function () {
    var this$1 = this;

  var c = 0;
  for (var i = 0, n = this.buckets.length; i < n; ++i) {
    c += this$1.buckets[i] || 0;
  }
  return c;
};

TimingBucket.prototype.log = function log (v) {
  if (v === undefined || isNaN(v)) {
    return;
  }
  var normalized = Math.floor(v / this.interval) * this.interval;
  this.buckets[normalized] = this.buckets[normalized] || 0;
  this.buckets[normalized]++;
};

TimingBucket.prototype.toString = function toString () {
    var this$1 = this;

  var cont = [];
  this.buckets.forEach(function (i) {
    cont.push((i + ": " + (this$1.buckets[i])));
  });
  return ("{" + (cont.join(', ')) + "}");
};

Object.defineProperties( TimingBucket.prototype, prototypeAccessors );

module.exports.TimingBucket = TimingBucket;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
var parseURL;
if (true) {
  /* eslint-env node */
  parseURL = __webpack_require__(291).parse;
} else {
  /* eslint-env browser */
  var scope = typeof window !== 'undefined' ? window : this;
  require('./browser-url-polyfill')(scope);
  parseURL = function makeURL() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return new (Function.prototype.bind.apply( URL, [ null ].concat( args) ));
  };
}

module.exports.parseURL = parseURL;


/***/ }),
/* 261 */
/***/ (function(module, exports) {

// TODO: consider using high-precision timer from performance
//       or consider using a JS library, such as uuid-js

function generateUUID() { // Public Domain/MIT
  var d = new Date().getTime();
  // if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
  //   d += performance.now(); //use high-precision timer if available
  // }


  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

module.exports.UUID = {
  generateUUID: generateUUID,
};


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var VERSION = "10.1.0" || '0.0.0-source';
// Parse the date if provided. Was seeing NaN formatted dates in source mode, so add fallback
var DATE =  true
  ? new Date(Date.parse("Mon Jul 30 2018 14:55:10 GMT-0400 (EDT)"))
  : new Date();
var MODE = "DEBUG";

// These property names are all for export, so make sure they're not mangled
var TARGET = {
  'name':    "node",
  'node':    true,
  'browser': false,
};

var FORMATTED_DATE = (function () {
  var pad = function (n) { return (n < 10 ? ("0" + n) : n); };
  var d = DATE;
  var YYYY = d.getFullYear();
  var MM = pad(d.getMonth() + 1);
  var DD = pad(d.getDate());
  var hh = pad(d.getHours());
  var mm = pad(d.getMinutes());
  return (YYYY + "/" + MM + "/" + DD + " " + hh + ":" + mm);
})();
var SUMMARY = ['SolclientJS', "10.1.0", MODE, FORMATTED_DATE].join(', ');

/**
 * Returns the API version. Use version, date and mode properties for build details.
 * Use the summary property or the .toString() method to return a summary.
 * @static
 * @type {Object}
 * @namespace
 * @memberof solace
 */
var Version = {
  /**
   * The API version, as an informational string. The format of this string is subject to change.
   * @type {String}
   */
  'version':       VERSION,
  /**
   * The API build date.
   * @type {Date}
   */
  'date':          DATE,
  /**
   * The API build date, as a formatted string.
   * The format of this date is:
   * `YYYY-MM-DD hh:mm`
   * where
   *  * `YYYY` is the 4-digit year,
   *  * `MM` is the 2-digit month   (01-12),
   *  * `DD` is the 2-digit day     (01-31),
   *  * `hh` is the 2-digit hour    (00-23),
   *  * `mm` is the 2-digit minute  (00-59)
   *
   * @type {String}
   */
  'formattedDate': FORMATTED_DATE,
  /**
   * Information about the build target. This object is informational; its type, structure and
   * content are subject to change.
   * @type {Object}
   */
  'target':        TARGET,
  /**
   * The build mode. This may be one of 'debug' or 'release'. Other build modes may be added
   * in the future.
   * @type {String}
   */
  'mode':          MODE,
  /**
   * If `true`, this is an unoptimized debug build.
   * @type {Boolean}
   */
  'debug':         true,
  /**
   * If `true`, this is an optimized release build. Note that there may be multiple release
   * builds in a distribution, with varying degrees of optimization.
   * @type {Boolean}
   */
  'release':       false,
  /**
   * An informational string summarizing the API name, version and build date.
   * @type {String}
   */
  'summary':       SUMMARY,

  toString: function toString() {
    return SUMMARY;
  },
};
module.exports.Version = Version;


/***/ }),
/* 263 */
/***/ (function(module, exports) {

var EPSILON = 1e6;

/**
 * @param {Array} arr The array to flatten
 * @returns {Array} A maximally flattened array. The original array is not modified.
 * @private
 */
function flatten(arr) {
  return arr.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []);
}

/**
 * @private
 */
var BaseChecks = (function () {
  var result = {
    /**
     * Checks whether a value is undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined or null.
     *
     * @private
     */
    nothing: function nothing(value) {
      return (value === undefined || value === null);
    },

    /**
     * Checks whether a value is anything, i.e. not undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True unless the value is undefined or null.
     *
     * @private
     */
    anything: function anything(value) {
      return !BaseChecks.nothing(value);
    },

    /**
     * Checks whether a value is undefined. Uses the conservative
     * typeof check for compatibility with particularly ill-behaved
     * libraries that redefine <code>undefined</code>.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined.
     *
     * @private
     */
    undefined: function undefined(value) {
      return typeof value === 'undefined';
    },

    /**
     * Checks whether a value is defined. This is true for any value with
     * a type that is not 'undefined'.
     *
     * @param {any} value The value to check
     * @returns {Boolean} True if the value is defined.
     *
     * @private
     */
    defined: function defined(value) {
      return !BaseChecks.undefined(value);
    },

    /**
     * Checks whether a value is an array.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an array.
     *
     * @private
     */
    array: function array(value) {
      return BaseChecks.anything(value) && Array.isArray(value);
    },

    /**
     * Checks whether a value is an object. If a value is an array, it is not an object.
     * If a value is null, it is not an object.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an object (and not an array).
     *
     * @private
     */
    object: function object(value) {
      return (!BaseChecks.array(value) &&
              value !== null &&
              (typeof value === 'object' || value instanceof Object));
    },

    /**
     * Checks whether a value is an instance of the given type.
     *
     * @param   {*} val The value to check.
     * @param   {Object} type The type to check.
     *
     * @returns {Boolean} True if type is in value's prototype chain.
     *
     * @private
     */
    instanceOf: function instanceOf(val, type) {
      return BaseChecks.object(val) && val instanceof type;
    },

    /**
     * Checks whether a value's typeof is equal to the given type string.
     *
     * @param {*} val The value to check.
     * @param {String} type The type string for comparison.
     *
     * @returns {Boolean} True if typeof(val) == type
     *
     * @private
     */
    type: function type(val, type$1) {
      return typeof val === type$1; /* dynamic */ // eslint-disable-line valid-typeof
    },

    /**
     * Checks whether a value is an instance of any of the given types.
     *
     * @param   {*} val The value to check.
     * @param   {Object} types The types to check.
     *
     * @returns {Boolean} True if any element of types is in val's prototype chain.
     *
     * @private
     */
    instanceOfAny: function instanceOfAny(val) {
      var types = [], len = arguments.length - 1;
      while ( len-- > 0 ) types[ len ] = arguments[ len + 1 ];

      return (BaseChecks.array(types) &&
              flatten(types).some(function (type) { return BaseChecks.instanceOf(val, type); }));
    },

    /**
     * Checks whether the given value is empty.
     *
     * Emptiness is determined using the following checks:
     *
     * <ol>
     *  <li>If an object is nothing, it is empty.</li>
     *  <li>If it is an object, and it has no keys of its own, it is empty.</li>
     *  <li>If it has a length property, it is empty if length === 0.</li>
     *  <li>If none of the above apply, the object is not empty.</li>
     * </ol>
     *
     * @param   {*} val The value to check.
     *
     * @returns {Boolean} True if the value is empty.
     *
     * @private
     */
    empty: function empty(val) {
      if (BaseChecks.nothing(val)) { return true; }
      if (BaseChecks.object(val)) {
        if (Object.keys(val).length === 0) {
          return true;
        }
      }
      if (val.length === 0) {
        return true;
      }
      return false;
    },

    /**
     * A user-defined check.
     *
     * @param   {*} val The value to check
     * @param   {Function} fn The function(val) to use.
     *
     * @returns {Boolean} The result of the function, coerced to a boolean.
     *
     * @private
     */
    truthy: function truthy(val, fn) {
      return !!fn(val);
    },

    rangeGe: function rangeGe(val, rangeMinInclusive) {
      return val >= rangeMinInclusive;
    },

    rangeGt: function rangeGt(val, rangeMin) {
      return val > rangeMin;
    },

    rangeLe: function rangeLe(val, rangeMaxInclusive) {
      return val <= rangeMaxInclusive;
    },

    rangeLt: function rangeLt(val, rangeMax) {
      return val < rangeMax;
    },

    rangeCompare: function rangeCompare(val, operator, operand) {
      var args = [], len = arguments.length - 3;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

      switch (operator) {
        case '=':
        case '==':
        case '===':
          return val === operand;
        case '~=':
        case '=~':
          {
            var epsilon = args[0] || EPSILON;
            return Math.abs(val - operand) < epsilon;
          }
        case '<':
          return val < operand;
        case '<=':
          return val <= operand;
        case '>':
          return val > operand;
        case '>=':
          return val >= operand;
        default:
          throw new Error(("Illegal operator for rangeCompare: " + operator));
      }
    },

    NaN: function NaN(val) {
      return Number.isNaN(val);
    },

    /**
     * Checks whether val is included in the object. If obj is an array, val is included if
     * val is an element of the array. Otherwise, if obj is an object, val is included if
     * val is one of the keys of obj.
     *
     * @param   {*} val The value to test
     * @param   {*} obj The object to test
     *
     * @returns {Boolean} True if the value is included in the object
     */
    included: function included(val, obj) {
      if (BaseChecks.nothing(obj)) {
        return false;
      }
      if (obj.includes) {
        return obj.includes(val);
      }
      if (Array.isArray(obj)) {
        // Not exactly Array.prototype.includes, which uses SameValueZero (+0 == -0)
        return obj.indexOf(val) >= 0;
      }
      if (BaseChecks.object(obj)) {
        var keys = Object.keys(obj);
        return BaseChecks.included(val, keys);
      }
      return false;
    },

    /**
     * Checks whether val is equal to expected.
     *
     * @param {any} val The value to check.
     * @param {any} expected The expected value.
     * @returns {Boolean} True if the value was equal to the expected value.
     */
    equal: function equal(val, expected) {
      return val === expected;
    },

    /**
     * Checks whether the given value appears as an attribute value in the given attributes object,
     * e.g. whether an enumeration contains the given value. If the attributes object is an array,
     * the array membership check {@link #included} is used instead.
     *
     * @param   {*} val The value to check.
     * @param   {Object} obj The object with attributes to check.
     *
     * @returns {Boolean} True if attrs has any attribute equal to val.
     */
    member: function member(val, obj) {
      return (BaseChecks.anything(obj) &&
              (BaseChecks.array(obj)
                ? BaseChecks.included(val, obj)
                : Object.keys(obj).some(function (k) { return obj[k] === val; }))
      );
    },

    boolean: function boolean(v) {
      return BaseChecks.type(v, 'boolean');
    },

    number: function number(v) {
      return BaseChecks.type(v, 'number');
    },

    string: function string(v) {
      return BaseChecks.type(v, 'string');
    },

    function: function function$1(v) {
      return BaseChecks.type(v, 'function');
    },
  };

  /**
   * Checks whether an object is none. This is the same check as <code>nothing</code>
   * @see {@link nothing}
   */
  result.none = result.nothing;

  /**
   * Checks whether an object is something. This is the same check as <code>anything</code>
   */
  result.something = result.anything;

  // Add check-loosening suffixes, (t | null), (t | undefined) and (t | null | undefined).
  // Do the t check last, just in case it is not (null | undefined) safe.
  Object.keys(result).forEach(function (key) {
    /**
     * .orNull checks. These are equivalent to the similarly named check, but also pass if the value
     * supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orNull = function orNull(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return val === null || result[key].apply(result, [ val ].concat( args ));
    };

    /**
     * .orUndefined checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orUndefined = function orUndefined(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return val === undefined || result[key].apply(result, [ val ].concat( args ));
    };

    /**
     * .orNothing checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was null or undefined.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orNothing = function orNothing(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return result.nothing(val) || result[key].apply(result, [ val ].concat( args ));
    };
  });

  return result;
})();

module.exports.BaseChecks = BaseChecks;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(148);
var Check = ref.Check;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;

var NO_OBJ = {}; // anonymous object

function objectValues(object) {
  return Object.keys(object).map(function (k) { return object[k]; });
}

function subcodeSummary(subcode, expected, got) {
  if ( expected === void 0 ) expected = null;
  if ( got === void 0 ) got = NO_OBJ;

  var expectedStr = expected ? ("; expected: " + expected) : '';
  var gotStr = got !== NO_OBJ ? ("; got: " + got) : '';
  switch (subcode) {
    case ErrorSubcode.PARAMETER_INVALID_TYPE:
      return ("Parameter type was invalid" + expectedStr + gotStr);
    default:
      return ErrorSubcode.nameOf(subcode).toLowerCase().replace(/_/, ' ') + expectedStr;
  }
}

function validateError(name, subcode, message) {
  throw new OperationError(("Parameter " + name + " failed validation"), subcode, message);
}

function validate(name, subcode, message, check, value) {
  var validatorArgs = [], len = arguments.length - 5;
  while ( len-- > 0 ) validatorArgs[ len ] = arguments[ len + 5 ];

  if (!check.apply(void 0, [ value ].concat( validatorArgs ))) {
    return validateError(name, subcode, message);
  }
  return value;
}

var typename = function (x) { return x && x.constructor && x.constructor.name || typeof x; };

/**
 * The Check object is a powerful validation API but it is partially built at runtime by composing
 * functions, and it requires significant boilerplate for parameter validation.
 *
 * The Parameter API expresses concrete validations using the Check API, returning values on success
 * and throwing the appropriate SDK exception on failure. It would be tempting to try to
 * automatically build a Parameter method for every Check method, but this would make Parameter
 * difficult to understand and use.
 *
 * @private
 */
var Parameter = {

  isArray: function isArray(name, value,
          subcode,
          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'array', value);

    return validate(name, subcode, message, Check.isArray, value);
  },

  isBoolean: function isBoolean(name, value,
            subcode,
            message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'boolean', value);

    return validate(name, subcode, message, Check.boolean, value);
  },

  isBooleanOrNothing: function isBooleanOrNothing(name, value,
                     subcode,
                     message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'boolean or nothing', value);

    return validate(name, subcode, message, Check.boolean.orNothing, value);
  },

  isEnumMember: function isEnumMember(name, value, memberOfEnum,
               subcode,
               message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
                subcode,
                ("one of [" + (memberOfEnum.names.join(', ')) + "]"),
                value);

    return validate(name, subcode, message, Check.member, value, memberOfEnum);
  },

  isEnumMemberOrNothing: function isEnumMemberOrNothing(name, value, memberOfEnum,
                        subcode,
                        message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
                subcode,
                ("one of [" + (memberOfEnum.names.join(', ')) + "]"),
                value);

    return validate(name, subcode, message, Check.member.orNothing, value, memberOfEnum);
  },

  isFunction: function isFunction(name, value,
             subcode,
             message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'function', value);

    return validate(name, subcode, message, Check.function, value);
  },

  isFunctionOrNothing: function isFunctionOrNothing(name, value,
                      subcode,
                      message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'function or nothing', value);

    return validate(name, subcode, message, Check.function.orNothing, value);
  },

  isInstanceOf: function isInstanceOf(name, value, instanceOf,
               subcode,
               message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, instanceOf.name, typename(value));

    return validate(name, subcode, message, Check.instanceOf, value, instanceOf);
  },

  isInstanceOfOrNothing: function isInstanceOfOrNothing(name, value, instanceOf,
                        subcode,
                        message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                                 ((instanceOf.name) + " or nothing"),
                                                 typename(value));

    return validate(name, subcode, message, Check.instanceOf.orNothing, value, instanceOf);
  },

  isInstanceOfOrNull: function isInstanceOfOrNull(name, value, instanceOf,
                     subcode,
                     message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                              ((instanceOf.name) + " or null"),
                                              typename(value));

    return validate(name, subcode, message, Check.instanceOf.orNull, value, instanceOf);
  },

  isInstanceOfOrUndefined: function isInstanceOfOrUndefined(name, value, instanceOf,
                          subcode,
                          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                                   ((instanceOf.name) + " or undefined"),
                                                   typename(value));

    return validate(name, subcode, message, Check.instanceOf.orUndefined, value, instanceOf);
  },

  isMember: function isMember(name, value, memberOf,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
            subcode,
            ("one of " + (memberOf.name) + ".[" + (objectValues(memberOf).join(', ')) + "]"),
            value);

    return validate(name, subcode, message, Check.member, value, memberOf);
  },

  isNumber: function isNumber(name, value,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number', value);

    return validate(name, subcode, message, Check.number, value);
  },

  isNumberOrNothing: function isNumberOrNothing(name, value,
                    subcode,
                    message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number or nothing', value);

    return validate(name, subcode, message, Check.number.orNothing, value);
  },

  isNumberOrNull: function isNumberOrNull(name, value,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number or null', value);

    return validate(name, subcode, message, Check.number.orNull, value);
  },

  isRangeCompare: function isRangeCompare(name, value, operator, operand,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, (operator + " " + operand), value);

    return validate(name, subcode, message, Check.rangeCompare, value, operator, operand);
  },

  isRangeCompareOrNothing: function isRangeCompareOrNothing(name, value, operator, operand,
                          subcode,
                          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, (operator + " " + operand + " or nothing"), value);

    return validate(name, subcode, message,
                    Check.rangeCompare.orNothing, value, operator, operand);
  },

  isStringOrNull: function isStringOrNull(name, value,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string or null', value);

    return validate(name, subcode, message, Check.string.orNull, value);
  },


  isString: function isString(name, value,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string', value);

    return validate(name, subcode, message, Check.string, value);
  },

  isStringOrNothing: function isStringOrNothing(name, value,
                    subcode,
                    message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string or nothing', value);

    return validate(name, subcode, message, Check.string.orNothing, value);
  },

  isValue: function isValue(name, value, expected,
          subcode,
          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, ("must be " + value));

    return validate(name, subcode, message, Check.equal, value, expected);
  },

};

module.exports.Parameter = Parameter;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {


function propertySpec(value, spec) {
  return Object.assign(
    { value: value }, 
    spec.indexOf('c') >= 0 ? { configurable: true } : {},
    spec.indexOf('e') >= 0 ? { enumerable: true }   : {},
    spec.indexOf('w') >= 0 ? { writable: true }     : {}
  );
}

var solace = __webpack_require__(151);
try {
  /*****************************************
 * solace namespace
 *****************************************/


// --------------------------
// solace.AbstractQueueDescriptor
// --------------------------
solace['AbstractQueueDescriptor'] = solace.AbstractQueueDescriptor;
Object.defineProperty(solace.AbstractQueueDescriptor.prototype, 'getType', propertySpec(solace.AbstractQueueDescriptor.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.AbstractQueueDescriptor.prototype, 'isDurable', propertySpec(solace.AbstractQueueDescriptor.prototype.isDurable, 'cw')); // GDP
// --------------------------
// solace.AuthenticationScheme
// --------------------------
solace['AuthenticationScheme'] = solace.AuthenticationScheme;
solace.AuthenticationScheme._setCanonical({"BASIC":"AuthenticationScheme_basic","CLIENT_CERTIFICATE":"AuthenticationScheme_clientCertificate","AUTHENTICATION_SCHEME_BASIC":"AuthenticationScheme_basic","AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE":"AuthenticationScheme_clientCertificate"}, true);
Object.defineProperty(solace.AuthenticationScheme, 'describe', propertySpec(solace.AuthenticationScheme.describe, 'cw')); // GDP
Object.defineProperty(solace.AuthenticationScheme, 'nameOf', propertySpec(solace.AuthenticationScheme.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheCBInfo
// --------------------------
solace['CacheCBInfo'] = solace.CacheCBInfo;
Object.defineProperty(solace.CacheCBInfo.prototype, 'getCallback', propertySpec(solace.CacheCBInfo.prototype.getCallback, 'cw')); // GDP
Object.defineProperty(solace.CacheCBInfo.prototype, 'getUserObject', propertySpec(solace.CacheCBInfo.prototype.getUserObject, 'cw')); // GDP
// --------------------------
// solace.CacheLiveDataAction
// --------------------------
solace['CacheLiveDataAction'] = solace.CacheLiveDataAction;
solace.CacheLiveDataAction._setCanonical({"FULFILL":1,"QUEUE":2,"FLOW_THRU":3}, true);
Object.defineProperty(solace.CacheLiveDataAction, 'describe', propertySpec(solace.CacheLiveDataAction.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheLiveDataAction, 'nameOf', propertySpec(solace.CacheLiveDataAction.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheRequestResult
// --------------------------
solace['CacheRequestResult'] = solace.CacheRequestResult;
Object.defineProperty(solace.CacheRequestResult.prototype, 'getReturnCode', propertySpec(solace.CacheRequestResult.prototype.getReturnCode, 'cw')); // GDP
Object.defineProperty(solace.CacheRequestResult.prototype, 'getReturnSubcode', propertySpec(solace.CacheRequestResult.prototype.getReturnSubcode, 'cw')); // GDP
Object.defineProperty(solace.CacheRequestResult.prototype, 'getTopic', propertySpec(solace.CacheRequestResult.prototype.getTopic, 'cw')); // GDP
// --------------------------
// solace.CacheReturnCode
// --------------------------
solace['CacheReturnCode'] = solace.CacheReturnCode;
solace.CacheReturnCode._setCanonical({"OK":1,"FAIL":2,"INCOMPLETE":3}, true);
Object.defineProperty(solace.CacheReturnCode, 'describe', propertySpec(solace.CacheReturnCode.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheReturnCode, 'nameOf', propertySpec(solace.CacheReturnCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheReturnSubcode
// --------------------------
solace['CacheReturnSubcode'] = solace.CacheReturnSubcode;
solace.CacheReturnSubcode._setCanonical({"REQUEST_COMPLETE":0,"LIVE_DATA_FULFILL":1,"ERROR_RESPONSE":2,"INVALID_SESSION":3,"REQUEST_TIMEOUT":4,"REQUEST_ALREADY_IN_PROGRESS":5,"NO_DATA":6,"SUSPECT_DATA":7,"CACHE_SESSION_DISPOSED":8,"SUBSCRIPTION_ERROR":9}, true);
Object.defineProperty(solace.CacheReturnSubcode, 'describe', propertySpec(solace.CacheReturnSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheReturnSubcode, 'nameOf', propertySpec(solace.CacheReturnSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheSession
// --------------------------
solace['CacheSession'] = solace.CacheSession;
Object.defineProperty(solace.CacheSession.prototype, 'getProperties', propertySpec(solace.CacheSession.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.CacheSession.prototype, 'sendCacheRequest', propertySpec(solace.CacheSession.prototype.sendCacheRequest, 'cw')); // GDP
// --------------------------
// solace.CacheSessionProperties
// --------------------------
solace['CacheSessionProperties'] = solace.CacheSessionProperties;
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getCacheName', propertySpec(solace.CacheSessionProperties.prototype.getCacheName, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setCacheName', propertySpec(solace.CacheSessionProperties.prototype.setCacheName, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getMaxMessageAgeSec', propertySpec(solace.CacheSessionProperties.prototype.getMaxMessageAgeSec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setMaxMessageAgeSec', propertySpec(solace.CacheSessionProperties.prototype.setMaxMessageAgeSec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getMaxMessages', propertySpec(solace.CacheSessionProperties.prototype.getMaxMessages, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setMaxMessages', propertySpec(solace.CacheSessionProperties.prototype.setMaxMessages, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getTimeoutMsec', propertySpec(solace.CacheSessionProperties.prototype.getTimeoutMsec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setTimeoutMsec', propertySpec(solace.CacheSessionProperties.prototype.setTimeoutMsec, 'cw')); // GDP
// --------------------------
// solace.CapabilityType
// --------------------------
solace['CapabilityType'] = solace.CapabilityType;
solace.CapabilityType._setCanonical({"PEER_SOFTWARE_VERSION":0,"PEER_SOFTWARE_DATE":1,"PEER_PLATFORM":2,"PEER_PORT_SPEED":3,"PEER_PORT_TYPE":4,"MAX_DIRECT_MSG_SIZE":5,"PEER_ROUTER_NAME":6,"MESSAGE_ELIDING":7,"NO_LOCAL":8,"GUARANTEED_MESSAGE_CONSUME":9,"TEMPORARY_ENDPOINT":10,"GUARANTEED_MESSAGE_PUBLISH":11,"GUARANTEED_MESSAGE_BROWSE":12,"ENDPOINT_MGMT":13,"SELECTOR":14,"MAX_GUARANTEED_MSG_SIZE":15,"ACTIVE_CONSUMER_INDICATION":16,"COMPRESSION":17,"CUT_THROUGH":18,"ENDPOINT_DISCARD_BEHAVIOR":19,"ENDPOINT_MESSAGE_TTL":20,"JNDI":21,"PER_TOPIC_SEQUENCE_NUMBERING":22,"QUEUE_SUBSCRIPTIONS":23,"SUBSCRIPTION_MANAGER":24,"TRANSACTED_SESSION":25}, true);
Object.defineProperty(solace.CapabilityType, 'describe', propertySpec(solace.CapabilityType.describe, 'cw')); // GDP
Object.defineProperty(solace.CapabilityType, 'nameOf', propertySpec(solace.CapabilityType.nameOf, 'cw')); // GDP
// --------------------------
// solace.ConsoleLogImpl
// --------------------------
solace['ConsoleLogImpl'] = solace.ConsoleLogImpl;
// --------------------------
// solace.Destination
// --------------------------
solace['Destination'] = solace.Destination;
Object.defineProperty(solace.Destination.prototype, 'getType', propertySpec(solace.Destination.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'getBytes', propertySpec(solace.Destination.prototype.getBytes, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'getOffset', propertySpec(solace.Destination.prototype.getOffset, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'validate', propertySpec(solace.Destination.prototype.validate, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'isWildcarded', propertySpec(solace.Destination.prototype.isWildcarded, 'cw')); // GDP
// --------------------------
// solace.DestinationType
// --------------------------
solace['DestinationType'] = solace.DestinationType;
solace.DestinationType._setCanonical({"TOPIC":"topic","QUEUE":"queue","TEMPORARY_QUEUE":"temporary_queue"}, true);
Object.defineProperty(solace.DestinationType, 'describe', propertySpec(solace.DestinationType.describe, 'cw')); // GDP
Object.defineProperty(solace.DestinationType, 'nameOf', propertySpec(solace.DestinationType.nameOf, 'cw')); // GDP
// --------------------------
// solace.ErrorSubcode
// --------------------------
solace['ErrorSubcode'] = solace.ErrorSubcode;
solace.ErrorSubcode._setCanonical({"UNKNOWN_ERROR":4294967295,"NO_ERROR":0,"SESSION_NOT_CONNECTED":2,"INVALID_SESSION_OPERATION":3,"INVALID_OPERATION":3,"TIMEOUT":4,"MESSAGE_VPN_NOT_ALLOWED":5,"MESSAGE_VPN_UNAVAILABLE":6,"CLIENT_USERNAME_IS_SHUTDOWN":7,"DYNAMIC_CLIENTS_NOT_ALLOWED":8,"CLIENT_NAME_ALREADY_IN_USE":9,"CLIENT_NAME_INVALID":10,"CLIENT_DELETE_IN_PROGRESS":11,"TOO_MANY_CLIENTS":12,"LOGIN_FAILURE":13,"INVALID_VIRTUAL_ADDRESS":14,"CLIENT_ACL_DENIED":15,"SUBSCRIPTION_ACL_DENIED":16,"PUBLISH_ACL_DENIED":17,"PARAMETER_OUT_OF_RANGE":18,"PARAMETER_CONFLICT":19,"PARAMETER_INVALID_TYPE":20,"INTERNAL_ERROR":21,"INSUFFICIENT_SPACE":22,"OUT_OF_RESOURCES":23,"PROTOCOL_ERROR":24,"COMMUNICATION_ERROR":25,"KEEP_ALIVE_FAILURE":26,"TOPIC_MISSING":28,"INVALID_TOPIC_SYNTAX":31,"MESSAGE_TOO_LARGE":32,"XML_PARSE_ERROR":33,"SUBSCRIPTION_ALREADY_PRESENT":34,"SUBSCRIPTION_NOT_FOUND":35,"SUBSCRIPTION_INVALID":36,"SUBSCRIPTION_ERROR_OTHER":37,"SUBSCRIPTION_TOO_MANY":38,"SUBSCRIPTION_ATTRIBUTES_CONFLICT":39,"NO_LOCAL_NOT_SUPPORTED":40,"DATA_ERROR_OTHER":42,"CREATE_XHR_FAILED":43,"CONNECTION_ERROR":44,"DATA_DECODE_ERROR":45,"INACTIVITY_TIMEOUT":46,"UNKNOWN_TRANSPORT_SESSION_ID":47,"AD_MESSAGING_NOT_SUPPORTED":48,"CREATE_WEBSOCKET_FAILED":49,"REPLICATION_IS_STANDBY":50,"BASIC_AUTHENTICATION_IS_SHUTDOWN":51,"CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN":52,"GM_UNAVAILABLE":100,"UNKNOWN_FLOW_NAME":111,"ALREADY_BOUND":112,"INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT":113,"UNKNOWN_QUEUE_NAME":114,"UNKNOWN_TOPIC_ENDPOINT_NAME":115,"MAX_CLIENTS_FOR_QUEUE":116,"MAX_CLIENTS_FOR_TE":117,"UNEXPECTED_UNBIND":118,"QUEUE_NOT_FOUND":119,"SPOOL_OVER_QUOTA":120,"QUEUE_SHUTDOWN":121,"TOPIC_ENDPOINT_SHUTDOWN":122,"NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT":123,"ENDPOINT_ALREADY_EXISTS":124,"PERMISSION_NOT_ALLOWED":125,"INVALID_SELECTOR":126,"MAX_MESSAGE_USAGE_EXCEEDED":127,"ENDPOINT_PROPERTY_MISMATCH":128,"NO_SUBSCRIPTION_MATCH":129,"MESSAGE_DELIVERY_MODE_MISMATCH":130,"MESSAGE_ALREADY_ACKNOWLEDGED":131,"SUBSCRIPTION_DOES_NOT_MATCH":133,"SELECTOR_DOES_NOT_MATCH":134,"INVALID_DTE_NAME":135,"UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND":136,"CALLBACK_ERROR":137,"NOLOCAL_DISCARD":138,"GM_NOT_READY":140,"LOW_PRIORITY_MSG_CONGESTION":141,"QUOTA_OUT_OF_RANGE":142,"FAILED_LOADING_TRUSTSTORE":143,"FAILED_LOADING_CERTIFICATE_AND_KEY":144,"UNRESOLVED_HOSTS":145}, true);
Object.defineProperty(solace.ErrorSubcode, 'describe', propertySpec(solace.ErrorSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.ErrorSubcode, 'nameOf', propertySpec(solace.ErrorSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.LogImpl
// --------------------------
solace['LogImpl'] = solace.LogImpl;
// --------------------------
// solace.LogLevel
// --------------------------
solace['LogLevel'] = solace.LogLevel;
solace.LogLevel._setCanonical({"FATAL":0,"ERROR":1,"WARN":2,"INFO":3,"DEBUG":4,"TRACE":5}, true);
Object.defineProperty(solace.LogLevel, 'describe', propertySpec(solace.LogLevel.describe, 'cw')); // GDP
Object.defineProperty(solace.LogLevel, 'nameOf', propertySpec(solace.LogLevel.nameOf, 'cw')); // GDP
// --------------------------
// solace.Long
// --------------------------
solace['Long'] = solace.Long;
// --------------------------
// solace.Message
// --------------------------
solace['Message'] = solace.Message;
Object.defineProperty(solace.Message.prototype, 'getType', propertySpec(solace.Message.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setApplicationMessageId', propertySpec(solace.Message.prototype.setApplicationMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getApplicationMessageId', propertySpec(solace.Message.prototype.getApplicationMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setApplicationMessageType', propertySpec(solace.Message.prototype.setApplicationMessageType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getApplicationMessageType', propertySpec(solace.Message.prototype.getApplicationMessageType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getBinaryAttachment', propertySpec(solace.Message.prototype.getBinaryAttachment, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setBinaryAttachment', propertySpec(solace.Message.prototype.setBinaryAttachment, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCacheRequestId', propertySpec(solace.Message.prototype.getCacheRequestId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCorrelationId', propertySpec(solace.Message.prototype.getCorrelationId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setCorrelationId', propertySpec(solace.Message.prototype.setCorrelationId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCorrelationKey', propertySpec(solace.Message.prototype.getCorrelationKey, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setCorrelationKey', propertySpec(solace.Message.prototype.setCorrelationKey, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDeliverToOne', propertySpec(solace.Message.prototype.isDeliverToOne, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDeliverToOne', propertySpec(solace.Message.prototype.setDeliverToOne, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getDeliveryMode', propertySpec(solace.Message.prototype.getDeliveryMode, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDeliveryMode', propertySpec(solace.Message.prototype.setDeliveryMode, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getDestination', propertySpec(solace.Message.prototype.getDestination, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDestination', propertySpec(solace.Message.prototype.setDestination, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDiscardIndication', propertySpec(solace.Message.prototype.isDiscardIndication, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDiscardIndication', propertySpec(solace.Message.prototype.setDiscardIndication, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isElidingEligible', propertySpec(solace.Message.prototype.isElidingEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setElidingEligible', propertySpec(solace.Message.prototype.setElidingEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPublisherId', propertySpec(solace.Message.prototype.getPublisherId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPublisherId', propertySpec(solace.Message.prototype.setPublisherId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPublisherMessageId', propertySpec(solace.Message.prototype.getPublisherMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPublisherMessageId', propertySpec(solace.Message.prototype.setPublisherMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getTimeToLive', propertySpec(solace.Message.prototype.getTimeToLive, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setTimeToLive', propertySpec(solace.Message.prototype.setTimeToLive, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGMExpiration', propertySpec(solace.Message.prototype.getGMExpiration, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGMExpiration', propertySpec(solace.Message.prototype.setGMExpiration, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDMQEligible', propertySpec(solace.Message.prototype.isDMQEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDMQEligible', propertySpec(solace.Message.prototype.setDMQEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getFlowId', propertySpec(solace.Message.prototype.getFlowId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setFlowId', propertySpec(solace.Message.prototype.setFlowId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGuaranteedPreviousMessageId', propertySpec(solace.Message.prototype.getGuaranteedPreviousMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGuaranteedPreviousMessageId', propertySpec(solace.Message.prototype.setGuaranteedPreviousMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getMessageConsumer', propertySpec(solace.Message.prototype.getMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setMessageConsumer', propertySpec(solace.Message.prototype.setMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGuaranteedMessageId', propertySpec(solace.Message.prototype.getGuaranteedMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGuaranteedMessageId', propertySpec(solace.Message.prototype.setGuaranteedMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getTopicSequenceNumber', propertySpec(solace.Message.prototype.getTopicSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setTopicSequenceNumber', propertySpec(solace.Message.prototype.setTopicSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'acknowledge', propertySpec(solace.Message.prototype.acknowledge, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isAcknowledgeImmediately', propertySpec(solace.Message.prototype.isAcknowledgeImmediately, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setAcknowledgeImmediately', propertySpec(solace.Message.prototype.setAcknowledgeImmediately, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCacheStatus', propertySpec(solace.Message.prototype.getCacheStatus, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isReplyMessage', propertySpec(solace.Message.prototype.isReplyMessage, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isRedelivered', propertySpec(solace.Message.prototype.isRedelivered, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setRedelivered', propertySpec(solace.Message.prototype.setRedelivered, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setAsReplyMessage', propertySpec(solace.Message.prototype.setAsReplyMessage, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getReceiverTimestamp', propertySpec(solace.Message.prototype.getReceiverTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getReplyTo', propertySpec(solace.Message.prototype.getReplyTo, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setReplyTo', propertySpec(solace.Message.prototype.setReplyTo, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSenderId', propertySpec(solace.Message.prototype.getSenderId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSenderId', propertySpec(solace.Message.prototype.setSenderId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSenderTimestamp', propertySpec(solace.Message.prototype.getSenderTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSenderTimestamp', propertySpec(solace.Message.prototype.setSenderTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSequenceNumber', propertySpec(solace.Message.prototype.getSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSequenceNumber', propertySpec(solace.Message.prototype.setSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getUserCos', propertySpec(solace.Message.prototype.getUserCos, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPriority', propertySpec(solace.Message.prototype.getPriority, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setUserCos', propertySpec(solace.Message.prototype.setUserCos, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPriority', propertySpec(solace.Message.prototype.setPriority, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlContent', propertySpec(solace.Message.prototype.getXmlContent, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlContentDecoded', propertySpec(solace.Message.prototype.getXmlContentDecoded, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setXmlContent', propertySpec(solace.Message.prototype.setXmlContent, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setXmlMetadata', propertySpec(solace.Message.prototype.setXmlMetadata, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlMetadata', propertySpec(solace.Message.prototype.getXmlMetadata, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getUserPropertyMap', propertySpec(solace.Message.prototype.getUserPropertyMap, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setUserPropertyMap', propertySpec(solace.Message.prototype.setUserPropertyMap, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSdtContainer', propertySpec(solace.Message.prototype.setSdtContainer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSdtContainer', propertySpec(solace.Message.prototype.getSdtContainer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'reset', propertySpec(solace.Message.prototype.reset, 'cw')); // GDP
// --------------------------
// solace.MessageCacheStatus
// --------------------------
solace['MessageCacheStatus'] = solace.MessageCacheStatus;
solace.MessageCacheStatus._setCanonical({"LIVE":0,"CACHED":1,"SUSPECT":2}, true);
Object.defineProperty(solace.MessageCacheStatus, 'describe', propertySpec(solace.MessageCacheStatus.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageCacheStatus, 'nameOf', propertySpec(solace.MessageCacheStatus.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumer
// --------------------------
solace['MessageConsumer'] = solace.MessageConsumer;
Object.defineProperty(solace.MessageConsumer.prototype, 'getDestination', propertySpec(solace.MessageConsumer.prototype.getDestination, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'applicationAck', propertySpec(solace.MessageConsumer.prototype.applicationAck, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getDisposedEvent', propertySpec(solace.MessageConsumer.prototype.getDisposedEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleDataMessage', propertySpec(solace.MessageConsumer.prototype.handleDataMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleUncorrelatedControlMessage', propertySpec(solace.MessageConsumer.prototype.handleUncorrelatedControlMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getProperties', propertySpec(solace.MessageConsumer.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'onVRNChanged', propertySpec(solace.MessageConsumer.prototype.onVRNChanged, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'clearStats', propertySpec(solace.MessageConsumer.prototype.clearStats, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getDisposedEvent', propertySpec(solace.MessageConsumer.prototype.getDisposedEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getProperties', propertySpec(solace.MessageConsumer.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getStat', propertySpec(solace.MessageConsumer.prototype.getStat, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleUncorrelatedControlMessage', propertySpec(solace.MessageConsumer.prototype.handleUncorrelatedControlMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'incStat', propertySpec(solace.MessageConsumer.prototype.incStat, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'processFSMEvent', propertySpec(solace.MessageConsumer.prototype.processFSMEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'formatErrorEvent', propertySpec(solace.MessageConsumer.prototype.formatErrorEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'disableEmitter', propertySpec(solace.MessageConsumer.prototype.disableEmitter, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerAcknowledgeMode
// --------------------------
solace['MessageConsumerAcknowledgeMode'] = solace.MessageConsumerAcknowledgeMode;
solace.MessageConsumerAcknowledgeMode._setCanonical({"AUTO":"AUTO","CLIENT":"CLIENT"}, true);
Object.defineProperty(solace.MessageConsumerAcknowledgeMode, 'describe', propertySpec(solace.MessageConsumerAcknowledgeMode.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumerAcknowledgeMode, 'nameOf', propertySpec(solace.MessageConsumerAcknowledgeMode.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerEventName
// --------------------------
solace['MessageConsumerEventName'] = solace.MessageConsumerEventName;
solace.MessageConsumerEventName._setCanonical({"UP":"MessageConsumerEventName_up","DOWN":"MessageConsumerEventName_down","ACTIVE":"MessageConsumerEventName_active","INACTIVE":"MessageConsumerEventName_inactive","DOWN_ERROR":"MessageConsumerEventName_downError","CONNECT_FAILED_ERROR":"MessageConsumerEventName_connectFailedError","GM_DISABLED":"MessageConsumerEventName_GMDisabled","DISPOSED":"MessageConsumerEventName_disposed","MESSAGE":"MessageConsumerEventName_message"}, true);
Object.defineProperty(solace.MessageConsumerEventName, 'describe', propertySpec(solace.MessageConsumerEventName.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumerEventName, 'nameOf', propertySpec(solace.MessageConsumerEventName.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerProperties
// --------------------------
solace['MessageConsumerProperties'] = solace.MessageConsumerProperties;
// --------------------------
// solace.MessageDeliveryModeType
// --------------------------
solace['MessageDeliveryModeType'] = solace.MessageDeliveryModeType;
solace.MessageDeliveryModeType._setCanonical({"DIRECT":0,"PERSISTENT":1,"NON_PERSISTENT":2}, true);
Object.defineProperty(solace.MessageDeliveryModeType, 'describe', propertySpec(solace.MessageDeliveryModeType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageDeliveryModeType, 'nameOf', propertySpec(solace.MessageDeliveryModeType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageDumpFlag
// --------------------------
solace['MessageDumpFlag'] = solace.MessageDumpFlag;
solace.MessageDumpFlag._setCanonical({"MSGDUMP_BRIEF":0,"MSGDUMP_FULL":1}, true);
Object.defineProperty(solace.MessageDumpFlag, 'describe', propertySpec(solace.MessageDumpFlag.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageDumpFlag, 'nameOf', propertySpec(solace.MessageDumpFlag.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessagePublisherAcknowledgeMode
// --------------------------
solace['MessagePublisherAcknowledgeMode'] = solace.MessagePublisherAcknowledgeMode;
solace.MessagePublisherAcknowledgeMode._setCanonical({"PER_MESSAGE":"PER_MESSAGE","WINDOWED":"WINDOWED"}, true);
Object.defineProperty(solace.MessagePublisherAcknowledgeMode, 'describe', propertySpec(solace.MessagePublisherAcknowledgeMode.describe, 'cw')); // GDP
Object.defineProperty(solace.MessagePublisherAcknowledgeMode, 'nameOf', propertySpec(solace.MessagePublisherAcknowledgeMode.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessagePublisherProperties
// --------------------------
solace['MessagePublisherProperties'] = solace.MessagePublisherProperties;
// --------------------------
// solace.MessageRxCBInfo
// --------------------------
solace['MessageRxCBInfo'] = solace.MessageRxCBInfo;
// --------------------------
// solace.MessageType
// --------------------------
solace['MessageType'] = solace.MessageType;
solace.MessageType._setCanonical({"BINARY":0,"MAP":1,"STREAM":2,"TEXT":3}, true);
Object.defineProperty(solace.MessageType, 'describe', propertySpec(solace.MessageType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageType, 'nameOf', propertySpec(solace.MessageType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageUserCosType
// --------------------------
solace['MessageUserCosType'] = solace.MessageUserCosType;
solace.MessageUserCosType._setCanonical({"COS1":0,"COS2":1,"COS3":2}, true);
Object.defineProperty(solace.MessageUserCosType, 'describe', propertySpec(solace.MessageUserCosType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageUserCosType, 'nameOf', propertySpec(solace.MessageUserCosType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MutableSessionProperty
// --------------------------
solace['MutableSessionProperty'] = solace.MutableSessionProperty;
solace.MutableSessionProperty._setCanonical({"CLIENT_NAME":1,"CLIENT_DESCRIPTION":2}, true);
Object.defineProperty(solace.MutableSessionProperty, 'describe', propertySpec(solace.MutableSessionProperty.describe, 'cw')); // GDP
Object.defineProperty(solace.MutableSessionProperty, 'nameOf', propertySpec(solace.MutableSessionProperty.nameOf, 'cw')); // GDP
// --------------------------
// solace.NotImplementedError
// --------------------------
solace['NotImplementedError'] = solace.NotImplementedError;
Object.defineProperty(solace.NotImplementedError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.OperationError
// --------------------------
solace['OperationError'] = solace.OperationError;
Object.defineProperty(solace.OperationError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.QueueAccessType
// --------------------------
solace['QueueAccessType'] = solace.QueueAccessType;
solace.QueueAccessType._setCanonical({"EXCLUSIVE":"EXCLUSIVE","NONEXCLUSIVE":"NONEXCLUSIVE"}, true);
Object.defineProperty(solace.QueueAccessType, 'describe', propertySpec(solace.QueueAccessType.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueAccessType, 'nameOf', propertySpec(solace.QueueAccessType.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueueDescriptor
// --------------------------
solace['QueueDescriptor'] = solace.QueueDescriptor;
Object.defineProperty(solace.QueueDescriptor, 'createFromSpec', propertySpec(solace.QueueDescriptor.createFromSpec, 'cw')); // GDP
Object.defineProperty(solace.QueueDescriptor.prototype, 'getType', propertySpec(solace.QueueDescriptor.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.QueueDescriptor.prototype, 'isDurable', propertySpec(solace.QueueDescriptor.prototype.isDurable, 'cw')); // GDP
// --------------------------
// solace.QueueDiscardBehavior
// --------------------------
solace['QueueDiscardBehavior'] = solace.QueueDiscardBehavior;
solace.QueueDiscardBehavior._setCanonical({"NOTIFY_SENDER_ON":"NOTIFY_SENDER_ON","NOTIFY_SENDER_OFF":"NOTIFY_SENDER_OFF"}, true);
Object.defineProperty(solace.QueueDiscardBehavior, 'describe', propertySpec(solace.QueueDiscardBehavior.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueDiscardBehavior, 'nameOf', propertySpec(solace.QueueDiscardBehavior.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueuePermissions
// --------------------------
solace['QueuePermissions'] = solace.QueuePermissions;
solace.QueuePermissions._setCanonical({"NONE":"NONE","READ_ONLY":"READ_ONLY","CONSUME":"CONSUME","MODIFY_TOPIC":"MODIFY_TOPIC","DELETE":"DELETE"}, true);
Object.defineProperty(solace.QueuePermissions, 'describe', propertySpec(solace.QueuePermissions.describe, 'cw')); // GDP
Object.defineProperty(solace.QueuePermissions, 'nameOf', propertySpec(solace.QueuePermissions.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueueProperties
// --------------------------
solace['QueueProperties'] = solace.QueueProperties;
// --------------------------
// solace.QueueType
// --------------------------
solace['QueueType'] = solace.QueueType;
solace.QueueType._setCanonical({"QUEUE":"QUEUE","TOPIC_ENDPOINT":"TOPIC_ENDPOINT"}, true);
Object.defineProperty(solace.QueueType, 'describe', propertySpec(solace.QueueType.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueType, 'nameOf', propertySpec(solace.QueueType.nameOf, 'cw')); // GDP
// --------------------------
// solace.RequestError
// --------------------------
solace['RequestError'] = solace.RequestError;
Object.defineProperty(solace.RequestError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.RequestEventCode
// --------------------------
solace['RequestEventCode'] = solace.RequestEventCode;
solace.RequestEventCode._setCanonical({"REQUEST_ABORTED":8,"REQUEST_TIMEOUT":9}, true);
Object.defineProperty(solace.RequestEventCode, 'describe', propertySpec(solace.RequestEventCode.describe, 'cw')); // GDP
Object.defineProperty(solace.RequestEventCode, 'nameOf', propertySpec(solace.RequestEventCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.SDTField
// --------------------------
solace['SDTField'] = solace.SDTField;
Object.defineProperty(solace.SDTField, 'create', propertySpec(solace.SDTField.create, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'getType', propertySpec(solace.SDTField.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'getValue', propertySpec(solace.SDTField.prototype.getValue, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'setError', propertySpec(solace.SDTField.prototype.setError, 'cw')); // GDP
// --------------------------
// solace.SDTFieldType
// --------------------------
solace['SDTFieldType'] = solace.SDTFieldType;
solace.SDTFieldType._setCanonical({"BOOL":0,"UINT8":1,"INT8":2,"UINT16":3,"INT16":4,"UINT32":5,"INT32":6,"UINT64":7,"INT64":8,"WCHAR":9,"STRING":10,"BYTEARRAY":11,"FLOATTYPE":12,"DOUBLETYPE":13,"MAP":14,"STREAM":15,"DESTINATION":16,"NULLTYPE":17,"UNKNOWN":18,"SMF_MESSAGE":19}, true);
Object.defineProperty(solace.SDTFieldType, 'describe', propertySpec(solace.SDTFieldType.describe, 'cw')); // GDP
Object.defineProperty(solace.SDTFieldType, 'nameOf', propertySpec(solace.SDTFieldType.nameOf, 'cw')); // GDP
// --------------------------
// solace.SDTMapContainer
// --------------------------
solace['SDTMapContainer'] = solace.SDTMapContainer;
Object.defineProperty(solace.SDTMapContainer.prototype, 'getKeys', propertySpec(solace.SDTMapContainer.prototype.getKeys, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'getField', propertySpec(solace.SDTMapContainer.prototype.getField, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'deleteField', propertySpec(solace.SDTMapContainer.prototype.deleteField, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'addField', propertySpec(solace.SDTMapContainer.prototype.addField, 'cw')); // GDP
// --------------------------
// solace.SDTStreamContainer
// --------------------------
solace['SDTStreamContainer'] = solace.SDTStreamContainer;
Object.defineProperty(solace.SDTStreamContainer.prototype, 'hasNext', propertySpec(solace.SDTStreamContainer.prototype.hasNext, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'getNext', propertySpec(solace.SDTStreamContainer.prototype.getNext, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'rewind', propertySpec(solace.SDTStreamContainer.prototype.rewind, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'addField', propertySpec(solace.SDTStreamContainer.prototype.addField, 'cw')); // GDP
// --------------------------
// solace.SDTUnsupportedValueError
// --------------------------
solace['SDTUnsupportedValueError'] = solace.SDTUnsupportedValueError;
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'inspect', propertySpec(solace.SDTUnsupportedValueError.prototype.inspect, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'getSubcode', propertySpec(solace.SDTUnsupportedValueError.prototype.getSubcode, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'getSourceData', propertySpec(solace.SDTUnsupportedValueError.prototype.getSourceData, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.SDTValueErrorSubcode
// --------------------------
solace['SDTValueErrorSubcode'] = solace.SDTValueErrorSubcode;
solace.SDTValueErrorSubcode._setCanonical({"VALUE_OUTSIDE_SUPPORTED_RANGE":1}, true);
Object.defineProperty(solace.SDTValueErrorSubcode, 'describe', propertySpec(solace.SDTValueErrorSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.SDTValueErrorSubcode, 'nameOf', propertySpec(solace.SDTValueErrorSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.Session
// --------------------------
solace['Session'] = solace.Session;
Object.defineProperty(solace.Session.prototype, 'subscribe', propertySpec(solace.Session.prototype.subscribe, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'unsubscribe', propertySpec(solace.Session.prototype.unsubscribe, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'unsubscribeDurableTopicEndpoint', propertySpec(solace.Session.prototype.unsubscribeDurableTopicEndpoint, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'updateProperty', propertySpec(solace.Session.prototype.updateProperty, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendRequest', propertySpec(solace.Session.prototype.sendRequest, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendReply', propertySpec(solace.Session.prototype.sendReply, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getStat', propertySpec(solace.Session.prototype.getStat, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'resetStats', propertySpec(solace.Session.prototype.resetStats, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getSessionProperties', propertySpec(solace.Session.prototype.getSessionProperties, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'isCapable', propertySpec(solace.Session.prototype.isCapable, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getCapability', propertySpec(solace.Session.prototype.getCapability, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getSessionState', propertySpec(solace.Session.prototype.getSessionState, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getFSMState', propertySpec(solace.Session.prototype.getFSMState, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createCacheSession', propertySpec(solace.Session.prototype.createCacheSession, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createMessageConsumer', propertySpec(solace.Session.prototype.createMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createDestinationFromDescriptor', propertySpec(solace.Session.prototype.createDestinationFromDescriptor, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createTemporaryDestination', propertySpec(solace.Session.prototype.createTemporaryDestination, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendEvent', propertySpec(solace.Session.prototype.sendEvent, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getTransportInfo', propertySpec(solace.Session.prototype.getTransportInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'injectTransportInterceptor', propertySpec(solace.Session.prototype.injectTransportInterceptor, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'allowOperation', propertySpec(solace.Session.prototype.allowOperation, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'updateCapabilities', propertySpec(solace.Session.prototype.updateCapabilities, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'validateAndSendMessage', propertySpec(solace.Session.prototype.validateAndSendMessage, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'enqueueOutstandingDataReq', propertySpec(solace.Session.prototype.enqueueOutstandingDataReq, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'cancelOutstandingDataReq', propertySpec(solace.Session.prototype.cancelOutstandingDataReq, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'cleanupSession', propertySpec(solace.Session.prototype.cleanupSession, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleDataMessage', propertySpec(solace.Session.prototype.handleDataMessage, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleSubscriptionUpdateResponse', propertySpec(solace.Session.prototype.handleSubscriptionUpdateResponse, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleDTEUnsubscribeResponse', propertySpec(solace.Session.prototype.handleDTEUnsubscribeResponse, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleSubscriptionUpdateError', propertySpec(solace.Session.prototype.handleSubscriptionUpdateError, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getEventCBInfo', propertySpec(solace.Session.prototype.getEventCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'setEventCBInfo', propertySpec(solace.Session.prototype.setEventCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getMessageCBInfo', propertySpec(solace.Session.prototype.getMessageCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'setMessageCBInfo', propertySpec(solace.Session.prototype.setMessageCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getCorrelationTag', propertySpec(solace.Session.prototype.getCorrelationTag, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'wrapEventCallback', propertySpec(solace.Session.prototype.wrapEventCallback, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'wrapMessageCallback', propertySpec(solace.Session.prototype.wrapMessageCallback, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'formatErrorEvent', propertySpec(solace.Session.prototype.formatErrorEvent, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'disableEmitter', propertySpec(solace.Session.prototype.disableEmitter, 'cw')); // GDP
// --------------------------
// solace.SessionEvent
// --------------------------
solace['SessionEvent'] = solace.SessionEvent;
Object.defineProperty(solace.SessionEvent.prototype, 'hasOwnProperty', propertySpec(solace.SessionEvent.prototype.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'toLocaleString', propertySpec(solace.SessionEvent.prototype.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'valueOf', propertySpec(solace.SessionEvent.prototype.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'isPrototypeOf', propertySpec(solace.SessionEvent.prototype.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'propertyIsEnumerable', propertySpec(solace.SessionEvent.prototype.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SessionEventCBInfo
// --------------------------
solace['SessionEventCBInfo'] = solace.SessionEventCBInfo;
// --------------------------
// solace.SessionEventCode
// --------------------------
solace['SessionEventCode'] = solace.SessionEventCode;
solace.SessionEventCode._setCanonical({"UP_NOTICE":0,"DOWN_ERROR":1,"CONNECT_FAILED_ERROR":2,"REJECTED_MESSAGE_ERROR":4,"SUBSCRIPTION_ERROR":5,"SUBSCRIPTION_OK":6,"VIRTUALROUTER_NAME_CHANGED":7,"REQUEST_ABORTED":8,"REQUEST_TIMEOUT":9,"PROPERTY_UPDATE_OK":10,"PROPERTY_UPDATE_ERROR":11,"CAN_ACCEPT_DATA":13,"DISCONNECTED":14,"RECONNECTING_NOTICE":22,"RECONNECTED_NOTICE":23,"REPUBLISHING_UNACKED_MESSAGES":24,"ACKNOWLEDGED_MESSAGE":25,"UNSUBSCRIBE_TE_TOPIC_OK":26,"UNSUBSCRIBE_TE_TOPIC_ERROR":27,"MESSAGE":28,"GUARANTEED_MESSAGE_PUBLISHER_DOWN":29}, true);
Object.defineProperty(solace.SessionEventCode, 'describe', propertySpec(solace.SessionEventCode.describe, 'cw')); // GDP
Object.defineProperty(solace.SessionEventCode, 'nameOf', propertySpec(solace.SessionEventCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.SessionProperties
// --------------------------
solace['SessionProperties'] = solace.SessionProperties;
// --------------------------
// solace.SessionState
// --------------------------
solace['SessionState'] = solace.SessionState;
solace.SessionState._setCanonical({"CONNECTING":1,"CONNECTED":2,"SESSION_ERROR":3,"DISCONNECTING":4,"DISCONNECTED":5}, true);
Object.defineProperty(solace.SessionState, 'describe', propertySpec(solace.SessionState.describe, 'cw')); // GDP
Object.defineProperty(solace.SessionState, 'nameOf', propertySpec(solace.SessionState.nameOf, 'cw')); // GDP
// --------------------------
// solace.SolclientFactory
// --------------------------
solace['SolclientFactory'] = solace.SolclientFactory;
Object.defineProperty(solace.SolclientFactory, 'hasOwnProperty', propertySpec(solace.SolclientFactory.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'toLocaleString', propertySpec(solace.SolclientFactory.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'valueOf', propertySpec(solace.SolclientFactory.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'isPrototypeOf', propertySpec(solace.SolclientFactory.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'propertyIsEnumerable', propertySpec(solace.SolclientFactory.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SolclientFactoryProfiles
// --------------------------
solace['SolclientFactoryProfiles'] = solace.SolclientFactoryProfiles;
Object.defineProperty(solace.SolclientFactoryProfiles, 'hasOwnProperty', propertySpec(solace.SolclientFactoryProfiles.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'toLocaleString', propertySpec(solace.SolclientFactoryProfiles.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'valueOf', propertySpec(solace.SolclientFactoryProfiles.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'isPrototypeOf', propertySpec(solace.SolclientFactoryProfiles.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'propertyIsEnumerable', propertySpec(solace.SolclientFactoryProfiles.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SolclientFactoryProperties
// --------------------------
solace['SolclientFactoryProperties'] = solace.SolclientFactoryProperties;
// --------------------------
// solace.StatType
// --------------------------
solace['StatType'] = solace.StatType;
solace.StatType._setCanonical({"TX_TOTAL_DATA_BYTES":0,"TX_TOTAL_DATA_MSGS":1,"TX_DIRECT_BYTES":2,"TX_DIRECT_MSGS":3,"TX_CONTROL_BYTES":4,"TX_CONTROL_MSGS":5,"TX_REQUEST_SENT":6,"TX_REQUEST_TIMEOUT":7,"RX_TOTAL_DATA_BYTES":8,"RX_TOTAL_DATA_MSGS":9,"RX_DIRECT_BYTES":10,"RX_DIRECT_MSGS":11,"RX_CONTROL_BYTES":12,"RX_CONTROL_MSGS":13,"RX_DISCARD_MSG_INDICATION":14,"RX_REPLY_MSG_RECVED":15,"RX_REPLY_MSG_DISCARD":16,"RX_DISCARD_SMF_UNKNOWN_ELEMENT":17,"CACHE_REQUEST_SENT":18,"CACHE_REQUEST_OK_RESPONSE":19,"CACHE_REQUEST_FAIL_RESPONSE":20,"CACHE_REQUEST_FULFILL_DISCARD_RESPONSE":21,"RX_CACHE_MSG":22,"CACHE_REQUEST_INCOMPLETE_RESPONSE":23,"CACHE_REQUEST_LIVE_DATA_FULFILL":24,"TX_PERSISTENT_BYTES":25,"TX_PERSISTENT_MSGS":26,"TX_NONPERSISTENT_BYTES":27,"TX_NONPERSISTENT_MSGS":28,"TX_PERSISTENT_BYTES_REDELIVERED":29,"TX_PERSISTENT_REDELIVERED":30,"TX_NONPERSISTENT_BYTES_REDELIVERED":31,"TX_NONPERSISTENT_REDELIVERED":32,"TX_ACKS_RXED":33,"TX_WINDOW_CLOSE":34,"TX_ACK_TIMEOUT":35,"RX_PERSISTENT_BYTES":36,"RX_PERSISTENT_MSGS":37,"RX_NONPERSISTENT_BYTES":38,"RX_NONPERSISTENT_MSGS":39,"RX_ACKED":40,"RX_DISCARD_DUPLICATE":41,"RX_DISCARD_NO_MATCHING_CONSUMER":42,"RX_DISCARD_OUT_OF_ORDER":43}, true);
Object.defineProperty(solace.StatType, 'describe', propertySpec(solace.StatType.describe, 'cw')); // GDP
Object.defineProperty(solace.StatType, 'nameOf', propertySpec(solace.StatType.nameOf, 'cw')); // GDP
// --------------------------
// solace.Topic
// --------------------------
solace['Topic'] = solace.Topic;
Object.defineProperty(solace.Topic, 'createFromName', propertySpec(solace.Topic.createFromName, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getType', propertySpec(solace.Topic.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getBytes', propertySpec(solace.Topic.prototype.getBytes, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getOffset', propertySpec(solace.Topic.prototype.getOffset, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'validate', propertySpec(solace.Topic.prototype.validate, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'isWildcarded', propertySpec(solace.Topic.prototype.isWildcarded, 'cw')); // GDP
// --------------------------
// solace.TransportError
// --------------------------
solace['TransportError'] = solace.TransportError;
Object.defineProperty(solace.TransportError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.TransportProtocol
// --------------------------
solace['TransportProtocol'] = solace.TransportProtocol;
solace.TransportProtocol._setCanonical({"HTTP_BASE64":"HTTP_BASE64","HTTP_BINARY":"HTTP_BINARY","HTTP_BINARY_STREAMING":"HTTP_BINARY_STREAMING","WS_BINARY":"WS_BINARY"}, true);
Object.defineProperty(solace.TransportProtocol, 'describe', propertySpec(solace.TransportProtocol.describe, 'cw')); // GDP
Object.defineProperty(solace.TransportProtocol, 'nameOf', propertySpec(solace.TransportProtocol.nameOf, 'cw')); // GDP
// --------------------------
// solace.Version
// --------------------------
solace['Version'] = solace.Version;
Object.defineProperty(solace.Version, 'hasOwnProperty', propertySpec(solace.Version.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.Version, 'toLocaleString', propertySpec(solace.Version.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.Version, 'valueOf', propertySpec(solace.Version.valueOf, 'cw')); // GDP
Object.defineProperty(solace.Version, 'isPrototypeOf', propertySpec(solace.Version.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.Version, 'propertyIsEnumerable', propertySpec(solace.Version.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.makeIterator
// --------------------------
solace['makeIterator'] = solace.makeIterator;
  module.exports = solace;
} catch (e) {
  console.error(e.stack);
}

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 267 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 268 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/array");

/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/date");

/***/ }),
/* 270 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/function");

/***/ }),
/* 271 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/map");

/***/ }),
/* 272 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/math");

/***/ }),
/* 273 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/number");

/***/ }),
/* 274 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/object");

/***/ }),
/* 275 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/parse-float");

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/parse-int");

/***/ }),
/* 277 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/regexp");

/***/ }),
/* 278 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/set");

/***/ }),
/* 279 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/string");

/***/ }),
/* 280 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/symbol");

/***/ }),
/* 281 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/typed");

/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = require("core-js/fn/array/includes");

/***/ }),
/* 283 */
/***/ (function(module, exports) {

module.exports = require("core-js/fn/set/from");

/***/ }),
/* 284 */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),
/* 285 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 286 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 287 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 288 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 290 */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),
/* 291 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = require("ws");

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2EzYzc4MTk2MTZmMmYxZTVlMmIiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXNraXQvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWxvZy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXJyb3IvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWNvbnZlcnQvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXV0aWwvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWRlc3RpbmF0aW9uL2FwaS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdmFsaWRhdGUvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmFjdG9yeS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2R0L2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1maWVsZC10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1maWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZGVidWcvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZzbS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90cmFuc3BvcnQtcmV0dXJuLWNvZGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXF1ZXVlL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zdGF0cy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90cmFuc3BvcnQtcHJvdG9jb2xzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvc21mLXByb3RvY29scy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXNlc3Npb24tZXZlbnQtY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLXR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZnNtL2xpYi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9tZXNzYWdlLWNvbnN1bWVyLWV2ZW50LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1kYXRhLXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2Jhc2UtbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9zbWYtaGVhZGVyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LWVycm9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXNlc3Npb24tc3RhdGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWV2ZW50cy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmxvdy9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZnNtL2xpYi9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvbWVzc2FnZS1jb25zdW1lci1hY2tub3dsZWRnZS1tb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvbWVzc2FnZS1wdWJsaXNoZXItYWNrbm93bGVkZ2UtbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS1kdW1wLWZsYWdzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvc2R0LW1hcC1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2R0L2xpYi9zZHQtc3RyZWFtLWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9jYXBhYmlsaXR5LXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tZXZlbnQtY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9jb250ZW50LXN1bW1hcnktdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90cmFuc3BvcnQtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1zZXNzaW9uLWV2ZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHNoLXN0YXRlLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtY2FwYWJpbGl0aWVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWRlc3RpbmF0aW9uL2xpYi9kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1lcnJvci9saWIvZXJyb3Itc3ViY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXJyb3IvbGliL3NvbGFjZS1lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9jb25zdW1lci1mc20tZXZlbnQtbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvY29uc3VtZXItZnNtLWV2ZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci1ldmVudC1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvcHVibGlzaGVyLWZzbS1ldmVudC1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvcHVibGlzaGVyLWZzbS1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlL2xpYi9tZXNzYWdlLWNhY2hlLXN0YXR1cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlL2xpYi9tZXNzYWdlLWRlbGl2ZXJ5LW1vZGUtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS1kdW1wLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS11c2VyLWNvcy10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvcXVldWUtYWNjZXNzLXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1kaXNjYXJkLWJlaGF2aW9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvcXVldWUtcGVybWlzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtcXVldWUvbGliL3F1ZXVlLXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvZW5jb2RlLXNpbmdsZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvaWVlZTc1NGxpYi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLWZpZWxkLWhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLXNpbmdsZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvc2R0LWRlc3RpbmF0aW9uLXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL2F1dGhlbnRpY2F0aW9uLXNjaGVtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1ldmVudC1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLWV2ZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXJlcXVlc3QtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9wYXJhbS1wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9zbWYtcGFyYW1ldGVyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvc21mLXBhcmFtZXRlci10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1zbXAtbWVzc2FnZS10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXN0YXRzL2xpYi9zdGF0LXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvYmFzZS1zbWYtY2xpZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1kZXN0aW5hdGlvbi9saWIvcXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL3RvcGljLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVycm9yL2xpYi9vcGVyYXRpb24tZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXJyb3IvbGliL3JlcXVlc3QtZXZlbnQtY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXNraXQvbGliL2xhenkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmFjdG9yeS9saWIvcHJvZmlsZS1iaW5kaW5nLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZhY3RvcnkvbGliL3NvbGNsaWVudC1mYWN0b3J5LXByb2ZpbGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZhY3RvcnkvbGliL3NvbGNsaWVudC1mYWN0b3J5LXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmxvdy9saWIvZmxvdy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmxvdy9saWIvcHJpdmF0ZS1mbG93LWV2ZW50LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZzbS9saWIvc3RhdGUtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1sb2cvbGliL2xvZy1pbXBsLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWxvZy9saWIvbG9nLWxldmVscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9tZXNzYWdlLWNvbnN1bWVyLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvbWVzc2FnZS1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvbWVzc2FnZS1wdWJsaXNoZXItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlL2xpYi9tZXNzYWdlLWR1bXAtc3RhbmRhcmQtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvYWJzdHJhY3QtcXVldWUtZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvcXVldWUtZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL2VuY29kZS1oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9wYXJzZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvc2R0LXVuc3VwcG9ydGVkLXZhbHVlLWVycm9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvc2R0LXZhbHVlLWVycm9yLXN1YmNvZGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL21lc3NhZ2UtcngtY2ItaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9tdXRhYmxlLXNlc3Npb24tcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9wMnAtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLWV2ZW50LWNiLWluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1mc20tZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1zdGF0ZS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXN0YXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL2NvZGVjL2FkcHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9jbGllbnQtY3RybC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL2NvZGVjL2NvbnRlbnQtc3VtbWFyeS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvcGFyc2Utc21mLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvcHJpb3JpdHktdXNlci1jb3MtbWFwLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvc21wLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL3NtZi11aC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1hZHByb3RvY29sLW1lc3NhZ2UtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtYWRwcm90b2NvbC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtY2xpZW50LWN0cmwtbWVzc2FnZS10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1jbGllbnQtY3RybC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtc21wLW1lc3NhZ2UtdHlwZS1mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi10cmFuc3BvcnQtc2Vzc2lvbi1tZXNzYWdlLXR5cGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLWNiLWluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtbGl2ZS1kYXRhLWFjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmVxdWVzdC1yZXN1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1yZXR1cm4tY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmV0dXJuLXN1YmNvZGVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLXNlc3Npb24tcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL25vZGUtdGxzLW9wdHMtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi9zbWYtY2xpZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LWNsaWVudC1zdGF0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL2h0dHAtY29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL3hoci1mYWN0b3J5LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtc2Vzc2lvbi1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYnNvY2tldC10cmFuc3BvcnQtc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi9zdHJpbmctYnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXZhbGlkYXRlL2xpYi9jaGVjay5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjbG9uZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImxvbmdcIiIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1jb3JlL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1jb252ZXJ0L2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtY29udmVydC9saWIvYml0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1jb252ZXJ0L2xpYi9jb252ZXJ0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWNvbnZlcnQvbGliL2hleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1jb252ZXJ0L2xpYi9sb25nLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWNvcmUvYXBpLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWNvcmUvbGliL25vZGUtZm9yd2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1kZWJ1Zy9saWIvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLWZyb20tbmV0d29yay5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1lbnYvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVycm9yL2xpYi9lcnJvci1yZXNwb25zZS1zdWJjb2RlLW1hcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1lcnJvci9saWIvbm90LWltcGxlbWVudGVkLWVycm9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVycm9yL2xpYi9yZXF1ZXN0LWVycm9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVza2l0L2xpYi9hcnJheS1vcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVza2l0L2xpYi9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXNraXQvbGliL2JpZGktbWFwLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVza2l0L2xpYi9lbnVtLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVza2l0L2xpYi9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvbWFrZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXNraXQvbGliL21peGluLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWVza2l0L2xpYi9yZXNvbHZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvc2V0LW9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZXZlbnRzL2xpYi9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWV2ZW50cy9saWIvdGltZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmFjdG9yeS9saWIvc29sY2xpZW50LWZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZmxvdy9saWIvZmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1mc20vbGliL2VudHJ5LXBvaW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZzbS9saWIvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtZnNtL2xpYi9leGl0LXBvaW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LWZzbS9saWIvc3RhdGUtbWFjaGluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1sb2cvbGliL2NvbnNvbGUtbG9nLWltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbG9nL2xpYi9nbG9iYWwtYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9hcHBsaWNhdGlvbi1hY2tzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL2NvbnN1bWVyLWZsb3dzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL2NvbnN1bWVyLWZzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9jb25zdW1lci1zdGF0ZS1uYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9tZXNzYWdlLWNvbnN1bWVyLXByb3BlcnRpZXMtdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL21lc3NhZ2UtZGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi90cmFuc3BvcnQtYWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvbWVzc2FnZS1pZHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXIvbGliL21lc3NhZ2UtcHVibGlzaGVyLXByb3BlcnRpZXMtdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvcHVibGlzaGVyLWZzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvcHVibGlzaGVyLXN0YXRlLW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LW1lc3NhZ2UvbGliL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtcXVldWUvbGliL3F1ZXVlLWRlc2NyaXB0b3ItdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1wcm9wZXJ0aWVzLXZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvcXVldWUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL2VuY29kZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvZW5jb2RlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL2VuY29kZS1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9wYXJzZS1kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLWZsb2F0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvcGFyc2UtbWFwLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvcGFyc2Utc3RyZWFtLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNkdC9saWIvdmFsaWRhdGUtc2R0LWZpZWxkLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL2NvcnJlbGF0ZWQtcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9kZWZhdWx0LWNhcGFiaWxpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9nbG9iYWwtY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9ob3N0LWxpc3QtZG5zLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9ob3N0LWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvb3V0c3RhbmRpbmctZGF0YS1yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tZnNtLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tb3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXByb3BlcnRpZXMtdmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc3Vic2NyaXB0aW9uLXVwZGF0ZS10aW1lb3V0LW1lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2FkcHJvdG9jb2wtbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9iaW5hcnktbWV0YS1ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9jbGllbnQtY3RybC1tZXNzYWdlLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2tlZXAtYWxpdmUtbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9zbXAtbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy90cmFuc3BvcnQtc21mLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtZ2V0LXJlc3VsdC1jb2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1nZXQtcmVzdWx0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLXJlcXVlc3QtdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtc2Vzc2lvbi1zdWJzY3JpYmUtaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1zZXNzaW9uLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXN0YXRzL2xpYi9zdGF0LWJ5bW9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC1zdGF0cy9saWIvc3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi9idWZmZXItZGF0YS1xdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL2J1ZmZlci1zbWYtY2xpZW50LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvc3RyaW5nLXNtZi1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90Y3AvYXBpLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdGNwL3RyYW5zcG9ydC10Y3AuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90cmFuc3BvcnQtY2FwYWJpbGl0aWVzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LWZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi90cmFuc3BvcnQtcHJvdG9jb2wtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL2h0dHAtdHJhbnNwb3J0LXNlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvaHR0cC9zZW5kLXhoci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9zdGF0ZS1iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvc3RhdGUtYmluYXJ5LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3N0YXRlLXN0cmVhbWluZy1hbmQtYmluYXJ5LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3N0YXRlLXdlYnNvY2tldC1iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvd2ViLXRyYW5zcG9ydC1mc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvd2ViLXRyYW5zcG9ydC1zdGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvd2ViLXRyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi93ZWJzb2NrZXQtY2xvc2UtY29kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdXRpbC9saWIvYXBpLXByb3BlcnRpZXMtdmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi9hcGktcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi9hcnJheS11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi9wcm9jZXNzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXV0aWwvbGliL3N0cmluZy11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi90aW1pbmctYnVja2V0LmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXV0aWwvbGliL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NvbGNsaWVudC11dGlsL2xpYi91dWlkLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXV0aWwvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2xjbGllbnQtdmFsaWRhdGUvbGliL2Jhc2UtY2hlY2tzLmpzIiwid2VicGFjazovLy8uL34vc29sY2xpZW50LXZhbGlkYXRlL2xpYi9wYXJhbWV0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJidWZmZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb25zdGFudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9hcnJheVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L2RhdGVcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9mdW5jdGlvblwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L21hcFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L21hdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9udW1iZXJcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9vYmplY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9wYXJzZS1mbG9hdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3BhcnNlLWludFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3JlZ2V4cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3NldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3N0cmluZ1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3N5bWJvbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZXM2L3R5cGVkXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY29yZS1qcy9mbi9hcnJheS9pbmNsdWRlc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNvcmUtanMvZm4vc2V0L2Zyb21cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkbnNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0bHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ3c1wiIl0sIm5hbWVzIjpbImNvbnN0IiwidGhpcyIsImxldCIsInN1cGVyIiwiaSIsImlkIiwidmFsaWRGb3JBRCIsInNlc3Npb25FdmVudCIsIndFdmVudCIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFeUIsVUFBRyxtQkFBTyxDQUFDLEdBQXdCLENBQUM7QUFBckQsbUJBQWUsdUJBQXVDO0FBQzlDLFlBQUcsbUJBQU8sQ0FBQyxHQUFjLENBQUM7QUFBbEMsVUFBTSxnQkFBNkI7QUFDMUIsWUFBRyxtQkFBTyxDQUFDLEdBQWdCLENBQUM7QUFBckMsV0FBTyxpQkFBK0I7QUFDaEMsWUFBRyxtQkFBTyxDQUFDLEdBQVksQ0FBQztBQUE5QixRQUFJLGNBQTJCO0FBQ3JCLFlBQUcsbUJBQU8sQ0FBQyxHQUFnQixDQUFDO0FBQXRDLFlBQVEsa0JBQStCO0FBQ2pDLFlBQUcsbUJBQU8sQ0FBQyxFQUFZLENBQUM7QUFBOUIsUUFBSSxjQUEyQjtBQUN0QixZQUFHLG1CQUFPLENBQUMsR0FBZ0IsQ0FBQztBQUFyQyxXQUFPLGlCQUErQjtBQUMvQixZQUFHLG1CQUFPLENBQUMsR0FBYSxDQUFDO0FBQWhDLFNBQUssZUFBNEI7QUFDdkIsWUFBRyxtQkFBTyxDQUFDLEdBQWdCLENBQUM7QUFBdEMsWUFBUSxrQkFBK0I7QUFDeEIsWUFBRyxtQkFBTyxDQUFDLEdBQXNCLENBQUM7QUFBakQsaUJBQWEsdUJBQXFDOztBQUUxRCxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDL0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO0FBQ2pELE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ25DLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUMzQixNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO0FBQ3BELE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDN0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztBQUNuQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDbkMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQztBQUMxQyxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7Ozs7Ozs7QUN2QnJCLFVBQUcsbUJBQU8sQ0FBQyxHQUF3QixDQUFDO0FBQXBELGtCQUFjLHNCQUF1QztBQUN0QyxZQUFHLG1CQUFPLENBQUMsR0FBc0IsQ0FBQztBQUFqRCxpQkFBYSx1QkFBcUM7QUFDekMsWUFBRyxtQkFBTyxDQUFDLEVBQWdCLENBQUM7QUFBckMsV0FBTyxpQkFBK0I7QUFDNUIsWUFBRyxtQkFBTyxDQUFDLEVBQWtCLENBQUM7QUFBeEMsWUFBUSxrQkFBaUM7O0FBRTlCLFlBQUcsbUJBQU8sQ0FBQyxDQUFvQixDQUFDO0FBQTNDLGFBQVMsbUJBQW1DO0FBQzFCLFlBQUcsbUJBQU8sQ0FBQyxDQUFtQixDQUFDO0FBQWpELG9CQUFnQiwwQkFBa0M7O0FBR3hELGdCQUFZO0FBQ1osY0FBVSx3QkFDRTs7QUFHWixXQUFPO0FBQ1AsZUFBVztBQUNYLFdBQU87QUFDUCxlQUFXLDZCQUNLOztBQUVsQkEsR0FBSyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDckIsU0FBUyxpQkFBaUIsR0FBRztFQUMzQixNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtJQUN2QixLQUFLLGlCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDZEEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7UUFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsZUFBZSxXQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7T0FDcEQ7S0FDRjs7SUFFRCxLQUFLLGlCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDZEEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7UUFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsZUFBZSxXQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7T0FDcEQ7S0FDRjs7SUFFRCxJQUFJLGdCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDYkEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUU7UUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsZUFBZSxXQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7T0FDbkQ7S0FDRjs7SUFFRCxJQUFJLGdCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDYkEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUU7UUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsZUFBZSxXQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7T0FDbkQ7S0FDRjs7SUFFRCxLQUFLLGlCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDZEEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFdBQVcsRUFBRSxJQUFJLFFBQVEsQ0FBQyxLQUFLLEVBQUU7UUFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsZUFBZSxXQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7T0FDcEQ7S0FDRjs7SUFFRCxLQUFLLGlCQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDZEEsR0FBSyxDQUFDLElBQUksR0FBRyxPQUFPLEVBQUUsQ0FBQztNQUN2QixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ3RCLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLGVBQWUsV0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO09BQ3BEO0tBQ0Y7R0FDRixDQUFDLENBQUM7Q0FDSjtBQUNELGlCQUFpQixFQUFFLENBQUM7O0FBRXBCLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7RUFDdEMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUs7SUFDcEMsTUFBTSxDQUFDLE9BQUssSUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUM5QyxDQUFDLENBQUM7Q0FDSjs7QUFFRCxJQUFNLFlBQVksR0FDaEIscUJBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7QUFBQTtFQUN0QixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsWUFBTTtJQUN2QixJQUFJLE9BQU8sU0FBUyxLQUFLLFVBQVUsRUFBRSxTQUFPLFNBQVMsQ0FBQztJQUN0RCxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRSxTQUFPLFNBQVMsT0FBTyxDQUFRLEVBQUUsQ0FBQzs7O0FBQUEsQ0FBQyxPQUFPLENBQUMsU0FBUyxXQUFLLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNyRyxJQUFJLENBQUMsU0FBUyxFQUFFLFNBQU8sU0FBUyxXQUFXLENBQVEsRUFBRSxDQUFDOzs7QUFBQSxDQUFDLE9BQU8sV0FBSSxJQUFJLEVBQUMsQ0FBQyxFQUFFLENBQUM7SUFDM0UsT0FBTyxTQUFTLENBQUM7RUFDbkIsQ0FBQyxDQUFDLEVBQUUsQ0FBQztFQUNMQSxHQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztFQUNsQixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLEdBQUcsRUFBSztJQUN0Q0MsTUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsT0FBTyxDQUFRLEVBQUUsQ0FBQzs7O0FBQUE7TUFDckMsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxPQUFDLE1BQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDLENBQUM7RUFDSixDQUFDLENBQUMsQ0FBQztFQUNILGNBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDN0IsQ0FBQzs7MkNBQUE7O0FBRUQsbUJBQUksU0FBUyxtQkFBRztFQUNkLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUN6QixDQUFDO0FBQ0QsbUJBQUksU0FBUyxpQkFBQyxJQUFJLEVBQUU7RUFDbEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7QUFDekIsQ0FBQzs7QUFFRCwyQkFBSSxrQkFBQyxlQUFlLEVBQUUsVUFBVSxFQUFFO0VBQ2hDRCxHQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztFQUNsQixPQUFPLFNBQVMsaUJBQWlCLENBQVEsRUFBRSxDQUFDOzs7QUFBQTtJQUMxQyxPQUFPLGVBQWUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLE9BQUMsTUFBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0VBQ3JFLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FFRjs7c0VBQUE7Ozs7Ozs7O0FBUUQsZ0JBQWdCLENBQUMsV0FBVyxHQUFHLFlBQU0sb0JBQVcsRUFBRSxJQUFDOzs7Ozs7Ozs7QUFTbkQsZ0JBQWdCLENBQUMsV0FBVyxHQUFHLFVBQUMsUUFBUSxFQUFLO0VBQzNDLFlBQVksQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0VBQzdDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztDQUN2QixDQUFDOztBQUVGLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxVQUFDLEtBQUssRUFBSztFQUN6QyxXQUFXLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDOztFQUU1QkEsR0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxJQUFJLE9BQU8sRUFBRSxJQUFJLElBQUksY0FBYyxFQUFFLENBQUM7O0VBRWpFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFHLEVBQUksbUJBQVUsQ0FBQyxVQUFRLEdBQUUsR0FBRyxDQUFFLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUMsQ0FBQzs7RUFFcEYsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ2pCLENBQUMsQ0FBQzs7QUFFSCxjQUFjLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMxQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDakMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ25DLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQztBQUN2QyxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7QUFDL0MsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLGNBQWMsRUFBRSxDQUFDLENBQUM7QUFDNUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDOzs7Ozs7O0FDL0lQLFVBQUcsbUJBQU8sQ0FBQyxHQUFxQyxDQUFDO0FBQTdFLDhCQUEwQixrQ0FBb0Q7QUFDaEUsWUFBRyxtQkFBTyxDQUFDLEVBQXNCLENBQUM7QUFBaEQsZ0JBQVksc0JBQXFDO0FBQzVCLFlBQUcsbUJBQU8sQ0FBQyxHQUE2QixDQUFDO0FBQTlELHVCQUFtQiw2QkFBNEM7QUFDL0MsWUFBRyxtQkFBTyxDQUFDLEVBQXVCLENBQUM7QUFBbkQsa0JBQWMsd0JBQXNDO0FBQ3RDLFlBQUcsbUJBQU8sQ0FBQyxHQUFxQixDQUFDO0FBQS9DLGdCQUFZLHNCQUFvQztBQUM5QixZQUFHLG1CQUFPLENBQUMsRUFBMkIsQ0FBQztBQUF6RCxvQkFBZ0IsMEJBQTBDO0FBQzdDLFlBQUcsbUJBQU8sQ0FBQyxFQUFvQixDQUFDO0FBQTdDLGVBQVcscUJBQW1DOztBQUV0RCxNQUFNLENBQUMsT0FBTyxDQUFDLDBCQUEwQixHQUFHLDBCQUEwQixDQUFDO0FBQ3ZFLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztBQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDO0FBQ3pELE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztBQUMvQyxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDM0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUNuRCxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7Ozs7Ozs7QUNkekIsVUFBRyxtQkFBTyxDQUFDLEdBQWMsQ0FBQztBQUFsQyxVQUFNLGNBQTZCO0FBQzdCLFlBQUcsbUJBQU8sQ0FBQyxHQUFZLENBQUM7QUFBOUIsUUFBSSxjQUEyQjtBQUN0QixZQUFHLG1CQUFPLENBQUMsR0FBZSxDQUFDO0FBQXBDLFdBQU8saUJBQThCO0FBQ2hDLFlBQUcsbUJBQU8sQ0FBQyxHQUFXLENBQUM7QUFBNUIsT0FBRyxhQUEwQjtBQUN2QixZQUFHLG1CQUFPLENBQUMsR0FBWSxDQUFDO0FBQTlCLFFBQUksY0FBMkI7O0FBRXZDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUMvQixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDM0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ2pDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN6QixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Ozs7Ozs7QUNWSixVQUFHLG1CQUFPLENBQUMsR0FBc0IsQ0FBQztBQUFqRCxpQkFBYSxxQkFBcUM7QUFDekIsWUFBRyxtQkFBTyxDQUFDLEdBQWlDLENBQUM7QUFBdEUsMkJBQXVCLGlDQUFnRDtBQUMzRCxZQUFHLG1CQUFPLENBQUMsR0FBbUIsQ0FBQztBQUEzQyxjQUFVLG9CQUFrQztBQUNsQyxZQUFHLG1CQUFPLENBQUMsR0FBVyxDQUFDO0FBQWpDLFlBQVEsa0JBQTBCO0FBQ3pCLFlBQUcsbUJBQU8sQ0FBQyxHQUFlLENBQUM7QUFBcEMsV0FBTyxpQkFBOEI7QUFDdkIsWUFBRyxtQkFBTyxDQUFDLEdBQXFCLENBQUM7QUFBL0MsZ0JBQVksc0JBQW9DO0FBQ25DLFlBQUcsbUJBQU8sQ0FBQyxHQUFvQixDQUFDO0FBQTdDLGVBQVcscUJBQW1DO0FBQ2hDLFlBQUcsbUJBQU8sQ0FBQyxHQUFxQixDQUFDO0FBQS9DLGdCQUFZLHNCQUFvQztBQUMxQyxZQUFHLG1CQUFPLENBQUMsR0FBWSxDQUFDO0FBQTlCLFFBQUksY0FBMkI7QUFDdEIsWUFBRyxtQkFBTyxDQUFDLEdBQWUsQ0FBQztBQUFwQyxXQUFPLGlCQUE4Qjs7QUFFN0MsTUFBTSxDQUFDLE9BQU8sR0FBRztFQUNmLGtCQUFROztFQUVSLDRCQUFhO0VBQ2IsZ0RBQXVCO0VBQ3ZCLHNCQUFVO0VBQ1YsZ0JBQU87RUFDUCwwQkFBWTtFQUNaLHdCQUFXO0VBQ1gsMEJBQVk7RUFDWixVQUFJO0VBQ0osZ0JBQU87Q0FDUixDQUFDOzs7Ozs7O0FDdkJtQixVQUFHLG1CQUFPLENBQUMsRUFBbUIsQ0FBQztBQUE1QyxlQUFXLG1CQUFrQztBQUNyQixZQUFHLG1CQUFPLENBQUMsR0FBZ0MsQ0FBQztBQUFwRSwwQkFBc0IsZ0NBQStDO0FBQ3BELFlBQUcsbUJBQU8sQ0FBQyxFQUF3QixDQUFDO0FBQXJELG1CQUFlLHlCQUF1QztBQUNyQyxZQUFHLG1CQUFPLENBQUMsRUFBd0IsQ0FBQztBQUFyRCxtQkFBZSx5QkFBdUM7QUFDM0MsWUFBRyxtQkFBTyxDQUFDLENBQW9CLENBQUM7QUFBM0MsYUFBUyxtQkFBbUM7QUFDckMsWUFBRyxtQkFBTyxDQUFDLEVBQWEsQ0FBQztBQUFoQyxTQUFLLGVBQTRCO0FBQ2YsWUFBRyxtQkFBTyxDQUFDLENBQW1CLENBQUM7QUFBakQsb0JBQWdCLDBCQUFrQztBQUMzQyxZQUFHLG1CQUFPLENBQUMsRUFBYSxDQUFDO0FBQWhDLFNBQUssZUFBNEI7Ozs7Ozs7Ozs7Ozs7QUFhekMsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUcsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLFVBQUMsU0FBUyxFQUFLO0VBQ3RGLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0VBQzNDLE9BQU8sS0FBSyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztDQUN4QyxDQUFDLENBQUM7O0FBRUgsZ0JBQWdCLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxtQkFBUyxFQUFJLGFBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7QUFhakcsZ0JBQWdCLENBQUMsNkJBQTZCLEdBQUcsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLFVBQUMsU0FBUyxFQUFLO0VBQzdGLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0VBQzNDLE9BQU8sS0FBSyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzdDLENBQUMsQ0FBQzs7QUFFSCxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDekMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsR0FBRyxzQkFBc0IsQ0FBQztBQUMvRCxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO0FBQ2pELE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM3QixNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Ozs7Ozs7QUNoRDdCLGlDOzs7Ozs7QUNBZSxVQUFHLG1CQUFPLENBQUMsR0FBYSxDQUFDO0FBQWhDLFNBQUssYUFBNEI7QUFDdEIsWUFBRyxtQkFBTyxDQUFDLEdBQWlCLENBQUM7QUFBeEMsYUFBUyxtQkFBZ0M7O0FBRWpELE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM3QixNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7Ozs7Ozs7QUNKckNBLEdBQUssQ0FBQyxRQUFRLEdBQUcsbUJBQU8sQ0FBQyxHQUFhLENBQUMsQ0FBQztBQUNxRCxVQUFHLG1CQUFPLENBQUMsRUFBdUIsQ0FBQztBQUF4SCxxQkFBaUI7QUFBRSxtQkFBZTtBQUFFLHFCQUFpQjtBQUFFLG9CQUFnQjtBQUFFLGNBQVUsa0JBQXNDO0FBQy9GLFlBQUcsbUJBQU8sQ0FBQyxHQUFvQyxDQUFDO0FBQTFFLDRCQUF3QixrQ0FBbUQ7QUFDdkQsWUFBRyxtQkFBTyxDQUFDLEdBQTZCLENBQUM7QUFBN0Qsc0JBQWtCLDRCQUE0QztBQUNwQyxZQUFHLG1CQUFPLENBQUMsR0FBcUMsQ0FBQztBQUEzRSw0QkFBd0Isa0NBQW9EO0FBQ3hELFlBQUcsbUJBQU8sQ0FBQyxHQUE4QixDQUFDO0FBQTlELHNCQUFrQiw0QkFBNkM7QUFDN0MsWUFBRyxtQkFBTyxDQUFDLEVBQTJCLENBQUM7QUFBekQsb0JBQWdCLDBCQUEwQztBQUM3QyxZQUFHLG1CQUFPLENBQUMsRUFBcUIsQ0FBQztBQUE5QyxlQUFXLHFCQUFvQztBQUM1QixZQUFHLG1CQUFPLENBQUMsRUFBNkIsQ0FBQztBQUE1RCxxQkFBaUIsMkJBQTRDO0FBQ3JDLFlBQUcsbUJBQU8sQ0FBQyxHQUFrQyxDQUFDO0FBQXRFLDBCQUFzQixnQ0FBaUQ7QUFDdkMsWUFBRyxtQkFBTyxDQUFDLEdBQTJDLENBQUM7QUFBdkYsa0NBQThCLHdDQUEwRDs7QUFFaEcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztBQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztBQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUM7QUFDaEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUNuRCxNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO0FBQ25FLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7QUFDdkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyx3QkFBd0IsQ0FBQztBQUNuRSxNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDO0FBQ3ZELE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQ3pDLE1BQU0sQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEdBQUcsc0JBQXNCLENBQUM7QUFDL0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztBQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLDhCQUE4QixHQUFHLDhCQUE4QixDQUFDO0FBQy9FLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQzs7Ozs7OztBQzFCVyxVQUFHLG1CQUFPLENBQUMsRUFBa0MsQ0FBQztBQUF4RixrQkFBYztBQUFFLDRCQUF3QixnQ0FBaUQ7QUFDekUsWUFBRyxtQkFBTyxDQUFDLEVBQXVCLENBQUM7QUFBbkQsa0JBQWMsd0JBQXNDO0FBQ2xDLFlBQUcsbUJBQU8sQ0FBQyxHQUF5QixDQUFDO0FBQXZELG9CQUFnQiwwQkFBd0M7QUFDNUIsWUFBRyxtQkFBTyxDQUFDLEVBQW9DLENBQUM7QUFBNUUsOEJBQTBCLG9DQUFtRDs7QUFFckYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0FBQy9DLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztBQUMvQyxNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO0FBQ25FLE1BQU0sQ0FBQyxPQUFPLENBQUMsMEJBQTBCLEdBQUcsMEJBQTBCLENBQUM7QUFDdkUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7QUNUcEMsVUFBRyxtQkFBTyxDQUFDLEdBQWEsQ0FBQztBQUFoQyxTQUFLLGFBQTRCO0FBQ3BCLFlBQUcsbUJBQU8sQ0FBQyxFQUE2QixDQUFDO0FBQXRELGVBQVcscUJBQTRDO0FBQzdDLFlBQUcsbUJBQU8sQ0FBQyxFQUFpQixDQUFDO0FBQXZDLFlBQVEsa0JBQWdDO0FBQzFCLFlBQUcsbUJBQU8sQ0FBQyxFQUF1QixDQUFDO0FBQWpELGdCQUFZLHNCQUFzQztBQUNqQyxZQUFHLG1CQUFPLENBQUMsRUFBeUIsQ0FBQztBQUF0RCxtQkFBZSx5QkFBd0M7QUFDbkMsWUFBRyxtQkFBTyxDQUFDLEVBQTRCLENBQUM7QUFBNUQsc0JBQWtCLDRCQUEyQztBQUNuQyxZQUFHLG1CQUFPLENBQUMsR0FBbUMsQ0FBQztBQUF6RSw0QkFBd0Isa0NBQWtEO0FBQ3BELFlBQUcsbUJBQU8sQ0FBQyxHQUFnQyxDQUFDO0FBQWxFLHdCQUFvQiw4QkFBK0M7O0FBRTNFLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM3QixNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDekMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ25DLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztBQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztBQUN2RCxNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixHQUFHLHdCQUF3QixDQUFDO0FBQ25FLE1BQU0sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEdBQUcsb0JBQW9CLENBQUM7Ozs7Ozs7QUNoQjdDLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7O0FBUTVDQSxHQUFLLENBQUMsWUFBWSxHQUFHOzs7OztFQUtuQixJQUFJLFNBQVMsQ0FBQzs7Ozs7RUFLZCxLQUFLLFFBQVEsQ0FBQzs7Ozs7RUFLZCxJQUFJLFNBQVMsQ0FBQzs7Ozs7RUFLZCxNQUFNLE9BQU8sQ0FBQzs7Ozs7RUFLZCxLQUFLLFFBQVEsQ0FBQzs7Ozs7RUFLZCxNQUFNLE9BQU8sQ0FBQzs7Ozs7RUFLZCxLQUFLLFFBQVEsQ0FBQzs7Ozs7OztFQU9kLE1BQU0sT0FBTyxDQUFDOzs7Ozs7O0VBT2QsS0FBSyxRQUFRLENBQUM7Ozs7O0VBS2QsS0FBSyxRQUFRLENBQUM7Ozs7O0VBS2QsTUFBTSxPQUFPLEVBQUU7Ozs7O0VBS2YsU0FBUyxJQUFJLEVBQUU7Ozs7O0VBS2YsU0FBUyxJQUFJLEVBQUU7Ozs7O0VBS2YsVUFBVSxHQUFHLEVBQUU7Ozs7O0VBS2YsR0FBRyxVQUFVLEVBQUU7Ozs7O0VBS2YsTUFBTSxPQUFPLEVBQUU7Ozs7O0VBS2YsV0FBVyxFQUFFLEVBQUU7Ozs7O0VBS2YsUUFBUSxLQUFLLEVBQUU7Ozs7O0VBS2YsT0FBTyxNQUFNLEVBQUU7Ozs7O0VBS2YsV0FBVyxFQUFFLEVBQUU7Q0FDaEIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7O0FDbkgvQixVQUFHLG1CQUFPLENBQUMsRUFBbUIsQ0FBQztBQUE3QyxnQkFBWSxvQkFBa0M7QUFDNUIsWUFBRyxtQkFBTyxDQUFDLEdBQXNCLENBQUM7QUFBcEQsb0JBQWdCLDBCQUFxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCN0QsSUFBTSxRQUFRLEdBU1osaUJBQVcsQ0FBQyxJQUE0QixFQUFFLEtBQVksRUFBRSxDQUF4Qzs2QkFBQSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQU87K0JBQUEsR0FBRyxJQUFJO0FBQUc7RUFDdkRBLEdBQUssQ0FBQyxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO0VBQzFDLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtJQUNoQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7RUFDZCxDQUFDO0VBQ0QsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7RUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7RUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7QUFDMUIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtBQUNELDBCQUFPLHVCQUFHO0VBQ1IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3BCLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsMkJBQVEsd0JBQUc7RUFDVCxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO0lBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7RUFDdEIsQ0FBQztFQUNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUNyQixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7QUFDRCwyQkFBUSxzQkFBQyxHQUFHLEVBQUU7RUFDWixJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUNwQixDQUFDOztBQUVELDJCQUFRLHdCQUFHO0VBQ1QsT0FBTyxrQkFBZ0IsSUFBRSxJQUFJLENBQUMsS0FBSyxhQUFRLElBQUUsSUFBSSxDQUFDLE1BQU0sT0FBRSxDQUFDLENBQUM7QUFDOUQsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7QUFDRCxTQUFPLE1BQU0sb0JBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtFQUN6QixPQUFPLElBQUksUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBRUY7O0FBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDOzs7Ozs7O0FDOUZSLFVBQUcsbUJBQU8sQ0FBQyxHQUFzQixDQUFDO0FBQXJELHFCQUFpQix5QkFBcUM7QUFDckMsWUFBRyxtQkFBTyxDQUFDLEdBQXFCLENBQUM7QUFBbEQsbUJBQWUseUJBQW9DO0FBQ2hDLFlBQUcsbUJBQU8sQ0FBQyxHQUF1QixDQUFDO0FBQXRELHFCQUFpQiwyQkFBc0M7QUFDckMsWUFBRyxtQkFBTyxDQUFDLEdBQXNCLENBQUM7QUFBcEQsb0JBQWdCLDBCQUFxQztBQUMxQyxZQUFHLG1CQUFPLENBQUMsRUFBYyxDQUFDO0FBQXJDLGFBQVMsbUJBQTZCO0FBQ3hCLFlBQUcsbUJBQU8sQ0FBQyxFQUFpQixDQUFDO0FBQTNDLGdCQUFZLHNCQUFnQztBQUNyQyxZQUFHLG1CQUFPLENBQUMsR0FBVSxDQUFDO0FBQTdCLFNBQUssZUFBeUI7QUFDbEIsWUFBRyxtQkFBTyxDQUFDLEdBQWUsQ0FBQztBQUF2QyxjQUFVLG9CQUE4QjtBQUNuQixZQUFHLG1CQUFPLENBQUMsR0FBeUIsQ0FBQztBQUExRCx1QkFBbUIsNkJBQXdDOztBQUVuRSxNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO0FBQ3JELE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztBQUNqRCxNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO0FBQ3JELE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQ3JDLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztBQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDN0IsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBQ3ZDLE1BQU0sQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEdBQUcsbUJBQW1CLENBQUM7Ozs7Ozs7QUNsQjFDLFVBQUcsbUJBQU8sQ0FBQyxHQUFhLENBQUM7QUFBaEMsU0FBSyxhQUE0Qjs7QUFFekMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0FDRjdCOzs7O0FBSWtCLFVBQUcsbUJBQU8sQ0FBQyxHQUFhLENBQUM7QUFBbkMsWUFBUSxnQkFBNEI7QUFDN0IsWUFBRyxtQkFBTyxDQUFDLEVBQWEsQ0FBQztBQUFoQyxTQUFLLGVBQTRCO0FBQ25CLFlBQUcsbUJBQU8sQ0FBQyxHQUFxQixDQUFDO0FBQS9DLGdCQUFZLHNCQUFvQzs7QUFFeEQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ25DLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM3QixNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Ozs7Ozs7QUNWMUIsVUFBRyxtQkFBTyxDQUFDLEdBQWUsQ0FBQztBQUFwQyxXQUFPLGVBQThCO0FBQ2pCLFlBQUcsbUJBQU8sQ0FBQyxFQUE0QixDQUFDO0FBQTVELHNCQUFrQiw0QkFBMkM7QUFDcEMsWUFBRyxtQkFBTyxDQUFDLEVBQW1DLENBQUM7QUFBeEUsMkJBQXVCLGlDQUFrRDtBQUN4RCxZQUFHLG1CQUFPLENBQUMsRUFBMEIsQ0FBQztBQUF2RCxtQkFBZSx5QkFBeUM7QUFDM0IsWUFBRyxtQkFBTyxDQUFDLEdBQXNDLENBQUM7QUFBL0UsK0JBQTJCLHFDQUFxRDtBQUMvRCxZQUFHLG1CQUFPLENBQUMsRUFBeUIsQ0FBQztBQUF0RCxtQkFBZSx5QkFBd0M7QUFDMUMsWUFBRyxtQkFBTyxDQUFDLEdBQXFCLENBQUM7QUFBOUMsZUFBVyxxQkFBb0M7QUFDM0IsWUFBRyxtQkFBTyxDQUFDLEVBQThCLENBQUM7QUFBOUQsc0JBQWtCLDRCQUE2Qzs7QUFFN0MsWUFBRyxtQkFBTyxDQUFDLENBQW1CLENBQUM7QUFBakQsb0JBQWdCLDBCQUFrQzs7Ozs7Ozs7QUFRMUQsZ0JBQWdCLENBQUMsYUFBYSxHQUFHLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxZQUFNLGFBQUksT0FBTyxFQUFFLElBQUMsQ0FBQzs7QUFFckYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ2pDLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7QUFDdkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRyx1QkFBdUIsQ0FBQztBQUNqRSxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsR0FBRywyQkFBMkIsQ0FBQztBQUN6RSxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQ3pDLE1BQU0sQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7Ozs7Ozs7QUMxQnpDLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7OztBQU01Q0EsR0FBSyxDQUFDLG1CQUFtQixHQUFHO0VBQzFCLEVBQUUsMkJBQTJCLENBQUM7RUFDOUIsSUFBSSx5QkFBeUIsQ0FBQztFQUM5QixRQUFRLHFCQUFxQixDQUFDO0VBQzlCLGlCQUFpQixZQUFZLENBQUM7RUFDOUIsMkJBQTJCLEVBQUUsQ0FBQztFQUM5QixnQkFBZ0IsYUFBYSxDQUFDO0NBQy9CLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7Ozs7QUFJbkUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxhQUFhLENBQUM7RUFDL0MsSUFBSSwyQkFBMkIsbUJBQW1CLENBQUMsRUFBRTtFQUNyRCxNQUFNLHlCQUF5QixtQkFBbUIsQ0FBQyxJQUFJO0VBQ3ZELFVBQVUscUJBQXFCLG1CQUFtQixDQUFDLFFBQVE7RUFDM0QsbUJBQW1CLFlBQVksbUJBQW1CLENBQUMsaUJBQWlCO0VBQ3BFLDZCQUE2QixFQUFFLG1CQUFtQixDQUFDLDJCQUEyQjtFQUM5RSxtQkFBbUIsWUFBWSxtQkFBbUIsQ0FBQyxnQkFBZ0I7Q0FDcEUsQ0FBQyxDQUFDOzs7Ozs7OztBQzFCOEIsVUFBRyxtQkFBTyxDQUFDLEdBQWlDLENBQUM7QUFBdEUsMkJBQXVCLCtCQUFnRDtBQUN0RCxZQUFHLG1CQUFPLENBQUMsRUFBMEIsQ0FBQztBQUF2RCxtQkFBZSx5QkFBeUM7QUFDdkMsWUFBRyxtQkFBTyxDQUFDLEdBQXdCLENBQUM7QUFBckQsbUJBQWUseUJBQXVDO0FBQzVCLFlBQUcsbUJBQU8sQ0FBQyxHQUFrQyxDQUFDO0FBQXhFLDRCQUF3QixrQ0FBaUQ7QUFDbkQsWUFBRyxtQkFBTyxDQUFDLEVBQStCLENBQUM7QUFBakUsd0JBQW9CLDhCQUE4QztBQUNoRCxZQUFHLG1CQUFPLENBQUMsRUFBeUIsQ0FBQztBQUF2RCxvQkFBZ0IsMEJBQXdDO0FBQ3ZDLFlBQUcsbUJBQU8sQ0FBQyxHQUF3QixDQUFDO0FBQXJELG1CQUFlLHlCQUF1QztBQUM1QixZQUFHLG1CQUFPLENBQUMsR0FBa0MsQ0FBQztBQUF4RSw0QkFBd0Isa0NBQWlEO0FBQzlELFlBQUcsbUJBQU8sQ0FBQyxFQUFtQixDQUFDO0FBQTFDLGFBQVMsbUJBQWtDOztBQUVuRCxNQUFNLENBQUMsT0FBTyxDQUFDLHVCQUF1QixHQUFHLHVCQUF1QixDQUFDO0FBQ2pFLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztBQUNqRCxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7QUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyx3QkFBd0IsQ0FBQztBQUNuRSxNQUFNLENBQUMsT0FBTyxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDO0FBQzNELE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO0FBQ2pELE1BQU0sQ0FBQyxPQUFPLENBQUMsd0JBQXdCLEdBQUcsd0JBQXdCLENBQUM7QUFDbkUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDOzs7Ozs7O0FDbEJ0QixVQUFHLG1CQUFPLENBQUMsR0FBZ0IsQ0FBQztBQUFuQyxTQUFLLGFBQStCO0FBQ3ZCLFlBQUcsbUJBQU8sQ0FBQyxHQUFtQixDQUFDO0FBQTVDLGVBQVcscUJBQWtDO0FBQ25DLFlBQUcsbUJBQU8sQ0FBQyxFQUFrQixDQUFDO0FBQXhDLFlBQVEsa0JBQWlDOztBQUVqRCxNQUFNLENBQUMsT0FBTyxHQUFHO0VBQ2YsWUFBSztFQUNMLGtCQUFRO0VBQ1Isd0JBQVc7Q0FDWixDQUFDOzs7Ozs7O0FDUlksVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBbkMsUUFBSSxZQUFnQzs7Ozs7Ozs7Ozs7O0FBWTVDQSxHQUFLLENBQUMsaUJBQWlCLEdBQUc7Ozs7Ozs7Ozs7Ozs7RUFheEIsV0FBVyxFQUFFLGFBQWE7Ozs7Ozs7Ozs7Ozs7RUFhMUIsV0FBVyxFQUFFLGFBQWE7Ozs7Ozs7Ozs7Ozs7OztFQWUxQixxQkFBcUIsRUFBRSx1QkFBdUI7Ozs7Ozs7Ozs7OztFQVk5QyxTQUFTLEVBQUUsV0FBVzs7Q0FFdkIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7Ozs7OztBQ3JFakMsVUFBRyxtQkFBTyxDQUFDLEVBQThCLENBQUM7QUFBaEUsd0JBQW9CLDRCQUE2QztBQUNqRCxZQUFHLG1CQUFPLENBQUMsRUFBd0IsQ0FBQztBQUFwRCxrQkFBYyx3QkFBdUM7QUFDcEMsWUFBRyxtQkFBTyxDQUFDLEdBQTBCLENBQUM7QUFBdkQsbUJBQWUseUJBQXlDO0FBQ2hDLFlBQUcsbUJBQU8sQ0FBQyxHQUFrQyxDQUFDO0FBQXRFLDBCQUFzQixnQ0FBaUQ7QUFDOUQsWUFBRyxtQkFBTyxDQUFDLEdBQWUsQ0FBQztBQUFwQyxXQUFPLGlCQUE4QjtBQUN2QixZQUFHLG1CQUFPLENBQUMsRUFBcUIsQ0FBQztBQUEvQyxnQkFBWSxzQkFBb0M7QUFDNUIsWUFBRyxtQkFBTyxDQUFDLEdBQTZCLENBQUM7QUFBN0Qsc0JBQWtCLDRCQUE0QztBQUM1QyxZQUFHLG1CQUFPLENBQUMsRUFBMkIsQ0FBQztBQUF6RCxvQkFBZ0IsMEJBQTBDO0FBQ3hDLFlBQUcsbUJBQU8sQ0FBQyxFQUEyQixDQUFDO0FBQXpELG9CQUFnQiwwQkFBMEM7QUFDdkMsWUFBRyxtQkFBTyxDQUFDLEVBQTBCLENBQUM7QUFBekQscUJBQWlCLDJCQUF5QztBQUM1QyxhQUFHLG1CQUFPLENBQUMsR0FBc0IsQ0FBQztBQUFoRCxnQkFBWSx1QkFBcUM7O0FBRS9CLGFBQUcsbUJBQU8sQ0FBQyxDQUFtQixDQUFDO0FBQWpELG9CQUFnQiwyQkFBa0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUIxRCxnQkFBZ0IsQ0FBQyxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsYUFBYTtFQUM3RCxVQUFDLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUN4RCxhQUFJLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsQ0FBQyxJQUFDLENBQUM7O0FBRTVFLE1BQU0sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEdBQUcsb0JBQW9CLENBQUM7QUFDM0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0FBQy9DLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztBQUNqRCxNQUFNLENBQUMsT0FBTyxDQUFDLHNCQUFzQixHQUFHLHNCQUFzQixDQUFDO0FBQy9ELE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNqQyxNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDO0FBQ3ZELE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0FBQzNDLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDbkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztBQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Ozs7Ozs7QUMzQzdCLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7QUFPNUNBLEdBQUssQ0FBQyxXQUFXLEdBQUc7RUFDbEIsSUFBSSxnQkFBZ0IsSUFBSTtFQUN4QixJQUFJLGdCQUFnQixJQUFJO0VBQ3hCLE1BQU0sY0FBYyxJQUFJO0VBQ3hCLE9BQU8sYUFBYSxJQUFJO0VBQ3hCLEdBQUcsaUJBQWlCLElBQUk7RUFDeEIsSUFBSSxnQkFBZ0IsSUFBSTtFQUN4QixPQUFPLGFBQWEsSUFBSTtFQUN4QixPQUFPLGFBQWEsSUFBSTtFQUN4QixNQUFNLGNBQWMsSUFBSTtFQUN4QixTQUFTLFdBQVcsSUFBSTtFQUN4QixXQUFXLFNBQVMsSUFBSTtFQUN4QixVQUFVLFVBQVUsSUFBSTtFQUN4QixLQUFLLGVBQWUsSUFBSTtFQUN4QixJQUFJLGdCQUFnQixJQUFJO0VBQ3hCLEdBQUcsaUJBQWlCLElBQUk7RUFDeEIsSUFBSSxnQkFBZ0IsSUFBSTtFQUN4QixVQUFVLFVBQVUsSUFBSTtFQUN4QixTQUFTLFdBQVcsSUFBSTtFQUN4QixrQkFBa0IsRUFBRSxJQUFJO0VBQ3hCLFFBQVEsWUFBWSxJQUFJOztDQUV6QixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7Ozs7Ozs7QUMvQmhDLFVBQUcsbUJBQU8sQ0FBQyxHQUFrQixDQUFDO0FBQXpDLGFBQVMsaUJBQWlDO0FBQ25CLFlBQUcsbUJBQU8sQ0FBQyxHQUE4QixDQUFDO0FBQWpFLHlCQUFxQiwrQkFBNkM7QUFDbEQsWUFBRyxtQkFBTyxDQUFDLEVBQXVCLENBQUM7QUFBbkQsa0JBQWMsd0JBQXNDO0FBQ2xDLFlBQUcsbUJBQU8sQ0FBQyxHQUF5QixDQUFDO0FBQXZELG9CQUFnQiwwQkFBd0M7QUFDckMsWUFBRyxtQkFBTyxDQUFDLEVBQTJCLENBQUM7QUFBMUQscUJBQWlCLDJCQUEwQztBQUN0QyxZQUFHLG1CQUFPLENBQUMsRUFBOEIsQ0FBQztBQUEvRCx1QkFBbUIsNkJBQTZDO0FBQ3JDLFlBQUcsbUJBQU8sQ0FBQyxFQUFxQyxDQUFDO0FBQTVFLDZCQUF5QixtQ0FBb0Q7QUFDckQsWUFBRyxtQkFBTyxDQUFDLEVBQWdDLENBQUM7QUFBcEUsMEJBQXNCLGdDQUErQzs7O0FBRzdFLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUNyQyxNQUFNLENBQUMsT0FBTyxDQUFDLHFCQUFxQixHQUFHLHFCQUFxQixDQUFDO0FBQzdELE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztBQUMvQyxNQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQ25ELE1BQU0sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7QUFDckQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztBQUN6RCxNQUFNLENBQUMsT0FBTyxDQUFDLHlCQUF5QixHQUFHLHlCQUF5QixDQUFDO0FBQ3JFLE1BQU0sQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEdBQUcsc0JBQXNCLENBQUM7Ozs7Ozs7QUNqQmpELFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7QUFPNUNBLEdBQUssQ0FBQyx5QkFBeUIsR0FBRzs7RUFFaEMsU0FBUyxZQUFZLENBQUM7O0VBRXRCLGdCQUFnQixLQUFLLENBQUM7O0VBRXRCLGVBQWUsTUFBTSxDQUFDOztFQUV0QixpQkFBaUIsSUFBSSxDQUFDOztFQUV0QixhQUFhLFFBQVEsQ0FBQzs7RUFFdEIsZUFBZSxNQUFNLENBQUM7O0VBRXRCLFVBQVUsV0FBVyxDQUFDOztFQUV0QixnQkFBZ0IsS0FBSyxFQUFFOztFQUV2QixtQkFBbUIsRUFBRSxFQUFFO0NBQ3hCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7Ozs7Ozs7QUM1QmpFLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7OztBQVM1Q0EsR0FBSyxDQUFDLGVBQWUsR0FBRzs7OztFQUl0QixLQUFLLFlBQVksT0FBTzs7OztFQUl4QixLQUFLLFlBQVksT0FBTzs7OztFQUl4QixlQUFlLEVBQUUsaUJBQWlCO0NBQ25DLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQzs7OztBQUkzRCxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUM7RUFDM0MsT0FBTyxZQUFZLGVBQWUsQ0FBQyxLQUFLO0VBQ3hDLE9BQU8sWUFBWSxlQUFlLENBQUMsS0FBSztFQUN4QyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsZUFBZTtDQUNuRCxDQUFDLENBQUM7Ozs7Ozs7O0FDaENIQSxHQUFLLENBQUMsbUJBQW1CLEdBQUcsbUJBQU8sQ0FBQyxDQUFtQixDQUFDLENBQUM7QUFDeEMsVUFBRyxtQkFBTyxDQUFDLENBQW1CLENBQUM7QUFBeEMsV0FBTyxlQUFrQztBQUN4QixZQUFHLG1CQUFPLENBQUMsRUFBb0IsQ0FBQztBQUFqRCxtQkFBZSx5QkFBbUM7QUFDdkMsWUFBRyxtQkFBTyxDQUFDLENBQWUsQ0FBQztBQUF0QyxhQUFTLG1CQUE4QjtBQUNwQixZQUFHLG1CQUFPLENBQUMsQ0FBZ0IsQ0FBQztBQUEvQyxRQUFJO0FBQUUsZUFBVyxxQkFBK0I7O0FBRWhELGNBQVU7QUFBRSxjQUFVLHNCQUFhO0FBQ25DLGtCQUFjLHNDQUF5Qjs7QUFFdkMsZUFBVztBQUFFLHNCQUFrQixrQ0FBaUI7QUFDbEIsWUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBM0QsZ0JBQVk7QUFBRSxrQkFBYyx3QkFBZ0M7O0FBRXBFQSxHQUFLLENBQUMsNEJBQTRCLEdBQUcsQ0FHckMsQ0FIc0M7NEJBQ3BDLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFZLFdBQVc7NEJBQzlDLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxHQUFFLFlBQ3BDLENBQUM7O0FBRUYsU0FBUyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtFQUM3Q0EsR0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0VBQ3ZDLFFBQVEsSUFBSTtJQUNWLEtBQUssZUFBZSxDQUFDLEtBQUs7TUFDeEIsT0FBTyxhQUFXLEdBQUUsSUFBSSxNQUFFLEdBQUUsRUFBRSxDQUFFLENBQUM7SUFDbkMsS0FBSyxlQUFlLENBQUMsZUFBZTtNQUNsQyxPQUFPLGFBQVcsR0FBRSxJQUFJLE1BQUUsR0FBRSxFQUFFLENBQUUsQ0FBQztJQUNuQztNQUNFLFNBQVMsQ0FBQyxrQ0FBa0MsRUFBRSxlQUFlLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7R0FDakY7RUFDRCxPQUFPLFNBQVMsQ0FBQztDQUNsQjs7QUFFRCxTQUFTLFlBQVksQ0FBQyxJQUFJLEVBQUU7RUFDMUIsT0FBTyw0QkFBNEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Q0FDakQ7O0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFO0VBQzVDLE9BQU8sSUFBSSxjQUFjLENBQUMsV0FBUyxHQUFFLElBQUksT0FBRyxHQUFFLFFBQVEsQ0FBRSxFQUFFLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0NBQzlGOzs7Ozs7Ozs7QUFTRCxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUk7d0JBQ2pCLGdCQUF3RCxFQUFFLENBQTFDO3FEQUFBLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7QUFBRztFQUNqRkUsR0FBRyxDQUFDLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7RUFXVkYsR0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0VBQy9CLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtJQUNsQixLQUFLLEdBQUcsZ0JBQWdCLENBQUMscUNBQXFDLENBQUMsQ0FBQztJQUNoRSxPQUFPLEVBQUUsWUFBSyxFQUFFLENBQUM7R0FDbEI7OztFQUdEQSxHQUFLLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7RUFDakMsSUFBSSxXQUFXLEdBQUcsR0FBRyxFQUFFO0lBQ3JCLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxxREFBbUQsR0FDbkQsV0FBVyxjQUFVLEdBQUUsSUFBSSxNQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3pELE9BQU8sRUFBRSxZQUFLLEVBQUUsQ0FBQztHQUNsQjs7RUFFREUsR0FBRyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7RUFDekIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7SUFDdkMsWUFBWSxHQUFHLElBQUksQ0FBQztHQUNyQjs7RUFFRCxLQUFLQSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQ25DLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7TUFDcEIsS0FBSyxHQUFHO1FBQ04sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7VUFDbkUsS0FBSyxHQUFHLGdCQUFnQixDQUFDLHNCQUFvQixHQUFFLElBQUksT0FBRyxHQUFFLENBQUMsTUFBRSxDQUFDLENBQUMsQ0FBQztVQUM5RCxPQUFPLEVBQUUsWUFBSyxFQUFFLENBQUM7U0FDbEI7UUFDRCxNQUFNOztNQUVSLEtBQUssR0FBRztRQUNOLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxFQUFFOztVQUUxRCxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsMkJBQXlCLEdBQUUsSUFBSSxPQUFHLEdBQUUsQ0FBQyxNQUFFLENBQUMsQ0FBQyxDQUFDO1VBQ25FLE9BQU8sRUFBRSxZQUFLLEVBQUUsQ0FBQztTQUNsQjs7UUFFRCxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLE1BQU07O01BRVI7UUFDRSxNQUFNO0tBQ1Q7R0FDRjs7RUFFRCxPQUFPLEVBQUUsMEJBQVksRUFBRSxDQUFDO0NBQ3pCOztBQUVELFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRTtFQUMxQixPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUMsZUFBZTtNQUN2QyxFQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsWUFBTyxDQUFDO01BQzVCLENBQUcsS0FBSyxXQUFPLENBQUMsQ0FBQztDQUN0Qjs7QUFFRCxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUU7RUFDMUIsT0FBTyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLGVBQWU7TUFDMUQsVUFBVSxDQUFDLEtBQUssQ0FBQztNQUNqQixLQUFLLENBQUMsQ0FBQztDQUNaOzs7Ozs7Ozs7QUFTRCxTQUFTLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFO0VBQzFCRixHQUFLLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztFQUNsQ0EsR0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0VBQzdCQSxHQUFLLENBQUMsV0FBVyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUM7RUFDbENBLEdBQUssQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0VBQ3ZDLE9BQU8sRUFBRSxZQUFLLEVBQUUsY0FBTSxFQUFFLHdCQUFXLEVBQUUsQ0FBQztDQUN2Qzs7Ozs7Ozs7Ozs7O0FBWUQsU0FBUyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLGdCQUF3RCxFQUFFLENBQTFDO3FEQUFBLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7QUFBRztFQUN6RSxVQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO0VBQXBDLFNBQUs7RUFBRSxVQUFNLGNBQXdCO0VBQ0osWUFBRyxjQUFjLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLENBQUM7RUFBaEYsY0FBVTtFQUFFLGdCQUFZLHNCQUF5RDtFQUNoR0UsR0FBRyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUM7Ozs7RUFJdkIsSUFBSSxDQUFDLEtBQUssRUFBRTtJQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxVQUFVLEVBQUs7TUFDN0RGLEdBQUssQ0FBQyxNQUFNLEdBQUcsNEJBQTRCLENBQUMsVUFBVSxDQUFDLENBQUM7TUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDNUIsT0FBTyxLQUFLLENBQUM7T0FDZDs7TUFFRCxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsb0JBQWtCLEdBQUUsTUFBTSwwQkFBc0IsR0FBRSxJQUFJLE1BQUUsQ0FBQyxDQUFDLENBQUM7TUFDcEYsT0FBTyxJQUFJLENBQUM7S0FDYixDQUFDLENBQUM7R0FDSjs7RUFFRCxPQUFPLEVBQUUsWUFBSyxFQUFFLGNBQU0sRUFBRSxZQUFLLEVBQUUsMEJBQVksRUFBRSxDQUFDO0NBQy9DOztBQUVEQSxHQUFLLENBQUMsZUFBZSxHQUFHO0VBQ3RCLDBCQUFZO0VBQ1osd0NBQW1CO0VBQ25CLHdCQUFXO0VBQ1gsY0FBTTtFQUNOLHdCQUFXO0VBQ1gsOEJBQWM7RUFDZCx3QkFBVztFQUNYLG9DQUFpQjtDQUNsQixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQzs7Ozs7OztBQzlLN0IsVUFBRyxtQkFBTyxDQUFDLEdBQWUsQ0FBQztBQUF2QyxjQUFVLGtCQUE4QjtBQUM3QixZQUFHLG1CQUFPLENBQUMsR0FBYyxDQUFDO0FBQXJDLGFBQVMsbUJBQTZCO0FBQ3hCLFlBQUcsbUJBQU8sQ0FBQyxFQUFpQixDQUFDO0FBQTNDLGdCQUFZLHNCQUFnQzs7Ozs7OztBQU9wRCxJQUFNLEtBQUssR0FBcUI7RUFZOUIsY0FBVyxDQUFDLElBQUksRUFBRSxVQUFpQixFQUFFLENBQUM7c0JBQVY7MkNBQUEsR0FBRyxJQUFJO0FBQUc7SUFDcENHLFlBQUssTUFBQyxVQUFJLENBQUMsQ0FBQzs7SUFFWkgsR0FBSyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtNQUN2Qiw0QkFBYTtNQUNiLFNBQVMsYUFBYSxFQUFFO01BQ3hCLFdBQVcsV0FBVyxFQUFFO01BQ3hCLFVBQVUsWUFBWSxFQUFFO01BQ3hCLFlBQVksVUFBYyxhQUFhLENBQUMsZUFBZSxFQUFFLFNBQUUsS0FBSSxFQUFDO01BQ2hFLG9CQUFvQixFQUFFLFdBQUMsRUFBSTtRQUN6QixhQUFhLENBQUMsV0FBVztZQUNyQixhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUM1QixhQUFhLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztPQUMvQztLQUNGLENBQUMsQ0FBQztJQUNILElBQUksYUFBYSxFQUFFLE1BQUksQ0FBQyxHQUFHLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7OztJQUczRCxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUs7TUFDM0NBLEdBQUssQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ2hDQyxNQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxTQUFTLEtBQUssVUFBVSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUNBLE1BQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQztLQUM5RSxDQUFDLENBQUM7O0lBRUgsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7R0FDL0Q7Ozs7c0NBQUE7Ozs7Ozs7Ozs7OztFQVlELHdCQUFRLHNCQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUU7SUFDeEIsSUFBSSxDQUFDLFNBQVMsRUFBRSxRQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7SUFDOUQsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFNLElBQUksS0FBSyxDQUFDLHFDQUFtQyxHQUFFLFNBQVMsQ0FBRSxDQUFDLENBQUM7O0lBRTdFLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQW9CLElBQUUsSUFBSSxpQkFBWSxHQUFFLFNBQVMsQ0FBRSxDQUFDLENBQUM7O0lBRTlELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUU7TUFDbEMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxzQkFBb0IsSUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBTyxHQUFFLElBQUksQ0FBRSxDQUFDLENBQUM7S0FDL0U7SUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELE9BQU8sSUFBSSxDQUFDO0dBQ2I7Ozs7Ozs7Ozs7RUFVRCwwQkFBVSx3QkFBQyxjQUFjLEVBQUUsSUFBSSxFQUFFO0lBQy9CLElBQUksQ0FBQyxjQUFjLEVBQUUsUUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0lBQzVFLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBc0MsR0FBRSxjQUFjLENBQUUsQ0FBQyxDQUFDOztJQUVyRixJQUFJLENBQUMsR0FBRyxDQUFDLHFCQUFtQixHQUFFLGNBQWMsU0FBSyxJQUFFLElBQUksRUFBRSxDQUFDLENBQUM7O0lBRTNELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEVBQUU7TUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFZLEdBQUUsY0FBYyx3QkFBb0IsSUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO01BQ25FLE9BQU8sSUFBSSxDQUFDO0tBQ2I7O0lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsSUFBSSxVQUFVLENBQUM7TUFDckQsS0FBSyxFQUFFLElBQUk7TUFDWCw4QkFBYztNQUNkLFVBQUk7S0FDTCxDQUFDLENBQUM7O0lBRUgsT0FBTyxJQUFJLENBQUM7R0FDYjs7Ozs7Ozs7OztFQVVELHlCQUFTLHVCQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUU7SUFDN0IsSUFBSSxDQUFDLGFBQWEsRUFBRSxRQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7SUFDMUUsSUFBSSxDQUFDLElBQUksRUFBRSxRQUFNLElBQUksS0FBSyxDQUFDLHVDQUFxQyxHQUFFLGFBQWEsQ0FBRSxDQUFDLENBQUM7O0lBRW5GLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQWtCLEdBQUUsYUFBYSxTQUFLLElBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQzs7SUFFekQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRTtNQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQVcsR0FBRSxhQUFhLHlCQUFxQixJQUFFLElBQUksRUFBRSxDQUFDLENBQUM7TUFDbEUsT0FBTyxJQUFJLENBQUM7S0FDYjs7SUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLFNBQVMsQ0FBQztNQUNsRCxLQUFLLEVBQUUsSUFBSTtNQUNYLDRCQUFhO01BQ2IsVUFBSTtLQUNMLENBQUMsQ0FBQzs7SUFFSCxPQUFPLElBQUksQ0FBQztHQUNiOzs7Ozs7Ozs7RUFTRCxzQ0FBc0Isb0NBQUMsY0FBYyxFQUFFO0lBQ3JDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssU0FBUyxFQUFFO01BQ3ZELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRyxJQUFJLG1CQUFjLEdBQUUsY0FBYyxxQkFBaUIsQ0FBQyxDQUFDLENBQUM7TUFDbEUsT0FBTyxJQUFJLENBQUM7S0FDYjs7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO0dBQzdEOzs7Ozs7Ozs7RUFTRCxxQ0FBcUIsbUNBQUMsYUFBYSxFQUFFO0lBQ25DLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEtBQUssU0FBUyxFQUFFO01BQ3JELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRyxJQUFJLGtCQUFhLEdBQUUsYUFBYSxxQkFBaUIsQ0FBQyxDQUFDLENBQUM7TUFDaEUsT0FBTyxJQUFJLENBQUM7S0FDYjs7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO0dBQzNEOzs7Ozs7Ozs7O0VBVUQscUJBQUssbUJBQUMsSUFBSSxFQUFFO0lBQ1YsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtNQUMxQixJQUFJLENBQUMsR0FBRyxDQUFDLDRCQUEwQixJQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxZQUFPLEdBQUUsSUFBSSxDQUFFLENBQUMsQ0FBQztLQUM3RTtJQUNELElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsT0FBTyxJQUFJLENBQUM7R0FDYjs7Ozs7Ozs7OztFQVVELG9CQUFJLGtCQUFDLElBQUksRUFBRTtJQUNULElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7TUFDekIsSUFBSSxDQUFDLEdBQUcsQ0FBQywyQkFBeUIsSUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsWUFBTyxHQUFFLElBQUksQ0FBRSxDQUFDLENBQUM7S0FDM0U7SUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hDLE9BQU8sSUFBSSxDQUFDO0dBQ2I7Ozs7Ozs7Ozs7Ozs7RUFhRCxvQ0FBb0Isa0NBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtJQUNsQyxPQUFPLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQztNQUNyQyxNQUFNLEtBQUssSUFBSTtNQUNmLFNBQVMsRUFBRSxLQUFLO01BQ2hCLGNBQU07TUFDTixRQUFRLEdBQUcsSUFBSTtLQUNoQixDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7Ozs7OztFQWFELHNDQUFzQixvQ0FBQyxLQUFLLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRTtJQUNwRCxPQUFPLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQztNQUNyQyxNQUFNLEtBQUssSUFBSTtNQUNmLFNBQVMsRUFBRSxLQUFLLENBQUMsc0JBQXNCLENBQUMsY0FBYyxDQUFDO01BQ3ZELGNBQU07S0FDUCxDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7Ozs7OztFQWFELHFDQUFxQixtQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRTtJQUNsRCxPQUFPLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQztNQUNyQyxNQUFNLEtBQUssSUFBSTtNQUNmLFNBQVMsRUFBRSxLQUFLLENBQUMscUJBQXFCLENBQUMsYUFBYSxDQUFDO01BQ3JELGNBQU07S0FDUCxDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7OztFQVVELDhCQUFjLDhCQUFHO0lBQ2YsT0FBTyxJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUM7TUFDckMsTUFBTSxFQUFFLElBQUk7S0FDYixDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7Ozs7O0VBWUQsa0NBQWtCLGdDQUFDLE1BQU0sRUFBRTtJQUN6QixPQUFPLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQztNQUNyQyxNQUFNLEtBQUssSUFBSTtNQUNmLFNBQVMsRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsZUFBZSxFQUFFO01BQ25ELGNBQU07S0FDUCxDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7RUFRRCx5QkFBUyx1QkFBQyxNQUFNLEVBQUU7SUFDaEIsT0FBTyxJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUM7TUFDckMsTUFBTSxLQUFLLElBQUk7TUFDZixTQUFTLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLGFBQWEsRUFBRTtNQUNqRCxjQUFNO0tBQ1AsQ0FBQyxDQUFDO0dBQ0o7Ozs7Ozs7OztFQVNELHlCQUFTLHlCQUFHO0lBQ1YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQztHQUNoQzs7Ozs7OztFQU9ELHVCQUFPLHVCQUFHO0lBQ1IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFXLElBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM5QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO01BQzFCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDMUI7R0FDRjs7Ozs7OztFQU9ELHNCQUFNLHNCQUFHO0lBQ1AsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFVLElBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO01BQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDekI7R0FDRjs7Ozs7Ozs7RUFRRCwyQkFBVyx5QkFBQyxDQUFDLEVBQUU7SUFDYixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVUsR0FBRSxDQUFDLENBQUUsQ0FBQyxDQUFDO0lBQzFCRCxHQUFLLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELElBQUksUUFBUSxFQUFFO01BQ1pBLEdBQUssQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7TUFHM0IsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLElBQUksQ0FBQyxHQUFHLENBQUMsZ0NBQThCLEdBQUUsQ0FBQyxTQUFLLElBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztPQUMxRDtNQUNELElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRTtRQUNwQixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVUsR0FBRSxDQUFDLENBQUUsQ0FBQyxDQUFDO1FBQzFCLE9BQU8sTUFBTSxDQUFDO09BQ2Y7TUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQVksR0FBRSxDQUFDLFNBQUssSUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0tBQ3hDLE1BQU07TUFDTCxJQUFJLENBQUMsR0FBRyxDQUFDLGdCQUFjLEdBQUUsQ0FBQyxTQUFLLElBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztLQUMxQzs7SUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDMUMsQ0FDRjs7O0VBNVZtQixZQTRWbkI7O0FBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOzs7Ozs7O0FDdldmLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQjVDQSxHQUFLLENBQUMsd0JBQXdCLEdBQUc7Ozs7O0VBSy9CLEVBQUUsb0JBQW9CLDZCQUE2Qjs7Ozs7OztFQU9uRCxJQUFJLGtCQUFrQiwrQkFBK0I7Ozs7OztFQU1yRCxNQUFNLGdCQUFnQixpQ0FBaUM7Ozs7OztFQU12RCxRQUFRLGNBQWMsbUNBQW1DOzs7Ozs7O0VBT3pELFVBQVUsWUFBWSxvQ0FBb0M7Ozs7Ozs7O0VBUTFELG9CQUFvQixFQUFFLDZDQUE2Qzs7Ozs7Ozs7RUFRbkUsV0FBVyxXQUFXLHFDQUFxQzs7Ozs7O0VBTTNELFFBQVEsY0FBYyxtQ0FBbUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtQnpELE9BQU8sZUFBZSxrQ0FBa0M7Q0FDekQsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsQ0FBQzs7Ozs7OztBQzlGbkQsVUFBRyxtQkFBTyxDQUFDLEdBQXlCLENBQUM7QUFBdkQsb0JBQWdCLHdCQUF3QztBQUN2QixZQUFHLG1CQUFPLENBQUMsRUFBMkMsQ0FBQztBQUF4RixtQ0FBK0IseUNBQTBEO0FBQzlELFlBQUcsbUJBQU8sQ0FBQyxFQUFxQyxDQUFDO0FBQTVFLDZCQUF5QixtQ0FBb0Q7QUFDakQsWUFBRyxtQkFBTyxDQUFDLEdBQW9DLENBQUM7QUFBNUUsOEJBQTBCLG9DQUFtRDtBQUN4QyxZQUFHLG1CQUFPLENBQUMsR0FBOEMsQ0FBQztBQUEvRix1Q0FBbUMsNkNBQTZEO0FBQzdFLFlBQUcsbUJBQU8sQ0FBQyxFQUEyQixDQUFDO0FBQTFELHFCQUFpQiwyQkFBMEM7QUFDbkMsWUFBRyxtQkFBTyxDQUFDLEVBQWlDLENBQUM7QUFBckUsMEJBQXNCLGdDQUFnRDs7QUFFOUUsTUFBTSxDQUFDLE9BQU8sQ0FBQywrQkFBK0IsR0FBRywrQkFBK0IsQ0FBQztBQUNqRixNQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO0FBQ25ELE1BQU0sQ0FBQyxPQUFPLENBQUMsMEJBQTBCLEdBQUcsMEJBQTBCLENBQUM7QUFDdkUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQztBQUNyRCxNQUFNLENBQUMsT0FBTyxDQUFDLHNCQUFzQixHQUFHLHNCQUFzQixDQUFDO0FBQy9ELE1BQU0sQ0FBQyxPQUFPLENBQUMsbUNBQW1DLEdBQUcsbUNBQW1DLENBQUM7QUFDekYsTUFBTSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsR0FBRyx5QkFBeUIsQ0FBQzs7Ozs7OztBQ2R2RCxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7QUFNNUNBLEdBQUssQ0FBQyxZQUFZLEdBQUc7RUFDbkIsSUFBSSxhQUFhLElBQUk7RUFDckIsT0FBTyxVQUFVLElBQUk7RUFDckIsT0FBTyxVQUFVLElBQUk7RUFDckIsZUFBZSxFQUFFLElBQUk7RUFDckIsS0FBSyxZQUFZLElBQUk7RUFDckIsSUFBSSxhQUFhLElBQUk7RUFDckIsU0FBUyxRQUFRLElBQUk7RUFDckIsTUFBTSxXQUFXLElBQUk7RUFDckIsV0FBVyxNQUFNLElBQUk7RUFDckIsVUFBVSxPQUFPLElBQUk7RUFDckIsR0FBRyxjQUFjLElBQUk7RUFDckIsTUFBTSxXQUFXLElBQUk7Q0FDdEIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7O0FDckJyRDs7OztBQUlBLElBQU0sV0FBVyxHQUNmLG9CQUFXLENBQUMsTUFBYSxFQUFFLE1BQVcsRUFBRSxDQUF0QjtpQ0FBQSxHQUFHLElBQUksQ0FBUTtpQ0FBQSxHQUFHLEVBQUU7QUFBRztFQUN2QyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztFQUN6QixJQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUM1QixDQUFDOzsyQ0FBQTs7QUFFRCxrQ0FBWSwwQkFBQyxLQUFLLEVBQUU7RUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDNUMsQ0FBQzs7QUFFRCxrQ0FBWSwwQkFBQyxTQUFTLEVBQUU7RUFDdEIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JDLENBQUM7O0FBRUQsdUNBQWlCLGlDQUFHO0VBQ2xCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUMxQixDQUFDOztBQUVELG1CQUFJLFNBQVMsbUJBQUc7RUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDekIsQ0FBQztBQUNELG1CQUFJLFNBQVMsaUJBQUMsR0FBRyxFQUFFO0VBQ2pCLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQ3hCLENBQUM7O0FBRUQsaUNBQVcsMkJBQUc7RUFDWkEsR0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO0VBQzNCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBVyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTtJQUMvQyxPQUFPLElBQUksQ0FBQztFQUNkLENBQUM7RUFDRCxPQUFPO0lBQ0wsWUFBWSxFQUFJLEdBQUcsQ0FBQyxXQUFXO0lBQy9CLGNBQWMsRUFBRSxHQUFHLENBQUMsVUFBVTtFQUNoQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQ0Y7O3FFQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7Ozs7OztBQ3pDekM7Ozs7O0FBS0EsSUFBTSxTQUFTLEdBQ2Isa0JBQVcsQ0FBQyxRQUFZLEVBQUUsR0FBTyxFQUFFLENBQWY7cUNBQUEsR0FBRyxDQUFDLENBQUs7MkJBQUEsR0FBRyxDQUFDO0FBQUc7RUFDbEM7RUFDQTtFQUNBO0VBQ0E7RUFDQSxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQzs7RUFFdEI7RUFDQSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztFQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztFQUNoQixJQUFJLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztFQUM3QixJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztFQUN0QixJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQztFQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztFQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztFQUNoQixJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztFQUNqQixJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO0VBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0VBQ2pCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLGdCQUFrQjtFQUNuQyxJQUFJLENBQUMsNEJBQTRCLEdBQUcsQ0FBQyxDQUFDOztFQUV0QztFQUNBLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0VBQ3hCLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0VBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0VBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0VBQ3hCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0VBQ3hCLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUM7RUFDbEMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7O0VBRTVCLElBQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDLElBQU07RUFDbkMsSUFBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLENBQUc7RUFDbkMsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUMsUUFBVTtFQUNuQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLElBQU07RUFDbkMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsTUFBUTtFQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQyxHQUFLO0VBQ25DLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLFdBQWE7RUFDbkMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLENBQUMsQ0FBQztFQUMzQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDOztFQUU5QixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO0VBQy9CLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0VBQ3ZCLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0VBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0VBQ3RCLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDO0VBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0VBQ3RCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLE1BQVE7O0VBRXBDO0VBQ0EsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQztFQUM5QixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztFQUN2QixJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztFQUN2QixJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQztFQUN0QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7RUFFcEI7RUFDQTtFQUNBO0VBQ0EsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7QUFDOUIsQ0FBQzs7QUFFRCxtQ0FBZSw2QkFBQyxZQUFZLEVBQUUsYUFBYSxFQUFFO0VBQzNDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0VBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0VBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxHQUFHLGFBQWEsQ0FBQztBQUNwRCxDQUFDOztBQUVELGtDQUFjLDRCQUFDLGFBQWEsRUFBRTtFQUM1QixJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztBQUNyQyxDQUFDLENBQ0Y7O0FBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDOzs7Ozs7O0FDOUVoQixVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUExQyxlQUFXLG1CQUFnQzs7Ozs7Ozs7Ozs7QUFXbkQsSUFBTSxjQUFjLEdBQW9CO0VBUXRDLHVCQUFXLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRTtJQUM1QkcsV0FBSyxNQUFDLHNCQUFnQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0dBQ3hCOzs7O3dEQUFBOztFQUVELGlDQUFRLHdCQUFHO0lBQ1QsT0FBTyxFQUFHQSxxQkFBSyxDQUFDLFFBQVEsTUFBQyxLQUFDLGdCQUFXLElBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQ3ZELENBQ0Y7OztFQWhCNEIsV0FnQjVCOztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQzs7Ozs7OztBQzdCakMsVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBbkMsUUFBSSxZQUFnQzs7Ozs7OztBQU81Q0gsR0FBSyxDQUFDLHFCQUFxQixHQUFHO0VBQzVCLElBQUksaUJBQWlCLENBQUM7RUFDdEIsa0JBQWtCLEdBQUcsQ0FBQztFQUN0QixVQUFVLFdBQVcsQ0FBQztFQUN0QixtQkFBbUIsRUFBRSxDQUFDO0VBQ3RCLGlCQUFpQixJQUFJLENBQUM7Q0FDdkIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7Ozs7OztBQ2ZqRCxVQUFHLG1CQUFPLENBQUMsR0FBcUIsQ0FBQztBQUEvQyxnQkFBWSxvQkFBb0M7QUFDekMsWUFBRyxtQkFBTyxDQUFDLEdBQWEsQ0FBQztBQUFoQyxTQUFLLGVBQTRCOztBQUV6QyxNQUFNLENBQUMsT0FBTyxHQUFHO0VBQ2YsMEJBQVk7RUFDWixZQUFLO0NBQ04sQ0FBQzs7Ozs7OztBQ05ZLFVBQUcsbUJBQU8sQ0FBQyxHQUFZLENBQUM7QUFBOUIsUUFBSSxZQUEyQjtBQUNoQixZQUFHLG1CQUFPLENBQUMsRUFBc0IsQ0FBQztBQUFqRCxpQkFBYSx1QkFBcUM7QUFDNUIsWUFBRyxtQkFBTyxDQUFDLEVBQWdDLENBQUM7QUFBbEUsd0JBQW9CLDhCQUErQzs7QUFFM0UsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQzNCLE1BQU0sQ0FBQyxPQUFPLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztBQUM3QyxNQUFNLENBQUMsT0FBTyxDQUFDLG9CQUFvQixHQUFHLG9CQUFvQixDQUFDOzs7Ozs7O0FDTm5DLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQTdDLGtCQUFjLHNCQUFnQzs7Ozs7OztBQU90RCxJQUFNLFNBQVMsR0FRYixrQkFBVyxDQUFDLElBQUksRUFBRTtFQUNoQixJQUFJLENBQUMsSUFBSSxFQUFFO0lBQ1QsTUFBTSxJQUFJLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0VBQy9DLENBQUM7RUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtJQUNkLE1BQU0sSUFBSSxjQUFjLENBQUMsMkJBQTJCLENBQUMsQ0FBQztFQUN4RCxDQUFDO0VBQ0QsSUFBSSxDQUFDLElBQUksR0FBRztJQUNWLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtFQUNqQixDQUFDLENBQUM7QUFDSixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtBQUNELDRCQUFRLHdCQUFHO0VBQ1RFLEdBQUcsQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7RUFDaEQsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtJQUM5QixlQUFlLEdBQUcsSUFBRyxHQUFFLGVBQWlCLENBQUM7RUFDM0MsQ0FBQztFQUNELE9BQU8sSUFBRSxJQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxRQUFHLElBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFHLGVBQWUsTUFBRSxDQUFDLENBQUM7QUFDM0UsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBLEtBQU87Q0FDUDtBQUNELHNDQUFrQixrQ0FBRztFQUNuQixPQUFPLEVBQUUsQ0FBQztBQUNaLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0FBQ0QsMkJBQU8sdUJBQUc7RUFDUixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ3hCLENBQUMsQ0FFRjs7QUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7Ozs7Ozs7QUN6RHZCLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCNUNGLEdBQUssQ0FBQyw4QkFBOEIsR0FBRzs7Ozs7O0VBTXJDLElBQUksSUFBSSxNQUFNOzs7OztFQUtkLE1BQU0sRUFBRSxRQUFRO0NBQ2pCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyw4QkFBOEIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLDhCQUE4QixDQUFDLENBQUM7Ozs7Ozs7QUNuQzNFLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7O0FBUTVDQSxHQUFLLENBQUMsK0JBQStCLEdBQUc7Ozs7OztFQU10QyxXQUFXLEVBQUUsYUFBYTs7Ozs7O0VBTTFCLFFBQVEsS0FBSyxVQUFVO0NBQ3hCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQywrQkFBK0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLCtCQUErQixDQUFDLENBQUM7Ozs7Ozs7QUN2QjdFLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7QUFVNUNBLEdBQUssQ0FBQyxlQUFlLEdBQUc7Ozs7RUFJdEIsYUFBYSxFQUFFLENBQUM7Ozs7RUFJaEIsWUFBWSxHQUFHLENBQUM7Q0FDakIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Ozs7O0FDckJyQixVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUEzRCxnQkFBWTtBQUFFLGtCQUFjLHNCQUFnQztBQUNsRCxZQUFHLG1CQUFPLENBQUMsRUFBYSxDQUFDO0FBQW5DLFlBQVEsa0JBQTRCOzs7Ozs7O0FBTzVDLElBQU0sZUFBZSxHQUluQix3QkFBVyxHQUFHO0VBQ1osSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7QUFDakIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtBQUNELGlDQUFPLHVCQUFHO0VBQ1IsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQyxDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0NBQ0E7QUFDRCxrQ0FBUSxzQkFBQyxHQUFHLEVBQUU7RUFDWixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDeEIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtBQUNELHFDQUFXLHlCQUFDLEdBQUcsRUFBRTtFQUNmLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxDQUFHO0NBQ0g7QUFDRCxrQ0FBUSxzQkFBQyxHQUFHLEVBQUUsV0FBVyxFQUFFLEtBQWlCLEVBQUUsQ0FBZDtpQ0FBQSxHQUFHLFNBQVM7QUFBRztFQUM3QyxJQUFJLFdBQVcsWUFBWSxRQUFRLEVBQUU7SUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUM7SUFDN0IsT0FBTztFQUNULENBQUMsTUFBTSxJQUFJLE9BQU8sS0FBSyxLQUFLLFdBQVcsRUFBRTtJQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3JELE9BQU87RUFDVCxDQUFDO0VBQ0QsTUFBTSxJQUFJLGNBQWMsQ0FBQyxzRUFBc0U7SUFDN0YsWUFBWSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUNGOztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQzs7Ozs7OztBQ3RFakRBLEdBQUssQ0FBQyxXQUFXLEdBQUcsbUJBQU8sQ0FBQyxFQUFhLENBQUMsQ0FBQztBQUNMLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQTNELGdCQUFZO0FBQUUsa0JBQWMsc0JBQWdDOzs7Ozs7OztBQVFwRSxJQUFNLGtCQUFrQixHQUl0QiwyQkFBVyxHQUFHO0VBQ1osSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7RUFDbEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7RUFDdEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDbkIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0FBQ0Qsb0NBQU8sdUJBQUc7RUFDUixPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlDLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0NBQ0E7Q0FDQTtBQUNELG9DQUFPLHVCQUFHO0VBQ1IsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztBQUN6RixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0NBQ0E7QUFDRCxtQ0FBTSxzQkFBRztFQUNQLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7QUFDRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0EsQ0FBRztDQUNIO0FBQ0QscUNBQVEsc0JBQUMsV0FBVyxFQUFFLEtBQWlCLEVBQUUsQ0FBZDtpQ0FBQSxHQUFHLFNBQVM7QUFBRztFQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxTQUFPOztFQUU1QixJQUFJLFdBQVcsWUFBWSxXQUFXLENBQUMsUUFBUSxFQUFFO0lBQy9DLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQy9CLE9BQU87RUFDVCxDQUFDOztFQUVELElBQUksT0FBTyxLQUFLLEtBQUssV0FBVyxFQUFFO0lBQ2hDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ25FLE9BQU87RUFDVCxDQUFDOztFQUVELE1BQU0sSUFBSSxjQUFjLENBQUMsc0VBQXNFO0lBQzdGLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FDRjs7QUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDOzs7Ozs7O0FDN0Z6QyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7Ozs7QUFTNUNBLEdBQUssQ0FBQyxjQUFjLEdBQUc7Ozs7RUFJckIscUJBQXFCLFNBQVMsQ0FBQzs7OztFQUkvQixrQkFBa0IsWUFBWSxDQUFDOzs7O0VBSS9CLGFBQWEsaUJBQWlCLENBQUM7Ozs7RUFJL0IsZUFBZSxlQUFlLENBQUM7Ozs7RUFJL0IsY0FBYyxnQkFBZ0IsQ0FBQzs7Ozs7RUFLL0IsbUJBQW1CLFdBQVcsQ0FBQzs7Ozs7OztFQU8vQixnQkFBZ0IsY0FBYyxDQUFDOzs7O0VBSS9CLGVBQWUsZUFBZSxDQUFDOzs7O0VBSS9CLFFBQVEsc0JBQXNCLENBQUM7Ozs7RUFJL0IsMEJBQTBCLElBQUksQ0FBQzs7OztFQUkvQixrQkFBa0IsWUFBWSxFQUFFOzs7O0VBSWhDLDBCQUEwQixJQUFJLEVBQUU7Ozs7RUFJaEMseUJBQXlCLEtBQUssRUFBRTs7OztFQUloQyxhQUFhLGlCQUFpQixFQUFFOzs7O0VBSWhDLFFBQVEsc0JBQXNCLEVBQUU7Ozs7O0VBS2hDLHVCQUF1QixPQUFPLEVBQUU7Ozs7RUFJaEMsMEJBQTBCLElBQUksRUFBRTs7OztFQUloQyxXQUFXLG1CQUFtQixFQUFFOzs7O0VBSWhDLFdBQVcsbUJBQW1CLEVBQUU7Ozs7RUFJaEMseUJBQXlCLEtBQUssRUFBRTs7OztFQUloQyxvQkFBb0IsVUFBVSxFQUFFOzs7O0VBSWhDLElBQUksMEJBQTBCLEVBQUU7Ozs7RUFJaEMsNEJBQTRCLEVBQUUsRUFBRTs7Ozs7RUFLaEMsbUJBQW1CLFdBQVcsRUFBRTs7OztFQUloQyxvQkFBb0IsVUFBVSxFQUFFOzs7O0VBSWhDLGtCQUFrQixZQUFZLEVBQUU7Q0FDakMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDOzs7Ozs7O0FDMUgzQyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQjVDQSxHQUFLLENBQUMsZ0JBQWdCLEdBQUc7Ozs7Ozs7Ozs7RUFVdkIsU0FBUywwQkFBMEIsQ0FBQzs7Ozs7O0VBTXBDLFVBQVUseUJBQXlCLENBQUM7Ozs7OztFQU1wQyxvQkFBb0IsZUFBZSxDQUFDOzs7Ozs7RUFNcEMsc0JBQXNCLGFBQWEsQ0FBQzs7Ozs7O0VBTXBDLGtCQUFrQixpQkFBaUIsQ0FBQzs7Ozs7O0VBTXBDLGVBQWUsb0JBQW9CLENBQUM7Ozs7OztFQU1wQywwQkFBMEIsU0FBUyxDQUFDOzs7Ozs7RUFNcEMsZUFBZSxvQkFBb0IsQ0FBQzs7Ozs7O0VBTXBDLGVBQWUsb0JBQW9CLENBQUM7Ozs7OztFQU1wQyxrQkFBa0IsaUJBQWlCLEVBQUU7Ozs7OztFQU1yQyxxQkFBcUIsY0FBYyxFQUFFOzs7Ozs7O0VBT3JDLGVBQWUsb0JBQW9CLEVBQUU7Ozs7OztFQU1yQyxZQUFZLHVCQUF1QixFQUFFOzs7Ozs7O0VBT3JDLG1CQUFtQixnQkFBZ0IsRUFBRTs7Ozs7OztFQU9yQyxrQkFBa0IsaUJBQWlCLEVBQUU7Ozs7Ozs7Ozs7OztFQVlyQyw2QkFBNkIsTUFBTSxFQUFFOzs7Ozs7O0VBT3JDLG9CQUFvQixlQUFlLEVBQUU7Ozs7O0VBS3JDLHVCQUF1QixZQUFZLEVBQUU7Ozs7Ozs7RUFPckMsMEJBQTBCLFNBQVMsRUFBRTs7Ozs7Ozs7RUFRckMsT0FBTyw0QkFBNEIsRUFBRTs7Ozs7Ozs7RUFRckMsaUNBQWlDLEVBQUUsRUFBRTtDQUN0QyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzs7Ozs7O0FDOUsvQyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7OztBQVE1Q0EsR0FBSyxDQUFDLGtCQUFrQixHQUFHO0VBQ3pCLFFBQVEsV0FBVyxDQUFDO0VBQ3BCLFdBQVcsUUFBUSxDQUFDO0VBQ3BCLGlCQUFpQixFQUFFLENBQUM7RUFDcEIsUUFBUSxXQUFXLENBQUM7RUFDcEIsZUFBZSxJQUFJLENBQUM7Q0FDckIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7OztBQ2hCM0IsVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBM0QsZ0JBQVk7QUFBRSxrQkFBYyxzQkFBZ0M7QUFDdkMsWUFBRyxtQkFBTyxDQUFDLEVBQTBCLENBQUM7QUFBM0QsdUJBQW1CLDZCQUF5Qzs7Ozs7Ozs7Ozs7O0FBWXBFLElBQU0sYUFBYSxHQVNqQixzQkFBVyxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxXQUFrQixFQUFFLENBQVQ7MkNBQUEsR0FBRyxJQUFJO0FBQUc7RUFDckUsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7RUFDaEIsSUFBSSxDQUFDLElBQUksR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQ3RDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0VBQ3RCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO0VBQ3hCLElBQUksQ0FBQyxNQUFNLEdBQUcsY0FBYyxDQUFDO0VBQzdCLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbkMsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsK0JBQU8sdUJBQUcsRUFBRSxPQUFPLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxFQUFFOztBQUU1QztDQUNDO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsK0JBQU8scUJBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxFQUFFOztBQUVuRSw2QkFBSyxtQkFBQyxRQUFRLEVBQUU7RUFDZCxRQUFRLEVBQUUsQ0FBQztFQUNYLE9BQU8sbUJBQW1CLENBQUMsRUFBRSxDQUFDO0FBQ2hDLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7QUFDRCw0QkFBSSxrQkFBQyxPQUFPLEVBQUUsaUJBQXlCLEVBQUUsQ0FBVjt1REFBQSxHQUFHLEtBQUs7QUFBRyxDQUFDLE9BQU8sbUJBQW1CLENBQUMsRUFBRSxDQUFDLEVBQUU7O0FBRTNFO0NBQ0M7Q0FDQTtBQUNELDRDQUFvQixvQ0FBRztFQUNyQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUM7QUFDdkMsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7QUFDRCxrQ0FBVSwwQkFBRyxFQUFFLE9BQU8sSUFBSSxDQUFDLEVBQUU7O0FBRTdCO0NBQ0M7Q0FDQTtBQUNELHNDQUFjLDhCQUFHLEVBQUUsT0FBTyxJQUFJLENBQUMsRUFBRTs7QUFFakM7Q0FDQztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtBQUNELHNDQUFjLDRCQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEtBQUssQ0FBQyxFQUFFOztBQUU5QztDQUNDO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtBQUNELHNDQUFjLDRCQUFDLFdBQVcsRUFBRTtFQUMxQixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDckI7SUFDQSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLE1BQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ2pFLENBQUM7RUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztFQUNoQyxJQUFJLFdBQVcsRUFBRTtJQUNmLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRSxhQUFXLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ3pELENBQUM7QUFDSCxDQUFDOztBQUVELGdDQUFRLHdCQUFHO0VBQ1QsT0FBTyxHQUFDLElBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEtBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLEdBQUcsRUFBRSxFQUFFLENBQUM7QUFDdEUsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsY0FBTyxNQUFNLG9CQUFDLEdBQUcsRUFBRTtFQUNqQkEsR0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7RUFDMUMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxhQUFhLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUU7SUFDaEYsTUFBTSxJQUFJLGNBQWMsQ0FBQyxpQkFBYyxHQUFFLEdBQUcsZUFBVSxJQUM3QixhQUFhLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUNBQTRCLENBQUM7NkJBQ2xFLFlBQVksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0VBQ2hFLENBQUM7O0VBRURBLEdBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDO0VBQzVGLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FFRjs7Ozs7QUFLRCxhQUFhLENBQUMsWUFBWSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzs7QUFFM0UsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDOzs7Ozs7OztBQ3ZJN0NBLEdBQUssQ0FBQyxJQUFJLEdBQUcsbUJBQU8sQ0FBQyxDQUFNLENBQUMsQ0FBQztBQUNQLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQTNDLGdCQUFZLG9CQUFnQztBQUN2QyxZQUFHLG1CQUFPLENBQUMsQ0FBbUIsQ0FBQztBQUFwQyxPQUFHLGFBQWtDO0FBQ1YsWUFBRyxtQkFBTyxDQUFDLEVBQWlDLENBQUM7QUFBeEUsNkJBQXlCLG1DQUFnRDs7QUFFekUsbUJBQWUsdUJBQVM7Ozs7Ozs7O0FBUWhDLElBQU0scUJBQXFCLEdBV3pCLDhCQUFXLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRTtFQUNsRSxJQUFJLENBQUMsbUJBQW1CLEdBQUcsV0FBVyxDQUFDO0VBQ3ZDLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO0VBQ3hCLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDO0VBQ2xDLElBQUksQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDO0VBQzdCLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO0FBQ3hCLENBQUM7O2dIQUFBOztBQUVEOztBQUVBLHFEQUFxQixxQ0FBRztFQUN0QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztBQUNsQyxDQUFDOztBQUVELG1CQUFJLGtCQUFrQixtQkFBRztFQUN2QixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztBQUNsQyxDQUFDOztBQUVELDBDQUFVLDBCQUFHO0VBQ1gsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ3RCLENBQUM7O0FBRUQsbUJBQUksT0FBTyxtQkFBRztFQUNaLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUN2QixDQUFDOztBQUVELCtDQUFlLCtCQUFHO0VBQ2hCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztBQUMzQixDQUFDOztBQUVELG1CQUFJLFlBQVksbUJBQUc7RUFDakIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0FBQzVCLENBQUM7O0FBRUQsMENBQVUsMEJBQUc7RUFDWCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDM0IsQ0FBQzs7QUFFRCxtQkFBSSxZQUFZLG1CQUFHO0VBQ2pCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztBQUM1QixDQUFDOztBQUVELDRDQUFZLDRCQUFHO0VBQ2IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQ3hCLENBQUM7O0FBRUQsbUJBQUksU0FBUyxtQkFBRztFQUNkLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztBQUNuQixDQUFDOztBQUVELGdDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGVBQUc7RUFDdEIsT0FBTztJQUNMLG9CQUFvQixFQUFFLHlCQUF5QixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUM7SUFDakYsU0FBUyxXQUFhLElBQUksQ0FBQyxPQUFPO0lBQ2xDLGNBQWMsTUFBUSxJQUFJLENBQUMsWUFBWTtJQUN2QyxjQUFjLE1BQVEsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO0lBQzlELEtBQUssZUFBaUIsSUFBSSxDQUFDLEdBQUcsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUs7RUFDdEUsQ0FBQyxDQUFDO0FBQ0osQ0FBQzs7QUFFRCx3Q0FBUSx3QkFBRztFQUNULE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixDQUFDLENBRUY7OytFQUFBOztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMscUJBQXFCLEdBQUcscUJBQXFCLENBQUM7Ozs7Ozs7QUN2RjVELFVBQUcsbUJBQU8sQ0FBQyxDQUFlLENBQUM7QUFGMUIsWUFBUTtBQUNSLFlBQVEsZ0JBQ21CO0FBQ1osWUFBRyxtQkFBTyxDQUFDLENBQWdCLENBQUM7QUFBckMsV0FBTyxpQkFBK0I7Ozs7Ozs7O0FBUTlDLElBQU0sUUFBUSxHQVFaLGlCQUFXLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFO0VBQ3ZELElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztFQUNyQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsVUFBVSxDQUFDO0VBQ3JDLElBQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDO0VBQ2xDLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO0VBQzVCLElBQUksQ0FBQywwQkFBMEI7SUFDN0IsQ0FBRyxJQUFJLENBQUMsa0JBQWtCLHNDQUFpQyxJQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUUsQ0FBQztBQUNyRixDQUFDOztBQUVELCtCQUFZLDRCQUFHO0VBQ2IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQ3pCLENBQUM7O0FBRUQsK0JBQVksMEJBQUMsU0FBUyxFQUFFO0VBQ3RCLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO0FBQzlCLENBQUM7O0FBRUQsdUNBQW9CLG9DQUFHO0VBQ3JCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO0FBQ2pDLENBQUM7O0FBRUQsNEJBQVMseUJBQUc7RUFDVixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDbkIsQ0FBQzs7QUFFRDtBQUNBLGdDQUFhLDZCQUFHO0VBQ2QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDOztBQUVELDBCQUFPLHVCQUFHO0VBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRTtJQUN6QixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtNQUN6QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFDdkUsQ0FBQyxNQUFNO01BQ0wsUUFBUSxDQUFDLEVBQUcsSUFBSSxDQUFDLDBCQUEwQixzQkFBaUIsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztFQUNILENBQUM7QUFDSCxDQUFDOztBQUVELG9DQUFpQiwrQkFBQyxHQUFHLEVBQUU7RUFDckIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7SUFDekMsUUFBUSxDQUFDLG1CQUFpQixHQUFFLEdBQUcsdUJBQW1CLENBQUMsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3RELE9BQU8sSUFBSSxDQUFDO0VBQ2QsQ0FBQztFQUNELFFBQVEsQ0FBQyxtQkFBaUIsR0FBRSxHQUFHLHNCQUFrQixDQUFDLENBQUMsQ0FBQztFQUNwRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7O0FBRUQsMkJBQVEsd0JBQUc7RUFDVCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELENBQUMsQ0FFRjs7QUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7Ozs7Ozs7QUM1RW5DQSxHQUFLLENBQUMsT0FBTyxHQUFHLG1CQUFPLENBQUMsRUFBUSxDQUFDLENBQUM7QUFDQyxVQUFHLG1CQUFPLENBQUMsR0FBK0IsQ0FBQztBQUF0RSw2QkFBeUIsaUNBQThDOztBQUV2RSxrQkFBYywwQkFBYTs7QUFFbkNBLEdBQUssQ0FBQyx3QkFBd0IsR0FBRztFQUMvQixTQUFTLHVCQUFHLEVBQUUsT0FBTyx5QkFBeUIsQ0FBQywrQkFBK0IsRUFBRSxDQUFDLEVBQUU7RUFDbkYsU0FBUyx1QkFBRyxFQUFFLE9BQU8sY0FBYyxDQUFDLHdCQUF3QixFQUFFLENBQUMsRUFBRTtFQUNqRSxTQUFTLHVCQUFHLEVBQUUsT0FBTyxjQUFjLENBQUMsZ0NBQWdDLEVBQUUsQ0FBQyxFQUFFO0NBQzFFLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsR0FBRyx3QkFBd0IsQ0FBQzs7Ozs7OztBQ1huRUEsR0FBSyxDQUFDLElBQUksR0FBRyxtQkFBTyxDQUFDLENBQU0sQ0FBQyxDQUFDO0FBQ0osVUFBRyxtQkFBTyxDQUFDLEVBQW9CLENBQUM7QUFBakQsbUJBQWUsdUJBQW1DO0FBQ2pDLFlBQUcsbUJBQU8sQ0FBQyxFQUFvQixDQUFDO0FBQWpELG1CQUFlLHlCQUFtQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CMUQsSUFBTSxXQUFXLEdBWWYsb0JBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBNEIsRUFBRSxDQUExQjs2QkFBQSxHQUFHLGVBQWUsQ0FBQyxLQUFLO0FBQUc7RUFDL0MsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7SUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3ZCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDekIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzNCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtNQUNwQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztNQUN6QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDekMsQ0FBQyxNQUFNO01BQ0wsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7SUFDNUIsQ0FBQztFQUNILENBQUMsTUFBTTtJQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztJQUVsQjtJQUNBO0lBQ0E7SUFDQUEsR0FBSyxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzdCLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0VBQzVCLENBQUM7QUFDSCxDQUFDOztvRUFBQTs7QUFFRDtDQUNDO0NBQ0E7QUFDRCw2QkFBTyx1QkFBRztFQUNSLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztBQUNwQixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0FBQ0QsbUJBQUksSUFBSSxtQkFBRztFQUNULE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3hCLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0FBQ0QsNkJBQU8sdUJBQUc7RUFDUixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDcEIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtBQUNELG1CQUFJLElBQUksbUJBQUc7RUFDVCxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN4QixDQUFDOztBQUVEO0NBQ0M7Q0FDQTtDQUNBO0NBQ0E7QUFDRCw4QkFBUSx3QkFBRztFQUNULE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUNyQixDQUFDO0FBQ0QsbUJBQUksS0FBSyxtQkFBRztFQUNWLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3pCLENBQUM7O0FBRUQsK0JBQVMseUJBQUc7RUFDVixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDdEIsQ0FBQztBQUNELG1CQUFJLE1BQU0sbUJBQUc7RUFDWCxPQUFPLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUMxQixDQUFDOztBQUVEO0NBQ0M7Q0FDQSxTQUFXO0NBQ1g7Q0FDQTtDQUNBO0NBQ0E7QUFDRCw4QkFBUSx3QkFBRztFQUNULElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtJQUNyQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ25DLE9BQU87RUFDVCxDQUFDOztFQUU0QjtJQUMzQixlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDO0lBRDFELFNBQUs7SUFBRSxnQkFBWSxvQkFDd0M7RUFDbkUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7RUFDekIsSUFBSSxLQUFLLEVBQUU7SUFDVCxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUNwQixNQUFNLEtBQUssQ0FBQztFQUNkLENBQUM7RUFDRCxJQUFJLENBQUMsYUFBYSxHQUFHLFlBQVksQ0FBQztBQUNwQyxDQUFDOztBQUVEO0NBQ0Msd0NBQTBDO0NBQzFDLDRGQUE4RjtDQUM5RjtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0Qsa0NBQVksNEJBQUc7RUFDYixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7RUFDaEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0FBQzVCLENBQUM7O0FBRUQ7Q0FDQztDQUNBO0FBQ0QsOEJBQVEsd0JBQUc7RUFDVCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUIsQ0FBQzs7QUFFRDtDQUNDO0NBQ0E7Q0FDQTtDQUNBO0FBQ0QsNEJBQU0sb0JBQUMsS0FBSyxFQUFFO0VBQ1osSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLFdBQVcsQ0FBQyxFQUFFO0lBQ25DLE9BQU8sS0FBSyxDQUFDO0VBQ2YsQ0FBQztFQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxFQUFFLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDcEUsQ0FBQyxDQUNGOztxRUFBQTs7QUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7Ozs7Ozs7QUNwSzNCLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUI1Q0EsR0FBSyxDQUFDLFlBQVksR0FBRzs7Ozs7OztFQU9uQixhQUFhLGtDQUFrQyxVQUFVOzs7O0VBSXpELFFBQVEsdUNBQXVDLENBQUM7Ozs7Ozs7O0VBUWhELHFCQUFxQiwwQkFBMEIsQ0FBQzs7Ozs7O0VBTWhELHlCQUF5QixzQkFBc0IsQ0FBQzs7Ozs7RUFLaEQsaUJBQWlCLDhCQUE4QixDQUFDOzs7O0VBSWhELE9BQU8sd0NBQXdDLENBQUM7Ozs7Ozs7Ozs7O0VBV2hELHVCQUF1Qix3QkFBd0IsQ0FBQzs7Ozs7Ozs7RUFRaEQsdUJBQXVCLHdCQUF3QixDQUFDOzs7Ozs7Ozs7OztFQVdoRCwyQkFBMkIsb0JBQW9CLENBQUM7Ozs7Ozs7O0VBUWhELDJCQUEyQixvQkFBb0IsQ0FBQzs7Ozs7Ozs7Ozs7RUFXaEQsMEJBQTBCLHFCQUFxQixDQUFDOzs7Ozs7O0VBT2hELG1CQUFtQiw0QkFBNEIsRUFBRTs7Ozs7Ozs7RUFRakQseUJBQXlCLHNCQUFzQixFQUFFOzs7Ozs7Ozs7RUFTakQsZ0JBQWdCLCtCQUErQixFQUFFOzs7Ozs7Ozs7RUFTakQsYUFBYSxrQ0FBa0MsRUFBRTs7Ozs7Ozs7Ozs7O0VBWWpELHVCQUF1Qix3QkFBd0IsRUFBRTs7Ozs7Ozs7Ozs7O0VBWWpELGlCQUFpQiw4QkFBOEIsRUFBRTs7Ozs7Ozs7O0VBU2pELHVCQUF1Qix3QkFBd0IsRUFBRTs7Ozs7Ozs7O0VBU2pELGtCQUFrQiw2QkFBNkIsRUFBRTs7Ozs7OztFQU9qRCxzQkFBc0IseUJBQXlCLEVBQUU7Ozs7O0VBS2pELGtCQUFrQiw2QkFBNkIsRUFBRTs7OztFQUlqRCxzQkFBc0IseUJBQXlCLEVBQUU7Ozs7Ozs7RUFPakQsY0FBYyxpQ0FBaUMsRUFBRTs7Ozs7OztFQU9qRCxrQkFBa0IsNkJBQTZCLEVBQUU7Ozs7Ozs7O0VBUWpELGdCQUFnQiwrQkFBK0IsRUFBRTs7Ozs7RUFLakQsY0FBYyxpQ0FBaUMsRUFBRTs7Ozs7RUFLakQsbUJBQW1CLDRCQUE0QixFQUFFOzs7Ozs7O0VBT2pELGtCQUFrQiw2QkFBNkIsRUFBRTs7Ozs7Ozs7Ozs7OztFQWFqRCxhQUFhLGtDQUFrQyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQmpELG9CQUFvQiwyQkFBMkIsRUFBRTs7Ozs7Ozs7O0VBU2pELGlCQUFpQiw4QkFBOEIsRUFBRTs7Ozs7OztFQU9qRCxlQUFlLGdDQUFnQyxFQUFFOzs7Ozs7Ozs7Ozs7RUFZakQsNEJBQTRCLG1CQUFtQixFQUFFOzs7Ozs7Ozs7RUFTakQsc0JBQXNCLHlCQUF5QixFQUFFOzs7Ozs7OztFQVFqRCxvQkFBb0IsMkJBQTJCLEVBQUU7Ozs7O0VBS2pELHdCQUF3Qix1QkFBdUIsRUFBRTs7Ozs7Ozs7RUFRakQscUJBQXFCLDBCQUEwQixFQUFFOzs7Ozs7OztFQVFqRCxnQ0FBZ0MsZUFBZSxFQUFFOzs7OztFQUtqRCxzQkFBc0IseUJBQXlCLEVBQUU7Ozs7Ozs7Ozs7Ozs7RUFhakQsZ0JBQWdCLCtCQUErQixFQUFFOzs7Ozs7O0VBT2pELGlCQUFpQiw4QkFBOEIsRUFBRTs7OztFQUlqRCxnQkFBZ0IsK0JBQStCLEVBQUU7Ozs7RUFJakQsaUJBQWlCLDhCQUE4QixFQUFFOzs7Ozs7OztFQVFqRCxrQkFBa0IsNkJBQTZCLEVBQUU7Ozs7Ozs7O0VBUWpELDRCQUE0QixtQkFBbUIsRUFBRTs7Ozs7RUFLakQsMEJBQTBCLHFCQUFxQixFQUFFOzs7OztFQUtqRCx1QkFBdUIsd0JBQXdCLEVBQUU7Ozs7Ozs7O0VBUWpELHNCQUFzQix5QkFBeUIsRUFBRTs7Ozs7Ozs7Ozs7RUFXakQsZ0NBQWdDLGVBQWUsRUFBRTs7Ozs7Ozs7RUFRakQsNkNBQTZDLEVBQUUsRUFBRTs7Ozs7Ozs7OztFQVVqRCxjQUFjLGlDQUFpQyxHQUFHOzs7Ozs7Ozs7Ozs7OztFQWNsRCxpQkFBaUIsOEJBQThCLEdBQUc7Ozs7Ozs7RUFPbEQsYUFBYSxrQ0FBa0MsR0FBRzs7Ozs7Ozs7RUFRbEQscUNBQXFDLFVBQVUsR0FBRzs7Ozs7Ozs7RUFRbEQsa0JBQWtCLDZCQUE2QixHQUFHOzs7Ozs7OztFQVFsRCwyQkFBMkIsb0JBQW9CLEdBQUc7Ozs7Ozs7O0VBUWxELHFCQUFxQiwwQkFBMEIsR0FBRzs7Ozs7Ozs7RUFRbEQsa0JBQWtCLDZCQUE2QixHQUFHOzs7OztFQUtsRCxpQkFBaUIsOEJBQThCLEdBQUc7Ozs7Ozs7RUFPbEQsZUFBZSxnQ0FBZ0MsR0FBRzs7Ozs7Ozs7RUFRbEQsZ0JBQWdCLCtCQUErQixHQUFHOzs7Ozs7O0VBT2xELGNBQWMsaUNBQWlDLEdBQUc7Ozs7Ozs7OztFQVNsRCx1QkFBdUIsd0JBQXdCLEdBQUc7Ozs7Ozs7O0VBUWxELDJDQUEyQyxJQUFJLEdBQUc7Ozs7Ozs7Ozs7RUFVbEQsdUJBQXVCLHdCQUF3QixHQUFHOzs7Ozs7Ozs7OztFQVdsRCxzQkFBc0IseUJBQXlCLEdBQUc7Ozs7Ozs7O0VBUWxELGdCQUFnQiwrQkFBK0IsR0FBRzs7Ozs7Ozs7RUFRbEQsMEJBQTBCLHFCQUFxQixHQUFHOzs7Ozs7OztFQVFsRCwwQkFBMEIscUJBQXFCLEdBQUc7Ozs7Ozs7O0VBUWxELHFCQUFxQiwwQkFBMEIsR0FBRzs7Ozs7RUFLbEQsOEJBQThCLGlCQUFpQixHQUFHOzs7O0VBSWxELDRCQUE0QixtQkFBbUIsR0FBRzs7Ozs7Ozs7O0VBU2xELDJCQUEyQixZQUFZLEdBQUc7Ozs7Ozs7O0VBUTFDLHVCQUF1QixnQkFBZ0IsR0FBRzs7Ozs7OztFQU8xQyxnQkFBZ0IsdUJBQXVCLEdBQUc7Ozs7Ozs7O0VBUTFDLHFDQUFxQyxFQUFFLEdBQUc7Ozs7O0VBSzFDLGNBQWMseUJBQXlCLEdBQUc7Ozs7Ozs7O0VBUTFDLGVBQWUsd0JBQXdCLEdBQUc7Ozs7Ozs7RUFPMUMsWUFBWSwyQkFBMkIsR0FBRzs7Ozs7Ozs7RUFRMUMsMkJBQTJCLFlBQVksR0FBRzs7Ozs7OztFQU8xQyxrQkFBa0IscUJBQXFCLEdBQUc7Ozs7O0VBSzFDLHlCQUF5QixjQUFjLEdBQUc7Ozs7RUFJMUMsa0NBQWtDLEtBQUssR0FBRzs7OztFQUkxQyxnQkFBZ0IsdUJBQXVCLEdBQUc7Q0FDM0MsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7Ozs7O0FDanFCckQ7Ozs7Ozs7OztBQVNBLElBQU0sV0FBVyxHQUFjO0VBQzdCLG9CQUFXLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUU7SUFDdENHLEtBQUssTUFBQyxhQUFPLElBQUksRUFBRSxDQUFDLENBQUM7Ozs7OztJQU1yQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7Ozs7O0lBTXZCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDOzs7O0lBSWpCLElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO01BQzNCLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7S0FDNUMsTUFBTTtNQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUM7S0FDaEM7R0FDRjs7OztrREFFRjs7O0VBekJ5QixLQXlCekI7O0FBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDOzs7Ozs7O0FDcEN6Qzs7O0FBR2MsVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBbkMsUUFBSSxZQUFnQzs7Ozs7OztBQU81Q0gsR0FBSyxDQUFDLHFCQUFxQixHQUFHO0VBQzVCLFVBQVUsa0JBQWtCLFlBQVk7RUFDeEMsZ0JBQWdCLFlBQVksa0JBQWtCO0VBQzlDLFlBQVksZ0JBQWdCLGNBQWM7RUFDMUMsa0JBQWtCLFVBQVUsb0JBQW9CO0VBQ2hELFdBQVcsaUJBQWlCLGFBQWE7RUFDekMsT0FBTyxxQkFBcUIsU0FBUztFQUNyQyxlQUFlLGFBQWEsaUJBQWlCO0VBQzdDLFVBQVUsa0JBQWtCLFlBQVk7RUFDeEMsU0FBUyxtQkFBbUIsV0FBVztFQUN2QyxZQUFZLGdCQUFnQixjQUFjO0VBQzFDLEdBQUcseUJBQXlCLEtBQUs7RUFDakMsV0FBVyxpQkFBaUIsYUFBYTtFQUN6QyxZQUFZLGdCQUFnQixjQUFjO0VBQzFDLGNBQWMsY0FBYyxnQkFBZ0I7RUFDNUMsUUFBUSxvQkFBb0IsVUFBVTtFQUN0QyxlQUFlLGFBQWEsaUJBQWlCO0VBQzdDLE9BQU8scUJBQXFCLFNBQVM7RUFDckMsMEJBQTBCLEVBQUUsNEJBQTRCO0NBQ3pELENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7Ozs7Ozs7QUMvQnZFOzs7QUFHa0IsVUFBRyxtQkFBTyxDQUFDLEVBQWUsQ0FBQztBQUFyQyxZQUFRLGdCQUE4Qjs7Ozs7Ozs7Ozs7QUFXOUMsSUFBTSxnQkFBZ0IsR0FBaUI7RUFDckMseUJBQVcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFO0lBQ3pCRyxRQUFLLE1BQUMsVUFBSSxDQUFDLENBQUM7SUFDWixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztHQUN4Qjs7Ozs0REFDRjs7O0VBTDhCLFFBSzlCOztBQUVELE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7Ozs7Ozs7QUNyQnJDLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7O0FBUTVDSCxHQUFLLENBQUMseUJBQXlCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztFQUN6QyxvQkFBb0IsT0FBTywrQ0FBK0M7RUFDMUUsb0JBQW9CLE9BQU8sOENBQThDO0VBQ3pFLFFBQVEsbUJBQW1CLG1DQUFtQztFQUM5RCxRQUFRLG1CQUFtQixvQ0FBb0M7RUFDL0QsSUFBSSx1QkFBdUIsZ0NBQWdDO0VBQzNELGlCQUFpQixVQUFVLDJDQUEyQztFQUN0RSx5QkFBeUIsRUFBRSxtREFBbUQ7RUFDOUUsZ0JBQWdCLFdBQVcsMkNBQTJDO0VBQ3RFLHVCQUF1QixJQUFJLGlEQUFpRDtFQUM1RSxFQUFFLHlCQUF5Qiw4QkFBOEI7RUFDekQsY0FBYyxhQUFhLHlDQUF5QztDQUNyRSxDQUFDLENBQUM7O0FBRUgsTUFBTSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsR0FBRyx5QkFBeUIsQ0FBQzs7Ozs7OztBQ3RCdkQsVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBbkMsUUFBSSxZQUFnQzs7Ozs7OztBQU81Q0EsR0FBSyxDQUFDLHNCQUFzQixHQUFHO0VBQzdCLFVBQVUsUUFBUSxvQkFBb0I7RUFDdEMsZ0JBQWdCLEVBQUUsd0JBQXdCO0VBQzFDLFlBQVksTUFBTSxzQkFBc0I7RUFDeEMsV0FBVyxPQUFPLHdCQUF3QjtFQUMxQyxPQUFPLFdBQVcsb0JBQW9CO0VBQ3RDLFVBQVUsUUFBUSx1QkFBdUI7RUFDekMsWUFBWSxNQUFNLHlCQUF5QjtFQUMzQyxjQUFjLElBQUksd0JBQXdCO0VBQzFDLEdBQUcsZUFBZSxjQUFjO0VBQ2hDLFdBQVcsT0FBTyxxQkFBcUI7RUFDdkMsWUFBWSxNQUFNLHNCQUFzQjtFQUN4QyxjQUFjLElBQUksd0JBQXdCO0VBQzFDLFFBQVEsVUFBVSxrQkFBa0I7RUFDcEMsZUFBZSxHQUFHLHlCQUF5QjtFQUMzQyxlQUFlLEdBQUcseUJBQXlCO0VBQzNDLE9BQU8sV0FBVyxrQkFBa0I7Q0FDckMsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7Ozs7OztBQzFCdkQsVUFBRyxtQkFBTyxDQUFDLEVBQWUsQ0FBQztBQUFyQyxZQUFRLGdCQUE4Qjs7Ozs7Ozs7OztBQVU5QyxJQUFNLGlCQUFpQixHQUFpQjtFQU90QywwQkFBVyxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFO0lBQ3JDRyxRQUFLLE1BQUMsVUFBSSxDQUFDLENBQUM7SUFDWixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM3QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztHQUNqQzs7Ozs4REFBQTtFQUNELHdDQUFZLDRCQUFHO0lBQ2IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0dBQ3hCLENBQ0Y7OztFQWYrQixRQWUvQjs7QUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDOzs7Ozs7O0FDM0J2QyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQjVDSCxHQUFLLENBQUMsa0JBQWtCLEdBQUc7Ozs7O0VBS3pCLElBQUksS0FBSyxDQUFDOzs7OztFQUtWLE1BQU0sR0FBRyxDQUFDOzs7OztFQUtWLE9BQU8sRUFBRSxDQUFDOztDQUVYLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7Ozs7Ozs7QUNyQ25ELFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7OztBQVM1Q0EsR0FBSyxDQUFDLHVCQUF1QixHQUFHOzs7Ozs7Ozs7Ozs7O0VBYTlCLE1BQU0sVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JqQixVQUFVLE1BQU0sQ0FBQzs7Ozs7O0VBTWpCLGNBQWMsRUFBRSxDQUFDO0NBQ2xCLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUM7Ozs7Ozs7QUMvQzNFQSxHQUFLLENBQUMsUUFBUSxHQUFHLG1CQUFPLENBQUMsRUFBaUIsQ0FBQyxDQUFDO0FBQzVDQSxHQUFLLENBQUMsOEJBQThCLEdBQUcsbUJBQU8sQ0FBQyxHQUFrQyxDQUFDLENBQUM7QUFPbEYsVUFBRyxtQkFBTyxDQUFDLEVBQWUsQ0FBQztBQUwxQixnQkFBWTtBQUNaLG1CQUFlO0FBQ2Ysc0JBQWtCO0FBQ2xCLDRCQUF3QjtBQUN4Qix3QkFBb0IsNEJBQ087QUFDZCxZQUFHLG1CQUFPLENBQUMsQ0FBb0IsQ0FBQztBQUF2QyxTQUFLLGVBQW1DO0FBQ1YsWUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBM0QsZ0JBQVk7QUFBRSxrQkFBYyx3QkFBZ0M7QUFDM0MsWUFBRyxtQkFBTyxDQUFDLEVBQXNCLENBQUM7QUFBbkQsbUJBQWUseUJBQXFDO0FBQ3pCLFlBQUcsbUJBQU8sQ0FBQyxDQUFnQixDQUFDO0FBQXZELGdCQUFZO0FBQUUsZUFBVyxxQkFBK0I7O0FBRWhFQSxHQUFLLENBQUMsZ0JBQWdCLEdBQUc7RUFDdkIsSUFBSSxhQUFhLEdBQUc7SUFDbEJBLEdBQUssQ0FBQyxTQUFTLEdBQUcsOEJBQThCLENBQUMsMkJBQTJCLENBQUM7SUFDN0UsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxXQUFDLEVBQUksa0JBQVMsQ0FBQyxDQUFDLENBQUMsSUFBQyxDQUFDO0dBQ3REO0NBQ0YsQ0FBQzs7QUFFRkEsR0FBSyxDQUFDLGVBQWUsR0FBRztFQUN0QixrQkFBa0IsOEJBQUMsT0FBTyxFQUFFO0lBQzFCLE9BQU8sbUJBQWlCLElBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztHQUNyRTs7RUFFRCxRQUFRLG9CQUFDLFFBQVEsRUFBRTtJQUNqQkUsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDakIsSUFBSTtNQUNGLEtBQUssR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7TUFDNUIsT0FBTyxLQUFLLENBQUM7S0FDZCxDQUFDLE9BQU8sQ0FBQyxFQUFFO01BQ1YsSUFBSSxDQUFDLFlBQVksd0JBQXdCLEVBQUU7UUFDekMsSUFBSSxDQUFDLENBQUMsVUFBVSxFQUFFLEtBQUssb0JBQW9CLENBQUMsNkJBQTZCLEVBQUU7VUFDekUsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7U0FDbkQ7T0FDRixNQUFNLElBQUksQ0FBQyxZQUFZLGNBQWMsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLFlBQVksQ0FBQyxzQkFBc0IsRUFBRTtRQUMzRixPQUFPLGdCQUFnQixDQUFDO09BQ3pCO01BQ0QsTUFBTSxDQUFDLENBQUM7S0FDVDtHQUNGOztFQUVELFFBQVEsb0JBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDOztBQUFBO0lBQ3hCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxZQUFZLGVBQWUsQ0FBQyxFQUFFO01BQ2pFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDREYsR0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7SUFDakJBLEdBQUssQ0FBQyxTQUFTLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hEQSxHQUFLLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBRyxFQUFLO01BQ3BCQSxHQUFLLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDM0NBLEdBQUssQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO01BQ3JDQSxHQUFLLENBQUMsS0FBSyxHQUFHQyxNQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO01BQzNDQyxHQUFHLENBQUMsUUFBUSxDQUFDO01BQ2IsUUFBUSxJQUFJO1FBQ1YsS0FBSyxZQUFZLENBQUMsR0FBRztVQUNuQixRQUFRLEdBQUcsSUFBRyxJQUFFRCxNQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUUsQ0FBQztVQUNuRCxNQUFNO1FBQ1IsS0FBSyxZQUFZLENBQUMsTUFBTTtVQUN0QixRQUFRLEdBQUcsSUFBRyxJQUFFQSxNQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUUsQ0FBQztVQUN0RCxNQUFNO1FBQ1IsS0FBSyxZQUFZLENBQUMsU0FBUztVQUN6QixRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztVQUMzRCxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUNyRCxRQUFRLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztXQUN2RDtVQUNELE1BQU07UUFDUjtVQUNFLFFBQVEsR0FBRyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO09BQ3pEO01BQ0QsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFHLFNBQVMsVUFBTSxHQUFFLEdBQUcsUUFBSSxJQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQUksR0FBRSxRQUFRLENBQUUsQ0FBQyxDQUFDO0tBQ3BGLENBQUMsQ0FBQztJQUNILE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUN6Qjs7RUFFRCxXQUFXLHVCQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsQ0FBQzs7QUFBQTtJQUM5QixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsWUFBWSxrQkFBa0IsQ0FBQyxFQUFFO01BQzFFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDbkJELEdBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2pCQSxHQUFLLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN4RCxPQUFPLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtNQUMxQkEsR0FBSyxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7TUFDMUNBLEdBQUssQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO01BQ3JDQSxHQUFLLENBQUMsS0FBSyxHQUFHQyxNQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDOztNQUUzQ0MsR0FBRyxDQUFDLFFBQVEsWUFBQztNQUNiLFFBQVEsSUFBSTtRQUNWLEtBQUssWUFBWSxDQUFDLEdBQUc7VUFDbkIsUUFBUSxHQUFHLElBQUcsSUFBRUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFFLENBQUM7VUFDbkQsTUFBTTtRQUNSLEtBQUssWUFBWSxDQUFDLE1BQU07VUFDdEIsUUFBUSxHQUFHLElBQUcsSUFBRUEsTUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFFLENBQUM7VUFDdEQsTUFBTTtRQUNSLEtBQUssWUFBWSxDQUFDLFNBQVM7VUFDekIsUUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7VUFDM0QsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDckQsUUFBUSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7V0FDdkQ7VUFDRCxNQUFNO1FBQ1IsS0FBSyxZQUFZLENBQUMsV0FBVztVQUMzQixRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1VBQzVCLE1BQU07UUFDUjtVQUNFLFFBQVEsR0FBRyxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDO09BQ3pEO01BQ0QsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFHLFNBQVMsTUFBRSxJQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQUksR0FBRSxRQUFRLENBQUUsQ0FBQyxDQUFDO0tBQ3ZFO0lBQ0QsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUN6Qjs7RUFFRCxVQUFVLHNCQUFDLFNBQVMsRUFBRTtJQUNwQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxZQUFZLGtCQUFrQixDQUFDLENBQUMsRUFBRTtNQUM1RSxPQUFPLENBQUMsQ0FBQztLQUNWO0lBQ0QsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CQyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNkLE9BQU8sU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFO01BQzFCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztNQUNwQixLQUFLLEVBQUUsQ0FBQztLQUNUO0lBQ0QsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQ25CLE9BQU8sS0FBSyxDQUFDO0dBQ2Q7O0VBRUQsVUFBVSxzQkFBQyxTQUFTLEVBQUU7SUFDcEIsT0FBTyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztHQUN2Qzs7RUFFRCxJQUFJLGdCQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRTtJQUMxQ0YsR0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0lBQzlCRSxHQUFHLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUN4QkEsR0FBRyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDMUJBLEdBQUcsQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO0lBQ3ZCLElBQUksU0FBUyxLQUFLLFNBQVMsSUFBSSxTQUFTLEtBQUssSUFBSSxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtNQUNsRixZQUFZLEdBQUcsU0FBUyxDQUFDO0tBQzFCO0lBQ0QsSUFBSSxVQUFVLEtBQUssU0FBUyxJQUFJLFVBQVUsS0FBSyxJQUFJLElBQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFO01BQ3JGLGFBQWEsR0FBRyxVQUFVLENBQUM7S0FDNUI7O0lBRUQsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxVQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUs7TUFDaEIsVUFBRyxRQUFRLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQztNQUE5RCxPQUFHO01BQUUsYUFBUztNQUFFLFNBQUs7TUFBRSxlQUFXLFVBQTZCO01BQ3RFLElBQUksQ0FBQyxTQUFTLEVBQUU7UUFDZCxPQUFPO09BQ1I7TUFDRCxJQUFJLGFBQWEsRUFBRTtRQUNqQixFQUFFLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO09BQ3pCOztNQUVELElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7O1FBR3hDLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDaEIsTUFBTTtRQUNMLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFHLEdBQUcsTUFBRSxDQUFDLEVBQUUsYUFBYSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztPQUNsQjs7TUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQ2xFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDaEIsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtVQUNuQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO1FBQ0QsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2QixJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLElBQUksS0FBSyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRTtVQUMxRixFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO09BQ0Y7TUFDRCxhQUFhLEdBQUcsSUFBSSxDQUFDO0tBQ3RCLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO0dBQ3RCO0NBQ0YsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7Ozs7Ozs7QUNsTG5DLFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUI1Q0YsR0FBSyxDQUFDLGtCQUFrQixHQUFHOzs7Ozs7OztFQVF6QixJQUFJLEVBQUUsQ0FBQzs7Ozs7OztFQU9QLElBQUksRUFBRSxDQUFDOzs7Ozs7OztFQVFQLElBQUksRUFBRSxDQUFDO0NBQ1IsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQzs7Ozs7OztBQ2pEbkQsVUFBRyxtQkFBTyxDQUFDLENBQWlCLENBQUM7QUFBbkMsUUFBSSxZQUFnQzs7Ozs7Ozs7OztBQVU1Q0EsR0FBSyxDQUFDLGVBQWUsR0FBRzs7Ozs7O0VBTXRCLFNBQVMsS0FBSyxXQUFXOzs7Ozs7RUFNekIsWUFBWSxFQUFFLGNBQWM7Q0FDN0IsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDOzs7Ozs7O0FDekI3QyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7Ozs7O0FBVTVDQSxHQUFLLENBQUMsb0JBQW9CLEdBQUc7Ozs7O0VBSzNCLGdCQUFnQixHQUFHLGtCQUFrQjs7Ozs7RUFLckMsaUJBQWlCLEVBQUUsbUJBQW1CO0NBQ3ZDLENBQUM7O0FBRUYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLG9CQUFvQixDQUFDLENBQUM7Ozs7Ozs7QUN2QnZELFVBQUcsbUJBQU8sQ0FBQyxDQUFpQixDQUFDO0FBQW5DLFFBQUksWUFBZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCNUNBLEdBQUssQ0FBQyxnQkFBZ0IsR0FBRzs7OztFQUl2QixJQUFJLFVBQVUsTUFBTTs7Ozs7RUFLcEIsU0FBUyxLQUFLLFdBQVc7Ozs7O0VBS3pCLE9BQU8sT0FBTyxTQUFTOzs7Ozs7RUFNdkIsWUFBWSxFQUFFLGNBQWM7Ozs7OztFQU01QixNQUFNLFFBQVEsUUFBUTtDQUN2QixDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzs7Ozs7O0FDbEQvQyxVQUFHLG1CQUFPLENBQUMsQ0FBaUIsQ0FBQztBQUFuQyxRQUFJLFlBQWdDOzs7Ozs7Ozs7O0FBVTVDQSxHQUFLLENBQUMsU0FBUyxHQUFHOzs7OztFQUtoQixLQUFLLFdBQVcsT0FBTzs7Ozs7RUFLdkIsY0FBYyxFQUFFLGdCQUFnQjtDQUNqQyxDQUFDOztBQUVGLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7Ozs7Ozs7QUN2Qi9DQSxHQUFLLENBQUMsY0FBYyxHQUFHLG1CQUFPLENBQUMsQ0FBdUIsQ0FBQyxDQUFDO0FBQ3ZDLFVBQUcsbUJBQU8sQ0FBQyxDQUFtQixDQUFDO0FBQXhDLFdBQU8sZUFBa0M7QUFDM0IsWUFBRyxtQkFBTyxDQUFDLEdBQWlCLENBQUM7QUFBM0MsZ0JBQVksc0JBQWdDO0FBQzdCLFlBQUcsbUJBQU8sQ0FBQyxHQUFrQixDQUFDO0FBQTdDLGlCQUFhLHVCQUFpQztBQUNuQyxZQUFHLG1CQUFPLENBQUMsR0FBYyxDQUFDO0FBQXJDLGFBQVMsbUJBQTZCO0FBQ3hCLFlBQUcsbUJBQU8sQ0FBQyxHQUFpQixDQUFDO0FBQTNDLGdCQUFZLHNCQUFnQztBQUNoQyxZQUFHLG1CQUFPLENBQUMsRUFBYyxDQUFDO0FBQXRDLGNBQVUsb0JBQTZCO0FBQ3pCLFlBQUcsbUJBQU8sQ0FBQyxFQUFtQixDQUFDO0FBQTdDLGdCQUFZLHNCQUFrQztBQUNqQyxZQUFHLG1CQUFPLENBQUMsRUFBMEIsQ0FBQztBQUFuRCxlQUFXLHFCQUF5QztBQUMxQyxZQUFHLG1CQUFPLENBQUMsRUFBYyxDQUFDO0FBQXBDLFlBQVEsa0JBQTZCO0FBQ3ZCLFlBQUcsbUJBQU8sQ0FBQyxFQUFvQixDQUFDO0FBQTlDLGdCQUFZLHNCQUFtQztBQUNsQyxhQUFHLG1CQUFPLENBQUMsQ0FBZ0IsQ0FBQztBQUF6QyxlQUFXLHNCQUErQjs7QUFFMUMsZ0JBQVksNkJBQWtCO0FBQzlCLGNBQVUsNEJBQW1CO0FBQzdCLGFBQVMsdUJBQWU7QUFDeEIsZ0JBQVksNkJBQWtCOztBQUU5QixpQkFBYSw2QkFBaUI7O0FBRXRDQSxHQUFLLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDOzs7QUFHL0IsU0FBUyxTQUFTLENBQUMsSUFBSSxFQUFFO0VBQ3ZCLE9BQU8sUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Q0FDM0M7OztBQUdELFNBQVMsd0JBQXdCLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRTtFQUMvQyxJQUFJLENBQUMsQ0FBQyxRQUFRLFlBQVksUUFBUSxDQUFDLEVBQUU7SUFDbkMsT0FBTyxLQUFLLENBQUM7R0FDZDs7RUFFREEsR0FBSyxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7RUFDbENFLEdBQUcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0VBQ3BCQSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztFQUNaLFFBQVEsUUFBUSxDQUFDLE9BQU8sRUFBRTtJQUN4QixLQUFLLFlBQVksQ0FBQyxJQUFJO01BQ3BCLEdBQUcsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO01BQzNCLFFBQVEsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDNUMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLEtBQUs7TUFDckIsR0FBRyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUM7TUFDbkMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDcEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLElBQUk7TUFDcEIsR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7TUFDM0IsUUFBUSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDcEMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLE1BQU07TUFDdEIsR0FBRyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUM7TUFDbkMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDckMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLEtBQUs7TUFDckIsR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7TUFDM0IsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDckMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLE1BQU07TUFDdEIsR0FBRyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUM7TUFDbkMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDckMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLEtBQUs7TUFDckIsR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7TUFDM0IsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDckMsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLE1BQU07TUFDdEIsR0FBRyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUM7TUFDbkMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDL0UsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLEtBQUs7TUFDckIsR0FBRyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7TUFDM0IsSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFO1FBQ2QsUUFBUSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDaEYsTUFBTTtRQUNMLFFBQVEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO29CQUN6QixNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztvQkFDekIsVUFBVSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO09BQ3pDO01BQ0QsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLEtBQUs7TUFDckIsR0FBRyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7TUFDeEIsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ25ELE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxNQUFNO01BQ3RCLEdBQUcsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDO01BQzFCLFFBQVEsR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7TUFDM0MsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFNBQVM7TUFDekIsR0FBRyxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUM7TUFDN0IsUUFBUSxHQUFHLEtBQUssQ0FBQztNQUNqQixNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsU0FBUztNQUN6QixHQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQztNQUN6QixRQUFRLEdBQUcsVUFBVSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztNQUM3QyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsVUFBVTtNQUMxQixHQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQztNQUN6QixRQUFRLEdBQUcsVUFBVSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztNQUM3QyxNQUFNO0lBQ1IsS0FBSyxZQUFZLENBQUMsR0FBRztNQUNuQixHQUFHLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQztNQUN2QixRQUFRLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQzVCLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxNQUFNO01BQ3RCLEdBQUcsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDO01BQzFCLFFBQVEsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDL0IsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFdBQVc7TUFDM0IsR0FBRyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUM7TUFDL0IsSUFBSSxLQUFLLFlBQVksY0FBYyxDQUFDLFdBQVcsRUFBRTtRQUMvQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7WUFDdEQsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO09BQ3RCO01BQ0QsTUFBTTtJQUNSLEtBQUssWUFBWSxDQUFDLFFBQVE7TUFDeEIsR0FBRyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7TUFDeEIsUUFBUSxHQUFHLEVBQUUsQ0FBQztNQUNkLE1BQU07SUFDUixLQUFLLFlBQVksQ0FBQyxPQUFPO01BQ3ZCLFFBQVEsR0FBRyxJQUFJLENBQUM7TUFDaEIsTUFBTTtJQUNSLFFBQVE7R0FDVDtFQUNELElBQUksUUFBUSxLQUFLLElBQUksRUFBRTtJQUNyQkYsR0FBSyxDQUFDLEdBQUcsR0FBRyxZQUFZLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuQixPQUFPLElBQUksQ0FBQztHQUNiOztFQUVELE9BQU8sS0FBSyxDQUFDO0NBQ2Q7O0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUU7RUFDckNBLEdBQUssQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0VBQ2Ysd0JBQXdCLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0VBQ3hDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUNyQjs7QUFFREEsR0FBSyxDQUFDLG1CQUFtQixHQUFHO0VBQzFCLHdDQUFtQjtFQUNuQixrREFBd0I7Q0FDekIsQ0FBQzs7QUFFRixNQUFNLENBQUMsT0FBTyxDQUFDLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDOzs7Ozs7O0FDaEp6REEsR0FBSyxDQUFDLFVBQVUsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwQmpCLFNBQVMscUJBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7SUFDM0JFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ1pGLEdBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7OztJQUdwQ0UsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNOQSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ05BLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDTixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUNaLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDcEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNOLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDUCxNQUFNLElBQUksQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7TUFDNUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNwQixDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDckIsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7TUFDbEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUNOLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNuQyxNQUFNO01BQ0wsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDVixDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7TUFFaEIsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFO1FBQzlCRixHQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5RCxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztRQUNkLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztPQUN4RCxNQUFNO1FBQ0wsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNOLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQztPQUN2QztLQUNGOzs7SUFHREEsR0FBSyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDaEIsS0FBS0UsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztNQUN6QixDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDdkI7SUFDRCxLQUFLQSxHQUFHLENBQUNFLEdBQUMsR0FBRyxLQUFLLEVBQUVBLEdBQUMsRUFBRUEsR0FBQyxJQUFJLENBQUMsRUFBRTtNQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQ3pCLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUN2QjtJQUNELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDZkYsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7SUFHeEJGLEdBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLE9BQU8sR0FBRyxDQUFDLE1BQU0sRUFBRTtNQUNqQixLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQzdDLEdBQUcsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3hCO0lBQ0QsT0FBTyxLQUFLLENBQUM7R0FDZDs7RUFFRCxXQUFXLHVCQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFOztJQUUvQkEsR0FBSyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDaEIsS0FBS0UsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFO01BQ3BDQSxHQUFHLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDekIsS0FBS0EsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3QixLQUFLLEtBQUssQ0FBQyxDQUFDO09BQ2I7S0FDRjtJQUNELElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNmRixHQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7OztJQUcxQkEsR0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNwQ0EsR0FBSyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3BEQSxHQUFLLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkRBLEdBQUssQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOzs7SUFHaEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO01BQzFCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQztLQUNyQztJQUNELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUNULE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUNqRTtJQUNELElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtNQUNYLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FB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R0FBRyxDQUFDLENBQUM7O0VBRWQsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbEMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDckMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ3RCOztBQUVELFNBQVMsYUFBYSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO0VBQzNDRixHQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztFQUNoQkUsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7O0VBRWQsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbEMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDckMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ3RCOztBQUVELFNBQVMsYUFBYSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFO0VBQzNDRixHQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztFQUNoQkUsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7O0VBRWQsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDbEMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7RUFDckMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ3RCOztBQUVELFNBQVMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0VBQ3JERixHQUFLLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztFQUNoQkUsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7RUFDZCxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNsQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztF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OUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUU7RUFDOUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7RUFDOUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7RUFHOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztFQUN2QixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtFQUMzQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtFQUM5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDOUIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtFQUM5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtFQUM5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtFQUM5QixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7OztFQUc5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUM5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUM5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7RUFHOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUM5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDOUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzlCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztFQUM5QixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENB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QUFZLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ3ZFO0lBQ0QsSUFBSSxLQUFLLEdBQUcsVUFBVSxFQUFFO01BQ3RCLE9BQU8sZUFBZSxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDakUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDekMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDeEMsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUN0QztHQUNGO0VBQ0QsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMxQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN6QyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUN4QyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQztDQUN6Qzs7QUFFRCxTQUFTLGNBQWMsQ0FBQyxT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Q25DQSxHQUFHLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQzs7RUFFeEMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7RUFDcEMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7RUFDbkMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUUsR0FBRSxFQUFFLENBQUUsR0FBRyxFQUFFLENBQUM7O0VBRW5DLE9BQU8sQ0FBQyxDQUFHLEVBQUUsTUFBRSxHQUFFLEVBQUUsTUFBRSxHQUFFLEVBQUUsTUFBRSxHQUFFLEVBQUUsTUFBRSxHQUFFLEVBQUUsTUFBRSxHQUFFLEVBQUUsTUFBRSxHQUFFLEVBQUUsQ0FBRSxFQUFFLEdBQUMsR0FBRSxRQUFRLEdBQUcsZUFBZSxDQUFFLENBQUMsQ0FBQztDQUN2Rjs7Ozs7Ozs7Ozs7O0FBWUQsSUFBTSxjQUFjLEdBQWdCO0VBTWxDLHVCQUFXLENBQUMsU0FBUyxFQUFFOzs7Ozs7Ozs7OztJQVdyQkEsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7Ozs7Ozs7Ozs7OztJQVlsQkEsR0FBRyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7Ozs7Ozs7Ozs7OztJQVlsQkEsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7Ozs7Ozs7Ozs7OztJQVlqQkEsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7SUFhakJBLEdBQUcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7SUFZbEJBLEdBQUcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDOztJQUVsQkYsR0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLElBQUk7TUFDM0IsT0FBTyxNQUFNLEtBQUssV0FBVztnQ0FDSCxNQUFNO21DQUNILE1BQU07T0FDbEMsQ0FBQyxPQUFPLENBQUM7OztJQUdaLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7Ozs7Ozs7OztNQVM1QyxJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksT0FBTyxDQUFDLEdBQUcsS0FBSyxTQUFTLEVBQUU7UUFDNUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQztPQUM3RCxNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLE9BQU8sQ0FBQyxLQUFLLEtBQUssVUFBVSxFQUFFO1FBQy9ELE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM5RCxNQUFNLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDL0Q7Ozs7TUFJRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUU7UUFDOUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQzdELE1BQU07UUFDTCxLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDNUQ7Ozs7TUFJRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUU7UUFDOUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQzdELE1BQU07UUFDTCxLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDNUQ7Ozs7Ozs7TUFPRCxJQUFJLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7UUFDaEQsTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQzlELE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztPQUMvRCxN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QUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0csMkdBQTJHO0FBQzNHLDZGQUE2RjtBQUM3Rix5R0FBeUc7QUFDekcsdUhBQXVIO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDOzs7Ozs7QUN2aUJBLG1DOzs7Ozs7QUNBQSxzQzs7Ozs7O0FDQUEsOEM7Ozs7OztBQ0FBLDZDOzs7Ozs7QUNBQSxpRDs7Ozs7O0FDQUEsNEM7Ozs7OztBQ0FBLDZDOzs7Ozs7QUNBQSwrQzs7Ozs7O0FDQUEsK0M7Ozs7OztBQ0FBLG9EOzs7Ozs7QUNBQSxrRDs7Ozs7O0FDQUEsK0M7Ozs7OztBQ0FBLDRDOzs7Ozs7QUNBQSwrQzs7Ozs7O0FDQUEsK0M7Ozs7OztBQ0FBLDhDOzs7Ozs7QUNBQSxzRDs7Ozs7O0FDQUEsZ0Q7Ozs7OztBQ0FBLGdDOzs7Ozs7QUNBQSxtQzs7Ozs7O0FDQUEsK0I7Ozs7OztBQ0FBLGtDOzs7Ozs7QUNBQSxnQzs7Ozs7O0FDQUEsK0I7Ozs7OztBQ0FBLGdDOzs7Ozs7QUNBQSxnQzs7Ozs7O0FDQUEsK0IiLCJmaWxlIjoic29sY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjY1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzYTNjNzgxOTYxNmYyZjFlNWUyYiIsImNvbnN0IHsgQXJyYXlPcGVyYXRpb25zIH0gPSByZXF1aXJlKCcuL2xpYi9hcnJheS1vcGVyYXRpb25zJyk7XG5jb25zdCB7IGFzc2VydCB9ID0gcmVxdWlyZSgnLi9saWIvYXNzZXJ0Jyk7XG5jb25zdCB7IEJpZGlNYXAgfSA9IHJlcXVpcmUoJy4vbGliL2JpZGktbWFwJyk7XG5jb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJy4vbGliL2VudW0nKTtcbmNvbnN0IHsgSXRlcmF0b3IgfSA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdG9yJyk7XG5jb25zdCB7IExhenkgfSA9IHJlcXVpcmUoJy4vbGliL2xhenknKTtcbmNvbnN0IHsgbWFrZU1hcCB9ID0gcmVxdWlyZSgnLi9saWIvbWFrZS1tYXAnKTtcbmNvbnN0IHsgTWl4aW4gfSA9IHJlcXVpcmUoJy4vbGliL21peGluJyk7XG5jb25zdCB7IFJlc29sdmVyIH0gPSByZXF1aXJlKCcuL2xpYi9yZXNvbHZlcicpO1xuY29uc3QgeyBTZXRPcGVyYXRpb25zIH0gPSByZXF1aXJlKCcuL2xpYi9zZXQtb3BlcmF0aW9ucycpO1xuXG5tb2R1bGUuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5tb2R1bGUuZXhwb3J0cy5BcnJheU9wZXJhdGlvbnMgPSBBcnJheU9wZXJhdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5CaWRpTWFwID0gQmlkaU1hcDtcbm1vZHVsZS5leHBvcnRzLkVudW0gPSBFbnVtO1xubW9kdWxlLmV4cG9ydHMuSXRlcmF0b3IgPSBJdGVyYXRvcjtcbm1vZHVsZS5leHBvcnRzLkxhenkgPSBMYXp5O1xubW9kdWxlLmV4cG9ydHMubWFrZUl0ZXJhdG9yID0gSXRlcmF0b3IubWFrZUl0ZXJhdG9yO1xubW9kdWxlLmV4cG9ydHMubWFrZU1hcCA9IG1ha2VNYXA7XG5tb2R1bGUuZXhwb3J0cy5NaXhpbiA9IE1peGluO1xubW9kdWxlLmV4cG9ydHMubWl4aW4gPSBNaXhpbi5taXhpbjtcbm1vZHVsZS5leHBvcnRzLlJlc29sdmVyID0gUmVzb2x2ZXI7XG5tb2R1bGUuZXhwb3J0cy5yZXNvbHZlID0gUmVzb2x2ZXIucmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzLlNldE9wZXJhdGlvbnMgPSBTZXRPcGVyYXRpb25zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXNraXQvYXBpLmpzIiwiY29uc3QgeyBDb25zb2xlTG9nSW1wbCB9ID0gcmVxdWlyZSgnLi9saWIvY29uc29sZS1sb2ctaW1wbCcpO1xuY29uc3QgeyBHbG9iYWxCaW5kaW5nIH0gPSByZXF1aXJlKCcuL2xpYi9nbG9iYWwtYmluZGluZycpO1xuY29uc3QgeyBMb2dJbXBsIH0gPSByZXF1aXJlKCcuL2xpYi9sb2ctaW1wbCcpO1xuY29uc3QgeyBMb2dMZXZlbCB9ID0gcmVxdWlyZSgnLi9saWIvbG9nLWxldmVscycpO1xuXG5jb25zdCB7IFBhcmFtZXRlciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5jb25zdCB7IFNvbGNsaWVudEZhY3RvcnkgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5cbmNvbnN0IHtcbiAgaXNFbnVtTWVtYmVyLFxuICBpc0Z1bmN0aW9uLFxufSA9IFBhcmFtZXRlcjtcblxuY29uc3Qge1xuICBnZXRJbXBsLFxuICBnZXRMb2dMZXZlbCxcbiAgc2V0SW1wbCxcbiAgc2V0TG9nTGV2ZWwsXG59ID0gR2xvYmFsQmluZGluZztcblxuY29uc3QgZm9yd2FyZGVyID0ge307XG5mdW5jdGlvbiBidWlsZExvZ0ZvcndhcmRlcigpIHtcbiAgT2JqZWN0LmFzc2lnbihmb3J3YXJkZXIsIHtcbiAgICB0cmFjZSguLi5hcmdzKSB7XG4gICAgICBjb25zdCBpbXBsID0gZ2V0SW1wbCgpO1xuICAgICAgaWYgKGltcGwgJiYgaW1wbC50cmFjZSAmJiBnZXRMb2dMZXZlbCgpID49IExvZ0xldmVsLlRSQUNFKSB7XG4gICAgICAgIGltcGwudHJhY2UuYXBwbHkobnVsbCwgWydzb2xjbGllbnRqczogJywgLi4uYXJnc10pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICBjb25zdCBpbXBsID0gZ2V0SW1wbCgpO1xuICAgICAgaWYgKGltcGwgJiYgaW1wbC5kZWJ1ZyAmJiBnZXRMb2dMZXZlbCgpID49IExvZ0xldmVsLkRFQlVHKSB7XG4gICAgICAgIGltcGwuZGVidWcuYXBwbHkobnVsbCwgWydzb2xjbGllbnRqczogJywgLi4uYXJnc10pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGltcGwgPSBnZXRJbXBsKCk7XG4gICAgICBpZiAoaW1wbCAmJiBpbXBsLmluZm8gJiYgZ2V0TG9nTGV2ZWwoKSA+PSBMb2dMZXZlbC5JTkZPKSB7XG4gICAgICAgIGltcGwuaW5mby5hcHBseShudWxsLCBbJ3NvbGNsaWVudGpzOiAnLCAuLi5hcmdzXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgY29uc3QgaW1wbCA9IGdldEltcGwoKTtcbiAgICAgIGlmIChpbXBsICYmIGltcGwud2FybiAmJiBnZXRMb2dMZXZlbCgpID49IExvZ0xldmVsLldBUk4pIHtcbiAgICAgICAgaW1wbC53YXJuLmFwcGx5KG51bGwsIFsnc29sY2xpZW50anM6ICcsIC4uLmFyZ3NdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgY29uc3QgaW1wbCA9IGdldEltcGwoKTtcbiAgICAgIGlmIChpbXBsICYmIGltcGwuZXJyb3IgJiYgZ2V0TG9nTGV2ZWwoKSA+PSBMb2dMZXZlbC5FUlJPUikge1xuICAgICAgICBpbXBsLmVycm9yLmFwcGx5KG51bGwsIFsnc29sY2xpZW50anM6ICcsIC4uLmFyZ3NdKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmF0YWwoLi4uYXJncykge1xuICAgICAgY29uc3QgaW1wbCA9IGdldEltcGwoKTtcbiAgICAgIGlmIChpbXBsICYmIGltcGwuZmF0YWwpIHtcbiAgICAgICAgaW1wbC5mYXRhbC5hcHBseShudWxsLCBbJ3NvbGNsaWVudGpzOiAnLCAuLi5hcmdzXSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5idWlsZExvZ0ZvcndhcmRlcigpOyAvLyBzdHJpcHBlZCBieSBwcm9kdWN0aW9uIGJ1aWxkXG5cbmZ1bmN0aW9uIGFkZEdsb2JhbEZ1bmNzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIE9iamVjdC5rZXlzKGZvcndhcmRlcikuZm9yRWFjaCgoaykgPT4ge1xuICAgIHRhcmdldFtgTE9HXyR7ay50b1VwcGVyQ2FzZSgpfWBdID0gc291cmNlW2tdO1xuICB9KTtcbn1cblxuY2xhc3MgTG9nRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoZm9ybWF0dGVyKSB7XG4gICAgdGhpcy5fZm9ybWF0dGVyID0gKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZm9ybWF0dGVyO1xuICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSByZXR1cm4gZnVuY3Rpb24gcHJlcGVuZCguLi5hcmdzKSB7IHJldHVybiBbZm9ybWF0dGVyLCAuLi5hcmdzXTsgfTtcbiAgICAgIGlmICghZm9ybWF0dGVyKSByZXR1cm4gZnVuY3Rpb24gcGFzc3Rocm91Z2goLi4uYXJncykgeyByZXR1cm4gWy4uLmFyZ3NdOyB9O1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcjtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGZvcndhcmRlcikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzW2tleV0gPSBmdW5jdGlvbiBmb3J3YXJkKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZvcndhcmRlcltrZXldLmFwcGx5KG51bGwsIHNlbGYuX2Zvcm1hdHRlciguLi5hcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGFkZEdsb2JhbEZ1bmNzKHRoaXMsIHRoaXMpO1xuICB9XG5cbiAgZ2V0IGZvcm1hdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyO1xuICB9XG4gIHNldCBmb3JtYXR0ZXIoZnVuYykge1xuICAgIHRoaXMuX2Zvcm1hdHRlciA9IGZ1bmM7XG4gIH1cblxuICB3cmFwKGdlbmVyaWNGdW5jdGlvbiwgdGFyZ2V0U2VsZikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiBnZW5lcmljTG9nV3JhcHBlciguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gZ2VuZXJpY0Z1bmN0aW9uLmFwcGx5KHRhcmdldFNlbGYsIHNlbGYuX2Zvcm1hdHRlciguLi5hcmdzKSk7XG4gICAgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIHdoaWNoIHdhcyBzZXQgYnkge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LmluaXR9IG9yIGFcbiAqIHN1YnNlcXVlbnQgY2FsbCB0byB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3Rvcnkuc2V0TG9nTGV2ZWx9LlxuICpcbiAqIEByZXR1cm5zIHtzb2xhY2UuTG9nTGV2ZWx9IFRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAqL1xuU29sY2xpZW50RmFjdG9yeS5nZXRMb2dMZXZlbCA9ICgpID0+IGdldExvZ0xldmVsKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNoYW5nZXMgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGZyb20gdGhlIGxldmVsIHNldCB3aGVuXG4gICAqIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5pbml0fSB3YXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5Mb2dMZXZlbH0gbmV3TGV2ZWwgVGhlIG5ldyBsb2cgbGV2ZWwgdG8gc2V0LlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IEludmFsaWQgbG9nIGxldmVsXG4gICAqL1xuU29sY2xpZW50RmFjdG9yeS5zZXRMb2dMZXZlbCA9IChuZXdMZXZlbCkgPT4ge1xuICBpc0VudW1NZW1iZXIoJ2xvZ0xldmVsJywgbmV3TGV2ZWwsIExvZ0xldmVsKTtcbiAgc2V0TG9nTGV2ZWwobmV3TGV2ZWwpO1xufTtcblxuU29sY2xpZW50RmFjdG9yeS5hZGRJbml0aWFsaXplcigocHJvcHMpID0+IHtcbiAgc2V0TG9nTGV2ZWwocHJvcHMubG9nTGV2ZWwpO1xuXG4gIGNvbnN0IGxvZ2dlciA9IHByb3BzLmxvZ2dlciB8fCBnZXRJbXBsKCkgfHwgbmV3IENvbnNvbGVMb2dJbXBsKCk7XG4gIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHN1cHBsaWVkIGxvZyBpbXBsZW1lbnRhdGlvbiBpcyBhIHN1cGVyc2V0IG9mIExvZ0ltcGxcbiAgT2JqZWN0LmtleXMobmV3IExvZ0ltcGwoKSkuZm9yRWFjaChrZXkgPT4gaXNGdW5jdGlvbihgbG9nZ2VyLiR7a2V5fWAsIGxvZ2dlcltrZXldKSk7XG5cbiAgc2V0SW1wbChsb2dnZXIpO1xufSk7XG5cbmFkZEdsb2JhbEZ1bmNzKGZvcndhcmRlciwgbW9kdWxlLmV4cG9ydHMpO1xubW9kdWxlLmV4cG9ydHMuTG9nSW1wbCA9IExvZ0ltcGw7XG5tb2R1bGUuZXhwb3J0cy5Mb2dMZXZlbCA9IExvZ0xldmVsO1xubW9kdWxlLmV4cG9ydHMuQmluZGluZyA9IEdsb2JhbEJpbmRpbmc7XG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlTG9nSW1wbCA9IENvbnNvbGVMb2dJbXBsO1xuR2xvYmFsQmluZGluZy5zZXRJbXBsKG5ldyBDb25zb2xlTG9nSW1wbCgpKTtcbm1vZHVsZS5leHBvcnRzLkxvZ0Zvcm1hdHRlciA9IExvZ0Zvcm1hdHRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWxvZy9hcGkuanMiLCJjb25zdCB7IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyIH0gPSByZXF1aXJlKCcuL2xpYi9lcnJvci1yZXNwb25zZS1zdWJjb2RlLW1hcHBlcicpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUgfSA9IHJlcXVpcmUoJy4vbGliL2Vycm9yLXN1YmNvZGVzJyk7XG5jb25zdCB7IE5vdEltcGxlbWVudGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4vbGliL25vdC1pbXBsZW1lbnRlZC1lcnJvcicpO1xuY29uc3QgeyBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnLi9saWIvb3BlcmF0aW9uLWVycm9yJyk7XG5jb25zdCB7IFJlcXVlc3RFcnJvciB9ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdC1lcnJvcicpO1xuY29uc3QgeyBSZXF1ZXN0RXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0LWV2ZW50LWNvZGVzJyk7XG5jb25zdCB7IFNvbGFjZUVycm9yIH0gPSByZXF1aXJlKCcuL2xpYi9zb2xhY2UtZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMuRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlcjtcbm1vZHVsZS5leHBvcnRzLkVycm9yU3ViY29kZSA9IEVycm9yU3ViY29kZTtcbm1vZHVsZS5leHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSBOb3RJbXBsZW1lbnRlZEVycm9yO1xubW9kdWxlLmV4cG9ydHMuT3BlcmF0aW9uRXJyb3IgPSBPcGVyYXRpb25FcnJvcjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3RFcnJvciA9IFJlcXVlc3RFcnJvcjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3RFdmVudENvZGUgPSBSZXF1ZXN0RXZlbnRDb2RlO1xubW9kdWxlLmV4cG9ydHMuU29sYWNlRXJyb3IgPSBTb2xhY2VFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVycm9yL2FwaS5qcyIsImNvbnN0IHsgQmFzZTY0IH0gPSByZXF1aXJlKCcuL2xpYi9iYXNlNjQnKTtcbmNvbnN0IHsgQml0cyB9ID0gcmVxdWlyZSgnLi9saWIvYml0cycpO1xuY29uc3QgeyBDb252ZXJ0IH0gPSByZXF1aXJlKCcuL2xpYi9jb252ZXJ0Jyk7XG5jb25zdCB7IEhleCB9ID0gcmVxdWlyZSgnLi9saWIvaGV4Jyk7XG5jb25zdCB7IExvbmcgfSA9IHJlcXVpcmUoJy4vbGliL2xvbmcnKTtcblxubW9kdWxlLmV4cG9ydHMuQmFzZTY0ID0gQmFzZTY0O1xubW9kdWxlLmV4cG9ydHMuQml0cyA9IEJpdHM7XG5tb2R1bGUuZXhwb3J0cy5Db252ZXJ0ID0gQ29udmVydDtcbm1vZHVsZS5leHBvcnRzLkhleCA9IEhleDtcbm1vZHVsZS5leHBvcnRzLkxvbmcgPSBMb25nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29udmVydC9hcGkuanMiLCJjb25zdCB7IEFQSVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vbGliL2FwaS1wcm9wZXJ0aWVzJyk7XG5jb25zdCB7IEFQSVByb3BlcnRpZXNWYWxpZGF0b3JzIH0gPSByZXF1aXJlKCcuL2xpYi9hcGktcHJvcGVydGllcy12YWxpZGF0b3JzJyk7XG5jb25zdCB7IEFycmF5VXRpbHMgfSA9IHJlcXVpcmUoJy4vbGliL2FycmF5LXV0aWxzJyk7XG5jb25zdCB7IHBhcnNlVVJMIH0gPSByZXF1aXJlKCcuL2xpYi91cmwnKTtcbmNvbnN0IHsgUHJvY2VzcyB9ID0gcmVxdWlyZSgnLi9saWIvcHJvY2VzcycpO1xuY29uc3QgeyBTdHJpbmdCdWZmZXIgfSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZy1idWZmZXInKTtcbmNvbnN0IHsgU3RyaW5nVXRpbHMgfSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZy11dGlscycpO1xuY29uc3QgeyBUaW1pbmdCdWNrZXQgfSA9IHJlcXVpcmUoJy4vbGliL3RpbWluZy1idWNrZXQnKTtcbmNvbnN0IHsgVVVJRCB9ID0gcmVxdWlyZSgnLi9saWIvdXVpZCcpO1xuY29uc3QgeyBWZXJzaW9uIH0gPSByZXF1aXJlKCcuL2xpYi92ZXJzaW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVVSTCxcblxuICBBUElQcm9wZXJ0aWVzLFxuICBBUElQcm9wZXJ0aWVzVmFsaWRhdG9ycyxcbiAgQXJyYXlVdGlscyxcbiAgUHJvY2VzcyxcbiAgU3RyaW5nQnVmZmVyLFxuICBTdHJpbmdVdGlscyxcbiAgVGltaW5nQnVja2V0LFxuICBVVUlELFxuICBWZXJzaW9uLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXV0aWwvYXBpLmpzIiwiY29uc3QgeyBEZXN0aW5hdGlvbiB9ID0gcmVxdWlyZSgnLi9saWIvZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgRGVzdGluYXRpb25Gcm9tTmV0d29yayB9ID0gcmVxdWlyZSgnLi9saWIvZGVzdGluYXRpb24tZnJvbS1uZXR3b3JrJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvZGVzdGluYXRpb24tdHlwZScpO1xuY29uc3QgeyBEZXN0aW5hdGlvblV0aWwgfSA9IHJlcXVpcmUoJy4vbGliL2Rlc3RpbmF0aW9uLXV0aWwnKTtcbmNvbnN0IHsgUGFyYW1ldGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcbmNvbnN0IHsgUXVldWUgfSA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlJyk7XG5jb25zdCB7IFNvbGNsaWVudEZhY3RvcnkgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5jb25zdCB7IFRvcGljIH0gPSByZXF1aXJlKCcuL2xpYi90b3BpYycpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRvcGljIHtAbGluayBzb2xhY2UuRGVzdGluYXRpb259IGluc3RhbmNlLiBXaGVuIHRoZSByZXR1cm5lZCBEZXN0aW5hdGlvbiBpcyBzZXQgYXNcbiAqIHRoZSBkZXN0aW5hdGlvbiBvZiBhIG1lc3NhZ2UgdmlhIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXREZXN0aW5hdGlvbn0sIHRoZSBtZXNzYWdlIHdpbGwgYmVcbiAqIGRlbGl2ZXJlZCB0byBkaXJlY3Qgc3Vic2NyaWJlcnMgb3IgdG9waWMgZW5kcG9pbnRzIHN1YnNjcmliZWQgdG8gdGhlIGdpdmVuIHRvcGljLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpY05hbWUgVGhlIHRvcGljIHN0cmluZyBmb3IgdGhlIG5ldyB0b3BpYy5cbiAqIEByZXR1cm5zIHtzb2xhY2UuRGVzdGluYXRpb259IFRoZSBuZXdseSBjcmVhdGVkIHRvcGljIGRlc3RpbmF0aW9uLlxuICogQG1ldGhvZFxuICogQG5hbWUgc29sYWNlLlNvbGNsaWVudEZhY3RvcnkuY3JlYXRlVG9waWNEZXN0aW5hdGlvblxuICovXG5Tb2xjbGllbnRGYWN0b3J5LmNyZWF0ZVRvcGljRGVzdGluYXRpb24gPSBTb2xjbGllbnRGYWN0b3J5LmNyZWF0ZUZhY3RvcnkoKHRvcGljTmFtZSkgPT4ge1xuICBQYXJhbWV0ZXIuaXNTdHJpbmcoJ3RvcGljTmFtZScsIHRvcGljTmFtZSk7XG4gIHJldHVybiBUb3BpYy5jcmVhdGVGcm9tTmFtZSh0b3BpY05hbWUpO1xufSk7XG4vKiBAZGVwcmVjYXRlZCBAKi9cblNvbGNsaWVudEZhY3RvcnkuY3JlYXRlVG9waWMgPSBTb2xjbGllbnRGYWN0b3J5LmNyZWF0ZUZhY3RvcnkodG9waWNOYW1lID0+IG5ldyBUb3BpYyh0b3BpY05hbWUpKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZHVyYWJsZSBxdWV1ZSB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9ufSBpbnN0YW5jZS4gV2hlbiB0aGUgcmV0dXJuZWQgRGVzdGluYXRpb24gaXNcbiAqIHNldCBhcyB0aGUgZGVzdGluYXRpb24gb2YgYSBtZXNzYWdlIHZpYSB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0RGVzdGluYXRpb259LCB0aGUgbWVzc2FnZSB3aWxsXG4gKiBiZSBkZWxpdmVyZWQgdG8gdGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBxdWV1ZSBvbiB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIG9mIHRoZSBzYW1lIG5hbWUuXG4gKlxuICogQHNpbmNlIDEwLjAuMFxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXVlTmFtZSBUaGUgcXVldWVOYW1lIG9mIHRoZSBxdWV1ZVxuICogQHJldHVybnMge3NvbGFjZS5EZXN0aW5hdGlvbn0gVGhlIG5ld2x5IGNyZWF0ZWQgcXVldWUgZGVzdGluYXRpb24uXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVEdXJhYmxlUXVldWVEZXN0aW5hdGlvblxuICovXG5Tb2xjbGllbnRGYWN0b3J5LmNyZWF0ZUR1cmFibGVRdWV1ZURlc3RpbmF0aW9uID0gU29sY2xpZW50RmFjdG9yeS5jcmVhdGVGYWN0b3J5KChxdWV1ZU5hbWUpID0+IHtcbiAgUGFyYW1ldGVyLmlzU3RyaW5nKCdxdWV1ZU5hbWUnLCBxdWV1ZU5hbWUpO1xuICByZXR1cm4gUXVldWUuY3JlYXRlRnJvbUxvY2FsTmFtZShxdWV1ZU5hbWUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzLkRlc3RpbmF0aW9uID0gRGVzdGluYXRpb247XG5tb2R1bGUuZXhwb3J0cy5EZXN0aW5hdGlvbkZyb21OZXR3b3JrID0gRGVzdGluYXRpb25Gcm9tTmV0d29yaztcbm1vZHVsZS5leHBvcnRzLkRlc3RpbmF0aW9uVHlwZSA9IERlc3RpbmF0aW9uVHlwZTtcbm1vZHVsZS5leHBvcnRzLkRlc3RpbmF0aW9uVXRpbCA9IERlc3RpbmF0aW9uVXRpbDtcbm1vZHVsZS5leHBvcnRzLlF1ZXVlID0gUXVldWU7XG5tb2R1bGUuZXhwb3J0cy5Ub3BpYyA9IFRvcGljO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vYXBpLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInV0aWxcIlxuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCB7IENoZWNrIH0gPSByZXF1aXJlKCcuL2xpYi9jaGVjaycpO1xuY29uc3QgeyBQYXJhbWV0ZXIgfSA9IHJlcXVpcmUoJy4vbGliL3BhcmFtZXRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cy5DaGVjayA9IENoZWNrO1xubW9kdWxlLmV4cG9ydHMuUGFyYW1ldGVyID0gUGFyYW1ldGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdmFsaWRhdGUvYXBpLmpzIiwiY29uc3QgQ29kZWNMaWIgPSByZXF1aXJlKCcuL2xpYi9jb2RlYycpO1xuY29uc3QgeyBBZFByb3RvY29sTWVzc2FnZSwgQmluYXJ5TWV0YUJsb2NrLCBDbGllbnRDdHJsTWVzc2FnZSwgS2VlcEFsaXZlTWVzc2FnZSwgU01QTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1vYmplY3RzJyk7XG5jb25zdCB7IFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvc21mLWFkcHJvdG9jb2wtbWVzc2FnZS10eXBlcycpO1xuY29uc3QgeyBTTUZBZFByb3RvY29sUGFyYW0gfSA9IHJlcXVpcmUoJy4vbGliL3NtZi1hZHByb3RvY29sLXBhcmFtcycpO1xuY29uc3QgeyBTTUZDbGllbnRDdHJsTWVzc2FnZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL3NtZi1jbGllbnQtY3RybC1tZXNzYWdlLXR5cGVzJyk7XG5jb25zdCB7IFNNRkNsaWVudEN0cmxQYXJhbSB9ID0gcmVxdWlyZSgnLi9saWIvc21mLWNsaWVudC1jdHJsLXBhcmFtcycpO1xuY29uc3QgeyBTTUZQYXJhbWV0ZXJUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9zbWYtcGFyYW1ldGVyLXR5cGVzJyk7XG5jb25zdCB7IFNNRlByb3RvY29sIH0gPSByZXF1aXJlKCcuL2xpYi9zbWYtcHJvdG9jb2xzJyk7XG5jb25zdCB7IFNNRlNNUE1lc3NhZ2VUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9zbWYtc21wLW1lc3NhZ2UtdHlwZXMnKTtcbmNvbnN0IHsgU01GU01QTWVzc2FnZVR5cGVGbGFncyB9ID0gcmVxdWlyZSgnLi9saWIvc21mLXNtcC1tZXNzYWdlLXR5cGUtZmxhZ3MnKTtcbmNvbnN0IHsgU01GVHJhbnNwb3J0U2Vzc2lvbk1lc3NhZ2VUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9zbWYtdHJhbnNwb3J0LXNlc3Npb24tbWVzc2FnZS10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5BZFByb3RvY29sTWVzc2FnZSA9IEFkUHJvdG9jb2xNZXNzYWdlO1xubW9kdWxlLmV4cG9ydHMuQmluYXJ5TWV0YUJsb2NrID0gQmluYXJ5TWV0YUJsb2NrO1xubW9kdWxlLmV4cG9ydHMuQ2xpZW50Q3RybE1lc3NhZ2UgPSBDbGllbnRDdHJsTWVzc2FnZTtcbm1vZHVsZS5leHBvcnRzLkNvZGVjID0gQ29kZWNMaWI7XG5tb2R1bGUuZXhwb3J0cy5LZWVwQWxpdmVNZXNzYWdlID0gS2VlcEFsaXZlTWVzc2FnZTtcbm1vZHVsZS5leHBvcnRzLlNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSA9IFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZTtcbm1vZHVsZS5leHBvcnRzLlNNRkFkUHJvdG9jb2xQYXJhbSA9IFNNRkFkUHJvdG9jb2xQYXJhbTtcbm1vZHVsZS5leHBvcnRzLlNNRkNsaWVudEN0cmxNZXNzYWdlVHlwZSA9IFNNRkNsaWVudEN0cmxNZXNzYWdlVHlwZTtcbm1vZHVsZS5leHBvcnRzLlNNRkNsaWVudEN0cmxQYXJhbSA9IFNNRkNsaWVudEN0cmxQYXJhbTtcbm1vZHVsZS5leHBvcnRzLlNNRlBhcmFtZXRlclR5cGUgPSBTTUZQYXJhbWV0ZXJUeXBlO1xubW9kdWxlLmV4cG9ydHMuU01GUHJvdG9jb2wgPSBTTUZQcm90b2NvbDtcbm1vZHVsZS5leHBvcnRzLlNNRlNNUE1lc3NhZ2VUeXBlRmxhZ3MgPSBTTUZTTVBNZXNzYWdlVHlwZUZsYWdzO1xubW9kdWxlLmV4cG9ydHMuU01GU01QTWVzc2FnZVR5cGUgPSBTTUZTTVBNZXNzYWdlVHlwZTtcbm1vZHVsZS5leHBvcnRzLlNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZSA9IFNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZTtcbm1vZHVsZS5leHBvcnRzLlNNUE1lc3NhZ2UgPSBTTVBNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2FwaS5qcyIsImNvbnN0IHsgRmFjdG9yeVByb2ZpbGUsIFNvbGNsaWVudEZhY3RvcnlQcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9saWIvc29sY2xpZW50LWZhY3RvcnktcHJvZmlsZXMnKTtcbmNvbnN0IHsgUHJvZmlsZUJpbmRpbmcgfSA9IHJlcXVpcmUoJy4vbGliL3Byb2ZpbGUtYmluZGluZycpO1xuY29uc3QgeyBTb2xjbGllbnRGYWN0b3J5IH0gPSByZXF1aXJlKCcuL2xpYi9zb2xjbGllbnQtZmFjdG9yeScpO1xuY29uc3QgeyBTb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcyB9ID0gcmVxdWlyZSgnLi9saWIvc29sY2xpZW50LWZhY3RvcnktcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5GYWN0b3J5UHJvZmlsZSA9IEZhY3RvcnlQcm9maWxlO1xubW9kdWxlLmV4cG9ydHMuUHJvZmlsZUJpbmRpbmcgPSBQcm9maWxlQmluZGluZztcbm1vZHVsZS5leHBvcnRzLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcyA9IFNvbGNsaWVudEZhY3RvcnlQcm9maWxlcztcbm1vZHVsZS5leHBvcnRzLlNvbGNsaWVudEZhY3RvcnlQcm9wZXJ0aWVzID0gU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXM7XG5tb2R1bGUuZXhwb3J0cy5Tb2xjbGllbnRGYWN0b3J5ID0gU29sY2xpZW50RmFjdG9yeTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZmFjdG9yeS9hcGkuanMiLCJjb25zdCB7IENvZGVjIH0gPSByZXF1aXJlKCcuL2xpYi9jb2RlYycpO1xuY29uc3QgeyBTRFREZXN0VHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvc2R0LWRlc3RpbmF0aW9uLXR5cGVzJyk7XG5jb25zdCB7IFNEVEZpZWxkIH0gPSByZXF1aXJlKCcuL2xpYi9zZHQtZmllbGQnKTtcbmNvbnN0IHsgU0RURmllbGRUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9zZHQtZmllbGQtdHlwZXMnKTtcbmNvbnN0IHsgU0RUTWFwQ29udGFpbmVyIH0gPSByZXF1aXJlKCcuL2xpYi9zZHQtbWFwLWNvbnRhaW5lcicpO1xuY29uc3QgeyBTRFRTdHJlYW1Db250YWluZXIgfSA9IHJlcXVpcmUoJy4vbGliL3NkdC1zdHJlYW0tY29udGFpbmVyJyk7XG5jb25zdCB7IFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvciB9ID0gcmVxdWlyZSgnLi9saWIvc2R0LXVuc3VwcG9ydGVkLXZhbHVlLWVycm9yJyk7XG5jb25zdCB7IFNEVFZhbHVlRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCcuL2xpYi9zZHQtdmFsdWUtZXJyb3Itc3ViY29kZXMnKTtcblxubW9kdWxlLmV4cG9ydHMuQ29kZWMgPSBDb2RlYztcbm1vZHVsZS5leHBvcnRzLlNEVERlc3RUeXBlID0gU0RURGVzdFR5cGU7XG5tb2R1bGUuZXhwb3J0cy5TRFRGaWVsZCA9IFNEVEZpZWxkO1xubW9kdWxlLmV4cG9ydHMuU0RURmllbGRUeXBlID0gU0RURmllbGRUeXBlO1xubW9kdWxlLmV4cG9ydHMuU0RUTWFwQ29udGFpbmVyID0gU0RUTWFwQ29udGFpbmVyO1xubW9kdWxlLmV4cG9ydHMuU0RUU3RyZWFtQ29udGFpbmVyID0gU0RUU3RyZWFtQ29udGFpbmVyO1xubW9kdWxlLmV4cG9ydHMuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yID0gU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yO1xubW9kdWxlLmV4cG9ydHMuU0RUVmFsdWVFcnJvclN1YmNvZGUgPSBTRFRWYWx1ZUVycm9yU3ViY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9hcGkuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIGFsbCBTRFQgZGF0YSB0eXBlcy5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IFNEVEZpZWxkVHlwZSA9IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgYm9vbGVhbi5cbiAgICovXG4gIEJPT0w6ICAgICAgICAwLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIE1hcHMgdG8gYSBudW1iZXIuXG4gICAqL1xuICBVSU5UODogICAgICAgMSxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgbnVtYmVyLlxuICAgKi9cbiAgSU5UODogICAgICAgIDIsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTWFwcyB0byBhIG51bWJlci5cbiAgICovXG4gIFVJTlQxNjogICAgICAzLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIE1hcHMgdG8gYSBudW1iZXIuXG4gICAqL1xuICBJTlQxNjogICAgICAgNCxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgbnVtYmVyLlxuICAgKi9cbiAgVUlOVDMyOiAgICAgIDUsXG4gIC8qKlxuICAgKkB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgbnVtYmVyLlxuICAgKi9cbiAgSU5UMzI6ICAgICAgIDYsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTWFwcyB0byBhIG51bWJlci4gPGJyPlxuICAgKiA8c3Ryb25nPldhcm5pbmc6PC9zdHJvbmc+IFN1cHBvcnRzIDQ4LWJpdCBpbnRlZ2VycyAocmFuZ2U6IDAgdG8gMjxzdXA+NDg8L3N1cD4tMSkuXG4gICAqIFdoZW4gZGVjb2RpbmcsIG9ubHkgdGhlIGxvd2VyIDQ4IGJpdHMgYXJlIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuXG4gICAqL1xuICBVSU5UNjQ6ICAgICAgNyxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgbnVtYmVyLiA8YnI+XG4gICAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gU3VwcG9ydHMgNDgtYml0IGludGVnZXJzICsgc2lnbiAocmFuZ2U6IC0oMjxzdXA+NDg8L3N1cD4tMSkgdG9cbiAgICogMjxzdXA+NDg8L3N1cD4tMSkuIFdoZW4gZGVjb2RpbmcsIG9ubHkgdGhlIGxvd2VyIDQ4IGJpdHMgYXJlIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuXG4gICAqL1xuICBJTlQ2NDogICAgICAgOCxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBBIHNpbmdsZSBjaGFyYWN0ZXI7IG1hcHMgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBXQ0hBUjogICAgICAgOSxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU1RSSU5HOiAgICAgIDEwLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIE1hcHMgdG8gYSBzdHJpbmcgKHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGJ5dGUgYXJyYXkpLlxuICAgKi9cbiAgQllURUFSUkFZOiAgIDExLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFNpbmdsZS1wcmVjaXNpb24gZmxvYXQ7IG1hcHMgdG8gYSBudW1iZXIuXG4gICAqL1xuICBGTE9BVFRZUEU6ICAgMTIsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gRG91YmxlLXByZWNpc2lvbiBmbG9hdDsgbWFwcyB0byBhIG51bWJlci5cbiAgICovXG4gIERPVUJMRVRZUEU6ICAxMyxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNYXBzIHRvIHtAbGluayBTRFRNYXBDb250YWluZXJ9LlxuICAgKi9cbiAgTUFQOiAgICAgICAgIDE0LFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIE1hcHMgdG8ge0BsaW5rIFNEVFN0cmVhbUNvbnRhaW5lcn0uXG4gICAqL1xuICBTVFJFQU06ICAgICAgMTUsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTWFwcyB0byB7QGxpbmsgRGVzdGluYXRpb259LlxuICAgKi9cbiAgREVTVElOQVRJT046IDE2LFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIE1hcHMgdG8gPGNvZGU+bnVsbDwvY29kZT4uXG4gICAqL1xuICBOVUxMVFlQRTogICAgMTcsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTWFwcyB0byBhbiB1bmtub3duIHR5cGUuXG4gICAqL1xuICBVTktOT1dOOiAgICAgMTgsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTWFwcyB0byBhbiBlbmNvZGVkIFNNRiBtZXNzYWdlLlxuICAgKi9cbiAgU01GX01FU1NBR0U6IDE5LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU0RURmllbGRUeXBlID0gRW51bS5uZXcoU0RURmllbGRUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvc2R0LWZpZWxkLXR5cGVzLmpzIiwiY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4vc2R0LWZpZWxkLXR5cGVzJyk7XG5jb25zdCB7IHZhbGlkYXRlU2R0RmllbGQgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUtc2R0LWZpZWxkJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+XG4gKlxuICogUmVwcmVzZW50cyBhIFNEVCAoU3RydWN0dXJlZCBEYXRhIFR5cGUpIGZpZWxkLiBUbyBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gPGNvZGU+U0RURmllbGQ8L2NvZGU+LFxuICogY2FsbCB7QGxpbmsgc29sYWNlLlNEVEZpZWxkLmNyZWF0ZX0uXG4gKlxuICogU0RURmllbGQgb2JqZWN0cyBhcmUgdXNlZCBpbiBTb2xhY2UgQ29udGFpbmVycyAoe0BsaW5rIHNvbGFjZS5TRFRNYXBDb250YWluZXJ9XG4gKiBhbmQge0BsaW5rIHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXJ9KS4gVGhlIDxiPmRlcHJlY2F0ZWQ8L2I+IHVzYWdlIG9mXG4gKiB7QGxpbmsgc29sYWNlLlNEVE1hcENvbnRhaW5lciNhZGRGaWVsZH0gYW5kIHtAbGluayBzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyI2FkZEZpZWxkfVxuICogdGFrZSBhIFNEVEZpZWxkIG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIHByZWZlcnJlZCB1c2FnZSBpcyB0byBwYXNzIGFcbiAqIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlfSBhbmQgdmFsdWUgYXMgYXJndW1lbnRzLlxuICpcbiAqIFNEVEZpZWxkIG9iamVjdHRzIG11c3QgYmUgdXNlZCBhcyBhbiBhcmd1bWVudCB0byB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0U2R0Q29udGFpbmVyfS5cbiAqIFRoZSBvbmx5IHZhbGlkIFNEVEZpZWxkIG9iamVjdHMgZm9yIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXRTZHRDb250YWluZXJ9IGFyZTpcbiAqICoge0BsaW5rIHNvbGFjZS5TRFRGaWVsZFR5cGUuU1RSRUFNfVxuICogKiB7QGxpbmsgc29sYWNlLlNEVEZpZWxkVHlwZS5NQVB9XG4gKiAqIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlLlNUUklOR31cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgU0RURmllbGQge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1NEVEZpZWxkVHlwZX0gW3R5cGU9U0RURmllbGRUeXBlLk5VTExUWVBFXSBUaGUgZmllbGQgdHlwZSB0byBjb25zdHJ1Y3RcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgZW5jYXBzdWxhdGVkXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdHlwZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSA9IFNEVEZpZWxkVHlwZS5OVUxMVFlQRSwgdmFsdWUgPSBudWxsKSB7XG4gICAgY29uc3QgZXJyID0gdmFsaWRhdGVTZHRGaWVsZCh0eXBlLCB2YWx1ZSk7XG4gICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgKGVycik7XG4gICAgfVxuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHlwZSBvZiBmaWVsZCByZXByZXNlbnRlZC5cbiAgICogQHJldHVybnMge3NvbGFjZS5TRFRGaWVsZFR5cGV9IFRoZSB0eXBlIG9mIGZpZWxkIHJlcHJlc2VudGVkLlxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaWVsZCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IEZpZWxkIHZhbHVlIChhcyBvbmUgb2YgdGhlIHN1cHBvcnRlZCBkYXRhIHR5cGVzKS5cbiAgICogQHRocm93cyB7c29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcn0gaWYgdmFsdWUgZm91bmQgaW4gdGhlIGZpZWxkXG4gICAqIGlzIG5vdCBpbiByYW5nZSBzdXBwb3J0ZWQgYnkgdGhlIHBsYXRmb3JtL3J1bnRpbWUuXG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgKHRoaXMuX2Vycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gZXJyb3Igb24gdGhlIG9iamVjdCB0byBiZSB0aHJvd24gb24gZ2V0VmFsdWUoKS5cbiAgICogVXNlZCBvbmx5IGJ5IHBhcnNlLWludGVnZXIsIGFzIGl0IGlzIHBvc3NpYmxlIHRvIHJlY2VpdmVcbiAgICogNjQgYml0IGludGVnZXJzIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIGEgamF2YVNjcmlwdCBudW1iZXIuXG4gICAqIEphdmFTY3JpcHQgbnVtYmVycyBhcmUgZmxvYXRzIGFuZCBjYW4gb25seSBob2xkIGEgNDggYml0IGludGVnZXIuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcn0gZXJyIGVycm9yIG9iamVjdC5cbiAgICovXG4gIHNldEVycm9yKGVycikge1xuICAgIHRoaXMuX2Vycm9yID0gZXJyO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBbU0RURmllbGQgdHlwZToke3RoaXMuX3R5cGV9IHZhbHVlOiR7dGhpcy5fdmFsdWV9XWA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFNEVEZpZWxkIGluc3RhbmNlIHJlcHJlc2VudGluZyBhIFZhbHVlIG9mIGEgZ2l2ZW4gVHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuU0RURmllbGRUeXBlfSB0eXBlIFRoZSB0eXBlIG9mIGZpZWxkIHJlcHJlc2VudGVkLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHRvIHN0b3JlIGluIHRoZSBmaWVsZC5cbiAgICogQHJldHVybnMge3NvbGFjZS5TRFRGaWVsZH0gVGhlIG5ldyBTRFQgZmllbGQgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgdmFsdWVcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBpZiB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0eXBlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUodHlwZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFNEVEZpZWxkKHR5cGUsIHZhbHVlKTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLlNEVEZpZWxkID0gU0RURmllbGQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1maWVsZC5qcyIsImNvbnN0IHsgQWRQcm90b2NvbE1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4vYWRwcm90b2NvbC1tZXNzYWdlJyk7XG5jb25zdCB7IEJpbmFyeU1ldGFCbG9jayB9ID0gcmVxdWlyZSgnLi9iaW5hcnktbWV0YS1ibG9jaycpO1xuY29uc3QgeyBDbGllbnRDdHJsTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9jbGllbnQtY3RybC1tZXNzYWdlJyk7XG5jb25zdCB7IEtlZXBBbGl2ZU1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4va2VlcC1hbGl2ZS1tZXNzYWdlJyk7XG5jb25zdCB7IFNNRkhlYWRlciB9ID0gcmVxdWlyZSgnLi9zbWYtaGVhZGVyJyk7XG5jb25zdCB7IFNNRlBhcmFtZXRlciB9ID0gcmVxdWlyZSgnLi9zbWYtcGFyYW1ldGVyJyk7XG5jb25zdCB7IFNNRlVIIH0gPSByZXF1aXJlKCcuL3NtZi11aCcpO1xuY29uc3QgeyBTTVBNZXNzYWdlIH0gPSByZXF1aXJlKCcuL3NtcC1tZXNzYWdlJyk7XG5jb25zdCB7IFRyYW5zcG9ydFNNRk1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LXNtZi1tZXNzYWdlJyk7XG5cbm1vZHVsZS5leHBvcnRzLkFkUHJvdG9jb2xNZXNzYWdlID0gQWRQcm90b2NvbE1lc3NhZ2U7XG5tb2R1bGUuZXhwb3J0cy5CaW5hcnlNZXRhQmxvY2sgPSBCaW5hcnlNZXRhQmxvY2s7XG5tb2R1bGUuZXhwb3J0cy5DbGllbnRDdHJsTWVzc2FnZSA9IENsaWVudEN0cmxNZXNzYWdlO1xubW9kdWxlLmV4cG9ydHMuS2VlcEFsaXZlTWVzc2FnZSA9IEtlZXBBbGl2ZU1lc3NhZ2U7XG5tb2R1bGUuZXhwb3J0cy5TTUZIZWFkZXIgPSBTTUZIZWFkZXI7XG5tb2R1bGUuZXhwb3J0cy5TTUZQYXJhbWV0ZXIgPSBTTUZQYXJhbWV0ZXI7XG5tb2R1bGUuZXhwb3J0cy5TTUZVSCA9IFNNRlVIO1xubW9kdWxlLmV4cG9ydHMuU01QTWVzc2FnZSA9IFNNUE1lc3NhZ2U7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRTTUZNZXNzYWdlID0gVHJhbnNwb3J0U01GTWVzc2FnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2FwaS5qcyIsImNvbnN0IHsgRGVidWcgfSA9IHJlcXVpcmUoJy4vbGliL2RlYnVnJyk7XG5cbm1vZHVsZS5leHBvcnRzLkRlYnVnID0gRGVidWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1kZWJ1Zy9hcGkuanMiLCIvKipcbiAqIEBtb2R1bGUgc29sYWNlL2ZzbVxuICovXG5cbmNvbnN0IHsgRnNtRXZlbnQgfSA9IHJlcXVpcmUoJy4vbGliL2V2ZW50Jyk7XG5jb25zdCB7IFN0YXRlIH0gPSByZXF1aXJlKCcuL2xpYi9zdGF0ZScpO1xuY29uc3QgeyBTdGF0ZU1hY2hpbmUgfSA9IHJlcXVpcmUoJy4vbGliL3N0YXRlLW1hY2hpbmUnKTtcblxubW9kdWxlLmV4cG9ydHMuRnNtRXZlbnQgPSBGc21FdmVudDtcbm1vZHVsZS5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG5tb2R1bGUuZXhwb3J0cy5TdGF0ZU1hY2hpbmUgPSBTdGF0ZU1hY2hpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vYXBpLmpzIiwiY29uc3QgeyBNZXNzYWdlIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlJyk7XG5jb25zdCB7IE1lc3NhZ2VDYWNoZVN0YXR1cyB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1jYWNoZS1zdGF0dXMnKTtcbmNvbnN0IHsgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtZGVsaXZlcnktbW9kZS10eXBlcycpO1xuY29uc3QgeyBNZXNzYWdlRHVtcEZsYWcgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtZHVtcC1mbGFncycpO1xuY29uc3QgeyBNZXNzYWdlRHVtcFN0YW5kYXJkUHJvdmlkZXIgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtZHVtcC1zdGFuZGFyZC1wcm92aWRlcicpO1xuY29uc3QgeyBNZXNzYWdlRHVtcFV0aWwgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtZHVtcC11dGlsJyk7XG5jb25zdCB7IE1lc3NhZ2VUeXBlIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLXR5cGVzJyk7XG5jb25zdCB7IE1lc3NhZ2VVc2VyQ29zVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS11c2VyLWNvcy10eXBlcycpO1xuXG5jb25zdCB7IFNvbGNsaWVudEZhY3RvcnkgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBzb2xhY2UuTWVzc2FnZX0gaW5zdGFuY2UuXG4gKiBAcmV0dXJucyB7c29sYWNlLk1lc3NhZ2V9IGEgbmV3IG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVNZXNzYWdlXG4gKi9cblNvbGNsaWVudEZhY3RvcnkuY3JlYXRlTWVzc2FnZSA9IFNvbGNsaWVudEZhY3RvcnkuY3JlYXRlRmFjdG9yeSgoKSA9PiBuZXcgTWVzc2FnZSgpKTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2U7XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlQ2FjaGVTdGF0dXMgPSBNZXNzYWdlQ2FjaGVTdGF0dXM7XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZSA9IE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUR1bXBGbGFnID0gTWVzc2FnZUR1bXBGbGFnO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUR1bXBTdGFuZGFyZFByb3ZpZGVyID0gTWVzc2FnZUR1bXBTdGFuZGFyZFByb3ZpZGVyO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUR1bXBVdGlsID0gTWVzc2FnZUR1bXBVdGlsO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVR5cGUgPSBNZXNzYWdlVHlwZTtcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VVc2VyQ29zVHlwZSA9IE1lc3NhZ2VVc2VyQ29zVHlwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UvYXBpLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgVHJhbnNwb3J0UmV0dXJuQ29kZSA9IHtcbiAgT0s6ICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICBGQUlMOiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gIE5PX1NQQUNFOiAgICAgICAgICAgICAgICAgICAgMixcbiAgREFUQV9ERUNPREVfRVJST1I6ICAgICAgICAgICAzLFxuICBJTlZBTElEX1NUQVRFX0ZPUl9PUEVSQVRJT046IDQsXG4gIENPTk5FQ1RJT05fRVJST1I6ICAgICAgICAgICAgNSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFJldHVybkNvZGUgPSBFbnVtLm5ldyhUcmFuc3BvcnRSZXR1cm5Db2RlKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIE1hbnVhbGx5IGRlbWFuZ2xlIHRoZXNlIG5hbWVzOyBidWcgNzAwMzFcbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFJldHVybkNvZGUuX3NldENhbm9uaWNhbCh7XG4gICdPSyc6ICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LLFxuICAnRkFJTCc6ICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0UmV0dXJuQ29kZS5GQUlMLFxuICAnTk9fU1BBQ0UnOiAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0UmV0dXJuQ29kZS5OT19TUEFDRSxcbiAgJ0RBVEFfREVDT0RFX0VSUk9SJzogICAgICAgICAgIFRyYW5zcG9ydFJldHVybkNvZGUuREFUQV9ERUNPREVfRVJST1IsXG4gICdJTlZBTElEX1NUQVRFX0ZPUl9PUEVSQVRJT04nOiBUcmFuc3BvcnRSZXR1cm5Db2RlLklOVkFMSURfU1RBVEVfRk9SX09QRVJBVElPTixcbiAgJ0NPTk5FQ1RJT05fRVJSUk9SJzogICAgICAgICAgIFRyYW5zcG9ydFJldHVybkNvZGUuQ09OTkVDVElPTl9FUlJPUlxufSk7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1yZXR1cm4tY29kZXMuanMiLCJjb25zdCB7IEFic3RyYWN0UXVldWVEZXNjcmlwdG9yIH0gPSByZXF1aXJlKCcuL2xpYi9hYnN0cmFjdC1xdWV1ZS1kZXNjcmlwdG9yJyk7XG5jb25zdCB7IFF1ZXVlQWNjZXNzVHlwZSB9ID0gcmVxdWlyZSgnLi9saWIvcXVldWUtYWNjZXNzLXR5cGVzJyk7XG5jb25zdCB7IFF1ZXVlRGVzY3JpcHRvciB9ID0gcmVxdWlyZSgnLi9saWIvcXVldWUtZGVzY3JpcHRvcicpO1xuY29uc3QgeyBRdWV1ZURlc2NyaXB0b3JWYWxpZGF0b3IgfSA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlLWRlc2NyaXB0b3ItdmFsaWRhdG9yJyk7XG5jb25zdCB7IFF1ZXVlRGlzY2FyZEJlaGF2aW9yIH0gPSByZXF1aXJlKCcuL2xpYi9xdWV1ZS1kaXNjYXJkLWJlaGF2aW9ycycpO1xuY29uc3QgeyBRdWV1ZVBlcm1pc3Npb25zIH0gPSByZXF1aXJlKCcuL2xpYi9xdWV1ZS1wZXJtaXNzaW9ucycpO1xuY29uc3QgeyBRdWV1ZVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlLXByb3BlcnRpZXMnKTtcbmNvbnN0IHsgUXVldWVQcm9wZXJ0aWVzVmFsaWRhdG9yIH0gPSByZXF1aXJlKCcuL2xpYi9xdWV1ZS1wcm9wZXJ0aWVzLXZhbGlkYXRvcicpO1xuY29uc3QgeyBRdWV1ZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlLXR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yID0gQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3I7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZUFjY2Vzc1R5cGUgPSBRdWV1ZUFjY2Vzc1R5cGU7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlc2NyaXB0b3IgPSBRdWV1ZURlc2NyaXB0b3I7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlc2NyaXB0b3JWYWxpZGF0b3IgPSBRdWV1ZURlc2NyaXB0b3JWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURpc2NhcmRCZWhhdmlvciA9IFF1ZXVlRGlzY2FyZEJlaGF2aW9yO1xubW9kdWxlLmV4cG9ydHMuUXVldWVQZXJtaXNzaW9ucyA9IFF1ZXVlUGVybWlzc2lvbnM7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVByb3BlcnRpZXMgPSBRdWV1ZVByb3BlcnRpZXM7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVByb3BlcnRpZXNWYWxpZGF0b3IgPSBRdWV1ZVByb3BlcnRpZXNWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVR5cGUgPSBRdWV1ZVR5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1xdWV1ZS9hcGkuanMiLCJjb25zdCB7IFN0YXRzIH0gPSByZXF1aXJlKCcuL2xpYi9zdGF0cy5qcycpO1xuY29uc3QgeyBTdGF0c0J5TW9kZSB9ID0gcmVxdWlyZSgnLi9saWIvc3RhdC1ieW1vZGUnKTtcbmNvbnN0IHsgU3RhdFR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL3N0YXQtdHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0YXRzLFxuICBTdGF0VHlwZSxcbiAgU3RhdHNCeU1vZGUsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc3RhdHMvYXBpLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIHNjaGVtZSB0eXBlcyByZWZlcmVuY2VkIGJ5IHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdHJhbnNwb3J0UHJvdG9jb2x9LFxuICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN3ZWJUcmFuc3BvcnRQcm90b2NvbExpc3R9IChicm93c2VyIG9ubHkpLCBhbmRcbiAqIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdHJhbnNwb3J0UHJvdG9jb2xJblVzZX0uXG4gKlxuICogQHRhcmdldCBicm93c2VyXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBUcmFuc3BvcnRQcm90b2NvbCA9IHtcblxuICAvKipcbiAgICogQSBDT01FVCBtb2RlbCB0aGF0IHVzZXMgYmFzZTY0IHBheWxvYWQgZW5jb2RpbmcuIEhUVFAgcmVzcG9uc2VzIGhhdmUgYSBkZWZpbmVkIENvbnRlbnQtTGVuZ3RoLlxuICAgKlxuICAgKiBHdWFyYW50ZWVkIE1lc3NhZ2luZyBpcyBpbmNvbXBhdGJpbGUgd2l0aCBIVFRQXyB0cmFuc3BvcnRzLlxuICAgKiAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzI2VuYWJsZWR9IG11c3QgYmUgYGZhbHNlYCBmb3IgYSBzZXNzaW9uIHRoYXQgbWF5XG4gICAqICAgIHVzZSB0aGlzIHRyYW5zcG9ydCBwcm90b2NvbC5cbiAgICogICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uI2NyZWF0ZU1lc3NhZ2VDb25zdW1lcn0gd2lsbCB0aHJvdyBvbiBhIHNlc3Npb24gdGhhdCBtYXkgdXNlIHRoaXNcbiAgICogICAgdHJhbnNwb3J0IHByb3RvY29sIGlmIHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMjZW5hYmxlZH0gaXMgYHRydWVgLlxuICAgKlxuICAgKiBAdGFyZ2V0IGJyb3dzZXJcbiAgICovXG4gIEhUVFBfQkFTRTY0OiAnSFRUUF9CQVNFNjQnLFxuXG4gIC8qKlxuICAgKiBBIENPTUVUIG1vZGVsIHRoYXQgdXNlcyBiaW5hcnkgcGF5bG9hZCBlbmNvZGluZy4gSFRUUCByZXNwb25zZXMgaGF2ZSBhIGRlZmluZWQgQ29udGVudC1MZW5ndGguXG4gICAqXG4gICAqIEd1YXJhbnRlZWQgTWVzc2FnaW5nIGlzIGluY29tcGF0YmlsZSB3aXRoIEhUVFBfIHRyYW5zcG9ydHMuXG4gICAqICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMjZW5hYmxlZH0gbXVzdCBiZSBgZmFsc2VgIGZvciBhIHNlc3Npb24gdGhhdCBtYXlcbiAgICogICAgdXNlIHRoaXMgdHJhbnNwb3J0IHByb3RvY29sLlxuICAgKiAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlTWVzc2FnZUNvbnN1bWVyfSB3aWxsIHRocm93IG9uIGEgc2Vzc2lvbiB0aGF0IG1heSB1c2UgdGhpc1xuICAgKiAgICB0cmFuc3BvcnQgcHJvdG9jb2wgaWYge0BsaW5rIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyNlbmFibGVkfSBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgSFRUUF9CSU5BUlk6ICdIVFRQX0JJTkFSWScsXG5cbiAgLyoqXG4gICAqIEEgQ09NRVQgbW9kZWwgdGhhdCB1c2VzIGJpbmFyeSBwYXlsb2FkIGVuY29kaW5nLiBIVFRQIHJlc3BvbnNlcyB1c2UgQ2h1bmtlZCBUcmFuc2Zlci1FbmNvZGluZ1xuICAgKiB0byBzdHJlYW0gZGF0YSBmcm9tIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgdG8gdGhlIGNsaWVudCB3aXRob3V0IG5lZWRpbmcgdG8gdGVybWluYXRlIHRoZVxuICAgKiBIVFRQIHJlc3BvbnNlLlxuICAgKlxuICAgKiBHdWFyYW50ZWVkIE1lc3NhZ2luZyBpcyBpbmNvbXBhdGJpbGUgd2l0aCBIVFRQXyB0cmFuc3BvcnRzLlxuICAgKiAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzI2VuYWJsZWR9IG11c3QgYmUgYGZhbHNlYCBmb3IgYSBzZXNzaW9uIHRoYXQgbWF5XG4gICAqICAgIHVzZSB0aGlzIHRyYW5zcG9ydCBwcm90b2NvbC5cbiAgICogICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uI2NyZWF0ZU1lc3NhZ2VDb25zdW1lcn0gd2lsbCB0aHJvdyBvbiBhIHNlc3Npb24gdGhhdCBtYXkgdXNlIHRoaXNcbiAgICogICAgdHJhbnNwb3J0IHByb3RvY29sIGlmIHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMjZW5hYmxlZH0gaXMgYHRydWVgLlxuICAgKlxuICAgKiBAdGFyZ2V0IGJyb3dzZXJcbiAgICovXG4gIEhUVFBfQklOQVJZX1NUUkVBTUlORzogJ0hUVFBfQklOQVJZX1NUUkVBTUlORycsXG5cbiAgLyoqXG4gICAqIEEgV2ViU29ja2V0IGNvbW11bmljYXRpb24gY2hhbm5lbCB1c2VzIGJpbmFyeSBwYXlsb2FkIGVuY29kaW5nIGFuZCBwcm92aWRlcyBmdWxsLWR1cGxleFxuICAgKiBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIGNsaWVudCBhbmQgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBvdmVyIGEgc2luZ2xlIFRDUCBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBwcmVmZXJyZWQgcHJvdG9jb2wgdG8gdXNlIGlmIGFsbCBuZXR3b3JraW5nIGluZnJhc3RydWN0dXJlIGJldHdlZWQgdGhlIGFwcGxpY2F0aW9uXG4gICAqIGFuZCB0aGUgU29sYWNlIE1lc3NhZ2Ugcm91dGVyIHN1cHBvcnQgV2ViU29ja2V0cy4gSWYgdGhpcyBpcyBub3QgdGhlIGNhc2UsIGl0IG1heSBiZSBuZWNlc3NhcnlcbiAgICogdG8gdXNlIG9uZSBvZiB0aGUgSFRUUCBwcm90b2NvbHMgdGhhdCB1c2UgdGhlIENPTUVUIG1vZGVsIG9mIG1lc3NhZ2luZy5cbiAgICpcbiAgICogVGhpcyB0cmFuc3BvcnQgcHJvdG9jb2wgc3VwcG9ydHMgR3VhcmFudGVlZCBNZXNzYWdpbmcuXG4gICAqL1xuICBXU19CSU5BUlk6ICdXU19CSU5BUlknLFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRQcm90b2NvbCA9IEVudW0ubmV3KFRyYW5zcG9ydFByb3RvY29sKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXByb3RvY29scy5qcyIsImNvbnN0IHsgQXV0aGVudGljYXRpb25TY2hlbWUgfSA9IHJlcXVpcmUoJy4vbGliL2F1dGhlbnRpY2F0aW9uLXNjaGVtZXMnKTtcbmNvbnN0IHsgQ2FwYWJpbGl0eVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL2NhcGFiaWxpdHktdHlwZXMnKTtcbmNvbnN0IHsgTWVzc2FnZVJ4Q0JJbmZvIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLXJ4LWNiLWluZm8nKTtcbmNvbnN0IHsgTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi9saWIvbXV0YWJsZS1zZXNzaW9uLXByb3BlcnRpZXMnKTtcbmNvbnN0IHsgU2Vzc2lvbiB9ID0gcmVxdWlyZSgnLi9saWIvc2Vzc2lvbicpO1xuY29uc3QgeyBTZXNzaW9uRXZlbnQgfSA9IHJlcXVpcmUoJy4vbGliL3Nlc3Npb24tZXZlbnQnKTtcbmNvbnN0IHsgU2Vzc2lvbkV2ZW50Q0JJbmZvIH0gPSByZXF1aXJlKCcuL2xpYi9zZXNzaW9uLWV2ZW50LWNiLWluZm8nKTtcbmNvbnN0IHsgU2Vzc2lvbkV2ZW50Q29kZSB9ID0gcmVxdWlyZSgnLi9saWIvc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBTZXNzaW9uRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL2xpYi9zZXNzaW9uLWV2ZW50LW5hbWVzJyk7XG5jb25zdCB7IFNlc3Npb25Qcm9wZXJ0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi9zZXNzaW9uLXByb3BlcnRpZXMnKTtcbmNvbnN0IHsgU2Vzc2lvblN0YXRlIH0gPSByZXF1aXJlKCcuL2xpYi9zZXNzaW9uLXN0YXRlcycpO1xuXG5jb25zdCB7IFNvbGNsaWVudEZhY3RvcnkgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlc3Npb24gaW5zdGFuY2UuXG4gKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uUHJvcGVydGllc30gc2Vzc2lvblByb3BlcnRpZXMgUHJvcGVydGllcyB0byBjb25maWd1cmUgdGhlIHNlc3Npb24uXG4gKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlUnhDQkluZm99IFttZXNzYWdlQ2FsbGJhY2tJbmZvXSA8Yj5EZXByZWNhdGVkOjwvYj5cbiAqICAgIENhbGxiYWNrIG1ldGhvZCBmb3IgbWVzc2FnZXMuICBJbnN0ZWFkIGFwcGxpY2F0aW9ucyBzaG91bGQgcmVjZWl2ZSBtZXNzYWdlIGV2ZW50cyB2aWFcbiAqICAgIGBzZXNzaW9uLm9uKHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLk1FU1NBR0UsIChtZXNzYWdlKSA9PiB7IC4uLiB9KTtgXG4gKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uRXZlbnRDQkluZm99IFtldmVudENhbGxiYWNrSW5mb10gPGI+RGVwcmVjYXRlZDo8L2I+IENhbGxiYWNrIG1ldGhvZCBmb3JcbiAqICAgIGV2ZW50cyBvbiB0aGUgPGk+U2Vzc2lvbjwvaT4uIEluc3RhZWFkIGFwcGxpY2F0aW9ucyBzaG91bGQgcmVjZWl2ZSBzZXNzaW9uIGV2ZW50cyB2aWFcbiAqICAgIGBzZXNzaW9uLm9uKHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLjxjb2RlPiwgKGV2ZW50KSA9PiB7IC4uLiB9KTtgXG4gKiBAcmV0dXJucyB7c29sYWNlLlNlc3Npb259IFRoZSBuZXdseS1jcmVhdGVkIHNlc3Npb24uXG4gKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB0eXBlIG9yIHZhbHVlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFN1YmNvZGU6IHtAbGluayBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVTZXNzaW9uXG4gKi9cblNvbGNsaWVudEZhY3RvcnkuY3JlYXRlU2Vzc2lvbiA9IFNvbGNsaWVudEZhY3RvcnkuY3JlYXRlRmFjdG9yeShcbiAgKHNlc3Npb25Qcm9wZXJ0aWVzLCBtZXNzYWdlQ2FsbGJhY2tJbmZvLCBldmVudENhbGxiYWNrSW5mbykgPT5cbiAgICBuZXcgU2Vzc2lvbihzZXNzaW9uUHJvcGVydGllcywgbWVzc2FnZUNhbGxiYWNrSW5mbywgZXZlbnRDYWxsYmFja0luZm8pKTtcblxubW9kdWxlLmV4cG9ydHMuQXV0aGVudGljYXRpb25TY2hlbWUgPSBBdXRoZW50aWNhdGlvblNjaGVtZTtcbm1vZHVsZS5leHBvcnRzLkNhcGFiaWxpdHlUeXBlID0gQ2FwYWJpbGl0eVR5cGU7XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlUnhDQkluZm8gPSBNZXNzYWdlUnhDQkluZm87XG5tb2R1bGUuZXhwb3J0cy5NdXRhYmxlU2Vzc2lvblByb3BlcnR5ID0gTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xubW9kdWxlLmV4cG9ydHMuU2Vzc2lvbkV2ZW50Q0JJbmZvID0gU2Vzc2lvbkV2ZW50Q0JJbmZvO1xubW9kdWxlLmV4cG9ydHMuU2Vzc2lvbkV2ZW50Q29kZSA9IFNlc3Npb25FdmVudENvZGU7XG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uRXZlbnROYW1lID0gU2Vzc2lvbkV2ZW50TmFtZTtcbm1vZHVsZS5leHBvcnRzLlNlc3Npb25Qcm9wZXJ0aWVzID0gU2Vzc2lvblByb3BlcnRpZXM7XG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uU3RhdGUgPSBTZXNzaW9uU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2FwaS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogU01GUHJvdG9jb2xcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTTUZQcm90b2NvbCA9IHtcbiAgQ1NQRjogICAgICAgICAgICAgICAweDAxLFxuICBDU01QOiAgICAgICAgICAgICAgIDB4MDIsXG4gIFBVQk1TRzogICAgICAgICAgICAgMHgwMyxcbiAgWE1MTElOSzogICAgICAgICAgICAweDA0LFxuICBXU0U6ICAgICAgICAgICAgICAgIDB4MDUsXG4gIFNFTVA6ICAgICAgICAgICAgICAgMHgwNixcbiAgU1VCQ1RSTDogICAgICAgICAgICAweDA3LFxuICBQVUJDVFJMOiAgICAgICAgICAgIDB4MDgsXG4gIEFEQ1RSTDogICAgICAgICAgICAgMHgwOSxcbiAgS0VFUEFMSVZFOiAgICAgICAgICAweDBhLFxuICBLRUVQQUxJVkVWMjogICAgICAgIDB4MGIsXG4gIENMSUVOVENUUkw6ICAgICAgICAgMHgwYyxcbiAgVFJNU0c6ICAgICAgICAgICAgICAweDBkLFxuICBKTkRJOiAgICAgICAgICAgICAgIDB4MGUsXG4gIFNNUDogICAgICAgICAgICAgICAgMHgwZixcbiAgU01SUDogICAgICAgICAgICAgICAweDEwLFxuICBTTUZfSU5fU01GOiAgICAgICAgIDB4MTEsXG4gIFNNRl9JTl9SVjogICAgICAgICAgMHgxMixcbiAgQURDVFJMX1BBU1NUSFJPVUdIOiAweDEzLFxuICBUU0VTU0lPTjogICAgICAgICAgIDB4MTQsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRlByb3RvY29sID0gRW51bS5uZXcoU01GUHJvdG9jb2wpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtcHJvdG9jb2xzLmpzIiwiY29uc3QgeyBTTUZDbGllbnQgfSA9IHJlcXVpcmUoJy4vbGliL3NtZi1jbGllbnQnKTtcbmNvbnN0IHsgVHJhbnNwb3J0Q2FwYWJpbGl0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQtY2FwYWJpbGl0aWVzJyk7XG5jb25zdCB7IFRyYW5zcG9ydEVycm9yIH0gPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQtZXJyb3InKTtcbmNvbnN0IHsgVHJhbnNwb3J0RmFjdG9yeSB9ID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0LWZhY3RvcnknKTtcbmNvbnN0IHsgVHJhbnNwb3J0UHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0UmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0LXJldHVybi1jb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uU3RhdGVzIH0gPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQtc2Vzc2lvbi1zdGF0ZXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cy5TTUZDbGllbnQgPSBTTUZDbGllbnQ7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRDYXBhYmlsaXRpZXMgPSBUcmFuc3BvcnRDYXBhYmlsaXRpZXM7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRFcnJvciA9IFRyYW5zcG9ydEVycm9yO1xubW9kdWxlLmV4cG9ydHMuVHJhbnNwb3J0RmFjdG9yeSA9IFRyYW5zcG9ydEZhY3Rvcnk7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRQcm90b2NvbCA9IFRyYW5zcG9ydFByb3RvY29sO1xubW9kdWxlLmV4cG9ydHMuVHJhbnNwb3J0UmV0dXJuQ29kZSA9IFRyYW5zcG9ydFJldHVybkNvZGU7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlID0gVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZTtcbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFNlc3Npb25TdGF0ZXMgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2FwaS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgcG9zc2libGUgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50IGNvZGVzLlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUgPSB7XG4gIC8vIFJhaXNlZCB3aGVuIFRyYW5zcG9ydFNlc3Npb24gaXMgdXAgYW5kIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBkYXRhXG4gIFVQX05PVElDRTogICAgICAgICAgIDEsXG4gIC8vIFJhaXNlZCBpZiB0aGUgc2Vzc2lvbiBpcyBkZXN0cm95ZWRcbiAgREVTVFJPWUVEX05PVElDRTogICAgMixcbiAgLy8gUmFpc2VkIHdoZW4gdGhlIHNlbmQgcXVldWUgaGFkIHJlYWNoZWQgaXRzIG1heGltdW0sIGJ1dCBub3cgaGFzIHNwYWNlIGFnYWluXG4gIENBTl9BQ0NFUFRfREFUQTogICAgIDQsXG4gIC8vIFJhaXNlZCB3aGVuIHRoZXJlIGlzIGEgZGVjb2RlIGVycm9yIG9uIHJlY2VpdmVkIGRhdGEuICBUaGUgYXBwIHNob3VsZCBkZXN0cm95IHRoZSBzZXNzaW9uXG4gIERBVEFfREVDT0RFX0VSUk9SOiAgIDUsXG4gIC8vIFJhaXNlZCB3aGVuIHRoZXJlIGlzIGEgZGVjb2RlIGVycm9yIG9uIHJlY2VpdmVkIGRhdGEuICBUaGUgYXBwIHNob3VsZCBkZXN0cm95IHRoZSBzZXNzaW9uXG4gIFBBUlNFX0ZBSUxVUkU6ICAgICAgIDYsXG4gIC8vIFJhaXNlZCB3aGVuIHRoZSBjb25uZWN0aW9uIHRpbWVzIG91dC4gVGhlIGFwcCBzaG91bGQgYXR0ZW1wdCBkb3duZ3JhZGUgaWYgYXZhaWxhYmxlLlxuICBDT05ORUNUX1RJTUVPVVQ6ICAgICA3LFxuICAvLyBUaGVyZSB3YXMgYW4gZXJyb3Igc2VuZGluZyBhIG1lc3NhZ2Ugb24gYW4gZXRhYmxpc2hlZCB0cmFuc3BvcnRcbiAgU0VORF9FUlJPUjogICAgICAgICAgOCxcbiAgLy8gVGhlIHJlcXVlc3RlZCBkb3duZ3JhZGUgd2FzIHJlamVjdGVkLlxuICBET1dOR1JBREVfRkFJTEVEOiAgICAxMCxcbiAgLy8gVGhlIHJlcXVlc3RlZCBkb3duZ3JhZGUgY29tcGxldGVkLlxuICBET1dOR1JBREVfU1VDQ0VFREVEOiAxMSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUgPSBFbnVtLm5ldyhUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXNlc3Npb24tZXZlbnQtY29kZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEVudW1lcmF0ZXMgZGVzdGluYXRpb24gdHlwZXMgZm9yIGRlc3RpbmF0aW9uIG9iamVjdHMuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgRGVzdGluYXRpb25UeXBlID0ge1xuICAvKipcbiAgICogQSBUb3BpYyBkZXN0aW5hdGlvbi5cbiAgICovXG4gIFRPUElDOiAgICAgICAgICAgJ3RvcGljJyxcbiAgLyoqXG4gICAqIEEgcXVldWUgZGVzdGluYXRpb24uXG4gICAqL1xuICBRVUVVRTogICAgICAgICAgICdxdWV1ZScsXG4gIC8qKlxuICAgKiBBIHRlbXBvcmFyeSBxdWV1ZSBkZXN0aW5hdGlvbi5cbiAgICovXG4gIFRFTVBPUkFSWV9RVUVVRTogJ3RlbXBvcmFyeV9xdWV1ZScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5EZXN0aW5hdGlvblR5cGUgPSBFbnVtLm5ldyhEZXN0aW5hdGlvblR5cGUpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gTWFudWFsbHkgZGVtYW5nbGUgdGhlc2UgbmFtZXM7IGJ1ZyA3MDEzMVxubW9kdWxlLmV4cG9ydHMuRGVzdGluYXRpb25UeXBlLl9zZXRDYW5vbmljYWwoe1xuICAnVE9QSUMnOiAgICAgICAgICAgRGVzdGluYXRpb25UeXBlLlRPUElDLFxuICAnUVVFVUUnOiAgICAgICAgICAgRGVzdGluYXRpb25UeXBlLlFVRVVFLFxuICAnVEVNUE9SQVJZX1FVRVVFJzogRGVzdGluYXRpb25UeXBlLlRFTVBPUkFSWV9RVUVVRVxufSk7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1kZXN0aW5hdGlvbi9saWIvZGVzdGluYXRpb24tdHlwZS5qcyIsImNvbnN0IFNvbGNsaWVudEZhY3RvcnlMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZmFjdG9yeScpO1xuY29uc3QgeyBDb252ZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuY29uc3QgeyBEZXN0aW5hdGlvblR5cGUgfSA9IHJlcXVpcmUoJy4vZGVzdGluYXRpb24tdHlwZScpO1xuY29uc3QgeyBMT0dfRVJST1IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgVVVJRCwgU3RyaW5nVXRpbHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5cbmNvbnN0IHsgdWNzMlRvVXRmOCwgdXRmOFRvVWNzMiB9ID0gQ29udmVydDtcbmNvbnN0IHsgUHJvZmlsZUJpbmRpbmcgfSA9IFNvbGNsaWVudEZhY3RvcnlMaWI7XG5cbmNvbnN0IHsgdG9TYWZlQ2hhcnMsIHN0cmlwTnVsbFRlcm1pbmF0ZSB9ID0gU3RyaW5nVXRpbHM7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuXG5jb25zdCBERVNUSU5BVElPTl9QUkVGSVhfRlJPTV9UWVBFID0ge1xuICBbRGVzdGluYXRpb25UeXBlLlFVRVVFXTogICAgICAgICAgICcjUDJQL1FVRS8nLFxuICBbRGVzdGluYXRpb25UeXBlLlRFTVBPUkFSWV9RVUVVRV06ICcjUDJQL1FUTVAvJyxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBvcmFyeU5hbWUodHlwZSwgdnJpZCwgbmFtZSkge1xuICBjb25zdCBpZCA9IG5hbWUgfHwgVVVJRC5nZW5lcmF0ZVVVSUQoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBEZXN0aW5hdGlvblR5cGUuVE9QSUM6XG4gICAgICByZXR1cm4gYCNQMlAvVFRNUC8ke3ZyaWR9LyR7aWR9YDtcbiAgICBjYXNlIERlc3RpbmF0aW9uVHlwZS5URU1QT1JBUllfUVVFVUU6XG4gICAgICByZXR1cm4gYCNQMlAvUVRNUC8ke3ZyaWR9LyR7aWR9YDtcbiAgICBkZWZhdWx0OlxuICAgICAgTE9HX0VSUk9SKCdVbmtub3duL2ludmFsaWQgZGVzdGluYXRpb24gdHlwZScsIERlc3RpbmF0aW9uVHlwZS5kZXNjcmliZSh0eXBlKSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJlZml4KHR5cGUpIHtcbiAgcmV0dXJuIERFU1RJTkFUSU9OX1BSRUZJWF9GUk9NX1RZUEVbdHlwZV0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wZXJhdGlvbkVycm9yKHR5cGUsIGVycm9yU3RyKSB7XG4gIHJldHVybiBuZXcgT3BlcmF0aW9uRXJyb3IoYEludmFsaWQgJHt0eXBlfTogJHtlcnJvclN0cn1gLCBFcnJvclN1YmNvZGUuSU5WQUxJRF9UT1BJQ19TWU5UQVgpO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHZhbGlkYXRlcyB0b3BpY3MgaW4gYWxsIGNvZGUgcGF0aHMgLS0gbGVnYWN5IGNvZGUgcGF0aHMgdGhhdCByZWxpZWQgb24gdmFsaWRhdGluZ1xuLy8gdG9waWNzIGFzIHRoZXkgd2VyZSB1c2VkLCBhbmQgbmV3ZXIgY29kZSBwYXRocyB0aGF0IHZhbGlkYXRlIERlc3RpbmF0aW9ucyBvbiBjb25zdHJ1Y3Rpb24uICBXZVxuLy8gbXVzdCBub3QgYWRkIHZhbGlkYXRpb24gaGVyZSB0aGF0IGNvdWxkIGJyZWFrIGxlZ2FjeSBhcHBzIHRoYXQgdXNlZCB0aGUgZGVwcmVjYXRlZCAnbmV3IFRvcGljJ1xuLy8gaW50ZXJmYWNlIHRoYXQgZG9lc24ndCBwZXJmb3JtIHZhbGlkYXRpb24sIGFuZCBzdWJzZXF1ZW50bHkgcmVseSBvbiB2YWxpZGF0ZS1vbi11c2UuXG4vL1xuLy8gTW9yZSBzdHJpY3QgY2hlY2tzIGRvbmUgZHVyaW5nIERlc3RpbmF0aW9uIGNvbnN0cnVjdGlvbiBzaG91bGQgYmUgcGxhY2VkIGluIHZhbGlkYXRlQW5kRW5jb2RlLlxuLy8gQHJldHVybiB7IGVycm9yLCBpc1dpbGRjYXJkZWQgfS4gIGlzV2lsZGNhcmRlZCB3aWxsIG5vdCBiZSBkZWZpbmVkIGlmIGVyb3JyIGlzIGRlZmluZWQuXG5mdW5jdGlvbiBsZWdhY3lWYWxpZGF0ZSh0eXBlLCBieXRlcywgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkNyZWF0b3IgPSBjcmVhdGVPcGVyYXRpb25FcnJvci5iaW5kKG51bGwsIHR5cGUpKSB7XG4gIGxldCBlcnJvcjtcblxuICAvKlxuICAgICogVFJCIHRvcGljcyBjYW4gY29udGFpbiBhbnkgdXRmLTggY2hhcmFjdGVyIGFuZCBtdXN0IGJlIDw9IDI1MCBieXRlc1xuICAgICogaW4gbGVuZ3RoLlxuICAgICogJyonLCBpZiBwcmVzZW50IGluIGEgbGV2ZWwsIG11c3QgYmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoYXQgbGV2ZWwuXG4gICAgKiBNYXkgbm90IGhhdmUgZW1wdHkgbGV2ZWxzLlxuICAgICovXG5cbiAgLy8gQ2hlY2sgbWluaW11bSBsZW5ndGggdXNpbmcgbmFtZSwgc2luY2UgdGhlIGJ5dGVzIG1heSBpbmNsdWRlIGEgZGVzdGluYXRpb24gdHlwZSBwcmVmaXguXG4gIC8vIGUuZy4gI1AyUC9RVUUvIHNob3VsZCBmYWlsIG9uIGxlbmd0aCwgbm90IGVtcHR5IGxldmVsLlxuICBjb25zdCBuYW1lTGVuZ3RoID0gbmFtZS5sZW5ndGg7XG4gIGlmIChuYW1lTGVuZ3RoIDwgMSkge1xuICAgIGVycm9yID0gZXhjZXB0aW9uQ3JlYXRvcignVG9vIHNob3J0IChtdXN0IGJlID49IDEgY2hhcmFjdGVyKS4nKTtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG5cbiAgLy8gQ2hlY2sgbWF4aW11bSBsZW5ndGggdXNpbmcgZW5jb2RlZCBieXRlcywgc2luY2UgVVRGLTggaXMgYSB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBpZiAoYnl0ZXNMZW5ndGggPiAyNTEpIHsgLy8gbnVsbCB0ZXJtaW5hdG9yIGRvZXNuJ3QgY291bnRcbiAgICBlcnJvciA9IGV4Y2VwdGlvbkNyZWF0b3IoYFRvbyBsb25nIChlbmNvZGluZyBtdXN0IGJlIDw9IDI1MCBieXRlcyk7IG5hbWUgaXMgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNMZW5ndGh9IGJ5dGVzOiAnJHtuYW1lfSdgKTtcbiAgICByZXR1cm4geyBlcnJvciB9O1xuICB9XG5cbiAgbGV0IGlzV2lsZGNhcmRlZCA9IGZhbHNlO1xuICBpZiAobmFtZS5jaGFyQXQobmFtZUxlbmd0aCAtIDEpID09PSAnPicpIHtcbiAgICBpc1dpbGRjYXJkZWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lTGVuZ3RoOyArK2kpIHtcbiAgICBzd2l0Y2ggKG5hbWUuY2hhckF0KGkpKSB7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gKG5hbWVMZW5ndGggLSAxKSB8fCBuYW1lLmNoYXJBdChpIC0gMSkgPT09ICcvJykge1xuICAgICAgICAgIGVycm9yID0gZXhjZXB0aW9uQ3JlYXRvcihgRW1wdHkgbGV2ZWwocykgaW4gJyR7bmFtZX0nQCR7aX0uYCk7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKic6XG4gICAgICAgIGlmICgoaSA8IChuYW1lTGVuZ3RoIC0gMSkpICYmIChuYW1lLmNoYXJBdChpICsgMSkgIT09ICcvJykpIHtcbiAgICAgICAgICAvLyBtdXN0IG5vdCBoYXZlIHNvbWV0aGluZyBvdGhlciB0aGFuICcvJyB0byB0aGUgcmlnaHRcbiAgICAgICAgICBlcnJvciA9IGV4Y2VwdGlvbkNyZWF0b3IoYElsbGVnYWwgd2lsZGNhcmQocykgaW4gJyR7bmFtZX0nQCR7aX0uYCk7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzV2lsZGNhcmRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBpc1dpbGRjYXJkZWQgfTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIFByb2ZpbGVCaW5kaW5nLnZhbHVlLnRvcGljVXRmOEVuY29kZVxuICAgID8gYCR7dWNzMlRvVXRmOChieXRlcyl9XFx1MDAwMGBcbiAgICA6IGAke2J5dGVzfVxcdTAwMDBgO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCeXRlcyhieXRlcykge1xuICByZXR1cm4gc3RyaXBOdWxsVGVybWluYXRlKFByb2ZpbGVCaW5kaW5nLnZhbHVlLnRvcGljVXRmOEVuY29kZVxuICAgID8gdXRmOFRvVWNzMihieXRlcylcbiAgICA6IGJ5dGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlc3RpbmF0aW9uVHlwZX0gdHlwZSBUaGUgdHlwZSBvZiBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB7Ynl0ZXMsIG9mZnNldCwgbmV0d29ya05hbWV9IFRoZSByZXN1bHQgb2YgdGhlIGVuY29kaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh0eXBlLCBuYW1lKSB7XG4gIGNvbnN0IHByZWZpeCA9IGNyZWF0ZVByZWZpeCh0eXBlKTtcbiAgY29uc3Qgb2Zmc2V0ID0gcHJlZml4Lmxlbmd0aDtcbiAgY29uc3QgbmV0d29ya05hbWUgPSBwcmVmaXggKyBuYW1lO1xuICBjb25zdCBieXRlcyA9IGVuY29kZUJ5dGVzKG5ldHdvcmtOYW1lKTtcbiAgcmV0dXJuIHsgYnl0ZXMsIG9mZnNldCwgbmV0d29ya05hbWUgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlc3RpbmF0aW9uVHlwZX0gdHlwZSBUaGUgdHlwZSBvZiBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXhjZXB0aW9uQ3JlYXRvcj1jcmVhdGVPcGVyYXRpb25FcnJvcl0gQSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gZXhjZXB0aW9uIGlmIGFuXG4gKiAgIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICogQHJldHVybnMge09iamVjdH0ge2J5dGVzLCBlcnJvciwgb2Zmc2V0LCBpc1dpbGRjYXJkZWR9IFRoZSByZXN1bHQgb2YgdGhlIGVuY29kaW5nIGFuZCBhbnlcbiAqICAgICAgdmFsaWRhdGlvbiBlcnJvclxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kRW5jb2RlKHR5cGUsIG5hbWUsIGV4Y2VwdGlvbkNyZWF0b3IgPSBjcmVhdGVPcGVyYXRpb25FcnJvci5iaW5kKG51bGwsIHR5cGUpKSB7XG4gIGNvbnN0IHsgYnl0ZXMsIG9mZnNldCB9ID0gZW5jb2RlKHR5cGUsIG5hbWUpO1xuICBjb25zdCB7IGVycm9yOiBjb25zdEVycm9yLCBpc1dpbGRjYXJkZWQgfSA9IGxlZ2FjeVZhbGlkYXRlKHR5cGUsIGJ5dGVzLCBuYW1lLCBleGNlcHRpb25DcmVhdG9yKTtcbiAgbGV0IGVycm9yID0gY29uc3RFcnJvcjtcblxuICAvLyBJZiB0aGVyZSB3YXMgbm8gJ2xlZ2FjeScgZXJyb3IsIHBlcmZvcm0gYW4gYWRkaXRpb25hbCBjaGVjayB0byBzZWUgaWYgdGhlIHByb3ZpZGVkIG5hbWUgc3RhcnRzXG4gIC8vIHdpdGggYSByZXNlcnZlZCBwcmVmaXguICBJdCBzaG91bGRuJ3QuICBQcmVmaXhlcyBzaG91bGQgYWx3YXlzIGJlIGFkZGVkIGJ5IHVzIGJ5IGVuY29kZSgpLlxuICBpZiAoIWVycm9yKSB7XG4gICAgT2JqZWN0LmtleXMoREVTVElOQVRJT05fUFJFRklYX0ZST01fVFlQRSkuc29tZSgocHJlZml4VHlwZSkgPT4ge1xuICAgICAgY29uc3QgcHJlZml4ID0gREVTVElOQVRJT05fUFJFRklYX0ZST01fVFlQRVtwcmVmaXhUeXBlXTtcbiAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBrZWVwIHByb2Nlc3NpbmcgbW9yZSBhcnJheSBlbGVtZW50cy5cbiAgICAgIH1cblxuICAgICAgZXJyb3IgPSBleGNlcHRpb25DcmVhdG9yKGBSZXNlcnZlZCBwcmVmaXggJyR7cHJlZml4fScgZm91bmQgYXQgc3RhcnQgb2YgJyR7bmFtZX0nYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7IGJ5dGVzLCBvZmZzZXQsIGVycm9yLCBpc1dpbGRjYXJkZWQgfTtcbn1cblxuY29uc3QgRGVzdGluYXRpb25VdGlsID0ge1xuICBjcmVhdGVQcmVmaXgsXG4gIGNyZWF0ZVRlbXBvcmFyeU5hbWUsXG4gIGRlY29kZUJ5dGVzLFxuICBlbmNvZGUsXG4gIGVuY29kZUJ5dGVzLFxuICBsZWdhY3lWYWxpZGF0ZSxcbiAgdG9TYWZlQ2hhcnMsXG4gIHZhbGlkYXRlQW5kRW5jb2RlLFxufTtcblxubW9kdWxlLmV4cG9ydHMuRGVzdGluYXRpb25VdGlsID0gRGVzdGluYXRpb25VdGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLXV0aWwuanMiLCJjb25zdCB7IEVudHJ5UG9pbnQgfSA9IHJlcXVpcmUoJy4vZW50cnktcG9pbnQnKTtcbmNvbnN0IHsgRXhpdFBvaW50IH0gPSByZXF1aXJlKCcuL2V4aXQtcG9pbnQnKTtcbmNvbnN0IHsgU3RhdGVDb250ZXh0IH0gPSByZXF1aXJlKCcuL3N0YXRlLWNvbnRleHQnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBzdGF0ZSBpbiBhIHN0YXRlIG1hY2hpbmUuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0ZSBleHRlbmRzIFN0YXRlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgT2JqZWN0IHNwZWNpZmllciB1c2VkIHRvIGltcGxlbWVudCB0aGUgbmFtZWQgcGFyYW1ldGVyXG4gICAqICBpZGlvbS4gIEluIGFkZGl0aW9uIHRvIHRoZSBwcm9wZXJ0aWVzIGRvY3VtZW50ZWQgaGVyZSwgaXQgaXMgYWxzbyBleHBlY3RlZFxuICAgKiAgdG8gaGF2ZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIGJ5IHRoZSBbU3RhdGVDb250ZXh0IGJhc2UgY2xhc3Nde0BsaW5rIFN0YXRlQ29udGV4dH0uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlLCB1c2VkIGluIGRlYnVnIGxvZ3MuXG4gICAqIEBwYXJhbSB7U3RhdGV8U3RhdGVNYWNoaW5lfSBzcGVjLnBhcmVudENvbnRleHQgT25lIG9mOlxuICAgKiAgLSBUaGUgcGFyZW50IHN0YXRlIG9iamVjdCBvcjtcbiAgICogIC0gVGhlIHN0YXRlTWFjaGluZSBvYmplY3QgZm9yIHRvcC1sZXZlbCBzdGF0ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQWRkaXRpb25hbCBtZXRob2RzIHRvIGFkZCB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzcGVjLCBleHRlbnNpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHNwZWMpO1xuXG4gICAgY29uc3QgcGFyZW50Q29udGV4dCA9IHNwZWMucGFyZW50Q29udGV4dDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuaW1wbCwge1xuICAgICAgcGFyZW50Q29udGV4dCxcbiAgICAgIHJlYWN0aW9uczogICAgICAgICAgICB7fSxcbiAgICAgIGVudHJ5UG9pbnRzOiAgICAgICAgICB7fSxcbiAgICAgIGV4aXRQb2ludHM6ICAgICAgICAgICB7fSxcbiAgICAgIGFuY2VzdG9yTGlzdDogICAgICAgICBbLi4ucGFyZW50Q29udGV4dC5nZXRBbmNlc3Rvckxpc3QoKSwgdGhpc10sXG4gICAgICBoYW5kbGVVbmhhbmRsZWRFdmVudDogZSA9PiAoXG4gICAgICAgIHBhcmVudENvbnRleHQuaGFuZGxlRXZlbnRcbiAgICAgICAgICA/IHBhcmVudENvbnRleHQuaGFuZGxlRXZlbnQoZSlcbiAgICAgICAgICA6IHBhcmVudENvbnRleHQuaW1wbC5oYW5kbGVVbmhhbmRsZWRFdmVudChlKVxuICAgICAgKSxcbiAgICB9KTtcbiAgICBpZiAocGFyZW50Q29udGV4dCkgdGhpcy5sb2cgPSBwYXJlbnRDb250ZXh0LmxvZy5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRXh0ZW5kIGFuZCBiaW5kIGZ1bmN0aW9uc1xuICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMgfHwge30pLmZvckVhY2goKGspID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNba107XG4gICAgICB0aGlzW2tdID0gdHlwZW9mIGV4dGVuc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IGV4dGVuc2lvbi5iaW5kKHRoaXMpIDogZXh0ZW5zaW9uO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRMb2dQYWRkaW5nKCcgJy5yZXBlYXQodGhpcy5pbXBsLmFuY2VzdG9yTGlzdC5sZW5ndGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJlYWN0aW9uIGZ1bmN0aW9uIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGZ1bmMgaXMgdG8gcmVhY3QgdG8uXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0LnJlYWN0aW9uQ2FsbGJhY2t9IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlblxuICAgKiAgdGhlIHN0YXRlIHByb2Nlc3NlcyBhbiBldmVudCB3aXRoIHRoZSBuYW1lIGV2ZW50TmFtZS4gIFRoZSBmdW5jdGlvbiBpc1xuICAgKiAgYm91bmQgdG8gdGhpcyBvYmplY3Qgc28gdGhhdCB0aGlzIHJlZmVycyB0byB0aGlzIHN0YXRlIG9iamVjdCB3aGVuIGl0XG4gICAqICBpcyBpbnZva2VkLlxuICAgKiBAcmV0dXJucyB7U3RhdGV9IFRoaXMgc3RhdGUgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZWFjdGlvbihldmVudE5hbWUsIGZ1bmMpIHtcbiAgICBpZiAoIWV2ZW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKCdObyBldmVudCBuYW1lIGZvciByZWFjdGlvbicpO1xuICAgIGlmICghZnVuYykgdGhyb3cgbmV3IEVycm9yKGBObyByZWFjdGlvbiBmdW5jdGlvbiBmb3IgcmVhY3Rpb24gJHtldmVudE5hbWV9YCk7XG5cbiAgICB0aGlzLmxvZyhgQWRkaW5nIHJlYWN0aW9uIHRvICR7dGhpc30gZm9yIGV2ZW50ICR7ZXZlbnROYW1lfWApO1xuXG4gICAgaWYgKHRoaXMuaW1wbC5yZWFjdGlvbnNbZXZlbnROYW1lXSkge1xuICAgICAgdGhpcy5sb2coYFJlcGxhY2luZyByZWFjdGlvbiAke3RoaXMuaW1wbC5yZWFjdGlvbnNbZXZlbnROYW1lXX0gd2l0aCAke2Z1bmN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW1wbC5yZWFjdGlvbnNbZXZlbnROYW1lXSA9IGZ1bmMuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZW50cnlQb2ludCBmb3IgdGhpcyBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBlbnRyeVBvaW50IGJlaW5nIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0LnJlYWN0aW9uQ2FsbGJhY2t9IGZ1bmMgVGhlIHJlYWN0aW9uIHRvIGludm9rZSBhZnRlclxuICAgKiAgdGhlIHN0YXRlIGlzIGVudGVyZWQgdmlhIHRoaXMgZW50cnlQb2ludFxuICAgKiBAcmV0dXJucyB7U3RhdGV9IFRoaXMgc3RhdGUgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBlbnRyeVBvaW50KGVudHJ5UG9pbnROYW1lLCBmdW5jKSB7XG4gICAgaWYgKCFlbnRyeVBvaW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKCdObyBlbnRyeSBwb2ludCBuYW1lIGZvciBlbnRyeSBwb2ludCcpO1xuICAgIGlmICghZnVuYykgdGhyb3cgbmV3IEVycm9yKGBObyByZWFjdGlvbiBmdW5jdGlvbiBmb3IgZW50cnkgcG9pbnQgJHtlbnRyeVBvaW50TmFtZX1gKTtcblxuICAgIHRoaXMubG9nKGBBZGRpbmcgZW50cnlQb2ludCAke2VudHJ5UG9pbnROYW1lfSB0byAke3RoaXN9YCk7XG5cbiAgICBpZiAodGhpcy5pbXBsLmVudHJ5UG9pbnRzW2VudHJ5UG9pbnROYW1lXSkge1xuICAgICAgdGhpcy5sb2coYEVudHJ5UG9pbnQgJHtlbnRyeVBvaW50TmFtZX0gYWxyZWFkeSBleGlzdHMgaW4gJHt0aGlzfWApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5pbXBsLmVudHJ5UG9pbnRzW2VudHJ5UG9pbnROYW1lXSA9IG5ldyBFbnRyeVBvaW50KHtcbiAgICAgIHN0YXRlOiB0aGlzLFxuICAgICAgZW50cnlQb2ludE5hbWUsXG4gICAgICBmdW5jLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4aXRQb2ludCBmb3IgdGhpcyBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4aXRQb2ludE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4aXRQb2ludCBiZWluZyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge1N0YXRlQ29udGV4dC5yZWFjdGlvbkNhbGxiYWNrfSBmdW5jIFRoZSByZWFjdGlvbiB0byBpbnZva2UgYWZ0ZXJcbiAgICogIHRoZSBzdGF0ZSBpcyBleGl0ZWQgdmlhIHRoaXMgZXhpdFBvaW50LlxuICAgKiBAcmV0dXJucyB7U3RhdGV9IFRoaXMgc3RhdGUgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqL1xuICBleGl0UG9pbnQoZXhpdFBvaW50TmFtZSwgZnVuYykge1xuICAgIGlmICghZXhpdFBvaW50TmFtZSkgdGhyb3cgbmV3IEVycm9yKCdObyBleGl0IHBvaW50IG5hbWUgZm9yIGVudHJ5IHBvaW50Jyk7XG4gICAgaWYgKCFmdW5jKSB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlYWN0aW9uIGZ1bmN0aW9uIGZvciBleGl0IHBvaW50ICR7ZXhpdFBvaW50TmFtZX1gKTtcblxuICAgIHRoaXMubG9nKGBBZGRpbmcgZXhpdFBvaW50ICR7ZXhpdFBvaW50TmFtZX0gdG8gJHt0aGlzfWApO1xuXG4gICAgaWYgKHRoaXMuaW1wbC5leGl0UG9pbnRzW2V4aXRQb2ludE5hbWVdKSB7XG4gICAgICB0aGlzLmxvZyhgRXhpdFBvaW50ICR7ZXhpdFBvaW50TmFtZX0gYWxyZWFkeSBleGlzdHMgaW4gICR7dGhpc31gKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuaW1wbC5leGl0UG9pbnRzW2V4aXRQb2ludE5hbWVdID0gbmV3IEV4aXRQb2ludCh7XG4gICAgICBzdGF0ZTogdGhpcyxcbiAgICAgIGV4aXRQb2ludE5hbWUsXG4gICAgICBmdW5jLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBlbnRyeSBwb2ludCB0byBiZVxuICAgKiAgICAgIHRyYW5zaXRpb25lZCB0by5cbiAgICogQHJldHVybnMgeyBTdGF0ZUNvbnRleHQgfSBUaGUgc3RhdGUgY29udGV4dCB0byB0cmFuc2l0aW9uIHRvIHdoZW5cbiAgICogICAgICBlbnRlcmluZyB2aWEgdGhlIHN0YXRlJ3MgZW50cnlQb2ludCBuYW1lZCBlbnRyeVBvaW50TmFtZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0RW50cnlQb2ludERlc3RTdGF0ZShlbnRyeVBvaW50TmFtZSkge1xuICAgIGlmICh0aGlzLmltcGwuZW50cnlQb2ludHNbZW50cnlQb2ludE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nKGAke3RoaXN9OiBFbnRyeVBvaW50ICR7ZW50cnlQb2ludE5hbWV9IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW1wbC5lbnRyeVBvaW50c1tlbnRyeVBvaW50TmFtZV0uZ2V0RGVzdFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4aXRQb2ludE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4aXQgcG9pbnQgdG8gYmVcbiAgICogICAgICB0cmFuc2l0aW9uZWQgdG8uXG4gICAqIEByZXR1cm5zIHtTdGF0ZUNvbnRleHR9IFRoZSBzdGF0ZSBjb250ZXh0IHRvIHRyYW5zaXRpb24gdG8gd2hlblxuICAgKiAgICAgIGV4aXRpbmcgdmlhIHRoZSBzdGF0ZSdzIGV4aXRQb2ludCBuYW1lZCBleGl0UG9pbnROYW1lLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRFeGl0UG9pbnREZXN0U3RhdGUoZXhpdFBvaW50TmFtZSkge1xuICAgIGlmICh0aGlzLmltcGwuZXhpdFBvaW50c1tleGl0UG9pbnROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvZyhgJHt0aGlzfTogRXhpdFBvaW50ICR7ZXhpdFBvaW50TmFtZX0gZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbXBsLmV4aXRQb2ludHNbZXhpdFBvaW50TmFtZV0uZ2V0RGVzdFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiAgVGhlIGZ1bmN0aW9uIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0IHNvIHRoYXQgdGhpcyByZWZlcnMgdG8gdGhpc1xuICAgKiAgc3RhdGUgb2JqZWN0IHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICogQHJldHVybnMge1N0YXRlfSBUaGlzIHN0YXRlIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZW50cnkoZnVuYykge1xuICAgIGlmICh0aGlzLmltcGwuYXBwRW50cnlGdW5jKSB7XG4gICAgICB0aGlzLmxvZyhgUmVwbGFjaW5nIGVudHJ5IGZ1bmN0aW9uICR7dGhpcy5pbXBsLmFwcEVudHJ5RnVuY30gd2l0aCAke2Z1bmN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW1wbC5hcHBFbnRyeUZ1bmMgPSBmdW5jLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgZXhpdGVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHN0YXRlIGlzIGV4aXRlZC5cbiAgICogIFRoZSBmdW5jdGlvbiBpcyBib3VuZCB0byB0aGlzIG9iamVjdCBzbyB0aGF0IHRoaXMgcmVmZXJzIHRvIHRoaXNcbiAgICogIHN0YXRlIG9iamVjdCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAqIEByZXR1cm5zIHtTdGF0ZX0gVGhpcyBzdGF0ZSBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGV4aXQoZnVuYykge1xuICAgIGlmICh0aGlzLmltcGwuYXBwRXhpdEZ1bmMpIHtcbiAgICAgIHRoaXMubG9nKGBSZXBsYWNpbmcgZXhpdCBmdW5jdGlvbiAke3RoaXMuaW1wbC5hcHBFeGl0RnVuY30gd2l0aCAke2Z1bmN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW1wbC5hcHBFeGl0RnVuYyA9IGZ1bmMuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIFt0cmFuc2l0aW9uVG9de0BsaW5rIFN0YXRlQ29udGV4dCN0cmFuc2l0aW9uVG99LFxuICAgKiBleGNlcHQgdGhlIG91dGVybW9zdCBzdGF0ZSBpcyBleGl0ZWQgaWYgdGhlIHNvdXJjZSBzdGF0ZSBpcyB3aXRoaW4gdGhlXG4gICAqIGRlc3Qgc3RhdGUgb3IgdmljZSB2ZXJzYS4gIElmIG9uZSBzdGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBvdGhlciwgdGhpc1xuICAgKiBpcyBlcXVpdmFsZW50IHRvIFt0cmFuc2l0aW9uVG9de0BsaW5rIFN0YXRlQ29udGV4dCN0cmFuc2l0aW9uVG99LlxuICAgKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0bzsgaWYgdW5kZWZpbmVkLCBpdCBpc1xuICAgKiAgICAgIGEgc2VsZi10cmFuc2l0aW9uLlxuICAgKiBAcGFyYW0ge1N0YXRlQ29udGV4dC5hY3Rpb25DYWxsYmFja30gW2FjdGlvbl0gT3B0aW9uYWwgVGhlIGFjdGlvbiB0byBwZXJmb3JtIGFzIHBhcnRcbiAgICogICAgICBvZiB0aGUgdHJhbnNpdGlvbiwgaWYgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICovXG4gIGV4dGVybmFsVHJhbnNpdGlvblRvKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdCh7XG4gICAgICBjYWxsZXI6ICAgIHRoaXMsXG4gICAgICBkZXN0U3RhdGU6IHN0YXRlLFxuICAgICAgYWN0aW9uLFxuICAgICAgZXh0ZXJuYWw6ICB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgc2ltaWxhciB0byBbdHJhbnNpdGlvblRvXXtAbGluayBTdGF0ZUNvbnRleHQjdHJhbnNpdGlvblRvfSwgZXhjZXB0XG4gICAqIHRoYXQgdGhpcyBpcyBhIHRyYW5zaXRpb24gdG8gYSBuYW1lZCBlbnRyeVBvaW50IGNyZWF0ZWQgb24gc3RhdGUuICBJZiB0aGVcbiAgICogbmFtZWQgZW50cnlQb2ludCBkb2VzIG5vdCBleGlzdCwgdGhpcyBpcyBhIG1hbGZvcm1lZCBGU00gYW5kIHRoZSBiZWhhdmlvdXJcbiAgICogaXMgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBoYXMgdGhlIG5hbWVkIGVudHJ5UG9pbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZW50cnlQb2ludCBvZiBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdGF0ZUNvbnRleHQuYWN0aW9uQ2FsbGJhY2t9IGFjdGlvbiBUaGUgYWN0aW9uIHRvIHBlcmZvcm0gYXMgcGFydCBvZlxuICAgKiAgICAgIHRoZSB0cmFuc2FjdGlvbiwgaWYgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvblxuICAgKi9cbiAgdHJhbnNpdGlvblRvRW50cnlQb2ludChzdGF0ZSwgZW50cnlQb2ludE5hbWUsIGFjdGlvbikge1xuICAgIHJldHVybiBuZXcgU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0KHtcbiAgICAgIGNhbGxlcjogICAgdGhpcyxcbiAgICAgIGRlc3RTdGF0ZTogc3RhdGUuZ2V0RW50cnlQb2ludERlc3RTdGF0ZShlbnRyeVBvaW50TmFtZSksXG4gICAgICBhY3Rpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBzaW1pbGFyIHRvIFt0cmFuc2l0aW9uVG9de0BsaW5rIFN0YXRlQ29udGV4dCN0cmFuc2l0aW9uVG99LCBleGNlcHRcbiAgICogdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiB0byBhIG5hbWVkIGV4aXRQb2ludCBjcmVhdGVkIG9uIHN0YXRlLiAgSWYgdGhlXG4gICAqIG5hbWVkIGV4aXRQb2ludCBkb2VzIG5vdCBleGlzdCwgdGhpcyBpcyBhIG1hbGZvcm1lZCBGU00gYW5kIHRoZSBiZWhhdmlvdXJcbiAgICogaXMgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBoYXMgdGhlIG5hbWVkIGV4aXRQb2ludC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4aXRQb2ludE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4aXRQb2ludCBvZiBzdGF0ZS5cbiAgICogQHBhcmFtIHtTdGF0ZUNvbnRleHQuYWN0aW9uQ2FsbGJhY2t9IFthY3Rpb25dIE9wdGlvbmFsIFRoZVxuICAgKiBhY3Rpb24gdG8gcGVyZm9ybSBhcyBwYXJ0IG9mIHRoZSB0cmFuc2FjdGlvbiwgaWYgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvblxuICAgKi9cbiAgdHJhbnNpdGlvblRvRXhpdFBvaW50KHN0YXRlLCBleGl0UG9pbnROYW1lLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdCh7XG4gICAgICBjYWxsZXI6ICAgIHRoaXMsXG4gICAgICBkZXN0U3RhdGU6IHN0YXRlLmdldEV4aXRQb2ludERlc3RTdGF0ZShleGl0UG9pbnROYW1lKSxcbiAgICAgIGFjdGlvbixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIHJlYWN0aW9uIGV2YWx1YXRlcyB0aGUgZ3VhcmQgY29uZGl0aW9ucyBmb3IgdGhlIHJlYWN0aW9uIGFuZCBub25lXG4gICAqIHN1Y2NlZWQsIHRoZSBldmVudFVuaGFuZGxlZFxuICAgKiBbUmVhY3Rpb25SZXN1bHRde0BsaW5rIFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gc2hvdWxkIGJlXG4gICAqIHJldHVybmVkLiAgVGhpcyBjYXVzZXMgdGhlIEZTTSB0byBjb250aW51ZSBsb29raW5nIGZvciBhIHJlYWN0aW9uIHRvXG4gICAqIHByb2Nlc3MgdGhlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7U3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0fSBUaGUgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uXG4gICAqL1xuICBldmVudFVuaGFuZGxlZCgpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdCh7XG4gICAgICBjYWxsZXI6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBbUmVhY3Rpb25SZXN1bHRde0BsaW5rIFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gaXMgdXNlZFxuICAgKiB3aGVuIGFuIGV2ZW50IGhhcyBiZWVuIGhhbmRsZWQgaW4gYSBzdGF0ZSBhbmQgdGhlIHRyYW5zaXRpb24gaXMgYSBsb2NhbFxuICAgKiB0cmFuc2l0aW9uIGJhY2sgdG8gaXRzZWxmLiAgTm90ZSB0aGF0IGludGVybmFsIHRyYW5zaXRpb25zIG5ldmVyIGNhdXNlXG4gICAqIHN0YXRlIGV4aXRzIG9yIGVudHJpZXMgLS0gaWYgdGhlIGludGVybmFsIHRyYW5zaXRpb24gaXMgZGVmaW5lZCBpbiBhblxuICAgKiBvdXRlciBzdGF0ZSB0aGF0IGNvbnRhaW5zIHRoZSBhY3RpdmUgc3RhdGUsIHRoZW4gdGhlIGJlaGF2aW91ciBpcyBhcyBpZiB0aGVcbiAgICogYWN0aXZlIHN0YXRlIGhhcyBpbmhlcml0ZWQgdGhlIGludGVybmFsIHRyYW5zaXRpb24gZnJvbSB0aGUgb3V0ZXIgc3RhdGUuXG4gICAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBhY3Rpb24gVGhlIGFjdGlvbiB0byBwZXJmb3JtIGluIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7U3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0fSBUaGUgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uXG4gICAqL1xuICBpbnRlcm5hbFRyYW5zaXRpb24oYWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZUNvbnRleHQuUmVhY3Rpb25SZXN1bHQoe1xuICAgICAgY2FsbGVyOiAgICB0aGlzLFxuICAgICAgZGVzdFN0YXRlOiB0aGlzLmdldFN0YXRlTWFjaGluZSgpLmdldEN1cnJlbnRTdGF0ZSgpLFxuICAgICAgYWN0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdGVybWluYXRlIHRoZSBGU00uXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0LmFjdGlvbkNhbGxiYWNrfSBhY3Rpb24gQW4gb3B0aW9uYWwgYWN0aW9uIHRvXG4gICAqICAgICAgdGFrZSB3aXRoaW4gdGhlIEZTTSBjb250ZXh0IGFmdGVyIGFsbCBzdGF0ZXMgaGF2ZSBiZWVuIGV4aXRlZC5cbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gVGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvblxuICAgKi9cbiAgdGVybWluYXRlKGFjdGlvbikge1xuICAgIHJldHVybiBuZXcgU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0KHtcbiAgICAgIGNhbGxlcjogICAgdGhpcyxcbiAgICAgIGRlc3RTdGF0ZTogdGhpcy5nZXRTdGF0ZU1hY2hpbmUoKS5nZXRGaW5hbFN0YXRlKCksXG4gICAgICBhY3Rpb24sXG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RhdGVDb250ZXh0fSBUaGUgcGFyZW50IHN0YXRlIGNvbnRleHQgZm9yIHRoaXMgc3RhdGUsIHdoaWNoXG4gICAqICAgICAgY291bGQgZWl0aGVyIGJlIGFuIG91dGVyIHN0YXRlLCBvciB0aGUgc3RhdGUgbWFjaGluZSBmb3IgdG9wLWxldmVsXG4gICAqICAgICAgc3RhdGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRQYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wbC5wYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC4gIENhbGxzIHRoZSBhcHAncyByZWdpc3RlcmVkIGVudHJ5XG4gICAqIGZ1bmN0aW9uLCBpZiBhbnkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uRW50cnkoKSB7XG4gICAgdGhpcy5sb2coYEVudGVyaW5nOiAke3RoaXN9YCk7XG4gICAgaWYgKHRoaXMuaW1wbC5hcHBFbnRyeUZ1bmMpIHtcbiAgICAgIHRoaXMuaW1wbC5hcHBFbnRyeUZ1bmMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBzdGF0ZSBpcyBiZWluZyBleGl0ZWQuICBDYWxscyB0aGUgYXBwJ3MgcmVnaXN0ZXJlZCBleGl0XG4gICAqIGZ1bmN0aW9uLCBpZiBhbnkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIG9uRXhpdCgpIHtcbiAgICB0aGlzLmxvZyhgRXhpdGluZzogJHt0aGlzfWApO1xuICAgIGlmICh0aGlzLmltcGwuYXBwRXhpdEZ1bmMpIHtcbiAgICAgIHRoaXMuaW1wbC5hcHBFeGl0RnVuYygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHN0YXRlIGlzIHRvIGhhbmRsZSBhbiBldmVudC5cbiAgICogQHBhcmFtIHtGc21FdmVudH0gZSBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuICAgKiBAcmV0dXJucyB7UmVhY3Rpb25SZXN1bHR9IFRoZSByZXN1bHQgb2YgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVFdmVudChlKSB7XG4gICAgdGhpcy5sb2coYFByb2Nlc3M6ICR7ZX1gKTtcbiAgICBjb25zdCByZWFjdGlvbiA9IHRoaXMuaW1wbC5yZWFjdGlvbnNbZS5nZXROYW1lKCldO1xuICAgIGlmIChyZWFjdGlvbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVhY3Rpb24oZSk7XG4gICAgICAvLyBBbGwgUmVhY3Rpb25SZXN1bHRzIGluIHdoaWNoIGFuIGV2ZW50IGlzIGNvbnNpZGVyZWQgaGFuZGxlZFxuICAgICAgLy8gaGF2ZSBhIGRlc3RTdGF0ZSBkZWZpbmVkLlxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5sb2coYFJlYWN0aW9uIHJldHVybmVkIHVuZGVmaW5lZDogJHtlfSBpbiAke3RoaXN9YCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmRlc3RTdGF0ZSkge1xuICAgICAgICB0aGlzLmxvZyhgSGFuZGxlZDogJHtlfWApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coYFVuaGFuZGxlZDogJHtlfSBpbiAke3RoaXN9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBObyByZWFjdGlvbjogJHtlfSBpbiAke3RoaXN9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW1wbC5oYW5kbGVVbmhhbmRsZWRFdmVudChlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZnNtL2xpYi9zdGF0ZS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIG1lc3NhZ2UgY29uc3VtZXIgZXZlbnQgbmFtZXMuIEEge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9IHdpbGwgZW1pdFxuICogdGhlc2UgZXZlbnRzIGFzIHBhcnQgb2YgaXRzIGxpZmVjeWNsZS4gIEFwcGxpY2F0aW9ucywgaGF2aW5nIGNyZWF0ZWQgYSBNZXNzYWdlQ29uc3VtZXIgY2FuXG4gKiBjaG9vc2UgdG8gbGlzdGVuIHRvIGFsbCBvZiB0aGUgZXZlbnRzIGRlc2NyaWJlZCBoZXJlLCBvciBhbnkgc3Vic2V0IG9mIHRoZXNlIGV2ZW50cy4gRm9yIEV4YW1wbGU6XG4gKiA8cHJlPlxuICogICA8Y29kZT5cbiAqICAgICBtYyA9IHNvbGFjZS5TZXNzaW9uLmNyZWF0ZU1lc3NhZ2VDb25zdW1lciguLi4pO1xuICogICAgIG1jLm9uKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuQ09OTkVDVF9GQUlMRURfRVJST1IsXG4gKiAgICAgICAgICAgZnVuY3Rpb24gY29ubmVjdEZhaWxlZEVycm9yRXZlbnRDYihlcnJvcikge1xuICogICAgICAgICAgICAgLy8gZGV0YWlscyBpcyBhbiBPcGVyYXRpb25FcnJvciBvYmplY3RcbiAqICAgICAgICAgICB9KTtcbiAqICAgPC9jb2RlPlxuICogPC9wcmU+XG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBuYW1lc3BhY2VcbiAqL1xuY29uc3QgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lID0ge1xuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgY29uc3VtZXIgaXMgZXN0YWJsaXNoZWQuXG4gICAqIEBldmVudCBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI1VQXG4gICAqL1xuICBVUDogICAgICAgICAgICAgICAgICAgJ01lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV91cCcsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciBpcyBzdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkLlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciBpcyBkaXNhYmxlZC5cbiAgICpcbiAgICogQGV2ZW50IHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjRE9XTlxuICAgKi9cbiAgRE9XTjogICAgICAgICAgICAgICAgICdNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWVfZG93bicsXG4gLyoqXG4gICAqIFRoZSBtZXNzYWdlIGNvbnN1bWVyIGhhcyBiZWNvbWUgYWN0aXZlLlxuICAgKlxuICAgKiBAZXZlbnQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNBQ1RJVkVcbiAgICovXG4gIEFDVElWRTogICAgICAgICAgICAgICAnTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2FjdGl2ZScsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciBoYXMgYmVjb21lIGluYWN0aXZlLlxuICAgKlxuICAgKiBAZXZlbnQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNJTkFDVElWRVxuICAgKi9cbiAgSU5BQ1RJVkU6ICAgICAgICAgICAgICdNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWVfaW5hY3RpdmUnLFxuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgY29uc3VtZXIgd2FzIGVzdGFibGlzaGVkIGFuZCB0aGVuIGRpc2Nvbm5lY3RlZCBieSB0aGUgcm91dGVyLFxuICAgKiBsaWtlbHkgZHVlIHRvIG9wZXJhdG9yIGludGVydmVudGlvbi4gVGhlIG1lc3NhZ2UgY29uc3VtZXIgaXMgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBldmVudCBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI0RPV05fRVJST1JcbiAgICovXG4gIERPV05fRVJST1I6ICAgICAgICAgICAnTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2Rvd25FcnJvcicsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciBhdHRlbXB0ZWQgdG8gY29ubmVjdCBidXQgd2FzIHVuc3VjY2Vzc2Z1bC5cbiAgICogVGhlIG1lc3NhZ2UgY29uc3VtZXIgaXMgZGlzYWJsZWQuXG4gICAqXG4gICAqIEBldmVudCBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI0NPTk5FQ1RfRkFJTEVEX0VSUk9SXG4gICAqIEBwYXJhbSB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBlcnJvciBEZXRhaWxzIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIENPTk5FQ1RfRkFJTEVEX0VSUk9SOiAnTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2Nvbm5lY3RGYWlsZWRFcnJvcicsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciB3aWxsIG5vdCBjb25uZWN0IGJlY2F1c2UgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbmNvbXBhdGlibGVcbiAgICogd2l0aCBHdWFyYW50ZWVkIE1lc3NhZ2luZy4gVGhlIG1lc3NhZ2UgY29uc3VtZXIgaXMgZGlzYWJsZWQgdW50aWwgYSBjb21wYXRpYmxlIHNlc3Npb25cbiAgICogaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAZXZlbnQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNHTV9ESVNBQkxFRFxuICAgKi9cbiAgR01fRElTQUJMRUQ6ICAgICAgICAgICdNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWVfR01EaXNhYmxlZCcsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBjb25zdW1lciBpcyBiZWluZyBkaXNwb3NlZC4gTm8gZnVydGhlciBldmVudHMgd2lsbCBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBAZXZlbnQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNESVNQT1NFRFxuICAgKi9cbiAgRElTUE9TRUQ6ICAgICAgICAgICAgICdNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWVfZGlzcG9zZWQnLFxuICAvKipcbiAgICogQSBtZXNzYWdlIHdhcyByZWNlaXZlZCBvbiB0aGUgbWVzc2FnZSBjb25zdW1lci5cbiAgICpcbiAgICogSWYgdGhlIGFwcGxpY2F0aW9uIHRocm93cyBhbiBleGNlcHRpb24gaW4gdGhpcyBsaXN0ZW5lciwgYW5kIHRoZSBjb25zdW1lciB3YXMgY29uZmlndXJlZFxuICAgKiB0byBhdXRvbWF0aWNhbGx5IGFja25vd2xlZGdlIG1lc3NhZ2VzXG4gICAqIChzZWUge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzI2Fja25vd2xlZGdlTW9kZX0pLFxuICAgKiB0aGUgQVBJIHdpbGwgbm90IGFja25vd2xlZGdlIHRoZSBtZXNzYWdlLCBzaW5jZSBpdFxuICAgKiBtYXkgbm90IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIGJ5IHRoZSBhcHBsaWNhdGlvbi4gU3VjaCBhIG1lc3NhZ2UgbXVzdCBiZVxuICAgKiBhY2tub3dsZWRnZWQgbWFudWFsbHkuIElmIHRoZSBhcHBsaWNhdGlvbiBkaWQgbm90IHJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgbWVzc2FnZSwgaXRcbiAgICogbWF5IGJlIHJlZGVsaXZlcmVkIGJ5IGNhbGxpbmcge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIjZGlzY29ubmVjdH0gZm9sbG93ZWQgYnlcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIjY29ubmVjdH0gZGVwZW5kaW5nIG9uIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogV2hlbiB0aGVyZSBpcyBubyBsaXN0ZW5lciBmb3IgPGk+TUVTU0FHRTwvaT4gb24gYSBNZXNzYWdlQ29uc3VtZXIsIG1lc3NhZ2VzIGFyZSBxdWV1ZWRcbiAgICogaW50ZXJuYWxseSB1bnRpbCBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgKlxuICAgKiBAZXZlbnQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNNRVNTQUdFXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2UgVGhlIHJlY2VpdmVkIG1lc3NhZ2UgYmVpbmcgZGVsaXZlcmVkIGluIHRoaXMgZXZlbnQuXG4gICAqL1xuICBNRVNTQUdFOiAgICAgICAgICAgICAgJ01lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV9tZXNzYWdlJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSA9IEVudW0ubmV3KE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9tZXNzYWdlLWNvbnN1bWVyLWV2ZW50LW5hbWVzLmpzIiwiY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLXB1Ymxpc2hlcicpO1xuY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci1hY2tub3dsZWRnZS1tb2RlcycpO1xuY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci1ldmVudC1uYW1lcycpO1xuY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1wdWJsaXNoZXItcHJvcGVydGllcycpO1xuY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllc1ZhbGlkYXRvciB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1wdWJsaXNoZXItcHJvcGVydGllcy12YWxpZGF0b3InKTtcbmNvbnN0IHsgUHVibGlzaGVyRlNNRXZlbnQgfSA9IHJlcXVpcmUoJy4vbGliL3B1Ymxpc2hlci1mc20tZXZlbnQnKTtcbmNvbnN0IHsgUHVibGlzaGVyRlNNRXZlbnROYW1lcyB9ID0gcmVxdWlyZSgnLi9saWIvcHVibGlzaGVyLWZzbS1ldmVudC1uYW1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlID0gTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZTtcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VQdWJsaXNoZXIgPSBNZXNzYWdlUHVibGlzaGVyO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgPSBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcztcbm1vZHVsZS5leHBvcnRzLlB1Ymxpc2hlckZTTUV2ZW50ID0gUHVibGlzaGVyRlNNRXZlbnQ7XG5tb2R1bGUuZXhwb3J0cy5QdWJsaXNoZXJGU01FdmVudE5hbWVzID0gUHVibGlzaGVyRlNNRXZlbnROYW1lcztcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzVmFsaWRhdG9yID0gTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXNWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lID0gTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2FwaS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNEVERhdGFUeXBlcyA9IHtcbiAgTnVsbDogICAgICAgICAgICAweDAwLFxuICBCb29sZWFuOiAgICAgICAgIDB4MDEsXG4gIEludGVnZXI6ICAgICAgICAgMHgwMixcbiAgVW5zaWduZWRJbnRlZ2VyOiAweDAzLFxuICBGbG9hdDogICAgICAgICAgIDB4MDQsXG4gIENoYXI6ICAgICAgICAgICAgMHgwNSxcbiAgQnl0ZUFycmF5OiAgICAgICAweDA2LFxuICBTdHJpbmc6ICAgICAgICAgIDB4MDcsXG4gIERlc3RpbmF0aW9uOiAgICAgMHgwOCxcbiAgU01GTWVzc2FnZTogICAgICAweDA5LFxuICBNYXA6ICAgICAgICAgICAgIDB4MEEsXG4gIFN0cmVhbTogICAgICAgICAgMHgwQixcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNEVERhdGFUeXBlcyA9IEVudW0ubmV3KFNEVERhdGFUeXBlcyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1kYXRhLXR5cGVzLmpzIiwiLyoqXG4gKiBAY29uc3RydWN0b3IgQmFzZU1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEJhc2VNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoaGVhZGVyID0gbnVsbCwgcGFyYW1zID0gW10pIHtcbiAgICB0aGlzLl9zbWZIZWFkZXIgPSBoZWFkZXI7XG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtcztcbiAgfVxuXG4gIGFkZFBhcmFtZXRlcihwYXJhbSkge1xuICAgIHRoaXMuX3BhcmFtZXRlcnNbcGFyYW0uZ2V0VHlwZSgpXSA9IHBhcmFtO1xuICB9XG5cbiAgZ2V0UGFyYW1ldGVyKHBhcmFtVHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzW3BhcmFtVHlwZV07XG4gIH1cblxuICBnZXRQYXJhbWV0ZXJBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVycztcbiAgfVxuXG4gIGdldCBzbWZIZWFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NtZkhlYWRlcjtcbiAgfVxuICBzZXQgc21mSGVhZGVyKHZhbCkge1xuICAgIHRoaXMuX3NtZkhlYWRlciA9IHZhbDtcbiAgfVxuXG4gIGdldFJlc3BvbnNlKCkge1xuICAgIGNvbnN0IHNtZiA9IHRoaXMuc21mSGVhZGVyO1xuICAgIGlmICghKHNtZiAmJiBzbWYucG1fcmVzcGNvZGUgJiYgc21mLnBtX3Jlc3BzdHIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlQ29kZTogICBzbWYucG1fcmVzcGNvZGUsXG4gICAgICByZXNwb25zZVN0cmluZzogc21mLnBtX3Jlc3BzdHIsXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5CYXNlTWVzc2FnZSA9IEJhc2VNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9tZXNzYWdlLW9iamVjdHMvYmFzZS1tZXNzYWdlLmpzIiwiLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250cm9sIG1lc3NhZ2VzIHdyYXAgYW4gU01GSGVhZGVyIGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTTUZIZWFkZXIge1xuICBjb25zdHJ1Y3Rvcihwcm90b2NvbCA9IDAsIHR0bCA9IDApIHtcbiAgICAvLyBoZWFkZXIgcHJvcGVydGllc1xuICAgIC8vIGhlYWRlciBibG9ja1xuICAgIC8vIFNNRiBwYXJhbWV0ZXJzXG4gICAgLy8gcGF5bG9hZFxuICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBbXTtcblxuICAgIC8vIENvbW1vbiBTTUYgaGVhZGVyIGZpZWxkIHZhbHVlc1xuICAgIHRoaXMuc21mX3ZlcnNpb24gPSAzO1xuICAgIHRoaXMuc21mX3VoID0gMDtcbiAgICB0aGlzLnNtZl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMuc21mX3ByaW9yaXR5ID0gMDtcbiAgICB0aGlzLnNtZl90dGwgPSB0dGw7XG4gICAgdGhpcy5zbWZfbXNnTGVuID0gMDtcbiAgICB0aGlzLnNtZl9kaSA9IDA7XG4gICAgdGhpcy5zbWZfdHFkID0gMDtcbiAgICB0aGlzLnNtZl9lbGlkaW5nRWxpZ2libGUgPSAwO1xuICAgIHRoaXMuc21mX2R0byA9IDA7XG4gICAgdGhpcy5zbWZfYWRmID0gMDsgICAgICAgICAgICAgICAgICAvLyBBRFxuICAgIHRoaXMuc21mX2RlYWRNZXNzYWdlUXVldWVFbGlnaWJsZSA9IDA7IC8vRE1RIEVsaWdpYmxlXG5cbiAgICAvLyBDb21tb24gU01GIHByb3RvY29sIHBhcmFtZXRlcnNcbiAgICB0aGlzLnBtX3VzZXJkYXRhID0gbnVsbDtcbiAgICB0aGlzLnBtX3Jlc3Bjb2RlID0gMDtcbiAgICB0aGlzLnBtX3Jlc3BzdHIgPSBudWxsO1xuICAgIHRoaXMucG1fdXNlcm5hbWUgPSBudWxsO1xuICAgIHRoaXMucG1fcGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMucG1fdHJfdG9waWNuYW1lX2J5dGVzID0gbnVsbDtcbiAgICB0aGlzLnBtX2RlbGl2ZXJ5bW9kZSA9IG51bGw7XG5cbiAgICB0aGlzLnBtX2FkX21zZ2lkID0gdW5kZWZpbmVkOyAgICAgIC8vIEFEXG4gICAgdGhpcy5wbV9hZF9wcmV2bXNnaWQgPSB1bmRlZmluZWQ7ICAvLyBBRFxuICAgIHRoaXMucG1fYWRfcmVkZWxmbGFnID0gMDsgICAgICAgICAgLy8gQURcbiAgICB0aGlzLnBtX2FkX2Zsb3dyZWRlbGZsYWcgPSAwOyAgICAgIC8vIEFEXG4gICAgdGhpcy5wbV9hZF90dGwgPSB1bmRlZmluZWQ7ICAgICAgICAvLyBBRFxuICAgIHRoaXMucG1fYWRfYWNraW1tID0gdW5kZWZpbmVkOyAgICAgLy8gQURcbiAgICB0aGlzLnBtX2FkX2Zsb3dpZCA9IDA7ICAgICAgICAgICAgIC8vIEFEXG4gICAgdGhpcy5wbV9hZF9wdWJsaXNoZXJpZCA9IDA7XG4gICAgdGhpcy5wbV9hZF9wdWJsaXNoZXJtc2dpZCA9IDA7XG5cbiAgICB0aGlzLnBtX2NvbnRlbnRfc3VtbWFyeSA9IG51bGw7XG4gICAgdGhpcy5wbV9jb3JydGFnID0gbnVsbDtcbiAgICB0aGlzLnBtX3RvcGljX29mZnNldCA9IDA7XG4gICAgdGhpcy5wbV90b3BpY19sZW4gPSAwO1xuICAgIHRoaXMucG1fcXVldWVfb2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBtX3F1ZXVlX2xlbiA9IDA7XG4gICAgdGhpcy5wbV9tc2dfcHJpb3JpdHkgPSBudWxsOyAgICAgICAgLy8ge251bWJlcn1cblxuICAgIC8vIGhvdXNla2VlcGluZ1xuICAgIHRoaXMudW5rbm93blByb3RvRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMubWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLmhlYWRlckxlbmd0aCA9IDA7XG4gICAgdGhpcy5wYXlsb2FkID0gbnVsbDtcblxuICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBpbnZhbGlkLCBidXQgdGhlIGZyYW1pbmcgKG1lc3NhZ2VMZW5ndGgpIGlzIGZpbmUuXG4gICAgLy8gc2V0IGJ5IHRoZSBwYXJzZXIgd2hlbiBVSD09MiBvbiBhbiB1bmtub3duIHBhcmFtZXRlci5cbiAgICAvLyBUaGUgU01GIGZzbSBjYW4gdGhlbiBkaXNjYXJkIGFuZCBpbmNyZW1lbnQgdGhlIHN0YXRzLlxuICAgIHRoaXMuZGlzY2FyZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIHNldE1lc3NhZ2VTaXplcyhoZWFkZXJMZW5ndGgsIHBheWxvYWRMZW5ndGgpIHtcbiAgICB0aGlzLmhlYWRlckxlbmd0aCA9IGhlYWRlckxlbmd0aDtcbiAgICB0aGlzLnBheWxvYWRMZW5ndGggPSBwYXlsb2FkTGVuZ3RoO1xuICAgIHRoaXMubWVzc2FnZUxlbmd0aCA9IGhlYWRlckxlbmd0aCArIHBheWxvYWRMZW5ndGg7XG4gIH1cblxuICBzZXRQYXlsb2FkU2l6ZShwYXlsb2FkTGVuZ3RoKSB7XG4gICAgdGhpcy5wYXlsb2FkTGVuZ3RoID0gcGF5bG9hZExlbmd0aDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TTUZIZWFkZXIgPSBTTUZIZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL21lc3NhZ2Utb2JqZWN0cy9zbWYtaGVhZGVyLmpzIiwiY29uc3QgeyBTb2xhY2VFcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gZXJyb3Igb2NjdXJzIG9uIHRoZSB0cmFuc3BvcnQgc2Vzc2lvbi5cbiAqIDxwPlxuICogQXBwbGljYXRpb25zIGFyZSBub3QgZXhwZWN0ZWQgdG8gaW5zdGFudGlhdGUgdGhpcyB0eXBlLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFRyYW5zcG9ydEVycm9yIGV4dGVuZHMgU29sYWNlRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUcmFuc3BvcnRFcnJvci5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVycm9yXG4gICAqIEBwYXJhbSB7RXJyb3JTdWJjb2RlfSBzdWJjb2RlIFRoZSBzdWJjb2RlIGZvciB0aGlzIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdWJjb2RlKSB7XG4gICAgc3VwZXIoJ1RyYW5zcG9ydEVycm9yJywgbWVzc2FnZSk7XG4gICAgdGhpcy5zdWJjb2RlID0gc3ViY29kZTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHtzdXBlci50b1N0cmluZygpfSwgc3ViY29kZT0ke3RoaXMuc3ViY29kZX1gO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydEVycm9yID0gVHJhbnNwb3J0RXJyb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1lcnJvci5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IHNlc3Npb24gc3RhdGVzLCB1c2VkIGJ5IFdlYlNvY2tldFRyYW5zcG9ydFNlc3Npb24gYW5kIEhUVFBUcmFuc3BvcnRTZXNzaW9uXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgVHJhbnNwb3J0U2Vzc2lvblN0YXRlID0ge1xuICBET1dOOiAgICAgICAgICAgICAgICAwLFxuICBXQUlUSU5HX0ZPUl9DUkVBVEU6ICAxLFxuICBTRVNTSU9OX1VQOiAgICAgICAgICAyLFxuICBXQUlUSU5HX0ZPUl9ERVNUUk9ZOiA0LFxuICBDT05ORUNUSU9OX0ZBSUxFRDogICA1LFxufTtcblxubW9kdWxlLmV4cG9ydHMuVHJhbnNwb3J0U2Vzc2lvblN0YXRlID0gRW51bS5uZXcoVHJhbnNwb3J0U2Vzc2lvblN0YXRlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXNlc3Npb24tc3RhdGVzLmpzIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJy4vbGliL2V2ZW50LWVtaXR0ZXInKTtcbmNvbnN0IHsgVGltZXIgfSA9IHJlcXVpcmUoJy4vbGliL3RpbWVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudEVtaXR0ZXIsXG4gIFRpbWVyLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWV2ZW50cy9hcGkuanMiLCJjb25zdCB7IEZsb3cgfSA9IHJlcXVpcmUoJy4vbGliL2Zsb3cnKTtcbmNvbnN0IHsgRmxvd09wZXJhdGlvbiB9ID0gcmVxdWlyZSgnLi9saWIvZmxvdy1vcGVyYXRpb24nKTtcbmNvbnN0IHsgUHJpdmF0ZUZsb3dFdmVudE5hbWUgfSA9IHJlcXVpcmUoJy4vbGliL3ByaXZhdGUtZmxvdy1ldmVudC1uYW1lcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5GbG93ID0gRmxvdztcbm1vZHVsZS5leHBvcnRzLkZsb3dPcGVyYXRpb24gPSBGbG93T3BlcmF0aW9uO1xubW9kdWxlLmV4cG9ydHMuUHJpdmF0ZUZsb3dFdmVudE5hbWUgPSBQcml2YXRlRmxvd0V2ZW50TmFtZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWZsb3cvYXBpLmpzIiwiY29uc3QgeyBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGhpcyBpcyBhIGJhc2UgY2xhc3MgZm9yIHZhcmlvdXMgRlNNLXJlbGF0ZWQgb2JqZWN0cy5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEZzbU9iamVjdCB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyBUaGUgb2JqZWN0IHNwZWNpZmllciB1c2VkIHRvIGltcGxlbWVudCB0aGUgbmFtZWRcbiAgICogICAgICBwYXJhbWV0ZXIgaWRpb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm5hbWUgVGhlIG5hbWUgb2YgdGhlIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBpZiAoIXNwZWMpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignTm8gc3BlYyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBpZiAoIXNwZWMubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdObyBuYW1lIHByb3ZpZGVkIGZvciBzcGVjJyk7XG4gICAgfVxuICAgIHRoaXMuaW1wbCA9IHtcbiAgICAgIG5hbWU6IHNwZWMubmFtZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgZXh0cmFTdHJpbmdJbmZvID0gdGhpcy5nZXRFeHRyYVN0cmluZ0luZm8oKTtcbiAgICBpZiAoZXh0cmFTdHJpbmdJbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4dHJhU3RyaW5nSW5mbyA9IGA7ICR7ZXh0cmFTdHJpbmdJbmZvfWA7XG4gICAgfVxuICAgIHJldHVybiBgeyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogJHt0aGlzLmdldE5hbWUoKX0ke2V4dHJhU3RyaW5nSW5mb319YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG92ZXJyaWRkZW4gYnkgY2xhc3NlcyB3YW50aW5nIHRvIGFkZCBtb3JlIGRhdGEsIHR5cGljYWxseSBpbiB0aGVcbiAgICogZm9ybSBvZiAnbmFtZTogdmFsdWU7IG5hbWU6IHZhbHVlJy5cbiAgICogQHJldHVybnMge1N0cmluZ30gRXh0cmEgc3RyaW5nIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBvYmplY3Qnc1xuICAgKiAgICAgIHRvU3RyaW5nKCkgb3V0cHV0LlxuICAgKi9cbiAgZ2V0RXh0cmFTdHJpbmdJbmZvKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9TdHJpbmd9IFRoZSBuYW1lIHBhc3NlZCBpbnRvIHRoZSBvYmplY3Qgc3BlY2lmaWVyLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXBsLm5hbWU7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5Gc21PYmplY3QgPSBGc21PYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vbGliL29iamVjdC5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgY29uc3VtZXIgYWNrbm93bGVkZ2VtZW50IG1vZGVzLiBUaGUgY29ycmVzcG9uZGluZ1xuICogTWVzc2FnZUNvbnN1bWVyIHByb3BlcnR5IHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyNhY2tub3dsZWRnZU1vZGV9XG4gKiBjb25maWd1cmVzIGhvdyBhY2tub3dsZWRnbWVudHMgYXJlIGdlbmVyYXRlZCBmb3IgcmVjZWl2ZWQgR3VhcmFudGVlZCBtZXNzYWdlcy5cbiAqXG4gKiBXaGVuIHJlY2VpdmVkIG1lc3NhZ2VzIGFyZSBhY2tub3dsZWRnZWQgdGhleSBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBHdWFyYW50ZWVkXG4gKiBNZXNzYWdlIHN0b3JhZ2Ugb24gdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci4gTWVzc2FnZSBDb25zdW1lciBhY2tub3dsZWRnZW1lbnRzLFxuICogPGI+b25seTwvYj4gcmVtb3ZlIG1lc3NhZ2VzIGZyb20gdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci5cbiAqXG4gKiBJbiBwYXJ0aWN1bGFyLCB3aXRoaG9sZGluZyBNZXNzYWdlIENvbnN1bWVyIEFja25vd2xlZGdlbW50cyBkb2VzIG5vdCBzdG9wXG4gKiBtZXNzYWdlIGRlbGl2ZXJ5LiBGb3IgTWVzc2FnZSBDb25zdW1lciBmbG93IGNvbnRyb2wgc2VlXG4gKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lci5zdG9wfS97QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lci5zdGFydH0uIE1lc3NhZ2UgQ29uc3VtZXJcbiAqIGZsb3cgY29udHJvbCBtYXkgYWxzbyBiZSBpbWxwZW1lbnRlZCBieSByZW1vdmluZyB0aGVcbiAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI2V2ZW50Ok1FU1NBR0V9IGxpc3RlbmVyLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAbmFtZXNwYWNlXG4gKi9cbmNvbnN0IE1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBBUEkgYXV0b21hdGljYWxseSBhY2tub3dsZWRnZXMgYW55IG1lc3NhZ2UgdGhhdCB3YXMgZGVsaXZlcmVkIHRvIGFsbFxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNldmVudDpNRVNTQUdFfSBsaXN0ZW5lcnMgd2l0aCBubyBleGNlcHRpb24gdGhyb3duXG4gICAqIG9uIGFueSBvZiB0aGVtLlxuICAgKi9cbiAgQVVUTzogICAnQVVUTycsXG4gIC8qKlxuICAgKiBUaGUgQVBJIGFja25vd2xlZGdlcyBhIG1lc3NhZ2Ugb25seSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBjYWxsc1xuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2UjYWNrbm93bGVkZ2V9LlxuICAgKi9cbiAgQ0xJRU5UOiAnQ0xJRU5UJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSA9IEVudW0ubmV3KE1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9tZXNzYWdlLWNvbnN1bWVyLWFja25vd2xlZGdlLW1vZGVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBlbnVtZXJhdGlvbi5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IE1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUgPSB7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQXBwbGljYXRpb25zIHJlY2VpdmUgYW4gYWNrbm93bGVkZ2VtZW50IGZvciBldmVyeVxuICAgKiBtZXNzYWdlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgUEVSX01FU1NBR0U6ICdQRVJfTUVTU0FHRScsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQXBwbGljYXRpb25zIHJlY2VpdmUgYSB3aW5kb3dlZCBhY2tub3dsZWRnZW1lbnQgdGhhdFxuICAgKiBhY2tub3dsZWRnZXMgdGhlIHJldHVybmVkIGNvcnJlbGF0aW9uIGlkZW50aWZpZXIgYW5kIGV2ZXJ5IG1lc3NhZ2Ugc2VudCBwcmlvci5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIFdJTkRPV0VEOiAgICAnV0lORE9XRUQnLFxufTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSA9IEVudW0ubmV3KE1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXIvbGliL21lc3NhZ2UtcHVibGlzaGVyLWFja25vd2xlZGdlLW1vZGVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVudW1lcmF0aW9uIG9mIG1lc3NhZ2UgZHVtcCBmb3JtYXRzLiBJdCBjb250cm9sc1xuICogdGhlIG91dHB1dCBvZiB7QGxpbmsgc29sYWNlLk1lc3NhZ2UjZHVtcH0uXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgTWVzc2FnZUR1bXBGbGFnID0ge1xuICAvKipcbiAgICogRGlzcGxheSBvbmx5IHRoZSBsZW5ndGggb2YgdGhlIGJpbmFyeSBhdHRhY2htZW50LCBYTUwgY29udGVudCBhbmQgdXNlciBwcm9wZXJ0eSBtYXBzLlxuICAgKi9cbiAgTVNHRFVNUF9CUklFRjogMCxcbiAgLyoqXG4gICAqIERpc3BsYXkgdGhlIGVudGlyZSBtZXNzYWdlIGNvbnRlbnRzLlxuICAgKi9cbiAgTVNHRFVNUF9GVUxMOiAgMSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VEdW1wRmxhZyA9IEVudW0ubmV3KE1lc3NhZ2VEdW1wRmxhZyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlL2xpYi9tZXNzYWdlLWR1bXAtZmxhZ3MuanMiLCJjb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBTRFRGaWVsZCB9ID0gcmVxdWlyZSgnLi9zZHQtZmllbGQnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBEZWZpbmVzIGEgU3RydWN0dXJlZCBEYXRhIFR5cGUgKFNEVCkgbWFwIGNvbnRhaW5lci5cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgU0RUTWFwQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFwID0gW107IC8vIGtleS12YWx1ZSBtYXBwaW5ncyAoa2V5cyBhcmUgc3RyaW5ncylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Yga2V5cyBpbiB0aGlzIG1hcCwgaW4gdW5zcGVjaWZpZWQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gQXJyYXkgb2YgZGVmaW5lZCBrZXlzIGluIHRoZSBtYXAuXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9tYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgU0RURmllbGQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge3NvbGFjZS5TRFRGaWVsZH0gVGhlIGZpZWxkIHJlZmVyZW5jZWQgYnkga2V5LlxuICAgKi9cbiAgZ2V0RmllbGQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBTRFRGaWVsZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGZpZWxkIGtleSB0byBkZWxldGUuXG4gICAqL1xuICBkZWxldGVGaWVsZChrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5fbWFwW2tleV07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGZpZWxkIHRvIHRoaXMgbWFwLiBJZiBhIGtleTp2YWx1ZSBtYXBwaW5nIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGtleSwgaXQgaXMgcmVwbGFjZWQuXG4gICAqIDxwPlxuICAgKiBAZGVwcmVjYXRlZCBJZiA8Y29kZT50eXBlT3JGaWVsZDwvY29kZT4gaXMgYSB7QGxpbmsgc29sYWNlLlNEVEZpZWxkfSBpbnN0YW5jZSxcbiAgICogaXQgaXMgYWRkZWQgdG8gdGhlIG1hcC5cbiAgICpcbiAgICogVGhlIHByZWZlcnJlZCB1c2FnZSBpcyB0byBwYXNzIGEge0BsaW5rIHNvbGFjZS5TRFRGaWVsZFR5cGV9LCB0aGVuIHRoZSBBUEkgd2lsbCBjcmVhdGUgYVxuICAgKiBTRFRGaWVsZCBvZiB0aGlzIHR5cGUgdXNpbmcgPGNvZGU+dmFsdWU8L2NvZGU+IGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IGJ5IHdoaWNoIHRvIHN0b3JlIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtzb2xhY2UuU0RURmllbGR8c29sYWNlLlNEVEZpZWxkVHlwZX0gdHlwZU9yRmllbGQgQSBTRFRGaWVsZCBpbnN0YW5jZSBvciBTRFRGaWVsZFR5cGUuXG4gICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gd3JhcCBhcyBhbiBTRFRGaWVsZC5cbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBpZiB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0eXBlXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5TRFRVbnN1cHBvcnRlZFZhbHVlRXJyb3J9IGlmIHZhbHVlIGlzIG5vdCBpbiByYW5nZVxuICAgKiAgc3VwcG9ydGVkIGJ5IHRoZSBwbGF0Zm9ybS9ydW50aW1lXG4gICAqL1xuICBhZGRGaWVsZChrZXksIHR5cGVPckZpZWxkLCB2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlT3JGaWVsZCBpbnN0YW5jZW9mIFNEVEZpZWxkKSB7XG4gICAgICB0aGlzLl9tYXBba2V5XSA9IHR5cGVPckZpZWxkO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fbWFwW2tleV0gPSBTRFRGaWVsZC5jcmVhdGUodHlwZU9yRmllbGQsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnMgdG8gYWRkRmllbGQ6IGV4cGVjdGVkIFNEVEZpZWxkLCBvciB0eXBlIGFuZCB2YWx1ZScsXG4gICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0NPTkZMSUNUKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TRFRNYXBDb250YWluZXIgPSBTRFRNYXBDb250YWluZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL3NkdC1tYXAtY29udGFpbmVyLmpzIiwiY29uc3QgU0RURmllbGRMaWIgPSByZXF1aXJlKCcuL3NkdC1maWVsZCcpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUsIE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBEZWZpbmVzIGEgU3RydWN0dXJlZCBEYXRhIFR5cGUgKFNEVCkgc3RyZWFtIGNvbnRhaW5lci4gQSBzdHJlYW0gaXMgYW4gaXRlcmFibGUgY29sbGVjdGlvbiBvZlxuICoge0BsaW5rIHNvbGFjZS5TRFRGaWVsZH1zLlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBTRFRTdHJlYW1Db250YWluZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBbXTtcbiAgICB0aGlzLl93cml0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5fcmVhZFB0ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYXQgbGVhc3Qgb25lIG1vcmUge0BsaW5rIHNvbGFjZS5TRFRGaWVsZH1cbiAgICogYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlLCBpZiB0aGVyZSBpcyBhbiBhdmFpbGFibGUgZmllbGQgYXQgdGhlIHJlYWQgcG9pbnRlcjsgZmFsc2UsIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc05leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9zdHJlYW0ubGVuZ3RoID4gdGhpcy5fcmVhZFB0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGZpZWxkIGluIHRoZSBzdHJlYW0gYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIuXG4gICAqIElmIHRoZSBlbmQgb2YgdGhlIHN0cmVhbSBpcyByZWFjaGVkLCBpdCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICogQHJldHVybnMge3NvbGFjZS5TRFRGaWVsZH0gVGhlIG5leHQgZmllbGQgaW4gdGhlIHN0cmVhbS5cbiAgICovXG4gIGdldE5leHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9yZWFkUHQgPCB0aGlzLl9zdHJlYW0ubGVuZ3RoKSA/IHRoaXMuX3N0cmVhbVt0aGlzLl9yZWFkUHQrK10gOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV3aW5kcyB0aGUgcmVhZCBwb2ludGVyIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbS4gTm9ybWFsbHkgd2hlbiB7QGxpbmsgaGFzTmV4dH1cbiAgICogcmV0dXJucyBmYWxzZSwgYSBjbGllbnQgYXBwbGljYXRpb24gbXVzdCBjYWxsIHJld2luZCgpIHRvIHJlaXRlcmF0ZSBvdmVyIHRoZSBzdHJlYW0ncyBmaWVsZHMuXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdGhlIHN0cmVhbSBjYW5ub3QgYmUgcmV3b3VuZC5cbiAgICovXG4gIHJld2luZCgpIHtcbiAgICB0aGlzLl9yZWFkUHQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBTRFRGaWVsZCB0byB0aGUgc3RyZWFtLlxuICAgKiA8cD5cbiAgICogSWYgPGNvZGU+ZmllbGQ8L2NvZGU+IGlzIGEge0BsaW5rIHNvbGFjZS5TRFRGaWVsZH0sIHRoaXMgZmllbGQgaXMgYXBwZW5kZWQgdG8gdGhlIHN0cmVhbS5cbiAgICogPGJyPlxuICAgKiBJZiA8Y29kZT5maWVsZDwvY29kZT4gaXMgYSB7QGxpbmsgc29sYWNlLlNEVEZpZWxkVHlwZX0sXG4gICAqIHRoZW4gdGhlIEFQSSB3aWxsIGNyZWF0ZSBhIFNEVEZpZWxkIG9mIHRoaXNcbiAgICogdHlwZSB3aXRoIGEgdmFsdWUgb2YgPGNvZGU+b3B0VmFsdWU8L2NvZGU+IGFuZCBhcHBlbmQgdGhpcyBuZXcgU0RURmllbGQgdG9cbiAgICogdGhlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuU0RURmllbGR8c29sYWNlLlNEVEZpZWxkVHlwZX0gZmllbGQgVGhlIGZpZWxkIHRvIGFwcGVuZCB0byB0aGUgc3RyZWFtLlxuICAgKiBAcGFyYW0geyp9IFtvcHRWYWx1ZV0gVGhlIHZhbHVlIHRvIHdyYXAgYXMgYW4gU0RURmllbGQuXG4gICAqL1xuICAvKipcbiAgICogQXBwZW5kcyBhIGZpZWxkIHRvIHRoaXMgc3RyZWFtLlxuICAgKiA8cD5cbiAgICogQGRlcHJlY2F0ZWQgSWYgPGNvZGU+dHlwZU9yRmllbGQ8L2NvZGU+IGlzIGEge0BsaW5rIHNvbGFjZS5TRFRGaWVsZH0gaW5zdGFuY2UsXG4gICAqIGl0IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIFRoZSBwcmVmZXJyZWQgdXNhZ2UgaXMgdG8gcGFzcyBhIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlfSwgdGhlbiB0aGUgQVBJIHdpbGwgY3JlYXRlIGFcbiAgICogU0RURmllbGQgb2YgdGhpcyB0eXBlIHVzaW5nIDxjb2RlPnZhbHVlPC9jb2RlPiBhbmQgYXBwZW5kIHRoaXMgbmV3IFNEVEZpZWxkXG4gICAqIHRvIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLlNEVEZpZWxkfHNvbGFjZS5TRFRGaWVsZFR5cGV9IHR5cGVPckZpZWxkIEEgU0RURmllbGQgaW5zdGFuY2Ugb3IgU0RURmllbGRUeXBlLlxuICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIHdyYXAgYXMgYW4gU0RURmllbGQuXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdHlwZVxuICAgKiBAdGhyb3dzIHtzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yfSBpZiB2YWx1ZSBpcyBub3QgaW4gcmFuZ2VcbiAgICogIHN1cHBvcnRlZCBieSB0aGUgcGxhdGZvcm0vcnVudGltZVxuICAgKi9cbiAgYWRkRmllbGQodHlwZU9yRmllbGQsIHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZSkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVPckZpZWxkIGluc3RhbmNlb2YgU0RURmllbGRMaWIuU0RURmllbGQpIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5wdXNoKHR5cGVPckZpZWxkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fc3RyZWFtLnB1c2goU0RURmllbGRMaWIuU0RURmllbGQuY3JlYXRlKHR5cGVPckZpZWxkLCB2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCBwYXJhbWV0ZXJzIHRvIGFkZEZpZWxkOiBleHBlY3RlZCBTRFRGaWVsZCwgb3IgdHlwZSBhbmQgdmFsdWUnLFxuICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuU0RUU3RyZWFtQ29udGFpbmVyID0gU0RUU3RyZWFtQ29udGFpbmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi9zZHQtc3RyZWFtLWNvbnRhaW5lci5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBlbnVtZXJhdGlvbiBvZiBwZWVyIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBDYXBhYmlsaXR5VHlwZSA9IHtcbiAgLyoqXG4gICAqIFBlZXIncyBzb2Z0d2FyZSBsb2FkIHZlcnNpb24uIFR5cGU6IHN0cmluZy5cbiAgICovXG4gIFBFRVJfU09GVFdBUkVfVkVSU0lPTjogICAgICAgIDAsXG4gIC8qKlxuICAgKiBQZWVyJ3Mgc29mdHdhcmUgcmVsZWFzZSBkYXRlLiBUeXBlOiBzdHJpbmcuXG4gICAqL1xuICBQRUVSX1NPRlRXQVJFX0RBVEU6ICAgICAgICAgICAxLFxuICAvKipcbiAgICogUGVlcidzIHBsYXRmb3JtLiBUeXBlOiBzdHJpbmcuXG4gICAqL1xuICBQRUVSX1BMQVRGT1JNOiAgICAgICAgICAgICAgICAyLFxuICAvKipcbiAgICogU3BlZWQgKGluIE1icHMpIG9mIHRoZSBwb3J0IHRoZSBjbGllbnQgY29ubmVjdHMgdG8uIFR5cGU6IG51bWJlci5cbiAgICovXG4gIFBFRVJfUE9SVF9TUEVFRDogICAgICAgICAgICAgIDMsXG4gIC8qKlxuICAgKiBUeXBlIG9mIHRoZSBwb3J0IHRoZSBjbGllbnQgaGFzIGNvbm5lY3RlZCB0byAoY3VycmVudGx5IDA6IEV0aGVybmV0KS4gVHlwZTogbnVtYmVyLlxuICAgKi9cbiAgUEVFUl9QT1JUX1RZUEU6ICAgICAgICAgICAgICAgNCxcbiAgLyoqXG4gICAqIE1heGltdW0gc2l6ZSBvZiBhIERpcmVjdCBtZXNzYWdlIChpbiBieXRlcyksIGluY2x1ZGluZyBhbGwgb3B0aW9uYWwgbWVzc2FnZSBoZWFkZXJzIGFuZCBkYXRhLlxuICAgKiBUeXBlOiBudW1iZXIuXG4gICAqL1xuICBNQVhfRElSRUNUX01TR19TSVpFOiAgICAgICAgICA1LFxuICAvKipcbiAgICogUGVlcidzIHJvdXRlciBuYW1lLiBUeXBlOiBzdHJpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgaXMgdXNlZnVsIHdoZW4gc2VuZGluZyBTRU1QIHJlcXVlc3RzIHRvIGEgcGVlcidzIFNFTVAgdG9waWMsIHdoaWNoIG1heSBiZVxuICAgKiBjb25zdHJ1Y3RlZCBhcyBgI1AyUC9yb3V0ZXJuYW1lLyNjbGllbnQvU0VNUGAuXG4gICAqL1xuICBQRUVSX1JPVVRFUl9OQU1FOiAgICAgICAgICAgICA2LFxuICAvKipcbiAgICogUGVlciBzdXBwb3J0cyBtZXNzYWdlIGVsaWRpbmcuIFR5cGU6IGJvb2xlYW4uXG4gICAqL1xuICBNRVNTQUdFX0VMSURJTkc6ICAgICAgICAgICAgICA3LFxuICAvKipcbiAgICogUGVlciBzdXBwb3J0cyBOb0xvY2FsIG9wdGlvbiAoY2xpZW50IG1heSBhdm9pZCByZWNlaXZpbmcgbWVzc2FnZXMgcHVibGlzaGVkIGJ5IGl0c2VsZikuXG4gICAqL1xuICBOT19MT0NBTDogICAgICAgICAgICAgICAgICAgICA4LFxuICAvKipcbiAgICogUGVlciBzdXBwb3J0cyBHdWFyYW50ZWVkIE1lc3NhZ2UgQ29uc3VtZXIgY29ubmVjdGlvbnMgZm9yIHJlY2VpdmluZyBndWFyYW50ZWVkIG1lc3NhZ2VzLlxuICAgKi9cbiAgR1VBUkFOVEVFRF9NRVNTQUdFX0NPTlNVTUU6ICAgOSxcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgdGVtcG9yYXJ5IGVuZHBvaW50cy5cbiAgICovXG4gIFRFTVBPUkFSWV9FTkRQT0lOVDogICAgICAgICAgIDEwLFxuICAvKipcbiAgICogUGVlciBzdXBwb3J0cyBHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaGVyIGNvbm5lY3Rpb25zIGZvciBzZWRuaW5nIGd1YXJhbnRlZWQgbWVzc2FnZXMuXG4gICAqL1xuICBHVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSDogICAxMSxcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgR3VhcmFudGVlZCBNZXNzYWdlcyBCcm93c2VyIGNvbm5lY3Rpb25zIGZvciByZWNlaXZpbmcgZ3VhcmFudGVlZCBtZXNzYWdlc1xuICAgKi9cbiAgR1VBUkFOVEVFRF9NRVNTQUdFX0JST1dTRTogICAgMTIsXG4gIC8qKlxuICAgKiBQZWVyIHN1cHBvcnRzIGNyZWF0aW5nL21vZGlmeS9kaXNwb3NpbmcgZW5kcG9pbnRzLlxuICAgKi9cbiAgRU5EUE9JTlRfTUdNVDogICAgICAgICAgICAgICAgMTMsXG4gIC8qKlxuICAgKiBQZWVyIHN1cHBvcnRzIHNlbGVjdG9ycyBvbiBHdWFyYW50ZWVkIE1lc3NhZ2UgQ29uc3VtZXJzLlxuICAgKi9cbiAgU0VMRUNUT1I6ICAgICAgICAgICAgICAgICAgICAgMTQsXG4gIC8qKlxuICAgKiBNYXhpbXVtIHNpemUgb2YgYSBEaXJlY3QgbWVzc2FnZSAoaW4gYnl0ZXMpLCBpbmNsdWRpbmcgYWxsIG9wdGlvbmFsIG1lc3NhZ2UgaGVhZGVycyBhbmQgZGF0YS5cbiAgICogVHlwZTogbnVtYmVyLlxuICAgKi9cbiAgTUFYX0dVQVJBTlRFRURfTVNHX1NJWkU6ICAgICAgMTUsXG4gIC8qKlxuICAgKiBQZWVyIHN1cHBvcnRzIEd1YXJhbnRlZWQgTWVzc2FnaW5nIENvbnN1bWVyIHN0YXRlIGNoYW5nZSB1cGRhdGVzLiBUeXBlOiBib29sZWFuXG4gICAqL1xuICBBQ1RJVkVfQ09OU1VNRVJfSU5ESUNBVElPTjogICAxNixcbiAgLyoqXG4gICAqIFBlZXIgYWNjZXB0cyBjb21wcmVzc2VkIChERUZMQVRFKSBkYXRhLiBUeXBlOiBib29sZWFuLlxuICAgKi9cbiAgQ09NUFJFU1NJT046ICAgICAgICAgICAgICAgICAgMTcsXG4gIC8qKlxuICAgKiBQZWVyIHN1cHBvcnRzIEd1YXJhbnRlZWQgTWVzc2FnaW5nIGN1dC10aHJvdWdoLiBUeXBlOiBib29sZWFuXG4gICAqL1xuICBDVVRfVEhST1VHSDogICAgICAgICAgICAgICAgICAxOCxcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgcHJvdmlzaW9uZWQgcXVldWUgYW5kIHRvcGljLWVuZHBvaW50IGRpc2NhcmQgYmVoYXZpb3IuIFR5cGU6IGJvb2xlYW5cbiAgICovXG4gIEVORFBPSU5UX0RJU0NBUkRfQkVIQVZJT1I6ICAgIDE5LFxuICAvKipcbiAgICogUGVlciBzdXBwb3J0cyBHdWFyYW50ZWVkIE1lc3NhZ2luZyBtZXNzYWdlIFRUTCBhbmQgRGVhZC1NZXNzYWdlIFF1ZXVlcy4gVHlwZTogYm9vbGVhblxuICAgKi9cbiAgRU5EUE9JTlRfTUVTU0FHRV9UVEw6ICAgICAgICAgMjAsXG4gIC8qKlxuICAgKiBQZWVyIGFjY2VwdHMgSk5ESSBxdWVyaWVzLiBUeXBlOiBib29sZWFuLlxuICAgKi9cbiAgSk5ESTogICAgICAgICAgICAgICAgICAgICAgICAgMjEsXG4gIC8qKlxuICAgKiBQZWVyIHN1cHBvcnRzIHBlciB0b3BpYyBzZXF1ZW5jZSBudW1iZXJpbmcgZm9yIEd1YXJhbnRlZWQgTWVzc2FnaW5nIG1lc3NhZ2VzLiBUeXBlOiBib29sZWFuXG4gICAqL1xuICBQRVJfVE9QSUNfU0VRVUVOQ0VfTlVNQkVSSU5HOiAyMixcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgUXVldWVTdWJzY3JpcHRpb25BZGQgZm9yIG1hbmFnaW5nIHN1YnNjcmlwdGlvbnMgb24gcXVldWUgZW5kcG9pbnRzLlxuICAgKiBUeXBlOiBib29sZWFuXG4gICAqL1xuICBRVUVVRV9TVUJTQ1JJUFRJT05TOiAgICAgICAgICAyMyxcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgYWRkL3JlbW92ZSBzdWJzY3JpcHRpb25zIGZvciBhIHNwZWNpZmllZCBjbGllbnROYW1lLiBUeXBlOiBib29sZWFuXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fTUFOQUdFUjogICAgICAgICAyNCxcbiAgLyoqXG4gICAqIFBlZXIgc3VwcG9ydHMgdHJhbnNhY3RlZCBzZXNzaW9ucy4gVHlwZTogYm9vbGVhbi5cbiAgICovXG4gIFRSQU5TQUNURURfU0VTU0lPTjogICAgICAgICAgIDI1LFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2FwYWJpbGl0eVR5cGUgPSBFbnVtLm5ldyhDYXBhYmlsaXR5VHlwZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9jYXBhYmlsaXR5LXR5cGVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuXG4vKipcbiAqIEBjYWxsYmFjayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZXMuc2Vzc2lvbkV2ZW50XG4gKiBAZnVuY3Rpb25cbiAqIEB0aGlzIHtzb2xhY2UuU2Vzc2lvbn0gVGhlIG1lc3NhZ2UgY29uc3VtZXIgZm9yIHRoZSBldmVudFxuICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbkV2ZW50fHNvbGFjZS5PcGVyYXRpb25FcnJvcn0gZXZlbnQgVGhlIGV2ZW50LiBJZiB0aGUgZXZlbnQgaXMgYW5cbiAqICBlcnJvciwgdGhlIGV2ZW50IHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIHNvbGFjZS5PcGVyYXRpb25FcnJvcn0gYnV0IHdpbGwgYWxzbyBiZVxuICogIGludGVyZmFjZS1jb21wYXRpYmxlIHdpdGgge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnR9LlxuICovXG5cblxuLyoqXG4gKiBBbiBhdHRyaWJ1dGUgb2Yge0BsaW5rIFNlc3Npb25FdmVudH0uIFRoaXMgZW51bWVyYXRpb24gcmVwcmVzZW50cyB0aGVcbiAqIGRpZmZlcmVudCBldmVudHMgZW1pdHRlZCBieSB7QGxpbmsgU2Vzc2lvbn0gdGhyb3VnaCB0aGUgc2Vzc2lvbiBldmVudFxuICogY2FsbGJhY2suXG4gKlxuICogV2hlbiBhIHNlc3Npb24gaXMgbm8gbG9uZ2VyIGluIGEgdXNhYmxlIHN0YXRlLCB0aGUgQVBJIHRlYXJzIGRvd24gdGhlIHVuZGVybHlpbmdcbiAqIGNvbm5lY3Rpb24gYW5kIG5vdGlmaWVzIHRoZSBhcHBsaWNhdGlvbiB3aXRoIG9uZSBvZiB0aGUgZm9sbG93aW5nIHNlc3Npb24gZXZlbnRzOlxuICogICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI2V2ZW50OkRPV05fRVJST1J9XG4gKiAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUjZXZlbnQ6Q09OTkVDVF9GQUlMRURfRVJST1J9XG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgU2Vzc2lvbkV2ZW50Q29kZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBTZXNzaW9uIGlzIHJlYWR5IHRvIHNlbmQvcmVjZWl2ZSBtZXNzYWdlcyBhbmQgcGVyZm9ybSBjb250cm9sIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEF0IHRoaXMgcG9pbnQgdGhlIHRyYW5zcG9ydCBzZXNzaW9uIGlzIHVwLCB0aGUgU2Vzc2lvbiBoYXMgbG9nZ2VkIGluLCBhbmQgdGhlXG4gICAqIFAyUEluYm94IHN1YnNjcmlwdGlvbiBpcyBhZGRlZC5cbiAgICpcbiAgICogVGhlIHNlc3Npb24gaXMgZXN0YWJsaXNoZWQuXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNVUF9OT1RJQ0VcbiAgICovXG4gIFVQX05PVElDRTogICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIHdhcyBlc3RhYmxpc2hlZCBhbmQgdGhlbiB3ZW50IGRvd24uXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNET1dOX0VSUk9SXG4gICAqIEBwYXJhbSB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBlcnJvciBUaGUgZGV0YWlscyByZWxhdGVkIHRvIHRoZSBzZXNzaW9uIGZhaWx1cmUuXG4gICAqL1xuICBET1dOX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiBhdHRlbXB0ZWQgdG8gY29ubmVjdCBidXQgd2FzIHVuc3VjY2Vzc2Z1bC5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI0NPTk5FQ1RfRkFJTEVEX0VSUk9SXG4gICAqIEBwYXJhbSB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBlcnJvciBUaGUgZGV0YWlscyByZWxhdGVkIHRvIHRoZSBmYWlsZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKi9cbiAgQ09OTkVDVF9GQUlMRURfRVJST1I6ICAgICAgICAgICAgICAyLFxuICAvKipcbiAgICogVGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciByZWplY3RlZCBhIHB1Ymxpc2hlZCBtZXNzYWdlLlxuICAgKiBAZXZlbnQgc29sYWNlLlNlc3Npb25FdmVudENvZGUjUkVKRUNURURfTUVTU0FHRV9FUlJPUlxuICAgKiBAcGFyYW0ge3NvbGFjZS5SZXF1ZXN0RXJyb3J9IGVycm9yIFRoZSBkZXRhaWxzIHJlbGF0ZWQgdG8gdGhlIHJlamVjdGVkIG1lc3NhZ2UuXG4gICAqL1xuICBSRUpFQ1RFRF9NRVNTQUdFX0VSUk9SOiAgICAgICAgICAgIDQsXG4gIC8qKlxuICAgKiBUaGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIHJlamVjdGVkIGEgc3Vic2NyaXB0aW9uIChhZGQgb3IgcmVtb3ZlKS5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1NVQlNDUklQVElPTl9FUlJPUlxuICAgKiBAcGFyYW0ge3NvbGFjZS5SZXF1ZXN0RXJyb3J9IGVycm9yIFRoZSBkZXRhaWxzIHJlbGF0ZWQgdG8gdGhlIGZhaWxlZCBzdWJzY3JpcHRpb24gdXBkYXRlLlxuICAgKi9cbiAgU1VCU0NSSVBUSU9OX0VSUk9SOiAgICAgICAgICAgICAgICA1LFxuICAvKipcbiAgICogVGhlIHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSBvcGVyYXRpb24gc3VjY2VlZGVkLlxuICAgKiBAZXZlbnQgc29sYWNlLlNlc3Npb25FdmVudENvZGUjU1VCU0NSSVBUSU9OX09LXG4gICAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb25FdmVudH0gZXZlbnQgVGhlIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgc3VjY2Vzc2Z1bCBzdWJzY3JpcHRpb24gdXBkYXRlLlxuICAgKi9cbiAgU1VCU0NSSVBUSU9OX09LOiAgICAgICAgICAgICAgICAgICA2LFxuICAvKipcbiAgICogVGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlcidzIFZpcnR1YWwgUm91dGVyIE5hbWUgY2hhbmdlZCBkdXJpbmcgYSByZWNvbm5lY3Qgb3BlcmF0aW9uLlxuICAgKiBAZXZlbnQgc29sYWNlLlNlc3Npb25FdmVudENvZGUjVklSVFVBTFJPVVRFUl9OQU1FX0NIQU5HRURcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbkV2ZW50fSBldmVudCBJbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBldmVudC5cbiAgICovXG4gIFZJUlRVQUxST1VURVJfTkFNRV9DSEFOR0VEOiAgICAgICAgNyxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEEgcmVxdWVzdCB3YXMgYWJvcnRlZCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGJlaW5nIGRpc2Nvbm5lY3RlZC5cbiAgICogVXNlIHtAbGluayBzb2xhY2UuUmVxdWVzdEZhaWxFdmVudH0gaW5zdGVhZC5cbiAgICovXG4gIFJFUVVFU1RfQUJPUlRFRDogICAgICAgICAgICAgICAgICAgOCxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoZSBldmVudCByZXByZXNlbnRzIGEgdGltZWQtb3V0IHJlcXVlc3QgQVBJIGNhbGwuXG4gICAqIFVzZSB7QGxpbmsgc29sYWNlLlJlcXVlc3RGYWlsRXZlbnR9IGluc3RlYWQuXG4gICAqL1xuICBSRVFVRVNUX1RJTUVPVVQ6ICAgICAgICAgICAgICAgICAgIDksXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgcmVwcmVzZW50cyBhIHN1Y2Nlc3NmdWwgdXBkYXRlIG9mIGEgbXV0YWJsZSBzZXNzaW9uIHByb3BlcnR5LlxuICAgKiBAZXZlbnQgc29sYWNlLlNlc3Npb25FdmVudENvZGUjUFJPUEVSVFlfVVBEQVRFX09LXG4gICAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb25FdmVudH0gZXZlbnQgSW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgc3VjY2Vzc2Z1bCBwcm9wZXJ0eSB1cGRhdGUuXG4gICAqL1xuICBQUk9QRVJUWV9VUERBVEVfT0s6ICAgICAgICAgICAgICAgIDEwLFxuICAvKipcbiAgICogVGhlIGV2ZW50IHJlcHJlc2VudHMgYSBmYWlsZWQgdXBkYXRlIG9mIGEgbXV0YWJsZSBzZXNzaW9uIHByb3BlcnR5LlxuICAgKiBAZXZlbnQgc29sYWNlLlNlc3Npb25FdmVudENvZGUjUFJPUEVSVFlfVVBEQVRFX0VSUk9SXG4gICAqIEBwYXJhbSB7c29sYWNlLlJlcXVlc3RFcnJvcn0gZXJyb3IgVGhlIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgZmFpbGVkIHByb3BlcnR5IHVwZGF0ZS5cbiAgICovXG4gIFBST1BFUlRZX1VQREFURV9FUlJPUjogICAgICAgICAgICAgMTEsXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiB0cmFuc3BvcnQgY2FuIGFjY2VwdCBkYXRhIGFnYWluLiAgVGhpcyBldmVudCB3aWxsIG9jY3VyIGFmdGVyIGFuXG4gICAqIHtAbGluayBzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IGlzIHRocm93biBmcm9tIGFuIEFQSSBjYWxsIHdpdGggYSBzdWJjb2RlIG9mXG4gICAqIHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOU1VGRklDSUVOVF9TUEFDRX0gdG8gaW5kaWNhdGUgdGhlIG9wZXJhdGlvbiBjYW4gYmUgcmV0cmllZC5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI0NBTl9BQ0NFUFRfREFUQVxuICAgKi9cbiAgQ0FOX0FDQ0VQVF9EQVRBOiAgICAgICAgICAgICAgICAgICAxMyxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIGNvbm5lY3Qgb3BlcmF0aW9uIGZhaWxlZCwgb3IgdGhlIHNlc3Npb24gdGhhdCB3YXMgb25jZSB1cCxcbiAgICogaXMgbm93IGRpc2Nvbm5lY3RlZC5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI0RJU0NPTk5FQ1RFRFxuICAgKi9cbiAgRElTQ09OTkVDVEVEOiAgICAgICAgICAgICAgICAgICAgICAxNCxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIGhhcyBnb25lIGRvd24sIGFuZCBhbiBhdXRvbWF0aWMgcmVjb25uZWN0aW9uIGF0dGVtcHQgaXMgaW4gcHJvZ3Jlc3MuXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNSRUNPTk5FQ1RJTkdfTk9USUNFXG4gICAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb25FdmVudH0gZXZlbnQgVGhlIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgY2F1c2Ugb2YgdGhlIGNvbm5lY3Rpb25cbiAgICogICAgaW50ZXJydXB0aW9uLlxuICAgKi9cbiAgUkVDT05ORUNUSU5HX05PVElDRTogICAgICAgICAgICAgICAyMixcbiAgLyoqXG4gICAqIFRoZSBhdXRvbWF0aWMgcmVjb25uZWN0IG9mIHRoZSBTZXNzaW9uIHdhcyBzdWNjZXNzZnVsLCBhbmQgdGhlIHNlc3Npb24gaXMgZXN0YWJsaXNoZWQgYWdhaW4uXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNSRUNPTk5FQ1RFRF9OT1RJQ0VcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbkV2ZW50fSBldmVudCBUaGUgZGV0YWlscyByZWxhdGVkIHRvIHRoZSByZS1lc3RhYmxpc2htZW50IG9mIHRoZVxuICAgKiAgICBjb25uZWN0aW9uLlxuICAgKi9cbiAgUkVDT05ORUNURURfTk9USUNFOiAgICAgICAgICAgICAgICAyMyxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIGhhcyBhdXRvbWF0aWNhbGx5IHJlY292ZXJlZCBhZnRlciB0aGUgR3VhcmFudGVlZCBNZXNzYWdlIHB1Ymxpc2hlclxuICAgKiBmYWlsZWQgdG8gcmVjb25uZWN0LlxuICAgKiBNZXNzYWdlcyBzZW50IGJ1dCBub3QgYWNrbm93bGVkZ2VkIGFyZSBiZWluZyByZW51bWJlcmVkIGFuZCByZXRyYW5zbWl0dGVkLlxuICAgKiBTb21lIG1lc3NhZ2VzIG1heSBiZSBkdXBsaWNhdGVkIGluIHRoZSBzeXN0ZW0uXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNSRVBVQkxJU0hJTkdfVU5BQ0tFRF9NRVNTQUdFU1xuICAgKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uRXZlbnR9IGV2ZW50IFRoZSBkZXRhaWxzIHJlbGF0ZWQgdG8gdGhlIHJlcHVibGlzaGluZyBvZiBtZXNzYWdlcyBvbiB0aGVcbiAgICogICAgc2Vzc2lvbi4gIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50I2luZm9TdHJ9IHdpbGwgaW5kaWNhdGUgdGhlIG51bWJlciBvZiBtZXNzYWdlcyBiZWluZ1xuICAgKiAgICByZXB1Ymxpc2hlZCwgd2hpY2ggaXMgYW4gdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBtZXNzYWdlcyB0aGF0IGNvdWxkIGJlIGR1cGxpY2F0ZWQgZHVlXG4gICAqICAgIHRvIHRoaXMgYWN0aW9uLlxuICAgKi9cbiAgUkVQVUJMSVNISU5HX1VOQUNLRURfTUVTU0FHRVM6ICAgICAyNCxcbiAgLyoqXG4gICAqIEEgbWVzc2FnZSB3YXMgYWNrbm93bGVkZ2VkIGJ5IHRoZSByb3V0ZXIuXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNBQ0tOT1dMRURHRURfTUVTU0FHRVxuICAgKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uRXZlbnR9IGV2ZW50IEFsbG93cyB0aGUgYWNrbm93bGVkZ2VtZW50IHRvIGJlIGNvcnJlbGF0ZWQgdG8gdGhlIHNlbnRcbiAgICogICAgbWVzc2FnZS5cbiAgICovXG4gIEFDS05PV0xFREdFRF9NRVNTQUdFOiAgICAgICAgICAgICAgMjUsXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliaW5nIHRoZSB0b3BpYyBmcm9tIHRoZSBEdXJhYmxlIFRvcGljIEVuZHBvaW50IHN1Y2NlZWRlZC5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1VOU1VCU0NSSUJFX1RFX1RPUElDX09LXG4gICAqL1xuICBVTlNVQlNDUklCRV9URV9UT1BJQ19PSzogICAgICAgICAgIDI2LFxuICAvKipcbiAgICogVW5zdWJzY3JpYmluZyB0aGUgdG9waWMgZnJvbSB0aGUgRHVyYWJsZSBUb3BpYyBFbmRwb2ludCBmYWlsZWQuXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNVTlNVQlNDUklCRV9URV9UT1BJQ19FUlJPUlxuICAgKiBAcGFyYW0ge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gZXJyb3IgVGhlIGRldGFpbHMgcmVsYXRlZCB0byB0aGUgZmFpbGVkIGF0dGVtcHQgdG8gcmVtb3ZlIHRoZVxuICAgKiAgICBzdWJzY3JpcHRpb24gZnJvbSBhIHRvcGljIGVuZHBvaW50LlxuICAgKi9cbiAgVU5TVUJTQ1JJQkVfVEVfVE9QSUNfRVJST1I6ICAgICAgICAyNyxcbiAgLyoqXG4gICAqIEEgRGlyZWN0IG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIG9uIHRoZSBzZXNzaW9uLiBUaGlzIGV2ZW50IGNvZGUgaXMgb25seSB1c2VkXG4gICAqIG9uIHRoZSA8Yj5FdmVudEVtaXR0ZXI8L2I+IHNlc3Npb24gaW50ZXJmYWNlLiAgSWYgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgY2FsbGJhY2sgaW50ZXJmYWNlLFxuICAgKiBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQgdmlhIHRoZSBjYWxsYmFjayBwcm92aWRlZCBpbiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VSeENCSW5mb30uXG4gICAqIEBldmVudCBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNNRVNTQUdFXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgcmVjZWl2ZWQgb24gdGhlIHNlc3Npb24uXG4gICAqL1xuICBNRVNTQUdFOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4LFxuICAvKipcbiAgICogR3VhcmFudGVlZCBNZXNzYWdpbmcgUHVibGlzaGVyIGhhcyBiZWVuIGNsb3NlZCBieSB0aGUgU29sYWNlXG4gICAqIG1lc3NhZ2Ugcm91dGVyLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIGFuIG9wZXJhdG9yIGhhcyBkaXNhYmxlZCB0aGVcbiAgICogbWVzc2FnZSBzcG9vbC5cbiAgICogQGV2ZW50IHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI0dVQVJBTlRFRURfTUVTU0FHRV9QVUJMSVNIRVJfRE9XTlxuICAgKiBAcGFyYW0ge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gZXJyb3IgSW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgZXJyb3IuXG4gICAqL1xuICBHVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSEVSX0RPV046IDI5LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU2Vzc2lvbkV2ZW50Q29kZSA9IEVudW0ubmV3KFNlc3Npb25FdmVudENvZGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1ldmVudC1jb2Rlcy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogVHlwZSBtYWNoaW5nIFNNRiBlbmNvZGluZyB2YWx1ZVxuICogQGVudW0ge251bWJlcn1cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IENvbnRlbnRTdW1tYXJ5VHlwZSA9IHtcbiAgWE1MX01FVEE6ICAgICAgICAgIDAsXG4gIFhNTF9QQVlMT0FEOiAgICAgICAxLFxuICBCSU5BUllfQVRUQUNITUVOVDogMixcbiAgQ0lEX0xJU1Q6ICAgICAgICAgIDMsXG4gIEJJTkFSWV9NRVRBREFUQTogICA0LFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29udGVudFN1bW1hcnlUeXBlID0gRW51bS5uZXcoQ29udGVudFN1bW1hcnlUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvY29udGVudC1zdW1tYXJ5LXR5cGVzLmpzIiwiY29uc3QgeyBFcnJvclN1YmNvZGUsIE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgVHJhbnNwb3J0UmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtcmV0dXJuLWNvZGVzJyk7XG5cbi8vIFN0dWJzIGRvbid0IHVzZSB0aGlzXG4vKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vLyBTdHVicyBkZWNsYXJlIGFsbCBwYXJhbXNcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICpcbiAqIEJhc2UgY2xhc3MgZm9yIHZhcmlvdXMgdHJhbnNwb3J0c1xuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgVHJhbnNwb3J0QmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtVUkx9IHVybCBUaGUgVVJMIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRDQiBUaGUgY2FsbGJhY2sgdG8gbm90aWZ5IG9uIGV2ZW50c1xuICAgKiBAcGFyYW0ge1NNRkNsaWVudH0gY2xpZW50IFRoZSBTTUYgY2xpZW50IHRvIG5vdGlmeSBvbiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc3BvcnRQcm9wcyBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSB0cmFuc3BvcnRcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBbaW50ZXJjZXB0b3JdIFRoZSB0cmFuc3BvcnQgaW50ZXJjZXB0b3IgdG8gaW5zdGFsbFxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsLCBldmVudENCLCBjbGllbnQsIHRyYW5zcG9ydFByb3BzLCBpbnRlcmNlcHRvciA9IG51bGwpIHtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5fc3NsID0gVHJhbnNwb3J0QmFzZS51c2VTc2wodXJsKTtcbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5fZXZlbnRDQiA9IGV2ZW50Q0I7XG4gICAgdGhpcy5fcHJvcHMgPSB0cmFuc3BvcnRQcm9wcztcbiAgICB0aGlzLnNldEludGVyY2VwdG9yKGludGVyY2VwdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAqIFJldHVybnMgdHJhbnNwb3J0IHJldHVybiBjb2RlLCB0byBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBjb25uZWN0KCkgeyByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSzsgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydC5cbiAgICogUmV0dXJucyB0cmFuc3BvcnQgcmV0dXJuIGNvZGUsIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbW1lZGlhdGUgRGVzdHJveSBncmFjZWZ1bGx5IGlmIGZhbHNlLlxuICAgKiBAcGFyYW0gez9TdHJpbmd9IG1zZyBUaGUgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBvcGVyYXRpb24sIGlmIGFueS5cbiAgICogQHBhcmFtIHs/RXJyb3JTdWJjb2RlfSBzdWJjb2RlIFRoZSBzdWJjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9wZXJhdGlvbiwgaWYgYW55LlxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvblxuICAgKi9cbiAgZGVzdHJveShpbW1lZGlhdGUsIG1zZywgc3ViY29kZSkgeyByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSzsgfVxuXG4gIGZsdXNoKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGVuY29kZWQgU01GIG1lc3NhZ2VcbiAgICogUmV0dXJucyB0cmFuc3BvcnQgcmV0dXJuIGNvZGUsIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVuY29kZWQgU01GIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0gez9Cb29sZWFufSBbZm9yY2VBbGxvd0VucXVldWU9ZmFsc2VdIElmIHRydWUsIGRvIG5vdCBmYWlsIGR1ZSB0byB0cmFuc3BvcnQgYnVmZmVyIGZ1bGxcbiAgICogQHJldHVybnMge1RyYW5zcG9ydFJldHVybkNvZGV9IFRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIHNlbmQobWVzc2FnZSwgZm9yY2VBbGxvd0VucXVldWUgPSBmYWxzZSkgeyByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSzsgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UHJvdG9jb2x9IFJldHVybiB0cmFuc3BvcnQgcHJvdG9jb2wgaW4gdXNlXG4gICAqL1xuICBnZXRUcmFuc3BvcnRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHMudHJhbnNwb3J0UHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9TdHJpbmd9IFJldHVybiB0cmFuc3BvcnQgc2Vzc2lvbiBpbmZvcm1hdGlvbiBzdWNoIGFzIHNlc3Npb25JZFxuICAgKi9cbiAgZ2V0SW5mb1N0cigpIHsgcmV0dXJuIG51bGw7IH1cblxuICAvKipcbiAgICogQHJldHVybnMge1RyYW5zcG9ydENsaWVudFN0YXRzfSB0cmFuc3BvcnQgc3RhdGlzdGljc1xuICAgKi9cbiAgZ2V0Q2xpZW50U3RhdHMoKSB7IHJldHVybiBudWxsOyB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc3BvcnQgY2FuIGJlIGRvd25ncmFkZWQgdG8gdGhlIG5leHQgcHJvdG9jb2wuXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGRvd25ncmFkZSB0aGUgdHJhbnNwb3J0LCB0aGUgZXhpc3RpbmcgdHJhbnNwb3J0IGlzIGRlc3Ryb3llZCBhbmRcbiAgICogdGhlIG5ldyB0cmFuc3BvcnQgY29ubmVjdGlvbiBpbml0aWF0ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JTdWJjb2RlfSBzdWJjb2RlIFRoZSBzdWJjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJuIHRydWUgaWYgZG93bmdyYWRlIGlzIGFsbG93ZWQgYW5kIGhhcyBiZWVuIGluaXRpYXRlZDsgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBiZWdpbkRvd25ncmFkZShtc2csIHN1YmNvZGUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGludGVyY2VwdG9yIGZvciB0aGlzIHRyYW5zcG9ydC4gVGhpcyBvYmplY3QgaGFzIHRoZSBjaGFuY2VcbiAgICogdG8gaW50ZXJ2ZW5lIGJlZm9yZSBieXRlcyBhcmUgc2VudCBvciByZWNlaXZlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbnRlcmNlcHRvcl0gSWYgc2V0LCB0aGUgaW50ZXJjZXB0b3IgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldEludGVyY2VwdG9yKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHRoaXMuX2ludGVyY2VwdG9yKSB7XG4gICAgICAvLyBSZXNldCBvcmlnaW5hbCBjYWxsYmFja3NcbiAgICAgIGlmICh0aGlzLl9pbnRlcmNlcHRvci5yZW1vdmVkKSB0aGlzLl9pbnRlcmNlcHRvci5yZW1vdmVkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbnRlcmNlcHRvciA9IGludGVyY2VwdG9yO1xuICAgIGlmIChpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKGludGVyY2VwdG9yLmluc3RhbGxlZCkgaW50ZXJjZXB0b3IuaW5zdGFsbGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmdldFRyYW5zcG9ydFByb3RvY29sKCl9JHt0aGlzLl9zc2wgPyAnIChTU0wpJyA6ICcnfWA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIFVSTCByZXF1aXJlcyBTU0w7IGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyB1c2VTc2wodXJsKSB7XG4gICAgY29uc3QgdXJsUGFydHMgPSAodXJsIHx8ICcnKS5zcGxpdCgnOi8vJyk7XG4gICAgaWYgKHVybFBhcnRzLmxlbmd0aCA9PT0gMCB8fCBUcmFuc3BvcnRCYXNlLnZhbGlkU2NoZW1lcy5pbmRleE9mKHVybFBhcnRzWzBdKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgSW52YWxpZCB1cmwgXCIke3VybH1cIjogT25seSBbJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnRCYXNlLnZhbGlkU2NoZW1lcy5qb2luKCcsICcpfV0gVVJMIHNjaGVtZXMgYXJlIHN1cHBvcnRlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZVNTTCA9ICh1cmxQYXJ0c1swXSA9PT0gJ2h0dHBzJyB8fCB1cmxQYXJ0c1swXSA9PT0gJ3dzcycgfHwgdXJsUGFydHNbMF0gPT09ICd0Y3BzJyk7XG4gICAgcmV0dXJuIHVzZVNTTDtcbiAgfVxuXG59XG5cbi8qKlxuICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxuICovXG5UcmFuc3BvcnRCYXNlLnZhbGlkU2NoZW1lcyA9IFsnaHR0cCcsICdodHRwcycsICd3cycsICd3c3MnLCAndGNwJywgJ3RjcHMnXTtcblxubW9kdWxlLmV4cG9ydHMuVHJhbnNwb3J0QmFzZSA9IFRyYW5zcG9ydEJhc2U7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LWJhc2UuanMiLCJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBIZXggfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUgfSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LXNlc3Npb24tZXZlbnQtY29kZXMnKTtcblxuY29uc3QgeyBmb3JtYXRIZXhTdHJpbmcgfSA9IEhleDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBEZWZpbmVzIGEgVHJhbnNwb3J0IFNlc3Npb24gRXZlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHRzRXZlbnRDb2RlIFRoZSB7QGxpbmsgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZX0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluZm9TdHIgQW4gaW5mb3JtYXRpb25hbCBzdHJpbmdcbiAgICogQHBhcmFtIHs/TnVtYmVyfSByZXNwb25zZUNvZGUgVGhlIHJlc3BvbnNlIGNvZGUgZnJvbSB0aGUgcm91dGVyLCBpZiBhbnlcbiAgICogQHBhcmFtIHtFcnJvclN1YmNvZGV9IHN1YmNvZGUgVGhlIHtAbGluayBFcnJvclN1YmNvZGV9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZXNzaW9uSWQgVGhlIHNlc3Npb24gSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRzRXZlbnRDb2RlLCBpbmZvU3RyLCByZXNwb25zZUNvZGUsIHN1YmNvZGUsIHNlc3Npb25JZCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydEV2ZW50Q29kZSA9IHRzRXZlbnRDb2RlO1xuICAgIHRoaXMuX2luZm9TdHIgPSBpbmZvU3RyO1xuICAgIHRoaXMuX3Jlc3BvbnNlQ29kZSA9IHJlc3BvbnNlQ29kZTtcbiAgICB0aGlzLl9lcnJvclN1YmNvZGUgPSBzdWJjb2RlO1xuICAgIHRoaXMuX3NpZCA9IHNlc3Npb25JZDtcbiAgfVxuXG4gIC8vIFRyYW5zcG9ydFNlc3Npb25FdmVudCBmdW5jdGlvbnNcblxuICBnZXRUcmFuc3BvcnRFdmVudENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydEV2ZW50Q29kZTtcbiAgfVxuXG4gIGdldCB0cmFuc3BvcnRFdmVudENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydEV2ZW50Q29kZTtcbiAgfVxuXG4gIGdldEluZm9TdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5mb1N0cjtcbiAgfVxuXG4gIGdldCBpbmZvU3RyKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZvU3RyO1xuICB9XG5cbiAgZ2V0UmVzcG9uc2VDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlQ29kZTtcbiAgfVxuXG4gIGdldCByZXNwb25zZUNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlQ29kZTtcbiAgfVxuXG4gIGdldFN1YmNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JTdWJjb2RlO1xuICB9XG5cbiAgZ2V0IGVycm9yU3ViY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3JTdWJjb2RlO1xuICB9XG5cbiAgZ2V0U2Vzc2lvbklkKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb25JZDtcbiAgfVxuXG4gIGdldCBzZXNzaW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZDtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3RyYW5zcG9ydEV2ZW50Q29kZSc6IFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuZGVzY3JpYmUodGhpcy50cmFuc3BvcnRFdmVudENvZGUpLFxuICAgICAgJ2luZm9TdHInOiAgICAgICAgICAgIHRoaXMuaW5mb1N0cixcbiAgICAgICdyZXNwb25zZUNvZGUnOiAgICAgICB0aGlzLnJlc3BvbnNlQ29kZSxcbiAgICAgICdlcnJvclN1YmNvZGUnOiAgICAgICBFcnJvclN1YmNvZGUuZGVzY3JpYmUodGhpcy5lcnJvclN1YmNvZGUpLFxuICAgICAgJ3NpZCc6ICAgICAgICAgICAgICAgIHRoaXMuc2lkICYmIGZvcm1hdEhleFN0cmluZyh0aGlzLnNpZCkgfHwgJ04vQScsXG4gICAgfTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3QodGhpcyk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRTZXNzaW9uRXZlbnQgPSBUcmFuc3BvcnRTZXNzaW9uRXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1zZXNzaW9uLWV2ZW50LmpzIiwiY29uc3Qge1xuICBMT0dfSU5GTyxcbiAgTE9HX1dBUk4sXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBQcm9jZXNzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHRyYW5zcG9ydHNcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFRTSFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVNzbCBUcnVlIGlmIFNTTCBzaG91bGQgYmUgdXNlZFxuICAgKiBAcGFyYW0ge1RyYW5zcG9ydFByb3RvY29sfSB0cFByb3RvY29sIFRoZSBwcm90b2NvbCB0byB1c2UgZm9yIHRoaXMgc3RhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXhpdENhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBub3RpZnkgb24gZXhpdFxuICAgKiBAcGFyYW0gez9UU0hTdGF0ZX0gbmV4dFN0YXRlIFRoZSBUU0ggc3RhdGUgdG8gdXNlIG9uIGRvd25ncmFkZVxuICAgKi9cbiAgY29uc3RydWN0b3IodXNlU3NsLCB0cFByb3RvY29sLCBleGl0Q2FsbGJhY2ssIG5leHRTdGF0ZSkge1xuICAgIHRoaXMuX3NzbCA9ICEhdXNlU3NsO1xuICAgIHRoaXMuX3RyYW5zcG9ydFByb3RvY29sID0gdHBQcm90b2NvbDtcbiAgICB0aGlzLl9leGl0Q2FsbGJhY2sgPSBleGl0Q2FsbGJhY2s7XG4gICAgdGhpcy5fbmV4dFN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuX3Vuc3VwcG9ydGVkUnVudGltZU1lc3NhZ2UgPVxuICAgICAgYCR7dGhpcy5fdHJhbnNwb3J0UHJvdG9jb2x9IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBydW50aW1lOiAke1Byb2Nlc3MudXNlckFnZW50fWA7XG4gIH1cblxuICBnZXROZXh0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRTdGF0ZTtcbiAgfVxuXG4gIHNldE5leHRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICB0aGlzLl9uZXh0U3RhdGUgPSBuZXh0U3RhdGU7XG4gIH1cblxuICBnZXRUcmFuc3BvcnRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0UHJvdG9jb2w7XG4gIH1cblxuICBnZXRVc2VTc2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NzbDtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIG1lXG4gIHZhbGlkYXRlTGVnYWwoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb25FbnRlcigpIHtcbiAgICBpZiAoIXRoaXMudmFsaWRhdGVMZWdhbCgpKSB7XG4gICAgICBpZiAodGhpcy5fbmV4dFN0YXRlICYmIHRoaXMuX2V4aXRDYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9leGl0Q2FsbGJhY2sodGhpcy5fbmV4dFN0YXRlLCB0aGlzLl91bnN1cHBvcnRlZFJ1bnRpbWVNZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExPR19XQVJOKGAke3RoaXMuX3Vuc3VwcG9ydGVkUnVudGltZU1lc3NhZ2V9LCBubyBuZXh0IHN0YXRlLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlRG93bmdyYWRlKGVycikge1xuICAgIGlmICh0aGlzLl9uZXh0U3RhdGUgJiYgdGhpcy5fZXhpdENhbGxiYWNrKSB7XG4gICAgICBMT0dfSU5GTyhgQ29ubmVjdCBmYWlsZWQgKCR7ZXJyfSksIHRyeSBuZXh0IHN0YXRlLmApO1xuICAgICAgdGhpcy5fZXhpdENhbGxiYWNrKHRoaXMuX25leHRTdGF0ZSwgJ0Nvbm5lY3QgZmFpbGVkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTE9HX1dBUk4oYENvbm5lY3QgZmFpbGVkICgke2Vycn0pLCBubyBuZXh0IHN0YXRlLmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRQcm90b2NvbCArICh0aGlzLl9zc2wgPyAnIChTU0wpJyA6ICcnKTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLlRTSFN0YXRlID0gVFNIU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RzaC1zdGF0ZS5qcyIsImNvbnN0IEhUVFBMaWIgPSByZXF1aXJlKCcuL2h0dHAnKTtcbmNvbnN0IHsgV2ViU29ja2V0VHJhbnNwb3J0U2Vzc2lvbiB9ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQtdHJhbnNwb3J0LXNlc3Npb24nKTtcblxuY29uc3QgeyBIVFRQQ29ubmVjdGlvbiB9ID0gSFRUUExpYjtcblxuY29uc3QgV2ViVHJhbnNwb3J0Q2FwYWJpbGl0aWVzID0ge1xuICB3ZWJTb2NrZXQoKSB7IHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnRTZXNzaW9uLmJyb3dzZXJTdXBwb3J0c0JpbmFyeVdlYlNvY2tldHMoKTsgfSxcbiAgeGhyQmluYXJ5KCkgeyByZXR1cm4gSFRUUENvbm5lY3Rpb24uYnJvd3NlclN1cHBvcnRzWGhyQmluYXJ5KCk7IH0sXG4gIHN0cmVhbWluZygpIHsgcmV0dXJuIEhUVFBDb25uZWN0aW9uLmJyb3dzZXJTdXBwb3J0c1N0cmVhbWluZ1Jlc3BvbnNlKCk7IH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5XZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgPSBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi93ZWItdHJhbnNwb3J0LWNhcGFiaWxpdGllcy5qcyIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uVHlwZSB9ID0gcmVxdWlyZSgnLi9kZXN0aW5hdGlvbi10eXBlJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uVXRpbCB9ID0gcmVxdWlyZSgnLi9kZXN0aW5hdGlvbi11dGlsJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy4gVXNlcnMgc2hvdWxkIG9idGFpbiBhbiBpbnN0YW5jZXMgZnJvbVxuICogb25lIG9mIHRoZSBmb2xsb3dpbmc6PC9iPlxuICogKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnkuY3JlYXRlVG9waWNEZXN0aW5hdGlvbn1cbiAqICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LmNyZWF0ZUR1cmFibGVRdWV1ZURlc3RpbmF0aW9ufVxuICogKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lciNnZXREZXN0aW5hdGlvbn1cbiAqICoge0BsaW5rIHNvbGFjZS5TRFRGaWVsZCNnZXRWYWx1ZX0gd2hlbiB7QGxpbmsgc29sYWNlLlNEVEZpZWxkI2dldFR5cGV9IHJldHVybnNcbiAqICAge0BsaW5rIHNvbGFjZS5TRFRGaWVsZFR5cGUuREVTVElOQVRJT059LlxuICpcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGRlc3RpbmF0aW9uLlxuICpcbiAqIFB1Ymxpc2hlcnMgY2FuIHNlbmQgbWVzc2FnZXMgdG8gdG9waWNzIG9yIHF1ZXVlcywgdG8gd2hpY2ggc3Vic2NyaWJlcnMgY2FuIHN1YnNjcmliZSBvclxuICogYmluZC4gQSBEZXN0aW5hdGlvbiBzcGVjaWZpZXMgdGhlIHRhcmdldCBvZiBzdWNoIGFuIG9wZXJhdGlvbi5cbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgRGVzdGluYXRpb24ge1xuXG4gIC8qXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ3xzb2xhY2UuRGVzdGluYXRpb258T2JqZWN0fSBzcGVjIFRoZSBuYW1lIG9mIHRoZSBkZXN0aW5hdGlvbiwgb3IsIHRoZVxuICAgKiAgZGVzdGluYXRpb24gdG8gY29weS4gSWYgdGhpcyBpcyBhIHtAbGluayBzb2xhY2UuRGVzdGluYXRpb259IHRoZW4gYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlXG4gICAqICBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5EZXN0aW5hdGlvblR5cGV9IFt0eXBlPXNvbGFjZS5EZXN0aW5hdGlvblR5cGUuVG9waWNdIFRoZSB0eXBlIG9mIGRlc3RpbmF0aW9uXG4gICAqICB0byBjcmVhdGVcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgMTAuMCBBcHBsaWNhdGlvbnMgc2hvdWxkIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IuXG4gICAqICBVc2UgdGhlIGZhY3RvcnkgbWV0aG9kcyBvbiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3Rvcnl9LlxuICAgKiovXG4gIGNvbnN0cnVjdG9yKHNwZWMsIHR5cGUgPSBEZXN0aW5hdGlvblR5cGUuVE9QSUMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9uYW1lID0gc3BlYy5uYW1lO1xuICAgICAgdGhpcy5fdHlwZSA9IHNwZWMudHlwZTtcbiAgICAgIHRoaXMuX2J5dGVzID0gc3BlYy5ieXRlcztcbiAgICAgIHRoaXMuX29mZnNldCA9IHNwZWMub2Zmc2V0O1xuICAgICAgaWYgKHNwZWMuaXNWYWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5faXNWYWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1dpbGRjYXJkZWQgPSBzcGVjLmlzV2lsZGNhcmRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25hbWUgPSBzcGVjO1xuICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIERvbid0IHZhbGlkYXRlIGVuY29kaW5nIGZvciBkZXByZWNhdGVkIGNvbnN0cnVjdGlvbiBwYXRoLlxuICAgICAgLy8gVGhpcyBwYXRoIHdvdWxkIGhhdmUgbW9yZSByZXN0cmljdGlvbnMgbm93LCBhbmQgaXQgYWxsb3dzXG4gICAgICAvLyBzZGtwZXJmIGEgcGF0aCBmb3IgYXJiaXRyYXJ5IHRvcGljIGNvbnN0cnVjdGlvbi5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IERlc3RpbmF0aW9uVXRpbC5lbmNvZGUodHlwZSwgc3BlYyk7XG4gICAgICB0aGlzLl9ieXRlcyA9IHJlc3VsdC5ieXRlcztcbiAgICAgIHRoaXMuX29mZnNldCA9IHJlc3VsdC5vZmZzZXQ7XG4gICAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVzdGluYXRpb24gbmFtZSBzcGVjaWZpZWQgYXQgY3JlYXRpb24gdGltZS5cbiAgICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3NvbGFjZS5EZXN0aW5hdGlvblR5cGV9IFRoZSBkZXN0aW5hdGlvbiB0eXBlXG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzb2xhY2UuRGVzdGluYXRpb25UeXBlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFR5cGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBudWxsLXRlcm1pbmF0ZWQgVVRGLTggZW5jb2RlZCBkZXN0aW5hdGlvbiBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJ5dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ieXRlcztcbiAgfVxuICBnZXQgYnl0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qnl0ZXMoKTtcbiAgfVxuXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2Zmc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBwcm92aWRlcyB0aGUgbGVnYWN5IHZhbGlkYXRpb24gdGhhdCB3YXMgZG9uZSBwb3N0LWNyZWF0aW9uIGFuZCBpcyB1c2VkIGluIHNvbWUgY29kZSBwYXRoc1xuICAgKiBvbiB1c2UuICBJdCBpcyBwcmVmZXJyZWQgdG8gdXNlIG5vbi1kZXByZWNhdGVkIHdheXMgb2YgY3JlYXRpbmcgZGVzdGluYXRpb25zLCB3aGljaCBkb1xuICAgKiB2YWxpZGF0aW9uIG9uIGNyZWF0ZSBpbnN0ZWFkLlxuICAgKiBAdGhyb3dzIE9wZXJhdGlvbkVycm9yIGlmIHRoZSBkZXN0aW5hdGlvbiBpcyBub3QgdmFsaWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5faXNWYWxpZGF0ZWQpIHtcbiAgICAgIGlmICh0aGlzLl9lcnJvcikgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBlcnJvciwgaXNXaWxkY2FyZGVkIH0gPVxuICAgICAgRGVzdGluYXRpb25VdGlsLmxlZ2FjeVZhbGlkYXRlKHRoaXMudHlwZSwgdGhpcy5ieXRlcywgdGhpcy5uYW1lKTtcbiAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IHRydWU7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRoaXMuX2lzV2lsZGNhcmRlZCA9IGlzV2lsZGNhcmRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHJlYWxseSBvbmx5IHVzZWZ1bCBmb3IgdG9waWNzLiAgSWYgYSBxdWV1ZSBuYW1lIGNvbnRhaW5zIGEgd2lsZGNhcmRlZCBjb25zdHJ1Y3QsIGl0IGlzXG4gICAqIHVwIHRvIHRoZSByb3V0ZXIgd2hhdCB0byBkbyAtLSBpdCB3b3VsZCBlaXRoZXIgcmVqZWN0IGl0IG9yIHRyZWF0IHRoZSB3aWxkY2FyZCBhcyBsaXRlcmFsLiAgQnV0XG4gICAqIGl0IGlzIGluY2x1ZGVkIGhlcmUgZm9yIGFsbCBkZXN0aW5hdGlvbiB0eXBlcyBzaW5jZSB3ZSBoYXZlIHRoZSBpbmZvLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBuYW1lIHJlcHJlc2VudHMgYSB3aWxkY2FyZGVkIHRvcGljOyBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEB0aHJvd3Mge09wZXJhdGlvbkVycm9yfSBJZiB0aGUgZGVzdGluYXRpb24gaXMgbm90IHZhbGlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNXaWxkY2FyZGVkKCkge1xuICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICByZXR1cm4gdGhpcy5faXNXaWxkY2FyZGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgZ2VuZXJpYyBkZXNjcmlwdGlvbiBvZiB0aGUgRGVzdGluYXRpb24uXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCBmb3IgY29tcGFyaXNvblxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIGRlc3RpbmF0aW9uIGlzIHRoZSBzYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERlc3RpbmF0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMudG9TdHJpbmcoKS52YWx1ZU9mKCkgPT09IG90aGVyLnRvU3RyaW5nKCkudmFsdWVPZigpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5EZXN0aW5hdGlvbiA9IERlc3RpbmF0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBEZWZpbmVzIGFuIGVycm9yIHN1YmNvZGUgZW51bWVyYXRpb24gd2hpY2ggaXMgcmV0dXJuZWQgYXMgYSBwcm9wZXJ0eSBvZlxuICogdGhlIGVycm9ycy9leGNlcHRpb25zIHRocm93biBieSB0aGUgQVBJLiBUaGUgc3ViY29kZSBwcm92aWRlcyBtb3JlIGRldGFpbGVkXG4gKiBlcnJvciBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHN1YmNvZGVzIGNhbiBhcHBseSB0byBlcnJvciByZXNwb25zZXMgcmVzdWx0aW5nIGZyb21cbiAqIGFueSBBUEkgbWV0aG9kLlxuICogKiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFfVxuICogKiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1R9XG4gKiAqIHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVEVSTkFMX0VSUk9SfVxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IEVycm9yU3ViY29kZSA9IHtcbiAgLy8vLy8vLy8vLy8vL1xuICAvLyBTRVNTSU9OIC8vXG4gIC8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIEVycm9ycyB0aGF0IGRvIG5vdCBoYXZlIGEgcHJvcGVyIHN1YmNvZGUuXG4gICAqL1xuICBVTktOT1dOX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4RkZGRkZGRkYsXG4gIC8qKlxuICAgKiBObyBlcnJvciBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudC5cbiAgICovXG4gIE5PX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIGlzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgKi9cbiAgLy8gU0VTU0lPTl9BTFJFQURZX0NPTk5FQ1RFRDogMSxcbiAgLyoqXG4gICAqIFRoZSBzZXNzaW9uIGlzIG5vdCBjb25uZWN0ZWQuXG4gICAqL1xuICBTRVNTSU9OX05PVF9DT05ORUNURUQ6ICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gIC8qKlxuICAgKiBUaGUgcGVyZm9ybWVkIHNlc3Npb24gb3BlcmF0aW9uIGlzIGludmFsaWQgZ2l2ZW4gdGhlIHN0YXRlXG4gICAqIG9yIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHNlc3Npb24uXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgc29sYWNlLkVycm9yU3ViQ29kZS5JTlZBTElEX09QRVJBVElPTn1cbiAgICovXG4gIElOVkFMSURfU0VTU0lPTl9PUEVSQVRJT046ICAgICAgICAgICAgICAgICAgICAgMyxcbiAgLyoqXG4gICAqIFRoZSBwZXJmb3JtZWQgc2Vzc2lvbiBvcGVyYXRpb24gaXMgaW52YWxpZCBnaXZlbiB0aGUgc3RhdGVcbiAgICogb3IgY29uZmlndXJhdGlvbiBvZiB0aGUgc2Vzc2lvbi5cbiAgICovXG4gIElOVkFMSURfT1BFUkFUSU9OOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgLyoqXG4gICAqIEFuIEFQSSBjYWxsIGZhaWxlZCBkdWUgdG8gYSB0aW1lb3V0LlxuICAgKi9cbiAgVElNRU9VVDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAvLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNRVNTQUdFIFZQTiAvL1xuICAvLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogVGhlIE1lc3NhZ2UgVlBOIG5hbWUgY29uZmlndXJlZCBmb3IgdGhlIHNlc3Npb24gaXMgbm90XG4gICAqIGNvbmZpZ3VyZWQgdG8gYWxsb3cgYWNjZXNzIGZvciB0aGUgc2Vzc2lvbidzIHVzZXJuYW1lLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMyBNZXNzYWdlIFZQTiBOb3QgQWxsb3dlZFxuICAgKi9cbiAgTUVTU0FHRV9WUE5fTk9UX0FMTE9XRUQ6ICAgICAgICAgICAgICAgICAgICAgICA1LFxuICAvKipcbiAgICogVGhlIE1lc3NhZ2UgVlBOIG5hbWUgc2V0IGZvciB0aGUgc2Vzc2lvbiAob3IgdGhlIGRlZmF1bHQgVlBOIGlmIG5vbmVcbiAgICogd2FzIHNldCkgaXMgY3VycmVudGx5IHNodXRkb3duIG9uIHRoZSByb3V0ZXIuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIE1lc3NhZ2UgVlBOIFVuYXZhaWxhYmxlXG4gICAqL1xuICBNRVNTQUdFX1ZQTl9VTkFWQUlMQUJMRTogICAgICAgICAgICAgICAgICAgICAgIDYsXG4gIC8vLy8vLy8vLy8vL1xuICAvLyBDTElFTlQgLy9cbiAgLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBUaGUgdXNlcm5hbWUgZm9yIHRoZSBjbGllbnQgaXMgYWRtaW5pc3RyYXRpdmVseSBzaHV0ZG93blxuICAgKiBvbiB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMyBDbGllbnQgVXNlcm5hbWUgSXMgU2h1dGRvd25cbiAgICovXG4gIENMSUVOVF9VU0VSTkFNRV9JU19TSFVURE9XTjogICAgICAgICAgICAgICAgICAgNyxcbiAgLyoqXG4gICAqIFRoZSB1c2VybmFtZSBmb3IgdGhlIHNlc3Npb24gaGFzIG5vdCBiZWVuIHNldCBhbmQgZHluYW1pY1xuICAgKiBjbGllbnRzIGFyZSBub3QgYWxsb3dlZC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgRHluYW1pYyBDbGllbnRzIE5vdCBBbGxvd2VkXG4gICAqL1xuICBEWU5BTUlDX0NMSUVOVFNfTk9UX0FMTE9XRUQ6ICAgICAgICAgICAgICAgICAgIDgsXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiBpcyBhdHRlbXB0aW5nIHRvIHVzZSBhIGNsaWVudCBuYW1lIHRoYXQgaXNcbiAgICogaW4gdXNlIGJ5IGFub3RoZXIgY2xpZW50LCBhbmQgdGhlIHJvdXRlciBpcyBjb25maWd1cmVkIHRvIHJlamVjdCB0aGVcbiAgICogbmV3IHNlc3Npb24uXG4gICAqIEEgY2xpZW50IG5hbWUgY2Fubm90IGJlIHVzZWQgYnkgbXVsdGlwbGUgY2xpZW50cyBpbiB0aGUgc2FtZSBNZXNzYWdlXG4gICAqIFZQTi5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgQ2xpZW50IE5hbWUgQWxyZWFkeSBJbiBVc2VcbiAgICovXG4gIENMSUVOVF9OQU1FX0FMUkVBRFlfSU5fVVNFOiAgICAgICAgICAgICAgICAgICAgOSxcbiAgLyoqXG4gICAqIFRoZSBjbGllbnQgbmFtZSBjaG9zZW4gaGFzIGJlZW4gcmVqZWN0ZWQgYXMgaW52YWxpZCBieSB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMCBDbGllbnQgTmFtZSBQYXJzZSBFcnJvclxuICAgKi9cbiAgQ0xJRU5UX05BTUVfSU5WQUxJRDogICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgLyoqXG4gICAqIFRoZSBjbGllbnQgbG9naW4gaXMgbm90IGN1cnJlbnRseSBwb3NzaWJsZSBiZWNhdXNlIGEgcHJldmlvdXNcbiAgICogaW5zdGFuY2Ugb2Ygc2FtZSBjbGllbnQgd2FzIGJlaW5nIGRlbGV0ZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIFN1YnNjcmliZXIgRGVsZXRlIEluIFByb2dyZXNzXG4gICAqL1xuICBDTElFTlRfREVMRVRFX0lOX1BST0dSRVNTOiAgICAgICAgICAgICAgICAgICAgIDExLFxuICAvKipcbiAgICogVGhlIGNsaWVudCBsb2dpbiBpcyBub3QgY3VycmVudGx5IHBvc3NpYmxlIGJlY2F1c2UgdGhlIG1heGltdW1cbiAgICogbnVtYmVyIG9mIGFjdGl2ZSBjbGllbnRzIG9uIHJvdXRlciBoYXMgYWxyZWFkeSBiZWVuIHJlYWNoZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIFRvbyBNYW55IENsaWVudHNcbiAgICogICogNTAzIFRvbyBNYW55IENvbm5lY3Rpb25zIGZvciBWUE5cbiAgICovXG4gIFRPT19NQU5ZX0NMSUVOVFM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTIsXG4gIC8qKlxuICAgKiBUaGUgY2xpZW50IGNvdWxkIG5vdCBsb2cgaW50byB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMSBlcnJvciBjb2Rlc1xuICAgKiAgKiA0MDQgZXJyb3IgY29kZXNcbiAgICogICogRmFpbGVkIHRvIHNlbmQgYSBzZXNzaW9uIHNldHVwIG1lc3NhZ2UgaW4gdGhlIHRyYW5zcG9ydC5cbiAgICovXG4gIExPR0lOX0ZBSUxVUkU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMsXG4gIC8vLy8vLy8vLy9cbiAgLy8gVlJJRCAvL1xuICAvLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGNvbm5lY3QgdG8gdGhlIHdyb25nIElQIGFkZHJlc3Mgb25cbiAgICogdGhlIHJvdXRlciAobXVzdCB1c2UgQ1ZSSUQgaWYgY29uZmlndXJlZCksIG9yIHRoZSByb3V0ZXIgQ1ZSSUQgaGFzXG4gICAqIGNoYW5nZWQgYW5kIHRoaXMgd2FzIGRldGVjdGVkIG9uIHJlY29ubmVjdC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgSW52YWxpZCBWaXJ0dWFsIFJvdXRlciBBZGRyZXNzXG4gICAqL1xuICBJTlZBTElEX1ZJUlRVQUxfQUREUkVTUzogICAgICAgICAgICAgICAgICAgICAgIDE0LFxuICAvLy8vLy8vLy9cbiAgLy8gQUNMIC8vXG4gIC8vLy8vLy8vL1xuICAvKipcbiAgICogVGhlIGNsaWVudCBsb2dpbiB0byB0aGUgcm91dGVyIHdhcyBkZW5pZWQgYmVjYXVzZSB0aGVcbiAgICogSVAgYWRkcmVzcy9uZXRtYXNrIGNvbWJpbmF0aW9uIHVzZWQgZm9yIHRoZSBjbGllbnQgaXMgZGVzaWduYXRlZCBpbiB0aGVcbiAgICogQUNMIChBY2Nlc3MgQ29udHJvbCBMaXN0KSBwcm9maWxlIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGNsaWVudC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgRm9yYmlkZGVuXG4gICAqL1xuICBDTElFTlRfQUNMX0RFTklFRDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1LFxuICAvKipcbiAgICogQWRkaW5nIGEgc3Vic2NyaXB0aW9uIHdhcyBkZW5pZWQgYmVjYXVzZSBpdCBtYXRjaGVkIGFcbiAgICogc3Vic2NyaXB0aW9uIHRoYXQgd2FzIGRlZmluZWQgYXMgZGVuaWVkIG9uIHRoZSBBQ0wgKEFjY2VzcyBDb250cm9sIExpc3QpXG4gICAqIHByb2ZpbGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAzIFN1YnNjcmlwdGlvbiBBQ0wgRGVuaWVkXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fQUNMX0RFTklFRDogICAgICAgICAgICAgICAgICAgICAgIDE2LFxuICAvKipcbiAgICogQSBtZXNzYWdlIGNvdWxkIG5vdCBiZSBwdWJsaXNoZWQgYmVjYXVzZSBpdHMgdG9waWMgbWF0Y2hlZFxuICAgKiBhIHRvcGljIGRlZmluZWQgYXMgZGVuaWVkIG9uIHRoZSBBQ0wgKEFjY2VzcyBDb250cm9sIExpc3QpIHByb2ZpbGVcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAzIFB1Ymxpc2ggQUNMIERlbmllZFxuICAgKi9cbiAgUFVCTElTSF9BQ0xfREVOSUVEOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNyxcbiAgLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBWQUxJREFUSU9OIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIEFuIEFQSSBjYWxsIHdhcyBtYWRlIHdpdGggYW4gb3V0LW9mLXJhbmdlIHBhcmFtZXRlci5cbiAgICovXG4gIFBBUkFNRVRFUl9PVVRfT0ZfUkFOR0U6ICAgICAgICAgICAgICAgICAgICAgICAgMTgsXG4gIC8qKlxuICAgKiBBbiBBUEkgY2FsbCB3YXMgbWFkZSB3aXRoIGEgcGFyYW1ldGVyIGNvbWJpbmF0aW9uXG4gICAqIHRoYXQgaXMgbm90IHZhbGlkLlxuICAgKi9cbiAgUEFSQU1FVEVSX0NPTkZMSUNUOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOSxcbiAgLyoqXG4gICAqIEFuIEFQSSBjYWxsIHdhcyBtYWRlIHdpdGggYSBwYXJhbWV0ZXIgb2YgaW5jb3JyZWN0IHR5cGUuXG4gICAqL1xuICBQQVJBTUVURVJfSU5WQUxJRF9UWVBFOiAgICAgICAgICAgICAgICAgICAgICAgIDIwLFxuICAvLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gRkFUQUwgRVJST1JTIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogIEFuIEFQSSBjYWxsIGhhZCBhbiBpbnRlcm5hbCBlcnJvciAobm90IGFuIGFwcGxpY2F0aW9uIGZhdWx0KS5cbiAgICovXG4gIElOVEVSTkFMX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjEsXG4gIC8qKlxuICAgKiBBbiBBUEkgY2FsbCBmYWlsZWQgZHVlIHRvIGluc3VmZmljaWVudCBzcGFjZSBpbiB0aGUgdHJhbnNwb3J0XG4gICAqIGJ1ZmZlciB0byBhY2NlcHQgbW9yZSBkYXRhLiBBZnRlciBhbiBpbnN1ZmZpY2llbnQgc3BhY2UgZXJyb3IsIHRoZVxuICAgKiBsaXN0ZW5lcnMgb24gdGhlIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9XG4gICAqIGV2ZW50IGFyZSBub3RpZmllZCB3aGVuIGl0IGlzIHBvc3NpYmxlIHRvIHJldHJ5IHRoZSBmYWlsZWQgb3BlcmF0aW9uLlxuICAgKi9cbiAgSU5TVUZGSUNJRU5UX1NQQUNFOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMixcbiAgLyoqXG4gICAqIFRoZSBtZXNzYWdlIHJvdXRlciBoYXMgcmVqZWN0ZWQgdGhlIHJlcXVlc3QuIEFsbCBhdmFpbGFibGVcbiAgICogcmVzb3VyY2VzIG9mIHRoZSByZXF1ZXN0ZWQgdHlwZSBhcmUgaW4gdXNlLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMCBOb3QgRW5vdWdoIFNwYWNlXG4gICAqL1xuICBPVVRfT0ZfUkVTT1VSQ0VTOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIzLFxuICAvKipcbiAgICogQW4gQVBJIGNhbGwgZmFpbGVkIGR1ZSB0byBhIHByb3RvY29sIGVycm9yIHdpdGggdGhlIHJvdXRlclxuICAgKiAobm90IGFuIGFwcGxpY2F0aW9uIGZhdWx0KS5cbiAgICovXG4gIFBST1RPQ09MX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjQsXG4gIC8qKlxuICAgKiBBbiBBUEkgY2FsbCBmYWlsZWQgZHVlIHRvIGEgY29tbXVuaWNhdGlvbiBlcnJvci4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoZVxuICAgKiB0cmFuc3BvcnQgY29ubmVjdGlvbiB0byB0aGUgbWVzc2FnZSByb3V0ZXIgaGFzIGJlZW4gdW5leHBlY3RlZGx5IGNsb3NlZC5cbiAgICovXG4gIENPTU1VTklDQVRJT05fRVJST1I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMjUsXG4gIC8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gS0VFUCBBTElWRSAvL1xuICAvLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiBrZWVwLWFsaXZlIGRldGVjdGVkIGEgZmFpbGVkIHNlc3Npb24uXG4gICAqL1xuICBLRUVQX0FMSVZFX0ZBSUxVUkU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI2LFxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTUVTU0FHRSBSRUxBVEVEIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogQW4gYXR0ZW1wdCB3YXMgbWFkZSB0byB1c2UgYSB0b3BpYyB3aGljaCBpcyBsb25nZXJcbiAgICogdGhhbiB0aGUgbWF4aW11bSB0aGF0IGlzIHN1cHBvcnRlZC5cbiAgICovXG4gIC8vIFRPUElDX1RPT19MQVJHRTogMjcsXG4gIC8qKlxuICAgKiBBIHNlbmQgY2FsbCB3YXMgbWFkZSB0aGF0IGRpZCBub3QgaGF2ZSBhIHRvcGljIGluIGEgbW9kZVxuICAgKiB3aGVyZSBvbmUgaXMgcmVxdWlyZWQgKGZvciBleGFtcGxlLCBjbGllbnQgbW9kZSkuXG4gICAqL1xuICBUT1BJQ19NSVNTSU5HOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDI4LFxuICAvKipcbiAgICogIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gc2VuZCBhIG1lc3NhZ2Ugd2l0aCBhIHRvdGFsXG4gICAqIHNpemUgZ3JlYXRlciB0aGFuIHRoYXQgc3VwcG9ydGVkIGJ5IHRoZSBwcm90b2NvbC4gKD8/PylcbiAgICovXG4gIC8vICBNQVhfVE9UQUxfTVNHU0laRV9FWENFRURFRDogMjksXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIHNlbmQgYSBtZXNzYWdlIHdpdGggdXNlciBkYXRhIGxhcmdlclxuICAgKiB0aGFuIHRoZSBtYXhpbXVtIHRoYXQgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgLy8gVVNFUl9EQVRBX1RPT19MQVJHRTogMzAsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIHVzZSBhIHRvcGljIHdoaWNoIGhhcyBhIHN5bnRheCB0aGF0XG4gICAqIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAwIFRvcGljIFBhcnNlIEVycm9yXG4gICAqL1xuICBJTlZBTElEX1RPUElDX1NZTlRBWDogICAgICAgICAgICAgICAgICAgICAgICAgIDMxLFxuICAvKipcbiAgICogVGhlIGNsaWVudCBhdHRlbXB0ZWQgdG8gc2VuZCBhIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gdGhhdFxuICAgKiBzdXBwb3J0ZWQgYnkgdGhlIHJvdXRlci5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgRG9jdW1lbnQgSXMgVG9vIExhcmdlXG4gICAqICAqIDQwMCBNZXNzYWdlIFRvbyBMb25nXG4gICAqL1xuICBNRVNTQUdFX1RPT19MQVJHRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMyLFxuICAvKipcbiAgICogVGhlIHJvdXRlciBjb3VsZCBub3QgcGFyc2UgYW4gWE1MIG1lc3NhZ2UuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAwIFhNTCBQYXJzZSBFcnJvclxuICAgKi9cbiAgWE1MX1BBUlNFX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMyxcbiAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBTVUJTQ1JJUFRJT05TIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIFRoZSBjbGllbnQgYXR0ZW1wdGVkIHRvIGFkZCBhIHN1YnNjcmlwdGlvbiB0aGF0IGFscmVhZHlcbiAgICogZXhpc3RzLiBUaGlzIHN1YmNvZGUgaXMgb25seSByZXR1cm5lZCBpZiB0aGUgc2Vzc2lvbiBwcm9wZXJ0eVxuICAgKiAnSWdub3JlRHVwbGljYXRlU3Vic2NyaXB0aW9uRXJyb3InIGlzIG5vdCBlbmFibGVkLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqIDQwMCBTdWJzY3JpcHRpb24gQWxyZWFkeSBFeGlzdHMpXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fQUxSRUFEWV9QUkVTRU5UOiAgICAgICAgICAgICAgICAgIDM0LFxuICAvKipcbiAgICogVGhlIGNsaWVudCBhdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgc3Vic2NyaXB0aW9uIHdoaWNoIGRpZCBub3QgZXhpc3QuXG4gICAqIFRoaXMgc3ViY29kZSBpcyBvbmx5IHJldHVybmVkIGlmIHRoZSBzZXNzaW9uIHByb3BlcnR5XG4gICAqICdJZ25vcmVEdXBsaWNhdGVTdWJzY3JpcHRpb25FcnJvcicgaXMgbm90IGVuYWJsZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogNDAwIFN1YnNjcmlwdGlvbiBOb3QgRm91bmQpXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fTk9UX0ZPVU5EOiAgICAgICAgICAgICAgICAgICAgICAgIDM1LFxuICAvKipcbiAgICogVGhlIGNsaWVudCBhdHRlbXB0ZWQgdG8gYWRkL3JlbW92ZSBhIHN1YnNjcmlwdGlvbiB0aGF0XG4gICAqIGlzIG5vdCB2YWxpZC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgU3Vic2NyaXB0aW9uIFBhcnNlIEVycm9yXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fSU5WQUxJRDogICAgICAgICAgICAgICAgICAgICAgICAgIDM2LFxuICAvKipcbiAgICogVGhlIHJvdXRlciByZWplY3RlZCBhIHN1YnNjcmlwdGlvbiBhZGQgb3IgcmVtb3ZlIHJlcXVlc3RcbiAgICogZm9yIGEgcmVhc29uIG5vdCBzZXBhcmF0ZWx5IGVudW1lcmF0ZWQuXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fRVJST1JfT1RIRVI6ICAgICAgICAgICAgICAgICAgICAgIDM3LFxuICAvKipcbiAgICogVGhlIGNsaWVudCBhdHRlbXB0ZWQgdG8gYWRkIGEgc3Vic2NyaXB0aW9uIHRoYXRcbiAgICogZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIGFsbG93ZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAwIE1heCBOdW0gU3Vic2NyaXB0aW9ucyBFeGNlZWRlZFxuICAgKi9cbiAgU1VCU0NSSVBUSU9OX1RPT19NQU5ZOiAgICAgICAgICAgICAgICAgICAgICAgICAzOCxcbiAgLyoqXG4gICAqICBUaGUgY2xpZW50IGF0dGVtcHRlZCB0byBhZGQgYSBzdWJzY3JpcHRpb24gd2hpY2ggYWxyZWFkeVxuICAgKiBleGlzdHMgYnV0IGl0IGhhcyBkaWZmZXJlbnQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgU3Vic2NyaXB0aW9uIEF0dHJpYnV0ZXMgQ29uZmxpY3QgV2l0aCBFeGlzdGluZyBTdWJzY3JpcHRpb25cbiAgICovXG4gIFNVQlNDUklQVElPTl9BVFRSSUJVVEVTX0NPTkZMSUNUOiAgICAgICAgICAgICAgMzksXG4gIC8qKlxuICAgKiBUaGUgY2xpZW50IGF0dGVtcHRlZCB0byBlc3RhYmxpc2ggYSBzZXNzaW9uIHdpdGggTm8gTG9jYWxcbiAgICogZW5hYmxlZCBhbmQgdGhlIGNhcGFiaWxpdHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgcm91dGVyLlxuICAgKi9cbiAgTk9fTE9DQUxfTk9UX1NVUFBPUlRFRDogICAgICAgICAgICAgICAgICAgICAgICA0MCxcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gVU5LTk9XTiBFUlJPUlMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgcmVqZWN0ZWQgYSBjb250cm9sIG1lc3NhZ2UgZm9yIGFub3RoZXIgcmVhc29uXG4gICAqIG5vdCBzZXBhcmF0ZWx5IGVudW1lcmF0ZWQuXG4gICAqL1xuICAvLyBDT05UUk9MX0VSUk9SX09USEVSOiA0MSxcbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgcmVqZWN0ZWQgYSBkYXRhIG1lc3NhZ2UgZm9yIGEgcmVhc29uXG4gICAqIG5vdCBzZXBhcmF0ZWx5IGVudW1lcmF0ZWQuXG4gICAqL1xuICBEQVRBX0VSUk9SX09USEVSOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQyLFxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFRSQU5TUE9SVCBFUlJPUlMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogRmFpbGVkIHRvIGNyZWF0ZSB0aGUgSFRUUCBjb25uZWN0aW9uLlxuICAgKi9cbiAgQ1JFQVRFX1hIUl9GQUlMRUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0MyxcbiAgLyoqXG4gICAqIEZhaWxlZCB0byBjcmVhdGUgdGhlIHRyYW5zcG9ydC5cbiAgICovXG4gIENPTk5FQ1RJT05fRVJST1I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNDQsXG4gIC8qKlxuICAgKiBGYWlsZWQgdG8gZGVjb2RlIHRoZSBkYXRhLlxuICAgKi9cbiAgREFUQV9ERUNPREVfRVJST1I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0NSxcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIFRoZSBzZXNzaW9uIHdhcyBpbmFjdGl2ZSBmb3IgdG9vIGxvbmcuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogKiA0MDAgSW5hY3Rpdml0eSBUaW1lb3V0XG4gICAqL1xuICBJTkFDVElWSVRZX1RJTUVPVVQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQ2LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogVGhlIHJvdXRlciBkb2VzIG5vdCBrbm93IHRoaXMgc2Vzc2lvbidzIGlkZW50aWZpZXIuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogKiA0MDAgVW5rbm93biBUcmFuc3BvcnQgU2Vzc2lvbiBJZGVudGZpZXJcbiAgICovXG4gIFVOS05PV05fVFJBTlNQT1JUX1NFU1NJT05fSUQ6ICAgICAgICAgICAgICAgICAgNDcsXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHN1YmNvZGUgaXMgbm90IHVzZWQgc2luY2UgMTAuMC4wLlxuICAgKiBHdWFyYW50ZWVkIE1lc3NhZ2VzICh3aXRoIGEgZGVsaXZlcnkgbW9kZSBvdGhlciB0aGFuIERJUkVDVCkgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqL1xuICBBRF9NRVNTQUdJTkdfTk9UX1NVUFBPUlRFRDogICAgICAgICAgICAgICAgICAgIDQ4LFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQ3JlYXRpbmcgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQgZmFpbGVkLlxuICAgKi9cbiAgQ1JFQVRFX1dFQlNPQ0tFVF9GQUlMRUQ6ICAgICAgICAgICAgICAgICAgICAgICA0OSxcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgdG8gcGVyZm9ybSBhbiBvcGVyYXRpb24gdXNpbmcgYSBWUE4gdGhhdCBpcyBjb25maWd1cmVkIHRvIGJlXG4gICAqIFNUQU5EQlkgZm9yIHJlcGxpY2F0aW9uLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICogNDAzIFJlcGxpY2F0aW9uIElzIFN0YW5kYnlcbiAgICovXG4gIFJFUExJQ0FUSU9OX0lTX1NUQU5EQlk6ICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEF1dGhlbnRpY2F0aW9uIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBCYXNpYyBhdXRoZW50aWNhdGlvbiBpcyBhZG1pbmlzdHJhdGl2ZWx5IHNodXQgZG93biBvbiB0aGVcbiAgICogcm91dGVyLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMyBCYXNpYyBBdXRoZW50aWNhdGlvbiBpcyBTaHV0ZG93blxuICAgKi9cbiAgQkFTSUNfQVVUSEVOVElDQVRJT05fSVNfU0hVVERPV046ICAgICAgICAgICAgICA1MSxcbiAgLyoqXG4gICAqIENsaWVudCBjZXJ0aWZpY2F0ZSBhdXRoZW50aWNhdGlvbiBpcyBhZG1pbmlzdHJhdGl2ZWx5XG4gICAqIHNodXQgZG93biBvbiB0aGUgcm91dGVyLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMyBDbGllbnQgQ2VydGlmaWNhdGUgQXV0aGVudGljYXRpb24gSXMgU2h1dGRvd25cbiAgICovXG4gIENMSUVOVF9DRVJUSUZJQ0FURV9BVVRIRU5USUNBVElPTl9JU19TSFVURE9XTjogNTIsXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gR3VhcmFudGVlZCBNZXNzYWdpbmcgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogR3VhcmFudGVlZCBNZXNzYWdpbmcgc2VydmljZXMgYXJlIG5vdCBlbmFibGVkIG9uIHRoZSByb3V0ZXIuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIFNlcnZpY2UgVW5hdmFpbGFibGVcbiAgICovXG4gIEdNX1VOQVZBSUxBQkxFOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxuICAvKipcbiAgICogVGhlIHNlc3Npb24gYXR0ZW1wdGVkIHRvIGNvbm5lY3QgdG8gYSBHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaGVyXG4gICAqIHRoYXQgZG9lcyBub3QgZXhpc3Qgb24gdGhpcyByb3V0ZXIuXG4gICAqIEFsbCB1bmFja2VkIG1lc3NhZ2VzIGhlbGQgYnkgdGhlIEFQSSBhcmUgcmVudW1iZXJlZCBhbmQgcmVkZWxpdmVyZWQuIFRoaXMgc3ViQ29kZVxuICAgKiBpcyBoYW5kbGVkIGludGVybmFsbHkgYW5kIHdpbGwgbm90IGJlIHNlZW4gYnkgdGhlIGFwcGxpY2F0aW9uLiBBZnRlciBzdWNjZXNzZnVsbHlcbiAgICogcmVudW1iZXJlaW5nIGFuZCByZWRlbGl2ZXJpbmcgdGhlIG1lc3NhZ2VzLCBpZiBhbnkgbWVzc2FnZXMgYXJlIHJlc2VudCwgbGlzdGVuZXJzXG4gICAqIG9uIHRoZSBAe2xpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUjZXZlbnQ6UkVQVUJMSVNISU5HX1VOQUNLRURfTUVTU0FHRVN9IGV2ZW50IGFyZVxuICAgKiBpbnZva2VkLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICogNDAwIFVua25vd24gRmxvdyBOYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBVTktOT1dOX0ZMT1dfTkFNRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMSxcbiAgLyoqXG4gICAqIEFscmVhZHkgYm91bmQgdG8gdGhlIFF1ZXVlIG9yIG5vdCBhdXRob3JpemVkIHRvIGJpbmQgdG8gdGhlIFF1ZXVlLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMCBBbHJlYWR5IEJvdW5kXG4gICAqL1xuICBBTFJFQURZX0JPVU5EOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMixcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYmluZCB0byBhIEd1YXJhbnRlZWQgTWVzc2FnaW5nIFRvcGljIEVuZHBvaW50IHdpdGggYW5cbiAgICogaW52YWxpZCB0b3BpYy5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgSW52YWxpZCBUb3BpYyBOYW1lXG4gICAqL1xuICBJTlZBTElEX1RPUElDX05BTUVfRk9SX1RPUElDX0VORFBPSU5UOiAgICAgICAgIDExMyxcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYmluZCB0byBhbiB1bmtub3duIFF1ZXVlIG5hbWUgKGZvciBleGFtcGxlLCBub3RcbiAgICogY29uZmlndXJlZCBvbiB0aGUgcm91dGVyKS5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA1MDMgVW5rbm93biBRdWV1ZVxuICAgKi9cbiAgVU5LTk9XTl9RVUVVRV9OQU1FOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTQsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIHBlcmZvcm0gYW4gb3BlcmF0aW9uIG9uIGFuIHVua25vd24gR3VhcmFudGVlZCBNZXNzYWdpbmdcbiAgICogVG9waWMgRW5kcG9pbnQgbmFtZSAoZm9yIGV4YW1wbGUsIG5vdCBjb25maWd1cmVkIG9uIHJvdXRlcikuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIFVua25vd24gRHVyYWJsZSBUb3BpYyBFbmRwb2ludFxuICAgKi9cbiAgVU5LTk9XTl9UT1BJQ19FTkRQT0lOVF9OQU1FOiAgICAgICAgICAgICAgICAgICAxMTUsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGJpbmQgdG8gYSBHdWFyYW50ZWVkIE1lc3NhZ2luZyBRdWV1ZSB0aGF0IGhhcyBhbHJlYWR5IHJlYWNoZWRcbiAgICogaXRzIG1heGltdW0gbnVtYmVyIG9mIGNsaWVudHMuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIE1heCBjbGllbnRzIGV4Y2VlZGVkIGZvciBRdWV1ZVxuICAgKi9cbiAgTUFYX0NMSUVOVFNfRk9SX1FVRVVFOiAgICAgICAgICAgICAgICAgICAgICAgICAxMTYsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGJpbmQgdG8gYSBHdWFyYW50ZWVkIE1lc3NhZ2luZyBUb3BpYyBFbmRwb2ludCB0aGF0IGhhcyBhbHJlYWR5XG4gICAqIHJlYWNoZWQgaXRzIG1heGltdW0gbnVtYmVyIG9mIGNsaWVudHMuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNTAzIE1heCBjbGllbnRzIGV4Y2VlZGVkIGZvciBkdXJhYmxlIFRvcGljIEVuZHBvaW50XG4gICAqL1xuICBNQVhfQ0xJRU5UU19GT1JfVEU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExNyxcbiAgLyoqXG4gICAqIEFuIHVuZXhwZWN0ZWQgdW5iaW5kIHJlc3BvbnNlIHdhcyByZWNlaXZlZCBmb3IgYSBHdWFyYW50ZWVkIE1lc3NhZ2luZyBRdWV1ZSBvciBUb3BpY1xuICAgKiBFbmRwb2ludCAoZm9yIGV4YW1wbGUsIHRoZSBRdWV1ZSBvciBUb3BpYyBFbmRwb2ludCB3YXMgZGVsZXRlZCBmcm9tIHRoZSByb3V0ZXIpLlxuICAgKi9cbiAgVU5FWFBFQ1RFRF9VTkJJTkQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTgsXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWVkIEd1YXJhbnRlZWQgTWVzc2FnaW5nIFF1ZXVlIHdhcyBub3QgZm91bmQgd2hlbiBwdWJsaXNoaW5nIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgUXVldWUgTm90IEZvdW5kXG4gICAqL1xuICBRVUVVRV9OT1RfRk9VTkQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExOSxcbiAgLyoqXG4gICAqIE1lc3NhZ2Ugd2FzIG5vdCBkZWxpdmVyZWQgYmVjYXVzZSB0aGUgR3VhcmFudGVlZCBNZXNzYWdlIHNwb29sIGlzIG92ZXIgaXRzXG4gICAqIGFsbG90dGVkIHNwYWNlIHF1b3RhLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDUwMyBTcG9vbCBPdmVyIFF1b3RhXG4gICAqL1xuICBTUE9PTF9PVkVSX1FVT1RBOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyMCxcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gb3BlcmF0ZSBvbiBhIHNodXRkb3duIEd1YXJhbnRlZWQgTWVzc2FnaW5nIHF1ZXVlLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDUwMyBRdWV1ZSBTaHV0ZG93blxuICAgKi9cbiAgUVVFVUVfU0hVVERPV046ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMjEsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIG9wZXJhdGUgb24gYSBzaHV0ZG93biBHdWFyYW50ZWVkIE1lc3NhZ2luZyBUb3BpYyBFbmRwb2ludC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA1MDMgRHVyYWJsZSBUb3BpYyBFbmRwb2ludCBTaHV0ZG93blxuICAgKiAgKiA1MDMgVEUgU2h1dGRvd25cbiAgICogICogNTAzIEVuZHBvaW50IFNodXRkb3duXG4gICAqL1xuICBUT1BJQ19FTkRQT0lOVF9TSFVURE9XTjogICAgICAgICAgICAgICAgICAgICAgIDEyMixcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYmluZCB0byBhIG5vbi1kdXJhYmxlIEd1YXJhbnRlZWQgTWVzc2FnaW5nIFF1ZXVlIG9yIFRvcGljXG4gICAqIEVuZHBvaW50LCBhbmQgdGhlIHJvdXRlciBpcyBvdXQgb2YgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDUwMyBObyBNb3JlIE5vbi1EdXJhYmxlIFF1ZXVlIG9yIFRvcGljIEVuZHBvaW50XG4gICAqL1xuICBOT19NT1JFX05PTl9EVVJBQkxFX1FVRVVFX09SX1RPUElDX0VORFBPSU5UOiAgIDEyMyxcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gY3JlYXRlIGEgUXVldWUgb3IgVG9waWMgRW5kcG9pbnQgdGhhdCBhbHJlYWR5IGV4aXN0cy5cbiAgICogVGhpcyBzdWJjb2RlIGlzIG9ubHkgcmV0dXJuZWQgaWZcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcy5pZ25vcmVQcm92aXNpb25FbmRwb2ludEV4aXN0c30gd2FzIG5vdCBzZXQgZm9yIHRoZSBjdXJyZW50XG4gICAqIHNlc3Npb24uXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAwIEVuZHBvaW50IEFscmVhZHkgRXhpc3RzXG4gICAqL1xuICBFTkRQT0lOVF9BTFJFQURZX0VYSVNUUzogICAgICAgICAgICAgICAgICAgICAgIDEyNCxcbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gZGVsZXRlIG9yIGNyZWF0ZSBhIFF1ZXVlIG9yIFRvcGljIEVuZHBvaW50IHdoZW4gdGhlXG4gICAqIFNlc3Npb24gZG9lcyBub3QgaGF2ZSBhdXRob3JpemF0aW9uIGZvciB0aGUgYWN0aW9uLiBUaGlzIHN1YmNvZGUgaXMgYWxzbyByZXR1cm5lZCB3aGVuIGFuXG4gICAqIGF0dGVtcHQgaXMgbWFkZSB0byByZW1vdmUgYSBtZXNzYWdlIGZyb20gYW4gZW5kcG9pbnQgd2hlbiB0aGUgU2Vzc2lvbiBkb2VzIG5vdCBoYXZlICdjb25zdW1lJ1xuICAgKiBhdXRob3JpemF0aW9uLCBvciB3aGVuIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBhZGQgb3IgcmVtb3ZlIGEgVG9waWMgc3Vic2NyaXB0aW9uIGZyb20gYSBRdWV1ZVxuICAgKiB3aGVuIHRoZSBTZXNzaW9uIGRvZXMgbm90IGhhdmUgJ21vZGlmeS10b3BpYycgYXV0aG9yaXphdGlvbi5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgUGVybWlzc2lvbiBOb3QgQWxsb3dlZFxuICAgKi9cbiAgUEVSTUlTU0lPTl9OT1RfQUxMT1dFRDogICAgICAgICAgICAgICAgICAgICAgICAxMjUsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGJpbmQgdG8gYSBRdWV1ZSBvciBUb3BpYyBFbmRwb2ludCB3aXRoIGFuIGludmFsaWRcbiAgICogc2VsZWN0b3IuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAwIEludmFsaWQgU2VsZWN0b3JcbiAgICovXG4gIElOVkFMSURfU0VMRUNUT1I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTI2LFxuICAvKipcbiAgICogUHVibGlzaGluZyB0aGUgbWVzc2FnZSB3YXMgZGVuaWVkIGR1ZSB0byBleGNlZWRpbmcgdGhlIG1heGltdW0gc3Bvb2xlZCBtZXNzYWdlXG4gICAqIGNvdW50LlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDUwMyBNYXggbWVzc2FnZSB1c2FnZSBleGNlZWRlZFxuICAgKi9cbiAgTUFYX01FU1NBR0VfVVNBR0VfRVhDRUVERUQ6ICAgICAgICAgICAgICAgICAgICAxMjcsXG4gIC8qKlxuICAgKiBBbiBhdHRlbXB0IHdhcyBtYWRlIHRvIGNyZWF0ZSBhIGR5bmFtaWMgZHVyYWJsZSBlbmRwb2ludCwgYW5kIGl0IHdhcyBmb3VuZCB0b1xuICAgKiBleGlzdCB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMCBFbmRwb2ludCBQcm9wZXJ0eSBNaXNtYXRjaFxuICAgKi9cbiAgRU5EUE9JTlRfUFJPUEVSVFlfTUlTTUFUQ0g6ICAgICAgICAgICAgICAgICAgICAxMjgsXG4gIC8qKlxuICAgKiBUaGUgY2xpZW50IGF0dGVtcHRlZCB0byBwdWJsaXNoIGFuIEd1YXJhbnRlZWQgTWVzc2FnaW5nIG1lc3NhZ2UgdG8gYSB0b3BpYyB0aGF0XG4gICAqIGRpZCBub3QgaGF2ZSBhbnkgZ3VhcmFudGVlZCBzdWJzY3JpcHRpb24gbWF0Y2hlcywgb3Igb25seSBtYXRjaGVkIGEgcmVwbGljYXRlZCB0b3BpYy5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA1MDMgTm8gU3Vic2NyaXB0aW9uIE1hdGNoXG4gICAqL1xuICBOT19TVUJTQ1JJUFRJT05fTUFUQ0g6ICAgICAgICAgICAgICAgICAgICAgICAgIDEyOSxcbiAgLyoqXG4gICAqIFRoZSBhcHBsaWNhdGlvbiBhdHRlbXB0ZWQgdG8gYWNrbm93bGVkZ2UgYSBtZXNzYWdlIHRoYXQgYXJyaXZlZCB2aWEgYSBkZWxpdmVyeVxuICAgKiBtb2RlIHRoYXQgZG9lcyBub3QgYWxsb3cgYWNrbm93bGVkZ2VtZW50cy5cbiAgICovXG4gIE1FU1NBR0VfREVMSVZFUllfTU9ERV9NSVNNQVRDSDogICAgICAgICAgICAgICAgMTMwLFxuICAvKipcbiAgICogVGhlIG1lc3NhZ2Ugd2FzIGFscmVhZHkgYWNrbm93bGVkZ2VkLlxuICAgKi9cbiAgTUVTU0FHRV9BTFJFQURZX0FDS05PV0xFREdFRDogICAgICAgICAgICAgICAgICAxMzEsXG5cbiAgLyoqXG4gICAqIFRoZSBBUEktc3VwcGxpZWQgc3Vic2NyaXB0aW9uIGRpZCBub3QgbWF0Y2ggd2hlbiBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYVxuICAgKiBub24tZXhjbHVzaXZlIGR1cmFibGUgdG9waWMgZW5kb2ludC5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDMgU3Vic2NyaXB0aW9uIERvZXMgTm90IE1hdGNoXG4gICAqL1xuICBTVUJTQ1JJUFRJT05fRE9FU19OT1RfTUFUQ0g6ICAgICAgICAgICAxMzMsXG4gIC8qKlxuICAgKiBUaGUgQVBJLXN1cHBsaWVkIHNlbGVjdG9yIGRpZCBub3QgbWF0Y2ggd2hlbiBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYVxuICAgKiBub24tZXhjbHVzaXZlIGR1cmFibGUgdG9waWMgZW5kcG9pbnQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogICogNDAzIFNlbGVjdG9yIERvZXMgTm90IE1hdGNoXG4gICAqL1xuICBTRUxFQ1RPUl9ET0VTX05PVF9NQVRDSDogICAgICAgICAgICAgICAxMzQsXG4gIC8qKlxuICAgKiBUaGUgc3Vic2NyaWJlciBoYXMgcHJvdmlkZWQgYW4gaW5jb3JyZWN0bHkgZm9ybWF0dGVkIGR1cmFibGUgdG9waWMgZW5kcG9pbnQgbmFtZS5cbiAgICpcbiAgICogQ2F1c2VzOlxuICAgKiAgKiA0MDAgSW52YWxpZCBEdXJhYmxlIFRvcGljIEVuZHBvaW50IE5hbWVcbiAgICovXG4gIElOVkFMSURfRFRFX05BTUU6ICAgICAgICAgICAgICAgICAgICAgIDEzNSxcbiAgLyoqXG4gICAqIFRoZSB1bnN1YnNjcmliZSByZXF1ZXN0IHdhcyBkZW5pZWQgYnkgdGhlIHJvdXRlciBiZWNhdXNlIHRoZSBkdXJhYmxlIHRvcGljIGVuZHBvaW50XG4gICAqIGhhZCBvbmUgb3IgbW9yZSBjbGllbnRzIGJvdW5kLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICAqIDQwMCBVbnN1YnNjcmliZSBOb3QgQWxsb3dlZCwgQ2xpZW50KHMpIEJvdW5kIFRvIERURVxuICAgKi9cbiAgVU5TVUJTQ1JJQkVfTk9UX0FMTE9XRURfQ0xJRU5UU19CT1VORDogMTM2LFxuICAvKipcbiAgICogQW4gYXBwbGljYXRpb24gY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IgYmFjayB0byB0aGUgQVBJLiBUaGUgcmVhc29uIHByb3BlcnR5IGRlc2NyaWJlc1xuICAgKiB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAgICovXG4gIENBTExCQUNLX0VSUk9SOiAgICAgICAgICAgICAgICAgICAgICAgIDEzNyxcbiAgLyoqXG4gICAqIEEgcHVibGlzaGVkIG1lc3NhZ2Ugd2FzIGRpc2NhcmRlZCBieSB0aGUgcm91dGVyIGJlY2F1c2UgaXQgd2lsbCBub3QgYmUgcHVibGlzaGVkXG4gICAqIGFueXdoZXJlIGJhc2VkIG9uIHRoZSBOb0xvY2FsIHByb3BlcnRpZXMuIFRoaXMgY2FuIGJlIGNvbnNpZGVyZWQgbm9ybWFsLlxuICAgKlxuICAgKiBDYXVzZXM6XG4gICAqICogNDAwIE5vbG9jYWwgRGlzY2FyZFxuICAgKi9cbiAgTk9MT0NBTF9ESVNDQVJEOiAgICAgICAgICAgICAgICAgICAgICAgMTM4LFxuICAvKipcbiAgICogVGhlIG9wZXJhdGlvbiBpcyBkZWxheWVkIGJlY2F1c2UgR3VhcmFudGVlZCBNZXNzYWdpbmcgaXMgbm90IHJlYWR5IG9uIHRoZSByb3V0ZXIuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogNTA3IEFkIE5vdCBSZWFkeVxuICAgKi9cbiAgR01fTk9UX1JFQURZOiAgICAgICAgICAgICAgICAgICAgICAgICAgMTQwLFxuICAvKipcbiAgICogVGhlIG1lc3NhZ2Ugd2FzIHJlamVjdGVkIGJlY2F1c2Ugb25lIG9yIG1vcmUgbWF0Y2hpbmcgZW5kcG9pbnRzJ1xuICAgKiByZWplY3QtbG93LXByaW9yaXR5LW1zZy1saW1pdCB3YXMgZXhjZWVkZWQuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogKiA1MDMgTG93IFByaW9yaXR5IE1zZyBDb25nZXN0aW9uXG4gICAqL1xuICBMT1dfUFJJT1JJVFlfTVNHX0NPTkdFU1RJT046ICAgICAgICAgICAxNDEsXG4gIC8qKlxuICAgKiBUaGUgc3BlY2lmaWVkIGVuZHBvaW50IHF1b3RhIHdhcyBvdXQgb2YgcmFuZ2UuXG4gICAqXG4gICAqIENhdXNlczpcbiAgICogNDAwIFF1b3RhIE91dCBPZiBSYW5nZVxuICAgKi9cbiAgUVVPVEFfT1VUX09GX1JBTkdFOiAgICAgICAgICAgICAgICAgICAgMTQyLFxuICAvKipcbiAgICogVW5hYmxlIHRvIGxvYWQgdGhlIGNlcnRpZmljYXRlIGZyb20gdGhlIFRydXN0U3RvcmUgZm9yIGEgU1NMXG4gICAqIHNlY3VyZWQgc2Vzc2lvbi5cbiAgICovXG4gIEZBSUxFRF9MT0FESU5HX1RSVVNUU1RPUkU6ICAgICAgICAgICAgIDE0MyxcbiAgLyoqXG4gICAqIFRoZSBjbGllbnQgZmFpbGVkIHRvIGxvYWQgY2VydGlmaWNhdGUgYW5kL29yIHByaXZhdGUga2V5IGZpbGVzLlxuICAgKi9cbiAgRkFJTEVEX0xPQURJTkdfQ0VSVElGSUNBVEVfQU5EX0tFWTogICAgMTQ0LFxuICAvKipcbiAgICogRE5TIHJlc29sdXRpb24gZmFpbGVkIGZvciBhbGwgaG9zdG5hbWVzLlxuICAgKi9cbiAgVU5SRVNPTFZFRF9IT1NUUzogICAgICAgICAgICAgICAgICAgICAgMTQ1LFxufTtcblxubW9kdWxlLmV4cG9ydHMuRXJyb3JTdWJjb2RlID0gRW51bS5uZXcoRXJyb3JTdWJjb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVycm9yL2xpYi9lcnJvci1zdWJjb2Rlcy5qcyIsIi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+XG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIGVycm9ycyB0aHJvd24gYnkgdGhlIEFQSS5cbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNsYXNzIFNvbGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBtZXNzYWdlLCBjb25zdHJ1Y3Rvcikge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJycpO1xuICAgIC8qKlxuICAgICAqIEVycm9yIE1lc3NhZ2UuXG4gICAgICogQG5hbWUgc29sYWNlLlNvbGFjZUVycm9yI21lc3NhZ2VcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7IC8vIGZvcmNlIHNldFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICAgKiBAbmFtZSBzb2xhY2UuU29sYWNlRXJyb3IjbmFtZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gdHlwZTtcblxuICAgIC8vIEVTNiBlcnJvciBzZW1hbnRpY3MgYXJlIGRpc2FwcG9pbnRpbmdcbiAgICAvLyBDbGVhbmVyIHN0YWNrIGNhcHR1cmUgZm9yIFY4LWJhc2VkIFZNc1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY29uc3RydWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuU29sYWNlRXJyb3IgPSBTb2xhY2VFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVycm9yL2xpYi9zb2xhY2UtZXJyb3IuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgcnBhdWxzb24gb24gMDYvMDIvMjAxNy5cbiAqL1xuY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBAcHJpdmF0ZVxuICogRXZlbnRzIG9uIHRoZSBDb25zdW1lciBGU01cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCBDb25zdW1lckZTTUV2ZW50TmFtZXMgPSB7XG4gIFNFU1NJT05fVVA6ICAgICAgICAgICAgICAgICAnU0VTU0lPTl9VUCcsXG4gIFNFU1NJT05fVVBfTk9fQUQ6ICAgICAgICAgICAnU0VTU0lPTl9VUF9OT19BRCcsXG4gIFNFU1NJT05fRE9XTjogICAgICAgICAgICAgICAnU0VTU0lPTl9ET1dOJyxcbiAgU0VTU0lPTl9ESVNDT05ORUNUOiAgICAgICAgICdTRVNTSU9OX0RJU0NPTk5FQ1QnLFxuICBGTE9XX0ZBSUxFRDogICAgICAgICAgICAgICAgJ0ZMT1dfRkFJTEVEJyxcbiAgRkxPV19VUDogICAgICAgICAgICAgICAgICAgICdGTE9XX1VQJyxcbiAgRkxPV19BQ1RJVkVfSU5EOiAgICAgICAgICAgICdGTE9XX0FDVElWRV9JTkQnLFxuICBGTE9XX0NMT1NFOiAgICAgICAgICAgICAgICAgJ0ZMT1dfQ0xPU0UnLFxuICBGTE9XX09QRU46ICAgICAgICAgICAgICAgICAgJ0ZMT1dfT1BFTicsXG4gIEZMT1dfVU5CT1VORDogICAgICAgICAgICAgICAnRkxPV19VTkJPVU5EJyxcbiAgQUNLOiAgICAgICAgICAgICAgICAgICAgICAgICdBQ0snLFxuICBBQ0tfVElNRU9VVDogICAgICAgICAgICAgICAgJ0FDS19USU1FT1VUJyxcbiAgQklORF9USU1FT1VUOiAgICAgICAgICAgICAgICdCSU5EX1RJTUVPVVQnLFxuICBVTkJJTkRfVElNRU9VVDogICAgICAgICAgICAgJ1VOQklORF9USU1FT1VUJyxcbiAgQ0FOX1NFTkQ6ICAgICAgICAgICAgICAgICAgICdDQU5fU0VORCcsXG4gIFRSQU5TUE9SVF9FUlJPUjogICAgICAgICAgICAnVFJBTlNQT1JUX0VSUk9SJyxcbiAgRElTUE9TRTogICAgICAgICAgICAgICAgICAgICdESVNQT1NFJyxcbiAgVklSVFVBTFJPVVRFUl9OQU1FX0NIQU5HRUQ6ICdWSVJUVUFMUk9VVEVSX05BTUVfQ0hBTkdFRCcsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25zdW1lckZTTUV2ZW50TmFtZXMgPSBFbnVtLm5ldyhDb25zdW1lckZTTUV2ZW50TmFtZXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvY29uc3VtZXItZnNtLWV2ZW50LW5hbWVzLmpzIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IHJwYXVsc29uIG9uIDA2LzAyLzIwMTcuXG4gKi9cbmNvbnN0IHsgRnNtRXZlbnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mc20nKTtcblxuLyoqXG4gKlxuICogQ29uc3VtZXJGU01FdmVudCBleHRlbmRzIHtAbGluayBGc21FdmVudH0uICBUaGlzIG9iamVjdCBzaG91bGQgYmUgdXNlZCBmb3IgYWxsIGV2ZW50c1xuICogcGFzc2VkIHRvIHRoZSBTdWJzY3JpYmVyIEZTTS4gIFRoaXMgZXh0ZW5zaW9uIHByb3ZpZGVzIG1lbWJlcnMgdG8gY2FycnkgaW5mb3JtYXRpb24gc3BlY2ZpYyB0b1xuICogdGhlIFN1YnNjcmliZXIgRlNNIHRyYW5zaXRpb25zLlxuICpcbiAqIEBleHRlbmRzIEZzbUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25zdW1lckZTTUV2ZW50IGV4dGVuZHMgRnNtRXZlbnQge1xuICBjb25zdHJ1Y3RvcihzcGVjLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIoc3BlYyk7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25zdW1lckZTTUV2ZW50ID0gQ29uc3VtZXJGU01FdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL2NvbnN1bWVyLWZzbS1ldmVudC5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogVGhlIHB1Ymxpc2hlciBjdXJyZW50bHkgaXNuJ3QgZXhwb3NlZCwgYW5kIGl0cyBldmVudHMgYXJlIGRpc3BhdGNoZWRcbiAqIHZpYSB0aGUgU2Vzc2lvbi4gVGhlc2UgZXZlbnRzIGFyZSB0aGVyZWZvcmUgcHJpdmF0ZS4gVGhleSBzaG91bGRcbiAqIGJlIG1vdmVkIHRvIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSB3aGVuIHRoZXkgYXJlIG1hZGUgcHVibGljLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZSA9IEVudW0ubmV3KHtcbiAgQUNLTk9XTEVER0VEX01FU1NBR0U6ICAgICAgJ01lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWVfYWNrbm93bGVkZ2VkTWVzc2FnZScsXG4gIENPTk5FQ1RfRkFJTEVEX0VSUk9SOiAgICAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX2Nvbm5lY3RGYWlsZWRFcnJvcicsXG4gIENBTl9TRU5EOiAgICAgICAgICAgICAgICAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX2NhblNlbmQnLFxuICBESVNQT1NFRDogICAgICAgICAgICAgICAgICAnTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZV9kaXNwb3NlZCcsXG4gIERPV046ICAgICAgICAgICAgICAgICAgICAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX2Rvd24nLFxuICBGTE9XX05BTUVfQ0hBTkdFRDogICAgICAgICAnTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZV9mbG93TmFtZUNoYW5nZWQnLFxuICBHVUFSQU5URUVEX01FU1NBR0lOR19ET1dOOiAnTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZV9ndWFyYW50ZWVkTWVzc2FnaW5nRG93bicsXG4gIFJFSkVDVEVEX01FU1NBR0U6ICAgICAgICAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX3JlamVjdGVkTWVzc2FnZScsXG4gIERJU0NPTk5FQ1RfRkFJTEVEX0VSUk9SOiAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX2Rpc2Nvbm5lY3RGYWlsZWRFcnJvcicsXG4gIFVQOiAgICAgICAgICAgICAgICAgICAgICAgICdNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lX3VwJyxcbiAgVFJBTlNQT1JUX0ZVTEw6ICAgICAgICAgICAgJ01lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWVfdHJhbnNwb3J0RnVsbCcsXG59KTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZSA9IE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvbWVzc2FnZS1wdWJsaXNoZXItZXZlbnQtbmFtZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEBwcml2YXRlXG4gKiBFdmVudHMgb24gdGhlIFB1Ymxpc2hlciBGU01cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCBQdWJsaXNoZXJGU01FdmVudE5hbWVzID0ge1xuICBTRVNTSU9OX1VQOiAgICAgICAnUHVibGlzaGVyU2Vzc2lvblVwJyxcbiAgU0VTU0lPTl9VUF9OT19BRDogJ1B1Ymxpc2hlclNlc3Npb25VcE5vQUQnLFxuICBTRVNTSU9OX0RPV046ICAgICAnUHVibGlzaGVyU2Vzc2lvbkRvd24nLFxuICBGTE9XX0ZBSUxFRDogICAgICAnTWVzc2FnZVB1Ymxpc2hlckZhaWxlZCcsXG4gIEZMT1dfVVA6ICAgICAgICAgICdNZXNzYWdlUHVibGlzaGVyVXAnLFxuICBGTE9XX0NMT1NFOiAgICAgICAnTWVzc2FnZVB1Ymxpc2hlckNsb3NlJyxcbiAgRkxPV19VTkJPVU5EOiAgICAgJ01lc3NhZ2VQdWJsaXNoZXJVbmJvdW5kJyxcbiAgVFJBTlNQT1JUX0ZVTEw6ICAgJ1B1Ymxpc2hlclRyYW5zcG9ydEZ1bGwnLFxuICBBQ0s6ICAgICAgICAgICAgICAnUHVibGlzaGVyQWNrJyxcbiAgQUNLX1RJTUVPVVQ6ICAgICAgJ1B1Ymxpc2hlckFja1RpbWVvdXQnLFxuICBCSU5EX1RJTUVPVVQ6ICAgICAnUHVibGlzaGVyQmluZFRpbWVvdXQnLFxuICBVTkJJTkRfVElNRU9VVDogICAnUHVibGlzaGVyVW5iaW5kVGltZW91dCcsXG4gIENBTl9TRU5EOiAgICAgICAgICdQdWJsaXNoZXJDYW5TZW5kJyxcbiAgVFJBTlNQT1JUX0VSUk9SOiAgJ1B1Ymxpc2hlclRyYW5zcG9ydEVycm9yJyxcbiAgUkVTRU5EX0NPTVBMRVRFOiAgJ1B1Ymxpc2hlclJlc2VuZENvbXBsZXRlJyxcbiAgRElTUE9TRTogICAgICAgICAgJ1B1Ymxpc2hlckRpc3Bvc2UnLFxufTtcblxubW9kdWxlLmV4cG9ydHMuUHVibGlzaGVyRlNNRXZlbnROYW1lcyA9IEVudW0ubmV3KFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXIvbGliL3B1Ymxpc2hlci1mc20tZXZlbnQtbmFtZXMuanMiLCJjb25zdCB7IEZzbUV2ZW50IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZnNtJyk7XG5cbi8qKlxuICpcbiAqIFB1Ymxpc2hlckZTTUV2ZW50IGV4dGVuZHMge0BsaW5rIEZzbUV2ZW50fS4gIFRoaXMgb2JqZWN0IHNob3VsZCBiZSB1c2VkIGZvciBhbGwgZXZlbnRzXG4gKiBwYXNzZWQgdG8gdGhlIFNlc3Npb25GU00uICBUaGlzIGV4dGVuc2lvbiBwcm92aWRlcyBtZW1iZXJzIHRvIGNhcnJ5IGluZm9ybWF0aW9uIHNwZWNmaWMgdG9cbiAqIHRoZSBTZXNzaW9uRlNNIHRyYW5zaXRpb25zLlxuICogQGV4dGVuZHMge0ZzbUV2ZW50fVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUHVibGlzaGVyRlNNRXZlbnQgZXh0ZW5kcyBGc21FdmVudCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgVGhlIHNwZWNpZmljYXRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGFzc2lnbiB0byB0aGlzIGV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge01lc3NhZ2V8QmFzZU1lc3NhZ2V9IHNtZm1lc3NhZ2UgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWMsIGRldGFpbHMsIHNtZm1lc3NhZ2UpIHtcbiAgICBzdXBlcihzcGVjKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRldGFpbHMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc21mbWVzc2FnZSk7XG4gIH1cbiAgZ2V0RXZlbnRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudFRleHQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuUHVibGlzaGVyRlNNRXZlbnQgPSBQdWJsaXNoZXJGU01FdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9wdWJsaXNoZXItZnNtLWV2ZW50LmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBBbiBhdHRyaWJ1ZSBvZiBhIHtAbGluayBzb2xhY2UuTWVzc2FnZX0uIEFwcGxpY2F0aW9ucyByZWNlaXZlIG1lc3NhZ2VzIGR1ZSB0byBzdWJzY3JpcHRpb25zIG9uXG4gKiB0b3BpY3MsIG9yIGNvbnN1bWVycyBjb25uZWN0ZWQgdG8gZHVyYWJsZSBvYmplY3RzLiAgVGhlIE1lc3NhZ2VDYWNoZVN0YXR1cyBvZiBzdWNoIG1lc3NhZ2VzIGlzOlxuICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ2FjaGVTdGF0dXMuTElWRX0uXG4gKlxuICogTWVzc2FnZSBhcmUgYWxzbyBkZWxpdmVyZWQgdG8gYW4gYXBwbGljYXRpb25cbiAqIGFzIGEgcmVzdWx0IG9mIGEgY2FjaGUgcmVxdWVzdCAoc2VlIHtAbGluayBzb2xhY2UuQ2FjaGVTZXNzaW9uI3NlbmRDYWNoZVJlcXVlc3R9KSB3aGljaFxuICogaGF2ZSBhIE1lc3NhZ2VDYWNoZVN0YXR1cyB0aGF0IGlzIHtAbGluayBzb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzLkNBQ0hFRH0gb3JcbiAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzLlNVU1BFQ1R9LlxuICpcbiAqIFRoZSBNZXNzYWdlQ2FjaGVTdGF0dXMgaXMgcmV0cmlldmVkIHdpdGgge0BsaW5rIHNvbGFjZS5NZXNzYWdlI2dldENhY2hlU3RhdHVzfS5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBNZXNzYWdlQ2FjaGVTdGF0dXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBpcyBsaXZlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgTElWRTogICAgMCxcbiAgLyoqXG4gICAqIFRoZSBtZXNzYWdlIHdhcyByZXRyaWV2ZWVkIGZyb20gYSBzb2xDYWNoZSBJbnN0YW5jZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIENBQ0hFRDogIDEsXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSB3YXMgcmV0cmlldmVkIGZyb20gYSBzdXNwZWN0IHNvbENhY2hlIEluc3RhbmNlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgU1VTUEVDVDogMixcblxufTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUNhY2hlU3RhdHVzID0gRW51bS5uZXcoTWVzc2FnZUNhY2hlU3RhdHVzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UvbGliL21lc3NhZ2UtY2FjaGUtc3RhdHVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVudW1lcmF0aW9uIG9mIG1lc3NhZ2UgZGVsaXZlcnkgbW9kZXMuXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUgPSB7XG4gIC8qKlxuICAgKiBUaGlzIG1vZGUgcHJvdmlkZXMgYXQtbW9zdC1vbmNlIG1lc3NhZ2UgZGVsaXZlcnkuIERpcmVjdCBtZXNzYWdlcyBoYXZlXG4gICAqIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyaXN0aWNzOlxuICAgKiAgICogVGhleSBhcmUgbm90IHJldGFpbmVkIGZvciBjbGllbnRzIHRoYXQgYXJlIG5vdCBjb25uZWN0ZWQgdG8gYSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gICAqICAgKiBUaGV5IGNhbiBiZSBkaXNjYXJkZWQgd2hlbiBjb25nZXN0aW9uIG9yIHN5c3RlbSBmYWlsdXJlcyBhcmUgZW5jb3VudGVyZWQuXG4gICAqICAgKiBUaGV5IGNhbiBiZSByZW9yZGVyZWQgaW4gdGhlIGV2ZW50IG9mIG5ldHdvcmsgdG9wb2xvZ3kgY2hhbmdlcy5cbiAgICpcbiAgICogRGlyZWN0IG1lc3NhZ2VzIGFyZSBtb3N0IGFwcHJvcHJpYXRlIGZvciBtZXNzYWdpbmcgYXBwbGljYXRpb25zIHRoYXQgcmVxdWlyZSB2ZXJ5XG4gICAqIGhpZ2gtcmF0ZSBvciB2ZXJ5IGxvdy1sYXRlbmN5IG1lc3NhZ2UgdHJhbnNtaXNzaW9uLiBEaXJlY3QgTWVzc2FnaW5nIGVuYWJsZXNcbiAgICogYXBwbGljYXRpb25zIHRvIGVmZmljaWVudGx5IHB1Ymxpc2ggbWVzc2FnZXMgdG8gYSBsYXJnZSBudW1iZXIgb2YgY2xpZW50c1xuICAgKiB3aXRoIG1hdGNoaW5nIHN1YnNjcmlwdGlvbnMuXG4gICAqL1xuICBESVJFQ1Q6ICAgICAgICAgMCxcbiAgLyoqXG4gICAqIEEgUGVyc2lzdGVudCBkZWxpdmVyeSBtb2RlIGlzIHVzZWQgZm9yIEd1YXJhbnRlZWQgTWVzc2FnaW5nLCBhbmQgdGhpcyBkZWxpdmVyeSBtb2RlXG4gICAqIGlzIG1vc3QgYXBwcm9wcmlhdGUgZm9yIGFwcGxpY2F0aW9ucyB0aGF0IHJlcXVpcmUgcGVyc2lzdGVudCBzdG9yYWdlIG9mIHRoZSBtZXNzYWdlc1xuICAgKiB0aGV5IHNlbmQgb3IgaW50ZW5kIHRvIHJlY2VpdmUuIFBlcnNpc3RlbnQgbWVzc2FnZXMgaGF2ZSB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcmlzdGljczpcbiAgICpcbiAgICogICogVGhleSBjYW5ub3QgYmUgZGlzY2FyZGVkIG9yIGxvc3QgKG9uY2UgdGhleSBhcmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIpLlxuICAgKiAgKiBUaGV5IGNhbm5vdCBiZSByZW9yZGVyZWQgaW4gdGhlIGV2ZW50IG9mIG5ldHdvcmsgdG9wb2xvZ3kgY2hhbmdlcy5cbiAgICogICogVGhleSBjYW5ub3QgYmUgZGVsaXZlcmVkIG1vcmUgdGhhbiBvbmNlIHRvIGEgc2luZ2xlIGNsaWVudCAodW5sZXNzIHRoZSByZWRlbGl2ZXJlZFxuICAgKiAgICBtZXNzYWdlIGZsYWcgaXMgYXBwbGllZCkuXG4gICAqICAqIFdoZW4gdGhleSBtYXRjaCBzdWJzY3JpcHRpb25zIG9uIGR1cmFibGUgZW5kcG9pbnRzLCB0aGV5IGFyZSByZXRhaW5lZCBmb3IgYSBjbGllbnRcbiAgICogICAgd2hlbiB0aGF0IGNsaWVudCBpcyBub3QgY29ubmVjdGVkLlxuICAgKlxuICAgKiBQZXJzaXN0ZW50IG1lc3NhZ2VzIGFyZSBtb3N0IGFwcHJvcHJpYXRlIGZvciBhcHBsaWNhdGlvbnMgdGhhdCByZXF1aXJlIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgKiBvZiB0aGUgbWVzc2FnZXMgdGhleSBzZW5kIG9yIGludGVuZCB0byByZWNlaXZlLlxuICAgKi9cbiAgUEVSU0lTVEVOVDogICAgIDEsXG4gIC8qKlxuICAgKiBUaGlzIG1vZGUgaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIFBlcnNpc3RlbnQuIEl0IGV4aXN0cyB0byBmYWNpbGl0YXRlIGludGVyYWN0aW9uXG4gICAqIHdpdGggSk1TIGFwcGxpY2F0aW9ucy4gSW4gbW9zdCBzaXR1YXRpb25zIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBHdWFyYW50ZWVkIE1lc3NhZ2luZyxcbiAgICogaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuUEVSU0lTVEVOVH0uXG4gICAqL1xuICBOT05fUEVSU0lTVEVOVDogMixcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlID0gRW51bS5uZXcoTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS1kZWxpdmVyeS1tb2RlLXR5cGVzLmpzIiwiY29uc3QgRGVidWdMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZGVidWcnKTtcbmNvbnN0IE1lc3NhZ2VEdW1wU3RhbmRhcmRQcm92aWRlckxpYiA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kdW1wLXN0YW5kYXJkLXByb3ZpZGVyJyk7XG5jb25zdCB7XG4gIFNEVEZpZWxkVHlwZSxcbiAgU0RUTWFwQ29udGFpbmVyLFxuICBTRFRTdHJlYW1Db250YWluZXIsXG4gIFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcixcbiAgU0RUVmFsdWVFcnJvclN1YmNvZGUsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LXNkdCcpO1xuY29uc3QgeyBDaGVjayB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBNZXNzYWdlRHVtcEZsYWcgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kdW1wLWZsYWdzJyk7XG5jb25zdCB7IFN0cmluZ0J1ZmZlciwgU3RyaW5nVXRpbHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5cbmNvbnN0IE1lc3NhZ2VEdW1wU3RhdGUgPSB7XG4gIGdldCBkdW1wUHJvdmlkZXJzKCkge1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IE1lc3NhZ2VEdW1wU3RhbmRhcmRQcm92aWRlckxpYi5NZXNzYWdlRHVtcFN0YW5kYXJkUHJvdmlkZXI7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3ZpZGVycykubWFwKGsgPT4gcHJvdmlkZXJzW2tdKTtcbiAgfSxcbn07XG5cbmNvbnN0IE1lc3NhZ2VEdW1wVXRpbCA9IHtcbiAgZ2V0T3V0T2ZSYW5nZVZhbHVlKHJhd0RhdGEpIHtcbiAgICByZXR1cm4gYDxvdXQgb2YgcmFuZ2U+XFxuJHtEZWJ1Z0xpYi5EZWJ1Zy5mb3JtYXREdW1wQnl0ZXMocmF3RGF0YSl9YDtcbiAgfSxcblxuICBnZXRWYWx1ZShzZHRGaWVsZCkge1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gc2R0RmllbGQuZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcikge1xuICAgICAgICBpZiAoZS5nZXRTdWJjb2RlKCkgPT09IFNEVFZhbHVlRXJyb3JTdWJjb2RlLlZBTFVFX09VVFNJREVfU1VQUE9SVEVEX1JBTkdFKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0T2ZSYW5nZVZhbHVlKGUuZ2V0U291cmNlRGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgT3BlcmF0aW9uRXJyb3IgJiYgZS5zdWJjb2RlID09PSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSkge1xuICAgICAgICByZXR1cm4gJzxpbnZhbGlkIHR5cGU+JztcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9LFxuXG4gIHByaW50TWFwKHNkdE1hcCwgaW5kZW50KSB7XG4gICAgaWYgKENoZWNrLm5vdGhpbmcoc2R0TWFwKSB8fCAhKHNkdE1hcCBpbnN0YW5jZW9mIFNEVE1hcENvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGNvbnN0IHN0ckluZGVudCA9IFN0cmluZ1V0aWxzLnBhZFJpZ2h0KCcnLCBpbmRlbnQsICcgJyk7XG4gICAgY29uc3Qga2V5cyA9IHNkdE1hcC5nZXRLZXlzKCkuc29ydCgpO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBzZHRGaWVsZFZhbHVlID0gc2R0TWFwLmdldEZpZWxkKGtleSk7XG4gICAgICBjb25zdCB0eXBlID0gc2R0RmllbGRWYWx1ZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoc2R0RmllbGRWYWx1ZSk7XG4gICAgICBsZXQgc3RyVmFsdWU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTRFRGaWVsZFR5cGUuTUFQOlxuICAgICAgICAgIHN0clZhbHVlID0gYFxcbiR7dGhpcy5wcmludE1hcCh2YWx1ZSwgaW5kZW50ICsgMil9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTRFRGaWVsZFR5cGUuU1RSRUFNOlxuICAgICAgICAgIHN0clZhbHVlID0gYFxcbiR7dGhpcy5wcmludFN0cmVhbSh2YWx1ZSwgaW5kZW50ICsgMil9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTRFRGaWVsZFR5cGUuQllURUFSUkFZOlxuICAgICAgICAgIHN0clZhbHVlID0gRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKHZhbHVlLCBmYWxzZSwgMCk7XG4gICAgICAgICAgaWYgKHN0clZhbHVlICE9PSBudWxsICYmIHN0clZhbHVlLnN1YnN0cigtMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBzdHJWYWx1ZSA9IHN0clZhbHVlLnN1YnN0cmluZygwLCBzdHJWYWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RyVmFsdWUgPSAodmFsdWUgIT09IG51bGwpID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgICB9XG4gICAgICBsaW5lcy5wdXNoKGAke3N0ckluZGVudH1LZXkgJyR7a2V5fScgKCR7U0RURmllbGRUeXBlLm5hbWVPZih0eXBlKX0pOiAke3N0clZhbHVlfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBwcmludFN0cmVhbShzZHRTdHJlYW0sIGluZGVudCkge1xuICAgIGlmIChDaGVjay5ub3RoaW5nKHNkdFN0cmVhbSkgfHwgIShzZHRTdHJlYW0gaW5zdGFuY2VvZiBTRFRTdHJlYW1Db250YWluZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2R0U3RyZWFtLnJld2luZCgpO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgY29uc3Qgc3RySW5kZW50ID0gU3RyaW5nVXRpbHMucGFkUmlnaHQoJycsIGluZGVudCwgJyAnKTtcbiAgICB3aGlsZSAoc2R0U3RyZWFtLmhhc05leHQoKSkge1xuICAgICAgY29uc3Qgc2R0RmllbGRWYWx1ZSA9IHNkdFN0cmVhbS5nZXROZXh0KCk7XG4gICAgICBjb25zdCB0eXBlID0gc2R0RmllbGRWYWx1ZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoc2R0RmllbGRWYWx1ZSk7XG5cbiAgICAgIGxldCBzdHJWYWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNEVEZpZWxkVHlwZS5NQVA6XG4gICAgICAgICAgc3RyVmFsdWUgPSBgXFxuJHt0aGlzLnByaW50TWFwKHZhbHVlLCBpbmRlbnQgKyAyKX1gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNEVEZpZWxkVHlwZS5TVFJFQU06XG4gICAgICAgICAgc3RyVmFsdWUgPSBgXFxuJHt0aGlzLnByaW50U3RyZWFtKHZhbHVlLCBpbmRlbnQgKyAyKX1gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNEVEZpZWxkVHlwZS5CWVRFQVJSQVk6XG4gICAgICAgICAgc3RyVmFsdWUgPSBEZWJ1Z0xpYi5EZWJ1Zy5mb3JtYXREdW1wQnl0ZXModmFsdWUsIGZhbHNlLCAwKTtcbiAgICAgICAgICBpZiAoc3RyVmFsdWUgIT09IG51bGwgJiYgc3RyVmFsdWUuc3Vic3RyKC0xKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN0clZhbHVlID0gc3RyVmFsdWUuc3Vic3RyaW5nKDAsIHN0clZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTRFRGaWVsZFR5cGUuREVTVElOQVRJT046XG4gICAgICAgICAgc3RyVmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0clZhbHVlID0gKHZhbHVlICE9PSBudWxsKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgfVxuICAgICAgbGluZXMucHVzaChgJHtzdHJJbmRlbnR9KCR7U0RURmllbGRUeXBlLm5hbWVPZih0eXBlKX0pOiAke3N0clZhbHVlfWApO1xuICAgIH1cbiAgICBzZHRTdHJlYW0ucmV3aW5kKCk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9LFxuXG4gIGNvdW50SXRlbXMoc2R0U3RyZWFtKSB7XG4gICAgaWYgKENoZWNrLm5vdGhpbmcoc2R0U3RyZWFtKSB8fCAoIShzZHRTdHJlYW0gaW5zdGFuY2VvZiBTRFRTdHJlYW1Db250YWluZXIpKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHNkdFN0cmVhbS5yZXdpbmQoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHdoaWxlIChzZHRTdHJlYW0uaGFzTmV4dCgpKSB7XG4gICAgICBzZHRTdHJlYW0uZ2V0TmV4dCgpO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgc2R0U3RyZWFtLnJld2luZCgpO1xuICAgIHJldHVybiBjb3VudDtcbiAgfSxcblxuICBmb3JtYXREYXRlKHRpbWVTdGFtcCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lU3RhbXApLnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgZHVtcChtZXNzYWdlLCBmbGFncywgc2VwYXJhdG9yLCBjb2xQYWRkaW5nKSB7XG4gICAgY29uc3Qgc2IgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gICAgbGV0IHRoZVNlcGFyYXRvciA9ICdcXG4nO1xuICAgIGxldCBuZWVkU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgbGV0IHRoZUNvbFBhZGRpbmcgPSA0MDtcbiAgICBpZiAoc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgJiYgc2VwYXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGVTZXBhcmF0b3IgPSBzZXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChjb2xQYWRkaW5nICE9PSB1bmRlZmluZWQgJiYgY29sUGFkZGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgY29sUGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoZUNvbFBhZGRpbmcgPSBjb2xQYWRkaW5nO1xuICAgIH1cblxuICAgIE1lc3NhZ2VEdW1wU3RhdGUuZHVtcFByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlciwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IFtrZXksIGlzUHJlc2VudCwgdmFsdWUsIGRldGFpbFZhbHVlXSA9IHByb3ZpZGVyKG1lc3NhZ2UsIGZsYWdzKTtcbiAgICAgIGlmICghaXNQcmVzZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkU2VwYXJhdG9yKSB7XG4gICAgICAgIHNiLmFwcGVuZCh0aGVTZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gVkFMVUUgZmllbGQsIHRoaXMgaXMgcHJvYmFibHkgYSBib29sZWFuIGZsYWdcbiAgICAgICAgLy8gYW5kIHdlIGp1c3QgZW5kIHVwIGRpc3BsYXlpbmcgdGhlIGtleSBhbmQgYSBuZXdsaW5lLlxuICAgICAgICBzYi5hcHBlbmQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNiLmFwcGVuZChTdHJpbmdVdGlscy5wYWRSaWdodChgJHtrZXl9OmAsIHRoZUNvbFBhZGRpbmcsICcgJykpO1xuICAgICAgICBzYi5hcHBlbmQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGV0YWlsVmFsdWUgIT09IG51bGwgJiYgKGZsYWdzICYgTWVzc2FnZUR1bXBGbGFnLk1TR0RVTVBfRlVMTCkpIHtcbiAgICAgICAgc2IuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgaWYgKGRldGFpbFZhbHVlLmluZGV4T2YoJyAgJykgIT09IDApIHtcbiAgICAgICAgICBzYi5hcHBlbmQoJyAgJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2IuYXBwZW5kKGRldGFpbFZhbHVlKTtcbiAgICAgICAgaWYgKGRldGFpbFZhbHVlLnN1YnN0cigtMSkgIT09ICdcXG4nICYmIGluZGV4IDwgKE1lc3NhZ2VEdW1wU3RhdGUuZHVtcFByb3ZpZGVycy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIHNiLmFwcGVuZCgnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5lZWRTZXBhcmF0b3IgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUR1bXBVdGlsID0gTWVzc2FnZUR1bXBVdGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS1kdW1wLXV0aWwuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW51bWVyYXRpb24gb2YgdXNlciBDbGFzcyBvZiBTZXJ2aWNlIChDT1MpIGxldmVscy4gVGhlIENPUyBpcyBzZXRcbiAqIG9uIGEgTWVzc2FnZSB3aXRoIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXRVc2VyQ29zfVxuICogVGhlIENsYXNzIG9mIFNlcnZpY2UgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGRpcmVjdCBhbmQgZ3VhcmFudGVlZCBtZXNzYWdlcy5cbiAqXG4gKiBGb3IgbWVzc2FnZXMgcHVibGlzaGVkIHdpdGgge0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5ESVJFQ1R9LCB0aGVcbiAqIGNsYXNzIG9mIHNlcnZpY2Ugc2VsZWN0cyB0aGUgd2VpZ2h0ZWQgcm91bmQtcm9iaW4gZGVsaXZlcnkgcXVldWUgd2hlbiB0aGVcbiAqIG1lc3NhZ2UgaXMgZm9yd2FyZGVkIHRvIGEgY29uc3VtZXIuICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZS5DT1MxfSBhcmUgdGhlXG4gKiBsb3dlc3QgcHJpb3JpdHkgbWVzc2FnZXMgYW5kIHdpbGwgdXNlIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgRC0xIGRlbGl2ZXJ5IHF1ZXVlcy5cbiAqXG4gKiBGb3IgbWVzc2FnZXMgcHVibGlzaGVkIGFzIGd1YXJhbnRlZWQgbWVzc2FnZXNcbiAqICh7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlR9IG9yXG4gKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLk5PTl9QRVJTSVNURU5UfSksIG1lc3NhZ2VzIHB1Ymxpc2hlZFxuICogd2l0aCB7QGxpbmsgc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZS5DT1MxfSBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBpZlxuICogdGhhdCBtZXNzYWdlIHdvdWxkIGNhdXNlIGFueSBxdWV1ZSBvciB0b3BpYy1lbmRwb2ludCB0byBleGNlZWQgaXRzIGNvbmZpZ3VyZWRcbiAqIGxvdy1wcmlvcml0eS1tYXgtbXNnLWNvdW50LlxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IE1lc3NhZ2VVc2VyQ29zVHlwZSA9IHtcbiAgLyoqXG4gICAqIERpcmVjdCBNZXNzYWdlczogTG93ZXN0IHByaW9yaXR5LCB1c2UgU29sYWNlIE1lc3NhZ2UgUm91dGVyIGNsaWVudCBELTEgcXVldWVzIGZvciBkZWxpdmVyeS5cbiAgICpcbiAgICogR3VhcmFudGVlZCBNZXNzYWdlczogTWVzc2FnZXMgY2FuIGJlIHJlamVjdGVkIGlmIHRoZSBtZXNzYWdlIHdvdWxkIGNhdXNlIGFueVxuICAgKiBxdWV1ZSBvciB0b3BpYy1lbmRwb2ludCB0byBleGNlZWQgaXQncyBjb25maWd1cmVkIDxpPmxvdy1wcmlvcmlpdHktbWF4LW1zZy1jb3VudDwvaT4uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBDT1MxOiAwLFxuICAvKipcbiAgICogRGlyZWN0IE1lc3NhZ2VzOiBNZWRpdW0gcHJpb3JpdHksIHVzZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgY2xpZW50IEQtMiBxdWV1ZXMgZm9yIGRlbGl2ZXJ5LlxuICAgKlxuICAgKiBHdWFyYW50ZWVkIE1lc3NhZ2VzOiBOL0EgKHNhbWUgYXMgQ09TMylcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIENPUzI6IDEsXG4gIC8qKlxuICAgKiBEaXJlY3QgTWVzc2FnZXM6IEhpZ2hlc3QgcHJpb3JpdHksIHVzZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgY2xpZW50IEQtMyBxdWV1ZXMgZm9yIGRlbGl2ZXJ5LlxuICAgKlxuICAgKiBHdWFyYW50ZWVkIE1lc3NhZ2VzOiBNZXNzYWdlcyBhcmUgbm90IHJlamVjdGVkIGZvciBleGNlZWRpbmcgPGk+bG93LXByaW9yaXR5LW1heC1tc2ctY291bnQ8L2k+LlxuICAgKiBNZXNzYWdlcyBtYXkgc3RpbGwgYmUgcmVqZWN0ZWQgZm9yIG90aGVyIHJlYXNvbnMgc3VjaCBhcyBRdWV1ZSAnU3Bvb2wgT3ZlciBRdW90YScuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBDT1MzOiAyLFxufTtcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVVzZXJDb3NUeXBlID0gRW51bS5uZXcoTWVzc2FnZVVzZXJDb3NUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UvbGliL21lc3NhZ2UtdXNlci1jb3MtdHlwZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHBvc3NpYmxlIGVuZHBvaW50IGFjY2VzcyB0eXBlcy4gVGhlIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQgcHJvcGVydHkgaXNcbiAqIHtAbGluayBzb2xhY2UuUXVldWVQcm9wZXJ0aWVzI2FjY2Vzc1R5cGV9LlxuICpcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IFF1ZXVlQWNjZXNzVHlwZSA9IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBBbiBleGNsdXNpdmUgZW5kcG9pbnQuIFRoZSBmaXJzdCBjbGllbnQgdG8gYmluZFxuICAgKiByZWNlaXZlcyB0aGUgc3RvcmVkIG1lc3NhZ2VzIG9uIHRoZSBFbmRwb2ludC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIEVYQ0xVU0lWRTogICAgJ0VYQ0xVU0lWRScsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQSBub24tZXhjbHVzaXZlIChzaGFyZWQpIFF1ZXVlLiBFYWNoIGNsaWVudCB0byBiaW5kXG4gICAqIHJlY2VpdmVzIG1lc3NhZ2VzIGluIGEgcm91bmQgcm9iaW4gZmFzaGlvbi5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIE5PTkVYQ0xVU0lWRTogJ05PTkVYQ0xVU0lWRScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZUFjY2Vzc1R5cGUgPSBFbnVtLm5ldyhRdWV1ZUFjY2Vzc1R5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtcXVldWUvbGliL3F1ZXVlLWFjY2Vzcy10eXBlcy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogRW51bWVyYXRlcyB0aGUgYmVoYXZpb3Igb3B0aW9ucyB3aGVuIGEgbWVzc2FnZSBjYW5ub3QgYmUgYWRkZWQgdG8gYW4gZW5kcG9pbnRcbiAqIChmb3IgZXhhbXBsZSwgdGhlIG1heGltdW0gcXVvdGEge0BsaW5rIHNvbGFjZS5RdWV1ZVByb3BlcnRpZXMjcXVvdGFNQn0gd2FzIGV4Y2VlZGVkKS5cbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBRdWV1ZURpc2NhcmRCZWhhdmlvciA9IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBTZW5kIHRoZSBwdWJsaXNoZXIgYSBtZXNzYWdlIHJlamVjdCBub3RpZmljYXRpb24uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBOT1RJRllfU0VOREVSX09OOiAgJ05PVElGWV9TRU5ERVJfT04nLFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIERpc2NhcmQgdGhlIG1lc3NhZ2UgYW5kIGFja25vd2xlZGdlIGl0LlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgTk9USUZZX1NFTkRFUl9PRkY6ICdOT1RJRllfU0VOREVSX09GRicsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURpc2NhcmRCZWhhdmlvciA9IEVudW0ubmV3KFF1ZXVlRGlzY2FyZEJlaGF2aW9yKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1kaXNjYXJkLWJlaGF2aW9ycy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcGVybWlzc2lvbnMgYXBwbGljYWJsZSB0byBhIHF1ZXVlLlxuICpcbiAqIFRoZSBjb3JyZXNwb25kaW5nIGVuZHBvaW50IHByb3BlcnR5IGlzXG4gKiB7QGxpbmsgc29sYWNlLlF1ZXVlUHJvcGVydGllcyNwZXJtaXNzaW9uc30uXG4gKlxuICogVGhlIGFjY2VzcyBjb250cm9sczpcbiAqICAqIHRoZSBwZXJtaXNzaW9ucyBmb3IgYWxsIG90aGVyIHVzZXJzIG9mIHRoZSBxdWV1ZSwgdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAqICBub24tZHVyYWJsZSBxdWV1ZXMge0BsaW5rIHNvbGFjZS5RdWV1ZVByb3BlcnRpZXMjcGVybWlzc2lvbnN9O1xuICogICogZm9yIHRoZSBjdXJyZW50IE1lc3NhZ2UgQ29uc3VtZXIgIG9uIGEgcXVldWUgb3IgZW5kcG9pbnQsXG4gKiAgICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wZXJtaXNzaW9uc31cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdG9waWMgZW5kcG9pbnQgd2l0aCBNT0RJRllfVE9QSUMgd2lsbCBhbGxvd1xuICogb3RoZXIgdXNlcnMgdG8gbW9kaWZ5IHRoZSB0b3BpYyBzdWJzY3JpYmVkIHRvIHRoYXQgZW5kcG9pbnQuXG4gKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgUXVldWVQZXJtaXNzaW9ucyA9IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBObyBjbGllbnQgb3RoZXIgdGhhbiB0aGUgcXVldWUncyBvd25lciBtYXkgYWNjZXNzIHRoZSBlbmRwb2ludC5cbiAgICovXG4gIE5PTkU6ICAgICAgICAgJ05PTkUnLFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENsaWVudCBtYXkgcmVhZCBtZXNzYWdlcyBidXQgbm90IGNvbnN1bWUgdGhlbS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIFJFQURfT05MWTogICAgJ1JFQURfT05MWScsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gIENsaWVudCBtYXkgcmVhZCBhbmQgY29uc3VtZSBtZXNzYWdlcy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIENPTlNVTUU6ICAgICAgJ0NPTlNVTUUnLFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENsaWVudCBtYXkgcmVhZCBhbmQgY29uc3VtZSBtZXNzYWdlcywgYW5kIG1vZGlmeSB0b3BpYyhzKSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIHF1ZXVlLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgTU9ESUZZX1RPUElDOiAnTU9ESUZZX1RPUElDJyxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBDbGllbnQgbWF5IHJlYWQgYW5kIGNvbnN1bWUgbWVzc2FnZXMsIG1vZGlmeSB0b3BpYyhzKSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAqIHF1ZXVlLCBhbmQgZGVsZXRlIHRoZSBxdWV1ZS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIERFTEVURTogICAgICAgJ0RFTEVURScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVBlcm1pc3Npb25zID0gRW51bS5uZXcoUXVldWVQZXJtaXNzaW9ucyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1xdWV1ZS9saWIvcXVldWUtcGVybWlzc2lvbnMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiByZW1vdGUgcmVzb3VyY2UgdG8gd2hpY2ggYW5cbiAqIHtAbGluayBzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3J9IHJlZmVycy5cbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBRdWV1ZVR5cGUgPSB7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHF1ZXVlIGRlc2NyaXB0b3IgcmVmZXJzIHRvIGEgcXVldWUgZW5kcG9pbnQuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBRVUVVRTogICAgICAgICAgJ1FVRVVFJyxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgcXVldWUgZGVzY3JpcHRvciByZWZlcnMgdG8gYSB0b3BpYyBlbmRwb2ludC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIFRPUElDX0VORFBPSU5UOiAnVE9QSUNfRU5EUE9JTlQnLFxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVUeXBlID0gRW51bS5uZXcoUXVldWVUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS10eXBlcy5qcyIsImNvbnN0IERlc3RpbmF0aW9uTGliID0gcmVxdWlyZSgnc29sY2xpZW50LWRlc3RpbmF0aW9uJyk7XG5jb25zdCB7IENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IEVuY29kZUhlYWRlciB9ID0gcmVxdWlyZSgnLi9lbmNvZGUtaGVhZGVyJyk7XG5jb25zdCB7IEVuY29kZUludGVnZXIgfSA9IHJlcXVpcmUoJy4vZW5jb2RlLWludGVnZXInKTtcbmNvbnN0IHsgRW5jb2RlTWFwIH0gPSByZXF1aXJlKCcuL2VuY29kZS1tYXAnKTtcbmNvbnN0IHsgRW5jb2RlU3RyZWFtIH0gPSByZXF1aXJlKCcuL2VuY29kZS1zdHJlYW0nKTtcbmNvbnN0IHsgSUVFRTc1NExJQiB9ID0gcmVxdWlyZSgnLi9pZWVlNzU0bGliJyk7XG5jb25zdCB7IFNEVERhdGFUeXBlcyB9ID0gcmVxdWlyZSgnLi4vc2R0LWRhdGEtdHlwZXMnKTtcbmNvbnN0IHsgU0RURGVzdFR5cGUgfSA9IHJlcXVpcmUoJy4uL3NkdC1kZXN0aW5hdGlvbi10eXBlcycpO1xuY29uc3QgeyBTRFRGaWVsZCB9ID0gcmVxdWlyZSgnLi4vc2R0LWZpZWxkJyk7XG5jb25zdCB7IFNEVEZpZWxkVHlwZSB9ID0gcmVxdWlyZSgnLi4vc2R0LWZpZWxkLXR5cGVzJyk7XG5jb25zdCB7IFN0cmluZ1V0aWxzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG5jb25zdCB7IGVuY29kZUhlYWRlciB9ID0gRW5jb2RlSGVhZGVyO1xuY29uc3QgeyBpbnQ0OFRvU3RyIH0gPSBFbmNvZGVJbnRlZ2VyO1xuY29uc3QgeyBlbmNvZGVNYXAgfSA9IEVuY29kZU1hcDtcbmNvbnN0IHsgZW5jb2RlU3RyZWFtIH0gPSBFbmNvZGVTdHJlYW07XG5cbmNvbnN0IHsgbnVsbFRlcm1pbmF0ZSB9ID0gU3RyaW5nVXRpbHM7XG5cbmNvbnN0IENfMl80OCA9IE1hdGgucG93KDIsIDQ4KTtcblxuLy8gVUNTLTIgLS0+IFVURi04IGNvbnZlcnNpb25cbmZ1bmN0aW9uIHN0cmVuY29kZShkYXRhKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xufVxuXG4vLyBFbmNvZGUgYW4gU0RURmllbGQgaW50byBwcm92aWRlZCBidWZmZXIgYnVmXG5mdW5jdGlvbiBlbmNvZGVTaW5nbGVFbGVtZW50VG9CdWYoc2R0ZmllbGQsIGJ1Zikge1xuICBpZiAoIShzZHRmaWVsZCBpbnN0YW5jZW9mIFNEVEZpZWxkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyB3ZSB3cml0ZSB0aGUgaGVhZGVyIGF0IHRoZSBlbmQsIG9uY2Ugd2Uga25vdyB0aGUgc2l6ZVxuICBjb25zdCB2YWx1ZSA9IHNkdGZpZWxkLmdldFZhbHVlKCk7XG4gIGxldCBmaWVsZFZhbCA9IG51bGw7XG4gIGxldCB0YWcgPSAwOyAvLyBTTUYgVEFHXG4gIHN3aXRjaCAoc2R0ZmllbGQuZ2V0VHlwZSgpKSB7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuQk9PTDpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5Cb29sZWFuO1xuICAgICAgZmllbGRWYWwgPSBDb252ZXJ0LmludDhUb1N0cih2YWx1ZSA/IDEgOiAwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLlVJTlQ4OlxuICAgICAgdGFnID0gU0RURGF0YVR5cGVzLlVuc2lnbmVkSW50ZWdlcjtcbiAgICAgIGZpZWxkVmFsID0gQ29udmVydC5pbnQ4VG9TdHIodmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuSU5UODpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5JbnRlZ2VyO1xuICAgICAgZmllbGRWYWwgPSBDb252ZXJ0LmludDhUb1N0cih2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNEVEZpZWxkVHlwZS5VSU5UMTY6XG4gICAgICB0YWcgPSBTRFREYXRhVHlwZXMuVW5zaWduZWRJbnRlZ2VyO1xuICAgICAgZmllbGRWYWwgPSBDb252ZXJ0LmludDE2VG9TdHIodmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuSU5UMTY6XG4gICAgICB0YWcgPSBTRFREYXRhVHlwZXMuSW50ZWdlcjtcbiAgICAgIGZpZWxkVmFsID0gQ29udmVydC5pbnQxNlRvU3RyKHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLlVJTlQzMjpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5VbnNpZ25lZEludGVnZXI7XG4gICAgICBmaWVsZFZhbCA9IENvbnZlcnQuaW50MzJUb1N0cih2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNEVEZpZWxkVHlwZS5JTlQzMjpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5JbnRlZ2VyO1xuICAgICAgZmllbGRWYWwgPSBDb252ZXJ0LmludDMyVG9TdHIodmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuVUlOVDY0OlxuICAgICAgdGFnID0gU0RURGF0YVR5cGVzLlVuc2lnbmVkSW50ZWdlcjtcbiAgICAgIGZpZWxkVmFsID0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMCkgKyBpbnQ0OFRvU3RyKHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLklOVDY0OlxuICAgICAgdGFnID0gU0RURGF0YVR5cGVzLkludGVnZXI7XG4gICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICBmaWVsZFZhbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDApICsgaW50NDhUb1N0cih2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZFZhbCA9IChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpICtcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSArXG4gICAgICAgICAgICAgICAgICAgIGludDQ4VG9TdHIoQ18yXzQ4ICsgdmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLldDSEFSOlxuICAgICAgdGFnID0gU0RURGF0YVR5cGVzLkNoYXI7XG4gICAgICBmaWVsZFZhbCA9IENvbnZlcnQuaW50MTZUb1N0cih2YWx1ZS5jaGFyQ29kZUF0KDApKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLlNUUklORzpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5TdHJpbmc7XG4gICAgICBmaWVsZFZhbCA9IG51bGxUZXJtaW5hdGUoc3RyZW5jb2RlKHZhbHVlKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNEVEZpZWxkVHlwZS5CWVRFQVJSQVk6XG4gICAgICB0YWcgPSBTRFREYXRhVHlwZXMuQnl0ZUFycmF5O1xuICAgICAgZmllbGRWYWwgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLkZMT0FUVFlQRTpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5GbG9hdDtcbiAgICAgIGZpZWxkVmFsID0gSUVFRTc1NExJQi50b0lFRUU3NTRTaW5nbGUodmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuRE9VQkxFVFlQRTpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5GbG9hdDtcbiAgICAgIGZpZWxkVmFsID0gSUVFRTc1NExJQi50b0lFRUU3NTREb3VibGUodmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTRFRGaWVsZFR5cGUuTUFQOlxuICAgICAgdGFnID0gU0RURGF0YVR5cGVzLk1hcDtcbiAgICAgIGZpZWxkVmFsID0gZW5jb2RlTWFwKHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLlNUUkVBTTpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5TdHJlYW07XG4gICAgICBmaWVsZFZhbCA9IGVuY29kZVN0cmVhbSh2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNEVEZpZWxkVHlwZS5ERVNUSU5BVElPTjpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5EZXN0aW5hdGlvbjtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlc3RpbmF0aW9uTGliLkRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGZpZWxkVmFsID0gQ29udmVydC5pbnQ4VG9TdHIoU0RURGVzdFR5cGVbdmFsdWUuZ2V0VHlwZSgpXSlcbiAgICAgICAgICArIHZhbHVlLmdldEJ5dGVzKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNEVEZpZWxkVHlwZS5OVUxMVFlQRTpcbiAgICAgIHRhZyA9IFNEVERhdGFUeXBlcy5OdWxsO1xuICAgICAgZmllbGRWYWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0RURmllbGRUeXBlLlVOS05PV046XG4gICAgICBmaWVsZFZhbCA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICB9XG4gIGlmIChmaWVsZFZhbCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGhkciA9IGVuY29kZUhlYWRlcih0YWcsIGZpZWxkVmFsLmxlbmd0aCk7XG4gICAgYnVmLnB1c2goaGRyKTtcbiAgICBidWYucHVzaChmaWVsZFZhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVNpbmdsZUVsZW1lbnQoc2R0ZmllbGQpIHtcbiAgY29uc3QgYnVmID0gW107XG4gIGVuY29kZVNpbmdsZUVsZW1lbnRUb0J1ZihzZHRmaWVsZCwgYnVmKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cblxuY29uc3QgRW5jb2RlU2luZ2xlRWxlbWVudCA9IHtcbiAgZW5jb2RlU2luZ2xlRWxlbWVudCxcbiAgZW5jb2RlU2luZ2xlRWxlbWVudFRvQnVmLFxufTtcblxubW9kdWxlLmV4cG9ydHMuRW5jb2RlU2luZ2xlRWxlbWVudCA9IEVuY29kZVNpbmdsZUVsZW1lbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL2VuY29kZS1zaW5nbGUtZWxlbWVudC5qcyIsImNvbnN0IElFRUU3NTRMSUIgPSB7XG4gIC8qKlxuICAgKiBAcHJlc2VydmVcbiAgICogVGhlIE1JVCBMaWNlbnNlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxMCBBbGFuIEd1dGllcnJlelxuICAgKlxuICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgKlxuICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICAgKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICpcbiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICAgKiBUSEUgU09GVFdBUkUuXG4gICAqL1xuXG4gIHRvSUVFRTc1NCh2SW4sIGViaXRzLCBmYml0cykge1xuICAgIGxldCB2ID0gdkluO1xuICAgIGNvbnN0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxO1xuXG4gICAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgICBsZXQgcztcbiAgICBsZXQgZTtcbiAgICBsZXQgZjtcbiAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgIGUgPSAoMSA8PCBiaWFzKSAtIDE7XG4gICAgICBmID0gMTtcbiAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gSW5maW5pdHkgfHwgdiA9PT0gLUluZmluaXR5KSB7XG4gICAgICBlID0gKDEgPDwgYmlhcykgLSAxO1xuICAgICAgZiA9IDA7XG4gICAgICBzID0gKHYgPCAwKSA/IDEgOiAwO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gMCkge1xuICAgICAgZSA9IDA7XG4gICAgICBmID0gMDtcbiAgICAgIHMgPSAoMSAvIHYgPT09IC1JbmZpbml0eSkgPyAxIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHYgPCAwO1xuICAgICAgdiA9IE1hdGguYWJzKHYpO1xuXG4gICAgICBpZiAodiA+PSBNYXRoLnBvdygyLCAxIC0gYmlhcykpIHtcbiAgICAgICAgY29uc3QgbG4gPSBNYXRoLm1pbihNYXRoLmZsb29yKE1hdGgubG9nKHYpIC8gTWF0aC5MTjIpLCBiaWFzKTtcbiAgICAgICAgZSA9IGxuICsgYmlhcztcbiAgICAgICAgZiA9ICh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikpIC0gTWF0aC5wb3coMiwgZmJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIGYgPSB2IC8gTWF0aC5wb3coMiwgMSAtIGJpYXMgLSBmYml0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cbiAgICBjb25zdCBiaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IGZiaXRzOyBpOyBpIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChmICUgMiA/IDEgOiAwKTtcbiAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGViaXRzOyBpOyBpIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcbiAgICAgIGUgPSBNYXRoLmZsb29yKGUgLyAyKTtcbiAgICB9XG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XG4gICAgYml0cy5yZXZlcnNlKCk7XG4gICAgbGV0IHN0ciA9IGJpdHMuam9pbignJyk7XG5cbiAgICAvLyBCaXRzIHRvIGJ5dGVzXG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCkge1xuICAgICAgYnl0ZXMucHVzaChwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDgpLCAyKSk7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH0sXG5cbiAgZnJvbUlFRUU3NTQoYnl0ZXMsIGViaXRzLCBmYml0cykge1xuICAgIC8vIEJ5dGVzIHRvIGJpdHNcbiAgICBjb25zdCBiaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aDsgaTsgaSAtPSAxKSB7XG4gICAgICBsZXQgYnl0ZUkgPSBieXRlc1tpIC0gMV07XG4gICAgICBmb3IgKGxldCBqID0gODsgajsgaiAtPSAxKSB7XG4gICAgICAgIGJpdHMucHVzaChieXRlSSAlIDIgPyAxIDogMCk7XG4gICAgICAgIGJ5dGVJID4+PSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBiaXRzLnJldmVyc2UoKTtcbiAgICBjb25zdCBzdHIgPSBiaXRzLmpvaW4oJycpO1xuXG4gICAgLy8gVW5wYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICAgIGNvbnN0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxO1xuICAgIGNvbnN0IHMgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDEpLCAyKSA/IC0xIDogMTtcbiAgICBjb25zdCBlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygxLCAxICsgZWJpdHMpLCAyKTtcbiAgICBjb25zdCBmID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygxICsgZWJpdHMpLCAyKTtcblxuICAgIC8vIFByb2R1Y2UgbnVtYmVyXG4gICAgaWYgKGUgPT09ICgxIDw8IGViaXRzKSAtIDEpIHtcbiAgICAgIHJldHVybiBmICE9PSAwID8gTmFOIDogcyAqIEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoZSA+IDApIHtcbiAgICAgIHJldHVybiBzICogTWF0aC5wb3coMiwgZSAtIGJpYXMpICogKDEgKyBmIC8gTWF0aC5wb3coMiwgZmJpdHMpKTtcbiAgICB9XG4gICAgaWYgKGYgIT09IDApIHtcbiAgICAgIHJldHVybiBzICogTWF0aC5wb3coMiwgLShiaWFzIC0gMSkpICogKGYgLyBNYXRoLnBvdygyLCBmYml0cykpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgc3RyVG9CeXRlQXJyKHN0cikge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHsgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpOyB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9LFxuICBieXRlQXJyVG9TdHIoYnl0ZXMpIHtcbiAgICBjb25zdCBzdHIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7IHN0ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gJiAweEZGKSk7IH1cbiAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICB9LFxuICBmcm9tSUVFRTc1NERvdWJsZShiKSB7IHJldHVybiB0aGlzLmZyb21JRUVFNzU0KHRoaXMuc3RyVG9CeXRlQXJyKGIpLCAxMSwgNTIpOyB9LFxuICB0b0lFRUU3NTREb3VibGUodikgeyByZXR1cm4gdGhpcy5ieXRlQXJyVG9TdHIodGhpcy50b0lFRUU3NTQodiwgMTEsIDUyKSk7IH0sXG4gIGZyb21JRUVFNzU0U2luZ2xlKGIpIHsgcmV0dXJuIHRoaXMuZnJvbUlFRUU3NTQodGhpcy5zdHJUb0J5dGVBcnIoYiksIDgsIDIzKTsgfSxcbiAgdG9JRUVFNzU0U2luZ2xlKHYpIHsgcmV0dXJuIHRoaXMuYnl0ZUFyclRvU3RyKHRoaXMudG9JRUVFNzU0KHYsIDgsIDIzKSk7IH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JRUVFNzU0TElCID0gSUVFRTc1NExJQjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvaWVlZTc1NGxpYi5qcyIsImNvbnN0IHsgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgUGFyc2VJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL3BhcnNlLWludGVnZXInKTtcblxuY29uc3QgeyBhdXRvRGVjb2RlVmFyTGVuZ3RoTnVtYmVyIH0gPSBQYXJzZUludGVnZXI7XG5cbmNvbnN0IFBhcnNlRmllbGRIZWFkZXIgPSB7XG4gIC8vIFBhcnNlIHRoZSBoZWFkZXIgcGFydCBvZiBhbiBTRFQgZmllbGQuXG4gIC8vIFJldHVybnMgW1RZUEUsIERFQ0xBUkVEX0xFTkdUSCwgVkFMVUVfREFUQV9MRU5HVEgsIENPTlNVTUVEX0JZVEVTXVxuICBwYXJzZUZpZWxkSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBwb3MgPSBvZmZzZXQ7XG4gICAgY29uc3Qgb25lYnl0ZSA9IENvbnZlcnQuc3RyVG9JbnQ4KGRhdGEuc3Vic3RyKHBvcywgMSkpO1xuICAgIGNvbnN0IGVsZW1UeXBlID0gKG9uZWJ5dGUgJiAweEZDKSA+PiAyO1xuICAgIGNvbnN0IGxlbkJ5dGVzID0gKG9uZWJ5dGUgJiAweDAzKSArIDE7XG4gICAgcG9zKys7XG4gICAgY29uc3QgZWxlbUxlbiA9IGF1dG9EZWNvZGVWYXJMZW5ndGhOdW1iZXIoZGF0YS5zdWJzdHIocG9zLCBsZW5CeXRlcykpO1xuICAgIHBvcyArPSBsZW5CeXRlcztcbiAgICBjb25zdCBlbGVtVmFsTGVuID0gZWxlbUxlbiAtICgxICsgbGVuQnl0ZXMpO1xuICAgIHJldHVybiBbZWxlbVR5cGUsIGVsZW1MZW4sIGVsZW1WYWxMZW4sIHBvcyAtIG9mZnNldF07XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXJzZUZpZWxkSGVhZGVyID0gUGFyc2VGaWVsZEhlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvcGFyc2UtZmllbGQtaGVhZGVyLmpzIiwiY29uc3QgeyBDb252ZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuY29uc3QgeyBMT0dfREVCVUcgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgUGFyc2VEZXN0aW5hdGlvbiB9ID0gcmVxdWlyZSgnLi9wYXJzZS1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBQYXJzZUZpZWxkSGVhZGVyIH0gPSByZXF1aXJlKCcuL3BhcnNlLWZpZWxkLWhlYWRlcicpO1xuY29uc3QgeyBQYXJzZUZsb2F0IH0gPSByZXF1aXJlKCcuL3BhcnNlLWZsb2F0Jyk7XG5jb25zdCB7IFBhcnNlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi9wYXJzZS1pbnRlZ2VyJyk7XG5jb25zdCB7IFBhcnNlTWFwIH0gPSByZXF1aXJlKCcuL3BhcnNlLW1hcCcpO1xuY29uc3QgeyBQYXJzZVN0cmVhbSB9ID0gcmVxdWlyZSgnLi9wYXJzZS1zdHJlYW0nKTtcbmNvbnN0IHsgU0RURGF0YVR5cGVzIH0gPSByZXF1aXJlKCcuLi9zZHQtZGF0YS10eXBlcycpO1xuY29uc3QgeyBTRFRGaWVsZCB9ID0gcmVxdWlyZSgnLi4vc2R0LWZpZWxkJyk7XG5jb25zdCB7IFNEVEZpZWxkVHlwZSB9ID0gcmVxdWlyZSgnLi4vc2R0LWZpZWxkLXR5cGVzJyk7XG5cbmNvbnN0IHtcbiAgc3RyVG9JbnQ4LFxuICBzdHJUb0ludDE2LFxuICB1dGY4VG9VY3MyLFxufSA9IENvbnZlcnQ7XG5jb25zdCB7IHBhcnNlRmllbGRIZWFkZXIgfSA9IFBhcnNlRmllbGRIZWFkZXI7XG5jb25zdCB7IHBhcnNlRmxvYXRGaWVsZCB9ID0gUGFyc2VGbG9hdDtcbmNvbnN0IHsgcGFyc2VJbnRlZ2VyRmllbGQgfSA9IFBhcnNlSW50ZWdlcjtcbmNvbnN0IHsgcGFyc2VNYXBBdCB9ID0gUGFyc2VNYXA7XG5jb25zdCB7IHBhcnNlU3RyZWFtQXQgfSA9IFBhcnNlU3RyZWFtO1xuY29uc3QgeyBwYXJzZURlc3RpbmF0aW9uIH0gPSBQYXJzZURlc3RpbmF0aW9uO1xuXG5jb25zdCBQYXJzZVNpbmdsZUVsZW1lbnQgPSB7XG4gIC8vIFBhcnNlIHNpbmdsZSBTRFQgZWxlbWVudCwgcmV0dXJucyBTRFRGaWVsZFxuICBwYXJzZVNpbmdsZUVsZW1lbnQoZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZmllbGRIZWFkZXIgPSBwYXJzZUZpZWxkSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgaWYgKCFmaWVsZEhlYWRlcikge1xuICAgICAgTE9HX0RFQlVHKGBwYXJzZVNpbmdsZUVsZW1lbnQgcmV0dXJuIGZhbHNlLCBmaWVsZEhlYWRlcj0ke2ZpZWxkSGVhZGVyfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zID0gb2Zmc2V0ICsgZmllbGRIZWFkZXJbM107XG5cbiAgICAvLyBGb3IgdXNlIGluc2lkZSBzd2l0Y2hcbiAgICBjb25zdCBlbGVtVmFsTGVuID0gZmllbGRIZWFkZXJbMl07XG5cbiAgICBzd2l0Y2ggKGZpZWxkSGVhZGVyWzBdKSB7XG4gICAgICBjYXNlIFNEVERhdGFUeXBlcy5OdWxsOlxuICAgICAgICByZXR1cm4gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5OVUxMVFlQRSwgbnVsbCk7XG4gICAgICBjYXNlIFNEVERhdGFUeXBlcy5Cb29sZWFuOlxuICAgICAgICByZXR1cm4gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5CT09MLCBzdHJUb0ludDgoZGF0YS5zdWJzdHIocG9zLCAxKSkgIT09IDApO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuSW50ZWdlcjpcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50ZWdlckZpZWxkKHRydWUsIGRhdGEuc3Vic3RyKHBvcywgZWxlbVZhbExlbikpO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuVW5zaWduZWRJbnRlZ2VyOlxuICAgICAgICByZXR1cm4gcGFyc2VJbnRlZ2VyRmllbGQoZmFsc2UsIGRhdGEuc3Vic3RyKHBvcywgZWxlbVZhbExlbikpO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuRmxvYXQ6XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0RmllbGQoZGF0YS5zdWJzdHIocG9zLCBlbGVtVmFsTGVuKSk7XG4gICAgICBjYXNlIFNEVERhdGFUeXBlcy5DaGFyOlxuICAgICAgICByZXR1cm4gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5XQ0hBUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0clRvSW50MTYoZGF0YS5zdWJzdHIocG9zLCAyKSkpKTtcbiAgICAgIGNhc2UgU0RURGF0YVR5cGVzLkJ5dGVBcnJheTpcbiAgICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuQllURUFSUkFZLCBkYXRhLnN1YnN0cihwb3MsIGVsZW1WYWxMZW4pKTtcbiAgICAgIGNhc2UgU0RURGF0YVR5cGVzLlN0cmluZzpcbiAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlIChudWxsLXRlcm1pbmF0b3IpXG4gICAgICAgIHJldHVybiBTRFRGaWVsZC5jcmVhdGUoU0RURmllbGRUeXBlLlNUUklORywgdXRmOFRvVWNzMihkYXRhLnN1YnN0cihwb3MsIGVsZW1WYWxMZW4gLSAxKSkpO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuRGVzdGluYXRpb246XG4gICAgICAgIHJldHVybiBwYXJzZURlc3RpbmF0aW9uKGRhdGEuc3Vic3RyKHBvcywgZWxlbVZhbExlbikpO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuU01GTWVzc2FnZTpcbiAgICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuU01GX01FU1NBR0UsIGRhdGEuc3Vic3RyKHBvcywgZWxlbVZhbExlbikpO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuTWFwOlxuICAgICAgICByZXR1cm4gcGFyc2VNYXBBdChkYXRhLCBwb3MsIGVsZW1WYWxMZW4pO1xuICAgICAgY2FzZSBTRFREYXRhVHlwZXMuU3RyZWFtOlxuICAgICAgICByZXR1cm4gcGFyc2VTdHJlYW1BdChkYXRhLCBwb3MsIGVsZW1WYWxMZW4pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuVU5LTk9XTiwgZGF0YS5zdWJzdHIocG9zLCBlbGVtVmFsTGVuKSk7XG5cbiAgICB9XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXJzZVNpbmdsZUVsZW1lbnQgPSBQYXJzZVNpbmdsZUVsZW1lbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLXNpbmdsZS1lbGVtZW50LmpzIiwiY29uc3QgeyBEZXN0aW5hdGlvblR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiBhbGwgU0RUIGRhdGEgdHlwZXMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgU0RURGVzdFR5cGUgPSB7XG4gIFtEZXN0aW5hdGlvblR5cGUuVE9QSUNdOiAgICAgICAgICAgMHgwMCxcbiAgW0Rlc3RpbmF0aW9uVHlwZS5RVUVVRV06ICAgICAgICAgICAweDAxLFxuICBbRGVzdGluYXRpb25UeXBlLlRFTVBPUkFSWV9RVUVVRV06IDB4MDEsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TRFREZXN0VHlwZSA9IEVudW0ubmV3KFNEVERlc3RUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvc2R0LWRlc3RpbmF0aW9uLXR5cGVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGF1dGhlbnRpY2F0aW9uIHNjaGVtZXMgdGhhdCBjYW4gYmUgdXNlZC4gVGhlIGNvcnJlc3BvbmRpbmcgc2Vzc2lvblxuICogcHJvcGVydHkgaXMge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNhdXRoZW50aWNhdGlvblNjaGVtZX0uXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQG5hbWVzcGFjZVxuICovXG5jb25zdCBBdXRoZW50aWNhdGlvblNjaGVtZSA9IHtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBVc2VybmFtZS9QYXNzd29yZCBiYXNlZCBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBCQVNJQzogICAgICAgICAgICAgICAgICAgICAgICdBdXRoZW50aWNhdGlvblNjaGVtZV9iYXNpYycsXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuQXV0aGVudGljYXRpb25TY2hlbWUuQ0xJRU5UX0NFUlRJRklDQVRFXG4gICAqIEBkZWZhdWx0IEF1dGhlbnRpY2F0aW9uU2NoZW1lX2NsaWVudENlcnRpZmljYXRlXG4gICAqIEBkZXNjcmlwdGlvbiBDbGllbnQtc2lkZSBjZXJ0aWZpY2F0ZSBiYXNlZCBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAqIEBzZWUge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xQZnh9XG4gICAqIEBzZWUge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xQZnhQYXNzd29yZH1cbiAgICogQHNlZSB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFByaXZhdGVLZXl9XG4gICAqIEBzZWUge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xQcml2YXRlS2V5UGFzc3dvcmR9XG4gICAqIEBzZWUge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xDZXJ0aWZpY2F0ZX1cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENsaWVudC1zaWRlIGNlcnRpZmljYXRlIGJhc2VkIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS4gIFRoZSBjZXJ0aWZpY2F0ZSBhbmRcbiAgICogICBwcml2YXRlIGtleSBhcmUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgQ0xJRU5UX0NFUlRJRklDQVRFOiAgICAgICAgICAnQXV0aGVudGljYXRpb25TY2hlbWVfY2xpZW50Q2VydGlmaWNhdGUnLFxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBzb2xhY2UuQXV0aGVudGljYXRpb25TY2hlbWUuQkFTSUN9IGluc3RlYWQuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBBVVRIRU5USUNBVElPTl9TQ0hFTUVfQkFTSUM6ICdBdXRoZW50aWNhdGlvblNjaGVtZV9iYXNpYycsXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLkNMSUVOVF9DRVJUSUZJQ0FURX0gaW5zdGVhZC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIEFVVEhFTlRJQ0FUSU9OX1NDSEVNRV9DTElFTlRfQ0VSVElGSUNBVEU6ICdBdXRoZW50aWNhdGlvblNjaGVtZV9jbGllbnRDZXJ0aWZpY2F0ZScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5BdXRoZW50aWNhdGlvblNjaGVtZSA9IEVudW0ubmV3KEF1dGhlbnRpY2F0aW9uU2NoZW1lKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL2F1dGhlbnRpY2F0aW9uLXNjaGVtZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTZXNzaW9uRXZlbnROYW1lID0ge1xuICBDT05ORUNUOiAgICAgICAgICAgICAgICAgICAgICAgJ1Nlc3Npb25Db25uZWN0JyxcbiAgRElTQ09OTkVDVDogICAgICAgICAgICAgICAgICAgICdTZXNzaW9uRGlzY29ubmVjdCcsXG4gIERJU1BPU0U6ICAgICAgICAgICAgICAgICAgICAgICAnU2Vzc2lvbkRpc3Bvc2UnLFxuICBDT05ORUNUX1RJTUVPVVQ6ICAgICAgICAgICAgICAgJ1Nlc3Npb25Db25uZWN0VGltZW91dCcsXG4gIENPTk5FQ1RfV0FJVF9USU1FT1VUOiAgICAgICAgICAnU2Vzc2lvbkNvbm5lY3RXYWl0VGltZW91dCcsXG4gIERPV05HUkFERV9USU1FT1VUOiAgICAgICAgICAgICAnU2Vzc2lvbkRvd25ncmFkZVRpbWVvdXQnLFxuICBUUkFOU1BPUlRfVVA6ICAgICAgICAgICAgICAgICAgJ1Nlc3Npb25UcmFuc3BvcnRVcCcsXG4gIFRSQU5TUE9SVF9ERVNUUk9ZRUQ6ICAgICAgICAgICAnU2Vzc2lvblRyYW5zcG9ydERlc3Ryb3llZCcsXG4gIFRSQU5TUE9SVF9DQU5fQUNDRVBUX0RBVEE6ICAgICAnU2Vzc2lvblRyYW5zcG9ydENhbkFjY2VwdERhdGEnLFxuICBUUkFOU1BPUlRfUEFSU0VfRVJST1I6ICAgICAgICAgJ1Nlc3Npb25UcmFuc3BvcnRQYXJzZUVycm9yJyxcbiAgVFJBTlNQT1JUX1BST1RPQ09MX1NNUDogICAgICAgICdTZXNzaW9uU01QTWVzc2FnZScsXG4gIFRSQU5TUE9SVF9QUk9UT0NPTF9DTElFTlRDVFJMOiAnU2Vzc2lvbkNsaWVudEN0cmxNZXNzYWdlJyxcbiAgRVhDRVBUSU9OOiAgICAgICAgICAgICAgICAgICAgICdTZXNzaW9uRXhjZXB0aW9uJyxcbiAgU1VCU0NSSUJFX1RJTUVPVVQ6ICAgICAgICAgICAgICdTZXNzaW9uU3Vic2NyaWJlVGltZW91dCcsXG4gIENSRUFURV9TVUJTQ1JJQkVSOiAgICAgICAgICAgICAnU2Vzc2lvbkNyZWF0ZVN1YnNjcmliZXInLFxuICBGTE9XX1VQOiAgICAgICAgICAgICAgICAgICAgICAgJ1Nlc3Npb25GbG93VXAnLFxuICBGTE9XX0ZBSUxFRDogICAgICAgICAgICAgICAgICAgJ1Nlc3Npb25GbG93RmFpbGVkJyxcbiAgU0VORF9FUlJPUjogICAgICAgICAgICAgICAgICAgICdTZXNzaW9uU2VuZEVycm9yJyxcbiAgRkxPV1NfRElTQ09OTkVDVEVEOiAgICAgICAgICAgICdTZXNzaW9uRmxvd3NEaXNjb25uZWN0ZWQnLFxuICBUUkFOU1BPUlRfRkxVU0hFRDogICAgICAgICAgICAgJ1Nlc3Npb25UcmFuc3BvcnRGbHVzaGVkJyxcbiAgRE5TX1JFU09MVVRJT05fQ09NUExFVEU6ICAgICAgICdTZXNzaW9uRE5TUmVzb2x1dGlvbkNvbXBsZXRlJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNlc3Npb25FdmVudE5hbWUgPSBFbnVtLm5ldyhTZXNzaW9uRXZlbnROYW1lKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tZXZlbnQtbmFtZXMuanMiLCJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUsXG4gICAgICAgIE9wZXJhdGlvbkVycm9yLFxuICAgICAgICBSZXF1ZXN0RXJyb3IsXG4gICAgICAgIFJlcXVlc3RFdmVudENvZGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZXZlbnQtY29kZXMnKTtcblxuZnVuY3Rpb24gYnVpbGRUeXBlKFN1cGVyY2xhc3MpIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVwcmVzZW50cyBhIHNlc3Npb24gZXZlbnQ7IGV2ZW50cyBhcmUgcGFzc2VkIHRvIHRoZSBhcHBsaWNhdGlvbi1wcm92aWRlZFxuICAgKiBldmVudCBoYW5kbGluZyBjYWxsYmFjayBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIHRoZSBzZXNzaW9uLlxuICAgKiBAbWVtYmVyb2Ygc29sYWNlXG4gICAqL1xuICBjbGFzcyBTZXNzaW9uRXZlbnQgZXh0ZW5kcyBTdXBlcmNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcmNsYXNzQXJncyBBcmdzIHRvIHBhc3MgdG8gc3VwZXJcbiAgICAgKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uRXZlbnRDb2RlfSBzZXNzaW9uRXZlbnRDb2RlIFRoZSBldmVudCBjb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGluZm9TdHIgSW5mb3JtYXRpb24gc3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNwb25zZUNvZGVdIEFueSBhc3NvY2lhdGVkIHJvdXRlciByZXNwb25zZSBjb2RlXG4gICAgICogQHBhcmFtIHtzb2xhY2UuRXJyb3JTdWJjb2RlfSBbZXJyb3JTdWJjb2RlXSBBbnkgYXNzb2NpYXRlZCBlcnJvciBzdWJjb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb3JyZWxhdGlvbktleV0gQW55IGFzc29jaWF0ZWQgY29ycmVsYXRpb24ga2V5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtyZWFzb25dIEFueSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdXBlcmNsYXNzQXJncyxcbiAgICAgICAgICAgICAgICBzZXNzaW9uRXZlbnRDb2RlLFxuICAgICAgICAgICAgICAgIGluZm9TdHIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9IDAsXG4gICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXkgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICBzdXBlciguLi5zdXBlcmNsYXNzQXJncyk7XG4gICAgICB0aGlzLl9zZXNzaW9uRXZlbnRDb2RlID0gc2Vzc2lvbkV2ZW50Q29kZTtcbiAgICAgIHRoaXMuX2luZm9TdHIgPSBpbmZvU3RyO1xuICAgICAgdGhpcy5fcmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgICAgdGhpcy5fZXJyb3JTdWJjb2RlID0gZXJyb3JTdWJjb2RlO1xuICAgICAgdGhpcy5fY29ycmVsYXRpb25LZXkgPSBjb3JyZWxhdGlvbktleTsgLy8gb3B0aW9uYWxcbiAgICAgIHRoaXMuX3JlYXNvbiA9IHJlYXNvbjsgLy8gb3B0aW9uYWxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c29sYWNlLlNlc3Npb25FdmVudENvZGV9XG4gICAgICogQGRlc2NyaXB0aW9uIEZ1cnRoZXIgcXVhbGlmaWVzIHRoZSBzZXNzaW9uIGV2ZW50LlxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uRXZlbnRDb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25FdmVudENvZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVzY3JpcHRpb24gaWYgYXBwbGljYWJsZSwgYW4gaW5mb3JtYXRpb24gc3RyaW5nIHJldHVybmVkIGJ5IHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gICAgICovXG4gICAgZ2V0IGluZm9TdHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5mb1N0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gaWYgYXBwbGljYWJsZSwgYSByZXNwb25zZSBjb2RlIHJldHVybmVkIGJ5IHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gICAgICovXG4gICAgZ2V0IHJlc3BvbnNlQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZUNvZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9zb2xhY2UuRXJyb3JTdWJjb2RlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBpZiBhcHBsaWNhYmxlLCBhbiBlcnJvciBzdWJjb2RlLiBEZWZpbmVkIGluIHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlfVxuICAgICAqL1xuICAgIGdldCBlcnJvclN1YmNvZGUoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGUtcHJvcGVydHlcbiAgICAgIHJldHVybiB0aGlzLnN1YmNvZGUgfHwgdGhpcy5fZXJyb3JTdWJjb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudCNlcnJvclN1YmNvZGV9IGluc3RlYWQuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGVycm9yU3ViQ29kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yU3ViY29kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQSB1c2VyLXNwZWNpZmllZCBvYmplY3RcbiAgICAgKiBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgcmVzcG9uc2Ugb3IgY29uZmlybWF0aW9uIGV2ZW50IGJ5IGluY2x1ZGluZyBpdCBhcyBhXG4gICAgICogcGFyYW1ldGVyIGluIHRoZSBvcmlnbmFsIEFQSSBjYWxsLiAgSWYgdGhlIHVzZXIgZGlkIG5vdCBzcGVjaWZ5IGFcbiAgICAgKiBjb3JyZWxhdGlvbktleSwgaXQgd2lsbCBiZSA8Y29kZT5udWxsPC9jb2RlPi5cbiAgICAgKi9cbiAgICBnZXQgY29ycmVsYXRpb25LZXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ycmVsYXRpb25LZXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9TdHJpbmd9XG4gICAgICogQGRlc2NyaXB0aW9uIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaWYgaXQgaXMgYXBwbGljYWJsZS5cbiAgICAgKi9cbiAgICBnZXQgcmVhc29uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYXNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSByZWFzb24gaW5mbyBvYmplY3RcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXQgcmVhc29uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9yZWFzb24gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdXBlclt1dGlsLmluc3BlY3QuY3VzdG9tXSB8fCB7fSwge1xuICAgICAgICAnc2Vzc2lvbkV2ZW50Q29kZSc6IFNlc3Npb25FdmVudENvZGUuZGVzY3JpYmUodGhpcy5zZXNzaW9uRXZlbnRDb2RlKSxcbiAgICAgICAgJ2luZm9TdHInOiAgICAgICAgICB0aGlzLmluZm9TdHIsXG4gICAgICAgICdyZXNwb25zZUNvZGUnOiAgICAgdGhpcy5yZXNwb25zZUNvZGUsXG4gICAgICAgICdlcnJvclN1YmNvZGUnOiAgICAgRXJyb3JTdWJjb2RlLmRlc2NyaWJlKHRoaXMuZXJyb3JTdWJjb2RlKSxcbiAgICAgICAgJ2NvcnJlbGF0aW9uS2V5JzogICB0aGlzLmNvcnJlbGF0aW9uS2V5ID8gdGhpcy5jb3JyZWxhdGlvbktleS50b1N0cmluZygpIDogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU2Vzc2lvbkV2ZW50O1xufVxuXG5jb25zdCBTVVBFUkNMQVNTX0ZPUl9TRVNTSU9OX0VWRU5UID0ge1xuICBbU2Vzc2lvbkV2ZW50Q29kZS5DT05ORUNUX0ZBSUxFRF9FUlJPUl06ICAgICAgICAgICAgICBPcGVyYXRpb25FcnJvcixcbiAgW1Nlc3Npb25FdmVudENvZGUuRE9XTl9FUlJPUl06ICAgICAgICAgICAgICAgICAgICAgICAgT3BlcmF0aW9uRXJyb3IsXG4gIFtTZXNzaW9uRXZlbnRDb2RlLkdVQVJBTlRFRURfTUVTU0FHRV9QVUJMSVNIRVJfRE9XTl06IE9wZXJhdGlvbkVycm9yLFxuICBbU2Vzc2lvbkV2ZW50Q29kZS5QUk9QRVJUWV9VUERBVEVfRVJST1JdOiAgICAgICAgICAgICBSZXF1ZXN0RXJyb3IsXG4gIFtTZXNzaW9uRXZlbnRDb2RlLlJFSkVDVEVEX01FU1NBR0VfRVJST1JdOiAgICAgICAgICAgIFJlcXVlc3RFcnJvcixcbiAgW1Nlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SXTogICAgICAgICAgICAgICAgUmVxdWVzdEVycm9yLFxuICBbU2Vzc2lvbkV2ZW50Q29kZS5VTlNVQlNDUklCRV9URV9UT1BJQ19FUlJPUl06ICAgICAgICBPcGVyYXRpb25FcnJvcixcbiAgW1JlcXVlc3RFdmVudENvZGUuUkVRVUVTVF9BQk9SVEVEXTogICAgICAgICAgICAgICAgICAgUmVxdWVzdEVycm9yLFxuICBbUmVxdWVzdEV2ZW50Q29kZS5SRVFVRVNUX1RJTUVPVVRdOiAgICAgICAgICAgICAgICAgICBSZXF1ZXN0RXJyb3IsXG59O1xuXG5jb25zdCBTVVBFUkNMQVNTX0FSR1MgPSBuZXcgTWFwKClcbiAgLnNldChPYmplY3QsICgpID0+IFtdKVxuICAuc2V0KE9wZXJhdGlvbkVycm9yLCAoc2VjLCBpbmZvU3RyLCByYywgc3ViY29kZSwgY2ssIHJlYXNvbikgPT4gW2luZm9TdHIsIHN1YmNvZGUsIHJlYXNvbl0pXG4gIC5zZXQoUmVxdWVzdEVycm9yLCAoc2VjLCBpbmZvU3RyLCByYywgc3ViY29kZSwgY2ssIHJlYXNvbikgPT4gW2luZm9TdHIsIHNlYywgY2ssIHJlYXNvbl0pO1xuXG5jb25zdCBUWVBFX0NBQ0hFID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBidWlsZChzZXNzaW9uRXZlbnRDb2RlLFxuICAgICAgICAgICAgICAgaW5mb1N0cixcbiAgICAgICAgICAgICAgIHJlc3BvbnNlQ29kZSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9IDAsXG4gICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICBjb25zdCBTdXBlcmNsYXNzID0gU1VQRVJDTEFTU19GT1JfU0VTU0lPTl9FVkVOVFtzZXNzaW9uRXZlbnRDb2RlXSB8fCBPYmplY3Q7XG4gIGNvbnN0IFNlc3Npb25FdmVudCA9ICgoKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IFRZUEVfQ0FDSEUuZ2V0KFN1cGVyY2xhc3MpO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgcmVzdWx0ID0gYnVpbGRUeXBlKFN1cGVyY2xhc3MpO1xuICAgIFRZUEVfQ0FDSEUuc2V0KFN1cGVyY2xhc3MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSkoKTtcbiAgY29uc3Qgc3VwZXJjbGFzc0FyZ3NCdWlsZGVyID0gKFNVUEVSQ0xBU1NfQVJHUy5nZXQoU3VwZXJjbGFzcykgfHwgKCgpID0+IFtdKSk7XG4gIGNvbnN0IHN1cGVyY2xhc3NBcmdzID0gc3VwZXJjbGFzc0FyZ3NCdWlsZGVyKHNlc3Npb25FdmVudENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdWJjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgcmV0dXJuIG5ldyBTZXNzaW9uRXZlbnQoc3VwZXJjbGFzc0FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25FdmVudENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdWJjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbn1cblxuLy8gRXhwb3NlIGEgdHlwZVxuY29uc3QgU2Vzc2lvbkV2ZW50ID0gYnVpbGRUeXBlKE9iamVjdCk7XG5TZXNzaW9uRXZlbnQuYnVpbGQgPSBidWlsZDtcblxubW9kdWxlLmV4cG9ydHMuU2Vzc2lvbkV2ZW50ID0gU2Vzc2lvbkV2ZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1ldmVudC5qcyIsImNvbnN0IE5vZGVTc2xDb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbmNvbnN0IFB1Ymxpc2hlckxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgQVBJUHJvcGVydGllcyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgQXV0aGVudGljYXRpb25TY2hlbWUgfSA9IHJlcXVpcmUoJy4vYXV0aGVudGljYXRpb24tc2NoZW1lcycpO1xuY29uc3QgeyBDaGVjayB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5cbmZ1bmN0aW9uIG1ha2VEZWZhdWx0cygpIHtcbiAgLy8gRGVmZXIgYmluZGluZy4gUHVibGlzaGVyIGNvbnN0cnVjdG9yIG1heSByZWx5IG9uIHByb2ZpbGUuXG4gIGNvbnN0IHsgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgfSA9IFB1Ymxpc2hlckxpYjtcbiAgcmV0dXJuIHtcbiAgICBfdnBuTmFtZUluVXNlOiAgICAgICAgJycsXG4gICAgX3ZpcnR1YWxSb3V0ZXJOYW1lOiAgICcnLFxuICAgIF9wMnBJbmJveEluVXNlOiAgICAgICAnJyxcbiAgICBfcDJwSW5ib3hCYXNlOiAgICAgICAgJycsXG4gICAgX3VzZXJJZGVudGlmaWNhdGlvbjogICcnLFxuICAgIF90cFByb3RvY29sSW5Vc2U6ICAgICBudWxsLFxuICAgIF90cENvbnRlbnRUeXBlOiAgICAgICAndGV4dC9wbGFpbicsXG4gICAgX3B1Ymxpc2hlclByb3BlcnRpZXM6IG5ldyBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcygpLFxuICB9O1xufVxuXG5jb25zdCBERUZBVUxUX0NJUEhFUl9TVUlURVMgPSBCVUlMRF9FTlYuVEFSR0VUX05PREUgPyBbXG4gICdFQ0RIRS1SU0EtQUVTMjU2LUdDTS1TSEEzODQnLFxuICAnRUNESEUtUlNBLUFFUzI1Ni1TSEEzODQnLFxuICAnRUNESEUtUlNBLUFFUzI1Ni1TSEEnLFxuICAnQUVTMjU2LUdDTS1TSEEzODQnLFxuICAnQUVTMjU2LVNIQTI1NicsXG4gICdBRVMyNTYtU0hBJyxcbiAgJ0VDREhFLVJTQS1ERVMtQ0JDMy1TSEEnLFxuICAnREVTLUNCQzMtU0hBJyxcbiAgJ0VDREhFLVJTQS1BRVMxMjgtR0NNLVNIQTI1NicsXG4gICdFQ0RIRS1SU0EtQUVTMTI4LVNIQTI1NicsXG4gICdFQ0RIRS1SU0EtQUVTMTI4LVNIQScsXG4gICdBRVMxMjgtR0NNLVNIQTI1NicsXG4gICdBRVMxMjgtU0hBMjU2JyxcbiAgJ0FFUzEyOC1TSEEnLFxuXS5qb2luKCcsJykgOiBudWxsO1xuXG5jb25zdCBTVVBQT1JURURfQ0lQSEVSX1NVSVRFUyA9IEJVSUxEX0VOVi5UQVJHRVRfTk9ERSA/IFtcbiAgJ0FFUzEyOC1HQ00tU0hBMjU2JyxcbiAgJ0FFUzEyOC1TSEEnLFxuICAnQUVTMTI4LVNIQTI1NicsXG4gICdBRVMyNTYtR0NNLVNIQTM4NCcsXG4gICdBRVMyNTYtU0hBJyxcbiAgJ0FFUzI1Ni1TSEEyNTYnLFxuICAnREVTLUNCQzMtU0hBJyxcbiAgJ0VDREhFLVJTQS1BRVMxMjgtR0NNLVNIQTI1NicsXG4gICdFQ0RIRS1SU0EtQUVTMTI4LVNIQScsXG4gICdFQ0RIRS1SU0EtQUVTMTI4LVNIQTI1NicsXG4gICdFQ0RIRS1SU0EtQUVTMjU2LUdDTS1TSEEzODQnLFxuICAnRUNESEUtUlNBLUFFUzI1Ni1TSEEnLFxuICAnRUNESEUtUlNBLUFFUzI1Ni1TSEEzODQnLFxuICAnRUNESEUtUlNBLURFUy1DQkMzLVNIQScsXG5dIDogbnVsbDtcblxuY29uc3QgU1VQUE9SVEVEX1NTTF9QUk9UT0NPTFMgPSBCVUlMRF9FTlYuVEFSR0VUX05PREVcbj8gW1xuICAndGxzdjEnLFxuICAndGxzdjEuMScsXG4gICd0bHN2MS4yJyxcbl1cbjogbnVsbDtcblxuLyoqXG4gKiBAbGVuZHMgU2Vzc2lvblByb3BlcnRpZXNcbiAqXG4gKi9cbmNsYXNzIFNlc3Npb25Qcm9wZXJ0aWVzQnJvd3NlciBleHRlbmRzIEFQSVByb3BlcnRpZXMge1xuICAvKipcbiAgICogVGhpcyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLiAgSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0fSBpbnN0ZWFkLCB3aGljaCBleHBsaWNpdGx5IGxpc3RzIGFsbFxuICAgKiB3ZWIgdHJhbnNwb3J0IHByb3RvY29scyB0aGF0IG1heSBiZSB1c2VkIHdoZW4gZXN0YWJsaXNoaW5nIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIHdlYiB0cmFuc3BvcnQgcHJvdG9jb2wgdGhhdCB3aWxsIGluaXRpYWxseSBiZSBzZWxlY3RlZCBieSB0aGVcbiAgICogc2Vzc2lvbiBmb3IgaXRzIGNvbm5lY3Rpb24gYXR0ZW1wdC4gSWYgdGhpcyBwcm90b2NvbCBmYWlscywgdGhlIHNlc3Npb24gd2lsbCBhdHRlbXB0IG90aGVyXG4gICAqIHByb3RvY29scyBpbiBhY2NvcmRhbmNlIHdpdGggaXRzIHRyYW5zcG9ydCBwcm90b2NvbCBjb25uZWN0IHBvbGljeS5cbiAgICpcbiAgICogSWYge0BsaW5rIHNvbGFjZS5GYWN0b3J5UHJvZmlsZSNjb21ldEVuYWJsZWR9IGlzIGB0cnVlYCwgdGhlIHNlbGVjdGlvbiBvZlxuICAgKiBhbnkge0BsaW5rIHNvbGFjZS5UcmFuc3BvcnRQcm90b2NvbH0gd2lsbCByZXN1bHQgaW4gdGhlIGluY2x1c2lvbiBvZlxuICAgKiBmYWxsYmFjayBwcm90b2NvbHMgaW4ge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN3ZWJUcmFuc3BvcnRQcm90b2NvbExpc3R9LlxuICAgKiBUaGlzIG1ha2VzIHRoZSBzZXNzaW9uIGluY29tcGF0aWJsZSB3aXRoIEd1YXJhbnRlZWQgTWVzc2FnaW5nLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBHdWFyYW50ZWVkIE1lc3NhZ2luZyBjb21wYXRpYmxlIHNlc3Npb24gd2l0aFxuICAgKiB7QGxpbmsgc29sYWNlLkZhY3RvcnlQcm9maWxlI2NvbWV0RW5hYmxlZH0gc2V0IHRvIGB0cnVlYCwgZW5zdXJlIHRoZSBzZXNzaW9uJ3NcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN3ZWJUcmFuc3BvcnRQcm90b2NvTGlzdH0gaXMgc2V0IHRvIG9ubHlcbiAgICoge0BsaW5rIHNvbGFjZS5UcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUll9LlxuICAgKlxuICAgKiAgKiBNdXR1YWxseSBleGNsdXNpdmUgdG8gcHJvcGVydHkgd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0XG4gICAqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN0cmFuc3BvcnRQcm90b2NvbFxuICAgKiBAdHlwZSB7c29sYWNlLlRyYW5zcG9ydFByb3RvY29sfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgZ2V0IHRyYW5zcG9ydFByb3RvY29sKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3RwUHJvdG9jb2wpID8gbnVsbCA6IHRoaXMuX3RwUHJvdG9jb2w7XG4gIH1cbiAgc2V0IHRyYW5zcG9ydFByb3RvY29sKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdHBQcm90b2NvbCA9IG5ld1ZhbHVlO1xuICB9XG5cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3RyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgdGltZW91dCwgaW4gbWlsbGlzZWNvbmRzLCB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSB0aGUgc2Vzc2lvbiB3aWxsIGFiYW5kb24gYVxuICAgKiBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCB0aGUgY3VycmVudCB0cmFuc3BvcnQgcHJvdG9jb2wgaWYgbm8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIGFuZCBiZWdpblxuICAgKiBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCBhIGRvd25ncmFkZWQgdHJhbnNwb3J0IHByb3RvY29sLiBJZiBubyByZW1haW5pbmcgZG93bmdyYWRlc1xuICAgKiBleGlzdCwgdGhlIHNlc3Npb24gd2lsbCBjb250aW51ZSB0aGUgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHQgdW50aWwgdGhlIGNvbm5lY3Rpb24gdGltZW91dFxuICAgKiBleHBpcmVzLiBOb3RlIHRoYXQgdGhlIFdTX0JJTkFSWSB0cmFuc3BvcnQgd2lsbCBhbHNvIGF0dGVtcHQgYSBkb3duZ3JhZGUgaWYgdGhlIHVuZGVybHlpbmdcbiAgICogV2ViU29ja2V0IGZhaWxzIHRvIGNvbm5lY3QgYmVmb3JlIHRoaXMgcGVyaW9kIGVsYXBzZXMuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+IDAuXG4gICAqIEBkZWZhdWx0IDMwMDBcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICBnZXQgdHJhbnNwb3J0RG93bmdyYWRlVGltZW91dEluTXNlY3MoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fdHBEb3duZ3JhZGVUaW1lb3V0KSA/IDMwMDAgOiB0aGlzLl90cERvd25ncmFkZVRpbWVvdXQ7XG4gIH1cbiAgc2V0IHRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdHBEb3duZ3JhZGVUaW1lb3V0ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3dlYlRyYW5zcG9ydFByb3RvY29sTGlzdFxuICAgKiBAdHlwZSB7QXJyYXkuPHNvbGFjZS5UcmFuc3BvcnRQcm90b2NvbD59XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgdXNlciBwcm92aWRlZCB3ZWIgdHJhbnNwb3J0IHByb3RvY29sIGxpc3QgaW5kaWNhdGluZyB0aGUgaW50aWFsIHByb3RvY29sXG4gICAqIHRvIGJlIHVzZWQgYnkgdGhlIHNlc3Npb24gZm9yIGl0cyBjb25uZWN0aW9uIGF0dGVtcHQsIGFuZCB0aGUgcHJvdG9jb2xzIHRvIHRyeVxuICAgKiBzdWJzZXF1ZW50bHkgaWYgdGhlIGF0dGVtcHQgZmFpbHMuXG4gICAqICAqIE11dHVhbGx5IGV4Y2x1c2l2ZSB0byBwcm9wZXJ0eSB0cmFuc3BvcnRQcm90b2NvbFxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgZ2V0IHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdCgpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl90cmFuc3BvcnRQcm90b2NvbExpc3QpXG4gICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgOiB0aGlzLl90cmFuc3BvcnRQcm90b2NvbExpc3Q7XG4gIH1cbiAgc2V0IHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3RyYW5zcG9ydFByb3RvY29sTGlzdCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIFNlc3Npb25Qcm9wZXJ0aWVzI2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbEluTXNlY3NcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFdoZW4gV2ViU29ja2V0IHRyYW5zcG9ydCBwcm90b2NvbCBpcyB1c2VkLCBTb2xDbGllbnQgdXNlcyB0aGlzIHByb3BlcnR5XG4gICAqIGFuZCB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzLm1heFdlYlBheWxvYWR9IHRvIHRocm90dGxlIHRoZSBwdWJsaXNoaW5nIHJhdGUgaW4gb3JkZXIgdG9cbiAgICogYXZvaWQgbmV0d29yayBzYXR1cmF0aW9uLlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgPj00LlxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIGdldCBidWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbClcbiAgICA/IDEwMFxuICAgIDogdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsO1xuICB9XG4gIHNldCBidWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsID0gbmV3VmFsdWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdHJhbnNwb3J0UHJvdG9jb2xJblVzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLlxuICAgKiBVc2Uge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN3ZWJUcmFuc3BvcnRQcm90b2NvbEluVXNlfSBpbnN0ZWFkLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXQgdHJhbnNwb3J0UHJvdG9jb2xJblVzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHBQcm90b2NvbEluVXNlIHx8IG51bGw7XG4gIH1cbiAgX3NldFRyYW5zcG9ydFByb3RvY29sSW5Vc2UodmFsdWUpIHtcbiAgICB0aGlzLl90cFByb3RvY29sSW5Vc2UgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjd2ViVHJhbnNwb3J0UHJvdG9jb2xJblVzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gQSByZWFkLW9ubHkgcHJvcGVydHkgYWJvdXQgdGhlIHdlYiB0cmFuc3BvcnQgcHJvdG9jb2wgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICogdXNlZCBieSB0aGUgc2Vzc2lvbiBmb3IgaXRzIGN1cnJlbnQgY29ubmVjdGlvbiBvciBjb25uZWN0aW9uIGF0dGVtcHQuIFRvIGRldGVybWluZSB3aGljaFxuICAgKiB3ZWIgdHJhbnNwb3J0IHByb3RvY29sIHdhcyBzdWNjZXNzZnVsbHkgdXNlZCBieSB0aGUgQVBJLCBpbnRlcnJvZ2F0ZSB0aGlzIHByb3BlcnR5IGFmdGVyIHRoZVxuICAgKiBzZXNzaW9uIGV2ZW50IFVQX05PVElDRSBpcyBkaXNwYXRjaGVkLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICBnZXQgd2ViVHJhbnNwb3J0UHJvdG9jb2xJblVzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHBQcm90b2NvbEluVXNlIHx8IG51bGw7XG4gIH1cbiAgX3NldFdlYlRyYW5zcG9ydFByb3RvY29sSW5Vc2UodmFsdWUpIHtcbiAgICB0aGlzLl90cFByb3RvY29sSW5Vc2UgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdHJhbnNwb3J0Q29udGVudFR5cGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uIFRyYW5zcG9ydCBjb250ZW50LXR5cGUgb3ZlcnJpZGUgZm9yIEhUVFAgdHJhbnNwb3J0c1xuICAgKiBAZGVmYXVsdCAndGV4dC9wbGFpbidcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgdHJhbnNwb3J0Q29udGVudFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RwQ29udGVudFR5cGUgfHwgJ3RleHQvcGxhaW4nO1xuICB9XG4gIHNldCB0cmFuc3BvcnRDb250ZW50VHlwZShuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3RwQ29udGVudFR5cGUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIF9sZW5kc0luc3BlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdidWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzJzogdGhpcy5idWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzLFxuICAgICAgJ3RyYW5zcG9ydENvbnRlbnRUeXBlJzogICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydENvbnRlbnRUeXBlLFxuICAgICAgJ3RyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzJzogICB0aGlzLnRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzLFxuICAgICAgJ3RyYW5zcG9ydFByb3RvY29sJzogICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydFByb3RvY29sLFxuICAgICAgJ3RyYW5zcG9ydFByb3RvY29sSW5Vc2UnOiAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydFByb3RvY29sSW5Vc2UsXG4gICAgICAnd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0JzogICAgICAgICAgIHRoaXMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0LFxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgU2Vzc2lvblByb3BlcnRpZXNOb2RlIGV4dGVuZHMgQVBJUHJvcGVydGllcyB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCB0cmFuc3BvcnRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHBQcm90b2NvbDtcbiAgfVxuICBzZXQgdHJhbnNwb3J0UHJvdG9jb2wodmFsdWUpIHtcbiAgICB0aGlzLl90cFByb3RvY29sID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRQcm90b2NvbExpc3Q7XG4gIH1cbiAgc2V0IHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdCh2YWx1ZSkge1xuICAgIHRoaXMuX3RyYW5zcG9ydFByb3RvY29sTGlzdCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzKCkge1xuICAgIHJldHVybiB0aGlzLl90cERvd25ncmFkZVRpbWVvdXQgfHwgODY0MDAwMDA7IC8vIEFsbCBkYXlcbiAgfVxuICBzZXQgdHJhbnNwb3J0RG93bmdyYWRlVGltZW91dEluTXNlY3ModmFsdWUpIHtcbiAgICB0aGlzLl90cERvd25ncmFkZVRpbWVvdXQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldCB0cmFuc3BvcnRQcm90b2NvbEluVXNlKCkge1xuICAgIHJldHVybiB0aGlzLl90cFByb3RvY29sSW5Vc2U7XG4gIH1cbiAgX3NldFRyYW5zcG9ydFByb3RvY29sSW5Vc2UodmFsdWUpIHtcbiAgICB0aGlzLl90cFByb3RvY29sSW5Vc2UgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCB3ZWJUcmFuc3BvcnRQcm90b2NvbEluVXNlKCkge1xuICAgIHJldHVybiB0aGlzLl90cFByb3RvY29sSW5Vc2U7XG4gIH1cbiAgX3NldFdlYlRyYW5zcG9ydFByb3RvY29sSW5Vc2UodmFsdWUpIHtcbiAgICB0aGlzLl90cFByb3RvY29sSW5Vc2UgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCB0cmFuc3BvcnRDb250ZW50VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHBDb250ZW50VHlwZTtcbiAgfVxuICBzZXQgdHJhbnNwb3J0Q29udGVudFR5cGUodmFsdWUpIHtcbiAgICB0aGlzLl90cENvbnRlbnRUeXBlID0gdmFsdWU7XG4gIH1cblxuICAvLyBUTFMgY29ubmVjdGlvbiBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xFeGNsdWRlZFByb3RvY29sc1xuICAgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59XG4gICAqIEBkZXNjcmlwdGlvbiBBbiBhcnJheSBvZiBUTFMgcHJvdG9jb2xzIHRvIGJlIGV4Y2x1ZGVkIHdoZW4gbmVnb3RpYXRpbmcgd2hpY2ggcHJvdG9jb2xcbiAgICogdG8gdXNlLlxuICAgKiAgKiBBbGxvd2VkIHZhbHVlcyBhcmU6IFRMU3YxLCBUTFN2MS4xLCBUTFN2MS4yXG4gICAqICAqIE5vdGU6IHdoZW4gYSBwcm90b2NvbCB2ZXJzaW9uIGlzIGV4Y2x1ZGVkIHdpdGhvdXQgZXhjbHVkaW5nIGFsbCBvZiBpdHNcbiAgICogICAgcHJldmlvdXMgcHJvdG9jb2wgdmVyc2lvbnMsIHRoZSBlZmZlY3QgaXMgdG8gYWxzbyBleGNsdWRlIGFsbCBzdWJzZXF1ZW50XG4gICAqICAgIHByb3RvY29sIHZlcnNpb25zLlxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IHNzbEV4Y2x1ZGVkUHJvdG9jb2xzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbEV4Y2x1ZGVkUHJvdG9jb2xzKVxuICAgICAgPyBudWxsXG4gICAgICA6IHRoaXMuX3NzbEV4Y2x1ZGVkUHJvdG9jb2xzO1xuICB9XG4gIHNldCBzc2xFeGNsdWRlZFByb3RvY29scyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3NzbEV4Y2x1ZGVkUHJvdG9jb2xzID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbENpcGhlclN1aXRlc1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gQSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBjaXBoZXIgc3VpdGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2UgdXNlZCBmb3IgVExTXG4gICAqIGNvbm5lY3Rpb25zLlxuICAgKiAgKiBBbGxvd2VkIHZhbHVlczpcbiAgICogICAgICogQUVTMTI4LUdDTS1TSEEyNTZcbiAgICogICAgICogQUVTMTI4LVNIQVxuICAgKiAgICAgKiBBRVMxMjgtU0hBMjU2XG4gICAqICAgICAqIEFFUzI1Ni1HQ00tU0hBMzg0XG4gICAqICAgICAqIEFFUzI1Ni1TSEFcbiAgICogICAgICogQUVTMjU2LVNIQTI1NlxuICAgKiAgICAgKiBERVMtQ0JDMy1TSEFcbiAgICogICAgICogRUNESEUtUlNBLUFFUzEyOC1HQ00tU0hBMjU2XG4gICAqICAgICAqIEVDREhFLVJTQS1BRVMxMjgtU0hBXG4gICAqICAgICAqIEVDREhFLVJTQS1BRVMxMjgtU0hBMjU2XG4gICAqICAgICAqIEVDREhFLVJTQS1BRVMyNTYtR0NNLVNIQTM4NFxuICAgKiAgICAgKiBFQ0RIRS1SU0EtQUVTMjU2LVNIQVxuICAgKiAgICAgKiBFQ0RIRS1SU0EtQUVTMjU2LVNIQTM4NFxuICAgKiAgICAgKiBFQ0RIRS1SU0EtREVTLUNCQzMtU0hBXG4gICAqICAgICAqIFJDNC1TSEFcbiAgICogICAgICogUkM0LU1ENVxuICAgKiBAZGVmYXVsdCB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzLkRFRkFVTFRfQ0lQSEVSX1NVSVRFU31cbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICBnZXQgc3NsQ2lwaGVyU3VpdGVzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbENpcGhlclN1aXRlcylcbiAgICAgID8gREVGQVVMVF9DSVBIRVJfU1VJVEVTXG4gICAgICA6IHRoaXMuX3NzbENpcGhlclN1aXRlcztcbiAgfVxuICBzZXQgc3NsQ2lwaGVyU3VpdGVzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3NsQ2lwaGVyU3VpdGVzID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFZhbGlkYXRlQ2VydGlmaWNhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvbiBXaGV0aGVyIHRoZSBzZXJ2ZXIgY2VydGlmaWNhdGUgc2hhbGwgYmUgdmVyaWZpZWQgYWdhaW5zdCB0aGUgbGlzdCBvZlxuICAgKiBjZXJ0aWZpY2F0ZXMgaW4gdGhlIHRydXN0IHN0b3Jlcy4gSWYgc2V0IHRvIGZhbHNlLCBhbGwgY2VydGlmaWNhdGUgdmFsaWRhdGlvbiBpcyBkaXNhYmxlZCxcbiAgICogaW5jbHVkaW5nIGRhdGUsIGhvc3RuYW1lIGFuZCBjb21tb24gbmFtZSB2YWxpZGF0aW9uLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IHNzbFZhbGlkYXRlQ2VydGlmaWNhdGUoKSB7XG4gICAgLy8gaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgdGhlbiB1c2UgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICBpZiAodGhpcy5fc3NsVmFsaWRhdGVDZXJ0ID09PSB1bmRlZmluZWQpIHJldHVybiAocHJvY2Vzcy5lbnYuTk9ERV9UTFNfUkVKRUNUX1VOQVVUSE9SSVpFRCAhPT0gJzAnKTtcbiAgICBpZiAodGhpcy5fc3NsVmFsaWRhdGVDZXJ0ID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fc3NsVmFsaWRhdGVDZXJ0O1xuICB9XG4gIHNldCBzc2xWYWxpZGF0ZUNlcnRpZmljYXRlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3NsVmFsaWRhdGVDZXJ0ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFRydXN0U3RvcmVzXG4gICAqIEB0eXBlIHtBcnJheS48U3RyaW5nPn1cbiAgICogQGRlc2NyaXB0aW9uIEFuIGFycmF5IG9mIGZpbGUgbmFtZXMgb2YgdHJ1c3RlZCBjZXJ0aWZpY2F0ZXMgaW4gUEVNIGZvcm1hdC5cbiAgICogSWYgbm90IHNldCwgYW5kIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjc3NsVmFsaWRhdGVDZXJ0aWZpY2F0ZX0gaXMgc2V0IHRvIHRydWUsXG4gICAqIHRoZSBzZXJ2ZXIgY2VydGlmaWNhdGUgd2lsbCBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB3ZWxsIGtub3duIFwicm9vdFwiIENBcy5cbiAgICogICAgKiBNdXR1YWxseSBleGNsdXNpdmUgdG8gc3NsUGZ4IHByb3BlcnR5IHdoZW5cbiAgICogICAgICB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFZhbGlkYXRlQ2VydGlmaWNhdGV9IGlzIHNldFxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IHNzbFRydXN0U3RvcmVzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbFRydXN0U3RvcmVzKVxuICAgICAgPyBudWxsXG4gICAgICA6IHRoaXMuX3NzbFRydXN0U3RvcmVzO1xuICB9XG4gIHNldCBzc2xUcnVzdFN0b3JlcyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3NzbFRydXN0U3RvcmVzID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFRydXN0ZWRDb21tb25OYW1lTGlzdFxuICAgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59XG4gICAqIEBkZXNjcmlwdGlvbiBBbiBhcnJheSBvZiBhY2NlcHRhYmxlIGNvbW1vbiBuYW1lcyBmb3IgbWF0Y2hpbmcgd2l0aCB0aGUgc2VydmVyIGNlcnRpZmljYXRlLlxuICAgKiBJZiBzZXQgdG8gYSBub24tZW1wdHkgYXJyYXksIHRoZSBBUEkgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBob3N0bmFtZSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAqIHByb3ZpZGVkIGJ5IE5vZGUuanMgd2l0aCBpdHMgb3duIGltcGxlbWVuYXRpb247IGlmIHNldCB0byBlbXB0eSBhcnJheSwgbm8gaG9zdG5hbWVcbiAgICogdmFsaWRhdGlvbiB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogICAgKiBPbmx5IHJlbGV2YW50IHdoZW4ge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xWYWxpZGF0ZUNlcnRpZmljYXRlfSBpcyBzZXRcbiAgICogICAgICB0byB0cnVlXG4gICAqICAgICogTm90ZSB0aGF0IGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlIHBhcnQgb2YgdGhlIGNvbW1vblxuICAgKiAgICAgIG5hbWVzIGFuZCBhcmUgbm90IGlnbm9yZWRcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIGdldCBzc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3QoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fc3NsVHJ1c3RlZENOTGlzdClcbiAgICAgID8gbnVsbFxuICAgICAgOiB0aGlzLl9zc2xUcnVzdGVkQ05MaXN0O1xuICB9XG4gIHNldCBzc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3QobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zc2xUcnVzdGVkQ05MaXN0ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvLyBDbGllbnQgY2VydGlmaWNhdGVzIHJlbGF0ZWRcblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3NzbFBmeFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGZpbGUgbmFtZSBvZiBhIGZpbGUgY29udGFpbmluZyBwcml2YXRlIGtleSwgY2VydGlmaWNhdGUgYW5kIG9wdGlvbmFsXG4gICAqIENBIGNlcnRpZmljYXRlcyBvZiB0aGUgY2xpZW50IGluIFBGWCBvciBQS0NTMTIgZm9ybWF0LlxuICAgKiAgICAqIE9ubHkgcmVsZXZhbnQgd2hlblxuICAgKiAgICAgIHtAbGluayBzb2xhY2UuQXV0aGVudGljYXRpb25TY2hlbWUuQ0xJRU5UX0NFUlRJRklDQVRFfSBpcyB1c2VkXG4gICAqICAgICogTXV0dWFsbHkgZXhjbHVzaXZlIHRvIHNzbFByaXZhdGVLZXksIHNzbENlcnRpZmljYXRlIGFuZCBzc2xUcnVzdFN0b3JlcyBwcm9wZXJ0aWVzXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICBnZXQgc3NsUGZ4KCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbFBmeClcbiAgICAgID8gJydcbiAgICAgIDogdGhpcy5fc3NsUGZ4O1xuICB9XG4gIHNldCBzc2xQZngobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zc2xQZnggPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjc3NsUGZ4UGFzc3dvcmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5pbmcgcGFzc3dvcmQgZm9yIHRoZSBjbGllbnQgcGZ4IGZpbGUuXG4gICAqICAgICogT25seSByZWxldmFudCB3aGVuXG4gICAqICAgICAge0BsaW5rIHNvbGFjZS5BdXRoZW50aWNhdGlvblNjaGVtZS5DTElFTlRfQ0VSVElGSUNBVEV9IGlzIHVzZWRcbiAgICogQGRlZmF1bHQgZW1wdHkgc3RyaW5nXG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IHNzbFBmeFBhc3N3b3JkKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbFBmeFBhc3N3ZCkgPyAnJyA6IHRoaXMuX3NzbFBmeFBhc3N3ZDtcbiAgfVxuICBzZXQgc3NsUGZ4UGFzc3dvcmQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zc2xQZnhQYXNzd2QgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjc3NsUHJpdmF0ZUtleVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGZpbGUgbmFtZSBvZiBhIGZpbGUgY29udGFpbmluZyBwcml2YXRlIGtleSBvZiB0aGUgY2xpZW50IGluIFBFTSBmb3JtYXQuXG4gICAqICAgICogT25seSByZWxldmFudCB3aGVuXG4gICAqICAgICAge0BsaW5rIHNvbGFjZS5BdXRoZW50aWNhdGlvblNjaGVtZS5DTElFTlRfQ0VSVElGSUNBVEV9IGlzIHVzZWRcbiAgICogICAgKiBNdXR1YWxseSBleGNsdXNpdmUgdG8gc3NsUGZ4IHByb3BlcnR5XG4gICAqIEBkZWZhdWx0IGVtcHR5IHN0cmluZ1xuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIGdldCBzc2xQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbFByaXZhdGVLZXkpID8gJycgOiB0aGlzLl9zc2xQcml2YXRlS2V5O1xuICB9XG4gIHNldCBzc2xQcml2YXRlS2V5KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3NsUHJpdmF0ZUtleSA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzc2xQcml2YXRlS2V5UGFzc3dvcmRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uIEEgc3RyaW5nIGNvbnRhaW5nIHBhc3N3b3JkIGZvciB0aGUgY2xpZW50IHByaXZhdGUga2V5LlxuICAgKiAgICAqIE9ubHkgcmVsZXZhbnQgd2hlblxuICAgKiAgICAgIHtAbGluayBzb2xhY2UuQXV0aGVudGljYXRpb25TY2hlbWUuQ0xJRU5UX0NFUlRJRklDQVRFfSBpcyB1c2VkXG4gICAqIEBkZWZhdWx0IGVtcHR5IHN0cmluZ1xuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIGdldCBzc2xQcml2YXRlS2V5UGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fc3NsUHJpdmF0ZUtleVBhc3N3ZCkgPyAnJyA6IHRoaXMuX3NzbFByaXZhdGVLZXlQYXNzd2Q7XG4gIH1cbiAgc2V0IHNzbFByaXZhdGVLZXlQYXNzd29yZChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3NzbFByaXZhdGVLZXlQYXNzd2QgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjc3NsQ2VydGlmaWNhdGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBmaWxlIG5hbWUgb2YgYSBmaWxlIGNvbnRhaW5pbmcgY2VydGlmaWNhdGUga2V5IG9mIHRoZSBjbGllbnQgaW4gUEVNXG4gICAqIGZvcm1hdC5cbiAgICogICAgKiBPbmx5IHJlbGV2YW50IHdoZW5cbiAgICogICAgICB7QGxpbmsgc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLkNMSUVOVF9DRVJUSUZJQ0FURX0gaXMgdXNlZFxuICAgKiAgICAqIE11dHVhbGx5IGV4Y2x1c2l2ZSB0byBzc2xQZnggcHJvcGVydHlcbiAgICogQGRlZmF1bHQgZW1wdHkgc3RyaW5nXG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IHNzbENlcnRpZmljYXRlKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NzbENlcnRpZmljYXRlKSA/ICcnIDogdGhpcy5fc3NsQ2VydGlmaWNhdGU7XG4gIH1cbiAgc2V0IHNzbENlcnRpZmljYXRlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3NsQ2VydGlmaWNhdGUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8vIFRMUyBjb25uZWN0aW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQG5hbWUgU2Vzc2lvblByb3BlcnRpZXMjc3NsUHJvdG9jb2xcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBTU0wgcHJvdG9jb2xzIHRvIHVzZS5cbiAgICogICAgKiBBbGxvd2VkIHZhbHVlcyBhcmU6IFNTTHYzLCBUTFN2MSwgVExTdjEuMSwgVExTdjEuMlxuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIGdldCBzc2xQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3NsUHJvdG9jb2w7XG4gIH1cbiAgc2V0IHNzbFByb3RvY29sKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3NsUHJvdG9jb2wgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIF9sZW5kc0luc3BlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdzc2xFeGNsdWRlZFByb3RvY29scyc6ICAgICB0aGlzLnNzbEV4Y2x1ZGVkUHJvdG9jb2xzLFxuICAgICAgJ3NzbENpcGhlclN1aXRlcyc6ICAgICAgICAgIHRoaXMuc3NsQ2lwaGVyU3VpdGVzLFxuICAgICAgJ3NzbFZhbGlkYXRlQ2VydGlmaWNhdGUnOiAgIHRoaXMuc3NsVmFsaWRhdGVDZXJ0aWZpY2F0ZSxcbiAgICAgICdzc2xUcnVzdFN0b3Jlcyc6ICAgICAgICAgICB0aGlzLnNzbFRydXN0U3RvcmVzLFxuICAgICAgJ3NzbFRydXN0ZWRDb21tb25OYW1lTGlzdCc6IHRoaXMuc3NsVHJ1c3RlZENvbW1vbk5hbWVMaXN0LFxuICAgICAgJ3NzbFBmeCc6ICAgICAgICAgICAgICAgICAgIHRoaXMuc3NsUGZ4LFxuICAgICAgJ3NzbFBmeFBhc3N3b3JkJzogICAgICAgICAgIHRoaXMuc3NsUGZ4UGFzc3dvcmQgPyAnKioqKionIDogdGhpcy5zc2xQZnhQYXNzd29yZCxcbiAgICAgICdzc2xQcml2YXRlS2V5JzogICAgICAgICAgICB0aGlzLnNzbFByaXZhdGVLZXksXG4gICAgICAnc3NsUHJpdmF0ZUtleVBhc3N3b3JkJzogICAgdGhpcy5zc2xQcml2YXRlS2V5UGFzc3dvcmQgPyAnKioqKionIDogdGhpcy5zc2xQcml2YXRlS2V5UGFzc3dvcmQsXG4gICAgICAnc3NsQ2VydGlmaWNhdGUnOiAgICAgICAgICAgdGhpcy5zc2xDZXJ0aWZpY2F0ZSxcbiAgICAgICdzc2xQcm90b2NvbCc6ICAgICAgICAgICAgICB0aGlzLnNzbFByb3RvY29sLFxuICAgIH07XG4gIH1cbn1cblxuY29uc3QgU2Vzc2lvblByb3BlcnRpZXNCYXNlID0gQlVJTERfRU5WLlRBUkdFVF9OT0RFXG4gID8gU2Vzc2lvblByb3BlcnRpZXNOb2RlXG4gIDogU2Vzc2lvblByb3BlcnRpZXNCcm93c2VyO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcHJlc2VudHMgYSBzZXNzaW9uIHByb3BlcnRpZXMgb2JqZWN0LiBQYXNzZWQgaW4gdG9cbiAqIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVTZXNzaW9ufSB3aGVuIGNyZWF0aW5nIGEge0BsaW5rIHNvbGFjZS5TZXNzaW9ufSBpbnN0YW5jZS5cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBleHRlbmRzIEFQSVByb3BlcnRpZXNcbiAqL1xuY2xhc3MgU2Vzc2lvblByb3BlcnRpZXMgZXh0ZW5kcyBTZXNzaW9uUHJvcGVydGllc0Jhc2Uge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUHJvcGVydGllcyB0byBhcHBseSB0byB0aGUgbmV3bHkgY29uc3RydWN0ZWQgb2JqZWN0LlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG1ha2VEZWZhdWx0cygpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2NoZW1lIHVzZWQgd2hlbiBlc3RhYmxpc2hpbmcgdGhlIHNlc3Npb24uXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNhdXRoZW50aWNhdGlvblNjaGVtZVxuICAgKiBAdHlwZSB7c29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lfVxuICAgKiBAZGVmYXVsdCB7QGxpbmsgc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLkJBU0lDfVxuICAgKi9cbiAgZ2V0IGF1dGhlbnRpY2F0aW9uU2NoZW1lKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2F1dGhTY2hlbWUpXG4gICAgICAgID8gQXV0aGVudGljYXRpb25TY2hlbWUuQkFTSUNcbiAgICAgICAgOiB0aGlzLl9hdXRoU2NoZW1lO1xuICB9XG4gIHNldCBhdXRoZW50aWNhdGlvblNjaGVtZShuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2F1dGhTY2hlbWUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVVJMIG9yIFVSTHMgb2YgdGhlIG1lc3NhZ2luZyBzZXJ2aWNlIHRvIGNvbm5lY3QgdG8uICBUaGUgVVJMIGlzIHR5cGljYWxseSBvZiB0aGUgZm9ybVxuICAgKiBgPHByb3RvY29sPjovLzxob3N0Wzpwb3J0XT5gLCB3aGVyZTpcbiAgICogICogYHByb3RvY29sYCBpcyBvbmUgb2YgYHdzYCwgYHdzc2AsIGBodHRwYCwgYGh0dHBzYCwgYHRjcGAgb3IgYHRjcHNgLlxuICAgKiAgKGB0Y3BgIGFuZCBgdGNwc2Agc3VwcG9ydGVkIGluIG5vZGVqcyBvbmx5LilcbiAgICogICogYGhvc3RgIGlzIGEgaG9zdG5hbWUgb3IgSVAgYWRkcmVzcyBvZiB0aGUgcm91dGVyIHRvIGNvbm5lY3QgdG8uXG4gICAqICAqIGBwb3J0YCBpcyB0aGUgcG9ydCBvbiB3aGljaCB0aGUgbWVzc2FnaW5nIHNlcnZpY2UgaXMgbGlzdGVuaW5nLiBUaGUgZGVmYXVsdCBpcyB0aGVcbiAgICogICAgd2VsbC1rbm93biBwb3J0IGZvciB0aGUgc2VydmljZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHByb3RvY29sLCBpZiBhbnkuXG4gICAqXG4gICAqIEFkZGl0aW9uYWxseSwgbm90ZTpcbiAgICogICogV2hlbiBhbiBBcnJheSBpcyBwcm92aWRlZCwgZWFjaCBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nIG9mIHRoZSBhYm92ZSBmb3JtYXQuXG4gICAqICAgIFRoZSBBUEkgd2lsbCBhdHRlbXB0IHRvIGNvbm5lY3QgdG8gdGhlc2UgVVJMcyBpbiB0aGUgc3BlY2lmaWVkIG9yZGVyLlxuICAgKiAgKiBDcm9zcy1kb21haW4gcmVzdHJpY3Rpb25zIHNob3VsZCBiZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24gd2hlbiBkZXBsb3lpbmcgd2ViXG4gICAqICAgIGFwcGxpY2F0aW9ucyB3aXRoIG1lc3NhZ2luZyBjYXBhYmlsaXRpZXMuIFNlZSB0aGUgQVBJIFVzZXIgR3VpZGUgZm9yIG1vcmVcbiAgICogICAgaW5mb3JtYXRpb24uXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN1cmxcbiAgICogQHR5cGUge1N0cmluZ3xBcnJheS48U3RyaW5nPn1cbiAgICogQGRlZmF1bHQgXCJcIlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl91cmwpID8gJycgOiB0aGlzLl91cmw7XG4gIH1cblxuICBzZXQgdXJsKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gbmV3VmFsdWU7XG4gIH1cblxuICAvLyAgPT09PT09PT09PT09PT09PT09PT09PT09IENyZWRlbnRpYWxzICA9PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3Bhc3N3b3JkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgcGFzc3dvcmQgcmVxdWlyZWQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKiBAZGVmYXVsdCBcIlwiXG4gICAqL1xuICBnZXQgcGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fcGFzc3dvcmQpID8gJycgOiB0aGlzLl9wYXNzd29yZDtcbiAgfVxuXG4gIHNldCBwYXNzd29yZChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3Bhc3N3b3JkID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3VzZXJOYW1lXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvbiAgVGhlIGNsaWVudCB1c2VybmFtZSByZXF1aXJlZCBmb3IgYXV0aGVudGljYXRpb24uXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICovXG4gIGdldCB1c2VyTmFtZSgpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl91c2VyTmFtZSkgPyAnJyA6IHRoaXMuX3VzZXJOYW1lO1xuICB9XG5cbiAgc2V0IHVzZXJOYW1lKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdXNlck5hbWUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjY2xpZW50TmFtZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJyAoYXV0b21hdGljYWxseSBnZW5lcmF0ZWQpXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgY2xpZW50IG5hbWUgdGhhdCBpcyB1c2VkIGR1cmluZyBsb2dpbiBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc2Vzc2lvblxuICAgKiBvbiB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyLlxuICAgKiAgKiBBbiBlbXB0eSBzdHJpbmcgY2F1c2VzIGEgdW5pcXVlIGNsaWVudCBuYW1lIHRvIGJlIGdlbmVyYXRlZFxuICAgKiAgICAgYXV0b21hdGljYWxseS5cbiAgICogICogSWYgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGEgdmFsaWQgVG9waWMgbmFtZSwgYW5kIGEgbWF4aW11bSBvZiAxNjAgYnl0ZXMgaW4gbGVuZ3RoLlxuICAgKiAgKiBUaGlzIHByb3BlcnR5IGlzIGFsc28gdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSB0aGUgc2VuZGVyIGluXG4gICAqICAgIGEgbWVzc2FnZSdzIHNlbmRlcklkIGZpZWxkIGlmIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMuaW5jbHVkZVNlbmRlcklkfVxuICAgKiAgICBpcyBzZXQuXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICovXG4gIGdldCBjbGllbnROYW1lKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2NsaWVudE5hbWUpID8gJycgOiB0aGlzLl9jbGllbnROYW1lO1xuICB9XG5cbiAgc2V0IGNsaWVudE5hbWUobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9jbGllbnROYW1lID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzdHJpbmcgdGhhdCB1bmlxdWVseSBkZXNjcmliZXMgdGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlLlxuICAgKiAgKiBJZiBsZWZ0IGJsYW5rLCB0aGUgQVBJIHdpbGwgZ2VuZXJhdGUgYSBkZXNjcmlwdGlvbiBzdHJpbmdcbiAgICogICAgdXNpbmcgdGhlIGN1cnJlbnQgdXNlci1hZ2VudCBzdHJpbmcuXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2FwcGxpY2F0aW9uRGVzY3JpcHRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBhcHBsaWNhdGlvbkRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2FwcERlc2MpID8gJycgOiB0aGlzLl9hcHBEZXNjO1xuICB9XG4gIHNldCBhcHBsaWNhdGlvbkRlc2NyaXB0aW9uKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fYXBwRGVzYyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNZXNzYWdlIFZQTiBuYW1lIHRoYXQgdGhlIGNsaWVudCBpcyByZXF1ZXN0aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3Zwbk5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB2cG5OYW1lKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3Zwbk5hbWUpID8gJycgOiB0aGlzLl92cG5OYW1lO1xuICB9XG4gIHNldCB2cG5OYW1lKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fdnBuTmFtZSA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IHNlc3Npb24gcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgd2hpY2ggTWVzc2FnZVxuICAgKiBWUE4gdGhlIHNlc3Npb24gaXMgY29ubmVjdGVkIHRvLiBXaGVuIG5vdCBjb25uZWN0ZWQsIG9yIHdoZW4gbm90IGluIGNsaWVudCBtb2RlLFxuICAgKiBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gICAqIEBkZWZhdWx0IFwiXCJcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3Zwbk5hbWVJblVzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2cG5OYW1lSW5Vc2UoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fdnBuTmFtZUluVXNlKSA/ICcnIDogdGhpcy5fdnBuTmFtZUluVXNlO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZwbiBuYW1lIGN1cnJlbnRseSBiZWluZyB1c2VkLlxuICAgKi9cbiAgX3NldFZwbk5hbWVJblVzZSh2YWx1ZSkge1xuICAgIHRoaXMuX3Zwbk5hbWVJblVzZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyN2aXJ0dWFsUm91dGVyTmFtZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gQSByZWFkLW9ubHkgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgdGhlIGNvbm5lY3RlZCBTb2xhY2UgTWVzc2FnZSBSb3V0ZXInc1xuICAgKiB2aXJ0dWFsIHJvdXRlciBuYW1lLlxuICAgKiBAZGVmYXVsdCBcIlwiXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZpcnR1YWxSb3V0ZXJOYW1lKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3ZpcnR1YWxSb3V0ZXJOYW1lKSA/ICcnIDogdGhpcy5fdmlydHVhbFJvdXRlck5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY3VycmVudCB2aXJ0dWFsIHJvdXRlciBuYW1lLlxuICAgKi9cbiAgX3NldFZpcnR1YWxSb3V0ZXJOYW1lKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlydHVhbFJvdXRlck5hbWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vICA9PT09PT09PT09PT09PT09PT09PT09PT0gQ29ubmVjdGlvbiBTdHJhdGVnaWVzID09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2Nvbm5lY3RUaW1lb3V0SW5Nc2Vjc1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHRpbWVvdXQgcGVyaW9kIChpbiBtaWxsaXNlY29uZHMpIGZvciBhIGNvbm5lY3Qgb3BlcmF0aW9uIHRvIGEgZ2l2ZW4gaG9zdC5cbiAgICogIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyA4MDAwLlxuICAgKiAgICogVGhlIHZhbGlkIHJhbmdlIGlzID4gMC5cbiAgICogQGRlZmF1bHQgODAwMFxuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjY29ubmVjdFRpbWVvdXRJbk1zZWNzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgdGltZW91dCBwZXJpb2QgKGluIG1pbGxpc2Vjb25kcykgZm9yIGEgY29ubmVjdCBvcGVyYXRpb24gdG8gYSBnaXZlbiBob3N0LlxuICAgKiAgSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGNhbGN1bGF0ZWQgYXMgc2hvd24gYmVsb3cuXG4gICAqICAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgPiAwLlxuICAgKiBAZGVmYXVsdCBtYXgoODAwMCwgMTAwMCArIHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdC5sZW5ndGggKiB0cmFuc3BvcnREb3duZ3JhZGVUaW1lb3V0SW5Nc2VjcylcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICBnZXQgY29ubmVjdFRpbWVvdXRJbk1zZWNzKCkge1xuICAgIGlmIChDaGVjay5ub3RoaW5nKHRoaXMuX2Nvbm5lY3RUaW1lb3V0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENvbm5lY3RUaW1lb3V0SW5Nc2VjcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RUaW1lb3V0O1xuICB9XG4gIHNldCBjb25uZWN0VGltZW91dEluTXNlY3MobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRlZmF1bHRDb25uZWN0VGltZW91dEluTXNlY3MoKSB7XG4gICAgY29uc3QgbWluVGltZW91dCA9IDgwMDA7XG4gICAgY29uc3QgeyB3ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QsIHRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRyYW5zcG9ydENvdW50ID0gd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0ID8gd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0Lmxlbmd0aCA6IDE7XG4gICAgY29uc3QgbWFyZ2luID0gdHJhbnNwb3J0Q291bnQgPiAxID8gMTAwMCA6IDA7XG4gICAgY29uc3QgY29ubmVjdERvd25ncmFkZURlZmF1bHQgPSB0cmFuc3BvcnRDb3VudCAqIHRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzICsgbWFyZ2luO1xuICAgIHJldHVybiBNYXRoLm1heChtaW5UaW1lb3V0LCBjb25uZWN0RG93bmdyYWRlRGVmYXVsdCk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2Nvbm5lY3RSZXRyaWVzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGNvbm5lY3RpbmcgZHVyaW5nIGluaXRpYWwgY29ubmVjdGlvbiBzZXR1cC5cbiAgICpcbiAgICogV2hlbiB1c2luZyBhIGhvc3QgbGlzdCwgZWFjaCB0cmF2ZXJzYWwgb2YgdGhlIGxpc3QgaXMgY29uc2lkZXJlZCBhIHRyeTsgdGhlcmVmb3JlLCBpZlxuICAgKiBgY29ubmVjdFJldHJpZXMgPT09IDJgLCB0aGUgaG9zdCBsaXN0IHdpbGwgYmUgdHJhdmVyc2VkIHVwIHRvIHRocmVlIHRpbWVzOiBvbmNlXG4gICAqIGZvciB0aGUgaW5pdGlhbCB0cnksIGFuZCB0d2ljZSBtb3JlIGZvciB0aGUgcmV0cmllcy4gRWFjaCByZXRyeSBiZWdpbnMgd2l0aCB0aGUgZmlyc3QgaG9zdFxuICAgKiBsaXN0ZWQuIEFmdGVyIGVhY2ggdW5zdWNjZXNzZnVsIGF0dGVtcHQgdG8gY29ubmVjdCB0byBhIGhvc3QsIHRoZSBBUEkgd2FpdHMgZm9yIHRoZSBhbW91bnRcbiAgICogb2YgdGltZSBzZXQgZm9yIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjcmVjb25uZWN0UmV0cnlXYWl0SW5Nc2Vjc30gYmVmb3JlIGF0dGVtcHRpbmdcbiAgICogYW5vdGhlciBjb25uZWN0aW9uLiBUaGUgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQgbWF5IGJlIHRvIHRoZSBzYW1lIGhvc3QsXG4gICAqIHNlZSB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2Nvbm5lY3RSZXRyaWVzUGVySG9zdH0uXG4gICAqXG4gICAqIElmIGFuIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gZmFpbHMsIHRoZSByZWNvbm5lY3Rpb24gaXMgYXR0ZW1wdGVkIHdpdGhcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNyZWNvbm5lY3RSZXRyaWVzfSByZXRyaWVzIGluc3RlYWQuXG4gICAqXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyBjb25uZWN0UmV0cmllcyA+PSAtMS5cbiAgICogICogLTEgbWVhbnMgdHJ5IHRvIGNvbm5lY3QgZm9yZXZlci5cbiAgICogICogMCBtZWFucyBubyBhdXRvbWF0aWMgY29ubmVjdGlvbiByZXRyaWVzOyB0aGUgQVBJIHdpbGwgdHJ5IG9uY2UgYW5kIHRoZW4gZ2l2ZSB1cC5cbiAgICogICogY29ubmVjdFJldHJpZXMgPj0gMSBtZWFucyByZWF0dGVtcHQgY29ubmVjdGlvbiBuIHRpbWVzLlxuICAgKiBAZGVmYXVsdCAyMFxuICAgKi9cbiAgZ2V0IGNvbm5lY3RSZXRyaWVzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2Nvbm5lY3RSZXRyaWVzKSA/IDIwIDogdGhpcy5fY29ubmVjdFJldHJpZXM7XG4gIH1cbiAgc2V0IGNvbm5lY3RSZXRyaWVzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fY29ubmVjdFJldHJpZXMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjY29ubmVjdFJldHJpZXNQZXJIb3N0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBXaGVuIHVzaW5nIGEgaG9zdCBsaXN0LCB0aGlzIHByb3BlcnR5IGRlZmluZXMgaG93IG1hbnkgdGltZXMgdG9cbiAgICogdHJ5IHRvIGNvbm5lY3QgdG8gYSBzaW5nbGUgaG9zdCBiZWZvcmUgbW92aW5nIHRvIHRoZSBuZXh0IGhvc3QgaW4gdGhlIGxpc3QuXG4gICAqXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyBjb25uZWN0UmV0cmllc1Blckhvc3QgPj0gLTEuXG4gICAqICAqIC0xIG1lYW5zIGF0dGVtcHQgYW4gaW5maW5pdGUgbnVtYmVyIG9mIGNvbm5lY3Rpb24gcmV0cmllcy4gVGhlIEFQSSB3aWxsIG9ubHlcbiAgICogICAgYXR0ZW1wdCB0byBjb25uZWN0IHRvIHRoZSBmaXJzdCBob3N0IGluIHRoZSBsaXN0LlxuICAgKiAgKiAwIG1lYW5zIG1ha2UgYSBzaW5nbGUgY29ubmVjdGlvbiBhdHRlbXB0IHBlciBob3N0LCB3aXRoIG5vIHJldHJpZXMuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCBjb25uZWN0UmV0cmllc1Blckhvc3QoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fY29ubmVjdFJldHJpZXNQZXJIb3N0KSA/IDAgOiB0aGlzLl9jb25uZWN0UmV0cmllc1Blckhvc3Q7XG4gIH1cbiAgc2V0IGNvbm5lY3RSZXRyaWVzUGVySG9zdChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2Nvbm5lY3RSZXRyaWVzUGVySG9zdCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNyZWNvbm5lY3RSZXRyeVdhaXRJbk1zZWNzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBIb3cgbXVjaCB0aW1lIHRvIHdhaXQgKGluIG1zKSBiZXR3ZWVuIGVhY2ggYXR0ZW1wdCB0byBjb25uZWN0IHRvXG4gICAqIGEgaG9zdC5cbiAgICogSWYgYSBjb25uZWN0IGF0dGVtcHQgaXMgbm90IHN1Y2Nlc3NmdWwsIHRoZSBBUEkgd2FpdHMgZm9yIHRoZSBhbW91bnQgb2YgdGltZVxuICAgKiBzcGVjaWZpZWQsIGFuZCB0aGVuIG1ha2VzIGFub3RoZXIgYXR0ZW1wdCB0byBjb25uZWN0LlxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2Nvbm5lY3RSZXRyaWVzUGVySG9zdH0gc2V0cyBob3cgbWFueSBjb25uZWN0aW9uXG4gICAqIGF0dGVtcHRzIHdpbGwgYmUgbWFkZSBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBuZXh0IGhvc3QgaW4gdGhlIGxpc3QuXG4gICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+PSAwIGFuZCA8PSA2MDAwMC5cbiAgICogQGRlZmF1bHQgMzAwMFxuICAgKi9cbiAgZ2V0IHJlY29ubmVjdFJldHJ5V2FpdEluTXNlY3MoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fcmVjb25uZWN0UmV0cnlXYWl0SW5Nc2VjcykgPyAzMDAwIDogdGhpcy5fcmVjb25uZWN0UmV0cnlXYWl0SW5Nc2VjcztcbiAgfVxuICBzZXQgcmVjb25uZWN0UmV0cnlXYWl0SW5Nc2VjcyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3JlY29ubmVjdFJldHJ5V2FpdEluTXNlY3MgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjcmVjb25uZWN0UmV0cmllc1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBjb25uZWN0aW5nIGFmdGVyIGEgY29ubmVjdGVkIHNlc3Npb24gZ29lcyBkb3duLlxuICAgKlxuICAgKiBXaGVuIHVzaW5nIGEgaG9zdCBsaXN0LCBlYWNoIHRyYXZlcnNhbCBvZiB0aGUgbGlzdCBpcyBjb25zaWRlcmVkIGEgdHJ5OyB0aGVyZWZvcmUsIGlmXG4gICAqIGByZWNvbm5lY3RSZXRyaWVzID09PSAyYCwgdGhlIGhvc3QgbGlzdCB3aWxsIGJlIHRyYXZlcnNlZCB1cCB0byB0aHJlZSB0aW1lczogb25jZVxuICAgKiBmb3IgdGhlIGluaXRpYWwgdHJ5LCBhbmQgdHdpY2UgbW9yZSBmb3IgdGhlIHJldHJpZXMuIEVhY2ggcmV0cnkgYmVnaW5zIHdpdGggdGhlIGZpcnN0IGhvc3RcbiAgICogbGlzdGVkLiBBZnRlciBlYWNoIHVuc3VjY2Vzc2Z1bCBhdHRlbXB0IHRvIGNvbm5lY3QgdG8gYSBob3N0LCB0aGUgQVBJIHdhaXRzIGZvciB0aGUgYW1vdW50XG4gICAqIG9mIHRpbWUgc2V0IGZvciB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3JlY29ubmVjdFJldHJ5V2FpdEluTXNlY3N9IGJlZm9yZSBhdHRlbXB0aW5nXG4gICAqIGFub3RoZXIgY29ubmVjdGlvbi4gVGhlIG5leHQgcmVjb25uZWN0IGF0dGVtcHQgbWF5IGJlIHRvIHRoZSBzYW1lIGhvc3QsXG4gICAqIHNlZSB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2Nvbm5lY3RSZXRyaWVzUGVySG9zdH0uXG4gICAqXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyByZWNvbm5lY3RSZXRyaWVzID49IC0xLlxuICAgKiAgKiAtMSBtZWFucyB0cnkgdG8gcmVjb25uZWN0IGZvcmV2ZXIuXG4gICAqICAqIDAgbWVhbnMgbm8gYXV0b21hdGljIHJlY29ubmVjdCByZXRyaWVzOyB0aGUgQVBJIHdpbGwgdHJ5IG9uY2UgYW5kIHRoZW4gZ2l2ZSB1cC5cbiAgICogICogcmVjb25uZWN0UmV0cmllcyA+PSAxIG1lYW5zIHJlYXR0ZW1wdCByZWNvbm5lY3QgbiB0aW1lcy5cbiAgICogQGRlZmF1bHQgMjBcbiAgICovXG4gIGdldCByZWNvbm5lY3RSZXRyaWVzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3JlY29ubmVjdFJldHJpZXMpID8gMjAgOiB0aGlzLl9yZWNvbm5lY3RSZXRyaWVzO1xuICB9XG4gIHNldCByZWNvbm5lY3RSZXRyaWVzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0UmV0cmllcyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLy8gID09PT09PT09PT09PT09PT09PT09PT09PSBtZXNzYWdlIHByb3BlcnRpZXMgPT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjZ2VuZXJhdGVTZW5kVGltZXN0YW1wc1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uIFdoZW4gZW5hYmxlZCwgYSBzZW5kIHRpbWVzdGFtcCBpcyBhdXRvbWF0aWNhbGx5IGluY2x1ZGVkXG4gICAqIChpZiBub3QgYWxyZWFkeSBwcmVzZW50KSBpbiB0aGUgU29sYWNlLWRlZmluZWQgZmllbGRzIGZvclxuICAgKiBlYWNoIG1lc3NhZ2Ugc2VudC5cbiAgICogQGRlZmF1bHQgIGZhbHNlXG4gICAqL1xuICBnZXQgZ2VuZXJhdGVTZW5kVGltZXN0YW1wcygpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl9nZW5TZW5kVGltZXN0YW1wcykgPyBmYWxzZSA6IHRoaXMuX2dlblNlbmRUaW1lc3RhbXBzO1xuICB9XG4gIHNldCBnZW5lcmF0ZVNlbmRUaW1lc3RhbXBzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fZ2VuU2VuZFRpbWVzdGFtcHMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjZ2VuZXJhdGVSZWNlaXZlVGltZXN0YW1wc1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uIFdoZW4gZW5hYmxlZCwgYSByZWNlaXZlIHRpbWVzdGFtcCBpcyByZWNvcmRlZCBmb3JcbiAgICogZWFjaCBtZXNzYWdlIGFuZCBwYXNzZWQgdG8gdGhlIHNlc3Npb24ncyBtZXNzYWdlIGNhbGxiYWNrIHJlY2VpdmUgaGFuZGxlci5cbiAgICogQGRlZmF1bHQgIGZhbHNlXG4gICAqL1xuICBnZXQgZ2VuZXJhdGVSZWNlaXZlVGltZXN0YW1wcygpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl9nZW5SZWNlaXZlVGltZXN0YW1wcykgPyBmYWxzZSA6IHRoaXMuX2dlblJlY2VpdmVUaW1lc3RhbXBzO1xuICB9XG4gIHNldCBnZW5lcmF0ZVJlY2VpdmVUaW1lc3RhbXBzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fZ2VuUmVjZWl2ZVRpbWVzdGFtcHMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjaW5jbHVkZVNlbmRlcklkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb24gV2hlbiBlbmFibGVkLCBhIHNlbmRlciBJRCBpcyBhdXRvbWF0aWNhbGx5IGluY2x1ZGVkXG4gICAqIChpZiBub3QgYWxyZWFkeSBwcmVzZW50KSBpbiB0aGUgU29sYWNlLWRlZmluZWQgZmllbGRzIGZvciBlYWNoIG1lc3NhZ2VcbiAgICogc2VudC5cbiAgICogQGRlZmF1bHQgIGZhbHNlXG4gICAqL1xuICBnZXQgaW5jbHVkZVNlbmRlcklkKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2luY2x1ZGVTZW5kZXJJZCkgPyBmYWxzZSA6IHRoaXMuX2luY2x1ZGVTZW5kZXJJZDtcbiAgfVxuICBzZXQgaW5jbHVkZVNlbmRlcklkKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5faW5jbHVkZVNlbmRlcklkID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2dlbmVyYXRlU2VxdWVuY2VOdW1iZXJcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvbiBXaGVuIGVuYWJsZWQsIGEgc2VxdWVuY2UgbnVtYmVyIGlzIGF1dG9tYXRpY2FsbHlcbiAgICogaW5jbHVkZWQgKGlmIG5vdCBhbHJlYWR5IHByZXNlbnQpIGluIHRoZSBTb2xhY2UtZGVmaW5lZCBmaWVsZHNcbiAgICogZm9yIGVhY2ggbWVzc2FnZSBzZW50LlxuICAgKiBAZGVmYXVsdCAgZmFsc2VcbiAgICovXG4gIGdldCBnZW5lcmF0ZVNlcXVlbmNlTnVtYmVyKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2dlblNlcXVlbmNlTnVtYmVyKSA/IGZhbHNlIDogdGhpcy5fZ2VuU2VxdWVuY2VOdW1iZXI7XG4gIH1cbiAgc2V0IGdlbmVyYXRlU2VxdWVuY2VOdW1iZXIobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9nZW5TZXF1ZW5jZU51bWJlciA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLy8gID09PT09PT09PT09PT09PT09PT09PT09PSBLZWVwIEFsaXZlID09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2tlZXBBbGl2ZUludGVydmFsSW5Nc2Vjc1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRvIHdhaXQgYmV0d2VlbiBzZW5kaW5nXG4gICAqIG91dCBrZWVwLWFsaXZlIG1lc3NhZ2VzIHRvIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+IDAuXG4gICAqIEBkZWZhdWx0ICAzMDAwXG4gICAqL1xuICBnZXQga2VlcEFsaXZlSW50ZXJ2YWxJbk1zZWNzKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2thSW50ZXJ2YWwpID8gMzAwMCA6IHRoaXMuX2thSW50ZXJ2YWw7XG4gIH1cbiAgc2V0IGtlZXBBbGl2ZUludGVydmFsSW5Nc2VjcyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2thSW50ZXJ2YWwgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMja2VlcEFsaXZlSW50ZXJ2YWxzTGltaXRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb25zZWN1dGl2ZSBLZWVwLUFsaXZlIG1lc3NhZ2VzIHRoYXRcbiAgICogY2FuIGJlIHNlbnQgd2l0aG91dCByZWNlaXZpbmcgYSByZXNwb25zZSBiZWZvcmUgdGhlIHNlc3Npb24gaXMgZGVjbGFyZWQgZG93blxuICAgKiBhbmQgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIGJ5IHRoZSBBUEkuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+PSAzLlxuICAgKiBAZGVmYXVsdCAzXG4gICAqL1xuICBnZXQga2VlcEFsaXZlSW50ZXJ2YWxzTGltaXQoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fa2FJbnRlcnZhbHNMaW1pdCkgPyAzIDogdGhpcy5fa2FJbnRlcnZhbHNMaW1pdDtcbiAgfVxuICBzZXQga2VlcEFsaXZlSW50ZXJ2YWxzTGltaXQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9rYUludGVydmFsc0xpbWl0ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT0gUDJQIEluYm94ID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjcDJwSW5ib3hJblVzZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gQSByZWFkLW9ubHkgc3RyaW5nIHRoYXQgaW5kaWNhdGVzIHRoZSBkZWZhdWx0XG4gICAqIHJlcGx5LXRvIGRlc3RpbmF0aW9uIHVzZWQgZm9yIGFueSByZXF1ZXN0IG1lc3NhZ2VzIHNlbnQgZnJvbSB0aGlzIHNlc3Npb24uXG4gICAqIFNlZSB7QGxpbmsgc29sYWNlLlNlc3Npb24jc2VuZFJlcXVlc3R9LlxuICAgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHZhbGlkIHdoZW4gdGhlIHNlc3Npb24gaXMgY29ubmVjdGVkLlxuICAgKiBAZGVmYXVsdCBcIlwiXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHAycEluYm94SW5Vc2UoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fcDJwSW5ib3hJblVzZSkgPyAnJyA6IHRoaXMuX3AycEluYm94SW5Vc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY3VycmVudCBQMlAgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgX3NldFAycEluYm94SW5Vc2UodmFsdWUpIHtcbiAgICB0aGlzLl9wMnBJbmJveEluVXNlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3AycEluYm94QmFzZVxuICAgKiBAZGVzY3JpcHRpb24gQSByZWFkLW9ubHkgaW5mb3JtYXRpb24gc3RyaW5nIHRoYXQgc3RvcmVzIHRoZSBQMlAgdG9waWMgc3Vic2NyaXB0aW9uXG4gICAqIG9idGFpbmVkIGZyb20gdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci5cbiAgICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB2YWxpZCB3aGVuIHRoZSBzZXNzaW9uIGlzIGNvbm5lY3RlZC5cbiAgICogQGRlZmF1bHQgIFwiXCJcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcDJwSW5ib3hCYXNlKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3AycEluYm94QmFzZSkgPyAnJyA6IHRoaXMuX3AycEluYm94QmFzZTtcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjdXJyZW50IFAyUCBpbmJveCByb290IHN1YnNjcmlwdGlvbi4gVGhlIHN1YnNjcmlwdGlvbiBvbiB0aGUgcm91dGVyXG4gICAqICAgYWRkaXRpb25hbGx5IGNvbnRhaW5zICcvPicsIHNvIGV4dHJhIHRvcGljIGxldmVscyBjYW4gYmUgYWRkZWQgdG8gdGhpcyByb290IGFuZCBtZXNzYWdlcyB0b1xuICAgKiAgIHRob3NlIHRvcGljcyB3aWxsIGJlIGF0dHJhY3RlZCB3aXRoIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBfc2V0UDJwSW5ib3hCYXNlKHZhbHVlKSB7XG4gICAgdGhpcy5fcDJwSW5ib3hCYXNlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3VzZXJJZGVudGlmaWNhdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb24gQSByZWFkLW9ubHkgc3RyaW5nIHByb3ZpZGluZyBpbmZvcm1hdGlvblxuICAgKiBhYm91dCB0aGUgYXBwbGljYXRpb24sIHN1Y2ggYXMgdGhlIG5hbWUgb2Ygb3BlcmF0aW5nIHN5c3RlbVxuICAgKiB0aGF0IGlzIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uLlxuICAgKiBAZGVmYXVsdCAgXCJcIlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1c2VySWRlbnRpZmljYXRpb24oKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fdXNlcklkZW50aWZpY2F0aW9uKSA/ICcnIDogdGhpcy5fdXNlcklkZW50aWZpY2F0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGN1cnJlbnQgdXNlcklkXG4gICAqL1xuICBfc2V0VXNlcklkZW50aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fdXNlcklkZW50aWZpY2F0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT0gU3Vic2NyaXB0aW9ucyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzdWJzY3JpYmVyTG9jYWxQcmlvcml0eVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gU3Vic2NyaWJlciBwcmlvcml0aWVzIGFyZSB1c2VkIGJ5IHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgdG8gZGlzdHJpYnV0ZSBtZXNzYWdlc1xuICAgKiB0aGF0IGhhdmUgdGhlIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXREZWxpdmVyVG9PbmV9IGZsYWcgc2V0IHRvIHRydWUuIFRoZXNlIG1lc3NhZ2VzIGFyZSBzZW50XG4gICAqIHRvIHRoZSBzdWJzY3JpYmVyIHdpdGggdGhlIGhpZ2hlc3QgcHJpb3JpdHkuIFN1YnNjcmliZXJzIGhhdmUgdHdvIHByaW9yaXRpZXM7IHRoaXNcbiAgICogcHJpb3JpdHkgaXMgZm9yIG1lc3NhZ2VzIHB1Ymxpc2hlZCBsb2NhbGx5LlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgMS4uNFxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlckxvY2FsUHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fc3ViTG9jYWxQcmlvcml0eSkgPyAxIDogdGhpcy5fc3ViTG9jYWxQcmlvcml0eTtcbiAgfVxuICBzZXQgc3Vic2NyaWJlckxvY2FsUHJpb3JpdHkobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9zdWJMb2NhbFByaW9yaXR5ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3N1YnNjcmliZXJOZXR3b3JrUHJpb3JpdHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFN1YnNjcmliZXIgcHJpb3JpdGllcyBhcmUgdXNlZCBieSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIHRvIGRpc3RyaWJ1dGUgbWVzc2FnZXNcbiAgICogdGhhdCBoYXZlIHRoZSB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0RGVsaXZlclRvT25lfSBmbGFnIHNldCB0byB0cnVlLiBUaGVzZSBtZXNzYWdlcyBhcmUgc2VudFxuICAgKiB0byB0aGUgc3Vic2NyaWJlciB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuICAgKlxuICAgKiBTdWJzY3JpYmVycyBoYXZlIHR3byBwcmlvcml0aWVzOyB0aGlzIHByaW9yaXR5IGlzIGZvciBtZXNzYWdlcyBwdWJsaXNoZWQgb24gU29sYWNlIE1lc3NhZ2VcbiAgICogUm91dGVycyBvdGhlciB0aGFuIHRoZSBvbmUgdGhhdCB0aGUgY2xpZW50IGlzIGNvbm5lY3RlZCB0by5cbiAgICogICogVGhlIHZhbGlkIHJhbmdlIGlzIDEuLjRcbiAgICogQGRlZmF1bHQgIDFcbiAgICovXG4gIGdldCBzdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5KCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3N1Yk5ldHdvcmtQcmlvcml0eSkgPyAxIDogdGhpcy5fc3ViTmV0d29ya1ByaW9yaXR5O1xuICB9XG4gIHNldCBzdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc3ViTmV0d29ya1ByaW9yaXR5ID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2lnbm9yZUR1cGxpY2F0ZVN1YnNjcmlwdGlvbkVycm9yXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb24gVXNlZCB0byBpZ25vcmUgZHVwbGljYXRlIHN1YnNjcmlwdGlvbiBlcnJvcnMgb24gc3Vic2NyaWJlLlxuICAgKiBAZGVmYXVsdCAgdHJ1ZVxuICAgKi9cbiAgZ2V0IGlnbm9yZUR1cGxpY2F0ZVN1YnNjcmlwdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX2lnbm9yZUR1cFN1YkVycm9yKSA/IHRydWUgOiB0aGlzLl9pZ25vcmVEdXBTdWJFcnJvcjtcbiAgfVxuICBzZXQgaWdub3JlRHVwbGljYXRlU3Vic2NyaXB0aW9uRXJyb3IobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9pZ25vcmVEdXBTdWJFcnJvciA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNpZ25vcmVTdWJzY3JpcHRpb25Ob3RGb3VuZEVycm9yXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb24gVXNlZCB0byBpZ25vcmUgc3Vic2NyaXB0aW9uIG5vdCBmb3VuZCBlcnJvcnMgb24gdW5zdWJzY3JpYmUuXG4gICAqIEBkZWZhdWx0ICB0cnVlXG4gICAqL1xuICBnZXQgaWdub3JlU3Vic2NyaXB0aW9uTm90Rm91bmRFcnJvcigpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl9pZ25vcmVTdWJOb3RGb3VuZEVycm9yKSA/IHRydWUgOiB0aGlzLl9pZ25vcmVTdWJOb3RGb3VuZEVycm9yO1xuICB9XG4gIHNldCBpZ25vcmVTdWJzY3JpcHRpb25Ob3RGb3VuZEVycm9yKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5faWdub3JlU3ViTm90Rm91bmRFcnJvciA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNyZWFwcGx5U3Vic2NyaXB0aW9uc1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uIFNldCB0byAndHJ1ZScgdG8gaGF2ZSB0aGUgQVBJIHJlbWVtYmVyIHN1YnNjcmlwdGlvbnMgYW5kIHJlYXBwbHkgdGhlbSB1cG9uXG4gICAqIGNhbGxpbmcge0BsaW5rIHNvbGFjZS5TZXNzaW9uI2Nvbm5lY3R9IG9uIGEgZGlzY29ubmVjdGVkIHNlc3Npb24uXG4gICAqIEBkZWZhdWx0ICBmYWxzZVxuICAgKi9cbiAgZ2V0IHJlYXBwbHlTdWJzY3JpcHRpb25zKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3JlYXBwbHlTdWJjcmlwdGlvbnMpID8gZmFsc2UgOiB0aGlzLl9yZWFwcGx5U3ViY3JpcHRpb25zO1xuICB9XG4gIHNldCByZWFwcGx5U3Vic2NyaXB0aW9ucyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3JlYXBwbHlTdWJjcmlwdGlvbnMgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PSBBRCBjb25maWd1cmF0aW9uID09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogU2V0cyB0aGUgZ3VhcmFudGVlZCBtZXNzYWdpbmcgcHVibGlzaGVyIHByb3BlcnRpZXMgZm9yIHRoZSBzZXNzaW9uLlxuICAgKiBJZiB0aGUgc3VwcGxpZWQgdmFsdWUgaXMgbm90IGEge0BsaW5rIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllc30sXG4gICAqIG9uZSB3aWxsIGJlIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBzdXBwbGllZCB2YWx1ZSBhcyBhbiBhcmd1bWVudC5cbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3B1Ymxpc2hlclByb3BlcnRpZXNcbiAgICogQHR5cGUge3NvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllc31cbiAgICovXG4gIGdldCBwdWJsaXNoZXJQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXJQcm9wZXJ0aWVzO1xuICB9XG4gIHNldCBwdWJsaXNoZXJQcm9wZXJ0aWVzKHZhbCkge1xuICAgIGNvbnN0IHsgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgfSA9IFB1Ymxpc2hlckxpYjtcbiAgICB0aGlzLl9wdWJsaXNoZXJQcm9wZXJ0aWVzID0gdmFsIGluc3RhbmNlb2YgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXNcbiAgICAgID8gdmFsXG4gICAgICA6IG5ldyBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyh2YWwpO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09IFRyYW5zcG9ydCBjb25maWd1cmF0aW9uID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjbm9Mb2NhbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uIFNldCB0byAndHJ1ZScgdG8gc2lnbmFsIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgdGhhdCBtZXNzYWdlcyBwdWJsaXNoZWQgb24gdGhlXG4gICAqIHNlc3Npb24gc2hvdWxkIG5vdCBiZSByZWNlaXZlZCBvbiB0aGUgc2FtZSBzZXNzaW9uIGV2ZW4gaWYgdGhlIGNsaWVudCBoYXMgYSBzdWJzY3JpcHRpb24gdGhhdFxuICAgKiBtYXRjaGVzIHRoZSBwdWJsaXNoZWQgdG9waWMuIElmIHRoaXMgcmVzdHJpY3Rpb24gaXMgcmVxdWVzdGVkLCBhbmQgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlclxuICAgKiBkb2VzIG5vdCBoYXZlIE5vIExvY2FsIHN1cHBvcnQsIHRoZSBzZXNzaW9uIGNvbm5lY3Qgd2lsbCBmYWlsLlxuICAgKiBAZGVmYXVsdCAgZmFsc2VcbiAgICovXG4gIGdldCBub0xvY2FsKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX25vTG9jYWwpID8gZmFsc2UgOiB0aGlzLl9ub0xvY2FsO1xuICB9XG4gIHNldCBub0xvY2FsKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fbm9Mb2NhbCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNyZWFkVGltZW91dEluTXNlY3NcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFRoZSB0aW1lb3V0IHBlcmlvZCAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgYSByZXBseSB0b1xuICAgKiBjb21lIGJhY2sgZnJvbSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyLiBUaGlzIHRpbWVvdXQgc2VydmVzIGFzIHRoZSBkZWZhdWx0XG4gICAqIHJlcXVlc3QgdGltZW91dCBmb3Ige0BsaW5rIHNvbGFjZS5TZXNzaW9uI3N1YnNjcmliZX0sXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbiN1bnN1YnNjcmliZX0sIHtAbGluayBzb2xhY2UuU2Vzc2lvbiN1cGRhdGVQcm9wZXJ0eX0uXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+PSAwLlxuICAgKiBAZGVmYXVsdCAxMDAwMFxuICAgKi9cbiAgZ2V0IHJlYWRUaW1lb3V0SW5Nc2VjcygpIHtcbiAgICByZXR1cm4gQ2hlY2subm90aGluZyh0aGlzLl9yZWFkVGltZW91dCkgPyAxMDAwMCA6IHRoaXMuX3JlYWRUaW1lb3V0O1xuICB9XG4gIHNldCByZWFkVGltZW91dEluTXNlY3MobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9yZWFkVGltZW91dCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNzZW5kQnVmZmVyTWF4U2l6ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIG1heGltdW0gYnVmZmVyIHNpemUgZm9yIHRoZSB0cmFuc3BvcnQgc2Vzc2lvbi4gVGhpcyBzaXplIG11c3QgYmUgYmlnZ2VyXG4gICAqIHRoYW4gdGhlIGxhcmdlc3QgbWVzc2FnZSBhbiBhcHBsaWNhdGlvbiBpbnRlbmRzIHRvIHNlbmQgb24gdGhlIHNlc3Npb24uXG4gICAqXG4gICAqIFRoZSBzZXNzaW9uIGJ1ZmZlciBzaXplIGNvbmZpZ3VyZWQgdXNpbmcgdGhlIHNlbmRCdWZmZXJNYXhTaXplXG4gICAqIHNlc3Npb24gcHJvcGVydHkgY29udHJvbHMgU29sQ2xpZW50IGJ1ZmZlcmluZyBvZiB0cmFuc21pdCBtZXNzYWdlcy4gV2hlblxuICAgKiBzZW5kaW5nIHNtYWxsIG1lc3NhZ2VzLCB0aGUgc2Vzc2lvbiBidWZmZXIgc2l6ZSBzaG91bGQgYmUgc2V0IHRvIG11bHRpcGxlIHRpbWVzXG4gICAqIHRoZSB0eXBpY2FsIG1lc3NhZ2Ugc2l6ZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZS4gUmVnYXJkbGVzcyBvZiB0aGUgYnVmZmVyXG4gICAqIHNpemUsIFNvbENsaWVudCBhbHdheXMgYWNjZXB0cyBhdCBsZWFzdCBvbmUgbWVzc2FnZSB0byB0cmFuc21pdC4gU28gZXZlbiBpZiBhXG4gICAqIHNpbmdsZSBtZXNzYWdlIGV4Y2VlZHMgc2VuZEJ1ZmZlck1heFNpemUsIGl0IGlzIGFjY2VwdGVkIGFuZFxuICAgKiB0cmFuc21pdHRlZCBhcyBsb25nIGFzIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIGRhdGEgaXMgemVyby4gSG93ZXZlciwgbm8gbW9yZVxuICAgKiBtZXNzYWdlcyBhcmUgYWNjZXB0ZWQgdW50aWwgdGhlIGFtb3VudCBvZiBkYXRhIGJ1ZmZlcmVkIGlzIHJlZHVjZWRcbiAgICogZW5vdWdoIHRvIGFsbG93IHJvb20gYmVsb3cgc2VuZEJ1ZmZlck1heFNpemUuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+IDAuXG4gICAqXG4gICAqIEBkZWZhdWx0IDY1NTM2ICg2NEtCKVxuICAgKi9cbiAgZ2V0IHNlbmRCdWZmZXJNYXhTaXplKCkge1xuICAgIHJldHVybiBDaGVjay5ub3RoaW5nKHRoaXMuX3NlbmRCdWZmZXJNYXhTaXplKSA/ICg2NCAqIDEwMjQpIDogdGhpcy5fc2VuZEJ1ZmZlck1heFNpemU7XG4gIH1cbiAgc2V0IHNlbmRCdWZmZXJNYXhTaXplKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fc2VuZEJ1ZmZlck1heFNpemUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjbWF4V2ViUGF5bG9hZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIG1heGltdW0gcGF5bG9hZCBzaXplIChpbiBieXRlcykgd2hlbiBzZW5kaW5nIGRhdGEgdXNpbmcgdGhlIFdlYiB0cmFuc3BvcnRcbiAgICogcHJvdG9jb2wuICBMYXJnZSBtZXNzYWdlcyBtYXkgZmFpbCB0byBiZSBzZW50IHRvIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgd2hlbiB0aGUgbWF4aW11bSB3ZWJcbiAgICogcGF5bG9hZCBpcyBzZXQgdG8gYSBzbWFsbCB2YWx1ZS4gVG8gYXZvaWQgdGhpcywgdXNlIGEgbGFyZ2UgbWF4aW11bSB3ZWIgcGF5bG9hZC5cbiAgICogICogVGhlIHZhbGlkIHJhbmdlIGlzID49IDEwMC5cbiAgICogQGRlZmF1bHQgMTA0ODU3NiAoMU1CKVxuICAgKi9cbiAgZ2V0IG1heFdlYlBheWxvYWQoKSB7XG4gICAgcmV0dXJuIENoZWNrLm5vdGhpbmcodGhpcy5fbWF4V2ViUGF5bG9hZCkgPyAoMTAyNCAqIDEwMjQpIDogdGhpcy5fbWF4V2ViUGF5bG9hZDtcbiAgfVxuICBzZXQgbWF4V2ViUGF5bG9hZChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX21heFdlYlBheWxvYWQgPSBuZXdWYWx1ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgbm9uSFRUUFRyYW5zcG9ydFByb3BzU2V0KCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIG9uIGRlbWFuZCBiYXNlZCBvbiBwcmVzZW5jZSBvZiBwcm9wZXJ0aWVzLlxuICAgICAgLy8gQ3VycmVudGx5IG5vdCB0cmFja2luZyB0aGlzIHNvIG5vIHByb3BlcnR5IG5hbWVzIGxpc3RlZC5cbiAgICByZXR1cm4gW10uZmlsdGVyKGsgPT4gQ2hlY2suc29tZXRoaW5nKHRoaXNba10pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIGJyaWVmIGRlc2NyaXB0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcy5fbGVuZHNJbnNwZWN0KCksIHtcbiAgICAgICdhdXRoZW50aWNhdGlvblNjaGVtZSc6ICAgICAgICAgICAgIEF1dGhlbnRpY2F0aW9uU2NoZW1lLmRlc2NyaWJlKHRoaXMuYXV0aGVudGljYXRpb25TY2hlbWUpLFxuICAgICAgJ3VybCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwsXG4gICAgICAncGFzc3dvcmQnOiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID8gJyoqKioqJyA6IHRoaXMucGFzc3dvcmQsXG4gICAgICAndXNlck5hbWUnOiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJOYW1lLFxuICAgICAgJ2NsaWVudE5hbWUnOiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnROYW1lLFxuICAgICAgJ2FwcGxpY2F0aW9uRGVzY3JpcHRpb24nOiAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgJ3Zwbk5hbWUnOiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52cG5OYW1lLFxuICAgICAgJ3Zwbk5hbWVJblVzZSc6ICAgICAgICAgICAgICAgICAgICAgdGhpcy52cG5OYW1lSW5Vc2UsXG4gICAgICAndmlydHVhbFJvdXRlck5hbWUnOiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxSb3V0ZXJOYW1lLFxuICAgICAgJ2Nvbm5lY3RUaW1lb3V0SW5Nc2Vjcyc6ICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dEluTXNlY3MsXG4gICAgICAnY29ubmVjdFJldHJpZXMnOiAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RSZXRyaWVzLFxuICAgICAgJ2Nvbm5lY3RSZXRyaWVzUGVySG9zdCc6ICAgICAgICAgICAgdGhpcy5jb25uZWN0UmV0cmllc1Blckhvc3QsXG4gICAgICAncmVjb25uZWN0UmV0cnlXYWl0SW5Nc2Vjcyc6ICAgICAgICB0aGlzLnJlY29ubmVjdFJldHJ5V2FpdEluTXNlY3MsXG4gICAgICAncmVjb25uZWN0UmV0cmllcyc6ICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdFJldHJpZXMsXG4gICAgICAnZ2VuZXJhdGVTZW5kVGltZXN0YW1wcyc6ICAgICAgICAgICB0aGlzLmdlbmVyYXRlU2VuZFRpbWVzdGFtcHMsXG4gICAgICAnZ2VuZXJhdGVSZWNlaXZlVGltZXN0YW1wcyc6ICAgICAgICB0aGlzLmdlbmVyYXRlUmVjZWl2ZVRpbWVzdGFtcHMsXG4gICAgICAnaW5jbHVkZVNlbmRlcklkJzogICAgICAgICAgICAgICAgICB0aGlzLmluY2x1ZGVTZW5kZXJJZCxcbiAgICAgICdnZW5lcmF0ZVNlcXVlbmNlTnVtYmVyJzogICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTZXF1ZW5jZU51bWJlcixcbiAgICAgICdrZWVwQWxpdmVJbnRlcnZhbEluTXNlY3MnOiAgICAgICAgIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWxJbk1zZWNzLFxuICAgICAgJ2tlZXBBbGl2ZUludGVydmFsc0xpbWl0JzogICAgICAgICAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbHNMaW1pdCxcbiAgICAgICdwMnBJbmJveEluVXNlJzogICAgICAgICAgICAgICAgICAgIHRoaXMucDJwSW5ib3hJblVzZSxcbiAgICAgICdwMnBJbmJveEJhc2UnOiAgICAgICAgICAgICAgICAgICAgIHRoaXMucDJwSW5ib3hCYXNlLFxuICAgICAgJ3VzZXJJZGVudGlmaWNhdGlvbic6ICAgICAgICAgICAgICAgdGhpcy51c2VySWRlbnRpZmljYXRpb24sXG4gICAgICAnc3Vic2NyaWJlckxvY2FsUHJpb3JpdHknOiAgICAgICAgICB0aGlzLnN1YnNjcmliZXJMb2NhbFByaW9yaXR5LFxuICAgICAgJ3N1YnNjcmliZXJOZXR3b3JrUHJpb3JpdHknOiAgICAgICAgdGhpcy5zdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5LFxuICAgICAgJ2lnbm9yZUR1cGxpY2F0ZVN1YnNjcmlwdGlvbkVycm9yJzogdGhpcy5pZ25vcmVEdXBsaWNhdGVTdWJzY3JpcHRpb25FcnJvcixcbiAgICAgICdyZWFwcGx5U3Vic2NyaXB0aW9ucyc6ICAgICAgICAgICAgIHRoaXMucmVhcHBseVN1YnNjcmlwdGlvbnMsXG4gICAgICAncHVibGlzaGVyUHJvcGVydGllcyc6ICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlclByb3BlcnRpZXMsXG4gICAgICAnbm9Mb2NhbCc6ICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vTG9jYWwsXG4gICAgICAncmVhZFRpbWVvdXRJbk1zZWNzJzogICAgICAgICAgICAgICB0aGlzLnJlYWRUaW1lb3V0SW5Nc2VjcyxcbiAgICAgICdzZW5kQnVmZmVyTWF4U2l6ZSc6ICAgICAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlck1heFNpemUsXG4gICAgICAnbWF4V2ViUGF5bG9hZCc6ICAgICAgICAgICAgICAgICAgICB0aGlzLm1heFdlYlBheWxvYWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI3RvU3RyaW5nXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBTZXNzaW9uLCBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gQSBicmllZiBkZXNjcmlwdGlvbiBvZiB0aGlzIG9iamVjdFxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKCk7IC8vIG9ubHkgaGVyZSBmb3IgdGhlIGRvY3NcbiAgfVxuXG59XG5cbi8vIERvbid0IHRyeSB0byBldmFsdWF0ZSB0aGVzZSBjb25zdGFudHMgaW4gYnJvd3NlciBtb2RlXG5pZiAoQlVJTERfRU5WLlRBUkdFVF9OT0RFKSB7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGRlZmF1bHQgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY2lwaGVyIHN1aXRlcyBpblxuICAgKiBvcmRlciBvZiBwcmVmZXJlbmNlIHVzZWQgZm9yIFNTTCBjb25uZWN0aW9ucy5cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBTZXNzaW9uUHJvcGVydGllcy5ERUZBVUxUX0NJUEhFUl9TVUlURVMgPSBERUZBVUxUX0NJUEhFUl9TVUlURVM7XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBjaXBoZXIgc3VpdGVzIHN1cHBvcnRlZCBieSB0aGUgQVBJIHdoZW4gdXNpbmcgU1NMIGNvbm5lY3Rpb25zXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTZXNzaW9uUHJvcGVydGllcy5TVVBQT1JURURfQ0lQSEVSX1NVSVRFUyA9IFNVUFBPUlRFRF9DSVBIRVJfU1VJVEVTO1xuXG4gIC8qKlxuICAgKiBTU0wgcHJvdG9jb2xzIHN1cHBvcnRlZCBieSB0aGUgQVBJIHdoZW4gdXNpbmcgU1NMIGNvbm5lY3Rpb25zXG4gICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNlc3Npb25Qcm9wZXJ0aWVzLlNVUFBPUlRFRF9TU0xfUFJPVE9DT0xTID0gU1VQUE9SVEVEX1NTTF9QUk9UT0NPTFM7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgKi8gLy8gZG9uJ3QgbWFuZ2xlIGltcG9ydFxuICBTZXNzaW9uUHJvcGVydGllcy5Tc2xQcm90b2NvbEV4Y2x1ZGVDb25zdGFudE1hcCA9IHtcbiAgICBbJ3NzbHYyJ106ICAgTm9kZVNzbENvbnN0YW50c1snU1NMX09QX05PX1NTTHYyJ10gfHwgMCxcbiAgICBbJ3NzbHYzJ106ICAgTm9kZVNzbENvbnN0YW50c1snU1NMX09QX05PX1NTTHYzJ10gfHwgMCxcbiAgICBbJ3Rsc3YxJ106ICAgTm9kZVNzbENvbnN0YW50c1snU1NMX09QX05PX1RMU3YxJ10gfHwgMCxcbiAgICBbJ3Rsc3YxLjEnXTogTm9kZVNzbENvbnN0YW50c1snU1NMX09QX05PX1RMU3YxXzEnXSB8fCAwLFxuICAgIFsndGxzdjEuMiddOiBOb2RlU3NsQ29uc3RhbnRzWydTU0xfT1BfTk9fVExTdjFfMiddIHx8IDAsXG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi8gLy8gZG9uJ3QgbWFuZ2xlIGltcG9ydFxufVxuXG5cbm1vZHVsZS5leHBvcnRzLlNlc3Npb25Qcm9wZXJ0aWVzID0gU2Vzc2lvblByb3BlcnRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXByb3BlcnRpZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTZXNzaW9uUmVxdWVzdFR5cGUgPSB7XG4gIEFERF9TVUJTQ1JJUFRJT046ICAgICAgICAwLFxuICBSRU1PVkVfU1VCU0NSSVBUSU9OOiAgICAgMSxcbiAgQUREX1AyUElOQk9YOiAgICAgICAgICAgIDIsXG4gIFJFTU9WRV9QMlBJTkJPWDogICAgICAgICAzLFxuICBSRU1PVkVfRFRFX1NVQlNDUklQVElPTjogMTAwLFxufTtcblxubW9kdWxlLmV4cG9ydHMuU2Vzc2lvblJlcXVlc3RUeXBlID0gRW51bS5uZXcoU2Vzc2lvblJlcXVlc3RUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tcmVxdWVzdC10eXBlcy5qcyIsImNvbnN0IE1lc3NhZ2VMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZScpO1xuY29uc3QgeyBCaWRpTWFwLCBMYXp5IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgQml0cywgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgQ29udGVudFN1bW1hcnlFbGVtZW50IH0gPSByZXF1aXJlKCcuL2NvbnRlbnQtc3VtbWFyeS1lbGVtZW50Jyk7XG5jb25zdCB7IENvbnRlbnRTdW1tYXJ5VHlwZSB9ID0gcmVxdWlyZSgnLi9jb250ZW50LXN1bW1hcnktdHlwZXMnKTtcbmNvbnN0IHsgTE9HX0VSUk9SIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IFNNRlVIIH0gPSByZXF1aXJlKCcuLi9tZXNzYWdlLW9iamVjdHMnKTtcblxuY29uc3QgeyBsYXp5VmFsdWUgfSA9IExhenk7XG5jb25zdCB7XG4gIGludDhUb1N0cixcbiAgaW50MTZUb1N0cixcbiAgaW50MjRUb1N0cixcbiAgaW50MzJUb1N0cixcbiAgc3RyVG9JbnQ4LFxuICBzdHJUb0ludDE2LFxuICBzdHJUb0ludDI0LFxuICBzdHJUb0ludDMyLFxufSA9IENvbnZlcnQ7XG5cbmNvbnN0IGRlbE1vZGVFbnVtQmlkaU1hcCA9IGxhenlWYWx1ZShcbiAgKCkgPT4ge1xuICAgIC8vIFNpbmdsZSBiaWRpcmVjdGlvbmFsIG1hcCBmb3IgbG9va3Vwcy4gTm90ZSB0aGF0IHRoZSBmb3J3YXJkXG4gICAgLy8ga2V5cyBhcmUgY29udmVydGVkIHRvIHN0cmluZ3MuXG4gICAgY29uc3Qgc291cmNlID0gW1xuICAgICAgWzB4MDAsIE1lc3NhZ2VMaWIuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuTk9OX1BFUlNJU1RFTlRdLFxuICAgICAgWzB4MDEsIE1lc3NhZ2VMaWIuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuUEVSU0lTVEVOVF0sXG4gICAgICBbMHgwMiwgTWVzc2FnZUxpYi5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5ESVJFQ1RdLFxuICAgIF0ubWFwKGVsID0+IFtlbFswXSwgZWxbMV1dKTtcbiAgICByZXR1cm4gbmV3IEJpZGlNYXAoLi4uc291cmNlKTtcbiAgfSk7XG5jb25zdCBsdXREZWxNb2RlVG9FbnVtID0gbGF6eVZhbHVlKCgpID0+IGRlbE1vZGVFbnVtQmlkaU1hcC52YWx1ZS5mb3J3YXJkKTtcbmNvbnN0IGx1dEVudW1Ub0RlbE1vZGUgPSBsYXp5VmFsdWUoKCkgPT4gZGVsTW9kZUVudW1CaWRpTWFwLnZhbHVlLnJldmVyc2UpO1xuXG4vKipcbiAqIFNNRiBUTFYgUGFyYW0gTFVUXG4gKiB1dFR5cGVNYXBbdWhdW3BhcmFtdHlwZV0gaXMgdGhlIGJpbmFyeSBwcmVmaXggZm9yIGEgcmVndWxhciAobm90IExXKSBUTFZcbiAqIHBhcmFtZXRlciB3aXRoIHVoIGFuZCBwYXJhbXR5cGUgdmFsdWVzIGFzIGFjY2Vzc2VkIGluIHRoZSBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB1aFR5cGVNYXAgPSAoKCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgcGFyYW1UeXBlQml0cyA9IDU7XG4gIGNvbnN0IHBhcmFtVHlwZUNvdW50ID0gTWF0aC5wb3coMiwgcGFyYW1UeXBlQml0cyk7XG4gIFNNRlVILnZhbHVlcy5mb3JFYWNoKCh1aCkgPT4ge1xuICAgIHJlc3VsdFt1aF0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtVHlwZUNvdW50OyArK2kpIHtcbiAgICAgIGxldCBieXRlMSA9IDA7XG4gICAgICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCB1aCwgNiwgMik7XG4gICAgICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCBpLCAwLCBwYXJhbVR5cGVCaXRzKTtcbiAgICAgIHJlc3VsdFt1aF1baV0gPSBpbnQ4VG9TdHIoYnl0ZTEpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KSgpO1xuXG4vKipcbiAqIFNNRiBUTFYgbGVuZ3RoIG1hcCBMVVRcbiAqXG4gKiBsZW5NYXBbeF0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoeClcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsZW5NYXAgPSAobmV3IEFycmF5KDI1NikuZmlsbChudWxsKS5tYXAoKF8sIGlkeCkgPT4gaW50OFRvU3RyKGlkeCkpKTtcblxuLyoqXG4gKiBTTUYgTGlnaHR3ZWlnaHQgUGFyYW0gTFVUXG4gKlxuICogbGlnaHRNYXBbdWhdW3BhcmFtdHlwZV1bbGVuXSBpcyB0aGUgcHJlZml4IGZvciBhbiBTTUYgTFdQXG4gKiB3aXRoIHVoLCBwYXJhbXR5cGUgYW5kIGxlbiB2YWx1ZXMgYXMgYWNjZXNzZWQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpZ2h0TWFwID0gKCgpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHBhcmFtVHlwZUJpdHMgPSAzO1xuICBjb25zdCBwYXJhbVR5cGVDb3VudCA9IE1hdGgucG93KDIsIHBhcmFtVHlwZUJpdHMpO1xuICBjb25zdCBsZW5CaXRzID0gMjtcbiAgY29uc3QgbGVuQ291bnQgPSBNYXRoLnBvdygyLCBsZW5CaXRzKTtcbiAgU01GVUgudmFsdWVzLmZvckVhY2goKHVoKSA9PiB7XG4gICAgcmVzdWx0W3VoXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1UeXBlQ291bnQ7ICsraSkge1xuICAgICAgcmVzdWx0W3VoXVtpXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5Db3VudDsgKytqKSB7XG4gICAgICAgIGxldCBieXRlMSA9IDA7XG4gICAgICAgIGJ5dGUxID0gQml0cy5zZXQoYnl0ZTEsIHVoLCA2LCAyKTtcbiAgICAgICAgYnl0ZTEgPSBCaXRzLnNldChieXRlMSwgMSwgNSwgMSk7XG4gICAgICAgIGJ5dGUxID0gQml0cy5zZXQoYnl0ZTEsIGksIDIsIDMpO1xuICAgICAgICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCBqLCAwLCAyKTtcbiAgICAgICAgcmVzdWx0W3VoXVtpXVtqXSA9IGludDhUb1N0cihieXRlMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5cbmNvbnN0IENvbnRlbnRTdW1tYXJ5RGVjb2RlTWFwID0gW1xuICBDb250ZW50U3VtbWFyeVR5cGUuWE1MX01FVEEsXG4gIENvbnRlbnRTdW1tYXJ5VHlwZS5YTUxfUEFZTE9BRCxcbiAgQ29udGVudFN1bW1hcnlUeXBlLkJJTkFSWV9BVFRBQ0hNRU5ULFxuICBDb250ZW50U3VtbWFyeVR5cGUuQ0lEX0xJU1QsXG4gIENvbnRlbnRTdW1tYXJ5VHlwZS5CSU5BUllfTUVUQURBVEEsXG5dO1xuXG5jb25zdCBQYXJhbVBhcnNlID0ge1xuXG4gIHBhcnNlVG9waWNRdWV1ZU9mZnNldHMoZGF0YSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0WzBdID0gc3RyVG9JbnQ4KGRhdGEuc3Vic3RyKG9mZnNldCwgMSkpO1xuICAgIHJlc3VsdFsxXSA9IHN0clRvSW50OChkYXRhLnN1YnN0cihvZmZzZXQgKyAxLCAxKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBwYXJzZVJlc3BvbnNlUGFyYW0oZGF0YSwgb2Zmc2V0LCBwYXJhbUxlbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdFswXSA9IHN0clRvSW50MzIoZGF0YS5zdWJzdHIob2Zmc2V0LCA0KSk7XG4gICAgY29uc3QgcmVzcFN0ckxlbiA9IHBhcmFtTGVuIC0gNDtcbiAgICBpZiAocmVzcFN0ckxlbiA+IDApIHtcbiAgICAgIHJlc3VsdFsxXSA9IGRhdGEuc3Vic3RyKG9mZnNldCArIDQsIHJlc3BTdHJMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRbMV0gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBwYXJzZURlbGl2ZXJ5TW9kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBjb25zdCBkZWxtb2RlID0gc3RyVG9JbnQ4KGRhdGEuc3Vic3RyKG9mZnNldCwgMSkpO1xuICAgIGNvbnN0IGxvb2t1cCA9IGx1dERlbE1vZGVUb0VudW0udmFsdWUuZ2V0KGRlbG1vZGUpO1xuICAgIHJldHVybiBsb29rdXAgIT09IHVuZGVmaW5lZCA/IGxvb2t1cCA6IE1lc3NhZ2VMaWIuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUO1xuICB9LFxuXG4gIGVuY0RlbGl2ZXJ5TW9kZShkZWxtb2RlKSB7XG4gICAgY29uc3QgbHV0ID0gbHV0RW51bVRvRGVsTW9kZS52YWx1ZTtcbiAgICBjb25zdCBsb29rdXAgPSBsdXQuZ2V0KGRlbG1vZGUpO1xuICAgIHJldHVybiBpbnQ4VG9TdHIobG9va3VwICE9PSB1bmRlZmluZWQgPyBsb29rdXAgOiBNZXNzYWdlTGliLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLkRJUkVDVCk7XG4gIH0sXG5cbiAgcGFyc2VDb250ZW50U3VtbWFyeShkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IGN1bXVsYXRpdmVTaXplID0gMDtcbiAgICBsZXQgcG9zID0gb2Zmc2V0O1xuXG4gICAgd2hpbGUgKHBvcyA8IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgY29uc3QgYnl0ZTEgPSBzdHJUb0ludDgoZGF0YS5jaGFyQXQocG9zKSk7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZSA9IEJpdHMuZ2V0KGJ5dGUxLCA0LCA0KTtcbiAgICAgIGNvbnN0IGVsZW1lbnREZWNsYXJlZExlbmd0aCA9IEJpdHMuZ2V0KGJ5dGUxLCAwLCA0KTtcbiAgICAgIGxldCBlbGVtZW50U2l6ZSA9IDA7XG4gICAgICBzd2l0Y2ggKGVsZW1lbnREZWNsYXJlZExlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZWxlbWVudFNpemUgPSBzdHJUb0ludDgoZGF0YS5zdWJzdHIocG9zICsgMSwgMSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZWxlbWVudFNpemUgPSBzdHJUb0ludDE2KGRhdGEuc3Vic3RyKHBvcyArIDEsIDIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGVsZW1lbnRTaXplID0gc3RyVG9JbnQyNChkYXRhLnN1YnN0cihwb3MgKyAxLCAzKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBlbGVtZW50U2l6ZSA9IHN0clRvSW50MzIoZGF0YS5zdWJzdHIocG9zICsgMSwgNCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEFsbG93IDEgYW5kIGNvbnRpbnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudERlY2xhcmVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIExPR19FUlJPUignSW52YWxpZCBjb250ZW50IHN1bW1hcnkgcGFyYW1ldGVyIC0gcG9zIG5vdCBhZHZhbmNpbmcnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBwb3MgKz0gZWxlbWVudERlY2xhcmVkTGVuZ3RoO1xuXG4gICAgICBjb25zdCBjc3QgPSBDb250ZW50U3VtbWFyeURlY29kZU1hcFtlbGVtZW50VHlwZV07XG4gICAgICBpZiAoY3N0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgTE9HX0VSUk9SKGBVbmhhbmRsZWQgZWxlbWVudCB0eXBlICR7ZWxlbWVudFR5cGV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IG5ldyBDb250ZW50U3VtbWFyeUVsZW1lbnQoY3N0LCBjdW11bGF0aXZlU2l6ZSwgZWxlbWVudFNpemUpO1xuICAgICAgZWxlbWVudHMucHVzaChjdXJyZW50RWxlbWVudCk7XG4gICAgICBjdW11bGF0aXZlU2l6ZSArPSBlbGVtZW50U2l6ZTtcbiAgICB9IC8vIGVuZCB3aGlsZSBsb29wXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuXG4gIGVuY0NvbnRlbnRTdW1tYXJ5KGNvbnRlbnRTdW1tYXJ5QXJyKSB7XG4gICAgY29uc3QgbWVzc2FnZUVsZW1lbnREZXNjcmlwdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNvbnRlbnRTdW1tYXJ5QXJyLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgLy8gYSBDb250ZW50U3VtbWFyeUVsZW1lbnRcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZW50U3VtbWFyeSA9IGNvbnRlbnRTdW1tYXJ5QXJyW2ldO1xuICAgICAgbGV0IGN1cnJlbnRTaXplU3RyID0gJyc7XG4gICAgICBsZXQgZmlyc3RCeXRlID0gQml0cy5zZXQoMCwgY3VycmVudENvbnRlbnRTdW1tYXJ5LnR5cGUsIDQsIDQpO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZW50U3VtbWFyeS5sZW5ndGggPD0gMjU1KSB7XG4gICAgICAgIC8vIGVsZW1lbnQgbGVuZ3RoOiAyXG4gICAgICAgIGZpcnN0Qnl0ZSA9IEJpdHMuc2V0KGZpcnN0Qnl0ZSwgMiwgMCwgNCk7XG4gICAgICAgIGN1cnJlbnRTaXplU3RyID0gaW50OFRvU3RyKGN1cnJlbnRDb250ZW50U3VtbWFyeS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q29udGVudFN1bW1hcnkubGVuZ3RoIDw9IDY1NTM1KSB7XG4gICAgICAgIGZpcnN0Qnl0ZSA9IEJpdHMuc2V0KGZpcnN0Qnl0ZSwgMywgMCwgNCk7XG4gICAgICAgIGN1cnJlbnRTaXplU3RyID0gaW50MTZUb1N0cihjdXJyZW50Q29udGVudFN1bW1hcnkubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbnRlbnRTdW1tYXJ5Lmxlbmd0aCA8PSAxNjc3NzIxNSkge1xuICAgICAgICBmaXJzdEJ5dGUgPSBCaXRzLnNldChmaXJzdEJ5dGUsIDQsIDAsIDQpO1xuICAgICAgICBjdXJyZW50U2l6ZVN0ciA9IGludDI0VG9TdHIoY3VycmVudENvbnRlbnRTdW1tYXJ5Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEJ5dGUgPSBCaXRzLnNldChmaXJzdEJ5dGUsIDUsIDAsIDQpO1xuICAgICAgICBjdXJyZW50U2l6ZVN0ciA9IGludDMyVG9TdHIoY3VycmVudENvbnRlbnRTdW1tYXJ5Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBtZXNzYWdlRWxlbWVudERlc2NyaXB0aW9ucy5wdXNoKGludDhUb1N0cihmaXJzdEJ5dGUpKTtcbiAgICAgIG1lc3NhZ2VFbGVtZW50RGVzY3JpcHRpb25zLnB1c2goY3VycmVudFNpemVTdHIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZUVsZW1lbnREZXNjcmlwdGlvbnMuam9pbignJyk7XG4gIH0sXG5cbiAgZW5jb2RlU01GUGFyYW0odWgsIHBhcmFtdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVoVHlwZU1hcFt1aF1bcGFyYW10eXBlXSArIGxlbk1hcFsyXTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIGlmIChsZW4gPD0gMjUzKSB7XG4gICAgICByZXR1cm4gdWhUeXBlTWFwW3VoXVtwYXJhbXR5cGVdICsgbGVuTWFwW2xlbiArIDJdICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1aFR5cGVNYXBbdWhdW3BhcmFtdHlwZV0gKyBsZW5NYXBbMF0gKyBpbnQzMlRvU3RyKGxlbiArIDYpICsgdmFsdWU7XG4gIH0sXG5cbiAgZW5jTGlnaHRTTUZQYXJhbSh1aCwgcGFyYW10eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiBsaWdodE1hcFt1aF1bcGFyYW10eXBlXVt2YWx1ZS5sZW5ndGhdICsgdmFsdWU7XG4gIH0sXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLlBhcmFtUGFyc2UgPSBQYXJhbVBhcnNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9wYXJhbS1wYXJzZS5qcyIsIi8qKlxuICogQGNsYXNzZGVzY1xuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBTTUYgcGFyYW1ldGVyXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU01GUGFyYW1ldGVyIHtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdWggVGhlIFVIIHZhbHVlIFswLi4yXVxuICogQHBhcmFtIHtTTUZQYXJhbWV0ZXJUeXBlfSB0eXBlIFRoZSB0eXBlIG9mIFNNRiBwYXJhbWV0ZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlclxuICovXG4gIGNvbnN0cnVjdG9yKHVoLCB0eXBlLCB2YWx1ZSkge1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fdWggPSB1aDtcbiAgfVxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBnZXRVaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWg7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX3VofToweCR7dGhpcy5fdHlwZS50b1N0cmluZygxNil9ID0gJHt0aGlzLl92YWx1ZX1gO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlNNRlBhcmFtZXRlciA9IFNNRlBhcmFtZXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL3NtZi1wYXJhbWV0ZXIuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTTUZQYXJhbWV0ZXJUeXBlID0ge1xuICAvLyBTTUYgcGFyYW1ldGVyIHR5cGVcbiAgUEFERElORzogICAgICAgICAgICAgICAgICAweDAwLFxuICBQVUJMSVNIRVJfSUQ6ICAgICAgICAgICAgIDB4MDEsXG4gIFBVQkxJU0hFUl9NU0dJRDogICAgICAgICAgMHgwMixcbiAgTUVTU0FHRVBSSU9SSVRZOiAgICAgICAgICAweDAzLFxuICBVU0VSREFUQTogICAgICAgICAgICAgICAgIDB4MDQsXG4gIFVTRVJOQU1FOiAgICAgICAgICAgICAgICAgMHgwNixcbiAgUEFTU1dPUkQ6ICAgICAgICAgICAgICAgICAweDA3LFxuICBSRVNQT05TRTogICAgICAgICAgICAgICAgIDB4MDgsXG4gIFNVQl9JRF9MSVNUOiAgICAgICAgICAgICAgMHgwQSxcbiAgR0VORVJJQ19BVFRBQ0hNRU5UOiAgICAgICAweDBCLFxuICBCSU5BUllfQVRUQUNITUVOVDogICAgICAgIDB4MEMsXG4gIERFTElWRVJZX01PREU6ICAgICAgICAgICAgMHgxMCxcbiAgQVNTVVJFRF9NRVNTQUdFX0lEOiAgICAgICAweDExLFxuICBBU1NVUkVEX1BSRVZNRVNTQUdFX0lEOiAgIDB4MTIsXG4gIEFTU1VSRURfUkVERUxJVkVSRURfRkxBRzogMHgxMyxcbiAgTUVTU0FHRV9DT05URU5UX1NVTU1BUlk6ICAweDE2LFxuICBBU1NVUkVEX0ZMT1dJRDogICAgICAgICAgIDB4MTcsXG4gIFRSX1RPUElDTkFNRTogICAgICAgICAgICAgMHgxOCxcbiAgQURfRkxPV1JFREVMSVZFUkVEX0ZMQUc6ICAweDE5LFxuICBBRF9USU1FVE9MSVZFOiAgICAgICAgICAgIDB4MUMsXG4gIEFEX1RPUElDU0VRVUVOQ0VfTlVNQkVSOiAgMHgxZSxcblxuICBMSUdIVF9DT1JSRUxBVElPTjogICAgICAgMHgwMCxcbiAgTElHSFRfVE9QSUNfTkFNRV9PRkZTRVQ6IDB4MDEsXG4gIExJR0hUX1FVRVVFX05BTUVfT0ZGU0VUOiAweDAyLFxuICBMSUdIVF9BQ0tfSU1NRURJQVRFTFk6ICAgMHgwMyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRlBhcmFtZXRlclR5cGUgPSBFbnVtLm5ldyhTTUZQYXJhbWV0ZXJUeXBlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvc21mLXBhcmFtZXRlci10eXBlcy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNNRlNNUE1lc3NhZ2VUeXBlID0ge1xuICBBRERTVUJTQ1JJUFRJT046ICAgICAgICAgICAgICAweDAwLFxuICBSRU1TVUJTQ1JJUFRJT046ICAgICAgICAgICAgICAweDAxLFxuICBBRERRVUVVRVNVQlNDUklQVElPTjogICAgICAgICAweDAyLFxuICBSRU1RVUVVRVNVQlNDUklQVElPTjogICAgICAgICAweDAzLFxuICBBRERTVUJTQ1JJUFRJT05GT1JDTElFTlROQU1FOiAweDA0LFxuICBSRU1TVUJTQ1JJUFRJT05GT1JDTElFTlROQU1FOiAweDA1LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU01GU01QTWVzc2FnZVR5cGUgPSBFbnVtLm5ldyhTTUZTTVBNZXNzYWdlVHlwZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1zbXAtbWVzc2FnZS10eXBlcy5qcyIsImNvbnN0IHsgQ2FjaGVDQkluZm8gfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlLWNiLWluZm8nKTtcbmNvbnN0IHsgQ2FjaGVDb250ZXh0IH0gPSByZXF1aXJlKCcuL2xpYi9jYWNoZS1jb250ZXh0Jyk7XG5jb25zdCB7IENhY2hlTGl2ZURhdGFBY3Rpb24gfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlLWxpdmUtZGF0YS1hY3Rpb25zJyk7XG5jb25zdCB7IENhY2hlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUtcmVxdWVzdCcpO1xuY29uc3QgeyBDYWNoZVJlcXVlc3RSZXN1bHQgfSA9IHJlcXVpcmUoJy4vbGliL2NhY2hlLXJlcXVlc3QtcmVzdWx0Jyk7XG5jb25zdCB7IENhY2hlUmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUtcmV0dXJuLWNvZGVzJyk7XG5jb25zdCB7IENhY2hlUmV0dXJuU3ViY29kZSB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUtcmV0dXJuLXN1YmNvZGVzJyk7XG5jb25zdCB7IENhY2hlU2Vzc2lvbiB9ID0gcmVxdWlyZSgnLi9saWIvY2FjaGUtc2Vzc2lvbicpO1xuY29uc3QgeyBDYWNoZVNlc3Npb25Qcm9wZXJ0aWVzIH0gPSByZXF1aXJlKCcuL2xpYi9jYWNoZS1zZXNzaW9uLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVDQkluZm8gPSBDYWNoZUNCSW5mbztcbm1vZHVsZS5leHBvcnRzLkNBQ0hFX1JFUVVFU1RfUFJFRklYID0gQ2FjaGVDb250ZXh0LkNBQ0hFX1JFUVVFU1RfUFJFRklYO1xubW9kdWxlLmV4cG9ydHMuQ2FjaGVMaXZlRGF0YUFjdGlvbiA9IENhY2hlTGl2ZURhdGFBY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJlcXVlc3RSZXN1bHQgPSBDYWNoZVJlcXVlc3RSZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJldHVybkNvZGUgPSBDYWNoZVJldHVybkNvZGU7XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJldHVyblN1YmNvZGUgPSBDYWNoZVJldHVyblN1YmNvZGU7XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJlcXVlc3QgPSBDYWNoZVJlcXVlc3Q7XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVNlc3Npb24gPSBDYWNoZVNlc3Npb247XG5tb2R1bGUuZXhwb3J0cy5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzID0gQ2FjaGVTZXNzaW9uUHJvcGVydGllcztcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9hcGkuanMiLCIvKipcbiAqIEBwcml2YXRlXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IENhY2hlQ29udGV4dCA9IHtcbiAgLyoqXG4gICAqIEEgcHJlZml4IGFwcGVhcmluZyBvbiB0aGUgcmVxdWVzdCBJRHMgb2YgYWxsIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCBhIFNvbGNhY2hlIHNlc3Npb24uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDQUNIRV9SRVFVRVNUX1BSRUZJWDogJyNDUlEnLFxuXG4gIC8qKlxuICAgKiBBIGdsb2JhbCBjb3VudGVyIGdlbmVyYXRpbmcgdW5pcXVlIGNvcnJlbGF0aW9uIElEcyBmb3IgY2FjaGUgcmVxdWVzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWNoZVJlcXVlc3RDb3JyZWxhdGlvbklkOiAwLFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVDb250ZXh0ID0gQ2FjaGVDb250ZXh0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtY29udGV4dC5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogU3RhdGlzdGljcyBmb3Igc2VudC9yZWNlaXZlZCBtZXNzYWdlcyBhbmQgY29udHJvbCBvcGVyYXRpb25zLlxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNvbnN0IFN0YXRUeXBlID0ge1xuXG4gIC8vIC0tLS0tLS0gU01GIGFuZCBEaXJlY3QgTWVzc2FnaW5nXG5cbiAgLyoqXG4gICAqIENvdW50IG9mIGJ5dGVzIHNlbnQgYXMgcGFydCBvZiBkYXRhIG1lc3NhZ2VzLlxuICAgKi9cbiAgVFhfVE9UQUxfREFUQV9CWVRFUzogICAgICAgICAgICAwLFxuICAvKipcbiAgICogQ291bnQgb2YgZGF0YSBtZXNzYWdlcyBzZW50LlxuICAgKi9cbiAgVFhfVE9UQUxfREFUQV9NU0dTOiAgICAgICAgICAgICAxLFxuICAvKipcbiAgICogQ291bnQgb2YgYnl0ZXMgc2VudCBhcyBwYXJ0IG9mIGRpcmVjdCBkYXRhIG1lc3NhZ2VzLlxuICAgKi9cbiAgVFhfRElSRUNUX0JZVEVTOiAgICAgICAgICAgICAgICAyLFxuICAvKipcbiAgICogQ291bnQgb2YgZGlyZWN0IGRhdGEgbWVzc2FnZXMgc2VudC5cbiAgICovXG4gIFRYX0RJUkVDVF9NU0dTOiAgICAgICAgICAgICAgICAgMyxcbiAgLyoqXG4gICAqIENvdW50IG9mIGJ5dGVzIHNlbnQgYXMgcGFydCBvZiBjb250cm9sIG1lc3NhZ2VzLlxuICAgKi9cbiAgVFhfQ09OVFJPTF9CWVRFUzogICAgICAgICAgICAgICA0LFxuICAvKipcbiAgICogQ291bnQgb2YgY29udHJvbCBtZXNzYWdlcyBzZW50LlxuICAgKi9cbiAgVFhfQ09OVFJPTF9NU0dTOiAgICAgICAgICAgICAgICA1LFxuICAvKipcbiAgICogQ291bnQgb2YgcmVxdWVzdCBtZXNzYWdlcyBzZW50LlxuICAgKi9cbiAgVFhfUkVRVUVTVF9TRU5UOiAgICAgICAgICAgICAgICA2LFxuICAvKipcbiAgICogQ291bnQgb2YgcmVxdWVzdCB0aW1lb3V0cyB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgVFhfUkVRVUVTVF9USU1FT1VUOiAgICAgICAgICAgICA3LFxuICAvKipcbiAgICogQ291bnQgb2YgYnl0ZXMgcmVjZWl2ZWQgYXMgcGFydCBvZiBkYXRhIG1lc3NhZ2VzLlxuICAgKi9cbiAgUlhfVE9UQUxfREFUQV9CWVRFUzogICAgICAgICAgICA4LFxuICAvKipcbiAgICogQ291bnQgb2YgZGF0YSBtZXNzYWdlcyByZWNlaXZlZC5cbiAgICovXG4gIFJYX1RPVEFMX0RBVEFfTVNHUzogICAgICAgICAgICAgOSxcbiAgLyoqXG4gICAqIENvdW50IG9mIGJ5dGVzIHJlY2VpdmVkIGFzIHBhcnQgb2YgZGlyZWN0IGRhdGEgbWVzc2FnZXMuXG4gICAqL1xuICBSWF9ESVJFQ1RfQllURVM6ICAgICAgICAgICAgICAgIDEwLFxuICAvKipcbiAgICogQ291bnQgb2YgZGlyZWN0IGRhdGEgbWVzc2FnZXMgcmVjZWl2ZWQuXG4gICAqL1xuICBSWF9ESVJFQ1RfTVNHUzogICAgICAgICAgICAgICAgIDExLFxuICAvKipcbiAgICogQ291bnQgb2YgYnl0ZXMgcmVjZWl2ZWQgYXMgcGFydCBvZiBjb250cm9sIG1lc3NhZ2VzLlxuICAgKi9cbiAgUlhfQ09OVFJPTF9CWVRFUzogICAgICAgICAgICAgICAxMixcbiAgLyoqXG4gICAqIENvdW50IG9mIGNvbnRyb2wgbWVzc2FnZXMgcmVjZWl2ZWQuXG4gICAqL1xuICBSWF9DT05UUk9MX01TR1M6ICAgICAgICAgICAgICAgIDEzLFxuICAvKipcbiAgICogQ291bnQgZGlzY2FyZCBtZXNzYWdlIGluZGljYXRpb25zIHJlY2VpdmVkIG9uIGluY29taW5nIG1lc3NhZ2VzLlxuICAgKi9cbiAgUlhfRElTQ0FSRF9NU0dfSU5ESUNBVElPTjogICAgICAxNCxcbiAgLyoqXG4gICAqIENvdW50IG9mIHJlcGx5IG1lc3NhZ2VkIHJlY2VpdmVkLlxuICAgKi9cbiAgUlhfUkVQTFlfTVNHX1JFQ1ZFRDogICAgICAgICAgICAxNSxcbiAgLyoqXG4gICAqIENvdW50IG9mIHJlY2VpdmVkIHJlcGx5IG1lc3NhZ2VzIHRoYXQgd2VyZSBkaXNjYXJkZWQuXG4gICAqL1xuICBSWF9SRVBMWV9NU0dfRElTQ0FSRDogICAgICAgICAgIDE2LFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvdW50IG9mIG1lc3NhZ2VzIGRpc2NhcmRlZCBkdWUgdG8gdGhlIHByZXNlbmNlIG9mIGFuIHVua25vd24gZWxlbWVudCBvclxuICAgKiB1bmtub3duIHByb3RvY29sIGluIHRoZSBTTUYgaGVhZGVyLlxuICAgKi9cbiAgUlhfRElTQ0FSRF9TTUZfVU5LTk9XTl9FTEVNRU5UOiAxNyxcblxuICAvLyAtLS0tLS0tIFNvbENhY2hlIFNlc3Npb25cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvdW50IG9mIGNhY2hlIHJlcXVlc3RzIHNlbnQuIE9uZSBjb25jZXB0dWFsIHJlcXVlc3QgKGkuZS4gb25lIEFQSSBjYWxsKVxuICAgKiBtYXkgaW52b2x2ZSBtYW55IHJlcXVlc3RzIGFuZCByZXBsaWVzLlxuICAgKi9cbiAgQ0FDSEVfUkVRVUVTVF9TRU5UOiAgICAgICAgICAgICAgICAgICAgIDE4LFxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvdW50IG9mIE9LIHJlc3BvbnNlcyB0byBjYWNoZSByZXF1ZXN0cy5cbiAgICovXG4gIENBQ0hFX1JFUVVFU1RfT0tfUkVTUE9OU0U6ICAgICAgICAgICAgICAxOSxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDb3VudCBvZiBjYWNoZSByZXF1ZXN0cyB0aGF0IHJldHVybmVkIGEgZmFpbHVyZSByZXNwb25zZS5cbiAgICovXG4gIENBQ0hFX1JFUVVFU1RfRkFJTF9SRVNQT05TRTogICAgICAgICAgICAyMCxcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDb3VudCBvZiBjYWNoZSByZXBsaWVzIGRpc2NhcmRlZCBiZWNhdXNlIGEgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQuXG4gICAqL1xuICBDQUNIRV9SRVFVRVNUX0ZVTEZJTExfRElTQ0FSRF9SRVNQT05TRTogMjEsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ291bnQgb2YgY2FjaGVkIG1lc3NhZ2VzIGRlbGl2ZXJlZCB0byB0aGUgYXBwbGljYXRpb24uXG4gICAqL1xuICBSWF9DQUNIRV9NU0c6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMjIsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ291bnQgb2YgY2FjaGUgcmVxdWVzdHMgdGhhdCB3ZXJlIGluY29tcGxldGUuXG4gICAqL1xuICBDQUNIRV9SRVFVRVNUX0lOQ09NUExFVEVfUkVTUE9OU0U6ICAgICAgMjMsXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGNhY2hlIHNlc3Npb24gb3BlcmF0aW9uIGNvbXBsZXRlZCB3aGVuIGxpdmUgZGF0YSBhcnJpdmVkIG9uIHRoZSByZXF1ZXN0ZWQgdG9waWMuXG4gICAqL1xuICBDQUNIRV9SRVFVRVNUX0xJVkVfREFUQV9GVUxGSUxMOiAgICAgICAgMjQsXG5cbiAgLy8gLS0tLS0tIEd1YXJhbnRlZWQgTWVzc2FnaW5nXG5cbiAgLyoqXG4gICAqIENvdW50IG9mIGJ5dGVzIHNlbnQgYXMgcGFydCBvZiBwZXJzaXN0ZW50IGRhdGEgbWVzc2FnZXMuXG4gICAqL1xuICBUWF9QRVJTSVNURU5UX0JZVEVTOiAgICAgICAgICAgICAgICAyNSxcbiAgLyoqXG4gICAqIENvdW50IG9mIHBlcnNpc3RlbnQgZGF0YSBtZXNzYWdlcyBzZW50LlxuICAgKi9cbiAgVFhfUEVSU0lTVEVOVF9NU0dTOiAgICAgICAgICAgICAgICAgMjYsXG4gIC8qKlxuICAgKiBDb3VudCBvZiBub24tcGVyc2lzdGVudCBkYXRhIGJ5dGVzIHNlbnQuXG4gICAqL1xuICBUWF9OT05QRVJTSVNURU5UX0JZVEVTOiAgICAgICAgICAgICAyNyxcbiAgLyoqXG4gICAqIENvdW50IG9mIG5vbi1wZXJzaXN0ZW50IGRhdGEgbWVzc2FnZXMgc2VudC5cbiAgICovXG4gIFRYX05PTlBFUlNJU1RFTlRfTVNHUzogICAgICAgICAgICAgIDI4LFxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBieXRlcyByZWRlbGl2ZXJlZCBpbiBQZXJzaXN0ZW50IG1lc3NhZ2VzLlxuICAgKi9cbiAgVFhfUEVSU0lTVEVOVF9CWVRFU19SRURFTElWRVJFRDogICAgMjksXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIFBlcnNpc3RlbnQgbWVzc2FnZXMgcmVkZWxpdmVyZWQuXG4gICAqL1xuICBUWF9QRVJTSVNURU5UX1JFREVMSVZFUkVEOiAgICAgICAgICAzMCxcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgYnl0ZXMgcmVkZWxpdmVyZWQgaW4gTm9uLVBlcnNpc3RlbnQgbWVzc2FnZXMuXG4gICAqL1xuICBUWF9OT05QRVJTSVNURU5UX0JZVEVTX1JFREVMSVZFUkVEOiAzMSxcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgTm9uLVBlcnNpc3RlbnQgbWVzc2FnZXMgcmVkZWxpdmVyZWQuXG4gICAqL1xuICBUWF9OT05QRVJTSVNURU5UX1JFREVMSVZFUkVEOiAgICAgICAzMixcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgYWNrbm93bGVkZ21lbnRzIHJlY2VpdmVkLlxuICAgKi9cbiAgVFhfQUNLU19SWEVEOiAgICAgICAgICAgICAgICAgICAgICAgMzMsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSB0cmFuc21pdCB3aW5kb3cgY2xvc2VkLlxuICAgKi9cbiAgVFhfV0lORE9XX0NMT1NFOiAgICAgICAgICAgICAgICAgICAgMzQsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBhY2tub3dsZWRnbWVudCB0aW1lciBleHBpcmVkLlxuICAgKi9cbiAgVFhfQUNLX1RJTUVPVVQ6ICAgICAgICAgICAgICAgICAgICAgMzUsXG4gIC8qKlxuICAgKiBDb3VudCBvZiBieXRlcyByZWNlaXZlZCBhcyBwYXJ0IG9mIHBlcnNpc3RlbnQgZGF0YSBtZXNzYWdlcy5cbiAgICovXG4gIFJYX1BFUlNJU1RFTlRfQllURVM6ICAgICAgICAgICAgICAgIDM2LFxuICAvKipcbiAgICogQ291bnQgb2YgcGVyc2lzdGVudCBkYXRhIG1lc3NhZ2VzIHJlY2VpdmVkLlxuICAgKi9cbiAgUlhfUEVSU0lTVEVOVF9NU0dTOiAgICAgICAgICAgICAgICAgMzcsXG4gIC8qKlxuICAgKiBDb3VudCBvZiBieXRlcyByZWNlaXZlZCBhcyBwYXJ0IG9mIG5vbi1wZXJzaXN0ZW50IGRhdGEgbWVzc2FnZXMuXG4gICAqL1xuICBSWF9OT05QRVJTSVNURU5UX0JZVEVTOiAgICAgICAgICAgICAzOCxcbiAgLyoqXG4gICAqIENvdW50IG9mIG5vbi1wZXJzaXN0ZW50IGRhdGEgbWVzc2FnZXMgcmVjZWl2ZWQuXG4gICAqL1xuICBSWF9OT05QRVJTSVNURU5UX01TR1M6ICAgICAgICAgICAgICAzOSxcbiAgLyoqXG4gICAqIENvdW50IG9mIGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyXG4gICAqIGZvciBndWFyYW50ZWVkIG1lc3NhZ2VzIHJlY2VpdmVkIGJ5IHRoZSBBUEkuXG4gICAqL1xuICBSWF9BQ0tFRDogICAgICAgICAgICAgICAgICAgICAgICAgICA0MCxcbiAgLyoqXG4gICAqIENvdW50IG9mIGd1YXJhbnRlZWQgbWVzc2FnZXMgZGlzY2FyZGVkIGZvciBiZWluZyBkdXBsaWNhdGVzLlxuICAgKi9cbiAgUlhfRElTQ0FSRF9EVVBMSUNBVEU6ICAgICAgICAgICAgICAgNDEsXG4gIC8qKlxuICAgKiBDb3VudCBvZiBndWFyYW50ZWVkIG1lc3NhZ2VzIGRpc2NhcmRlZCBkdWUgdG8gbm8gbWF0Y2ggbWVzc2FnZSBjb25zdW1lciBmb3IgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBSWF9ESVNDQVJEX05PX01BVENISU5HX0NPTlNVTUVSOiAgICA0MixcbiAgLyoqXG4gICAqIENvdW50IG9mIGd1YXJhbnRlZWQgbWVzc2FnZXMgZGlzY2FyZGVkIGZvciBiZWluZyByZWNlaXZlZCBvdXQgb2Ygb3JkZXIuXG4gICAqL1xuICBSWF9ESVNDQVJEX09VVF9PRl9PUkRFUjogICAgICAgICAgICA0Myxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlN0YXRUeXBlID0gRW51bS5uZXcoU3RhdFR5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc3RhdHMvbGliL3N0YXQtdHlwZXMuanMiLCJjbGFzcyBCYXNlU01GQ2xpZW50IHtcbiAgY29uc3RydWN0b3IocnhTbWZDQiwgcnhNZXNzYWdlRXJyb3JDQiwgc2Vzc2lvbikge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLl9yeFNtZkNCID0gcnhTbWZDQjsgLy8gY2FsbGJhY2sgZm9yIHBhcnNlZCBtc2dcbiAgICB0aGlzLl9yeE1lc3NhZ2VFcnJvckNCID0gcnhNZXNzYWdlRXJyb3JDQjsgLy8gaW52YWxpZCBVSCwgZXRjLlxuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fY29ycmVsYXRpb25Db3VudGVyID0gMDtcbiAgfVxuXG4gIG5leHRDb3JyZWxhdGlvblRhZygpIHtcbiAgICAvLyBMb2dpbiB1c2VzIHRoZSBtYXggdmFsdWUgYXMgYSBzZW50aW5lbCwgc28gd3JhcCBhcm91bmQgZWFybHlcbiAgICBpZiAoKyt0aGlzLl9jb3JyZWxhdGlvbkNvdW50ZXIgPj0gQmFzZVNNRkNsaWVudC5TTUZfTUFYX0NPUlJFTEFUSU9OKSB7XG4gICAgICB0aGlzLl9jb3JyZWxhdGlvbkNvdW50ZXIgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29ycmVsYXRpb25Db3VudGVyO1xuICB9XG59XG5cbkJhc2VTTUZDbGllbnQuU01GX01BWF9DT1JSRUxBVElPTiA9IDB4RkZGRkZGO1xuXG5cbm1vZHVsZS5leHBvcnRzLkJhc2VTTUZDbGllbnQgPSBCYXNlU01GQ2xpZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi9iYXNlLXNtZi1jbGllbnQuanMiLCJjb25zdCBIVFRQTGliID0gcmVxdWlyZSgnLi9odHRwJyk7XG5jb25zdCB7IFN0YXRlQmFzZTY0IH0gPSByZXF1aXJlKCcuL3N0YXRlLWJhc2U2NCcpO1xuY29uc3QgeyBTdGF0ZUJpbmFyeSB9ID0gcmVxdWlyZSgnLi9zdGF0ZS1iaW5hcnknKTtcbmNvbnN0IHsgU3RhdGVTdHJlYW1pbmdBbmRCaW5hcnkgfSA9IHJlcXVpcmUoJy4vc3RhdGUtc3RyZWFtaW5nLWFuZC1iaW5hcnknKTtcbmNvbnN0IHsgU3RhdGVXZWJTb2NrZXRCaW5hcnkgfSA9IHJlcXVpcmUoJy4vc3RhdGUtd2Vic29ja2V0LWJpbmFyeScpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnQgfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydCcpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydC1jYXBhYmlsaXRpZXMnKTtcblxuY29uc3QgeyBTb2xjbGllbnRGYWN0b3J5IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZmFjdG9yeScpO1xuXG5Tb2xjbGllbnRGYWN0b3J5LmFkZEluaXRpYWxpemVyKGZ1bmN0aW9uIGZhY3RvcnlJbml0aWFsaXplcigpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdsb2JhbC1yZXF1aXJlXG4gIGNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbiAgaWYgKEJVSUxEX0VOVi5UQVJHRVRfTk9ERSkge1xuICAgIC8vIFdlYlNvY2tldCB0cmFuc3BvcnQ6XG4gICAgLy8gdXNlIGN1c3RvbSBhZ2VudCBmb3IgY2xpZW50IGNlcnRpZmljYXRlIGFuZCBTU0wgc2Vzc2lvbiByZXN1bWUgc3VwcG9ydFxuICAgIHRoaXMud3NTc2xBZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7XG4gICAgICBrZWVwQWxpdmU6IGZhbHNlLFxuICAgIH0pO1xuICB9XG59KTtcblxuY29uc3QgeyBIVFRQQ29ubmVjdGlvbiwgSFRUUFRyYW5zcG9ydFNlc3Npb24gfSA9IEhUVFBMaWI7XG5cbm1vZHVsZS5leHBvcnRzLkhUVFBDb25uZWN0aW9uID0gSFRUUENvbm5lY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5IVFRQVHJhbnNwb3J0U2Vzc2lvbiA9IEhUVFBUcmFuc3BvcnRTZXNzaW9uO1xubW9kdWxlLmV4cG9ydHMuU3RhdGVCYXNlNjQgPSBTdGF0ZUJhc2U2NDtcbm1vZHVsZS5leHBvcnRzLlN0YXRlQmluYXJ5ID0gU3RhdGVCaW5hcnk7XG5tb2R1bGUuZXhwb3J0cy5TdGF0ZVN0cmVhbWluZ0FuZEJpbmFyeSA9IFN0YXRlU3RyZWFtaW5nQW5kQmluYXJ5O1xubW9kdWxlLmV4cG9ydHMuU3RhdGVXZWJTb2NrZXRCaW5hcnkgPSBTdGF0ZVdlYlNvY2tldEJpbmFyeTtcbm1vZHVsZS5leHBvcnRzLldlYlRyYW5zcG9ydCA9IFdlYlRyYW5zcG9ydDtcbm1vZHVsZS5leHBvcnRzLldlYlRyYW5zcG9ydENhcGFiaWxpdGllcyA9IFdlYlRyYW5zcG9ydENhcGFiaWxpdGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL2FwaS5qcyIsImNvbnN0IHsgSFRUUENvbm5lY3Rpb24gfSA9IHJlcXVpcmUoJy4vaHR0cC1jb25uZWN0aW9uJyk7XG5jb25zdCB7IEhUVFBUcmFuc3BvcnRTZXNzaW9uIH0gPSByZXF1aXJlKCcuL2h0dHAtdHJhbnNwb3J0LXNlc3Npb24nKTtcblxuaWYgKEJVSUxEX0VOVi5UQVJHRVRfQlJPV1NFUikge1xuICBtb2R1bGUuZXhwb3J0cy5IVFRQQ29ubmVjdGlvbiA9IEhUVFBDb25uZWN0aW9uO1xuICBtb2R1bGUuZXhwb3J0cy5IVFRQVHJhbnNwb3J0U2Vzc2lvbiA9IEhUVFBUcmFuc3BvcnRTZXNzaW9uO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvaHR0cC9hcGkuanMiLCJjb25zdCBEZXN0aW5hdGlvblV0aWxMaWIgPSByZXF1aXJlKCcuL2Rlc3RpbmF0aW9uLXV0aWwnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IGFzc2VydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7IERlc3RpbmF0aW9uIH0gPSByZXF1aXJlKCcuL2Rlc3RpbmF0aW9uJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uVHlwZSB9ID0gcmVxdWlyZSgnLi9kZXN0aW5hdGlvbi10eXBlJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIFF1ZXVlLCB3aGljaCBpcyBhIHR5cGUgb2Yge0BsaW5rIHNvbGFjZS5EZXN0aW5hdGlvbn0uXG4gKlxuICogSW5zdGFuY2VzIHNob3VsZCBiZSBhY3F1aXJlZCB0aHJvdWdoXG4gKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnkuY3JlYXRlRHVyYWJsZVF1ZXVlRGVzdGluYXRpb259IG9yIGJ5IGNhbGxpbmdcbiAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyI2dldERlc3RpbmF0aW9ufSBvbiBhIGNvbnN1bWVyIGJvdW5kIHRvIGEgdGVtcG9yYXJ5IHF1ZXVlLlxuICpcbiAqIEBleHRlbmRzIHNvbGFjZS5EZXN0aW5hdGlvblxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUXVldWUgZXh0ZW5kcyBEZXN0aW5hdGlvbiB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIFRoZSBzcGVjIGZvciB0aGlzIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgYXNzZXJ0KHNwZWMubmFtZSwgJ1F1ZXVlIG5hbWUgbm90IHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KHNwZWMudHlwZSA9PT0gRGVzdGluYXRpb25UeXBlLlFVRVVFXG4gICAgICAgICAgIHx8IHNwZWMudHlwZSA9PT0gRGVzdGluYXRpb25UeXBlLlRFTVBPUkFSWV9RVUVVRSwgJ1F1ZXVlIHNwZWMudHlwZSBpcyBpbnZhbGlkJyk7XG4gICAgYXNzZXJ0KHNwZWMuYnl0ZXMsICdRdWV1ZSBzcGVjIG1pc3NpbmcgYnl0ZXMnKTtcbiAgICBhc3NlcnQoc3BlYy5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ1F1ZXVlIHNwZWMgbWlzc2luZyBvZmZzZXQnKTtcbiAgICBzdXBlcihzcGVjKTtcbiAgfVxuXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9XG4gIGdldCBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2Zmc2V0KCk7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIGBbUXVldWUgJHt0aGlzLmdldE5hbWUoKX1dYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBxdWV1ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHF1ZXVlIChubyBwcmVmaXgpXG4gICAqIEByZXR1cm5zIHtRdWV1ZX0gYSBRdWV1ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUZyb21Mb2NhbE5hbWUocXVldWVOYW1lKSB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBEZXN0aW5hdGlvblV0aWxMaWIuRGVzdGluYXRpb25VdGlsLnZhbGlkYXRlQW5kRW5jb2RlKFxuICAgICAgRGVzdGluYXRpb25UeXBlLlFVRVVFLCBxdWV1ZU5hbWUpO1xuICAgIGlmIChlbmNvZGluZy5lcnJvcikge1xuICAgICAgdGhyb3cgZW5jb2RpbmcuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUXVldWUoe1xuICAgICAgbmFtZTogICAgICAgICBxdWV1ZU5hbWUsXG4gICAgICB0eXBlOiAgICAgICAgIERlc3RpbmF0aW9uVHlwZS5RVUVVRSxcbiAgICAgIGlzVmFsaWRhdGVkOiAgdHJ1ZSxcbiAgICAgIGJ5dGVzOiAgICAgICAgZW5jb2RpbmcuYnl0ZXMsXG4gICAgICBvZmZzZXQ6ICAgICAgIGVuY29kaW5nLm9mZnNldCxcbiAgICAgIGlzV2lsZGNhcmRlZDogZW5jb2RpbmcuaXNXaWxkY2FyZGVkLFxuICAgIH0pO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuUXVldWUgPSBRdWV1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWRlc3RpbmF0aW9uL2xpYi9xdWV1ZS5qcyIsImNvbnN0IERlc3RpbmF0aW9uVXRpbExpYiA9IHJlcXVpcmUoJy4vZGVzdGluYXRpb24tdXRpbCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgRGVzdGluYXRpb24gfSA9IHJlcXVpcmUoJy4vZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgRGVzdGluYXRpb25UeXBlIH0gPSByZXF1aXJlKCcuL2Rlc3RpbmF0aW9uLXR5cGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgVG9waWMsIHdoaWNoIGlzIGEgdHlwZSBvZiB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9ufS5cbiAqXG4gKiBAZXh0ZW5kcyBzb2xhY2UuRGVzdGluYXRpb25cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIDEwLjAgQXBwbGljYXRpb25zIHNob3VsZCBub3QgZGlyZWN0bHkgcmVmZXIgdG8gdGhpcyB0eXBlLlxuICogIHtAbGluayBzb2xhY2UuRGVzdGluYXRpb259IHByb3ZpZGVzIHRoZSBmdWxsIGludGVyZmFjZSBhdmFpbGFibGUgdG8gdG9waWMsIGFuZCBpdCBjYW4gYmVcbiAqICBkZXRlcm1pbmVkIHdoZXRoZXIgdGhlIGRlc3RpbmF0aW9uIHJlcHJlc2VudHMgYSB0b3BpYyBpZiB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9uI2dldFR5cGV9XG4gKiAgcmV0dXJucyB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9uVHlwZS5UT1BJQ30uXG4gKi9cbmNsYXNzIFRvcGljIGV4dGVuZHMgRGVzdGluYXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHNwZWMgVGhlIHRvcGljIHNwZWNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzdXBlcih7XG4gICAgICAgIHR5cGU6ICAgICAgICAgRGVzdGluYXRpb25UeXBlLlRPUElDLFxuICAgICAgICBuYW1lOiAgICAgICAgIHNwZWMubmFtZSxcbiAgICAgICAgYnl0ZXM6ICAgICAgICBzcGVjLmJ5dGVzLFxuICAgICAgICBvZmZzZXQ6ICAgICAgIHNwZWMub2Zmc2V0LFxuICAgICAgICBpc1ZhbGlkYXRlZDogIHNwZWMuaXNWYWxpZGF0ZWQsXG4gICAgICAgIGlzV2lsZGNhcmRlZDogc3BlYy5pc1dpbGRjYXJkZWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVwcmVjYXRlZCBwYXRoIC0tIHN1cGVyIHdpbGwgZG8gdG9waWMgZW5jb2RlXG4gICAgICBzdXBlcihzcGVjLCBEZXN0aW5hdGlvblR5cGUuVE9QSUMpO1xuICAgIH1cbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYFtUb3BpYyAke3RoaXMuZ2V0TmFtZSgpfV1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvcGljTmFtZSBUaGUgbmFtZSBmb3IgdGhlIHRvcGljXG4gICAqIEByZXR1cm5zIHtUb3BpY30gdGhlIFRvcGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRnJvbU5hbWUodG9waWNOYW1lKSB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBEZXN0aW5hdGlvblV0aWxMaWIuRGVzdGluYXRpb25VdGlsLnZhbGlkYXRlQW5kRW5jb2RlKFxuICAgICAgRGVzdGluYXRpb25UeXBlLlRPUElDLCB0b3BpY05hbWUpO1xuICAgIGlmIChlbmNvZGluZy5lcnJvcikge1xuICAgICAgdGhyb3cgZW5jb2RpbmcuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVG9waWMoe1xuICAgICAgbmFtZTogICAgICAgICB0b3BpY05hbWUsXG4gICAgICBpc1ZhbGlkYXRlZDogIHRydWUsXG4gICAgICBieXRlczogICAgICAgIGVuY29kaW5nLmJ5dGVzLFxuICAgICAgb2Zmc2V0OiAgICAgICBlbmNvZGluZy5vZmZzZXQsXG4gICAgICBpc1dpbGRjYXJkZWQ6IGVuY29kaW5nLmlzV2lsZGNhcmRlZCxcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Ub3BpYyA9IFRvcGljO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL3RvcGljLmpzIiwiY29uc3QgeyBTb2xhY2VFcnJvciB9ID0gcmVxdWlyZSgnLi9zb2xhY2UtZXJyb3InKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiA8Yj5UaGlzIGNsYXNzIGlzIG5vdCBleHBvc2VkIGZvciBjb25zdHJ1Y3Rpb24gYnkgQVBJIHVzZXJzLjwvYj5cbiAqIEFuIGVycm9yIHRocm93biBieSB0aGUgQVBJIHdoZW4gYW4gb3BlcmF0aW9uYWwgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAZXh0ZW5kcyB7c29sYWNlLlNvbGFjZUVycm9yfVxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBPcGVyYXRpb25FcnJvciBleHRlbmRzIFNvbGFjZUVycm9yIHtcblxuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3ViY29kZV0gVGhlIHN1YmNvZGUuIFNlZSB7QGxpbmsgRXJyb3JTdWJjb2RlfSBmb3IgdmFsaWQgdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVhc29uXSBFbWJlZGRlZCBlcnJvciBvciBleGNlcHRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3ViY29kZSwgcmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgICAqIEBuYW1lIHNvbGFjZS5PcGVyYXRpb25FcnJvciNuYW1lXG4gICAgICogQHR5cGUge0NvbnN0YW50fVxuICAgICAqIEBkZXNjcmlwdGlvbiAnT3BlcmF0aW9uRXJyb3InXG4gICAgICovXG4gICAgc3VwZXIoJ09wZXJhdGlvbkVycm9yJywgbWVzc2FnZSwgT3BlcmF0aW9uRXJyb3IpO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJjb2RlIGZvciB0aGUgZXJyb3IuIEBzZWUge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGV9XG4gICAgICogQG5hbWUgc29sYWNlLk9wZXJhdGlvbkVycm9yI3N1YmNvZGVcbiAgICAgKiBAdHlwZSB7c29sYWNlLkVycm9yU3ViY29kZX1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmNvZGUgPSBzdWJjb2RlO1xuICAgIC8qKlxuICAgICAqIFRoZSByZWFzb24gZm9yIHRoZSBlcnJvcjogYW4gZW1iZWRkZWQgZXJyb3Igb2JqZWN0IG9yIGV4Y2VwdGlvbi5cbiAgICAgKiBAbmFtZSBzb2xhY2UuT3BlcmF0aW9uRXJyb3IjcmVhc29uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLk9wZXJhdGlvbkVycm9yID0gT3BlcmF0aW9uRXJyb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lcnJvci9saWIvb3BlcmF0aW9uLWVycm9yLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBBbiBhdHRyaWJ1dGUgb2Yge0BsaW5rIHNvbGFjZS5SZXF1ZXN0RXJyb3J9LiBUaGlzIGVudW1lcmF0aW9uIHJlcHJlc2VudHMgdGhlXG4gKiBkaWZmZXJlbnQgZXJyb3JzIGVtaXR0ZWQgYnlcbiAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbi5yZXF1ZXN0RmFpbGVkQ2FsbGJhY2t9XG4gKiB3aGVuIGEge0BsaW5rIHNvbGFjZS5TZXNzc2lvbiNzZW5kUmVxdWVzdH0gZmFpbHMuXG4gKlxuICogVGhlIGNsaWVudCBhcHBsaWNhdGlvbiByZWNlaXZlcyBhIHJlcXVlc3QgZXJyb3Igd2l0aCBldmVudCBjb2RlXG4gKiB7QGxpbmsgc29sYWNlLlJlcXVlc3RFdmVudENvZGUuUkVRVUVTVF9BQk9SVEVEfVxuICogd2hlbiB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQsIG9yIGNsb3NlZCBhcyBhIHJlc3VsdFxuICogb2YgYSBjb21tdW5pY2F0aW9uIGVycm9yLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgUmVxdWVzdEV2ZW50Q29kZSA9IHtcbiAgLyoqXG4gICAqIEEgcmVxdWVzdCB3YXMgYWJvcnRlZCBiZWNhdXNlIHRoZSBzZXNzaW9uIGlzIGRpc2Nvbm5lY3RlZC5cbiAgICovXG4gIFJFUVVFU1RfQUJPUlRFRDogOCxcbiAgLyoqXG4gICAqIFRoZSBldmVudCByZXByZXNlbnRzIGEgdGltZWQtb3V0IHJlcXVlc3QgQVBJIGNhbGwuXG4gICAqL1xuICBSRVFVRVNUX1RJTUVPVVQ6IDksXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0RXZlbnRDb2RlID0gRW51bS5uZXcoUmVxdWVzdEV2ZW50Q29kZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lcnJvci9saWIvcmVxdWVzdC1ldmVudC1jb2Rlcy5qcyIsImNvbnN0IERFRkFVTFRfUFJPUEVSVFlfT1BUSU9OUyA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbn07XG5cbmZ1bmN0aW9uIHNldFByb3BlcnR5VmFsdWUodGFyZ2V0LCBrZXksIHZhbHVlLCBvcHRpb25zID0gbnVsbCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgdmFsdWUgfSwgREVGQVVMVF9QUk9QRVJUWV9PUFRJT05TLCBvcHRpb25zKSk7XG59XG5cblxuZnVuY3Rpb24gbGF6eVByb3BlcnR5KHRhcmdldCwga2V5LCBldmFsRm4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsIC8vIEFsbG93IHJlcGxhY2luZyB0aGlzIHByb3BlcnR5IHdpdGggcmVzb2x2ZWQgdmFsdWUuXG4gICAgICBnZXQ6ICAgICAgICAgICgpID0+IHtcbiAgICAgICAgLy8gVGhlIGdldHRlciBldmFsdWF0ZXMgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkLlxuICAgICAgICAvLyBJdCByZXBsYWNlcyBpdHNlbGYgd2l0aCB0aGUgdmFsdWUgaXQgcmVzb2x2ZXMuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWxGbih0YXJnZXQsIGtleSk7XG4gICAgICAgIHNldFByb3BlcnR5VmFsdWUodGFyZ2V0LCBrZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgc2V0UHJvcGVydHlWYWx1ZSh0YXJnZXQsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICB9LCBERUZBVUxUX1BST1BFUlRZX09QVElPTlMpKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gbGF6eVByb3BlcnRpZXModGFyZ2V0LCBvYmopIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgbGF6eVByb3BlcnR5KHRhcmdldCwgaywgb2JqW2tdKTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGxhenlWYWx1ZShldmFsRm4pIHtcbiAgcmV0dXJuIGxhenlQcm9wZXJ0eSh7fSwgJ3ZhbHVlJywgZXZhbEZuKTtcbn1cblxuY29uc3QgTGF6eSA9IHtcbiAgbGF6eVByb3BlcnRpZXMsXG4gIGxhenlQcm9wZXJ0eSxcbiAgbGF6eVZhbHVlLFxufTtcblxubW9kdWxlLmV4cG9ydHMuTGF6eSA9IExhenk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvbGF6eS5qcyIsImNvbnN0IHsgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuXG5sZXQgYmluZGluZyA9IG51bGw7XG5cbmNvbnN0IFByb2ZpbGVCaW5kaW5nID0ge1xuICBnZXQgdmFsdWUoKSB7XG4gICAgaWYgKGJpbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignUHJvZmlsZSBiaW5kaW5nIG5vdCBpbml0aWFsaXplZC4gQ2FsbCBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5pbml0Jyk7XG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5nO1xuICB9LFxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAvLyBwcml2YXRlLCBzbyB3ZSdsbCBhbGxvdyBpdCBmb3IgdGVzdGluZ1xuICAgIGJpbmRpbmcgPSB2YWx1ZTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlByb2ZpbGVCaW5kaW5nID0gUHJvZmlsZUJpbmRpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mYWN0b3J5L2xpYi9wcm9maWxlLWJpbmRpbmcuanMiLCJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBQcmVmZXJyZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIHByb2ZpbGUgc3lzdGVtOlxuXG4vLyBFbmQgdXNlcjpcbi8vICBvcGFxdWUgcHJvZmlsZXMsIHByb3BlcnR5LXN0eWxlIGFjY2Vzc1xuLy8gQVBJIGltcGxlbWVudGF0aW9uOlxuLy8gIGluaGVyaXRlZCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eS1zdHlsZSBhY2Nlc3Ncbi8vIEEgcm9vdCwgZm9yd2FyZCBjb21wYXRpYmxlIHByb2ZpbGVcbi8vIEEgbGVnYWN5LCBiYWNrd2FyZHMgY29tcGF0aWJsZSBwcm9maWxlXG4vLyBGZWF0dXJlL21pbGVzdG9uZSBwcm9maWxlcyB0aGF0IGluaGVyaXQgZnJvbSBvbmUgb2YgdGhlc2UgdHdvIGNvbmZpZ3VyYXRpb25zXG5cbi8vIFRoZSBsb3dlc3QtZnJpY3Rpb24gd2F5IG9mIGRvaW5nIHRoaXMgaXMgdXNpbmcgcHJvdG90eXBlIGluaGVyaXRhbmNlLlxuLy8gQWxzbyBjb25zaWRlcmVkOlxuLy8gIGdldFByb3BlcnR5KCkgd2l0aCBjaGlsZC0+cGFyZW50IHBvaW50ZXJzIC0tIG1peGVzIHN0cmluZ1xuLy8gICAgYW5kIHByb3BlcnR5IGFjY2Vzc1xuLy8gIEVTNiBwcm94aWVzIC0tIG5vdCB1bml2ZXJzYWwgYW5kIG5vdCBzaGltbWFibGVcblxuLy8gTmVjZXNzYXJ5IHRvIGFidXNlIHByb3RvdHlwZSBpbmhlcml0YW5jZSBmb3Igc3RhdGljIHByb3BlcnR5IGluaGVyaXRhbmNlOlxuLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIDxiPlRoaXMgY2xhc3MgaXMgbm90IGV4cG9zZWQgZm9yIGNvbnN0cnVjdGlvbiBieSBBUEkgdXNlcnMuIFVzZXJzIHNob3VsZCBvYnRhaW4gYW4gaW5zdGFuY2UgZnJvbVxuICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXN9LjwvYj5cbiAqXG4gKiBBIGZhY3RvcnkgcHJvZmlsZSBkZXRlcm1pbmVzIHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkgb2YgdGhlIEFQSS4gUHJvZmlsZXMgYXJlIHByZWRlZmluZWRcbiAqIGNvbWJpbmF0aW9ucyBvZiBjYXBhYmlsaXRpZXMgdGhhdCByZXByZXNlbnQgYSBtdXR1YWxseS1jb25zaXN0ZW50LCB2YWxpZCBjb25maWd1cmF0aW9uIHN0YXRlXG4gKiBmb3IgQVBJIGZlYXR1cmVzLlxuICpcbiAqIFRoZSBmYWN0b3J5IG1heSBiZSBpbml0aWFsaXplZCBleGFjdGx5IG9uY2UsIHdpdGggYSBzaW5nbGUgZmFjdG9yeSBwcm9maWxlLlxuICpcbiAqIENoYW5naW5nIHdoaWNoIGZhY3RvcnkgcHJvZmlsZSBpcyB1c2VkIGJ5IHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5pbml0fSBtYXkgcmVzdWx0IGluXG4gKiBkaWZmZXJlbnQgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZXMsIHZhbGlkYXRpb24sIGZ1bmN0aW9uIHNpZ25hdHVyZXMgYW5kIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBDaGFuZ2luZyB0aGUgZmFjdG9yeSBwcm9maWxlIHdpbGwgbm90IGNoYW5nZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gQVBJIG1ldGhvZHMuIFRoYXQgaXMsXG4gKiBhc3N1bWluZyBhbGwgcHJvcGVydGllcyBhbmQgYXJndW1lbnRzIGFyZSBleHBsaWNpdGx5IHNldCwgYW4gYXBwbGljYXRpb24gbWF5IGNhbGwgdGhlXG4gKiBBUEkgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgYmVmb3JlIHRvIGNhdXNlIHRoZSBzYW1lIHJlc3VsdCwgdW5sZXNzIGV4cGxpY2l0bHkgbm90ZWQuXG4gKlxuICogSWYgbm8gcHJvZmlsZSBpcyBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IHdpbGwgcHJvdmlkZSBlcXVpdmFsZW50IGZ1bmN0aW9uYWxpdHkgdG9cbiAqIFNvbGNsaWVudEpTIHZlcnNpb24gNy54LiBOZXcgYXBwbGljYXRpb25zIGFyZSBlbmNvdXJhZ2VkIHRvIHVzZSB0aGVcbiAqIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb24xMH0gcHJvZmlsZSBmb3IgdGhlIGJlc3QgY29tcGF0aWJpbGl0eSB3aXRoXG4gKiBvdGhlciBBUElzIChleGNsdWRpbmcgNy54IEphdmFTY3JpcHQgQVBJcykuXG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRmFjdG9yeVByb2ZpbGUge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIEd1YXJhbnRlZWQgTWVzc2FnaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBBUEkuIFdoZW4gYHRydWVgLFxuICAgKiBBRCBwdWJsaXNoaW5nIGNhcGFiaWxpdHkgaXMgZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZ3VhcmFudGVlZE1lc3NhZ2luZ0VuYWJsZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBBUEkgd2lsbCBhbGxvdyBDb21ldCAobG9uZy1oZWxkIEhUVFAgcmVxdWVzdCkgdHJhbnNwb3J0c1xuICAgKiB0byBiZSB1c2VkLiBJZiB0aGlzIGlzIGB0cnVlYCwgdHJhbnNwb3J0IHByb3RvY29scyBtYXkgZmFsbCBiYWNrIHRvIEhUVFBcbiAgICogaWYgYSBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZCB3aXRoIGEgcHJlZmVycmVkIHByb3RvY29sLlxuICAgKlxuICAgKiAgKiBOT1RFOiBHdWFyYW50ZWVkIE1lc3NhZ2luZyBjYW5ub3QgYmUgZW5hYmxlZCBpZiBDb21ldCBpcyBlbmFibGVkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgZ2V0IGNvbWV0RW5hYmxlZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIEFQSSBwZXJmb3JtcyBVVEYtOCBlbmNvZGluZyBvbiB1c2VyIHN0cmluZ3Mgd2hlcmUgdGhlIFNNRlxuICAgKiBzcGVjIHJlcXVpcmVzIGl0LlxuICAgKiAgKiBXaGVuIHRoaXMgaXMgYHRydWVgLCB0aGUgQVBJIHdpbGwgY29ycmVjdGx5IGludGVyb3BlcmF0ZSB3aXRoIG90aGVyIFNvbGFjZSBBUElzIHRoYXQgc2VuZFxuICAgKiAgICBVVEYtOCBlbmNvZGVkIHRvcGljcy5cbiAgICogICogV2hlbiB0aGlzIGlzIGBmYWxzZWAsIHRoZSBBUEkgd2lsbCBpbnRlcm9wZXJhdGUgY29ycmVjdGx5IHdpdGggNy54IGFuZCBlYXJsaWVyIEphdmFTY3JpcHRcbiAgICogICAgQVBJcywgdGhhdCB1c2VkIGFuIGFyYml0cmFyeSBlbmNvZGluZyBmb3Igc3VjaCBzdHJpbmdzLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0b3BpY1V0ZjhFbmNvZGUoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdndWFyYW50ZWVkTWVzc2FnaW5nRW5hYmxlZCc6IHRoaXMuZ3VhcmFudGVlZE1lc3NhZ2luZ0VuYWJsZWQsXG4gICAgICAnY29tZXRFbmFibGVkJzogICAgICAgICAgICAgICB0aGlzLmNvbWV0RW5hYmxlZCxcbiAgICAgICd0b3BpY1V0ZjhFbmNvZGUnOiAgICAgICAgICAgIHRoaXMudG9waWNVdGY4RW5jb2RlLFxuICAgIH07XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIFZlcnNpb24gNyBwcm9maWxlIGZvciBTb2xjbGllbnRKUy4gVGhpcyBwcm9maWxlIHNldHMgZmFjdG9yeSBhbmQgc2Vzc2lvbiBkZWZhdWx0IHZhbHVlc1xuICogdGhhdCBwcm92aWRlIFNvbGNsaWVudEpTIDcueCBiZWhhdmlvdXIsIGFuZCBpbnRlcm9wZXJhYmlsaXR5IHdpdGggU29sY2xpZW50SlMgNy54IGNsaWVudHMuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHR5cGUge3NvbGFjZS5GYWN0b3J5UHJvZmlsZX1cbiAqIEBuYW1lIHZlcnNpb243XG4gKiBAbWVtYmVyb2Ygc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlc1xuICovXG5jbGFzcyBWZXJzaW9uN1Byb2ZpbGUgZXh0ZW5kcyBGYWN0b3J5UHJvZmlsZSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGBmYWxzZWA6IEd1YXJhbnRlZWQgTWVzc2FnaW5nIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgdG8gbWFpbnRhaW4gYXZhaWxhYmlsaXR5IG9mIENvbWV0XG4gICAqIEhUVFAgdHJhbnNwb3J0cyBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb243Lmd1YXJhbnRlZWRNZXNzYWdpbmdFbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWA6IEd1YXJhbnRlZWQgTWVzc2FnaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBBUEkuIE5vdGUgdGhhdCB2ZXJzaW9uIDcueCBTb2xjbGllbnRKU1xuICAgKiBjbGllbnRzIGNhbm5vdCBzZW5kIG9yIHJlY2VpdmUgYW55IG1lc3NhZ2VzIHVzaW5nIEd1YXJhbnRlZWQgTWVzc2FnaW5nIGZlYXR1cmVzLlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb243Lmd1YXJhbnRlZWRNZXNzYWdpbmdFbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICBnZXQgZ3VhcmFudGVlZE1lc3NhZ2luZ0VuYWJsZWQoKSB7IHJldHVybiAhIUJVSUxEX0VOVi5UQVJHRVRfTk9ERTsgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWU6IENvbWV0IEhUVFAgdHJhbnNwb3J0cyBhcmUgZW5hYmxlZCBmb3IgdGhlIEFQSS4gVGhlIEFQSSB1c2VyIG1heSwgYnkgZGVmYXVsdCxcbiAgICogc2VsZWN0IENvbWV0IEhUVFAgdHJhbnNwb3J0IHByb3RvY29sLCBhbmQgdGhlIEFQSSBtYXkgZmFsbCBiYWNrIHRvIHRoZXNlIHByb3RvY29scyBkdXJpbmcgYVxuICAgKiBjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAqXG4gICAqIEBuYW1lIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjcuY29tZXRFbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICAvKipcbiAgICogUmV0dXJucyBmYWxzZTogQ29tZXQgSFRUUCB0cmFuc3BvcnRzIGFyZSBub3QgcHJlc2VudCBpbiBOb2RlLmpzLlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb243LmNvbWV0RW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IGNvbWV0RW5hYmxlZCgpIHsgcmV0dXJuICEhQlVJTERfRU5WLlRBUkdFVF9CUk9XU0VSOyB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhbHNlOiB0b3BpYyBVVEYtOCBlbmNvZGluZyBpcyBkaXNhYmxlZCBmb3IgdGhlIEFQSS4gVGhlIG5ldHdvcmsgZW5jb2Rpbmcgb2YgdG9waWNzIGlzXG4gICAqIGNvbXBhdGlibGUgd2l0aCBvdGhlciBTb2xjbGllbnRKUyA3LnggY2xpZW50cywgYW5kIG1heSBub3QgYmUgaW50ZXJvcGVyYWJsZSB3aXRoIG90aGVyXG4gICAqIFNvbGFjZSBNZXNzYWdpbmcgQVBJcy5cbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uNy50b3BpY1V0ZjhFbmNvZGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHRvcGljVXRmOEVuY29kZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5jb25zdCBsZWdhY3lJbnN0YW5jZSA9IG5ldyBWZXJzaW9uN1Byb2ZpbGUoKTtcblxuLyoqXG4gKiBUaGUgVmVyc2lvbiAxMCBwcm9maWxlIGZvciBTb2xjbGllbnRKUy4gVGhpcyBwcm9maWxlIHNldHMgZmFjdG9yeSBhbmQgc2Vzc2lvbiBkZWZhdWx0IHZhbHVlc1xuICogdGhhdCBwcm92aWRlIHRoZSBmdWxsIGNhcGFiaWxpdHkgb2YgdGhlIEFQSSBhcyBvZiB2ZXJzaW9uIDEwLjAsIGluY2x1ZGluZyBpbnRlcm9wZXJhYmlsaXR5IHdpdGhcbiAqIG90aGVyIFNvbGFjZSBNZXNzYWdpbmcgcHJvZHVjdHMuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgdmVyc2lvbjEwXG4gKiBAbWVtYmVyb2Ygc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlc1xuICovXG5jbGFzcyBWZXJzaW9uMTBQcm9maWxlIGV4dGVuZHMgRmFjdG9yeVByb2ZpbGUge1xuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWA6IEd1YXJhbnRlZWQgTWVzc2FnaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBBUEksXG4gICAqIHdpdGggdGhlIHJlc3VsdCB0aGF0IHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMjZW5hYmxlZH0gaXMgYHRydWVgIGJ5IGRlZmF1bHRcbiAgICogb24gcGxhdGZvcm1zIHRoYXQgc3VwcG9ydCBHdWFyYW50ZWVkIE1lc3NhZ2luZyBwdWJsaXNoaW5nLlxuICAgKlxuICAgKiBXaGVyZSB0aGUge0BsaW5rIHNvbGFjZS5UcmFuc3BvcnRUeXBlLldTX0JJTkFSWX0gdHJhbnNwb3J0IGlzIHVuYXZhaWxhYmxlLCBzdWNoIGFzIE1pY3Jvc29mdFxuICAgKiBJbnRlcm5ldCBFeHBsb3JlciA5LCB7QGxpbmsgc29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzI2VuYWJsZWR9IGlzIGBmYWxzZWAgYnlcbiAgICogZGVmYXVsdC5cbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uMTAuZ3VhcmFudGVlZE1lc3NhZ2luZ0VuYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAdGFyZ2V0IGJyb3dzZXJcbiAgICovXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYDogR3VhcmFudGVlZCBNZXNzYWdpbmcgaXMgZW5hYmxlZCBieSBkZWZhdWx0IGZvciB0aGUgQVBJLlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb24xMC5ndWFyYW50ZWVkTWVzc2FnaW5nRW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0YXJnZXQgbm9kZVxuICAgKi9cbiAgZ2V0IGd1YXJhbnRlZWRNZXNzYWdpbmdFbmFibGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGBmYWxzZWA6IENvbWV0IEhUVFAgdHJhbnNwb3J0cyBhcmUgZGlzYWJsZWQgZm9yIHRoZSBBUEkuIFRoZSBBUEkgd2lsbCBub3Qgc2VsZWN0IG9yXG4gICAqIGZhbGwgYmFjayB0byBIVFRQIENvbWV0IHRyYW5zcG9ydCBwcm90b2NvbHMsIHdoaWNoIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgb2YgR3VhcmFudGVlZFxuICAgKiBNZXNzYWdpbmcgZmVhdHVyZXMuXG4gICAqXG4gICAqIEBuYW1lIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjEwLmNvbWV0RW5hYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgLyoqXG4gICAqIFJldHVybnMgZmFsc2U6IENvbWV0IEhUVFAgdHJhbnNwb3J0cyBhcmUgbm90IHByZXNlbnQgaW4gTm9kZS5qcy5cbiAgICpcbiAgICogQG5hbWUgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uMTAuY29tZXRFbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICBnZXQgY29tZXRFbmFibGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWA6IHRoZSBBUEkgd2lsbCBlbmNvZGUgdG9waWNzIGZvciBpbnRlcm9wZXJhYmlsaXR5IHdpdGggb3RoZXIgU29sYWNlIE1lc3NhZ2luZ1xuICAgKiBwcm9kdWN0cy4gU29sY2xpZW50SlMgNy54IGNsaWVudHMgbWF5IGZhaWwgdG8gY29ycmVjdGx5IGRlY29kZSB3aGVuIHRvcGljIG5hbWVzIHRoYXQgaW5jbHVkZVxuICAgKiBtdWx0aS1ieXRlIFVURi04IGNvZGUgcG9pbnRzLlxuICAgKlxuICAgKiBAbmFtZSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb24xMC50b3BpY1V0ZjhFbmNvZGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHRvcGljVXRmOEVuY29kZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgZm9yd2FyZEluc3RhbmNlID0gbmV3IFZlcnNpb24xMFByb2ZpbGUoKTtcblxuLyoqXG4gKiBUaGUgY29sbGVjdGlvbiBvZiBwcmVkZWZpbmVkIGZhY3RvcnkgcHJvZmlsZXMgYXZhaWxhYmxlIGZvciBhcHBsaWNhdGlvbiB1c2UuXG4gKlxuICogU2VlIGVhY2ggbWVtYmVyIGZvciBhIGRlc2NyaXB0aW9uIG9mIGl0cyBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzID0ge1xuICBfbGVnYWN5OiAgbGVnYWN5SW5zdGFuY2UsXG4gIF9mb3J3YXJkOiBmb3J3YXJkSW5zdGFuY2UsXG4gIF9kZWZhdWx0OiBsZWdhY3lJbnN0YW5jZSxcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gNyBwcm9maWxlIGZvciBicm93c2Vycy4ge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjd9XG4gICAqXG4gICAqIFRoZSB2ZXJzaW9uIDcgcHJvZmlsZSBjb25maWd1cmVzIEFQSSBkZWZhdWx0cyBmb3IgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIHRoZVxuICAgKiBTb2xjbGllbnRKUyA3LnggQVBJLCBhbmQgYXBwbGljYXRpb25zIHRoYXQgdXNlIGl0LlxuICAgKlxuICAgKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uN31cbiAgICpcbiAgICogQHR5cGUge3NvbGFjZS5GYWN0b3J5UHJvZmlsZX1cbiAgICogQHRhcmdldCBicm93c2VyXG4gICAqL1xuICAvKipcbiAgICogVGhlIHZlcnNpb24gNyBwcm9maWxlIGZvciBOb2RlLkpTLiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uN31cbiAgICpcbiAgICogQSB2ZXJzaW9uIDcgcHJvZmlsZSBjb25maWd1cmVzIEFQSSBkZWZhdWx0cyBmb3IgaW50ZXJvcGVyYWJpbGl0eSB3aXRoIHRoZVxuICAgKiBTb2xjbGllbnRKUyA3LnggQVBJLCBhbmQgYXBwbGljYXRpb25zIHRoYXQgdXNlIGl0LlxuICAgKlxuICAgKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uN31cbiAgICpcbiAgICogQHR5cGUge3NvbGFjZS5GYWN0b3J5UHJvZmlsZX1cbiAgICogQHRhcmdldCBub2RlXG4gICAqL1xuICB2ZXJzaW9uNzogbGVnYWN5SW5zdGFuY2UsXG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIDEwIHByb2ZpbGUgZm9yIGJyb3dzZXJzLlxuICAgKlxuICAgKiBUaGUgdmVyc2lvbiAxMCBwcm9maWxlIGNvbmZpZ3VyZXMgQVBJIGRlZmF1bHRzIGZvciB1c2Ugd2l0aCBHdWFyYW50ZWVkIE1lc3NhZ2luZywgYW5kIG90aGVyXG4gICAqIFNvbGFjZSBNZXNzYWdpbmcgQVBJcy5cbiAgICpcbiAgICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjEwfVxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLkZhY3RvcnlQcm9maWxlfVxuICAgKiBAdGFyZ2V0IGJyb3dzZXJcbiAgICovXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiAxMCBwcm9maWxlIGZvciBOb2RlLkpTLlxuICAgKlxuICAgKiBUaGUgdmVyc2lvbiAxMCBwcm9maWxlIGNvbmZpZ3VyZXMgQVBJIGRlZmF1bHRzIGZvciB1c2Ugd2l0aCBHdWFyYW50ZWVkIE1lc3NhZ2luZywgYW5kIG90aGVyXG4gICAqIFNvbGFjZSBNZXNzYWdpbmcgQVBJcy5cbiAgICpcbiAgICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjEwfVxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLkZhY3RvcnlQcm9maWxlfVxuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIHZlcnNpb24xMDogZm9yd2FyZEluc3RhbmNlLFxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3ZlcnNpb243JzogIHRoaXMudmVyc2lvbjcsXG4gICAgICAndmVyc2lvbjEwJzogdGhpcy52ZXJzaW9uMTAsXG4gICAgfTtcbiAgfSxcblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuRmFjdG9yeVByb2ZpbGUgPSBGYWN0b3J5UHJvZmlsZTtcbm1vZHVsZS5leHBvcnRzLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcyA9IFNvbGNsaWVudEZhY3RvcnlQcm9maWxlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWZhY3RvcnkvbGliL3NvbGNsaWVudC1mYWN0b3J5LXByb2ZpbGVzLmpzIiwiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgQVBJUHJvcGVydGllcyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgQ2hlY2sgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0TG9nTGV2ZWwoKSB7XG4gIC8vIGJyZWFrIGRlcGVuZGVuY3kgbG9vcFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgY29uc3QgeyBMb2dMZXZlbCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuICByZXR1cm4gTG9nTGV2ZWwuSU5GTztcbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9wZXJ0aWVzIHVzZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeX0uXG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBTb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcyBleHRlbmRzIEFQSVByb3BlcnRpZXMge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcyB0byBhcHBseSB0byB0aGlzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c29sYWNlLkxvZ0xldmVsfSBbb3B0aW9ucy5sb2dMZXZlbF0gIGxvZ0xldmVsIChkZWZhdWx0PXtAbGluayBzb2xhY2UuTG9nTGV2ZWwuSU5GT31cbiAgICogQHBhcmFtIHtzb2xhY2UuTG9nSW1wbH0gW29wdGlvbnMubG9nZ2VyXSAgICAgbG9nIGltcGxlbWVudGF0aW9uIChkZWZhdWx0PU5VTEwpXG4gICAqIEBwYXJhbSB7c29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlc30gW29wdGlvbnMucHJvZmlsZV0gSmF2YXNjcmlwdCBwcm9maWxlXG4gICAqICAoZGVmYXVsdD17QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uN30pXG4gICAqIEBtZW1iZXJPZiBTb2xjbGllbnRGYWN0b3J5UHJvcGVydGllc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGxvZ0xldmVsOiBnZXREZWZhdWx0TG9nTGV2ZWwoKSxcbiAgICAgIGxvZ2dlcjogICBudWxsLFxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmYWN0b3J5IHByb2ZpbGUgdG8gdXNlLiBUaGUgZm9sbG93aW5nIGZhY3RvcnkgcHJvZmlsZXMgYXJlIGF2YWlsYWJsZTpcbiAgICogKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uN30sIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgcHJvZmlsZVxuICAgKiAgICAgIGZvciBleGlzdGluZyBzb2xDbGllbnRKUyA3LnggYXBwbGljYXRpb25zXG4gICAqICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudmVyc2lvbjEwfSwgdGhlIHJlY29tbWVuZGVkIHByb2ZpbGVcbiAgICogICAgICBmb3IgbmV3IGFwcGxpY2F0aW9uc1xuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLkZhY3RvcnlQcm9maWxlc31cbiAgICovXG4gIGdldCBwcm9maWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9maWxlO1xuICB9XG4gIHNldCBwcm9maWxlKHByb2ZpbGUpIHtcbiAgICB0aGlzLl9wcm9maWxlID0gcHJvZmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbG9nZ2luZyBsZXZlbCB0byB1c2UgZm9yIGZpbHRlcmluZyBsb2cgZXZlbnRzLiBNZXNzYWdlcyB3aXRoIGEgbGV2ZWwgb2YgbGVzc2VyIGltcG9ydGFuY2VcbiAgICogdGhhbiB0aGlzIHdpbGwgYmUgZmlsdGVyZWQgb3V0IGFuZCBub3QgbG9nZ2VkLlxuICAgKiBAdHlwZSB7c29sYWNlLkxvZ0xldmVsfVxuICAgKi9cbiAgZ2V0IGxvZ0xldmVsKCkge1xuICAgIHJldHVybiBDaGVjay5udW1iZXIodGhpcy5fbG9nTGV2ZWwpID8gdGhpcy5fbG9nTGV2ZWwgOiBnZXREZWZhdWx0TG9nTGV2ZWwoKTtcbiAgfVxuICBzZXQgbG9nTGV2ZWwodmFsKSB7XG4gICAgdGhpcy5fbG9nTGV2ZWwgPSB2YWw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvZ2dpbmcgaW1wbGVtZW50YXRpb24gdG8gdXNlLiBJbiB0aGUgZGVidWcgQVBJLCB0aGUgbG9nIGltcGxlbWVudGF0aW9uIHdpbGwgYmUgY2FsbGVkXG4gICAqIGZvciBldmVyeSBsb2cgc3RhdGVtZW50IG5vdCBmaWx0ZXJlZCBvdXQgYnkgdGhlIGxvZyBsZXZlbC4gSWYgbm8gaW1wbGVtZW50YXRpb24gaXMgc3VwcGxpZWQsXG4gICAqIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCwgd2hpY2ggbG9ncyB0byB0aGUgZ2xvYmFsIGNvbnNvbGUgb2JqZWN0LlxuICAgKiBAdHlwZSB7c29sYWNlLkxvZ0ltcGx9XG4gICAqL1xuICBnZXQgbG9nZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2dnZXIgfHwgbnVsbDtcbiAgfVxuICBzZXQgbG9nZ2VyKHZhbCkge1xuICAgIHRoaXMuX2xvZ2dlciA9IHZhbDtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICAvLyBicmVhayBkZXBlbmRlbmN5IGxvb3BcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICBjb25zdCB7IExvZ0xldmVsIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICdsb2dMZXZlbCc6IExvZ0xldmVsLmRlc2NyaWJlKHRoaXMuX2xvZ0xldmVsKSxcbiAgICAgICdwcm9maWxlJzogIHRoaXMuX3Byb2ZpbGUsXG4gICAgfTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3QodGhpcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXMgPSBTb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWZhY3RvcnkvbGliL3NvbGNsaWVudC1mYWN0b3J5LXByb3BlcnRpZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG5jb25zdCBGbG93T3BlcmF0aW9uID0ge1xuICBDT05ORUNUOiAgICAgICAgICdGbG93T3BlcmF0aW9uX0NPTk5FQ1QnLFxuICBESVNDT05ORUNUOiAgICAgICdGbG93T3BlcmF0aW9uX0RJU0NPTk5FQ1QnLFxuICBTVEFSVDogICAgICAgICAgICdGbG93T3BlcmF0aW9uX1NUQVJUJyxcbiAgU1RPUDogICAgICAgICAgICAnRmxvd09wZXJhdGlvbl9TVE9QJyxcbiAgRElTUE9TRTogICAgICAgICAnRmxvd09wZXJhdGlvbl9ERVNUUk9ZJyxcbiAgR0VUX1NUQVRTOiAgICAgICAnRmxvd09wZXJhdGlvbl9HRVRfU1RBVFMnLFxuICBSRVNFVF9TVEFUUzogICAgICdGbG93T3BlcmF0aW9uX1JFU0VUX1NUQVRTJyxcbiAgR0VUX1BST1BFUlRJRVM6ICAnRmxvd09wZXJhdGlvbl9HRVRfUFJPUEVSVElFUycsXG4gIEdFVF9ERVNUSU5BVElPTjogJ0Zsb3dPcGVyYXRpb25fR0VUX0RFU1RJTkFUSU9OJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkZsb3dPcGVyYXRpb24gPSBFbnVtLm5ldyhGbG93T3BlcmF0aW9uKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWZsb3cvbGliL2Zsb3ctb3BlcmF0aW9uLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuY29uc3QgUHJpdmF0ZUZsb3dFdmVudE5hbWUgPSB7XG4gIEJJTkRfV0FJVElORzogJ1ByaXZhdGVGbG93RXZlbnROYW1lX2JpbmRXYWl0aW5nJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlByaXZhdGVGbG93RXZlbnROYW1lID0gRW51bS5uZXcoUHJpdmF0ZUZsb3dFdmVudE5hbWUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZmxvdy9saWIvcHJpdmF0ZS1mbG93LWV2ZW50LW5hbWVzLmpzIiwiY29uc3QgU3RhdGVMaWIgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5jb25zdCB7IEZzbU9iamVjdCB9ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcbmNvbnN0IHsgSXRlcmF0b3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcblxuY29uc3QgeyBtYWtlSXRlcmF0b3IgfSA9IEl0ZXJhdG9yO1xuXG4vKipcbiAqIFJlYWN0IHRvIGFuIGV2ZW50LlxuICogQGNhbGxiYWNrIFN0YXRlQ29udGV4dC5yZWFjdGlvbkNhbGxiYWNrXG4gKiBAcGFyYW0ge0ZzbUV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcmVhY3QgdG8uXG4gKiBAcmV0dXJucyB7U3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0fSBPbmUgb2YgdGhlIG1hbnkgcG9zc2libGVcbiAqICAgICAgcmVhY3Rpb24gcmVzdWx0cyB0aGF0IGNhbiBiZSBjcmVhdGVkIGJ5IG9uZSBvZiB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAgICAgICAgICAtIHtAbGluayBTdGF0ZUNvbnRleHQjdHJhbnNpdGlvblRvfVxuICogICAgICAgICAgLSB7QGxpbmsgRnNtU3RhdGUjaW50ZXJuYWxUcmFuc2l0aW9ufVxuICogICAgICAgICAgLSB7QGxpbmsgRnNtU3RhdGUjZXh0ZXJuYWxUcmFuc2l0aW9uVG99XG4gKiAgICAgICAgICAtIHtAbGluayBGc21TdGF0ZSN0ZXJtaW5hdGV9XG4gKiAgICAgICAgICAtIHtAbGluayBGc21TdGF0ZSNldmVudFVuaGFuZGxlZH1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGhpcyBhYnN0cmFjdCBjbGFzcyBjYW4gaG9zdCBvbmUgb3IgbW9yZSBzdGF0ZXMuICBDb25jcmV0ZSBleGFtcGxlcyB3b3VsZFxuICogYmUgYSBzdGF0ZSwgd2hpY2ggY2FuIGhvc3Qgb25lIG9yIG1vcmUgaW5uZXIgc3RhdGVzLCBvciBhIHN0YXRlIG1hY2hpbmUsXG4gKiB3aGljaCB3b3VsZCB0eXBpY2FsbHkgaGF2ZSBtdWx0aXBsZSB0b3AtbGV2ZWwgc3RhdGVzLiAgSXQgYWxzbyBzZXJ2ZXMgYXMgYVxuICogY29udGV4dCBpbiB3aGljaCB0cmFuc2l0aW9ucyBjYW4gb2NjdXIuXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0ZUNvbnRleHQgZXh0ZW5kcyBGc21PYmplY3Qge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIE9iamVjdCBzcGVjaWZpZXIgdXNlZCB0byBpbXBsZW1lbnQgdGhlIG5hbWVkIHBhcmFtZXRlclxuICAgKiAgaWRpb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLm5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRleHQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIoc3BlYyk7XG4gICAgdGhpcy5pbXBsID0gdGhpcy5pbXBsIHx8IHt9O1xuICAgIHRoaXMuaW1wbC5sb2dQYWRkaW5nID0gJyc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhdGUtbWFjaGluZSB0aGF0IGhvc3RzIHRoaXMgc3RhdGUgY29udGV4dC5cbiAgICogQHJldHVybnMge1N0YXRlTWFjaGluZX0gVGhlIEZTTSB0aGF0IGhvc3RzIHRoaXMgY29udGV4dC5cbiAgICovXG4gIGdldFN0YXRlTWFjaGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXBsLmFuY2VzdG9yTGlzdFswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbml0aWFsIHJlYWN0aW9uIGZvciB0aGUgc3RhdGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtTdGF0ZUNvbnRleHQucmVhY3Rpb25DYWxsYmFja30gZnVuYyBUaGUgcmVhY3Rpb24gY2FsbGJhY2sgdG8gYmVcbiAgICogICAgICBjYWxsZWQgYWZ0ZXIgdGhlIHN0YXRlIGlzIGVudGVyZWQgYXMgdGhlIGRlZXBlc3Qgc3RhdGUgb2YgYVxuICAgKiAgICAgIHRyYW5zaXRpb24sIG9yIGZvciBhIHN0YXRlIG1hY2hpbmUgd2hlbiBpdCBpcyBzdGFydGVkLlxuICAgKiBAcmV0dXJucyB7U3RhdGVDb250ZXh0fSBUaGUgb2JqZWN0IHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZCBvblxuICAgKi9cbiAgaW5pdGlhbChmdW5jKSB7XG4gICAgaWYgKHRoaXMuaW1wbC5pbml0aWFsUmVhY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nKGBSZXBsYWNpbmcgJHt0aGlzfSBpbml0aWFsUmVhY3Rpb24gJHt0aGlzLmltcGwuaW5pdGlhbFJlYWN0aW9ufSB3aXRoICR7ZnVuY31gKTtcbiAgICB9XG4gICAgdGhpcy5pbXBsLmluaXRpYWxSZWFjdGlvbiA9IGZ1bmMuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgZm9yICdsb2NhbCcgdHJhbnNpdGlvbnMuICBIb3dldmVyLCB3ZSBleHRlbmQgdGhlIGZvcm1hbFxuICAgKiBkZWZpbml0aW9uIG9mIGxvY2FsIHRyYW5zaXRpb25zIGhlcmUuICBUaGUgZm9ybWFsIGRlZmluaXRpb24gaXMgdGhhdFxuICAgKiB0aGUgZGVzdCBzdGF0ZSBpcyB3aXRoaW4gdGhlIHNyYyBzdGF0ZSwgYW5kIHRoZSBzcmMgc3RhdGUgaXMgbm90XG4gICAqIGV4aXRlZC4gIFdlIGV4dGVuZCB0aGlzIGRlZmluaXRpb24gdG8gaW5jbHVkZSBzdGF0ZXMgd2hlcmUgdGhlIHNyY1xuICAgKiBzdGF0ZSBpcyB3aXRoaW4gZGVzdC4gSW4gdGhpcyBjYXNlLCBhIGxvY2FsIHRyYW5zaXRpb24gbWVhbnMgdGhhdCBkZXN0XG4gICAqIHdpbGwgbm90IGJlIGV4aXRlZCBhbmQgZW50ZXJlZCBhbmQgdGhlIHRyYW5zaXRpb24gd2lsbCBvY2N1ciBpbiB0aGVcbiAgICogY29udGV4dCBvZiBkZXN0IGJlZm9yZSBleGVjdXRpbmcgZGVzdCdzIGluaXRpYWwgdHJhbnNpdGlvbi4gIE5vdGUgdGhhdFxuICAgKiB0aGlzIGRlZmluaXRpb24gb2YgbG9jYWwgdHJhbnNpdGlvbiBtYXRjaGVzIHRoYXQgb2ZcbiAgICoge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VNTF9zdGF0ZV9tYWNoaW5lI0xvY2FsX3ZlcnN1c19leHRlcm5hbF90cmFuc2l0aW9uc3xXaWtpcGVkaWF9LlxuICAgKiBCdXQgaXQgZG9lcyBub3QgbWF0Y2ggZmlndXJlIDE0LjM0IG9yIHNlY3Rpb24gMTQuNS4xMiBvZiB0aGVcbiAgICoge0BsaW5rIGh0dHA6Ly93d3cub21nLm9yZy9zcGVjL1VNTC8yLjUvUERGL3xGb3JtYWwgVU1MIFNwZWNpZmljYXRpb24gdjIuNX0uXG4gICAqIE5ldmVydGhlbGVzcywgaXQgZG9lcyBzZWVtIGhlbHBmdWwgdG8gYmUgYWJsZSB0byBleHByZXNzIGEgdHJhbnNpdGlvblxuICAgKiB0aGF0IGRvZXMgbGVhdmUgdGhlIGRlc3RpbmF0aW9uIHN0YXRlIHZzLiBhIHRyYW5zaXRpb24gdGhhdCBkb2VzIG5vdC5cbiAgICpcbiAgICogSWYgbmVpdGhlciB0aGUgc291cmNlIG5vciB0aGUgZGVzdCBzdGF0ZXMgYXJlIHdpdGhpbiB0aGUgb3RoZXIsIHRoZVxuICAgKiBiZWhhdmlvdXIgaXMgdGhlIHNhbWUgYXMgYW4gZXh0ZXJuYWwgdHJhbnNpdGlvbiAtLSBzcmMgaXMgYWx3YXlzIGV4aXRlZFxuICAgKiBhbmQgZGVzdCBpcyBhbHdheXMgZW50ZXJlZC5cbiAgICpcbiAgICogVGhpcyBpcyBpbmNsdWRlZCBpbiB0aGUgU3RhdGVDb250ZXh0IGluc3RlYWQgb2Ygd2l0aGluIHRoZSBTdGF0ZSBpdHNlbGZcbiAgICogc2luY2UgdGhpcyBjYW4gYmUgdXNlZCBieSB0aGUgaW5pdGlhbCByZWFjdGlvbiBmb3IgYSBzdGF0ZSBtYWNoaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by5cbiAgICogQHBhcmFtIHtTdGF0ZUNvbnRleHQuYWN0aW9uQ2FsbGJhY2t9IFthY3Rpb25dIE9wdGlvbmFsIFRoZSBhY3Rpb24gdG8gcGVyZm9ybSBhc1xuICAgKiAgICAgIHBhcnQgb2YgdGhlIHRyYW5zaXRpb24sIGlmIGRlc2lyZWQuXG4gICAqIEByZXR1cm5zIHtTdGF0ZUNvbnRleHQuUmVhY3Rpb25SZXN1bHR9IHRoZSByZXN1bHQgb2JqZWN0IHVzZWRcbiAgICogICAgICBpbnRlcm5hbGx5IGZvciBmdXJ0aGVyIHByb2Nlc3Npbmcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgdHJhbnNpdGlvblRvKHN0YXRlLCBhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdCh7XG4gICAgICBjYWxsZXI6ICAgIHRoaXMsXG4gICAgICBkZXN0U3RhdGU6IHN0YXRlLFxuICAgICAgYWN0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdGVybWluYXRlIHRoZSBGU00uXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0LmFjdGlvbkNhbGxiYWNrfSBhY3Rpb24gQW4gb3B0aW9uYWwgYWN0aW9uIHRvXG4gICAqICAgICAgdGFrZSB3aXRoaW4gdGhlIEZTTSBjb250ZXh0IGFmdGVyIGFsbCBzdGF0ZXMgaGF2ZSBiZWVuIGV4aXRlZC5cbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gVGhlIHJlYWN0aW9uIHJlc3VsdCBmb3IgdGhlIHRlcm1pbmF0aW9uLlxuICAgKi9cbiAgdGVybWluYXRlKGFjdGlvbikge1xuICAgIHJldHVybiBuZXcgU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0KHtcbiAgICAgIGNhbGxlcjogICAgdGhpcyxcbiAgICAgIGRlc3RTdGF0ZTogdGhpcy5nZXRTdGF0ZU1hY2hpbmUoKS5nZXRGaW5hbFN0YXRlKCksXG4gICAgICBhY3Rpb24sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBjYWxsYmFjayB0byBleGVjdXRlIGFuIGFjdGlvbiBhcyBwYXJ0IG9mIGEgdHJhbnNpdGlvbiBpbiB0aGVcbiAgICogYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICpcbiAgICogVG8gYmUgdXNlZCBvbmx5IGJ5IHRoZSBGU00gaW5mcmFzdHJ1Y3R1cmUgb3IgdW5pdCB0ZXN0cy5cbiAgICpcbiAgICogQGNhbGxiYWNrIFN0YXRlQ29udGV4dC5hY3Rpb25DYWxsYmFja1xuICAgKiBAcGFyYW0ge1N0YXRlQ29udGV4dH0gY29udGV4dCBUaGUgY29udGV4dCB3aXRoaW4gd2hpY2ggdGhlIGFjdGlvbiBpc1xuICAgKiAgICAgIGV4ZWN1dGVkLiAgV2hlbiB0aGUgYWN0aXZlIHN0YXRlIGNoYW5nZXMsIHRoaXMgaXMgZG9uZSBhZnRlclxuICAgKiAgICAgIHN0YXRlcyBhcmUgZXhpdGVkIGFuZCBiZWZvcmUgc3RhdGVzIGFyZSBlbnRlcmVkLiAgSXQgaXMgdGhlXG4gICAqICAgICAgZGVlcGVzdCBjb250ZXh0IHRoYXQgY29udGFpbnMgdGhlIGxhc3QgZXhpdGVkIGFuZCBmaXJzdCBlbnRlcmVkXG4gICAqICAgICAgc3RhdGUgYXMgcGFydCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICogQHBhcmFtIHtGc21FdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0YXRlQ29udGV4dD59IFRoZSBjb250ZXh0J3MgYW5jZXN0b3IgbGlzdC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0QW5jZXN0b3JMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmltcGwuYW5jZXN0b3JMaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBkZWJ1ZyBsb2cgd2l0aCBhcHByb3ByaWF0ZSBwYWRkaW5nIGZvciB0aGUgY29udGV4dC4gIFRoZSBwYWRkaW5nXG4gICAqIGhlbHBzIHRvIHZpc3VhbGl6ZSB0aGUgbGV2ZWwgd2l0aGluIHRoZSBoaWVyYXJjaGljYWwgc3RhdGUgbWFjaGluZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbG9nKC4uLmFyZ3MpIHtcbiAgICBMT0dfVFJBQ0UodGhpcy5pbXBsLmxvZ1BhZGRpbmcsIC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIHRyYW5zaXRpb24gZm9yIHRoZSBjb250ZXh0IG5lZWRzIHRvIGJlIHRha2VuLlxuICAgKiBAcGFyYW0ge0ZzbUV2ZW50fSBbZXZlbnRdIFRoZSBldmVudCBjYXVzaW5nIHRoaXMgdHJhbnNpdGlvbjsgdW5kZWZpbmVkIGZvciB0aGVcbiAgICogICAgICBGU00ncyBpbml0aWFsIHRyYW5zaXRpb24uXG4gICAqIEByZXR1cm5zIHtTdGF0ZUNvbnRleHQuUmVhY3Rpb25SZXN1bHR9IHRoZSByZXN1bHQgdG8gYmUgcHJvY2Vzc2VkIGJ5XG4gICAqICAgICAgdGhlIEZTTSBpbmZyYXN0cnVjdHVyZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgb25Jbml0aWFsKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmICh0aGlzLmltcGwuaW5pdGlhbFJlYWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZyhgSW5pdGlhbDogZm9yICR7dGhpc31gKTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaW1wbC5pbml0aWFsUmVhY3Rpb24oZXZlbnQpO1xuICAgICAgaWYgKHJlc3VsdC5leHRlcm5hbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluaXRpYWwgcmVhY3Rpb24gZm9yICR7dGhpc30gcmV0dXJuZWQgZXh0ZXJuYWwgdHJhbnNpdGlvbnNgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIChTdGF0ZUxpYi5TdGF0ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgaW5pdGlhbCByZWFjdGlvbiBmb3IgJHt0aGlzfWApO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGluaXRpYWwgcmVhY3Rpb24sIHRoZW4gd2UganVzdCBlbnRlciB0aGlzIHN0YXRlLlxuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgYSBtYWxmb3JtZWQgRlNNIGlmIHRoZXJlIGFyZSBpbm5lciBzdGF0ZXMgYW5kXG4gICAgLy8gdGhpcyBzdGF0ZSBoYXMgbm8gaW5pdGlhbCByZWFjdGlvbi4gIFdlIHdvbid0IHBvbGljZSB0aGlzIHNpbmNlIGl0XG4gICAgLy8gaXNuJ3QgZWFzaWx5IGRvbmUgd2l0aCB0aGUgZGF0YSB3ZSBhcmUgb3RoZXJ3aXNlIG1haW50YWluaW5nICh3ZSBvbmx5XG4gICAgLy8ga25vdyBhYm91dCBwYXJlbnQgc3RhdGVzLCBub3QgY2hpbGRyZW4pLCBhbmQgc3VjaCBhIHByb2JsZW0gd291bGQgYmVcbiAgICAvLyBlYXNpbHkgY2F1Z2h0IGJ5IHRlc3Rpbmcgb2YgdGhlIEZTTS5cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8odGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYSByZWFjdGlvbiBmdW5jdGlvbiBoYXMgYmVlbiBjYWxsZWQsIHRoaXMgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZVxuICAgKiByZXR1cm5lZCB7QGxpbmsgU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0fS5cbiAgICogQHBhcmFtIHtTdGF0ZUNvbnRleHQuUmVhY3Rpb25SZXN1bHR9IHJlc3VsdCBUaGUgcmVzdWx0IG9mIGEgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSB7RnNtRXZlbnR8dW5kZWZpbmVkfSBlIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgcmVhY3Rpb247XG4gICAqICAgICAgdW5kZWZpbmVkIGlmIHRoaXMgd2FzIGR1ZSB0byB0aGUgaW5pdGlhbCByZWFjdGlvbi5cbiAgICogQHJldHVybnMge1N0YXRlfSBUaGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBGU00gYWZ0ZXIgdGhlIFJlYWN0aW9uUmVzdWx0IHdhc1xuICAgKiAgICAgIHByb2Nlc3NlZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvY2Vzc1JlYWN0aW9uUmVzdWx0KHJlc3VsdCwgZSkge1xuICAgIGxldCBjdXJDb250ZXh0ID0gdGhpcztcblxuICAgIGlmICghcmVzdWx0LmRlc3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdFN0YXRlSXRlciA9IHRoaXMubG93ZXN0Q29tbW9uQW5jZXN0b3IocmVzdWx0KTtcblxuICAgIC8vIGV4aXQgc3RhdGVzIHVudGlsIHdlIGdldCB0byB0aGUgTENBXG4gICAgd2hpbGUgKGN1ckNvbnRleHQgIT09IGRlc3RTdGF0ZUl0ZXIuZGVyZWYoKSkge1xuICAgICAgY3VyQ29udGV4dC5vbkV4aXQoKTtcbiAgICAgIGN1ckNvbnRleHQgPSBjdXJDb250ZXh0LmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zaXRpb25cbiAgICBpZiAocmVzdWx0LmFjdGlvbikge1xuICAgICAgcmVzdWx0LmFjdGlvbihjdXJDb250ZXh0LCBlKTtcbiAgICB9XG5cbiAgICBjdXJDb250ZXh0LmxvZyhgQWN0aW9uOiB0cmFuc2l0aW9uIHRvICR7cmVzdWx0LmRlc3RTdGF0ZX0gaW4gY29udGV4dCAke2N1ckNvbnRleHR9YCk7XG5cbiAgICAvLyBTdGFydCBieSBpbmNyZW1lbnRpbmcgdGhlIGl0ZXJhdG9yIHNvIHdlIGRvbid0IGVudGVyIHRoZVxuICAgIC8vIGNvbnRleHQsIHdoaWNoIHdlIGFyZSBhbHJlYWR5IGluLiAgVGhlbiBlbnRlciByZW1haW5pbmcgc3RhdGVzXG4gICAgLy8gaW4gdGhlIGxpc3QuXG4gICAgZm9yIChkZXN0U3RhdGVJdGVyLmluY3IoKTsgIWRlc3RTdGF0ZUl0ZXIuZW5kKCk7IGRlc3RTdGF0ZUl0ZXIuaW5jcigpKSB7XG4gICAgICBjdXJDb250ZXh0ID0gZGVzdFN0YXRlSXRlci5kZXJlZigpO1xuICAgICAgY3VyQ29udGV4dC5vbkVudHJ5KCk7XG4gICAgfVxuXG4gICAgLy8gZXhlY3V0ZSB0aGUgaW5pdGlhbCB0cmFuc2l0aW9uIGluIHRoZSBkZXN0U3RhdGUuXG4gICAgY29uc3QgZGVzdEluaXRpYWwgPSBjdXJDb250ZXh0Lm9uSW5pdGlhbChlKTtcbiAgICBpZiAoZGVzdEluaXRpYWwuZGVzdFN0YXRlICE9PSBjdXJDb250ZXh0KSB7XG4gICAgICByZXR1cm4gY3VyQ29udGV4dC5wcm9jZXNzUmVhY3Rpb25SZXN1bHQoZGVzdEluaXRpYWwsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyQ29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiByZWFjdGlvblJlc3VsdCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGl0ZXJhdG9yIHRvIHRoZVxuICAgKiBjb250ZXh0IGluIHdoaWNoIHRvIHByb2Nlc3MgYSB0cmFuc2l0aW9uIGZyb20gJ3NlbGYnIHRvXG4gICAqICdyZWFjdGlvblJlc3VsdC5kZXN0U3RhdGUnLiAgQWR2YW5jaW5nIHRoZSBpdGVyYXRvciBwcm92aWRlcyB0aGUgc3RhdGVzXG4gICAqIHRoYXQgbmVlZCB0byBiZSBlbnRlcmVkIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGlzIHByb2Nlc3NlZC5cbiAgICogQHBhcmFtIHtSZWFjdGlvblJlc3VsdH0gcmVhY3Rpb25SZXN1bHQgQW4gb2JqZWN0IGNyZWF0ZWQgd2l0aCBvbmUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aW9uIHJlc3VsdCBtZXRob2RzIGRlZmluZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyIGEgc3RhdGUgY29udGV4dCBvciBhIHN0YXRlLlxuICAgKiBAcmV0dXJucyB7SXRlcmF0b3J9IFRoZSBpdGVyYXRvciB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGVcbiAgICogY29udGV4dCBpbiB3aGljaCB0byBleGVjdXRlIHRoZSB0cmFuc2FjdGlvbiwgYW5kIHN1YnNlcXVlbnQgZWxlbWVudHMgYXJlXG4gICAqIHRvIGJlIGVudGVyZWQgYWZ0ZXIgZXhlY3V0aW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgbG93ZXN0Q29tbW9uQW5jZXN0b3IocmVhY3Rpb25SZXN1bHQpIHtcbiAgICBjb25zdCBhbmNlc3Rvckxpc3QgPSB0aGlzLmltcGwuYW5jZXN0b3JMaXN0O1xuICAgIGNvbnN0IGRlc3RBbmNlc3Rvckxpc3QgPSByZWFjdGlvblJlc3VsdC5kZXN0U3RhdGUuZ2V0QW5jZXN0b3JMaXN0KCk7XG4gICAgbGV0IGk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHN0YXRlcyBiZWxvbmcgdG8gdGhlIHNhbWUgc3RhdGUgbWFjaGluZVxuICAgIGlmIChhbmNlc3Rvckxpc3RbMF0gIT09IGRlc3RBbmNlc3Rvckxpc3RbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29tbW9uIGFuY2VzdG9yIGJldHdlZW4gKCR7dGhpc30gaW4gJHthbmNlc3Rvckxpc3RbMF19KSBhbmQgKCR7cmVhY3Rpb25SZXN1bHQuZGVzdFN0YXRlfSBpbiAke2Rlc3RBbmNlc3Rvckxpc3RbMF19KWApO1xuICAgIH1cblxuICAgIC8vIE9wdGltaXplIGNhc2Ugd2hlcmUgdGhlIHR3byBzdGF0ZXMgYXJlIHRoZSBzYW1lLiAgVGhpcyB3b3VsZCBiZSB0aGVcbiAgICAvLyBjYXNlIGZvciBpbnRlcm5hbCBhbmQgc2VsZi10cmFuc2l0aW9ucy5cbiAgICBpZiAodGhpcyA9PT0gcmVhY3Rpb25SZXN1bHQuZGVzdFN0YXRlKSB7XG4gICAgICBpID0gYW5jZXN0b3JMaXN0Lmxlbmd0aDtcbiAgICAgIGlmIChyZWFjdGlvblJlc3VsdC5leHRlcm5hbCkge1xuICAgICAgICAvLyBzZWxmLXRyYW5zaXRpb24sIG11c3QgZXhpdCB0aGVuIHJlLWVudGVyIHN0YXRlLiAgVGhlcmVmb3JlLFxuICAgICAgICAvLyB0aGUgY29udGV4dCBpcyBvdXIgcGFyZW50LlxuICAgICAgICAtLWk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBhbmNlc3Rvckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yTGlzdFtpXSAhPT0gZGVzdEFuY2VzdG9yTGlzdFtpXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIG9uZSBzdGF0ZSBpcyB3aXRoaW4gdGhlIG90aGVyIHN0YXRlLlxuICAgICAgaWYgKChpID09PSBhbmNlc3Rvckxpc3QubGVuZ3RoKSB8fCAoaSA9PT0gZGVzdEFuY2VzdG9yTGlzdC5sZW5ndGgpKSB7XG4gICAgICAgIC8vIE9uZSBzdGF0ZSB3aXRoaW4gdGhlIG90aGVyLiBDaGVjayB3aGV0aGVyIHRoaXMgaXMgYSBsb2NhbFxuICAgICAgICAvLyBvciBhbiBleHRlcm5hbCB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAocmVhY3Rpb25SZXN1bHQuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAtLWk7ICAgIC8vIE5lZWQgdG8gZXhpdC9yZS1lbnRlciB0aGUgb3V0ZXJtb3N0IHN0YXRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIZXJlICdpJyBwb2ludHMgdG8gdGhlIGZpcnN0IHN0YXRlIHRvIGJlIGVudGVyZWQgYWZ0ZXIgZXhlY3V0aW5nIHRoZVxuICAgIC8vIHRyYW5zaXRpb24uICBXZSBtYWtlIHRoZSBpdGVyYXRvciB3aXRoICdpLTEnIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAvLyBpcyB0aGUgY29udGV4dCB3aXRoaW4gd2hpY2ggdG8gZXhlY3V0ZSB0aGUgdHJhbnNpdGlvbi5cbiAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKGRlc3RBbmNlc3Rvckxpc3QsIGkgLSAxKTtcbiAgfVxuXG4gIHNldExvZ1BhZGRpbmcocGFkZGluZykge1xuICAgIHRoaXMuaW1wbC5sb2dQYWRkaW5nID0gcGFkZGluZztcbiAgfVxufVxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgUmVhY3Rpb25SZXN1bHQgaXMgc3VpdGFibGUgYXMgYSByZXR1cm4gdmFsdWUgZnJvbSBhIHJlYWN0aW9uIGZ1bmN0aW9uXG4gKiBvciBhbiBpbml0aWFsIHJlYWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0ID0gY2xhc3Mge1xuICAvKipcbiAgICogVGhlIFJlYWN0aW9uUmVzdWx0IGNvbnN0cnVjdG9yIHNob3VsZCBuZXZlciBiZSBpbnZva2VkIGJ5IHVzZXJzIG9mIHRoZVxuICAgKiBpbmZyYXN0cnVjdHVyZS4gSXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSB2YXJpb3VzIHB1YmxpYyBtZXRob2RzIG9mXG4gICAqIFN0YXRlQ29udGV4dCBvciBTdGF0ZSwgd2hpY2ggcmV0dXJuIGEgUmVhY3Rpb25SZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIERlZmluZWQgYWNjb3JkaW5nIHRvIG1lbWJlcnMgZGVzY3JpYmVkIGJlbG93IGZvclxuICAgKiAgICAgIGV2ZW50cyB0aGF0IGFyZSBoYW5kbGVkIGJ5IHRoZSByZWFjdGlvbiBmdW5jdGlvbjsgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiAgICAgIGV2ZW50IHdhcyBub3QgaGFuZGxlZCBieSB0aGUgcmVhY3Rpb24gZnVuY3Rpb24uICBGb3IgaW5pdGlhbFxuICAgKiAgICAgIHJlYWN0aW9ucywgc3BlYyBtdXN0IE5PVCBiZSB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0fSBzcGVjLmNhbGxlciBUaGUgc3RhdGUgY29udGV4dCBmcm9tIHdoaWNoXG4gICAqICAgICAge1N0YXRlQ29udGV4dC5SZWFjdGlvblJlc3VsdH0gaXMgYmVpbmcgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSB7U3RhdGV9IHNwZWMuZGVzdFN0YXRlIFRoZSBkZXN0aW5hdGlvbiBzdGF0ZSB0b1xuICAgKiAgICAgIHRyYW5zaXRpb24gdG8uXG4gICAqIEBwYXJhbSB7U3RhdGVDb250ZXh0LmFjdGlvbkNhbGxiYWNrfSBbc3BlYy5hY3Rpb25dIFRoZSBmdW5jdGlvbiB0byBjYWxsIGluXG4gICAqICAgICAgdGhlIHRyYW5zaXRpb24gY29udGV4dCBhZnRlciB0aGUgYXBwcm9wcmlhdGUgc3RhdGVzIGhhdmUgYmVlblxuICAgKiAgICAgIGV4aXRlZCwgaWYgZGVzaXJlZDsgdW5kZWZpbmVkIGlmIG5vIGFjdGlvbiBpcyB0byBiZSBwZXJmb3JtZWQgYXMgYVxuICAgKiAgICAgIHJlc3VsdCBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBzcGVjLmV4dGVybmFsIFRydWUgaWYgdGhlIHRyYW5zaXRpb24gaXMgYW4gZXh0ZXJuYWxcbiAgICogICAgICB0cmFuc2l0aW9uOyBmYWxzZSBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBpZiAoIXNwZWMgfHwgIXNwZWMuY2FsbGVyIHx8ICEoc3BlYy5jYWxsZXIgaW5zdGFuY2VvZiBTdGF0ZUNvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWMuY2FsbGVyIGlzIHJlcXVpcmVkIHRvIGJlIGEgU3RhdGVDb250ZXh0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFzcGVjLmNhbGxlci5nZXRTdGF0ZU1hY2hpbmUoKS5pc1J1bm5pbmcoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdGlvblJlc3VsdCBvYmplY3RzIGNhbiBvbmx5IGJlIGNyZWF0ZWQgd2hpbGUgcHJvY2Vzc2luZyBldmVudHMnKTtcbiAgICB9XG4gICAgaWYgKHNwZWMuZGVzdFN0YXRlKSB7XG4gICAgICBpZiAoIShzcGVjLmRlc3RTdGF0ZSBpbnN0YW5jZW9mIFN0YXRlTGliLlN0YXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3RTdGF0ZSBtdXN0IGJlIGEgU3RhdGUgb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3BlYy5hY3Rpb24gJiYgKHR5cGVvZiAoc3BlYy5hY3Rpb24pICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FjdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdFN0YXRlID0gc3BlYy5kZXN0U3RhdGU7XG4gICAgICB0aGlzLmFjdGlvbiA9IHNwZWMuYWN0aW9uO1xuICAgICAgdGhpcy5leHRlcm5hbCA9IHNwZWMuZXh0ZXJuYWw7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TdGF0ZUNvbnRleHQgPSBTdGF0ZUNvbnRleHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vbGliL3N0YXRlLWNvbnRleHQuanMiLCIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovIC8vIGRlY2xhcmUgcHJvdG90eXBlIHN0dWJzXG5cbi8qKlxuICogQSBsb2dnaW5nIGNhbGxiYWNrLiBJdCBtdXN0IGFjY2VwdCBhbnkgdmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBvZiBhbnkgdHlwZS4gSXQgbXVzdCBub3QgdGhyb3cuXG4gKlxuICogQGNhbGxiYWNrXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIHNvbGFjZS5Mb2dJbXBsLmxvZ2dpbmdDYWxsYmFja1xuICogQHBhcmFtIHsuLi4qfSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gbG9nLiBUeXBpY2FsbHkgdGhpcyBpcyBhIG1peHR1cmUgb2Ygc3RyaW5ncyBhbmRcbiAqICBvYmplY3RzIHRvIGJlIGluc3BlY3RlZC4gQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gbWlnaHQgY2FsbCAudG9TdHJpbmcoKSBvbiBlYWNoXG4gKiAgYXJndW1lbnQuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBiaW5kaW5nIHRvIGEgbG9nIGltcGxlbWVudGF0aW9uLiBBcHBsaWNhdGlvbnMgdGhhdCBuZWVkIHRvXG4gKiBjb250cm9sIEFQSSBsb2dnaW5nIG11c3QgY29uc3RydWN0IGEgTG9nSW1wbFxuICogaW5zdGFuY2UsIGEgbG9nIGltcGxlbWVudGF0aW9uIHRoYXQgY2FuIGJlIHNldCBpblxuICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcyNsb2dnZXJ9LlxuICogVGhlIGJpbmRpbmcgd2lsbCBjYWxsIHRoZSBzdXBwbGllZCBsb2cgbWV0aG9kcyB3aXRoIHRoZVxuICogcGFyYW1ldGVycyBzdXBwbGllZCB0byBlYWNoLlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBMb2dJbXBsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c29sYWNlLkxvZ0ltcGwubG9nZ2luZ0NhbGxiYWNrfSB0cmFjZSBDYWxsYmFjayBmb3Ige0BsaW5rIHNvbGFjZS5Mb2dMZXZlbC5UUkFDRX0gbG9ncy5cbiAgICogQHBhcmFtIHtzb2xhY2UuTG9nSW1wbC5sb2dnaW5nQ2FsbGJhY2t9IGRlYnVnIENhbGxiYWNrIGZvciB7QGxpbmsgc29sYWNlLkxvZ0xldmVsLkRFQlVHfSBsb2dzLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5Mb2dJbXBsLmxvZ2dpbmdDYWxsYmFja30gaW5mbyBDYWxsYmFjayBmb3Ige0BsaW5rIHNvbGFjZS5Mb2dMZXZlbC5JTkZPfSBsb2dzLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5Mb2dJbXBsLmxvZ2dpbmdDYWxsYmFja30gd2FybiBDYWxsYmFjayBmb3Ige0BsaW5rIHNvbGFjZS5Mb2dMZXZlbC5XQVJOfSBsb2dzLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5Mb2dJbXBsLmxvZ2dpbmdDYWxsYmFja30gZXJyb3IgQ2FsbGJhY2sgZm9yIHtAbGluayBzb2xhY2UuTG9nTGV2ZWwuRVJST1J9IGxvZ3MuXG4gICAqIEBwYXJhbSB7c29sYWNlLkxvZ0ltcGwubG9nZ2luZ0NhbGxiYWNrfSBmYXRhbCBDYWxsYmFjayBmb3Ige0BsaW5rIHNvbGFjZS5Mb2dMZXZlbC5GQVRBTH0gbG9ncy5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0cmFjZSwgZGVidWcsIGluZm8sIHdhcm4sIGVycm9yLCBmYXRhbCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgdHJhY2UsXG4gICAgICBkZWJ1ZyxcbiAgICAgIGluZm8sXG4gICAgICB3YXJuLFxuICAgICAgZXJyb3IsXG4gICAgICBmYXRhbCxcbiAgICB9KTtcbiAgfVxuXG4gIHRyYWNlKCkge31cbiAgZGVidWcoKSB7fVxuICBpbmZvKCkge31cbiAgd2FybigpIHt9XG4gIGVycm9yKCkge31cbiAgZmF0YWwoKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Mb2dJbXBsID0gTG9nSW1wbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWxvZy9saWIvbG9nLWltcGwuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsb2cgbGV2ZWwgZW51bWVyYXRpb24uXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBMb2dMZXZlbCA9IHtcbiAgLyoqXG4gICAqIEZhdGFsLiBSc2VydmVkIGZvciB1bnJlY292ZXJhYmxlIGVycm9ycy5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEZBVEFMOiAwLFxuICAvKipcbiAgICogRXJyb3IuIEFuIGludGVybmFsIGVycm9yIHRvIHRoZSBBUEkgb3IgU29sYWNlIE1lc3NhZ2UgUm91dGVyLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgRVJST1I6IDEsXG4gIC8qKlxuICAgKiBXYXJuLiBBbiBleHRlcm5hbCBlcnJvciB3aGljaCBtYXkgYmUgY2F1c2VkIGJ5IHRoZSBhcHBsaWNhdGlvbiBwYXNzaW5nIGludmFsaWRcbiAgICogYXJndW1lbnRzIG9yIG9iamVjdHMgdG8gdGhlIEFQSS4gT2Z0ZW4gYWNjb21wYW5pZWQgYnkgYW4gdGhyb3duIGV4Y2VwdGlvbi5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIFdBUk46ICAyLFxuICAvKipcbiAgICogSW5mby4gQW4gdW5leHBlY3RlZCBldmVudCBvciBvY2N1cnJlbmNlIHRoYXQgZG9lcyBub3QgYWZmZWN0IHRoZSBzYW5lXG4gICAqIG9wZXJhdGlvbiBvZiB0aGUgU0RLIG9yIGFwcGxpY2F0aW9uLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgSU5GTzogIDMsXG4gIC8qKlxuICAgKiBEZWJ1Zy4gVGhlIGhpZ2hlc3QgKGxlYXN0KSBsZXZlbCBvZiBkZWJ1ZyBsb2dzLiBEZWJ1ZyBsb2dzIHByb3ZpZGUgYW4gb3ZlcnZpZXcgb2ZcbiAgICogdGhlIEFQSSBvcGVyYXRpb24uXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBERUJVRzogNCxcbiAgLyoqXG4gICAqIFRyYWNlLiBUaGUgbG93ZWVzdCAobW9zdCB2ZXJib3NlKSBsZXZlbCBvZiBkZWJ1ZyBsb2dzLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgVFJBQ0U6IDUsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Mb2dMZXZlbCA9IEVudW0ubmV3KExvZ0xldmVsKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWxvZy9saWIvbG9nLWxldmVscy5qcyIsImNvbnN0IHsgQ29uc3VtZXJGbG93cyB9ID0gcmVxdWlyZSgnLi9saWIvY29uc3VtZXItZmxvd3MnKTtcbmNvbnN0IHsgQ29uc3VtZXJGU01FdmVudCB9ID0gcmVxdWlyZSgnLi9saWIvY29uc3VtZXItZnNtLWV2ZW50Jyk7XG5jb25zdCB7IENvbnN1bWVyRlNNRXZlbnROYW1lcyB9ID0gcmVxdWlyZSgnLi9saWIvY29uc3VtZXItZnNtLWV2ZW50LW5hbWVzJyk7XG5jb25zdCB7IE1lc3NhZ2VDb25zdW1lciB9ID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1jb25zdW1lcicpO1xuY29uc3QgeyBNZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGUgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtY29uc3VtZXItYWNrbm93bGVkZ2UtbW9kZXMnKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL2xpYi9tZXNzYWdlLWNvbnN1bWVyLWV2ZW50LW5hbWVzJyk7XG5jb25zdCB7IE1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2UtY29uc3VtZXItcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5Db25zdW1lckZsb3dzID0gQ29uc3VtZXJGbG93cztcbm1vZHVsZS5leHBvcnRzLkNvbnN1bWVyRlNNRXZlbnQgPSBDb25zdW1lckZTTUV2ZW50O1xubW9kdWxlLmV4cG9ydHMuQ29uc3VtZXJGU01FdmVudE5hbWVzID0gQ29uc3VtZXJGU01FdmVudE5hbWVzO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUNvbnN1bWVyID0gTWVzc2FnZUNvbnN1bWVyO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlID0gTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lID0gTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lO1xubW9kdWxlLmV4cG9ydHMuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyA9IE1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2FwaS5qcyIsImNvbnN0IFF1ZXVlTGliID0gcmVxdWlyZSgnc29sY2xpZW50LXF1ZXVlJyk7XG5jb25zdCB7IEFQSVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IENoZWNrIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItYWNrbm93bGVkZ2UtbW9kZXMnKTtcbmNvbnN0IHsgVG9waWMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuXG5jb25zdCBERUZBVUxUUyA9IHtcbiAgcXVldWVEZXNjcmlwdG9yOiAgICAgICAgICAgdW5kZWZpbmVkLFxuICBxdWV1ZVByb3BlcnRpZXM6ICAgICAgICAgICB1bmRlZmluZWQsXG4gIGNvbm5lY3RUaW1lb3V0SW5Nc2VjczogICAgIDEwMDAwLFxuICBjb25uZWN0QXR0ZW1wdHM6ICAgICAgICAgICAzLFxuICB0b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHNlbGVjdG9yOiB1bmRlZmluZWQsXG4gIGFja25vd2xlZGdlTW9kZTogICAgICAgICAgIE1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZS5BVVRPLFxuICBhY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzOiAxMDAwLFxuICBhY2tub3dsZWRnZVRocmVzaG9sZDogICAgICA2MCxcbiAgYWN0aXZlSW5kaWNhdGlvbkVuYWJsZWQ6ICAgZmFsc2UsXG4gIG5vTG9jYWw6ICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICB3aW5kb3dTaXplOiAgICAgICAgICAgICAgICAyNTUsXG59O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIERlZmluZXMgdGhlIHByb3BlcnRpZXMgZm9yIGEge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9LlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyBleHRlbmRzIEFQSVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoREVGQVVMVFMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIHF1ZXVlIGZyb20gd2hpY2ggdG8gY29uc3VtZS5cbiAgICogICogRm9yIGR1cmFibGUgcXVldWVzIGFuZCBkdXJhYmxlIHRvcGljIGVuZHBvaW50cywgdGhpcyBtdXN0IGJlIGFcbiAgICogICAge0BsaW5rIHNvbGFjZS5RdWV1ZURlc2NyaXB0b3J9LlxuICAgKiAgKiBXaGVuIGFuIHtAbGluayBzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3J9IGlzIHVzZWQsIHRoZSBuYW1lIGlzIGdlbmVyYXRlZCB3aGVuXG4gICAqICAgIHRoZSB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lcn0gaXMgY29ubmVjdGVkLiBUaGUgZ2VuZXJhdGVkIGRlc2NyaXB0b3IgY2FuIGJlIHF1ZXJpZWRcbiAgICogICAgZnJvbSB0aGUgY29uc3VtZXIgYWZ0ZXIgaXQgaGFzIHN1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgYnkgY2FsbGluZ1xuICAgKiAgICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lciNnZXRRdWV1ZURlc2NyaXB0b3J9LlxuICAgKiBAdHlwZSB7c29sYWNlLlF1ZXVlRGVzY3JpcHRvcn1cbiAgICovXG4gIGdldCBxdWV1ZURlc2NyaXB0b3IoKSB7XG4gICAgcmV0dXJuIENoZWNrLnNvbWV0aGluZyh0aGlzLl9xdWV1ZURlc2NyaXB0b3IpXG4gICAgICA/IHRoaXMuX3F1ZXVlRGVzY3JpcHRvclxuICAgICAgOiBERUZBVUxUUy5xdWV1ZURlc2NyaXB0b3I7XG4gIH1cbiAgc2V0IHF1ZXVlRGVzY3JpcHRvcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFF1ZXVlTGliLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yKSB7XG4gICAgICB0aGlzLl9xdWV1ZURlc2NyaXB0b3IgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9xdWV1ZURlc2NyaXB0b3IgPSB2YWx1ZS5uYW1lXG4gICAgICAgID8gbmV3IFF1ZXVlTGliLlF1ZXVlRGVzY3JpcHRvcih2YWx1ZSlcbiAgICAgICAgOiBuZXcgUXVldWVMaWIuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3IodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZURlc2NyaXB0b3IgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcHJvcGVydGllcyBvZiB0aGUgcmVtb3RlIHF1ZXVlLlxuICAgKiAgKiBGb3IgdGVtcG9yYXJ5IHF1ZXVlcyBhbmQgdGVtcG9yYXJ5IHRvcGljIGVuZHBvaW50cywgdGhlc2UgcHJvcGVydGllcyBkZWZpbmUgdGhlIHF1ZXVlIHRoYXRcbiAgICogICAgaXMgY3JlYXRlZC5cbiAgICogICogRm9yIGR1cmFibGUgcXVldWVzLCB0aGVzZSBtdXN0IGJlIHVuc2V0IG9uIGNvbnN1bWVyIGNyZWF0aW9uLiBUaGUgdmFsdWVzIHdpbGwgYmUgcG9wdWxhdGVkXG4gICAqICAgIGFmdGVyIHRoZSBxdWV1ZSBpcyBjb25uZWN0ZWQgYW5kIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FsbGluZ1xuICAgKiAgICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lci4jZ2V0UXVldWVQcm9wZXJ0aWVzfS5cbiAgICogQHR5cGUge3NvbGFjZS5RdWV1ZVByb3BlcnRpZXN9XG4gICAqL1xuICBnZXQgcXVldWVQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fcXVldWVQcm9wZXJ0aWVzKVxuICAgICAgPyB0aGlzLl9xdWV1ZVByb3BlcnRpZXNcbiAgICAgIDogREVGQVVMVFMucXVldWVQcm9wZXJ0aWVzO1xuICB9XG4gIHNldCBxdWV1ZVByb3BlcnRpZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3F1ZXVlUHJvcGVydGllcyA9IG5ldyBRdWV1ZUxpYi5RdWV1ZVByb3BlcnRpZXModmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZVByb3BlcnRpZXMgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0gUHJvcGVydGllcyBjb250cm9sbGluZyBjb25uZWN0aW9uIG9mIHRoZSBjb25zdW1lciAtLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBUaGUgYmluZCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB3aGVuIGNyZWF0aW5nIGEgY29ubmVjdGlvbiB0byB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyLlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgPj0gNTAuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDEwMDAwXG4gICAqL1xuICBnZXQgY29ubmVjdFRpbWVvdXRJbk1zZWNzKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fYmluZFRpbWVvdXRJbk1zZWNzKVxuICAgICAgPyB0aGlzLl9iaW5kVGltZW91dEluTXNlY3NcbiAgICAgIDogREVGQVVMVFMuY29ubmVjdFRpbWVvdXRJbk1zZWNzO1xuICB9XG4gIHNldCBjb25uZWN0VGltZW91dEluTXNlY3ModmFsdWUpIHtcbiAgICB0aGlzLl9iaW5kVGltZW91dEluTXNlY3MgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBiaW5kIGF0dGVtcHRzIHdoZW4gY3JlYXRpbmcgYSBjb25uZWN0aW9uIHRvIHRoZVxuICAgKiBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyA+PSAxLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzXG4gICAqL1xuICBnZXQgY29ubmVjdEF0dGVtcHRzKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fY29ubmVjdEF0dGVtcHRzKVxuICAgICAgPyB0aGlzLl9jb25uZWN0QXR0ZW1wdHNcbiAgICAgIDogREVGQVVMVFMuY29ubmVjdEF0dGVtcHRzO1xuICB9XG4gIHNldCBjb25uZWN0QXR0ZW1wdHModmFsKSB7XG4gICAgdGhpcy5fY29ubmVjdEF0dGVtcHRzID0gdmFsO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tIFByb3BlcnRpZXMgYXBwbGllZCB0byB0aGUgcXVldWUgd2hlbiBjb25uZWN0aW5nIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVGhpcyBtdXN0IGJlIHVuZGVmaW5lZCBpZlxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMjcXVldWVEZXNjcmlwdG9yI3R5cGV9IGlzIG5vdFxuICAgKiB7c29sYWNlLlF1ZXVlVHlwZS5UT1BJQ19FTkRQT0lOVH0uXG4gICAqXG4gICAqIElmIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyNxdWV1ZURlc2NyaXB0b3IjZHVyYWJsZX0gaXNcbiAgICogZmFsc2UsIHRoaXMgbWF5IGJlIGxlZnQgdW5kZWZpbmVkIHRvIGdlbmVyYXRlIHRoZSB0b3BpYyBlbmRwb2ludCdzXG4gICAqIGRlc3RpbmF0aW9uLiBXaGVuIGdlbmVyYXRlZCwgdGhlIGRlc3RpbmF0aW9uIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gICAqIHRoZSB7c29sYWNlLk1lc3NhZ2VDb25zdW1lcn0gYWZ0ZXIgaXQgaXMgY29ubmVjdGVkIGJ5IGNhbGxpbmdcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIjZ2V0RGVzdGluYXRpb259LlxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLkRlc3RpbmF0aW9ufVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGdldCB0b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uO1xuICB9XG4gIHNldCB0b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uKHZhbCkge1xuICAgIC8vIEF2b2lkIGluc3RhbmNlb2YgY2hlY2sgZmFpbGluZyBvbiBOb2RlIDQ/XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl90b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uID0gVG9waWMuY3JlYXRlRnJvbU5hbWUodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbiA9IHZhbDtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLSBQcm9wZXJ0aWVzIGNvbnRyb2xsaW5nIGFuIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gdG8gYSBxdWV1ZSAtLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBUaGUgQXBwbGljYXRpb24gQWNrbm93bGVkZ2VtZW50IG1vZGUgZm9yIHRoZSBNZXNzYWdlIENvbnN1bWVyLlxuICAgKlxuICAgKiBXaGVuIHRoZSBhY2tub3dsZWRnZW1lbnQgbW9kZSBpcyB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZS5DTElFTlR9LFxuICAgKiBhIG1lc3NhZ2UgaXMgQXBwbGljYXRpb24gQWNrbm93bGVkZ2VkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGNhbGxzXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZSNhY2tub3dsZWRnZX0gb24gdGhhdCBtZXNzYWdlLlxuICAgKlxuICAgKiBXaGVuIHRoZSBhY2tub3dsZWRnZSBtb2RlIGlzIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlLkFVVE99LCBhIG1lc3NhZ2UgaXNcbiAgICogQXBwbGljYXRpb24gQWNrbm93bGVkZ2VkIGJ5IHRoZSBBUEkgYWZ0ZXIgYWxsXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI2V2ZW50Ok1FU1NBR0V9XG4gICAqIGxpc3RlbmVycyBhcmUgY2FsbGVkIGFuZCBub25lIHRocm93IGFuIGV4Y2VwdGlvbi4gSWYgYSBtZXNzYWdlIGhhbmRsZXIgdGhyb3dzLCB0aGUgbWVzc2FnZVxuICAgKiBjYW4gc3RpbGwgYmUgYWNrbm93bGVkZ2VkIGJ5IGNhbGxpbmcge0BsaW5rIHNvbGFjZS5NZXNzYWdlI2Fja25vd2xlZGdlfSwgYnV0IHRoaXMgd291bGQgbm90IGJlXG4gICAqIGEgcmVjb21tZW5kZWQgcHJhY3RpY2UuXG4gICAqXG4gICAqIFdoZW4gcmVjZWl2ZWQgbWVzc2FnZXMgYXJlIEFwcGxpY2F0aW9uIEFja25vd2xlZGdlZCB0aGV5IGFyZSByZW1vdmVkIGZyb20gdGhlIEd1YXJhbnRlZWRcbiAgICogTWVzc2FnZSBzdG9yYWdlIG9uIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuIE1lc3NhZ2UgQ29uc3VtZXIgQXBwbGljYXRpb24gQWNrbm93bGVkZ2VkLFxuICAgKiA8Yj5vbmx5PC9iPiByZW1vdmUgbWVzc2FnZXMgZnJvbSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyLlxuICAgKlxuICAgKiBJbiBwYXJ0aWN1bGFyLCB3aXRoaG9sZGluZyBNZXNzYWdlIENvbnN1bWVyIEFja25vd2xlZGdlbW50cyBkb2VzIG5vdCBzdG9wXG4gICAqIG1lc3NhZ2UgZGVsaXZlcnkuIEZvciBNZXNzYWdlIENvbnN1bWVyIGZsb3cgY29udHJvbCAoYWthIHRyYW5zcG9ydCBhY2tub3dsZWRnZW1lZW50KSBzZWVcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIuc3RvcH0ve0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIuc3RhcnR9LiBNZXNzYWdlIENvbnN1bWVyXG4gICAqIGZsb3cgY29udHJvbCBtYXkgYWxzbyBiZSBpbWxwZW1lbnRlZCBieSByZW1vdmluZyB0aGVcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjZXZlbnQ6TUVTU0FHRX0gbGlzdGVuZXIuXG4gICAqXG4gICAqIEZsb3cgY29udHJvbCBhbmQgdHJhbnNwb3J0IGFja25vd2xlZGdlbWVudHMgY2hhcmFjdGVyaXN0aWNzIGFyZSBkZWZpbmVkIGJ5XG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcy5hY2tub3dsZWRnZVRocmVzaG9sZH0gYW5kXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcy5hY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzfVxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZX1cbiAgICogQGRlZmF1bHQgc29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZS5BVVRPXG4gICAqL1xuICBnZXQgYWNrbm93bGVkZ2VNb2RlKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fYWNrbm93bGVkZ2VNb2RlKVxuICAgICAgPyB0aGlzLl9hY2tub3dsZWRnZU1vZGVcbiAgICAgIDogREVGQVVMVFMuYWNrbm93bGVkZ2VNb2RlO1xuICB9XG4gIHNldCBhY2tub3dsZWRnZU1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9hY2tub3dsZWRnZU1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNwb3J0IGFja25vd2xlZGdlbWVudCB0aW1lb3V0IGZvciBndWFyYW50ZWVkIG1lc3NhZ2luZy5cbiAgICogV2hlbiB0aGUge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzLmFja25vd2xlZGdlVGhyZXNob2xkfSBpcyBub3QgZXhjZWVkZWQsXG4gICAqIGFja25vd2xlZGdlbWVudHMgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgcm91dGVyIGF0IGludGVydmFscyBub3QgbGVzcyB0aGFuXG4gICAqIHRoaXMgdmFsdWUuXG4gICAqICAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgMjAgPD0gYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcyA8PSAxNTAwLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMDAwXG4gICAqL1xuICBnZXQgYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcygpIHtcbiAgICByZXR1cm4gQ2hlY2suc29tZXRoaW5nKHRoaXMuX2Fja25vd2xlZGdlVGltZW91dEluTXNlY3MpXG4gICAgICA/IHRoaXMuX2Fja25vd2xlZGdlVGltZW91dEluTXNlY3NcbiAgICAgIDogREVGQVVMVFMuYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcztcbiAgfVxuICBzZXQgYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2Vjcyh2YWwpIHtcbiAgICB0aGlzLl9hY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzID0gdmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0aHJlc2hvbGQgZm9yIHNlbmRpbmcgYW4gYWNrbm93bGVkZ2VtZW50LCBhcyBhIHBlcmNlbnRhZ2UuXG4gICAqIFRoZSBBUEkgc2VuZHMgYSB0cmFuc3BvcnQgYWNrbm93bGVkZ21lbnQgZXZlcnlcbiAgICogTiBtZXNzYWdlcyB3aGVyZSBOIGlzIGNhbGN1bGF0ZWQgYXMgdGhpcyBwZXJjZW50YWdlIG9mIHRoZSB0cmFuc3BvcnRcbiAgICogd2luZG93IHNpemUgaWYgdGhlIGVuZHBvaW50J3MgbWF4LWRlbGl2ZXJlZC11bmFja2VkLW1zZ3MtcGVyLWZsb3dcbiAgICogc2V0dGluZyBhdCBiaW5kIHRpbWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0cmFuc3BvcnRcbiAgICogd2luZG93IHNpemUuIE90aGVyd2lzZSwgTiBpcyBjYWxjdWxhdGVkIGFzIHRoaXMgcGVyY2VudGFnZSBvZiB0aGVcbiAgICogZW5kcG9pbnQncyBtYXgtZGVsaXZlcmVkLXVuYWNrZWQtbXNncy1wZXItZmxvdyBzZXR0aW5nIGF0IGJpbmQgdGltZS5cbiAgICogKiBUaGUgdmFsaWQgcmFuZ2UgaXMgMSA8PSBhY2tub3dsZWRnZVRocmVzaG9sZCA8PSA3NS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgNjBcbiAgICovXG4gIGdldCBhY2tub3dsZWRnZVRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gQ2hlY2suc29tZXRoaW5nKHRoaXMuX2Fja25vd2xlZGdlVGhyZXNob2xkKVxuICAgICAgPyB0aGlzLl9hY2tub3dsZWRnZVRocmVzaG9sZFxuICAgICAgOiBERUZBVUxUUy5hY2tub3dsZWRnZVRocmVzaG9sZDtcbiAgfVxuICBzZXQgYWNrbm93bGVkZ2VUaHJlc2hvbGQodmFsdWUpIHtcbiAgICB0aGlzLl9hY2tub3dsZWRnZVRocmVzaG9sZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBXaGVuIGVuYWJsZWQsIGEgR3VhcmFudGVlZCBNZXNzYWdpbmcgQ29uc3VtZXIgcmVxdWVzdHMgQWN0aXZlIGFuZCBJbmFjdGl2ZVxuICAgKiBldmVudHMgZnJvbSB0aGUgcm91dGVyIGFuZCBlbWl0cyB0aGVtIHRvIGludGVyZXN0ZWQgbGlzdGVuZXJzLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQHNlZSB7c29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50LkFDVElWRX1cbiAgICogQHNlZSB7c29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50LklOQUNUSVZFfVxuICAgKi9cbiAgZ2V0IGFjdGl2ZUluZGljYXRpb25FbmFibGVkKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fYWN0aXZlSW5kaWNhdGlvbkVuYWJsZWQpXG4gICAgICA/IHRoaXMuX2FjdGl2ZUluZGljYXRpb25FbmFibGVkXG4gICAgICA6IERFRkFVTFRTLmFjdGl2ZUluZGljYXRpb25FbmFibGVkO1xuICB9XG4gIHNldCBhY3RpdmVJbmRpY2F0aW9uRW5hYmxlZChuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2FjdGl2ZUluZGljYXRpb25FbmFibGVkID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBlbmFibGVkLCBhIEd1YXJhbnRlZWQgTWVzc2FnaW5nIENvbnN1bWVyIGRvZXMgbm90IHJlY2VpdmUgbWVzc2FnZXMgcHVibGlzaGVkXG4gICAqIGluIHRoZSBzYW1lIFNlc3Npb24sIGV2ZW4gaWYgdGhlIGVuZHBvaW50IGNvbnRhaW5zIGEgc3Vic2NyaXB0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHVibGlzaGVkXG4gICAqIG1lc3NhZ2UuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0IG5vTG9jYWwoKSB7XG4gICAgcmV0dXJuIENoZWNrLnNvbWV0aGluZyh0aGlzLl9ub0xvY2FsKVxuICAgICAgPyB0aGlzLl9ub0xvY2FsXG4gICAgICA6IERFRkFVTFRTLm5vTG9jYWw7XG4gIH1cbiAgc2V0IG5vTG9jYWwobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9ub0xvY2FsID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdpbmRvdyBzaXplIGZvciBHdWFyYW50ZWVkIE1lc3NhZ2UgZGVsaXZlcnkuICBUaGlzIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtZXNzYWdlcyB0aGF0XG4gICAqIHdpbGwgYmUgcHJlZmV0Y2hlZCBmcm9tIHRoZSBTb2xhY2UgTWVzc2FnaW5nIFJvdXRlciBhbmQgcXVldWVkIGludGVybmFsbHkgYnkgdGhlIEFQSSB3aGlsZVxuICAgKiB3YWl0aW5nIGZvciB0aGUgYXBwbGljYXRpb24gdG8gYWNjZXB0IGRlbGl2ZXJ5IG9mIHRoZSBtZXNzYWdlcy5cbiAgICogICAqIFRoZSB2YWxpZCByYW5nZSBpcyAxIDw9IHdpbmRvd1NpemUgPD0gMjU1LlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAyNTVcbiAgICovXG4gIGdldCB3aW5kb3dTaXplKCkge1xuICAgIHJldHVybiBDaGVjay5zb21ldGhpbmcodGhpcy5fd2luZG93U2l6ZSlcbiAgICAgID8gdGhpcy5fd2luZG93U2l6ZSA6XG4gICAgICBERUZBVUxUUy53aW5kb3dTaXplO1xuICB9XG4gIHNldCB3aW5kb3dTaXplKHZhbCkge1xuICAgIHRoaXMuX3dpbmRvd1NpemUgPSB2YWw7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzID0gTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL21lc3NhZ2UtY29uc3VtZXItcHJvcGVydGllcy5qcyIsImNvbnN0IFNNRkxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zbWYnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IENhcGFiaWxpdHlUeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2Vzc2lvbicpO1xuY29uc3QgeyBDb25zdW1lckZTTSB9ID0gcmVxdWlyZSgnLi9jb25zdW1lci1mc20nKTtcbmNvbnN0IHsgQ29uc3VtZXJGU01FdmVudCB9ID0gcmVxdWlyZSgnLi9jb25zdW1lci1mc20tZXZlbnQnKTtcbmNvbnN0IHsgQ29uc3VtZXJGU01FdmVudE5hbWVzIH0gPSByZXF1aXJlKCcuL2NvbnN1bWVyLWZzbS1ldmVudC1uYW1lcycpO1xuY29uc3QgeyBGbG93LCBGbG93T3BlcmF0aW9uIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZmxvdycpO1xuY29uc3QgeyBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1jb25zdW1lci1ldmVudC1uYW1lcycpO1xuY29uc3QgeyBNZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItcHJvcGVydGllcycpO1xuY29uc3QgeyBNZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzVmFsaWRhdG9yIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItcHJvcGVydGllcy12YWxpZGF0b3InKTtcbmNvbnN0IHsgT3BlcmF0aW9uRXJyb3IsIEVycm9yU3ViY29kZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IFF1ZXVlLCBUb3BpYyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWRlc3RpbmF0aW9uJyk7XG5jb25zdCB7IFF1ZXVlQWNjZXNzVHlwZSwgUXVldWVQZXJtaXNzaW9ucywgUXVldWVEaXNjYXJkQmVoYXZpb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1xdWV1ZScpO1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgcmV0dXJuIGBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuJHtNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuZGVzY3JpYmUoZXZlbnROYW1lKX1gO1xufVxuXG5sZXQgbG9jYWxDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGdldENvbnN1bWVyTG9jYWxOYW1lKCkge1xuICByZXR1cm4gYENvbnN1bWVyRlNNICR7bG9jYWxDb3VudGVyKyt9YDtcbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiA8Yj5UaGlzIGNsYXNzIGlzIG5vdCBleHBvc2VkIGZvciBjb25zdHJ1Y3Rpb24gYnkgQVBJIHVzZXJzLjwvYj5cbiAqIEEgTWVzc2FnZSBDb25zdW1lciBpcyBjcmVhdGVkIGJ5IGNhbGxpbmcge0BsaW5rIHNvbGFjZS5TZXNzaW9uI2NyZWF0ZU1lc3NhZ2VDb25zdW1lcn0uXG4gKlxuICogQSBNZXNzYWdlQ29uc3VtZXIgY29udHJvbHMgR3VhcmFudGVlZCBNZXNzYWdlIGRlbGl2ZXJ5IHRvIHRoaXMgY2xpZW50LlxuICpcbiAqIENvbnN1bWVyIGNoYXJhY3RlcmlzdGljcyBhbmQgYmVoYXZpb3IgYXJlIGRlZmluZWQgYnkge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzfS5cbiAqIFRoZSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGJlIHN1cHBsaWVkIGFzIGEgc2ltcGxlIGtleS12YWx1ZSB7T2JqZWN0fS4gVGhlIHF1ZXVlIGRlc2NyaXB0b3IsXG4gKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMjcXVldWVEZXNjcmlwdG9yfSBtdXN0IGJlIHNwZWNpZmllZCB0byBpZGVudGlmeSB0aGVcbiAqIEd1YXJhbnRlZWQgTWVzc2FnZSBRdWV1ZSBvciBHdWFyYW50ZWVkIE1lc3NhZ2UgVG9waWMgRW5kcG9pbnQgb24gdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci5cbiAqXG4gKiBUaGUgTWVzc2FnZUNvbnN1bWVyIG9iamVjdCBpcyBhbiBFdmVudEVtaXR0ZXIsIGFuZCB3aWxsIGVtaXQgZXZlbnRzIHRvIHdoaWNoIHRoZVxuICogYXBwbGljYXRpb24gbWF5IGNob29zZSB0byBzdWJzY3JpYmUsIHN1Y2ggYXMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlclxuICogZ29pbmcgdXAgb3IgZG93bi5cbiAqXG4gKiBJZiBhIHJlZ2lzdGVyZWQgbGlzdGVuZXIgZm9yIGFuIGVtaXR0ZWQgZXZlbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdGhpcyBpcyBjYXVnaHQgYW5kIGVtaXR0ZWQgYXNcbiAqIGFuICdlcnJvcicuXG4gKlxuICogQGZpcmVzIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjQUNUSVZFXG4gKiBAZmlyZXMgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNDT05ORUNUX0ZBSUxFRF9FUlJPUlxuICogQGZpcmVzIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjRElTUE9TRURcbiAqIEBmaXJlcyBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI0RPV05cbiAqIEBmaXJlcyBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI0RPV05fRVJST1JcbiAqIEBmaXJlcyBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI0dNX0RJU0FCTEVEXG4gKiBAZmlyZXMgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNJTkFDVElWRVxuICogQGZpcmVzIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjTUVTU0FHRVxuICogQGZpcmVzIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjVVBcbiAqXG4gKlxuICpcbiAqIEBleHRlbmRzIHNvbGFjZS5GbG93XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNsYXNzIE1lc3NhZ2VDb25zdW1lciBleHRlbmRzIEZsb3cge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgcHJvcGVydGllcywgc2Vzc2lvbkludGVyZmFjZUZhY3RvcnkgfSA9IHt9KSB7XG4gICAgY29uc3QgYXBwbHlQcm9wZXJ0aWVzID0gbmV3IE1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllc1ZhbGlkYXRvci52YWxpZGF0ZShhcHBseVByb3BlcnRpZXMpO1xuICAgIHN1cGVyKGFwcGx5UHJvcGVydGllcywgc2Vzc2lvbkludGVyZmFjZUZhY3RvcnksIHtcbiAgICAgIGRpcmVjdDogTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLk1FU1NBR0UsXG4gICAgICBlbWl0czogIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS52YWx1ZXMsXG4gICAgICBmb3JtYXRFdmVudE5hbWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdXBlckZvcm1hdHRlciA9IHRoaXMubG9nZ2VyLmZvcm1hdHRlcjtcbiAgICB0aGlzLmxvZ2dlci5mb3JtYXR0ZXIgPSAoLi4uYXJncykgPT4gc3VwZXJGb3JtYXR0ZXIoJ1ttZXNzYWdlLWNvbnN1bWVyXScsIC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZzbSA9IHRoaXMuX21ha2VGU00oKTtcblxuICAgIHRoaXMuX29uKE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5BQ1RJVkUsICgpID0+IHRoaXMuX29uRmxvd0FjdGl2ZSh0cnVlKSk7XG4gICAgdGhpcy5fb24oTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLklOQUNUSVZFLCAoKSA9PiB0aGlzLl9vbkZsb3dBY3RpdmUoZmFsc2UpKTtcbiAgICB0aGlzLl9vbihNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuRE9XTl9FUlJPUiwgdGhpcy5fb25GbG93RGlzY29ubmVjdGVkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX29uKE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5VUCwgdGhpcy5fb25GbG93VXAuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fZnNtLnN0YXJ0KCk7IC8vIFN1YnNjcmliZXIgZmxvd3Mgc2VsZi1tYW5hZ2UsIHNvIHRoZXkgc3RhcnQgaW1tZWRpYXRlbHlcbiAgfVxuXG4gIF9tYWtlRlNNKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG5hbWUgPSBgJHtnZXRDb25zdW1lckxvY2FsTmFtZSgpfWA7XG4gICAgcmV0dXJuIG5ldyBDb25zdW1lckZTTSh7XG4gICAgICBuYW1lLFxuICAgICAgY29uc3VtZXI6ICAgICAgICAgdGhpcyxcbiAgICAgIHNlc3Npb25JbnRlcmZhY2U6IHRoaXMuX3Nlc3Npb25JbnRlcmZhY2UsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZ2lucyBkZWxpdmVyeSBvZiBtZXNzYWdlcyB0byB0aGlzIGNvbnN1bWVyLiBUaGlzIG1ldGhvZCBvcGVucyB0aGUgcHJvdG9jb2wgd2luZG93XG4gICAqIHRvIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgc28gZnVydGhlciBtZXNzYWdlcyBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEEgbmV3bHkgY3JlYXRlZCBjb25zdW1lciBpcyBpbiBzdGFydGVkIHN0YXRlLlxuICAgKlxuICAgKiBJZiB0aGUgY29uc3VtZXIgd2FzIGFscmVhZHkgc3RhcnRlZCwgdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAgICpcbiAgICogQSBjb25zdW1lciBpcyBzdG9wcGVkIGJ5IGNhbGxpbmcge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIuc3RvcH1cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBNZXNzYWdlIENvbnN1bWVyIGlzIGRpc3Bvc2VkLlxuICAgKiAgIHN1YmNvZGUgPSB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn1cbiAgICogKiBpZiB0aGUgTWVzc2FnZSBDb25zdW1lciBpcyBkaXNjb25uZWN0ZWQuXG4gICAqICAgc3ViY29kZSA9IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfVxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uQ2hlY2soRmxvd09wZXJhdGlvbi5TVEFSVCk7XG4gICAgdGhpcy5fZnNtLnJlcXVlc3RTdGFydERpc3BhdGNoVXNlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIG1lc3NhZ2VzIGZyb20gYmVpbmcgZGVsaXZlcmVkIHRvIHRoaXMgY29uc3VtZXIgZnJvbSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyLlxuICAgKiBNZXNzYWdlcyBtYXkgY29udGludWUgdG8gYmUgcHJlZmV0Y2hlZCBieSB0aGUgQVBJIGFuZCBxdWV1ZWQgaW50ZXJuYWxseVxuICAgKiB1bnRpbCB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lciNzdGFydH0gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBJZiB0aGUgY29uc3VtZXIgd2FzIGFscmVhZHkgc3RvcHBlZCwgdGhpcyBtZXRob2QgaGFzIG5vIGVmZmVjdC5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBNZXNzYWdlIENvbnN1bWVyIGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogICBzdWJjb2RlID0ge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059XG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuX29wZXJhdGlvbkNoZWNrKEZsb3dPcGVyYXRpb24uU1RPUCk7XG4gICAgdGhpcy5fZnNtLnJlcXVlc3RTdG9wRGlzcGF0Y2hVc2VyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdGhlIGNvbnN1bWVyIGltbWVkaWF0ZWx5LiBUaGUgYXBwbGljYXRpb24gc2hvdWxkIGFkZCBldmVudCBsaXN0ZW5lcnMgKHNlZVxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZX0pLiBJZiB0aGVyZSBpcyBubyBsaXN0ZW5lciBhZGRlZCBmb3JcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjZXZlbnQ6TUVTU0FHRX0gdGhlbiB1cCB0byBhIHdpbmRvd1xuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMud2luZG93U2l6ZX0gb2YgbWVzc2FnZXMgY2FuIGJlIHF1ZXVlZCBpbnRlcm5hbGx5LlxuICAgKiB0byB0aGUge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9IGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9XG4gICAqICAqIGlmIGNvbnN1bWVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgcm91dGVyIGZvciB0aGlzIGNsaWVudC5cbiAgICogIHN1YmNvZGUgPSB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn1cbiAgICpcbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKCh0aGlzLl9zZXNzaW9uSW50ZXJmYWNlLmdldENhcGFiaWxpdHkoQ2FwYWJpbGl0eVR5cGUuR1VBUkFOVEVFRF9NRVNTQUdFX0NPTlNVTUUpXG4gICAgICAgICE9PSBudWxsKSAmJlxuICAgICAgICAoIXRoaXMuX3Nlc3Npb25JbnRlcmZhY2UuaXNDYXBhYmxlKENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FKSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignQ29uc3VtZXIgaXMgbm90IHN1cHBvcnRlZCBieSByb3V0ZXIgZm9yIHRoaXMgY2xpZW50JyxcbiAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgc3VwZXIuY29ubmVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc0ZTTUV2ZW50KG5ldyBDb25zdW1lckZTTUV2ZW50KHsgbmFtZTogQ29uc3VtZXJGU01FdmVudE5hbWVzLkZMT1dfT1BFTiB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIGFuIG9yZGVybHkgZGlzY29ubmVjdGlvbiBvZiB0aGUgTWVzc2FnZSBDb25zdW1lci4gVGhlIEFQSSB3aWxsIHNlbmQgYW55IHBlbmRpbmdcbiAgICogY2xpZW50IGFja25vd2xlZGdlbWVudHMgb24gdGhlIE1lc3NhZ2UgQ29uc3VtZXIsIHRoZW4gc2VuZCBhbiB1bmJpbmQgcmVxdWVzdC5cbiAgICogQW55IG1lc3NhZ2VzIHN1YnNlcXVlbnRseVxuICAgKiByZWNlaXZlZCBhcmUgZGlzY2FyZGVkIHNpbGVudGx5LiBXaGVuIHRoZSB1bmJpbmQgbWVzc2FnZSBpcyBhY2tub3dsZWRnZWQsIHRoZSBhcHBsaWNhdGlvblxuICAgKiByZWNlaXZlcyBhIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lI2V2ZW50OkRPV059IGV2ZW50IGlmIGl0IGhhcyBzZXQgYSBsaXN0ZW5lclxuICAgKiBmb3IgdGhhdCBldmVudC5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBNZXNzYWdlIENvbnN1bWVyIGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogICBzdWJjb2RlID0ge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059XG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgQ29uc3VtZXJGU01FdmVudCh7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX0NMT1NFIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHB1Ymxpc2ggbWVzc2FnZXMgdGhhdCB0aGlzIGNvbnN1bWVyXG4gICAqIHdpbGwgcmVjZWl2ZS5cbiAgICogKiBGb3IgdG9waWMgZW5kcG9pbnRzLCB0aGlzIGlzIHRoZSB0b3BpYyB0byB3aGljaCB0aGUgdG9waWMgZW5kcG9pbnQgaXMgc3Vic2NyaWJlZC5cbiAgICogKiBGb3IgcXVldWVzLCB0aGlzIGlzIHRoZSBhc3NvY2lhdGVkIHF1ZXVlIGRlc3RpbmF0aW9uLlxuICAgKlxuICAgKiBUaGUgZGVzdGluYXRpb24gcmV0dXJuZWQgY2FuXG4gICAqIGJlIHVzZWQgdG8gc2V0IHRoZSBSZXBseVRvIGZpZWxkIGluIGEgbWVzc2FnZSwgb3Igb3RoZXJ3aXNlIGNvbW11bmljYXRlZFxuICAgKiB0byBwYXJ0bmVycyB0aGF0IG5lZWQgdG8gc2VuZCBtZXNzYWdlcyB0byB0aGlzIE1lc3NhZ2UgQ29uc3VtZXIuIFRoaXMgaXMgZXNwZWNpYWxseSB1c2VmdWxcbiAgICogZm9yIHRlbXBvcmFyeSBlbmRwb2ludHMgKFF1ZXVlcyBhbmQgVG9waWMgRW5kcG9pbnRzKSwgYXMgdGhlIGRlc3RpbmF0aW9uXG4gICAqIGlzIHVua25vd24gYmVmb3JlIHRoZSBlbmRwb2ludCBpcyBjcmVhdGVkLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHN1Y2NlZWQgYWZ0ZXIge0BsaW5rIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNldmVudDpVUH0gZm9yIHRlbXBvcmFyaWVzXG4gICAqIHdpdGggZ2VuZXJhdGVkIGRlc3RpbmF0aW9ucy5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lcn0gaXMgZGlzY29ubmVjdGVkIGFuZCB0aGUgZGVzdGluYXRpb24gaXMgdGVtcG9yYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c29sYWNlLkRlc3RpbmF0aW9ufSBUaGUgcHVibGlzaGluZyBkZXN0aW5hdGlvbiB0aGF0IGRlbGl2ZXJzIHRvIHRoaXMgY29uc3VtZXIuXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbigpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuX2ZzbS5nZXREZXN0aW5hdGlvbigpO1xuICAgIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIFF1ZXVlKSB7XG4gICAgICByZXR1cm4gbmV3IFF1ZXVlKGRlc3RpbmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb3BpYyhkZXN0aW5hdGlvbik7XG4gIH1cblxuICAvLyBBcHBsaWNhdGlvbiBoYXMgZGlzY29ubmVjdGVkIHRoZSBzZXNzaW9uLCB3ZSBtdXN0IGNvbnRpbnVlIHRvIG9yZGVybHkgc2h1dCBkb3duXG4gIC8vIHVuYmluZGluZyBNZXNzYWdlIENvbnN1bWVycyxcbiAgLy8gYnV0IE1lc3NhZ2UgQ29uc3VtZXJzIHRoYXQgYXJlIHVwIG1lcmVseSB0cmVhdCB0aGlzIGFzIGEgJ2Rvd24nIGV2ZW50IGFuZFxuICAvLyB0cmFuc2l0aW9uIHRvIGF3YWl0aW5nU2Vzc2lvblVwXG4gIF9kaXNjb25uZWN0U2Vzc2lvbigpIHtcbiAgICBzdXBlci5fZGlzY29ubmVjdFNlc3Npb24oKTtcbiAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgQ29uc3VtZXJGU01FdmVudCh7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RJU0NPTk5FQ1QgfSkpO1xuICB9XG5cbiAgX29wZXJhdGlvbkNoZWNrKG9wZXJhdGlvbikge1xuICAgIHN1cGVyLl9vcGVyYXRpb25DaGVjayhvcGVyYXRpb24pO1xuICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICBjYXNlIEZsb3dPcGVyYXRpb24uR0VUX0RFU1RJTkFUSU9OOlxuICAgICAgICBpZiAodGhpcy5faXNEaXNjb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignQ2Fubm90IGdldCBkZXN0aW5hdGlvbiBvZiBhIGRpc2Nvbm5lY3RlZCBmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gbWVzc2FnZUlkIFRoZSBtZXNzYWdlIElEIHRvIGFja1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFwcGxpY2F0aW9uQWNrKG1lc3NhZ2VJZCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfVFJBQ0UoYEFkZGluZyBhcHBsaWNhdGlvbiBhY2sgZm9yICR7bWVzc2FnZUlkfWApO1xuICAgIHRoaXMuX2ZzbS5hcHBsaWNhdGlvbkFjayhtZXNzYWdlSWQpO1xuICB9XG5cbiAgZ2V0RGlzcG9zZWRFdmVudCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgcmV0dXJuIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5ESVNQT1NFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlfSBtZXNzYWdlIFRoZSBkYXRhIG1lc3NhZ2UgdG8gaGFuZGxlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaGFuZGxlRGF0YU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfVFJBQ0UoJ0hhbmRsaW5nIGRhdGEgbWVzc2FnZScpO1xuICAgIG1lc3NhZ2Uuc2V0TWVzc2FnZUNvbnN1bWVyKHRoaXMpO1xuICAgIHRoaXMuX2ZzbS5hY2NlcHRNZXNzYWdlKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge3NvbGFjZS5BZFByb3RvY29sTWVzc2FnZX0gbWVzc2FnZSBUaGUgY29udHJvbCBtZXNzYWdlIHRvIGhhbmRsZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGhhbmRsZVVuY29ycmVsYXRlZENvbnRyb2xNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKCdIYW5kbGluZyB1bmNvcnJlbGF0ZWQgY29udHJvbCBtZXNzYWdlJyk7XG4gICAgY29uc3QgbXNnVHlwZSA9IG1lc3NhZ2UubXNnVHlwZTtcbiAgICBjb25zdCB7IFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSB9ID0gU01GTGliO1xuICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgY2FzZSBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuVU5CSU5EOlxuICAgICAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgQ29uc3VtZXJGU01FdmVudCh7XG4gICAgICAgICAgbmFtZTogQ29uc3VtZXJGU01FdmVudE5hbWVzLkZMT1dfVU5CT1VORCxcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLkZMT1dDSEFOR0VVUERBVEU6XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZTTUV2ZW50KG5ldyBDb25zdW1lckZTTUV2ZW50KHtcbiAgICAgICAgICBuYW1lOiBDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19BQ1RJVkVfSU5ELFxuICAgICAgICB9LCB7XG4gICAgICAgICAgYWN0aXZlOiBtZXNzYWdlLmdldEFjdGl2ZUZsb3coKSxcbiAgICAgICAgfSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIExPR19ERUJVRygnRHJvcHBpbmcgdW5oYW5kbGVkIEFEIGNvbnRyb2wgbWVzc2FnZTogJyxcbiAgICAgICAgICAgICAgICAgIFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZS5kZXNjcmliZShtc2dUeXBlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgY29weSBvZiB0aGUgcHJvcGVydGllcyBmb3IgdGhpcyBNZXNzYWdlQ29uc3VtZXIuXG4gICAqXG4gICAqIElmIHRoZSBvYmplY3Qgd2FzIGNvbnN0cnVjdGVkIHVzaW5nIGFuIHtAbGluayBzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3J9LFxuICAgKiBhbmQgdGhlIHF1ZXVlIGRlc2NyaXB0b3Igd2FzIHN1YnNlcXVlbnRseSBjb25uZWN0ZWQgdG8gYW4gZW5kcG9pbnQsIHRoZVxuICAgKiBgTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllc2AgcmV0dXJuZWQgd2lsbCBpbmNsdWRlIGEge0BsaW5rIHNvbGFjZS5RdWV1ZURlc2NyaXB0b3J9XG4gICAqIHRoYXQgY29udGFpbnMgdGhlIHJlc29sdmVkIG5hbWUuXG4gICAqXG4gICAqIEEgbmV3IGNvcHkgb2YgdGhlIHByb3BlcnRpZXMgb2JqZWN0IGlzIHJldHVybmVkIGVhY2ggdGltZSB0aGlzIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuICAgKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNhbm5vdCBiZSBwb2xsZWQgZm9yIG11dGF0aW9ucyBzdWNoIGFzIHRoZSBvbmUgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXN9IFRoZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9iamVjdC5cbiAgICovXG4gIGdldFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFByb3BlcnRpZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHJvdXRlciBzdGF0ZSBjb250YWluZWQgaW4gdGhlIGNvbnN1bWVyLCBlLmcuIG9uIFZSTiBjaGFuZ2VcbiAgICpcbiAgICogQG1lbWJlcm9mIE1lc3NhZ2VDb25zdW1lclxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uVlJOQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgQ29uc3VtZXJGU01FdmVudCh7XG4gICAgICBuYW1lOiBDb25zdW1lckZTTUV2ZW50TmFtZXMuVklSVFVBTFJPVVRFUl9OQU1FX0NIQU5HRUQsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIHRoZSBNZXNzYWdlQ29uc3VtZXIgaGFzIGNvbm5lY3RlZCB0byBhbiBlbmRwb2ludFxuICAgKiAoe0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjVVB9KSwgYWNjZXNzdHlwZSByZXByZXNlbnRzXG4gICAqICB0aGUgYWNjZXNzIHR5cGUgZm9yIHRoZSBlbmRwb2ludCB0byB3aGljaCB0aGlzIE1lc3NhZ2UgQ29uc3VtZXIgaXMgYm91bmQuXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIuYWNjZXNzVHlwZVxuICAgKiBAdHlwZSB7c29sYWNlLlF1ZXVlQWNjZXNzVHlwZX1cbiAgICovXG4gIGdldCBhY2Nlc3NUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2Nlc3NUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5RdWV1ZUFjY2Vzc1R5cGV9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXQgYWNjZXNzVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMuX2FjY2Vzc1R5cGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjb25zdW1lciBpcyBhY3RpdmUuIElmIGFjdGl2ZSBpbmRpY2F0aW9ucyBmb3IgdGhlIGNvbnN1bWVyIGFyZSBub3RcbiAgICogZW5hYmxlZCwgdGhpcyB3aWxsIHJldHVybiB1bmRlZmluZWQuXG4gICAqIEB0eXBlIHs/Qm9vbGVhbn1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldCBhY3RpdmUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fZW1pdCh2YWx1ZSA/IE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5BQ1RJVkUgOiBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuSU5BQ1RJVkUpO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciB0aGUgTWVzc2FnZUNvbnN1bWVyIGhhcyBjb25uZWN0ZWQgYXMgaW5kaWNhdGVkIGJ5IHRoZSBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNldmVudDpVUH0sIHF1ZXVlRGlzY2FyZEJlaGF2aW9yIHJlcHJlc2VudHNcbiAgICogdGhlIGRpc2NhcmQgYmVoYXZpb3IgZmxhZ3MgZm9yIHRoZSBlbmRwb2ludCB0byB3aGljaCB0aGlzIE1lc3NhZ2UgQ29uc3VtZXIgaXMgYm91bmQuXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucXVldWVEaXNjYXJkQmVoYXZpb3VyXG4gICAqIEB0eXBlIHtzb2xhY2UuUXVldWVEaXNjYXJkQmVoYXZpb3J9XG4gICAqL1xuICBnZXQgcXVldWVEaXNjYXJkQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlRGlzY2FyZEJlaGF2aW9yO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldCBxdWV1ZURpc2NhcmRCZWhhdmlvcih2YWx1ZSkge1xuICAgIHRoaXMuX3F1ZXVlRGlzY2FyZEJlaGF2aW9yID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgdGhlIE1lc3NhZ2VDb25zdW1lciBoYXMgY29ubmVjdGVkIGFzIGluZGljYXRlZCBieSB0aGUgZXZlbnRcbiAgICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUjZXZlbnQ6VVB9XG4gICAqIHJlc3BlY3RzVFRMIGlzIGB0cnVlYCB3aGVuIHRoZSBlbmRwb2ludCByZXNwZWN0cyBUaW1lIFRvIExpdmUgb24gbWVzc2FnZXNcbiAgICogYW5kICdmYWxzZScgb3RoZXJ3aXNlLlxuICAgKiBAbmFtZSBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnJlc3BlY3RzVFRMXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IHJlc3BlY3RzVFRMKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwZWN0c1RUTDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0IHJlc3BlY3RzVFRMKHZhbHVlKSB7XG4gICAgdGhpcy5fcmVzcGVjdHNUVEwgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmbG93IElEIGZvciB0aGlzIGNvbnN1bWVyLiBUaGlzIG51bWJlciB3aWxsIGNoYW5nZSBiZXR3ZWVuIHJlY29ubmVjdHNcbiAgICogYW5kIGlzIHB1cmVseSBpbmZvcm1hdGlvbmFsLlxuICAgKiBAdHlwZSB7TG9uZ31cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZmxvd0lkKCkge1xuICAgIHJldHVybiB0aGlzLl9mbG93SWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7TG9uZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldCBmbG93SWQodmFsdWUpIHtcbiAgICB0aGlzLl9mbG93SWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciB0aGUgTWVzc2FnZUNvbnN1bWVyIGhhcyBjb25uZWN0ZWQgYXMgaW5kaWNhdGVkIGJ5IHRoZSBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSNldmVudDpVUH0sIHRoaXMgcHJvcGVydHkgcmVwcmVzZW50c1xuICAgKiBwZXJtaXNzaW9ucyBncmFudGVkIGJ5IHRoZSByb3V0ZXIgdG8gdGhpcyB1c2VyIG9uIHRoaXMgTWVzc2FnZSBDb25zdW1lclxuICAgKiBAbmFtZSBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnBlcm1pc3Npb25zXG4gICAqIEB0eXBlIHtzb2xhY2UuUXVldWVQZXJtaXNzaW9uc31cbiAgICovXG4gIGdldCBwZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVybWlzc2lvbnMgfHwgMDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXQgcGVybWlzc2lvbnModmFsdWUpIHtcbiAgICB0aGlzLl9wZXJtaXNzaW9ucyA9IHZhbHVlO1xuICB9XG5cbiAgX29uRmxvd0FjdGl2ZShpc0FjdGl2ZSkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoYEZsb3cgKGZsb3dJZCA9ICR7dGhpcy5fZmxvd0lkfSkgYmVjYW1lICR7aXNBY3RpdmUgPyAnYWN0aXZlJyA6ICdpbmFjdGl2ZSd9YCk7XG4gICAgdGhpcy5fYWN0aXZlID0gaXNBY3RpdmU7XG4gIH1cblxuICBfb25GbG93RGlzY29ubmVjdGVkKCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoYCR7dGhpc30gZGlzY29ubmVjdGVkYCk7XG4gIH1cblxuICBfZGlzcG9zZUZTTSgpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKCdEaXNwb3NpbmcgRlNNJyk7XG4gICAgdGhpcy5wcm9jZXNzRlNNRXZlbnQobmV3IENvbnN1bWVyRlNNRXZlbnQoeyBuYW1lOiBDb25zdW1lckZTTUV2ZW50TmFtZXMuRElTUE9TRSB9KSk7XG4gIH1cblxuICBfb25GbG93VXAoKSB7XG4gICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19ERUJVRyhgRmxvdyBpcyB1cDogZmxvd0lkID0gJHt0aGlzLl9mbG93SWR9YCk7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3VwZXJbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSwge1xuICAgICAgJ2Rlc3RpbmF0aW9uJzogICAgICAgICAgdGhpcy5fZGVzdGluYXRpb24sXG4gICAgICAnYWNjZXNzVHlwZSc6ICAgICAgICAgICBRdWV1ZUFjY2Vzc1R5cGUuZGVzY3JpYmUodGhpcy5hY2Nlc3NUeXBlKSxcbiAgICAgICdwZXJtaXNzaW9ucyc6ICAgICAgICAgIFF1ZXVlUGVybWlzc2lvbnMuZGVzY3JpYmUodGhpcy5wZXJtaXNzaW9ucyksXG4gICAgICAncmVzcGVjdHNUVEwnOiAgICAgICAgICB0aGlzLnJlc3BlY3RzVFRMLFxuICAgICAgJ2FjdGl2ZSc6ICAgICAgICAgICAgICAgdGhpcy53YW50Rmxvd0NoYW5nZU5vdGlmeSA/IHRoaXMuYWN0aXZlIDogJyhpbmRpY2F0aW9ucyBkaXNhYmxlZCknLFxuICAgICAgJ3dhbnRGbG93Q2hhbmdlTm90aWZ5JzogdGhpcy53YW50Rmxvd0NoYW5nZU5vdGlmeSxcbiAgICAgICdxdWV1ZURpc2NhcmRCZWhhdmlvcic6IFF1ZXVlRGlzY2FyZEJlaGF2aW9yLmRlc2NyaWJlKHRoaXMucXVldWVEaXNjYXJkQmVoYXZpb3IpLFxuICAgICAgJ21heFdpbmRvd1NpemUnOiAgICAgICAgdGhpcy5fZnNtLm1heFdpbmRvd1NpemUsXG4gICAgfSk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9XG5cbiAgX2lzRGlzY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9mc20uaXNEaXNjb25uZWN0ZWQoKTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VDb25zdW1lciA9IE1lc3NhZ2VDb25zdW1lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL21lc3NhZ2UtY29uc3VtZXIuanMiLCJjb25zdCBTb2xjbGllbnRGYWN0b3J5TGliID0gcmVxdWlyZSgnc29sY2xpZW50LWZhY3RvcnknKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IEFQSVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IENoZWNrIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcbmNvbnN0IHsgTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSB9ID0gcmVxdWlyZSgnLi9tZXNzYWdlLXB1Ymxpc2hlci1hY2tub3dsZWRnZS1tb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC10cmFuc3BvcnQnKTtcblxuZnVuY3Rpb24gZGVmYXVsdEVuYWJsZVB1Ymxpc2hlcigpIHtcbiAgY29uc3QgeyBQcm9maWxlQmluZGluZyB9ID0gU29sY2xpZW50RmFjdG9yeUxpYjtcbiAgY29uc3QgYmluZGluZyA9IFByb2ZpbGVCaW5kaW5nLnZhbHVlO1xuICBjb25zdCBnbG9iYWxseUVuYWJsZWQgPSBiaW5kaW5nLmd1YXJhbnRlZWRNZXNzYWdpbmdFbmFibGVkO1xuICBjb25zdCB3ZWJTb2NrZXRBdmFpbGFibGUgPSBUcmFuc3BvcnRDYXBhYmlsaXRpZXMud2ViLndlYlNvY2tldCgpO1xuICByZXR1cm4gZ2xvYmFsbHlFbmFibGVkICYmIHdlYlNvY2tldEF2YWlsYWJsZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgZW5hYmxlZDogICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuYWJsZVB1Ymxpc2hlcigpLFxuICAgIHdpbmRvd1NpemU6ICAgICAgICAgICAgICAgIDUwLFxuICAgIGFja25vd2xlZGdlVGltZW91dEluTXNlY3M6IDIwMDAsXG4gICAgYWNrbm93bGVkZ2VNb2RlOiAgICAgICAgICAgTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZS5QRVJfTUVTU0FHRSxcbiAgICBjb25uZWN0UmV0cnlDb3VudDogICAgICAgICAzLFxuICAgIGNvbm5lY3RUaW1lb3V0SW5Nc2VjczogICAgIDUwMDAsXG4gIH07XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgY29uZmlndXJhdGlvbiBmb3IgYSBndWFyYW50ZWVkIG1lc3NhZ2UgcHVibGlzaGVyLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgZXh0ZW5kcyBBUElQcm9wZXJ0aWVzIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoZ2V0RGVmYXVsdHMoKSwgb3B0aW9ucyB8fCB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyNlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb24gV2hlbiBlbmFibGVkLCBhIEd1YXJhbnRlZWQgTWVzc2FnaW5nIFB1Ymxpc2hlclxuICAgKiBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgd2hlbiBhIHNlc3Npb24gaXMgY29ubmVjdGVkLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgdmFsdWUgcHJvdmlkZWQgdG9cbiAgICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LmluaXR9LFxuICAgKiBpbiB0aGUgcHJvZmlsZSwge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvcGVydGllcyNwcm9maWxlfSxcbiAgICogaW4gdGhlIGZpZWxkIHtAbGluayBzb2xhY2UuRmFjdG9yeVByb2ZpbGUjZ3VhcmFudGVlZE1lc3NhZ2luZ0VuYWJsZWR9LlxuICAgKi9cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH1cbiAgc2V0IGVuYWJsZWQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9lbmFibGVkID0gbmV3VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyN3aW5kb3dTaXplXG4gICAqIEBkZWZhdWx0IDUwXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiAgTWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkXG4gICAqIHdpdGhvdXQgYWNrbm93bGVkZ21lbnQuXG4gICAqICAqIFRoZSB2YWxpZCByYW5nZSBpcyAxIDw9IHZhbHVlIDw9IDI1NVxuICAgKi9cbiAgZ2V0IHdpbmRvd1NpemUoKSB7XG4gICAgcmV0dXJuIENoZWNrLmRlZmluZWQodGhpcy5fd2luZG93U2l6ZSlcbiAgICAgID8gdGhpcy5fd2luZG93U2l6ZVxuICAgICAgOiBnZXREZWZhdWx0cygpLndpbmRvd1NpemU7XG4gIH1cbiAgc2V0IHdpbmRvd1NpemUobmV3VmFsdWUpIHtcbiAgICB0aGlzLl93aW5kb3dTaXplID0gbmV3VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyNhY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDIwMDBcbiAgICogQGRlc2NyaXB0aW9uICBUaGUgdGltZSB0byB3YWl0IGZvciBhbiBhY2tub3dsZWRnZW1lbnQsXG4gICAqIGluIG1pbGxpc2Vjb25kcywgYmVmb3JlIHJldHJhbnNtaXR0aW5nIHVuYWNrbm93bGVkZ2VkXG4gICAqIG1lc3NhZ2VzLlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgMjAgPD0gdmFsdWUgPD0gNjAwMDAuXG4gICAqL1xuICBnZXQgYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcygpIHtcbiAgICByZXR1cm4gQ2hlY2suZGVmaW5lZCh0aGlzLl9hY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzKVxuICAgICAgPyB0aGlzLl9hY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzXG4gICAgICA6IGdldERlZmF1bHRzKCkuYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcztcbiAgfVxuICBzZXQgYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX2Fja25vd2xlZGdlVGltZW91dEluTXNlY3MgPSBuZXdWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQG5hbWUgc29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzI2Fja25vd2xlZGdlTW9kZVxuICAgKiBAdHlwZSB7c29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGV9XG4gICAqIEBkZWZhdWx0IHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZS5QRVJfTUVTU0FHRX1cbiAgICogQGRlc2NyaXB0aW9uICBUaGUgbWVzc2FnZS1yb3V0ZXIgc2VuZHMgd2luZG93ZWQgYWNrbm93bGVkZ2VtZW50c1xuICAgKiB3aGljaCB0aGUgQVBJIGNvbnZlcnRzIHRvIHBlci1tZXNzYWdlIGFja25vd2xlZGdlbWVudCBieSBkZWZhdWx0LiBJZlxuICAgKiBhY2tub3dsZWRnZU1vZGUgaXMgV2luZG93ZWQsIHRoZW4gdGhlIEFQSSB3aWxsIHNpbXBseSBwYXNzIHRocm91Z2hcbiAgICogdGhlIG1lc3NhZ2Utcm91dGVyIGFja25vd2xlZGdlbWVudHMuXG4gICAqL1xuICBnZXQgYWNrbm93bGVkZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2tub3dsZWRnZU1vZGUgfHwgTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZS5QRVJfTUVTU0FHRTtcbiAgfVxuICBzZXQgYWNrbm93bGVkZ2VNb2RlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fYWNrbm93bGVkZ2VNb2RlID0gbmV3VmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEBuYW1lIHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcyNjb25uZWN0UmV0cnlDb3VudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGEgYmluZCAoYWthIG9wZW4tZmxvdykgcmVxdWVzdFxuICAgKiBiZWZvcmUgZGVjaWRpbmcgdGhlIHRoZSBHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaGVyIGNhbm5vdCBiZSBzdGFydGVkLlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgMCA8PSB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBjb25uZWN0UmV0cnlDb3VudCgpIHtcbiAgICByZXR1cm4gQ2hlY2suZGVmaW5lZCh0aGlzLl9jb25uZWN0UmV0cnlDb3VudClcbiAgICAgID8gdGhpcy5fY29ubmVjdFJldHJ5Q291bnRcbiAgICAgIDogZ2V0RGVmYXVsdHMoKS5jb25uZWN0UmV0cnlDb3VudDtcbiAgfVxuICBzZXQgY29ubmVjdFJldHJ5Q291bnQobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9jb25uZWN0UmV0cnlDb3VudCA9IG5ld1ZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAbmFtZSBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMjY29ubmVjdFRpbWVvdXRJbk1zZWNzXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDUwMDBcbiAgICogQGRlc2NyaXB0aW9uICBUaGUgdGltZSB0byB3YWl0IGZvciBhbiBiaW5kIHJlc3BvbnNlLFxuICAgKiBpbiBtaWxsaXNlY29uZHMsIGJlZm9yZSByZXRyYW5zbWl0dGluZyB0aGUgYmluZCByZXF1ZXN0LlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgNTAgPD0gdmFsdWU8L2xpPlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGNvbm5lY3RUaW1lb3V0SW5Nc2VjcygpIHtcbiAgICByZXR1cm4gQ2hlY2suZGVmaW5lZCh0aGlzLl9jb25uZWN0VGltZW91dEluTXNlY3MpXG4gICAgICA/IHRoaXMuX2Nvbm5lY3RUaW1lb3V0SW5Nc2Vjc1xuICAgICAgOiBnZXREZWZhdWx0cygpLmNvbm5lY3RUaW1lb3V0SW5Nc2VjcztcbiAgfVxuICBzZXQgY29ubmVjdFRpbWVvdXRJbk1zZWNzKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fY29ubmVjdFRpbWVvdXRJbk1zZWNzID0gbmV3VmFsdWU7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuYWJsZWQ6ICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCxcbiAgICAgIHdpbmRvd1NpemU6ICAgICAgICAgICAgICAgIHRoaXMud2luZG93U2l6ZSxcbiAgICAgIGFja25vd2xlZGdlVGltZW91dEluTXNlY3M6IHRoaXMuYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcyxcbiAgICAgIGFja25vd2xlZGdlTW9kZTogICAgICAgICAgIE1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUuZGVzY3JpYmUodGhpcy5hY2tub3dsZWRnZU1vZGUpLFxuICAgICAgY29ubmVjdFJldHJ5Q291bnQ6ICAgICAgICAgdGhpcy5jb25uZWN0UmV0cnlDb3VudCxcbiAgICAgIGNvbm5lY3RUaW1lb3V0SW5Nc2VjczogICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJbk1zZWNzLFxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgPSBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci1wcm9wZXJ0aWVzLmpzIiwiY29uc3QgRGVidWdMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZGVidWcnKTtcbmNvbnN0IE1lc3NhZ2VEdW1wVXRpbExpYiA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kdW1wLXV0aWwnKTtcbmNvbnN0IHsgRGVzdGluYXRpb24gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBMT0dfRVJST1IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTWVzc2FnZUNhY2hlU3RhdHVzIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY2FjaGUtc3RhdHVzJyk7XG5jb25zdCB7IE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtZGVsaXZlcnktbW9kZS10eXBlcycpO1xuY29uc3QgeyBNZXNzYWdlRHVtcEZsYWcgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kdW1wLWZsYWdzJyk7XG5jb25zdCB7IE1lc3NhZ2VVc2VyQ29zVHlwZSB9ID0gcmVxdWlyZSgnLi9tZXNzYWdlLXVzZXItY29zLXR5cGVzJyk7XG5jb25zdCB7IFNEVE1hcENvbnRhaW5lciwgU0RURmllbGRUeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2R0Jyk7XG5jb25zdCB7IFN0cmluZ1V0aWxzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG5cbmNvbnN0IE1lc3NhZ2VEdW1wU3RhbmRhcmRQcm92aWRlciA9IHtcblxuICBmcERlc3RpbmF0aW9uKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICBjb25zdCBkZXN0ID0gbWVzc2FnZS5nZXREZXN0aW5hdGlvbigpO1xuICAgIGlmIChkZXN0ICE9PSBudWxsICYmIGRlc3QgaW5zdGFuY2VvZiBEZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIFsnRGVzdGluYXRpb24nLCB0cnVlLCBkZXN0LnRvU3RyaW5nKCksIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydEZXN0aW5hdGlvbicsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBTZW5kZXJJZChtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgcmV0dXJuIFsnU2VuZGVySWQnLCAobWVzc2FnZS5nZXRTZW5kZXJJZCgpICE9PSB1bmRlZmluZWQgJiYgbWVzc2FnZS5nZXRTZW5kZXJJZCgpICE9PSBudWxsKSwgbWVzc2FnZS5nZXRTZW5kZXJJZCgpLCBudWxsXTtcbiAgfSxcblxuICBmcEFwcG1zZ1R5cGUobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ0FwcE1lc3NhZ2VUeXBlJywgKG1lc3NhZ2UuZ2V0QXBwbGljYXRpb25NZXNzYWdlVHlwZSgpICE9PSB1bmRlZmluZWQgJiYgbWVzc2FnZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKCkgIT09IG51bGwpLFxuICAgICAgbWVzc2FnZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKCksIG51bGxdO1xuICB9LFxuXG4gIGZwQXBwTXNnSWQobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ0FwcE1lc3NhZ2VJRCcsIChtZXNzYWdlLmdldEFwcGxpY2F0aW9uTWVzc2FnZUlkKCkgIT09IHVuZGVmaW5lZCAmJiBtZXNzYWdlLmdldEFwcGxpY2F0aW9uTWVzc2FnZUlkKCkgIT09IG51bGwpLFxuICAgICAgbWVzc2FnZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VJZCgpLCBudWxsXTtcbiAgfSxcblxuICBmcFNlcXVlbmNlTnVtYmVyKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICBjb25zdCBzZXF1ZW5jZU51bSA9IG1lc3NhZ2UuZ2V0U2VxdWVuY2VOdW1iZXIoKTtcbiAgICBpZiAodHlwZW9mIHNlcXVlbmNlTnVtID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFsnU2VxdWVuY2VOdW1iZXInLCB0cnVlLCBzZXF1ZW5jZU51bSwgbnVsbF07XG4gICAgfVxuICAgIHJldHVybiBbJ1NlcXVlbmNlTnVtYmVyJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFRvcGljU2VxdWVuY2VOdW1iZXIobWVzc2FnZS8qLCBmbGFncyAqLykge1xuICAgIGNvbnN0IHRvcGljU2VxTm8gPSBtZXNzYWdlLmdldFRvcGljU2VxdWVuY2VOdW1iZXIoKTtcbiAgICBpZiAoTG9uZy5pc0xvbmcodG9waWNTZXFObykpIHtcbiAgICAgIHJldHVybiBbJ1RvcGljU2VxdWVuY2VOdW1iZXInLCB0cnVlLCB0b3BpY1NlcU5vLnRvU3RyaW5nKCksIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydUb3BpY2VxdWVuY2VOdW1iZXInLCBmYWxzZSwgJycsIG51bGxdO1xuICB9LFxuXG4gIGZwQ29ycmVsYXRpb25JZChtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgcmV0dXJuIFsnQ29ycmVsYXRpb25JZCcsIChtZXNzYWdlLmdldENvcnJlbGF0aW9uSWQoKSAhPT0gdW5kZWZpbmVkICYmIG1lc3NhZ2UuZ2V0Q29ycmVsYXRpb25JZCgpICE9PSBudWxsKSxcbiAgICAgIG1lc3NhZ2UuZ2V0Q29ycmVsYXRpb25JZCgpLCBudWxsXTtcbiAgfSxcblxuICBmcEh0dHBDb250ZW50VHlwZSgvKm1lc3NhZ2UqLyAvKiwgZmxhZ3MqLykge1xuICAgIC8vIFRPRE86XG4gICAgLy8gSFRUUCBDb250ZW50IFR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICAgIC8vIGNvbnN0IHN0clZhbHVlID0gbWVzc2FnZS5nZXRIVFRQQ29udGVudFR5cGUoKTtcbiAgICAvLyByZXR1cm4gWydIVFRQIENvbnRlbnQgVHlwZScsIChzdHJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHN0clZhbHVlICE9PSBudWxsKSwgc3RyVmFsdWUsIG51bGxdO1xuICAgIHJldHVybiBbJ0hUVFAgQ29udGVudCBUeXBlJywgZmFsc2UsIHVuZGVmaW5lZCwgbnVsbF07XG4gIH0sXG5cbiAgZnBIdHRwQ29udGVudEVuY29kaW5nKC8qbWVzc2FnZSovIC8qLCBmbGFncyovKSB7XG4gICAgLy8gVE9ETzpcbiAgICAvLyBIVFRQIENvbnRlbnQgRW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICAgIC8vIGNvbnN0IHN0clZhbHVlID0gbWVzc2FnZS5nZXRIVFRQQ29udGVudFR5cGUoKTtcbiAgICAvLyByZXR1cm4gWydIVFRQIENvbnRlbnQgRW5jb2RpbmcnLCAoc3RyVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzdHJWYWx1ZSAhPT0gbnVsbCksIHN0clZhbHVlLFxuICAgIC8vICAgICAgICAgbnVsbF07XG4gICAgcmV0dXJuIFsnSFRUUCBDb250ZW50IEVuY29kaW5nJywgZmFsc2UsIHVuZGVmaW5lZCwgbnVsbF07XG4gIH0sXG5cbiAgZnBTZW5kVGltZXN0YW1wKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBtZXNzYWdlLmdldFNlbmRlclRpbWVzdGFtcCgpO1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgbWR1ID0gTWVzc2FnZUR1bXBVdGlsTGliLk1lc3NhZ2VEdW1wVXRpbDtcbiAgICAgIHJldHVybiBbJ1NlbmRUaW1lc3RhbXAnLCB0cnVlLFxuICAgICAgICBgJHt0aW1lc3RhbXB9ICgke21kdS5mb3JtYXREYXRlKHRpbWVzdGFtcCl9KWAsIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydTZW5kVGltZXN0YW1wJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFJjdlRpbWVzdGFtcChtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbWVzc2FnZS5nZXRSZWNlaXZlclRpbWVzdGFtcCgpO1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgbWR1ID0gTWVzc2FnZUR1bXBVdGlsTGliLk1lc3NhZ2VEdW1wVXRpbDtcbiAgICAgIHJldHVybiBbJ1JjdlRpbWVzdGFtcCcsIHRydWUsXG4gICAgICAgIGAke3RpbWVzdGFtcH0gKCR7bWR1LmZvcm1hdERhdGUodGltZXN0YW1wKX0pYCwgbnVsbF07XG4gICAgfVxuICAgIHJldHVybiBbJ1JjdlRpbWVzdGFtcCcsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBDbGFzc09mU2VydmljZShtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgY29uc3QgY29zID0gbWVzc2FnZS5nZXRVc2VyQ29zKCk7XG4gICAgaWYgKHR5cGVvZiBjb3MgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gWydDbGFzcyBPZiBTZXJ2aWNlJywgdHJ1ZSwgTWVzc2FnZVVzZXJDb3NUeXBlLm5hbWVPZihtZXNzYWdlLmdldFVzZXJDb3MoKSksIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydDbGFzcyBPZiBTZXJ2aWNlJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuLy8gIGZwUHJpb3JpdHkobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuLy8gICAgY29uc3QgcHJpbyA9IG1lc3NhZ2UuZ2V0UHJpb3JpdHkoKSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5nZXRQcmlvcml0eSgpIDogJ3VuZGVmaW5lZCc7XG4vLyAgICByZXR1cm4gWydNZXNzYWdlIFByaW9yaXR5JywgdHJ1ZSwgcHJpbywgbnVsbF07XG4vLyAgfSxcblxuICBmcERlbGl2ZXJ5TW9kZShtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgY29uc3QgbW9kZSA9IG1lc3NhZ2UuZ2V0RGVsaXZlcnlNb2RlKCk7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFsnRGVsaXZlcnlNb2RlJywgdHJ1ZSwgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUubmFtZU9mKG1lc3NhZ2UuZ2V0RGVsaXZlcnlNb2RlKCkpLCBudWxsXTtcbiAgICB9XG4gICAgcmV0dXJuIFsnRGVsaXZlcnlNb2RlJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcEd1YXJhbnRlZWRNc2dJZChtZXNzYWdlLyosIGZsYWdzKi8pIHtcbiAgICBjb25zdCBtc2dJZCA9IG1lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpO1xuICAgIGlmIChMb25nLmlzTG9uZyhtc2dJZCkpIHtcbiAgICAgIHJldHVybiBbJ01lc3NhZ2UgSWQnLCB0cnVlLCBtc2dJZC50b1N0cmluZygxMCksIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydNZXNzYWdlIElkJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFRpbWVUb0xpdmUobWVzc2FnZS8qICwgZmxhZ3MgKi8pIHtcbiAgICBjb25zdCB0aW1lVG9MaXZlID0gbWVzc2FnZS5nZXRUaW1lVG9MaXZlKCk7XG4gICAgaWYgKHR5cGVvZiB0aW1lVG9MaXZlID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgbWR1ID0gTWVzc2FnZUR1bXBVdGlsTGliLk1lc3NhZ2VEdW1wVXRpbDtcbiAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgcmV0dXJuIFsnVGltZVRvTGl2ZScsIHRydWUsXG4gICAgICAgIGAke3RpbWVUb0xpdmV9ICgke21kdS5mb3JtYXREYXRlKGQuZ2V0VGltZSgpICsgdGltZVRvTGl2ZSl9KWAsIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydUaW1lVG9MaXZlJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcEV4cGlyYXRpb24obWVzc2FnZS8qLCBmbGFncyovKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbWVzc2FnZS5nZXRHTUV4cGlyYXRpb24oKTtcbiAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IG1kdSA9IE1lc3NhZ2VEdW1wVXRpbExpYi5NZXNzYWdlRHVtcFV0aWw7XG4gICAgICByZXR1cm4gWydFeHBpcmF0aW9uJywgdHJ1ZSxcbiAgICAgICAgYCR7dGltZXN0YW1wfSAoJHttZHUuZm9ybWF0RGF0ZSh0aW1lc3RhbXApfSlgLCBudWxsXTtcbiAgICB9XG4gICAgcmV0dXJuIFsnRXhwaXJhdGlvbicsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBNZXNzYWdlRE1RRWxpZ2libGUobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ0RNUSBFbGlnaWJsZScsIG1lc3NhZ2UuaXNETVFFbGlnaWJsZSgpLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBNZXNzYWdlUmVkZWxpdmVyZWQobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ01lc3NhZ2UgUmUtZGVsaXZlcmVkJywgbWVzc2FnZS5pc1JlZGVsaXZlcmVkKCksICcnLCBudWxsXTtcbiAgfSxcblxuICBmcERpc2NhcmRJbmRpY2F0aW9uKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICByZXR1cm4gWydEaXNjYXJkIEluZGljYXRpb24nLCBtZXNzYWdlLmlzRGlzY2FyZEluZGljYXRpb24oKSwgJycsIG51bGxdO1xuICB9LFxuXG4gIGZwQWNrSW1tZWRpYXRlbHkobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ0FDSyBJbW1lZGlhdGVseScsIG1lc3NhZ2UuaXNBY2tub3dsZWRnZUltbWVkaWF0ZWx5KCksICcnLCBudWxsXTtcbiAgfSxcblxuICBmcEVsaWRpbmdFbGlnaWJsZShtZXNzYWdlLyogLCBmbGFncyovKSB7XG4gICAgcmV0dXJuIFsnRWxpZGluZyBFbGlnaWJsZScsIG1lc3NhZ2UuaXNFbGlkaW5nRWxpZ2libGUoKSwgJycsIG51bGxdO1xuICB9LFxuXG4gIGZwUmVwbHlNZXNzYWdlKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICByZXR1cm4gWydSZXBseSBNZXNzYWdlJywgbWVzc2FnZS5pc1JlcGx5TWVzc2FnZSgpLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBSZXBseVRvKG1lc3NhZ2UvKiAsIGZsYWdzKi8pIHtcbiAgICBjb25zdCByZXBseVRvID0gbWVzc2FnZS5nZXRSZXBseVRvKCk7XG4gICAgaWYgKHJlcGx5VG8gIT09IG51bGwgJiYgcmVwbHlUbyBpbnN0YW5jZW9mIERlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm4gWydSZXBseVRvJywgdHJ1ZSwgcmVwbHlUby50b1N0cmluZygpLCBudWxsXTtcbiAgICB9XG4gICAgcmV0dXJuIFsnUmVwbHlUbycsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBEZWxpdmVyVG9PbmUobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ0RlbGl2ZXIgVG8gT25lJywgbWVzc2FnZS5pc0RlbGl2ZXJUb09uZSgpLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBDYWNoZU1lc3NhZ2UobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIHJldHVybiBbJ01lc3NhZ2UgZnJvbSBjYWNoZScsIG1lc3NhZ2UuZ2V0Q2FjaGVTdGF0dXMoKSAhPT0gTWVzc2FnZUNhY2hlU3RhdHVzLkxJVkUsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcENhY2hlUmVxdWVzdElkKG1lc3NhZ2UvKiwgZmxhZ3MgKi8pIHtcbiAgICBjb25zdCBjYWNoZVJlcXVlc3RJZCA9IG1lc3NhZ2UuZ2V0Q2FjaGVSZXF1ZXN0SWQoKTtcbiAgICBpZiAoTG9uZy5pc0xvbmcoY2FjaGVSZXF1ZXN0SWQpKSB7XG4gICAgICByZXR1cm4gWydDYWNoZSBSZXF1ZXN0IElkJywgdHJ1ZSwgY2FjaGVSZXF1ZXN0SWQudG9TdHJpbmcsIG51bGxdO1xuICAgIH1cbiAgICByZXR1cm4gWydDYWNoZSBSZXF1ZXN0IElkJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFVzZXJQcm9wZXJ0eU1hcChtZXNzYWdlLCBmbGFncykge1xuICAgIGNvbnN0IHByb3BNYXAgPSBtZXNzYWdlLmdldFVzZXJQcm9wZXJ0eU1hcCgpO1xuICAgIGlmIChwcm9wTWFwICE9PSBudWxsICYmIHByb3BNYXAgaW5zdGFuY2VvZiBTRFRNYXBDb250YWluZXIpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYCR7cHJvcE1hcC5nZXRLZXlzKCkubGVuZ3RofSBlbnRyaWVzYDtcbiAgICAgIGxldCBkZXRhaWxWYWx1ZSA9IG51bGw7XG4gICAgICBpZiAoZmxhZ3MgPT09IE1lc3NhZ2VEdW1wRmxhZy5NU0dEVU1QX0ZVTEwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtZHUgPSBNZXNzYWdlRHVtcFV0aWxMaWIuTWVzc2FnZUR1bXBVdGlsO1xuICAgICAgICAgIGRldGFpbFZhbHVlID0gbWR1LnByaW50TWFwKHByb3BNYXAsIDIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgTE9HX0VSUk9SKGUubWVzc2FnZSwgZS5zdGFjayk7XG4gICAgICAgICAgZGV0YWlsVmFsdWUgPSAnRXJyb3InO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gWydVc2VyIFByb3BlcnR5IE1hcCcsIHRydWUsIHZhbHVlLCBkZXRhaWxWYWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBbJ1VzZXIgUHJvcGVydHkgTWFwJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcENvcnJlbGF0aW9uVGFnKG1lc3NhZ2UvKiwgZmxhZ3MqLykge1xuICAgIGNvbnN0IHN0clZhbHVlID0gbWVzc2FnZS5nZXRDb3JyZWxhdGlvbktleSgpO1xuICAgIHJldHVybiBbJ0NvcnJlbGF0aW9uIFRhZyBQb2ludGVyJywgKHN0clZhbHVlICE9PSB1bmRlZmluZWQgJiYgc3RyVmFsdWUgIT09IG51bGwpLFxuICAgICAgc3RyVmFsdWUsIG51bGxdO1xuICB9LFxuXG4gIGZwVXNlckRhdGEobWVzc2FnZS8qICwgZmxhZ3MqLykge1xuICAgIGlmIChTdHJpbmdVdGlscy5ub3RFbXB0eShtZXNzYWdlLmdldFVzZXJEYXRhKCkpKSB7XG4gICAgICByZXR1cm4gWydVc2VyIERhdGEnLCB0cnVlLCBgbGVuPSR7bWVzc2FnZS5nZXRVc2VyRGF0YSgpLmxlbmd0aH1gLFxuICAgICAgICBEZWJ1Z0xpYi5EZWJ1Zy5mb3JtYXREdW1wQnl0ZXMobWVzc2FnZS5nZXRVc2VyRGF0YSgpLCB0cnVlLCAyKV07XG4gICAgfVxuICAgIHJldHVybiBbJ1VzZXIgRGF0YScsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG5cbiAgZnBTZHRTdHJlYW0obWVzc2FnZSwgZmxhZ3MpIHtcbiAgICBjb25zdCBzZHRGaWVsZFZhbHVlID0gbWVzc2FnZS5nZXRTZHRDb250YWluZXIoKTtcbiAgICBpZiAoc2R0RmllbGRWYWx1ZSAhPT0gbnVsbCAmJiBzZHRGaWVsZFZhbHVlLmdldFR5cGUoKSA9PT0gU0RURmllbGRUeXBlLlNUUkVBTSkge1xuICAgICAgY29uc3QgbWR1ID0gTWVzc2FnZUR1bXBVdGlsTGliLk1lc3NhZ2VEdW1wVXRpbDtcbiAgICAgIGNvbnN0IHZhbHVlID0gYCR7bWR1LmNvdW50SXRlbXMoc2R0RmllbGRWYWx1ZS5nZXRWYWx1ZSgpKX0gZW50cmllc2A7XG4gICAgICBsZXQgZGV0YWlsVmFsdWUgPSBudWxsO1xuICAgICAgaWYgKGZsYWdzID09PSBNZXNzYWdlRHVtcEZsYWcuTVNHRFVNUF9GVUxMKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGV0YWlsVmFsdWUgPSBtZHUucHJpbnRTdHJlYW0oc2R0RmllbGRWYWx1ZS5nZXRWYWx1ZSgpLCAyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIExPR19FUlJPUihlLm1lc3NhZ2UsIGUuc3RhY2spO1xuICAgICAgICAgIGRldGFpbFZhbHVlID0gJ0Vycm9yJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsnU0RUIFN0cmVhbScsIHRydWUsIHZhbHVlLCBkZXRhaWxWYWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBbJ1NEVCBTdHJlYW0nLCBmYWxzZSwgJycsIG51bGxdO1xuICB9LFxuXG4gIGZwU2R0TWFwKG1lc3NhZ2UsIGZsYWdzKSB7XG4gICAgY29uc3Qgc2R0RmllbGRWYWx1ZSA9IG1lc3NhZ2UuZ2V0U2R0Q29udGFpbmVyKCk7XG4gICAgaWYgKHNkdEZpZWxkVmFsdWUgIT09IG51bGwgJiYgc2R0RmllbGRWYWx1ZS5nZXRUeXBlKCkgPT09IFNEVEZpZWxkVHlwZS5NQVApIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYCR7c2R0RmllbGRWYWx1ZS5nZXRWYWx1ZSgpLmdldEtleXMoKS5sZW5ndGh9IGVudHJpZXNgO1xuICAgICAgbGV0IGRldGFpbFZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChmbGFncyA9PT0gTWVzc2FnZUR1bXBGbGFnLk1TR0RVTVBfRlVMTCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1kdSA9IE1lc3NhZ2VEdW1wVXRpbExpYi5NZXNzYWdlRHVtcFV0aWw7XG4gICAgICAgICAgZGV0YWlsVmFsdWUgPSBtZHUucHJpbnRNYXAoc2R0RmllbGRWYWx1ZS5nZXRWYWx1ZSgpLCAyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIExPR19FUlJPUihlLm1lc3NhZ2UsIGUuc3RhY2spO1xuICAgICAgICAgIGRldGFpbFZhbHVlID0gJ0Vycm9yJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsnU0RUIE1hcCcsIHRydWUsIHZhbHVlLCBkZXRhaWxWYWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBbJ1NEVCBNYXAnLCBmYWxzZSwgJycsIG51bGxdO1xuICB9LFxuXG4gIGZwQmluYXJ5QXR0YWNobWVudChtZXNzYWdlLCBmbGFncykge1xuICAgIGNvbnN0IGF0dCA9IG1lc3NhZ2UuZ2V0QmluYXJ5QXR0YWNobWVudCgpO1xuICAgIGlmIChTdHJpbmdVdGlscy5ub3RFbXB0eShhdHQpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGBsZW49JHthdHQubGVuZ3RofWA7XG4gICAgICBsZXQgZGV0YWlsVmFsdWUgPSBudWxsO1xuICAgICAgaWYgKGZsYWdzID09PSBNZXNzYWdlRHVtcEZsYWcuTVNHRFVNUF9GVUxMKSB7XG4gICAgICAgIGRldGFpbFZhbHVlID0gRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKGF0dCwgdHJ1ZSwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gWydCaW5hcnkgQXR0YWNobWVudCcsIHRydWUsIHZhbHVlLCBkZXRhaWxWYWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBbJ0JpbmFyeSBBdHRhY2htZW50JywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFhtbENvbnRlbnQobWVzc2FnZSwgZmxhZ3MpIHtcbiAgICBjb25zdCB4bWwgPSBtZXNzYWdlLmdldFhtbENvbnRlbnQoKTtcbiAgICBpZiAoU3RyaW5nVXRpbHMubm90RW1wdHkoeG1sKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBgbGVuPSR7eG1sLmxlbmd0aH1gO1xuICAgICAgbGV0IGRldGFpbFZhbHVlID0gbnVsbDtcbiAgICAgIGlmIChmbGFncyA9PT0gTWVzc2FnZUR1bXBGbGFnLk1TR0RVTVBfRlVMTCkge1xuICAgICAgICBkZXRhaWxWYWx1ZSA9IERlYnVnTGliLkRlYnVnLmZvcm1hdER1bXBCeXRlcyh4bWwsIHRydWUsIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsnWE1MJywgdHJ1ZSwgdmFsdWUsIGRldGFpbFZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIFsnWE1MJywgZmFsc2UsICcnLCBudWxsXTtcbiAgfSxcblxuICBmcFhtbE1ldGFkYXRhKG1lc3NhZ2UsIGZsYWdzKSB7XG4gICAgY29uc3QgeG1sTWV0YWRhdGEgPSBtZXNzYWdlLmdldFhtbE1ldGFkYXRhKCk7XG4gICAgaWYgKFN0cmluZ1V0aWxzLm5vdEVtcHR5KHhtbE1ldGFkYXRhKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBgbGVuPSR7eG1sTWV0YWRhdGEubGVuZ3RofWA7XG4gICAgICBsZXQgZGV0YWlsVmFsdWUgPSBudWxsO1xuICAgICAgaWYgKGZsYWdzID09PSBNZXNzYWdlRHVtcEZsYWcuTVNHRFVNUF9GVUxMKSB7XG4gICAgICAgIGRldGFpbFZhbHVlID0gRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKHhtbE1ldGFkYXRhLCB0cnVlLCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ1hNTCBNZXRhZGF0YScsIHRydWUsIHZhbHVlLCBkZXRhaWxWYWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBbJ1hNTCBNZXRhZGF0YScsIGZhbHNlLCAnJywgbnVsbF07XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlRHVtcFN0YW5kYXJkUHJvdmlkZXIgPSBNZXNzYWdlRHVtcFN0YW5kYXJkUHJvdmlkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlL2xpYi9tZXNzYWdlLWR1bXAtc3RhbmRhcmQtcHJvdmlkZXIuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW51bWVyYXRpb24gb2YgbWVzc2FnZSBwYXlsb2FkIHR5cGVzXG4gKiAoc2VlIHtAbGluayBzb2xhY2UuTWVzc2FnZSNnZXRCaW5hcnlBdHRhY2htZW50fSlcbiAqXG4gKiBBIG1lc3NhZ2UgbWF5IGNvbnRhaW4gdW5zdHJ1Y3R1cmVkIGJ5dGUgZGF0YSwgb3IgYSBzdHJ1Y3R1cmVkIGNvbnRhaW5lci5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBNZXNzYWdlVHlwZSA9IHtcbiAgLyoqXG4gICAqIEJpbmFyeSBtZXNzYWdlICh1bnN0cnVjdHVyZWQgYnl0ZXMgc3RvcmVkIGluIHRoZSBiaW5hcnkgYXR0YWNobWVudCBtZXNzYWdlIHBhcnQpLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQklOQVJZOiAwLFxuICAvKipcbiAgICogU3RydWN0dXJlZCBtYXAgbWVzc2FnZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIE1BUDogICAgMSxcbiAgLyoqXG4gICAqIFN0cnVjdHVyZWQgc3RyZWFtIG1lc3NhZ2UuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBTVFJFQU06IDIsXG4gIC8qKlxuICAgKiBTdHJ1Y3R1cmVkIHRleHQgbWVzc2FnZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIFRFWFQ6ICAgMyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VUeXBlID0gRW51bS5uZXcoTWVzc2FnZVR5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS10eXBlcy5qcyIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IEFQSVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uVHlwZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWRlc3RpbmF0aW9uJyk7XG5jb25zdCB7IE9wZXJhdGlvbkVycm9yLCBFcnJvclN1YmNvZGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBRdWV1ZVR5cGUgfSA9IHJlcXVpcmUoJy4vcXVldWUtdHlwZXMnKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIGR1cmFibGU6IHRydWUsXG4gIHR5cGU6ICAgIHVuZGVmaW5lZCxcbn07XG5cbmNvbnN0IFRZUEVfREVTQ1JJUFRJT04gPSB7XG4gIFtRdWV1ZVR5cGUuUVVFVUVdOiAgICAgICAgICAncXVldWUnLFxuICBbUXVldWVUeXBlLlRPUElDX0VORFBPSU5UXTogJ3RvcGljIGVuZHBvaW50Jyxcbn07XG5cbmNvbnN0IERFU0lOQVRJT05fVFlQRV9UT19ERVNDUklQVE9SX1RZUEUgPSB7XG4gIFtEZXN0aW5hdGlvblR5cGUuVE9QSUNdOiAgICAgICAgICAgbnVsbCxcbiAgW0Rlc3RpbmF0aW9uVHlwZS5RVUVVRV06ICAgICAgICAgICBRdWV1ZVR5cGUuUVVFVUUsXG4gIFtEZXN0aW5hdGlvblR5cGUuVEVNUE9SQVJZX1FVRVVFXTogUXVldWVUeXBlLlFVRVVFLFxufTtcblxuZnVuY3Rpb24gbWF5YmVBZGFwdEZyb21EZXN0aW5hdGlvbihzcGVjKSB7XG4gIGlmIChzcGVjICYmIHNwZWMubmFtZSAmJiBzcGVjLnR5cGUgJiYgRGVzdGluYXRpb25UeXBlLnZhbHVlcy5pbmNsdWRlcyhzcGVjLnR5cGUpKSB7XG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IERFU0lOQVRJT05fVFlQRV9UT19ERVNDUklQVE9SX1RZUEVbc3BlYy50eXBlXTtcbiAgICBpZiAoIXRhcmdldFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgQ2Fubm90IGNyZWF0ZSBhIGRlc2NyaXB0b3IgZnJvbSBhICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVzdGluYXRpb25UeXBlLmRlc2NyaWJlKHNwZWMudHlwZSl9IGRlc3RpbmF0aW9uYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0NPTkZMSUNUKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICAgIHNwZWMubmFtZSxcbiAgICAgIHR5cGU6ICAgIFF1ZXVlVHlwZS5RVUVVRSxcbiAgICAgIGR1cmFibGU6IHNwZWMudHlwZSAhPT0gRGVzdGluYXRpb25UeXBlLlRFTVBPUkFSWV9RVUVVRSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+XG4gKiA8cD5cbiAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciB7QGxpbmsgc29sYWNlLlF1ZXVlRGVzY3JpcHRvcn0uIEFQSSB1c2VycyBzaG91bGQgYWNjZXNzIHRoZVxuICogbWV0aG9kcyBkZXNjcmliZWQgaGVyZSB0aHJvdWdoIGEge0BsaW5rIHNvbGFjZS5RdWV1ZURlc2NyaXB0b3J9LlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvciBleHRlbmRzIEFQSVByb3BlcnRpZXMge1xuICAvKlxuICAgKiBAcGFyYW0ge09iamVjdHxzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3J9IHF1ZXVlU3BlYyBBIHNwZWNpZmljYXRpb24gZm9yIHRoaXMgZGVzY3JpcHRvci5cbiAgICogQHBhcmFtIHtzb2xhY2UuUXVldWVUeXBlfSBxdWV1ZVNwZWMudHlwZSBUaGUgdHlwZSBvZiBxdWV1ZSBmb3IgdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtxdWV1ZVNwZWMuZHVyYWJsZT10cnVlXSBXaGV0aGVyIHRoaXMgc3BlYyByZWZlcnMgdG8gYSBkdXJhYmxlIHF1ZXVlLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHF1ZXVlU3BlYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBzdXBlcihERUZBVUxUUywgbWF5YmVBZGFwdEZyb21EZXN0aW5hdGlvbihxdWV1ZVNwZWMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBxdWV1ZSB0eXBlIHRvIHdoaWNoIHRoaXMgZGVzY3JpcHRvciByZWZlcnMuXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuUXVldWVUeXBlfSBUaGUgcXVldWUgdHlwZSB0aGF0IHRoaXMgb2JqZWN0IGRlc2NyaWJlc1xuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c29sYWNlLlF1ZXVlVHlwZX1cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBRdWV1ZSBUeXBlLlxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpO1xuICB9XG4gIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgdGhpcy5fdHlwZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgd2hldGhlciB0aGlzIGRlc2NyaXB0b3IgcmVmZXJzIHRvIGEgZHVyYWJsZSBxdWV1ZS5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGlzIGRlc2NyaWJlcyBhIGR1cmFibGUgcXVldWVcbiAgICovXG4gIGlzRHVyYWJsZSgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgcmV0dXJuIHRoaXMuX2R1cmFibGU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb24gVHJ1ZSBpZiB0aGlzIGRlc2NyaXB0b3IgcmVmZXJzIHRvIGEgRHVyYWJibGUgUXVldWUuXG4gICAqL1xuICBnZXQgZHVyYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0R1cmFibGUoKTtcbiAgfVxuICBzZXQgZHVyYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2R1cmFibGUgPSB2YWx1ZTtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3R5cGUnOiAgICB0aGlzLnR5cGUsXG4gICAgICAnZHVyYWJsZSc6IHRoaXMuZHVyYWJsZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGluZm9ybWF0aW9uYWwgc3VtbWFyeSBvZiB0aGlzIG9iamVjdCwgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3VtbWFyeSBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHshdGhpcy5pc0R1cmFibGUoKSA/ICdub24nIDogJyd9LWR1cmFibGUgYCArXG4gICAgICAgICAgIGAke1RZUEVfREVTQ1JJUFRJT05bdGhpcy5nZXRUeXBlKCldfWA7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5BYnN0cmFjdFF1ZXVlRGVzY3JpcHRvciA9IEFic3RyYWN0UXVldWVEZXNjcmlwdG9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtcXVldWUvbGliL2Fic3RyYWN0LXF1ZXVlLWRlc2NyaXB0b3IuanMiLCJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvciB9ID0gcmVxdWlyZSgnLi9hYnN0cmFjdC1xdWV1ZS1kZXNjcmlwdG9yJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIG5hbWU6ICAgIHVuZGVmaW5lZCxcbiAgZHVyYWJsZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpZGVudGlmaWVzIGEgcXVldWUgb3IgdG9waWMgZW5kcG9pbnQgb24gdGhlIG1lc3NhZ2Ugcm91dGVyLlxuICpcbiAqIE9wZXJhdGlvbnMgdGhhdCBtYWtlIHVzZSBvZiBxdWV1ZSBkZXNjcmlwdG9ycyBpbmNsdWRlXG4gKiAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlTWVzc2FnZUNvbnN1bWVyfVxuICogICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uI2R0ZVVuc3Vic2NyaWJlfVxuICpcbiAqIEBjbGFzc2Rlc2MgUXVldWVEZXNjcmlwdG9yXG4gKiBAZXh0ZW5kcyB7QWJzdHJhY3RRdWV1ZURlc2NyaXB0b3J9XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNsYXNzIFF1ZXVlRGVzY3JpcHRvciBleHRlbmRzIEFic3RyYWN0UXVldWVEZXNjcmlwdG9yIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgc29sYWNlLlF1ZXVlRGVzY3JpcHRvcn0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHNvbGFjZS5RdWV1ZURlc2NyaXB0b3J9IHF1ZXVlU3BlYyBBIHNwZWNpZmljYXRpb24gZm9yIHRoaXMgZGVzY3JpcHRvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXVlU3BlYy5uYW1lIFRoZSByZW1vdGUgbmFtZSB0byB3aGljaCB0aGlzIHNwZWNpZmljYXRpb24gcmVmZXJzLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5RdWV1ZVR5cGV9IHF1ZXVlU3BlYy50eXBlIFRoZSB0eXBlIG9mIHF1ZXVlIGZvciB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3F1ZXVlU3BlYy5kdXJhYmxlPXRydWVdIGB0cnVlYCBpZiB0aGlzIHJlZmVycyB0byBhIGR1cmFibGUgcXVldWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihxdWV1ZVNwZWMpIHtcbiAgICBzdXBlcihxdWV1ZVNwZWMgaW5zdGFuY2VvZiBEZXN0aW5hdGlvblxuICAgICAgICAgICAgPyB7IG5hbWU6IHF1ZXVlU3BlYy5uYW1lLCB0eXBlOiBxdWV1ZVNwZWMudHlwZSB9IC8vIHN5bnRoZXNpemUgZHVyYWJsZSBsYXRlclxuICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHsgfSwgREVGQVVMVFMsIHF1ZXVlU3BlYykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMvc2V0cyB0aGUgcmVtb3RlIG5hbWUgdG8gd2hpY2ggdGhpcyBkZXNjcmlwdG9yIHJlZmVycy5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHF1ZXVlLlxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYW1lKCk7XG4gIH1cbiAgc2V0IG5hbWUodmFsdWUpIHtcbiAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICduYW1lJzogICAgdGhpcy5uYW1lLFxuICAgICAgJ3R5cGUnOiAgICB0aGlzLnR5cGUsXG4gICAgICAnZHVyYWJsZSc6IHRoaXMuZHVyYWJsZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGluZm9ybWF0aW9uYWwgc3VtbWFyeSBvZiB0aGlzIG9iamVjdCwgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgc3VtbWFyeSBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHtzdXBlci50b1N0cmluZygpfSAnJHt0aGlzLmdldE5hbWUoKX0nYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7YW55fSBzcGVjIFRoZSBkZXNjcmlwdG9yIHNwZWNcbiAgICogQHJldHVybnMge1F1ZXVlRGVzY3JpcHRvcnxBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvcn0gQSBuZXcgZGVzY3JpcHRvciBmb3IgdGhlIHNwZWNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVGcm9tU3BlYyhzcGVjKSB7XG4gICAgaWYgKHNwZWMubmFtZSkgcmV0dXJuIG5ldyBRdWV1ZURlc2NyaXB0b3Ioc3BlYyk7XG4gICAgcmV0dXJuIEFic3RyYWN0UXVldWVEZXNjcmlwdG9yKHNwZWMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVzY3JpcHRvciA9IFF1ZXVlRGVzY3JpcHRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1kZXNjcmlwdG9yLmpzIiwiY29uc3QgeyBDb252ZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuY29uc3QgeyBTRFREYXRhVHlwZXMgfSA9IHJlcXVpcmUoJy4uL3NkdC1kYXRhLXR5cGVzJyk7XG5cbmNvbnN0IEVuY29kZUhlYWRlciA9IHtcbiAgZW5jb2RlSGVhZGVyKHRhZywgdmFsdWVMZW4pIHtcbiAgICAvLyBUYWcgaW4gZmlyc3QgNiBiaXRzLCB0aGVuIChsZW5ieXRlcy0xKSBpbiAyIGJpdHNcbiAgICBsZXQgYnl0ZTAgPSAodGFnIDw8IDIpICYgMHhGRjtcbiAgICBsZXQgc3RyU2R0TGVuID0gbnVsbDtcblxuICAgIGlmICh0YWcgPT09IFNEVERhdGFUeXBlcy5NYXAgfHwgdGFnID09PSBTRFREYXRhVHlwZXMuU3RyZWFtKSB7XG4gICAgICAgIC8vIGZvcmNlIDQgYnl0ZXNcbiAgICAgIHN0clNkdExlbiA9IENvbnZlcnQuaW50MzJUb1N0cih2YWx1ZUxlbiArIDUpO1xuICAgICAgYnl0ZTAgfD0gMzsgLy8gNCBsZW5ndGggYnl0ZXNcbiAgICB9IGVsc2UgaWYgKHZhbHVlTGVuICsgMiA8PSAyNTUpIHtcbiAgICAgIHN0clNkdExlbiA9IENvbnZlcnQuaW50OFRvU3RyKHZhbHVlTGVuICsgMik7XG4gICAgICBieXRlMCB8PSAwOyAvLyAxIGxlbmd0aCBieXRlXG4gICAgfSBlbHNlIGlmICh2YWx1ZUxlbiArIDMgPD0gNjU1MzUpIHtcbiAgICAgIHN0clNkdExlbiA9IENvbnZlcnQuaW50MTZUb1N0cih2YWx1ZUxlbiArIDMpO1xuICAgICAgYnl0ZTAgfD0gMTsgLy8gMiBsZW5ndGggYnl0ZXNcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyU2R0TGVuID0gQ29udmVydC5pbnQzMlRvU3RyKHZhbHVlTGVuICsgNSk7XG4gICAgICBieXRlMCB8PSAzOyAvLyA0IGxlbmd0aCBieXRlc1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBDb252ZXJ0LmludDhUb1N0cihieXRlMCkgKyBzdHJTZHRMZW47XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkVuY29kZUhlYWRlciA9IEVuY29kZUhlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvZW5jb2RlLWhlYWRlci5qcyIsImNvbnN0IHsgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgU0RURmllbGQgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZCcpO1xuY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZC10eXBlcycpO1xuY29uc3QgeyBTRFRVbnN1cHBvcnRlZFZhbHVlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL3NkdC11bnN1cHBvcnRlZC12YWx1ZS1lcnJvcicpO1xuY29uc3QgeyBTRFRWYWx1ZUVycm9yU3ViY29kZSB9ID0gcmVxdWlyZSgnLi4vc2R0LXZhbHVlLWVycm9yLXN1YmNvZGVzJyk7XG5cbmNvbnN0IHsgY3JlYXRlOiBjcmVhdGVGaWVsZCB9ID0gU0RURmllbGQ7XG5cbmNvbnN0IENfMl80OCA9IE1hdGgucG93KDIsIDQ4KTtcblxuZnVuY3Rpb24gZ2V0QmluYXJ5U3RyaW5nKHN0ckJ5dGVzKSB7XG4gIGNvbnN0IGJpdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0ckJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgbGV0IGJ5dGVJID0gc3RyQnl0ZXMuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyArK2opIHtcbiAgICAgIGJpdHMucHVzaChieXRlSSAlIDIgPyAxIDogMCk7XG4gICAgICBieXRlSSA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgYml0cy5yZXZlcnNlKCk7XG4gIHJldHVybiBiaXRzLmpvaW4oJycpO1xufVxuXG5jb25zdCBQYXJzZUludGVnZXIgPSB7XG5cbiAgLy8gVXRpbDogZGVjb2RlIDEsIDIsIDMsIDQgYnl0ZSBVSU5ULlxuICBhdXRvRGVjb2RlVmFyTGVuZ3RoTnVtYmVyKGRhdGFTdHIpIHtcbiAgICBzd2l0Y2ggKGRhdGFTdHIubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBDb252ZXJ0LnN0clRvSW50OChkYXRhU3RyKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIENvbnZlcnQuc3RyVG9JbnQxNihkYXRhU3RyKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIENvbnZlcnQuc3RyVG9JbnQyNChkYXRhU3RyKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIENvbnZlcnQuc3RyVG9JbnQzMihkYXRhU3RyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIFNEVCBGaWVsZDogW1VdSU5UIDgsIDE2LCAzMiwgNjQuXG4gIHBhcnNlSW50ZWdlckZpZWxkKGlzU2lnbmVkLCBkYXRhc3RyKSB7XG4gICAgbGV0IHNpZ24gPSBmYWxzZTtcbiAgICBsZXQgdmFsID0gMDtcbiAgICBsZXQgdW5zYWZlQml0cztcblxuICAgIHN3aXRjaCAoZGF0YXN0ci5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFsID0gQ29udmVydC5zdHJUb0ludDgoZGF0YXN0cik7XG4gICAgICAgIGlmICghaXNTaWduZWQpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRmllbGQoU0RURmllbGRUeXBlLlVJTlQ4LCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ24gPSAodmFsICYgMHg4MCkgIT09IDA7XG4gICAgICAgIGlmIChzaWduKSB7XG4gICAgICAgICAgdmFsIC09IDI1NjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRmllbGQoU0RURmllbGRUeXBlLklOVDgsIHZhbCk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdmFsID0gQ29udmVydC5zdHJUb0ludDE2KGRhdGFzdHIpO1xuICAgICAgICBpZiAoIWlzU2lnbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMTYsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbiA9ICh2YWwgJiAweDgwMDApICE9PSAwO1xuICAgICAgICBpZiAoc2lnbikge1xuICAgICAgICAgIHZhbCAtPSA2NTUzNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRmllbGQoU0RURmllbGRUeXBlLklOVDE2LCB2YWwpO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHZhbCA9IENvbnZlcnQuc3RyVG9JbnQzMihkYXRhc3RyKTtcbiAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgLy8gcmF3IHJlYWQgdXNpbmcgc3RyVG9JbnQzMiAoaXQgcmVhZHMgMidzIGNvbXBsZW1lbnQpXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpZWxkKFNEVEZpZWxkVHlwZS5JTlQzMiwgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnNpb24gZXJyb3Igd2l0aCBzdHJUb0ludDMyISAod2UgY2FuJ3QgcmVhZCBiYWNrIGEgMzJiaXQgdWludClcbiAgICAgICAgLy8gU29sdXRpb24gaXMgdG8gY29udmVydCBieXRlIHBvc2l0aW9ucyBvdXJzZWx2ZXMgd2l0aG91dCB1c2luZyBiaXR3aXNlIHNoaWZ0c1xuICAgICAgICAvLyBCZWNhdXNlIHRoZSBVSU5UIGlzIGd1YXJhbnRlZWQgdG8gYmUgPCAyXjUzIHRoaXMgc2hvdWxkIHdvcmsuXG4gICAgICAgIHZhbCA9IChkYXRhc3RyLmNoYXJDb2RlQXQoMCkgKiAxNjc3NzIxNikgK1xuICAgICAgICAgICAgICAoZGF0YXN0ci5jaGFyQ29kZUF0KDEpICogNjU1MzYpICtcbiAgICAgICAgICAgICAgKGRhdGFzdHIuY2hhckNvZGVBdCgyKSAqIDI1NikgK1xuICAgICAgICAgICAgICAoZGF0YXN0ci5jaGFyQ29kZUF0KDMpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMzIsIHZhbCk7XG5cbiAgICAgIGNhc2UgODpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG5cbiAgICAgICAgICAvLyB3ZSBoYW5kbGUgNDgtYml0IGludHMgc2FmZWx5XG4gICAgICAgICAgdmFsID0gZ2V0QmluYXJ5U3RyaW5nKGRhdGFzdHIuc3Vic3RyKDAsIDgpKTtcbiAgICAgICAgICBzaWduID0gaXNTaWduZWQgJiYgdmFsLnN1YnN0cigwLCAxKSA9PT0gJzEnO1xuXG4gICAgICAgICAgLy8gSWYgdGhlc2UgYml0cyBjaGFuZ2UgdGhlIHJlcHJlc2VudGF0aW9uLCB3ZSBjYW4ndFxuICAgICAgICAgIC8vIGNvbXB1dGUgYSB2YWxpZCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICB1bnNhZmVCaXRzID0gcGFyc2VJbnQodmFsLnN1YnN0cigxLCAxNSksIDIpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIG51bWJlciBpcyBub3Qgc2lnbmVkLCBlbmZvcmNlIGJpdHMgMS0xNSA9PT0gMC5cbiAgICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIGlzIHNpZ25lZCBhbmQgbmVnYXRpdmUsIGVuZm9yY2UgYml0cyAxLTE1ID09PSAxLlxuICAgICAgICAgIGlmICgoIXNpZ24gJiYgKHVuc2FmZUJpdHMgIT09IDApKSB8fFxuICAgICAgICAgICAgKHNpZ24gJiYgKHVuc2FmZUJpdHMgIT09IDB4N0ZGRikpKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBTRFRVbnN1cHBvcnRlZFZhbHVlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgU0RUVmFsdWVFcnJvclN1YmNvZGUuVkFMVUVfT1VUU0lERV9TVVBQT1JURURfUkFOR0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhc3RyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWwgPSBwYXJzZUludCh2YWwuc3Vic3RyKDE2LCA0OCksIDIpO1xuICAgICAgICAgIGlmIChzaWduKSB7XG4gICAgICAgICAgICAvLyBuZWdhdGl2ZSAodHdvJ3MgY29tcGxlbWVudCkgbnVtYmVyXG4gICAgICAgICAgICB2YWwgLT0gQ18yXzQ4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZpZWxkID0gY3JlYXRlRmllbGQoaXNTaWduZWQgPyBTRFRGaWVsZFR5cGUuSU5UNjQgOiBTRFRGaWVsZFR5cGUuVUlOVDY0LCB2YWwpO1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZmllbGQuc2V0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXJzZUludGVnZXIgPSBQYXJzZUludGVnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLWludGVnZXIuanMiLCJjb25zdCBEZWJ1Z0xpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZWJ1ZycpO1xuY29uc3QgeyBTb2xhY2VFcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+XG4gKlxuICogUmVwcmVzZW50cyBhIFNEVCB1bnN1cHBvcnRlZCB2YWx1ZSBlcnJvci4gIEFuIFNEVCBmaWVsZCB3YXMgYXNzaWduZWQgYSB2YWx1ZSB0aGF0IGlzIHdpdGhpblxuICogdGhlIHR5cGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBTRFQgdHlwZSwgYnV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybS9ydW50aW1lLlxuICogVGhpcyBvY2N1cnMgd2hlbiBhIHJlY2VpdmVkIHtAbGluayBzb2xhY2UuU0RUQ29udGFpbmVyTWFwfSBvciB7QGxpbmsgc29sYWNlLlNEVENvbnRhaW5lclN0cmVhbX1cbiAqIGNvbnRhaW5zIGEgZmllbGQgd2l0aCBhIHZhbHVlIHRoYXQgY2FuIG5vdCByZXByZXNlbnRlZCBpbiB0aGUgbG9jYWwgYXJjaGl0ZWN0dXJlLlxuICogUG9zc2libGUgY2F1c2VzIGluY2x1ZGU6XG4gKiAqIHJlY2VpdmUgNjQgYml0IGludGVnZXIgdGhhdCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYWNjdXJhdGVseSBpbiBhIGphdmFTY3JpcHQgbnVtYmVyLiBKYXZhU2NyaXB0XG4gKiAgIG51bWJlcnMgYXJlIGZsb2F0cyBhbmQgY2FuIG9ubHkgaG9sZCBhIDQ4IGJpdCBpbnRlZ2VyIHdpdGhvdXQgbG9zcyBvZiBwcmVjaXNzaW9uLiBBbnkgaW50ZWdlclxuICogICBncmVhdGVyIHRoYW4gMjgxNDc0OTc2NzEwNjU1IG9yIGxlc3MgdGhhbiAtMjgxNDc0OTc2NzEwNjU1IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24uXG4gKiBAZXh0ZW5kcyBzb2xhY2UuU29sYWNlRXJyb3JcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yIGV4dGVuZHMgU29sYWNlRXJyb3Ige1xuICAvKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXJyb3JcbiAgICogQHBhcmFtIHtTRFRWYWx1ZUVycm9yU3ViY29kZX0gc3ViY29kZSBUaGUgc3ViY29kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlcnJvclxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlRGF0YSBUaGUgb3JpZ2luYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdWJjb2RlLCBzb3VyY2VEYXRhKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgICAqIEBuYW1lIHNvbGFjZS5TRFRVbnN1cHBvcnRlZFZhbHVlRXJyb3IjbmFtZVxuICAgICAqIEB0eXBlIHtDb25zdGFudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gJ1NEVFVuc3VwcG9ydGVkVmFsdWUnXG4gICAgICovXG4gICAgc3VwZXIoJ1NEVFVuc3VwcG9ydGVkVmFsdWUnLCBtZXNzYWdlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ViY29kZSBmb3IgdGhlIGVycm9yLiBzZWUge0BsaW5rIHNvbGFjZS5TRFRWYWx1ZUVycm9yU3ViY29kZX1cbiAgICAgKiBAbmFtZSBzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yI3N1YmNvZGVcbiAgICAgKiBAdHlwZSB7c29sYWNlLlNEVFZhbHVlRXJyb3JTdWJjb2RlfVxuICAgICAqL1xuICAgIHRoaXMuc3ViY29kZSA9IHN1YmNvZGU7XG4gICAgdGhpcy5zb3VyY2VEYXRhID0gc291cmNlRGF0YSB8fCAnJztcbiAgfVxuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmluc3BlY3Qoe1xuICAgICAgc3ViY29kZTogICAgbnVsbCxcbiAgICAgIHNvdXJjZURhdGE6IHYgPT4gRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKHYsIGZhbHNlLCAwKSxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFN1YmNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViY29kZTtcbiAgfVxuXG4gIGdldFNvdXJjZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlRGF0YTtcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvciA9IFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvc2R0LXVuc3VwcG9ydGVkLXZhbHVlLWVycm9yLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiB7QGxpbmsgc29sYWNlLlNEVFVuc3Vwb3J0ZWRWYWx1ZUVycm9yfSBjYXVzZXMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBTRFRWYWx1ZUVycm9yU3ViY29kZSA9IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgdmFsdWUgZm9yIHRoaXMgZmllbGQgbWF5IGJlIHZhbGlkIG9uIG90aGVyIHBsYXRmb3JtcywgYnV0IGlzIG91dHNpZGUgdGhlXG4gICAqIHJhbmdlIHRoYXQgaXMgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0gZm9yIHRoZSBnaXZlbiB0eXBlLlxuICAgKi9cbiAgVkFMVUVfT1VUU0lERV9TVVBQT1JURURfUkFOR0U6IDEsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TRFRWYWx1ZUVycm9yU3ViY29kZSA9IEVudW0ubmV3KFNEVFZhbHVlRXJyb3JTdWJjb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvc2R0LXZhbHVlLWVycm9yLXN1YmNvZGVzLmpzIiwiLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogRW5jYXBzdWxhdGVzIHRoZSBzZXNzaW9uJ3MgbWVzc2FnZSByZWNlaXZlIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZFxuICogYW4gb3B0aW9uYWwgdXNlci1zcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgcGFzc2VkIHRvIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVTZXNzaW9ufSB3aGVuIGNyZWF0aW5nIGEgc2Vzc2lvbi5cbiAqIEBkZXByZWNhdGVkIFRoZSB7QGxpbmsgc29sYWNlLlNlc3Npb259IGlzIGFuIDxiPkV2ZW50RW1pdHRlcjwvYj4uXG4gKiBVc2UgPHR0PnNlc3Npb25PYmplY3Qub24oe0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLk1FU1NBR0V9KTwvdHQ+IGluc3RlYWQuXG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBNZXNzYWdlUnhDQkluZm8ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1lc3NhZ2VSeENCSW5mby5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihTZXNzaW9uLCBNZXNzYWdlLCBPYmplY3QpfSBtZXNzYWdlUnhDQkZ1bmN0aW9uXG4gICAqICAgICAgICAgIEludm9rZWQgYnkgdGhlIEFQSSB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgKiAgICAgICAgICBvdmVyIHRoZSBzZXNzaW9uLiBUaGUgcHJvdG90eXBlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlXG4gICAqICAgICAgICAgIGZvbGxvd2luZzogKHtAbGluayBzb2xhY2UuU2Vzc2lvbn0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBzb2xhY2UuTWVzc2FnZX0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9KVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXNlck9iamVjdFxuICAgKiAgICAgICAgICBBbiBvcHRpb25hbCB1c2VyLXNwZWNpZmllZCBvYmplY3QgcGFzc2VkIG9uIGV2ZXJ5IG1lc3NhZ2UgcmVjZWl2ZSBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIHNvbGFjZVxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZVJ4Q0JGdW5jdGlvbiwgdXNlck9iamVjdCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihTZXNzaW9uLCBNZXNzYWdlLCBPYmplY3QpfVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgcHJvdG90eXBlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlXG4gICAgICogZm9sbG93aW5nOiAoe0BsaW5rIHNvbGFjZS5TZXNzaW9ufSwge0BsaW5rIHNvbGFjZS5NZXNzYWdlfSwgdXNlck9iamVjdCB7T2JqZWN0fSlcbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2VSeENCRnVuY3Rpb24gPSBtZXNzYWdlUnhDQkZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gdXNlci1zcGVjaWZpZWQgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy51c2VyT2JqZWN0ID0gdXNlck9iamVjdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlUnhDQkluZm8gPSBNZXNzYWdlUnhDQkluZm87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9tZXNzYWdlLXJ4LWNiLWluZm8uanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW51bWVyYXRpb24gb2Ygc2Vzc2lvbiBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIG1vZGlmaWVkIGJ5XG4gKiB7QGxpbmsgc29sYWNlLlNlc3Npb24udXBkYXRlUHJvcGVydHl9IGFmdGVyIHRoZSB7QGxpbmsgc29sYWNlLlNlc3Npb259IGlzIG9yaWdpbmFsbHlcbiAqIGNyZWF0ZWQuXG4gKlxuICogVGhlc2UgY29ycmVzcG9uZCB0byBzZXNzaW9uIHByb3BlcnRpZXMgaW4ge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllc30uXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBNdXRhYmxlU2Vzc2lvblByb3BlcnR5ID0ge1xuICAvKipcbiAgICogQ2xpZW50IG5hbWU6IHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjY2xpZW50TmFtZX1cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIENMSUVOVF9OQU1FOiAgICAgICAgMSxcbiAgLyoqXG4gICAqIEFwcGxpY2F0aW9uIGRlc2NyaXB0aW9uOiB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2FwcGxpY2F0aW9uRGVzY3JpcHRpb259XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBDTElFTlRfREVTQ1JJUFRJT046IDIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5NdXRhYmxlU2Vzc2lvblByb3BlcnR5ID0gRW51bS5uZXcoTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9tdXRhYmxlLXNlc3Npb24tcHJvcGVydGllcy5qcyIsImNvbnN0IFAyUFV0aWwgPSB7XG4gIGdldFAyUEluYm94VG9waWMoYmFzZSkge1xuICAgIHJldHVybiAoYCR7YmFzZX0vI2ApO1xuICB9LFxuICBnZXRQMlBUb3BpY1N1YnNjcmlwdGlvbihiYXNlKSB7XG4gICAgcmV0dXJuIChgJHtiYXNlfS8+YCk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5QMlBVdGlsID0gUDJQVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL3AycC11dGlsLmpzIiwiLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIHNlc3Npb24ncyBldmVudCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgYW4gb3B0aW9uYWwgdXNlci1zcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgcGFzc2VkIHRvIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVTZXNzaW9ufSB3aGVuIGNyZWF0aW5nIGEgc2Vzc2lvbi5cbiAqIEBkZXByZWNhdGVkIFRoZSB7QGxpbmsgc29sYWNlLlNlc3Npb259IGlzIGFuIDxiPkV2ZW50RW1pdHRlcjwvYj4uICBSZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICogYWdhaW5zdCB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGV9IGV2ZW50cyBpbnN0ZWFkLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuXG5jbGFzcyBTZXNzaW9uRXZlbnRDQkluZm8ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNlc3Npb25FdmVudENCSW5mby5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihTZXNzaW9uLCBTZXNzaW9uRXZlbnQsIE9iamVjdCwgT2JqZWN0KX0gc2Vzc2lvbkV2ZW50Q0JGdW5jdGlvblxuICAgKiAgaW52b2tlZCBieSB0aGUgTWVzc2FnaW5nIEFQSSB3aGVuIGEgc2Vzc2lvbiBldmVudCBvY2N1cnMuIFRoZSBwcm90b3R5cGVcbiAgICogIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGZvbGxvd2luZzogKHtAbGluayBzb2xhY2UuU2Vzc2lvbn0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fX0pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT2JqZWN0IEFuIG9wdGlvbmFsIHVzZXItc3BlY2lmaWVkIG9iamVjdCBwYXNzZWQgb25cbiAgICogZXZlcnkgc2Vzc2lvbiBldmVudCBjYWxsYmFjay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlc3Npb25FdmVudENCRnVuY3Rpb24sIHVzZXJPYmplY3QpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiB1c2VyLXNwZWNpZmllZCBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLnVzZXJPYmplY3QgPSB1c2VyT2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgcHJvdG90eXBlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdGhlXG4gICAgICogZm9sbG93aW5nOlxuICAgICAqICh7QGxpbmsgc29sYWNlLlNlc3Npb259LCB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudH0sXG4gICAgICogdXNlck9iamVjdCB7T2JqZWN0fSwgUkZVT2JqZWN0IHtPYmplY3R9KVxuICAgICAqL1xuICAgIHRoaXMuc2Vzc2lvbkV2ZW50Q0JGdW5jdGlvbiA9IHNlc3Npb25FdmVudENCRnVuY3Rpb247XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuU2Vzc2lvbkV2ZW50Q0JJbmZvID0gU2Vzc2lvbkV2ZW50Q0JJbmZvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1ldmVudC1jYi1pbmZvLmpzIiwiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgRnNtRXZlbnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mc20nKTtcbmNvbnN0IHsgSGV4IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuXG5jb25zdCB7IGZvcm1hdEhleFN0cmluZyB9ID0gSGV4O1xuLyoqXG4gKiBTZXNzaW9uRlNNRXZlbnQgZXh0ZW5kcyB7QGxpbmsgRnNtRXZlbnR9LiAgVGhpcyBvYmplY3Qgc2hvdWxkIGJlIHVzZWQgZm9yIGFsbCBldmVudHNcbiAqIHBhc3NlZCB0byB0aGUgU2Vzc2lvbkZTTS4gIFRoaXMgZXh0ZW5zaW9uIHByb3ZpZGVzIG1lbWJlcnMgdG8gY2FycnkgaW5mb3JtYXRpb24gc3BlY2ZpYyB0b1xuICogdGhlIFNlc3Npb25GU00gdHJhbnNpdGlvbnMuXG4gKiBAZXh0ZW5kcyBGc21FdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2Vzc2lvbkZTTUV2ZW50IGV4dGVuZHMgRnNtRXZlbnQge1xuICBjb25zdHJ1Y3RvcihzcGVjLCBmaWVsZHMpIHtcbiAgICBzdXBlcihzcGVjKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbmZvcm1hdGlvbiBTdHJpbmcgZm9yIHRoZSB7U2Vzc2lvbkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRUZXh0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RXJyb3JTdWJjb2RlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgU29sYWNlIEVycm9yU3ViY29kZSBmb3IgYW55IGdlbmVyYXRlZCB7U2Vzc2lvbkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JTdWJjb2RlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgcmVhc29uIHN0cmluZyB0byBiZSBpbmNsdWRlZCBpbiBhbnkgZ2VuZXJhdGVkIHtTZXNzaW9uRXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5ldmVudFJlYXNvbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1RyYW5zcG9ydFNNRk1lc3NhZ2V9XG4gICAgICogQGRlc2NyaXB0aW9uIEEgZGVjb2RlZCBTTUYgbWVzc2FnZSByZWNlaXZlZCBmcm9tIHRoZSB0cmFuc3BvcnQuIE1heSBiZVxuICAgICAqIGVpdGhlciBhIHtDbGllbnRDdHJsTWVzc2FnZX0gb3IgYSB7U01QTWVzc2FnZX1cbiAgICAgKi9cbiAgICB0aGlzLnNtZk1zZyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIFRyYW5zcG9ydCBTZXNzaW9uSWQgcmV0cmlldmVkIGZyb20gYSB7VHJhbnNwb3J0U2Vzc2lvbkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMuc2Vzc2lvbklkID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgUHVibGlzaGVyIG9yIENvbnN1bWVyIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggYSBHTSBldmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmd1YXJhbnRlZWRGbG93T2JqZWN0ID0gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZmllbGRzKTtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2V2ZW50VGV4dCc6ICAgIHRoaXMuZXZlbnRUZXh0LFxuICAgICAgJ2V2ZW50UmVhc29uJzogIHRoaXMuZXZlbnRSZWFzb24sXG4gICAgICAnZXJyb3JTdWJjb2RlJzogRXJyb3JTdWJjb2RlLmRlc2NyaWJlKHRoaXMuZXJyb3JTdWJjb2RlKSxcbiAgICAgICdzZXNzaW9uSWQnOiAgICB0aGlzLnNlc3Npb25JZCAmJiBmb3JtYXRIZXhTdHJpbmcodGhpcy5zZXNzaW9uSWQpIHx8ICdOL0EnLFxuICAgIH07XG4gIH1cblxuICBnZXRFeHRyYVN0cmluZ0luZm8oKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uRlNNRXZlbnQgPSBTZXNzaW9uRlNNRXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLWZzbS1ldmVudC5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc2Vzc2lvbiBzdGF0ZVxuICogQGVudW0ge3N0cmluZ31cbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFNlc3Npb25TdGF0ZU5hbWUgPSB7XG4gIERJU0NPTk5FQ1RFRDogICAgICAgICAgICAgICAgICAgICAnU2Vzc2lvbkRpc2Nvbm5lY3RlZCcsXG4gIENPTk5FQ1RJTkc6ICAgICAgICAgICAgICAgICAgICAgICAnU2Vzc2lvbkNvbm5lY3RpbmcnLFxuICBXQUlUSU5HX0ZPUl9UUkFOU1BPUlQ6ICAgICAgICAgICAgJ1dhaXRpbmdGb3JUcmFuc3BvcnQnLFxuICBXQUlUSU5HX0ZPUl9UUkFOU1BPUlRfVVA6ICAgICAgICAgJ1dhaXRpbmdGb3JUcmFuc3BvcnRVcCcsXG4gIFdBSVRJTkdfRk9SX0xPR0lOOiAgICAgICAgICAgICAgICAnV2FpdGluZ0ZvckxvZ2luJyxcbiAgVFJBTlNQT1JUX1VQOiAgICAgICAgICAgICAgICAgICAgICdTZXNzaW9uVHJhbnNwb3J0VXAnLFxuICBGVUxMWV9DT05ORUNURUQ6ICAgICAgICAgICAgICAgICAgJ1Nlc3Npb25GdWxseUNvbm5lY3RlZCcsXG4gIFNFU1NJT05fRVJST1I6ICAgICAgICAgICAgICAgICAgICAnU2Vzc2lvbkVycm9yJyxcbiAgRElTQ09OTkVDVElORzogICAgICAgICAgICAgICAgICAgICdTZXNzaW9uRGlzY29ubmVjdGluZycsXG4gIFJFQVBQTFlJTkdfU1VCU0NSSVBUSU9OUzogICAgICAgICAnUmVhcHBseWluZ1N1YnNjcmlwdGlvbnMnLFxuICBXQUlUSU5HX0ZPUl9QVUJGTE9XOiAgICAgICAgICAgICAgJ1dhaXRpbmdGb3JNZXNzYWdlUHVibGlzaGVyJyxcbiAgRElTUE9TRUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICdTZXNzaW9uRGlzcG9zZWQnLFxuICBXQUlUSU5HX0ZPUl9TVUJDT05GSVJNOiAgICAgICAgICAgJ1dhaXRGb3JTdWJDb25maXJtJyxcbiAgV0FJVElOR19GT1JfQ0FOX0FDQ0VQVF9EQVRBOiAgICAgICdXYWl0Rm9yQ2FuQWNjZXB0RGF0YScsXG4gIERJU0NPTk5FQ1RJTkdfRkxPV1M6ICAgICAgICAgICAgICAnRGlzY29ubmVjdGluZ0Zsb3dzJyxcbiAgRkxVU0hJTkdfVFJBTlNQT1JUOiAgICAgICAgICAgICAgICdGbHVzaGluZ1RyYW5zcG9ydCcsXG4gIERFU1RST1lJTkdfVFJBTlNQT1JUOiAgICAgICAgICAgICAnRGVzdHJveWluZ1RyYW5zcG9ydCcsXG4gIFJFQ09OTkVDVElORzogICAgICAgICAgICAgICAgICAgICAnUmVjb25uZWN0aW5nJyxcbiAgVFJBTlNQT1JUX0ZBSUw6ICAgICAgICAgICAgICAgICAgICdUcmFuc3BvcnRGYWlsJyxcbiAgV0FJVElOR19GT1JfSU5URVJDT05ORUNUX1RJTUVPVVQ6ICdXYWl0aW5nRm9ySW50ZXJjb25uZWN0VGltZW91dCcsXG4gIFdBSVRJTkdfRk9SX0ROUzogICAgICAgICAgICAgICAgICAnV2FpdGluZ0ZvckROUycsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uU3RhdGVOYW1lID0gRW51bS5uZXcoU2Vzc2lvblN0YXRlTmFtZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXN0YXRlLW5hbWVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgU2Vzc2lvblN0YXRlID0ge1xuICAvKipcbiAgICogVGhlIHNlc3Npb24gaXMgY29ubmVjdGluZy5cbiAgICovXG4gIENPTk5FQ1RJTkc6ICAgIDEsXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiBpcyBjb25uZWN0ZWQuXG4gICAqL1xuICBDT05ORUNURUQ6ICAgICAyLFxuICAvKipcbiAgICogVGhlIHNlc3Npb24gZXhwZXJpZW5jZWQgYW4gZXJyb3IuXG4gICAqL1xuICBTRVNTSU9OX0VSUk9SOiAzLFxuICAvKipcbiAgICogVGhlIHNlc3Npb24gaXMgZGlzY29ubmVjdGluZy5cbiAgICovXG4gIERJU0NPTk5FQ1RJTkc6IDQsXG4gIC8qKlxuICAgKiBUaGUgc2Vzc2lvbiBpcyBkaXNjb25uZWN0ZWQuXG4gICAqL1xuICBESVNDT05ORUNURUQ6ICA1LFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uU3RhdGUgPSBFbnVtLm5ldyhTZXNzaW9uU3RhdGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi1zdGF0ZXMuanMiLCJjb25zdCBTTUZMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5jb25zdCB7IEFkUHJvdG9jb2xNZXNzYWdlLCBTTUZQYXJhbWV0ZXIgfSA9IHJlcXVpcmUoJy4uL21lc3NhZ2Utb2JqZWN0cycpO1xuY29uc3QgeyBCaXRzLCBDb252ZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuY29uc3QgeyBMT0dfREVCVUcsIExPR19JTkZPLCBMT0dfRVJST1IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbi8vIGNvbnN0IHsgU01GQWRQcm90b2NvbFBhcmFtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5cbmNvbnN0IHtcbiAgZ2V0OiBiaXRzLFxuICBzZXQ6IHNldEJpdHMsXG59ID0gQml0cztcblxuY29uc3Qge1xuICBpbnQ4VG9TdHIsIHN0clRvSW50OCxcbiAgaW50MTZUb1N0ciwgc3RyVG9JbnQxNixcbiAgaW50MjRUb1N0cixcbiAgaW50MzJUb1N0ciwgc3RyVG9VSW50MzIsXG59ID0gQ29udmVydDtcblxuZnVuY3Rpb24gcGFyc2VBZHBBdChkYXRhLCBvZmZzZXQpIHtcbiAgaWYgKChvZmZzZXQgKyAzKSA+IGRhdGEubGVuZ3RoKSB7XG4gICAgLy9ub3QgZW5vdWdoIGRhdGFcbiAgICBMT0dfREVCVUcoJ05vdCBlbm91Z2ggZGF0YSB0byByZWFkIGFuIEFEUCBtZXNzYWdlLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgcG9zID0gb2Zmc2V0O1xuICBsZXQgb25lYnl0ZSA9IHN0clRvSW50OChkYXRhLnN1YnN0cihwb3MsIDEpKTtcbiAgcG9zKys7XG5cbiAgLy8gdmFyIG1zZ1JGVSA9IGJpdHMob25lYnl0ZSwgNiwgMik7XG4gIGNvbnN0IGFkcFZlcnNpb24gPSBiaXRzKG9uZWJ5dGUsIDAsIDYpO1xuICBsZXQgbXNnTGVuZ3RoO1xuICBsZXQgbXNnVHlwZTtcbiAgaWYgKGFkcFZlcnNpb24gPCAzKSB7XG4gICAgY29uc3QgdHdvYnl0ZSA9IHN0clRvSW50MTYoZGF0YS5zdWJzdHIocG9zLCAyKSk7XG4gICAgcG9zICs9IDI7XG4gICAgbXNnVHlwZSA9IGJpdHModHdvYnl0ZSwgMTIsIDQpO1xuICAgIC8vIGxlbmd0aCBpbiAzMiBiaXQgd29yZHMgaXMgaW4gdGhlIGxvd2VyIDEyIGJpdHNcbiAgICBtc2dMZW5ndGggPSBiaXRzKHR3b2J5dGUsIDAsIDEyKTtcbiAgICAvLyBjb252ZXJ0IGxlbmd0aCB0byBudW1iZXIgb2YgYnl0ZXNcbiAgICBtc2dMZW5ndGggPDw9IDI7XG4gIH0gZWxzZSBpZiAoYWRwVmVyc2lvbiA9PT0gMykge1xuICAgIG9uZWJ5dGUgPSBzdHJUb0ludDgoZGF0YVtwb3NdKTtcbiAgICBwb3MrKztcbiAgICBtc2dUeXBlID0gYml0cyhvbmVieXRlLCAwLCA4KTtcbiAgICBtc2dMZW5ndGggPSBzdHJUb1VJbnQzMihkYXRhLnN1YnN0cihwb3MsIDQpKTtcbiAgICBwb3MgKz0gNDtcbiAgfSBlbHNlIHtcbiAgICBMT0dfRVJST1IoJ0ZvdW5kIHVuc3VwcG9ydGVkIEFEUCBWZXJzaW9uJywgYWRwVmVyc2lvbik7XG4gICAgcmV0dXJuIGZhbHNlOyAvL3Vuc3VwcG9ydGVkIHR5cGVcbiAgfVxuICAvL1xuICAvLyBWZXJpZnkgdGhhdCB0aGUgQURQIGhlYWRlciBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBlbnRpcmVcbiAgLy8gY29udGVudHMgb2YgdGhlIFNNRiBtZXNzYWdlLlxuICBpZiAob2Zmc2V0ICsgbXNnTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICBMT0dfRVJST1IoYEludmFsaWQgQXNzc3VyZWQgQ29udHJvbCBQcm90b2NvbCBsZW5ndGg9JHttc2dMZW5ndGhcbiAgICAgIH0gZXhjZWVkcyByZW1haW5pbmcgbWVzc2FnZSBidWZmZXIgPSAke2RhdGEubGVuZ3RoIC0gb2Zmc2V0fWApO1xuICAgIHJldHVybiBmYWxzZTsgLy8gaW52YWxpZCBtZXNzYWdlIGZvcm1hdFxuICB9XG4gIGNvbnN0IGFkcE1zZyA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShtc2dUeXBlLCBhZHBWZXJzaW9uKTtcbiAgd2hpbGUgKHBvcyA8IChvZmZzZXQgKyBtc2dMZW5ndGgpKSB7XG4gICAgb25lYnl0ZSA9IHN0clRvSW50OChkYXRhLnN1YnN0cihwb3MsIDEpKTtcbiAgICBwb3MrKztcbiAgICBjb25zdCBwYXJhbVVIID0gYml0cyhvbmVieXRlLCA2LCAyKTtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSBiaXRzKG9uZWJ5dGUsIDAsIDYpO1xuXG4gICAgLy8gTG9vayBmb3IgYW5kIHNraXAgcGFkZGluZyBieXRlc1xuICAgIGlmIChwYXJhbVR5cGUgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocG9zID49IChvZmZzZXQgKyBtc2dMZW5ndGgpKSB7XG4gICAgICBMT0dfRVJST1IoYEludmFsaWQgQXNzc3VyZWQgQ29udHJvbCBQcm90b2NvbCBwYXJhbWV0ZXI9JHtwYXJhbVR5cGV9IGF0IHBvc2l0aW9uID0ke3Bvc31gKTtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gQXNzdXJlZCBDb250cm9sIHBhcnNpbmcgZmFpbFxuICAgIH1cbiAgICBsZXQgcGFyYW1MZW4gPSBzdHJUb0ludDgoZGF0YS5zdWJzdHIocG9zLCAxKSk7XG4gICAgbGV0IHBhcmFtVmFsdWVMZW47XG4gICAgcG9zKys7XG4gICAgLy8gSWYgcGFyYW1MZW4gPT0gMCwgdGhlbiB0aGlzIGlzIGFuIGV4dGVuZGVkIGxlbmd0aCBmb3JtYXRcbiAgICAvLyBhbmQgdGhlcmUgaXMgYSA0IGJ5dGUgbGVuZ3RoIGZvbGxvd2luZyB0aGUgJzAnXG4gICAgaWYgKHBhcmFtTGVuID09PSAwKSB7XG4gICAgICAvLyBuZWVkIGF0IGxlYXN0IDUgbW9yZSBieXRlcyBpbiB0aGUgYnVmZmVyXG4gICAgICBpZiAocG9zICsgNSA+IChvZmZzZXQgKyBtc2dMZW5ndGgpKSB7XG4gICAgICAgIExPR19FUlJPUihgSW52YWxpZCBBc3NzdXJlZCBDb250cm9sIFByb3RvY29sIHBhcmFtZXRlcj0ke3BhcmFtVHlwZX0gYXQgcG9zaXRpb24gPSR7cG9zfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEFzc3VyZWQgQ29udHJvbCBwYXJzaW5nIGZhaWxcbiAgICAgIH1cbiAgICAgIHBhcmFtTGVuID0gc3RyVG9VSW50MzIoZGF0YS5zdWJzdHIocG9zLCA0KSk7XG4gICAgICBwb3MgKz0gNDtcbiAgICAgIHBhcmFtVmFsdWVMZW4gPSBwYXJhbUxlbiAtIDU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtVmFsdWVMZW4gPSBwYXJhbUxlbiAtIDI7XG4gICAgfVxuICAgIGlmIChwYXJhbUxlbiA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEFzc3VyZWQgQ29udHJvbCBwYXJzaW5nIGZhaWxcbiAgICB9XG4gICAgLy9cbiAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgZW5vdWdoIGJ1ZmZlciBmb3IgcGFyYW1WYWx1ZUxlblxuICAgIGlmIChwb3MgKyBwYXJhbVZhbHVlTGVuID4gb2Zmc2V0ICsgbXNnTGVuZ3RoKSB7XG4gICAgICBMT0dfRVJST1IoYEludmFsaWQgQXNzc3VyZWQgQ29udHJvbCBQcm90b2NvbCBwYXJhbWV0ZXI9JHtwYXJhbVR5cGVcbiAgICAgICAgfSBsZW5ndGggPSR7cGFyYW1WYWx1ZUxlbn0gaW52YWxpZCBhdCBwb3NpdGlvbiA9JHtwb3N9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEFzc3VyZWQgQ29udHJvbCBwYXJzaW5nIGZhaWxcbiAgICB9XG4gICAgY29uc3QgcGFyYW1WYWx1ZSA9IGRhdGEuc3Vic3RyKHBvcywgcGFyYW1WYWx1ZUxlbik7XG4gICAgYWRwTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKHBhcmFtVUgsIHBhcmFtVHlwZSwgcGFyYW1WYWx1ZSkpO1xuICAgIHBvcyArPSBwYXJhbVZhbHVlTGVuO1xuICB9XG4gIHJldHVybiBhZHBNc2c7XG59XG5cbmZ1bmN0aW9uIGVuY0FkcDhQYXJhbSh1aCwgcGFyYW10eXBlLCB2YWx1ZSkge1xuICBjb25zdCBkYXRhID0gW107XG4gIGxldCBieXRlMSA9IDA7XG5cbiAgYnl0ZTEgPSBCaXRzLnNldChieXRlMSwgdWgsIDYsIDIpO1xuICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCBwYXJhbXR5cGUsIDAsIDYpO1xuICBkYXRhLnB1c2goQ29udmVydC5pbnQ4VG9TdHIoYnl0ZTEpKTtcbiAgZGF0YS5wdXNoKENvbnZlcnQuaW50OFRvU3RyKDMpKTsgLy8gbGVuZ3RoXG4gIGRhdGEucHVzaChDb252ZXJ0LmludDhUb1N0cih2YWx1ZSkpO1xuICByZXR1cm4gZGF0YS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZW5jQWRwMTZQYXJhbSh1aCwgcGFyYW10eXBlLCB2YWx1ZSkge1xuICBjb25zdCBkYXRhID0gW107XG4gIGxldCBieXRlMSA9IDA7XG5cbiAgYnl0ZTEgPSBCaXRzLnNldChieXRlMSwgdWgsIDYsIDIpO1xuICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCBwYXJhbXR5cGUsIDAsIDYpO1xuICBkYXRhLnB1c2goQ29udmVydC5pbnQ4VG9TdHIoYnl0ZTEpKTtcbiAgZGF0YS5wdXNoKENvbnZlcnQuaW50OFRvU3RyKDQpKTsgLy8gbGVuZ3RoXG4gIGRhdGEucHVzaChDb252ZXJ0LmludDE2VG9TdHIodmFsdWUpKTtcbiAgcmV0dXJuIGRhdGEuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVuY0FkcDMyUGFyYW0odWgsIHBhcmFtdHlwZSwgdmFsdWUpIHtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgYnl0ZTEgPSAwO1xuXG4gIGJ5dGUxID0gQml0cy5zZXQoYnl0ZTEsIHVoLCA2LCAyKTtcbiAgYnl0ZTEgPSBCaXRzLnNldChieXRlMSwgcGFyYW10eXBlLCAwLCA2KTtcbiAgZGF0YS5wdXNoKENvbnZlcnQuaW50OFRvU3RyKGJ5dGUxKSk7XG4gIGRhdGEucHVzaChDb252ZXJ0LmludDhUb1N0cig2KSk7IC8vIGxlbmd0aFxuICBkYXRhLnB1c2goQ29udmVydC5pbnQzMlRvU3RyKHZhbHVlKSk7XG4gIHJldHVybiBkYXRhLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBlbmNBZHA2NFBhcmFtKHVoLCBwYXJhbXR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgbGV0IGJ5dGUxID0gMDtcblxuICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCB1aCwgNiwgMik7XG4gIGJ5dGUxID0gQml0cy5zZXQoYnl0ZTEsIHBhcmFtdHlwZSwgMCwgNik7XG4gIGRhdGEucHVzaChDb252ZXJ0LmludDhUb1N0cihieXRlMSkpO1xuICBkYXRhLnB1c2goQ29udmVydC5pbnQ4VG9TdHIoMTApKTsgLy8gbGVuZ3RoXG4gIGRhdGEucHVzaChDb252ZXJ0LmludDY0VG9TdHIodmFsdWUpKTtcbiAgcmV0dXJuIGRhdGEuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVuY0FkcDY0QWNrUGFpclBhcmFtKHVoLCBwYXJhbXR5cGUsIG1pbiwgbWF4KSB7XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgbGV0IGJ5dGUxID0gMDtcbiAgYnl0ZTEgPSBCaXRzLnNldChieXRlMSwgdWgsIDYsIDIpO1xuICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCBwYXJhbXR5cGUsIDAsIDYpO1xuICBkYXRhLnB1c2goQ29udmVydC5pbnQ4VG9TdHIoYnl0ZTEpKTtcbiAgZGF0YS5wdXNoKENvbnZlcnQuaW50OFRvU3RyKDE4KSk7IC8vIGxlbmd0aFxuICBkYXRhLnB1c2goQ29udmVydC5pbnQ2NFRvU3RyKG1pbikpO1xuICBkYXRhLnB1c2goQ29udmVydC5pbnQ2NFRvU3RyKG1heCkpO1xuICByZXR1cm4gZGF0YS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZW5jQWRwVVRGOE5UUGFyYW0odWgsIHBhcmFtdHlwZSwgdmFsdWUpIHtcbiAgLy8gdmFsdWUgaXMgYWxyZWFkeSBVVEY4IGVuY29kZWQgYW5kIG51bGwgdGVybWluYXRlZC5cbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgYnl0ZTEgPSAwO1xuICBieXRlMSA9IEJpdHMuc2V0KGJ5dGUxLCB1aCwgNiwgMik7XG4gIGJ5dGUxID0gQml0cy5zZXQoYnl0ZTEsIHBhcmFtdHlwZSwgMCwgNik7XG4gIGRhdGEucHVzaChDb252ZXJ0LmludDhUb1N0cihieXRlMSkpO1xuXG4gIGxldCBieXRlMiA9IDA7XG4gIGlmICh2YWx1ZS5sZW5ndGggPD0gMjUzKSB7XG4gICAgYnl0ZTIgPSB2YWx1ZS5sZW5ndGggKyAyOyAvLyBmdWxsIGxlbmd0aCBvZiBwYXJhbVxuICAgIGRhdGEucHVzaChDb252ZXJ0LmludDhUb1N0cihieXRlMikpO1xuICB9IGVsc2Uge1xuICAgIGJ5dGUyID0gMDsgLy8gZXh0ZW5kZWQtbGVuZ3RoXG4gICAgZGF0YS5wdXNoKENvbnZlcnQuaW50OFRvU3RyKGJ5dGUyKSk7XG4gICAgZGF0YS5wdXNoKENvbnZlcnQuaW50MzJUb1N0cih2YWx1ZS5sZW5ndGggKyA1KSk7XG4gIH1cbiAgZGF0YS5wdXNoKHZhbHVlKTtcbiAgcmV0dXJuIGRhdGEuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGVuY0FkcChhZHBNc2cpIHtcbiAgY29uc3QgcGFyYW1zcGFjZSA9IFtdO1xuICBjb25zdCBwYXJhbWFycmF5ID0gYWRwTXNnLmdldFBhcmFtZXRlckFycmF5KCk7XG5cbiAgbGV0IHA7XG4gIGxldCBieXRlMSA9IDA7XG4gIGZvciAocCA9IDA7IHAgPCBwYXJhbWFycmF5Lmxlbmd0aDsgcCsrKSB7XG4gICAgY29uc3QgcGFyYW0gPSBwYXJhbWFycmF5W3BdO1xuICAgIC8vIEl0J3Mgbm90IGEgZmxhdCBhcnJheSwgd2UgaGF2ZSBnYXBzIVxuICAgIGlmIChwYXJhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHBhcmFtLmdldFR5cGUoKSkge1xuICAgICAgLypcbiAgICAgICAqIDggYml0IHBhcmFtZXRlcnNcbiAgICAgICAqL1xuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLldJTkRPVzpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5FUF9EVVJBQkxFOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLkFDQ0VTU1RZUEU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRkxPV1RZUEU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRVBfUkVTUEVDVFNfVFRMOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLlRSQU5TQUNUSU9OX0NUUkxfTUVTU0FHRV9UWVBFOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLlRSQU5TQUNURURfU0VTU0lPTl9TVEFURTpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5BQ1RJVkVfRkxPV19JTkRJQ0FUSU9OOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLldBTlRfRkxPV19DSEFOR0VfTk9USUZZOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLk1BWF9SRURFTElWRVJZOlxuICAgICAgICBwYXJhbXNwYWNlLnB1c2goZW5jQWRwOFBhcmFtKHBhcmFtLmdldFVoKCksIHBhcmFtLmdldFR5cGUoKSwgcGFyYW0uZ2V0VmFsdWUoKSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8qXG4gICAgICAgKiAxNiBiaXQgcGFyYW1ldGVyc1xuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRVBfQkVIQVZJT1VSOlxuICAgICAgICBwYXJhbXNwYWNlLnB1c2goZW5jQWRwMTZQYXJhbShwYXJhbS5nZXRVaCgpLCBwYXJhbS5nZXRUeXBlKCksIHBhcmFtLmdldFZhbHVlKCkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvKlxuICAgICAgICogMzIgYml0IHBhcmFtZXRlcnNcbiAgICAgICAqL1xuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLkZMT1dJRDpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5UUkFOU1BPUlRfV0lORE9XOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLkVQX0FMTE9USEVSX1BFUk1JU1NJT046XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRVBfUVVPVEE6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRVBfTUFYX01TR1NJWkU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uR1JBTlRFRF9QRVJNSVNTSU9OOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLlRSQU5TQUNURURfU0VTU0lPTl9JRDpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5QVUJMSVNIRVJfSUQ6XG4gICAgICAgIHBhcmFtc3BhY2UucHVzaChlbmNBZHAzMlBhcmFtKHBhcmFtLmdldFVoKCksIHBhcmFtLmdldFR5cGUoKSwgcGFyYW0uZ2V0VmFsdWUoKSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8qXG4gICAgICAgKiA2NCBiaXQgcGFyYW1ldGVyc1xuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uTEFTVE1TR0lEU0VOVDpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURBQ0tFRDpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURSRUNFSVZFRDpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5UUkFOU0FDVElPTl9JRDpcbiAgICAgICAgcGFyYW1zcGFjZS5wdXNoKGVuY0FkcDY0UGFyYW0ocGFyYW0uZ2V0VWgoKSwgcGFyYW0uZ2V0VHlwZSgpLCBwYXJhbS5nZXRWYWx1ZSgpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLypcbiAgICAgICAqIGFwcGxpY2F0aW9uIGFja1xuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uQVBQTElDQVRJT05fQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVW5wYWNrIHRoaXMgdG8gbXVsdGlwbGUgcGFyYW1ldGVyc1xuICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IHBhcmFtLmdldFZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgdWggPSBwYXJhbS5nZXRVaCgpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbS5nZXRUeXBlKCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgcGFyYW1zcGFjZS5wdXNoKGVuY0FkcDY0QWNrUGFpclBhcmFtKHVoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VbMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiBzdHJpbmcgYW5kIG90aGVyIHZhcmlhYmxlIGxlbmd0aCBwYXJhbWV0ZXJzXG4gICAgICAgKi9cbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5RVUVVRU5BTUU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRFRFTkFNRTpcbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5UT1BJQ05BTUU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uRkxPV05BTUU6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uU0VMRUNUT1I6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uVFJBTlNBQ1RFRF9TRVNTSU9OX05BTUU6XG4gICAgICAgIHBhcmFtc3BhY2UucHVzaChlbmNBZHBVVEY4TlRQYXJhbShwYXJhbS5nZXRVaCgpLCBwYXJhbS5nZXRUeXBlKCksIHBhcmFtLmdldFZhbHVlKCkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvKlxuICAgICAgICogVHJhbnNhY3Rpb24gUHVibGlzaGVyIE5vdGlmeVxuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uVFJBTlNBQ1RJT05fRkxPV19ERVNDUklQVE9SX1BVQl9OT1RJRlk6XG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIGJyZWFrO1xuICAgICAgLypcbiAgICAgICAqIFRyYW5zYWN0aW9uIFB1Ymxpc2hlciBBY2tcbiAgICAgICAqL1xuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLlRSQU5TQUNUSU9OX0ZMT1dfREVTQ1JJUFRPUl9QVUJfQUNLOlxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICBicmVhaztcbiAgICAgIC8qXG4gICAgICAgKiBUcmFuc2FjdGlvbiBTdWJzY3JpYmVyIEFja1xuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uVFJBTlNBQ1RJT05fRkxPV19ERVNDUklQVE9SX1NVQl9BQ0s6XG4gICAgICAgIC8vIFRPRE86XG4gICAgICAgIGJyZWFrO1xuICAgICAgLypcbiAgICAgICAqIE5vIExvY2FsIFBhcmFtZXRlciBoYXMgbm8gZGF0YVxuICAgICAgICogQ3V0IFRocm91Z2ggUGFyYW1ldGVyIGhhcyBubyBkYXRhXG4gICAgICAgKi9cbiAgICAgIGNhc2UgU01GTGliLlNNRkFkUHJvdG9jb2xQYXJhbS5OT0xPQ0FMOlxuICAgICAgY2FzZSBTTUZMaWIuU01GQWRQcm90b2NvbFBhcmFtLkNVVF9USFJPVUdIOlxuICAgICAgICBieXRlMSA9IHNldEJpdHMoYnl0ZTEsIHBhcmFtLmdldFVoKCksIDYsIDIpO1xuICAgICAgICBieXRlMSA9IHNldEJpdHMoYnl0ZTEsIHBhcmFtLmdldFR5cGUoKSwgMCwgNik7XG4gICAgICAgIHBhcmFtc3BhY2UucHVzaChcbiAgICAgICAgICBpbnQ4VG9TdHIoYnl0ZTEpICsgLy8gdWgsIHR5cGVcbiAgICAgICAgICBpbnQ4VG9TdHIoMikgICAgICAgLy8gbGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLypcbiAgICAgICAqIEFwcGxpY2F0aW9uIFB1Ymxpc2hlciBBY2tub3dsZWRnZVxuICAgICAgICovXG4gICAgICBjYXNlIFNNRkxpYi5TTUZBZFByb3RvY29sUGFyYW0uQVBQTElDQVRJT05fUFVCX0FDSzpcbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBMT0dfSU5GTygnVW5yZWNvZ25pemVkIEFEUHJvdG9jb2wgUGFyYW1ldGVyIGluIE1lc3NhZ2UnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGFyYW1kYXRhID0gcGFyYW1zcGFjZS5qb2luKCcnKTtcblxuICBjb25zdCBkYXRhID0gW107XG4gIGlmIChhZHBNc2cudmVyc2lvbiA9PT0gMikge1xuICAgIGxldCB0aHJlZWJ5dGVzID0gMDtcbiAgICB0aHJlZWJ5dGVzID0gc2V0Qml0cyh0aHJlZWJ5dGVzLCAwLCAyMiwgMik7IC8vIFJGVVxuICAgIHRocmVlYnl0ZXMgPSBzZXRCaXRzKHRocmVlYnl0ZXMsIGFkcE1zZy52ZXJzaW9uLCAxNiwgNik7IC8vIFJGVVxuICAgIHRocmVlYnl0ZXMgPSBzZXRCaXRzKHRocmVlYnl0ZXMsIGFkcE1zZy5tc2dUeXBlLCAxMiwgNCk7IC8vIG1zZ3R5cGVcbiAgICAvLyBsZW5ndGggaW4gMzIgYml0IHdvcmRzIG1lYW5zIHRoZSByZWFsIGxlbmd0aCBtdXN0IGFsd2F5cyBiZSBhIG11bHRpcGxlIG9mIDQsIHNvIHBhZCBhc1xuICAgIC8vIG5lY2Vzc2FyeVxuXG4gICAgLy8gNCAtIGhvdyBtYW55IGJ5dGVzIHBhc3NlZCBhIDQgYnl0ZSBib3VuZGFyeVxuICAgIGxldCBwYWRCeXRlcyA9IDQgLSAoKDMgKyBwYXJhbWRhdGEubGVuZ3RoKSAmIDB4Myk7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGgsIDMgYnl0ZXMgaGVhZGVyICsgcGFyYW1zLCBpbiAzMiBiaXQgd29yZHNcbiAgICBjb25zdCBsZW5ndGggPSAoMyArIHBhcmFtZGF0YS5sZW5ndGggKyBwYWRCeXRlcykgPj4gMjtcbiAgICB0aHJlZWJ5dGVzID0gc2V0Qml0cyh0aHJlZWJ5dGVzLCBsZW5ndGgsIDAsIDEyKTtcbiAgICBkYXRhLnB1c2goaW50MjRUb1N0cih0aHJlZWJ5dGVzKSk7IC8vIGZpcnN0IDNCIChSRlUsIHZlcnNpb24sIG1zZ3R5cGUsIGxlbmd0aClcbiAgICBkYXRhLnB1c2gocGFyYW1kYXRhKTtcblxuICAgIGlmIChwYWRCeXRlcyA9PT0gNCkgcGFkQnl0ZXMgPSAwOyAvLyBkb24ndCBhZGQgNCBwYWQgYnl0ZXNcbiAgICB3aGlsZSAocGFkQnl0ZXMgPiAwKSB7XG4gICAgICBkYXRhLnB1c2goaW50OFRvU3RyKDApKTtcbiAgICAgIHBhZEJ5dGVzLS07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFkcE1zZy52ZXJzaW9uID09PSAzKSB7XG4gICAgbGV0IHR3b2J5dGVzID0gMDtcbiAgICB0d29ieXRlcyA9IHNldEJpdHModHdvYnl0ZXMsIDAsIDE0LCAyKTsgLy8gUkZVXG4gICAgdHdvYnl0ZXMgPSBzZXRCaXRzKHR3b2J5dGVzLCBhZHBNc2cudmVyc2lvbiwgOCwgNik7IC8vIHZlcnNpb25cbiAgICB0d29ieXRlcyA9IHNldEJpdHModHdvYnl0ZXMsIGFkcE1zZy5tc2dUeXBlLCAwLCA4KTsgLy8gbXNndHlwZVxuICAgIGRhdGEucHVzaChpbnQxNlRvU3RyKHR3b2J5dGVzKSk7IC8vIGZpcnN0IDJCIChSRlUsIHZlcnNpb24sIG1zZ3R5cGUpXG4gICAgZGF0YS5wdXNoKGludDMyVG9TdHIoNiArIHBhcmFtZGF0YS5sZW5ndGgpKTsgLy9sZW5ndGg6IDZCIGhlYWRlciArIHBhcmFtc1xuICAgIGRhdGEucHVzaChwYXJhbWRhdGEpO1xuICB9IGVsc2Uge1xuICAgIExPR19FUlJPUihgSW52YWxpZCBWZXJzaW9uICR7YWRwTXNnLnZlcnNpb259IGZvdW5kIHdoaWxlIGVuY29kaW5nYCk7XG4gIH1cblxuICByZXR1cm4gZGF0YS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2VBZHBBdCA9IHBhcnNlQWRwQXQ7XG5tb2R1bGUuZXhwb3J0cy5lbmNBZHAgPSBlbmNBZHA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL2NvZGVjL2FkcHJvdG9jb2wuanMiLCJjb25zdCB7IEJpdHMsIENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IENsaWVudEN0cmxNZXNzYWdlLCBTTUZQYXJhbWV0ZXIgfSA9IHJlcXVpcmUoJy4uL21lc3NhZ2Utb2JqZWN0cycpO1xuY29uc3QgeyBMT0dfRVJST1IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcblxuY29uc3Qge1xuICBnZXQ6IGJpdHMsXG4gIHNldDogc2V0Qml0cyxcbn0gPSBCaXRzO1xuXG5jb25zdCB7XG4gIGludDhUb1N0ciwgc3RyVG9JbnQ4LFxuICBpbnQxNlRvU3RyLCBzdHJUb0ludDE2LFxuICBpbnQzMlRvU3RyLCBzdHJUb1VJbnQzMixcbn0gPSBDb252ZXJ0O1xuXG5mdW5jdGlvbiBwYXJzZUNDQXQoZGF0YSwgb2Zmc2V0LCBwYXlsb2FkTGVuKSB7XG4gIGNvbnN0IGNjTXNnID0gbmV3IENsaWVudEN0cmxNZXNzYWdlKCk7XG4gIGlmIChwYXlsb2FkTGVuIDwgNiB8fCBvZmZzZXQgKyA2ID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIG5vdCBlbm91Z2ggZGF0YSEgUmV0dXJuIGVtcHR5LlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHdlIGNhbiBnZXQgYW4gZW1wdHkgQ0MgcGF5bG9hZCBhcyBhIHJvdXRlciByZXNwb25zZVxuICAgIHJldHVybiBjY01zZztcbiAgfVxuXG4gIGxldCBwb3MgPSBvZmZzZXQ7XG4gIGNvbnN0IHR3b2J5dGVzID0gc3RyVG9JbnQxNihkYXRhLnN1YnN0cihwb3MsIDIpKTtcbiAgcG9zICs9IDI7XG4gICAgLy8gdmFyIHVoID0gYml0cyh0d29ieXRlcywgMTUsIDEpO1xuICBjb25zdCB2ZXJzaW9uID0gYml0cyh0d29ieXRlcywgOCwgMyk7XG4gIGNvbnN0IG1zZ1R5cGUgPSBiaXRzKHR3b2J5dGVzLCAwLCA4KTtcbiAgY29uc3QgbGVuID0gc3RyVG9VSW50MzIoZGF0YS5zdWJzdHIocG9zLCA0KSk7XG4gIHBvcyArPSA0O1xuXG4gICAgLy8gU2FuaXR5IGNoZWNrOiB3ZSBzdXBwb3J0IENsaWVudEN0cmwgdjFcbiAgaWYgKHZlcnNpb24gIT09IDEpIHtcbiAgICBMT0dfRVJST1IoYFVuc3VwcG9ydGVkIENsaWVudEN0cmwgdmVyc2lvbiAke3ZlcnNpb259YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbiA8PSAwIHx8IChvZmZzZXQgKyBsZW4pID4gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjY01zZy5tc2dUeXBlID0gbXNnVHlwZTtcbiAgY2NNc2cudmVyc2lvbiA9IHZlcnNpb247XG4gIHdoaWxlIChwb3MgPCAob2Zmc2V0ICsgbGVuKSkge1xuICAgIGNvbnN0IG9uZWJ5dGUgPSBzdHJUb0ludDgoZGF0YS5zdWJzdHIocG9zLCAxKSk7XG4gICAgcG9zKys7XG4gICAgY29uc3QgcGFyYW1VaCA9IGJpdHMob25lYnl0ZSwgNywgMSk7XG4gICAgY29uc3QgcGFyYW1UeXBlID0gYml0cyhvbmVieXRlLCAwLCA3KTtcbiAgICBjb25zdCBwYXJhbUxlbiA9IHN0clRvVUludDMyKGRhdGEuc3Vic3RyKHBvcywgNCkpO1xuICAgIGlmIChwYXJhbUxlbiA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIFNNRiBwYXJzaW5nIGZhaWxcbiAgICB9XG5cbiAgICBwb3MgKz0gNDtcbiAgICBjb25zdCBwYXJhbVZhbHVlTGVuID0gcGFyYW1MZW4gLSA1O1xuICAgIGNvbnN0IHBhcmFtVmFsdWUgPSBkYXRhLnN1YnN0cihwb3MsIHBhcmFtVmFsdWVMZW4pO1xuICAgIGNjTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKHBhcmFtVWgsIHBhcmFtVHlwZSwgcGFyYW1WYWx1ZSkpO1xuICAgIHBvcyArPSBwYXJhbVZhbHVlTGVuO1xuICB9XG4gIHJldHVybiBjY01zZztcbn1cblxuZnVuY3Rpb24gZW5jQ0MoY2NNc2cpIHtcbiAgY29uc3QgcGFyYW1TcGFjZSA9IFtdO1xuICBjb25zdCBwYXJhbUFycmF5ID0gY2NNc2cuZ2V0UGFyYW1ldGVyQXJyYXkoKTtcbiAgICAvKlxuICAgIENsaWVudEN0cmwgUGFyYW1ldGVyIGZvcm1hdHRpbmc6XG4gICAgICAgIDEgYnl0ZSB1aC90eXBlXG4gICAgICAgIDQgYnl0ZXMgbGVuZ3RoXG4gICAgICAgIE4gYnl0ZXMgdmFsdWVcbiAgICAgKi9cbiAgZm9yIChsZXQgcCA9IDAsIG4gPSBwYXJhbUFycmF5Lmxlbmd0aDsgcCA8IG47ICsrcCkge1xuICAgIGNvbnN0IGN1cnJlbnRQYXJhbSA9IHBhcmFtQXJyYXlbcF07XG4gICAgICAvLyBJdCdzIG5vdCBhIGZsYXQgYXJyYXksIHdlIGhhdmUgZ2FwcyFcbiAgICBpZiAoY3VycmVudFBhcmFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudFBhcmFtT25lQnl0ZSA9IDA7XG4gICAgY3VycmVudFBhcmFtT25lQnl0ZSA9IHNldEJpdHMoY3VycmVudFBhcmFtT25lQnl0ZSwgY3VycmVudFBhcmFtLmdldFVoKCksIDcsIDEpO1xuICAgIGN1cnJlbnRQYXJhbU9uZUJ5dGUgPSBzZXRCaXRzKGN1cnJlbnRQYXJhbU9uZUJ5dGUsIGN1cnJlbnRQYXJhbS5nZXRUeXBlKCksIDAsIDcpO1xuICAgIHBhcmFtU3BhY2UucHVzaChpbnQ4VG9TdHIoY3VycmVudFBhcmFtT25lQnl0ZSkpO1xuICAgIHBhcmFtU3BhY2UucHVzaChpbnQzMlRvU3RyKGN1cnJlbnRQYXJhbS5nZXRWYWx1ZSgpLmxlbmd0aCArIDUpKTtcbiAgICBwYXJhbVNwYWNlLnB1c2goY3VycmVudFBhcmFtLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgY29uc3QgcGFyYW1EYXRhID0gcGFyYW1TcGFjZS5qb2luKCcnKTtcbiAgbGV0IHR3b2J5dGVzID0gMDtcbiAgdHdvYnl0ZXMgPSBzZXRCaXRzKHR3b2J5dGVzLCAwLCAxNSwgMSk7IC8vIHVoXG4gIHR3b2J5dGVzID0gc2V0Qml0cyh0d29ieXRlcywgMCwgMTEsIDQpOyAvLyBSRlVcbiAgdHdvYnl0ZXMgPSBzZXRCaXRzKHR3b2J5dGVzLCAxLCA4LCAzKTsgLy8gdmVyc2lvblxuICB0d29ieXRlcyA9IHNldEJpdHModHdvYnl0ZXMsIGNjTXNnLm1zZ1R5cGUsIDAsIDgpOyAvLyBtc2d0eXBlXG5cbiAgY29uc3QgZGF0YSA9IFtdO1xuICBkYXRhLnB1c2goaW50MTZUb1N0cih0d29ieXRlcykpOyAvLyBmaXJzdCAyQiAodWgsIHZlcnNpb24sIG1zZ3R5cGUpXG4gIGRhdGEucHVzaChpbnQzMlRvU3RyKDYgKyBwYXJhbURhdGEubGVuZ3RoKSk7IC8vIGxlbmd0aDogNkIgaGVhZGVyICsgcGFyYW1zXG4gIGRhdGEucHVzaChwYXJhbURhdGEpO1xuICByZXR1cm4gZGF0YS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2VDQ0F0ID0gcGFyc2VDQ0F0O1xubW9kdWxlLmV4cG9ydHMuZW5jQ0MgPSBlbmNDQztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvY2xpZW50LWN0cmwuanMiLCJjbGFzcyBDb250ZW50U3VtbWFyeUVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlID0gbnVsbCwgcG9zaXRpb24gPSAwLCBsZW5ndGggPSAwKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQ29udGVudFN1bW1hcnlFbGVtZW50ID0gQ29udGVudFN1bW1hcnlFbGVtZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9jb250ZW50LXN1bW1hcnktZWxlbWVudC5qcyIsImNvbnN0IHtcbiAgTE9HX1RSQUNFLFxuICBMT0dfREVCVUcsXG4gIExPR19FUlJPUixcbiAgTE9HX0lORk8sXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBCYXNlNjQsIEJpdHMsIENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IFBhcmFtUGFyc2UgfSA9IHJlcXVpcmUoJy4vcGFyYW0tcGFyc2UnKTtcbmNvbnN0IHsgU01GSGVhZGVyIH0gPSByZXF1aXJlKCcuLi9tZXNzYWdlLW9iamVjdHMnKTtcbmNvbnN0IHsgU01GUGFyYW1ldGVyVHlwZSB9ID0gcmVxdWlyZSgnLi4vc21mLXBhcmFtZXRlci10eXBlcycpO1xuXG5jb25zdCB7XG4gIGRlY29kZTogYmFzZTY0RGVjb2RlLFxufSA9IEJhc2U2NDtcbmNvbnN0IHtcbiAgZ2V0OiBiaXRzLFxufSA9IEJpdHM7XG5jb25zdCB7XG4gIHN0clRvSW50OCxcbiAgc3RyVG9JbnQyNCxcbiAgc3RyVG9JbnQzMixcbiAgc3RyVG9VSW50MzIsXG4gIHN0clRvVUludDY0LFxufSA9IENvbnZlcnQ7XG5cbmZ1bmN0aW9uIGlzU01GSGVhZGVyQXZhaWxhYmxlKGRhdGEsIG9mZnNldCkge1xuICBjb25zdCByZW1haW5pbmcgPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKHJlbWFpbmluZyA8IDEyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzU01GSGVhZGVyVmFsaWQoZGF0YSwgb2Zmc2V0KSB7XG4gIGlmICghaXNTTUZIZWFkZXJBdmFpbGFibGUoZGF0YSwgb2Zmc2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB2ZXJzaW9uID0gc3RyVG9JbnQ4KGRhdGFbb2Zmc2V0XSkgJiAweDc7XG4gIGlmICh2ZXJzaW9uICE9PSAzKSB7XG4gICAgTE9HX0VSUk9SKGBJbnZhbGlkIHNtZiB2ZXJzaW9uIGluIHNtZiBoZWFkZXIsIHZlcnNpb249JHt2ZXJzaW9ufWApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNTTUZBdmFpbGFibGUoZGF0YSwgb2Zmc2V0KSB7XG4gIGlmICghaXNTTUZIZWFkZXJWYWxpZChkYXRhLCBvZmZzZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJlbWFpbmluZyA9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xuICBjb25zdCB0b3RhbExlbiA9IHN0clRvVUludDMyKGRhdGEuc3Vic3RyKG9mZnNldCArIDgsIDQpKTtcbiAgcmV0dXJuICh0b3RhbExlbiA8PSByZW1haW5pbmcpO1xufVxuXG4vKipcbiAqIFBhcnNlIFNNRiBpbiB0aGUgZ2l2ZW4gZGF0YSBhdCB0aGUgc3VwcGxpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgVGhlIGJpbmFyeSBkYXRhIHRvIHBhcnNlXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgaW4gdGhlIGRhdGEgdG8gYmVnaW4gcGFyc2luZ1xuICogQHBhcmFtIHtCb29sZWFufSByZWFkSGVhZGVyT25seSBJZiB0cnVlLCBzdG9wIHBhcnNpbmcgYXQgZW5kIG9mIGhlYWRlclxuICogQHJldHVybnMge1NNRkhlYWRlcnxudWxsfSBUaGUgU01GIGhlYWRlciwgaWYgcG9zc2libGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU01GQXQoZGF0YSwgb2Zmc2V0LCByZWFkSGVhZGVyT25seSA9IGZhbHNlKSB7XG4gIGlmICghaXNTTUZIZWFkZXJWYWxpZChkYXRhLCBvZmZzZXQpKSB7XG4gICAgTE9HX0RFQlVHKCdWYWxpZCBTTUYgaGVhZGVyIG5vdCBhdmFpbGFibGUnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgcG9zID0gb2Zmc2V0O1xuXG4gICAgLy8gUmVhZGluZyBmaXhlZCBoZWFkZXIgYmxvY2sgKDEyIGJ5dGVzKVxuICBjb25zdCB3b3JkMSA9IHN0clRvSW50MzIoZGF0YS5zdWJzdHIocG9zLCA0KSk7XG4gIGNvbnN0IGhlYWRlckxlbiA9IHN0clRvVUludDMyKGRhdGEuc3Vic3RyKHBvcyArIDQsIDQpKTtcbiAgY29uc3Qgd29yZDMgPSBzdHJUb1VJbnQzMihkYXRhLnN1YnN0cihwb3MgKyA4LCA0KSk7XG5cbiAgY29uc3Qgc21mSGVhZGVyID0gbmV3IFNNRkhlYWRlcigpO1xuICBzbWZIZWFkZXIuc21mX2RpID0gYml0cyh3b3JkMSwgMzEsIDEpO1xuICBzbWZIZWFkZXIuc21mX2VsaWRpbmdFbGlnaWJsZSA9IGJpdHMod29yZDEsIDMwLCAxKTtcbiAgc21mSGVhZGVyLnNtZl9kdG8gPSBiaXRzKHdvcmQxLCAyOSwgMSk7XG4gIHNtZkhlYWRlci5zbWZfYWRmID0gYml0cyh3b3JkMSwgMjgsIDEpO1xuICBzbWZIZWFkZXIuc21mX2RlYWRNZXNzYWdlUXVldWVFbGlnaWJsZSA9IGJpdHMod29yZDEsIDI3LCAxKTtcbiAgc21mSGVhZGVyLnNtZl92ZXJzaW9uID0gYml0cyh3b3JkMSwgMjQsIDMpO1xuICBzbWZIZWFkZXIuc21mX3VoID0gYml0cyh3b3JkMSwgMjIsIDIpO1xuICBzbWZIZWFkZXIuc21mX3Byb3RvY29sID0gYml0cyh3b3JkMSwgMTYsIDYpO1xuICBzbWZIZWFkZXIuc21mX3ByaW9yaXR5ID0gYml0cyh3b3JkMSwgMTIsIDQpO1xuICBzbWZIZWFkZXIuc21mX3R0bCA9IGJpdHMod29yZDEsIDAsIDgpO1xuXG4gIGNvbnN0IHBheWxvYWRMZW4gPSB3b3JkMyAtIGhlYWRlckxlbjtcbiAgaWYgKHBheWxvYWRMZW4gPCAwKSB7XG4gICAgTE9HX0VSUk9SKCdTTUYgcGFyc2UgZXJyb3I6IGxvc3QgZnJhbWluZycpO1xuICAgIHJldHVybiBudWxsOyAvLyBTTUYgcGFyc2UgZXJyb3I6IGxvc3QgZnJhbWluZ1xuICB9XG4gIHNtZkhlYWRlci5zZXRNZXNzYWdlU2l6ZXMoaGVhZGVyTGVuLCBwYXlsb2FkTGVuKTtcbiAgaWYgKHJlYWRIZWFkZXJPbmx5KSB7XG4gICAgcmV0dXJuIHNtZkhlYWRlcjtcbiAgfVxuICBwb3MgKz0gMTI7XG5cbiAgLy8gUmVhZGluZyB2YXJpYWJsZS1sZW5ndGggcGFyYW1zXG4gIGNvbnN0IGVuZCA9IG9mZnNldCArIGhlYWRlckxlbjtcbiAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgIGNvbnN0IHBhcmFtQnl0ZTEgPSBkYXRhLmNoYXJDb2RlQXQocG9zKTtcbiAgICArK3BvcztcblxuICAgIGNvbnN0IHBybVVoID0gYml0cyhwYXJhbUJ5dGUxLCA2LCAyKTtcbiAgICBjb25zdCBwYXJhbUlzTGlnaHR3ZWlnaHQgPSAoYml0cyhwYXJhbUJ5dGUxLCA1LCAxKSAhPT0gMCk7XG4gICAgaWYgKHBhcmFtSXNMaWdodHdlaWdodCkge1xuICAgICAgLy8gTElHSFRXRUlHSFQgcGFyYW1cbiAgICAgIGNvbnN0IGx3cFR5cGUgPSBiaXRzKHBhcmFtQnl0ZTEsIDIsIDMpO1xuICAgICAgY29uc3QgbHdwTGVuID0gYml0cyhwYXJhbUJ5dGUxLCAwLCAyKSArIDE7XG4gICAgICBjb25zdCBsd3BWYWx1ZUxlbiA9IGx3cExlbiAtIDE7XG4gICAgICBpZiAobHdwTGVuIDw9IDApIHtcbiAgICAgICAgTE9HX0VSUk9SKCdJbnZhbGlkIGxpZ2h0d2VpZ2h0IHBhcmFtZXRlciBsZW5ndGgnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgcGFyYW1ldGVyXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAobHdwVHlwZSkge1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuTElHSFRfQ09SUkVMQVRJT046XG4gICAgICAgICAgc21mSGVhZGVyLnBtX2NvcnJ0YWcgPSBzdHJUb0ludDI0KGRhdGEuc3Vic3RyKHBvcywgMykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuTElHSFRfVE9QSUNfTkFNRV9PRkZTRVQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUXVldWVPZmZzZXRzID0gUGFyYW1QYXJzZS5wYXJzZVRvcGljUXVldWVPZmZzZXRzKGRhdGEsIHBvcyk7XG4gICAgICAgICAgICBzbWZIZWFkZXIucG1fcXVldWVfb2Zmc2V0ID0gcGFyc2VkUXVldWVPZmZzZXRzWzBdO1xuICAgICAgICAgICAgc21mSGVhZGVyLnBtX3F1ZXVlX2xlbiA9IHBhcnNlZFF1ZXVlT2Zmc2V0c1sxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBTTUZQYXJhbWV0ZXJUeXBlLkxJR0hUX1FVRVVFX05BTUVfT0ZGU0VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFRvcGljT2Zmc2V0cyA9IFBhcmFtUGFyc2UucGFyc2VUb3BpY1F1ZXVlT2Zmc2V0cyhkYXRhLCBwb3MpO1xuICAgICAgICAgICAgc21mSGVhZGVyLnBtX3RvcGljX29mZnNldCA9IHBhcnNlZFRvcGljT2Zmc2V0c1swXTtcbiAgICAgICAgICAgIHNtZkhlYWRlci5wbV90b3BpY19sZW4gPSBwYXJzZWRUb3BpY09mZnNldHNbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5MSUdIVF9BQ0tfSU1NRURJQVRFTFk6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX2FkX2Fja2ltbSA9ICEhZGF0YS5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHBybVVoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUsIGFuZCBzaWxlbnRseSBkaXNjYXJkIHRoZSBwYXJhbWV0ZXIuXG4gICAgICAgICAgICBMT0dfVFJBQ0UoYFVuaGFuZGxlZCBMSUdIVFdFSUdIVCBwYXJhbWV0ZXIgdHlwZTogJHtsd3BUeXBlfSBVSCBpcyAke3BybVVofSBkaXNjYXJkaW5nIHBhcmFtZXRlci5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWdub3JlLCBhbmQgc2lsZW50bHkgZGlzY2FyZCB0aGUgZW50aXJlIG1lc3NhZ2UuXG4gICAgICAgICAgICBMT0dfVFJBQ0UoYFVuaGFuZGxlZCBMSUdIVFdFSUdIVCBwYXJhbWV0ZXIgdHlwZTogJHtsd3BUeXBlfSBVSCBpcyAke3BybVVofSBkaXNjYXJkaW5nIG1lc3NhZ2UuYCk7XG4gICAgICAgICAgICBzbWZIZWFkZXIuZGlzY2FyZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBvcyArPSBsd3BWYWx1ZUxlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVHVUxBUiBlbmNvZGVkIHBhcmFtXG4gICAgICBjb25zdCBwU3RhcnQgPSBwb3M7XG4gICAgICBjb25zdCBwVHlwZSA9IGJpdHMocGFyYW1CeXRlMSwgMCwgNSk7XG4gICAgICBpZiAocFR5cGUgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8vIFBBRERJTkcgKGJyZWFrIHdoaWxlOiBoZWFkZXIgZmluaXNoZWQpXG4gICAgICB9XG5cbiAgICAgIGxldCBwTGVuID0gZGF0YS5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBwb3MrKztcbiAgICAgIGxldCBwVmFsdWVMZW47XG4gICAgICBpZiAocExlbiA9PT0gMCkge1xuICAgICAgICAvLyBleHRlbmRlZC1sZW5ndGggcGFyYW1ldGVyICgzMi1iaXQpXG4gICAgICAgIHBMZW4gPSBzdHJUb1VJbnQzMihkYXRhLnN1YnN0cihwb3MsIDQpKTtcbiAgICAgICAgcG9zICs9IDQ7XG4gICAgICAgIHBWYWx1ZUxlbiA9IHBMZW4gLSA2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcFZhbHVlTGVuID0gcExlbiAtIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwTGVuIDw9IDApIHtcbiAgICAgICAgTE9HX0VSUk9SKGBJbnZhbGlkIHJlZ3VsYXIgcGFyYW1ldGVyIGxlbmd0aCAke3BMZW59LyR7cFZhbHVlTGVuXG4gICAgICAgICAgICAgICAgICB9IHdpdGggc3VzcGVjdCB0eXBlICR7U01GUGFyYW1ldGVyVHlwZS5kZXNjcmliZShwVHlwZSl9IGF0IHBhcmFtZXRlciBhdCBwb3NpdGlvbiAke3BTdGFydH1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIEludmFsaWQgcGFyYW1ldGVyXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocFR5cGUpIHtcbiAgICAgICAgY2FzZSBTTUZQYXJhbWV0ZXJUeXBlLlBVQkxJU0hFUl9JRDpcbiAgICAgICAgICBzbWZIZWFkZXIucG1fYWRfcHVibGlzaGVyX2lkID0gc3RyVG9VSW50NjQoZGF0YS5zdWJzdHIocG9zLCA4KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5QVUJMSVNIRVJfTVNHSUQ6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX2FkX3B1Ymxpc2hlcm1zZ2lkID0gc3RyVG9VSW50NjQoZGF0YS5zdWJzdHIocG9zLCA4KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5NRVNTQUdFUFJJT1JJVFk6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX21zZ19wcmlvcml0eSA9IGRhdGEuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuVVNFUkRBVEE6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX3VzZXJkYXRhID0gZGF0YS5zdWJzdHIocG9zLCBwVmFsdWVMZW4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuVVNFUk5BTUU6XG4gICAgICAgICAgLy8gb25seSB1c2VmdWwgb24gQVBJIC0+IHJvdXRlclxuICAgICAgICAgIHNtZkhlYWRlci5wbV91c2VybmFtZSA9IGJhc2U2NERlY29kZShkYXRhLnN1YnN0cihwb3MsIHBWYWx1ZUxlbikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuUEFTU1dPUkQ6XG4gICAgICAgICAgLy8gb25seSB1c2VmdWwgb24gQVBJIC0+IHJvdXRlclxuICAgICAgICAgIHNtZkhlYWRlci5wbV9wYXNzd29yZCA9IGJhc2U2NERlY29kZShkYXRhLnN1YnN0cihwb3MsIHBWYWx1ZUxlbikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuUkVTUE9OU0U6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBQYXJhbVBhcnNlLnBhcnNlUmVzcG9uc2VQYXJhbShkYXRhLCBwb3MsIHBWYWx1ZUxlbik7XG4gICAgICAgICAgICBzbWZIZWFkZXIucG1fcmVzcGNvZGUgPSBwYXJzZWRSZXNwb25zZVswXTtcbiAgICAgICAgICAgIHNtZkhlYWRlci5wbV9yZXNwc3RyID0gcGFyc2VkUmVzcG9uc2VbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5TVUJfSURfTElTVDpcbiAgICAgICAgY2FzZSBTTUZQYXJhbWV0ZXJUeXBlLkdFTkVSSUNfQVRUQUNITUVOVDpcbiAgICAgICAgY2FzZSBTTUZQYXJhbWV0ZXJUeXBlLkJJTkFSWV9BVFRBQ0hNRU5UOlxuICAgICAgICAgIExPR19JTkZPKCdTa2lwcGluZyBkZXByZWNhdGVkIHBhcmFtZXRlciB0eXBlJyk7XG4gICAgICAgICAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuREVMSVZFUllfTU9ERTpcbiAgICAgICAgICAvLyBEZWxpdmVyeU1vZGUgaXMgRElSRUNUIHVubGVzcyB0aGUgQUQgZmxhZyBpcyBzZXQuIFRoZVxuICAgICAgICAgIC8vIGRlbGl2ZXJ5TW9kZSBwYXJhbWV0ZXIgKGFuZCBhbGwgb3RoZXIgZ3VhcmFudGVlZCBtZXNzYWdpbmdcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzIG1heSBiZSBwcmVzZW50IGluIGRlbW90ZWQgbWVzc2FnZXMgcmVmbGVjdGluZyBob3dcbiAgICAgICAgICAvLyB0aGUgbWVzc2FnZSB3YXMgcHVibGlzaGVkLlxuICAgICAgICAgIC8vIElGIGV2ZXIgc29sQ2xpZW50SlMgbXVzdCBzdXBwb3J0IHRoZSBob3Jyb3IgdGhhdCBpcyBjdXQtdGhyb3VnaFxuICAgICAgICAgIC8vIHBlcnNpc3RlbmNlLCB0aGVuIHdlIG11c3QgZGVmZXIgc2V0dGluZyBkZWxpdmVyeU1vZGUgYmFjayB0b1xuICAgICAgICAgIC8vIERJUkVDVCB1bnRpbCB0aGUgc2Vzc2lvbiBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cnVlIGRpcmVjdFxuICAgICAgICAgIC8vIG1lc3NhZ2Ugb3IgYSBjdXQtdGhyb3VnaCBkaXJlY3QgbWVzc2FnZS4gIEJ1dCB1bnRpbCB0aGF0IGlzXG4gICAgICAgICAgLy8gZm9yY2VkIHVwb24gdXMsIHRoZSBjbGVhbmVzdCBwbGFjZSB0byBzZXQgZGVsaXZlcnlNb2RlIGlzIGFsd2F5c1xuICAgICAgICAgIC8vIGhlcmUgaW4gdGhlIHBhcnNlci5cbiAgICAgICAgICBpZiAoc21mSGVhZGVyLnNtZl9hZGYpIHtcbiAgICAgICAgICAgIHNtZkhlYWRlci5wbV9kZWxpdmVyeW1vZGUgPSBQYXJhbVBhcnNlLnBhcnNlRGVsaXZlcnlNb2RlKGRhdGEsIHBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuQVNTVVJFRF9NRVNTQUdFX0lEOlxuICAgICAgICAgIHNtZkhlYWRlci5wbV9hZF9tc2dpZCA9IHN0clRvVUludDY0KGRhdGEuc3Vic3RyKHBvcywgOCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuQVNTVVJFRF9QUkVWTUVTU0FHRV9JRDpcbiAgICAgICAgICBzbWZIZWFkZXIucG1fYWRfcHJldm1zZ2lkID0gc3RyVG9VSW50NjQoZGF0YS5zdWJzdHIocG9zLCA4KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5BU1NVUkVEX1JFREVMSVZFUkVEX0ZMQUc6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX2FkX3JlZGVsZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5BRF9USU1FVE9MSVZFOlxuICAgICAgICAgIHNtZkhlYWRlci5wbV9hZF90dGwgPSBzdHJUb1VJbnQ2NChkYXRhLnN1YnN0cihwb3MsIDgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTTUZQYXJhbWV0ZXJUeXBlLkFEX1RPUElDU0VRVUVOQ0VfTlVNQkVSOlxuICAgICAgICAgIHNtZkhlYWRlci5wbV9hZF90b3BpY1NlcXVlbmNlTnVtYmVyID0gc3RyVG9VSW50NjQoZGF0YS5zdWJzdHIocG9zLCA4KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5NRVNTQUdFX0NPTlRFTlRfU1VNTUFSWTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50U3VtbWFyeSA9IFBhcmFtUGFyc2UucGFyc2VDb250ZW50U3VtbWFyeShkYXRhLCBwb3MsIHBWYWx1ZUxlbik7XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgIExPR19FUlJPUihgSW52YWxpZCBtZXNzYWdlIGNvbnRlbnQgc3VtbWFyeSBhdCAke3Bvc30sIGxlbiAke3BWYWx1ZUxlbn1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpbnZhbGlkIG1lc3NhZ2UgY29udGVudCBzdW1tYXJ5IHBhcmFtZXRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc21mSGVhZGVyLnBtX2NvbnRlbnRfc3VtbWFyeSA9IGNvbnRlbnRTdW1tYXJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuQVNTVVJFRF9GTE9XSUQ6XG4gICAgICAgICAgc21mSGVhZGVyLnBtX2FkX2Zsb3dpZCA9IHN0clRvVUludDMyKGRhdGEuc3Vic3RyKHBvcywgNCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNNRlBhcmFtZXRlclR5cGUuVFJfVE9QSUNOQU1FOlxuICAgICAgICAgIC8vIGNvcHkgYnl0ZXMuIERvbid0IHN0cmlwIG51bGwgdGVybWluYXRvclxuICAgICAgICAgIHNtZkhlYWRlci5wbV90cl90b3BpY25hbWVfYnl0ZXMgPSBkYXRhLnN1YnN0cihwb3MsIHBWYWx1ZUxlbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU01GUGFyYW1ldGVyVHlwZS5BRF9GTE9XUkVERUxJVkVSRURfRkxBRzpcbiAgICAgICAgICBzbWZIZWFkZXIucG1fYWRfZmxvd3JlZGVsZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHBybVVoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUsIGFuZCBzaWxlbnRseSBkaXNjYXJkIHRoZSBwYXJhbWV0ZXIuXG4gICAgICAgICAgICBMT0dfVFJBQ0UoYFVuaGFuZGxlZCBTTUYgcGFyYW1ldGVyIHR5cGU6ICR7cFR5cGV9IFVIIGlzICR7cHJtVWh9IGRpc2NhcmRpbmcgcGFyYW1ldGVyLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUsIGFuZCBzaWxlbnRseSBkaXNjYXJkIHRoZSBlbnRpcmUgbWVzc2FnZS5cbiAgICAgICAgICAgIExPR19UUkFDRShgVW5oYW5kbGVkIFNNRiBwYXJhbWV0ZXIgdHlwZTogJHtwVHlwZX0gVUggaXMgJHtwcm1VaH0gZGlzY2FyZGluZyBtZXNzYWdlLmApO1xuICAgICAgICAgICAgc21mSGVhZGVyLmRpc2NhcmRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGVuZCBwYXJhbSB0eXBlIHN3aXRjaCBibG9ja1xuXG4gICAgICBwb3MgKz0gcFZhbHVlTGVuO1xuICAgIH0gLy8gZW5kIChyZWd1bGFyIHBhcmFtKVxuICB9IC8vIGVuZCB3aGlsZVxuXG4gIHJldHVybiBzbWZIZWFkZXI7XG59XG5cbmNvbnN0IFBhcnNlU01GID0ge1xuICBpc1NNRkhlYWRlckF2YWlsYWJsZSxcbiAgaXNTTUZIZWFkZXJWYWxpZCxcbiAgaXNTTUZBdmFpbGFibGUsXG4gIHBhcnNlU01GQXQsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5QYXJzZVNNRiA9IFBhcnNlU01GO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9wYXJzZS1zbWYuanMiLCJjb25zdCBNZXNzYWdlTGliID0gcmVxdWlyZSgnc29sY2xpZW50LW1lc3NhZ2UnKTtcbmNvbnN0IHsgQmlkaU1hcCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbmNsYXNzIFByaW9yaXR5VXNlckNvc01hcCBleHRlbmRzIEJpZGlNYXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbTWVzc2FnZUxpYi5NZXNzYWdlVXNlckNvc1R5cGUuQ09TMSwgMF0sXG4gICAgICAgICAgW01lc3NhZ2VMaWIuTWVzc2FnZVVzZXJDb3NUeXBlLkNPUzIsIDFdLFxuICAgICAgICAgIFtNZXNzYWdlTGliLk1lc3NhZ2VVc2VyQ29zVHlwZS5DT1MzLCAyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuUHJpb3JpdHlVc2VyQ29zTWFwID0gUHJpb3JpdHlVc2VyQ29zTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9wcmlvcml0eS11c2VyLWNvcy1tYXAuanMiLCJjb25zdCB7IEJpdHMsIENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IExPR19ERUJVRyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBTTUZTTVBNZXNzYWdlVHlwZSB9ID0gcmVxdWlyZSgnLi4vc21mLXNtcC1tZXNzYWdlLXR5cGVzJyk7XG5jb25zdCB7IFNNUE1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4uL21lc3NhZ2Utb2JqZWN0cycpO1xuXG5jb25zdCB7XG4gIGdldDogYml0cyxcbiAgc2V0OiBzZXRCaXRzLFxufSA9IEJpdHM7XG5cbmNvbnN0IHtcbiAgaW50OFRvU3RyLCBzdHJUb0ludDgsXG4gIGludDMyVG9TdHIsIHN0clRvVUludDMyLFxufSA9IENvbnZlcnQ7XG5cbmNvbnN0IFNNUCA9IHtcbiAgcGFyc2VTTVBBdChkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoKG9mZnNldCArIDYpID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgZW5vdWdoIGRhdGFcbiAgICAgIExPR19ERUJVRygnTm90IGVub3VnaCBkYXRhIHRvIHJlYWQgYW4gU01QIG1lc3NhZ2UuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwb3MgPSBvZmZzZXQ7XG4gICAgY29uc3Qgb25lYnl0ZSA9IHN0clRvSW50OChkYXRhLnN1YnN0cihwb3MsIDEpKTtcbiAgICBwb3MrKztcblxuICAgICAgICAgICAgLy8gdmFyIG1zZ1VoID0gYml0cyhvbmVieXRlLCA3LCAxKTtcbiAgICBjb25zdCBtc2dUeXBlID0gYml0cyhvbmVieXRlLCAwLCA3KTtcbiAgICBjb25zdCBzbXBNc2cgPSBuZXcgU01QTWVzc2FnZSgpO1xuXG4gICAgaWYgKCEobXNnVHlwZSA9PT0gU01GU01QTWVzc2FnZVR5cGUuQUREU1VCU0NSSVBUSU9OIHx8XG4gICAgICAgICAgbXNnVHlwZSA9PT0gU01GU01QTWVzc2FnZVR5cGUuUkVNU1VCU0NSSVBUSU9OKSkge1xuICAgICAgTE9HX0RFQlVHKGBGb3VuZCB1bnN1cHBvcnRlZCBTTVAgbWVzc2FnZVR5cGUgJHttc2dUeXBlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB1bnN1cHBvcnRlZCB0eXBlXG4gICAgfVxuXG4gICAgY29uc3QgbXNnTGVuZ3RoID0gc3RyVG9VSW50MzIoZGF0YS5zdWJzdHIocG9zLCA0KSk7XG4gICAgcG9zICs9IDQ7XG4gICAgaWYgKChvZmZzZXQgKyBtc2dMZW5ndGgpID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggZGF0YVxuICAgICAgTE9HX0RFQlVHKGBJbnZhbGlkIGRlY2xhcmVkIGxlbmd0aCBvZiAke21zZ0xlbmd0aH0sIHVuYWJsZSB0byByZWFkIFNNUCBtZXNzYWdlLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtc2dGbGFncyA9IHN0clRvSW50OChkYXRhLnN1YnN0cihwb3MsIDEpKTtcbiAgICBwb3MrKztcblxuICAgIHNtcE1zZy5tc2dUeXBlID0gbXNnVHlwZTtcbiAgICBzbXBNc2cuc21wRmxhZ3MgPSBtc2dGbGFncztcbiAgICBzbXBNc2cuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24gPSBkYXRhLnN1YnN0cihwb3MsIG1zZ0xlbmd0aCAtIDYpOyAvLyA2IGlzIHRoZSBiYXNlIGxlblxuICAgIHJldHVybiBzbXBNc2c7XG4gIH0sXG5cbiAgZW5jU21wKHNtcE1zZykge1xuICAgIGlmICghKHNtcE1zZy5tc2dUeXBlID09PSBTTUZTTVBNZXNzYWdlVHlwZS5BRERTVUJTQ1JJUFRJT04gfHxcbiAgICAgICAgICBzbXBNc2cubXNnVHlwZSA9PT0gU01GU01QTWVzc2FnZVR5cGUuUkVNU1VCU0NSSVBUSU9OKSkge1xuICAgICAgTE9HX0RFQlVHKGBVbnN1cHBvcnRlZCBTTVAgbWVzc2FnZSBmb3IgZW5jb2Rpbmc6ICR7c21wTXNnfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBsZXQgb25lYnl0ZSA9IDA7XG4gICAgb25lYnl0ZSA9IHNldEJpdHMob25lYnl0ZSwgMSwgNywgMSk7XG4gICAgb25lYnl0ZSA9IHNldEJpdHMob25lYnl0ZSwgc21wTXNnLm1zZ1R5cGUsIDAsIDcpO1xuICAgIGRhdGEucHVzaChpbnQ4VG9TdHIob25lYnl0ZSkpO1xuICAgIGRhdGEucHVzaChpbnQzMlRvU3RyKDYgKyBzbXBNc2cuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24ubGVuZ3RoKSk7IC8vIGxlbmd0aFxuICAgIGRhdGEucHVzaChpbnQ4VG9TdHIoc21wTXNnLnNtcEZsYWdzKSk7XG4gICAgZGF0YS5wdXNoKHNtcE1zZy5lbmNvZGVkVXRmOFN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIGRhdGEuam9pbignJyk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TTVAgPSBTTVA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL2NvZGVjL3NtcC5qcyIsImNvbnN0IHsgQml0cywgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTGF6eSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7IExPR19FUlJPUiB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBTTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUgfSA9IHJlcXVpcmUoJy4uL3NtZi10cmFuc3BvcnQtc2Vzc2lvbi1tZXNzYWdlLXR5cGVzJyk7XG5jb25zdCB7IFRyYW5zcG9ydFNNRk1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4uL21lc3NhZ2Utb2JqZWN0cycpO1xuXG5jb25zdCB7XG4gIGdldDogYml0cyxcbn0gPSBCaXRzO1xuY29uc3Qge1xuICBzdHJUb0ludDgsXG4gIGludDE2VG9TdHIsIHN0clRvSW50MTYsXG4gIGludDMyVG9TdHIsXG59ID0gQ29udmVydDtcbmNvbnN0IHsgbGF6eVZhbHVlIH0gPSBMYXp5O1xuXG4vLyA9PT09PT09PT09IFRTU01GID09PT09PT09PT1cbmZ1bmN0aW9uIHJlbWFpbnMoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gcGFyc2VUc1NtZkhkckF0KGRhdGEsIG9mZnNldCwgc21maGVhZGVyKSB7XG4gIGxldCBwb3MgPSBvZmZzZXQ7XG4gIGlmIChyZW1haW5zKGRhdGEsIHBvcykgPCAxMCkge1xuICAgIExPR19FUlJPUignVHNTbWYgcGFyc2UgZmFpbGVkOiBub3QgZW5vdWdoIGRhdGEsIGV4cGVjdGVkIGF0IGxlYXN0IDEwQicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zcG9ydFNNRk1lc3NhZ2UgPSBuZXcgVHJhbnNwb3J0U01GTWVzc2FnZSgpO1xuICB0cmFuc3BvcnRTTUZNZXNzYWdlLnNtZkhlYWRlciA9IHNtZmhlYWRlcjtcbiAgY29uc3QgdHdvYnl0ZSA9IHN0clRvSW50MTYoZGF0YS5zdWJzdHIocG9zLCAyKSk7XG4gIHBvcyArPSAyO1xuICB0cmFuc3BvcnRTTUZNZXNzYWdlLnVoID0gYml0cyh0d29ieXRlLCAxNSwgMSk7XG4gIHRyYW5zcG9ydFNNRk1lc3NhZ2UubWVzc2FnZVR5cGUgPSBiaXRzKHR3b2J5dGUsIDgsIDcpO1xuICBjb25zdCB0c0hkckxlbiA9IGJpdHModHdvYnl0ZSwgMCwgOCk7XG4gIHRyYW5zcG9ydFNNRk1lc3NhZ2UudHNIZWFkZXJMZW5ndGggPSB0c0hkckxlbjtcbiAgdHJhbnNwb3J0U01GTWVzc2FnZS5zZXNzaW9uSWQgPSBkYXRhLnN1YnN0cihwb3MsIDgpO1xuICBwb3MgKz0gODtcblxuICBpZiAodHJhbnNwb3J0U01GTWVzc2FnZS5tZXNzYWdlVHlwZSA9PT1cbiAgICAgIFNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZS5DUkVBVEVfUkVTUCkge1xuICAgIC8vIHBhcnNlIGV4dHJhIGNodW5rOiByb3V0ZXJUYWdcbiAgICBjb25zdCBydHJUYWdMZW4gPSBzdHJUb0ludDgoZGF0YS5zdWJzdHIocG9zLCAxKSk7XG4gICAgcG9zKys7XG4gICAgaWYgKHJlbWFpbnMoZGF0YSwgcG9zKSA8IHJ0clRhZ0xlbikge1xuICAgICAgTE9HX0VSUk9SKGBUc1NtZiBwYXJzZSBmYWlsZWQ6IG5vdCBlbm91Z2ggZGF0YSBmb3IgUm91dGVyVGFnLCBleHBlY3RlZCAke3J0clRhZ0xlbn1CYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyYW5zcG9ydFNNRk1lc3NhZ2Uucm91dGVyVGFnID0gZGF0YS5zdWJzdHIocG9zLCBydHJUYWdMZW4pO1xuICAgIHBvcyArPSBydHJUYWdMZW47XG4gIH1cblxuICAvLyBGRldEIGFueSByZW1haW5pbmcgVHNTbWYgcGFkZGluZz9cbiAgcG9zID0gb2Zmc2V0ICsgdHNIZHJMZW47XG5cbiAgLy8gTGVuZ3RoIG9mIGVuY2Fwc3VsYXRlZCBtZXNzYWdlIHBheWxvYWQ6XG4gIC8vIHRoZSBTTUYgbXNnIHBheWxvYWQgbGVuZ3RoIC0gYnl0ZXMgY29uc3VtZWQgaW4gVHNTbWZcblxuICBpZiAoc21maGVhZGVyLnBheWxvYWRMZW5ndGggPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAvLyBzcGVjaWFsIFwic3RyZWFtaW5nXCIgdW5rbm93bi1sZW5ndGggaGVhZGVyXG4gICAgdHJhbnNwb3J0U01GTWVzc2FnZS5wYXlsb2FkTGVuZ3RoID0gc21maGVhZGVyLnBheWxvYWRMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0U01GTWVzc2FnZS5wYXlsb2FkTGVuZ3RoID0gc21maGVhZGVyLnBheWxvYWRMZW5ndGggLSB0c0hkckxlbjtcbiAgfVxuICByZXR1cm4gdHJhbnNwb3J0U01GTWVzc2FnZTsgLy8gSGVhZGVyIHdpdGggbm8gcGF5bG9hZCBmaWVsZFxufVxuXG4vLyBHZW5lcmF0ZXMgYW4gU01GIGhlYWRlciB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcgdGhlIHRoZSB0b3RhbCBsZW5ndGhcbi8vIFRoaXMgaXMgZml4ZWQgZm9yIGFsbCBjbGllbnQgZ2VuZXJhdGVkIHRyYW5zcG9ydCBzZXNzaW9uIG1lc3NhZ2VzXG5jb25zdCB0c0hlYWRlclByZUxlbmd0aCA9IGxhenlWYWx1ZSgoKSA9PiAoXG4gIGludDMyVG9TdHIoMHgwMzE0MDAwMSkgKyAgLy8gU01GIHZlcnNpb24sIFRyYW5zcG9ydFNlc3Npb24sIFRUTFxuICBpbnQzMlRvU3RyKDEyKSAgICAgICAgICAgIC8vIEhlYWRlciBsZW5ndGhcbikpO1xuXG5jb25zdCB0c0Rlc3Ryb3lIZWFkZXJQcmVTaWQgPSBsYXp5VmFsdWUoKCkgPT4gKFxuICB0c0hlYWRlclByZUxlbmd0aC52YWx1ZSArIC8vIEhlYWRlciB1cCB0byB0aGUgbWVzc2FnZSBsZW5ndGggZmllbGRcbiAgaW50MzJUb1N0cigyMikgKyAgICAgICAgICAvLyBUb3RhbCBsZW5ndGhcbiAgaW50MTZUb1N0cigweDgyMGEpICAgICAgICAvLyBtc2dUeXBlKGRlc3Ryb3kpLCBsZW5ndGhcbikpO1xuXG5jb25zdCB0c0NyZWF0ZUhlYWRlciA9IGxhenlWYWx1ZSgoKSA9PiAoXG4gIHRzSGVhZGVyUHJlTGVuZ3RoLnZhbHVlICsgLy8gSGVhZGVyIHVwIHRvIHRoZSBtZXNzYWdlIGxlbmd0aCBmaWVsZFxuICBpbnQzMlRvU3RyKDIyKSArICAgICAgICAgIC8vIFRvdGFsIGxlbmd0aFxuICBpbnQxNlRvU3RyKDB4ODAwYSkgKyAgICAgIC8vIG1zZ1R5cGUoY3JlYXRlKSwgbGVuZ3RoXG4gIGludDMyVG9TdHIoMCkgKyAgICAgICAgICAgLy8gU2Vzc2lvbiBJRCAoZmlyc3QgaGFsZilcbiAgaW50MzJUb1N0cigwKSAgICAgICAgICAgICAvLyBTZXNzaW9uIElEIChzZWNvbmQgaGFsZilcbikpO1xuXG5jb25zdCB0c0RhdGFUb2tlblByZVNpZCA9IGxhenlWYWx1ZSgoKSA9PiAoXG4gIGludDMyVG9TdHIoMHgwMzk0MDAwMSkgK1xuICBpbnQzMlRvU3RyKDEyKSArXG4gIGludDMyVG9TdHIoMjIpICtcbiAgaW50MTZUb1N0cigweDg1MGEpXG4pKTtcblxuY29uc3QgdHNEYXRhU3RyZWFtVG9rZW5QcmVTaWQgPSBsYXp5VmFsdWUoKCkgPT4gKFxuICBpbnQzMlRvU3RyKDB4MDM5NDAwMDEpICtcbiAgaW50MzJUb1N0cigxMikgK1xuICBpbnQzMlRvU3RyKDI0KSArXG4gIGludDE2VG9TdHIoMHg4NjBjKVxuKSk7XG5cbi8vIEdlbmVyYXRlIGEgZnVsbCBUcmFuc3BvcnQgU2Vzc2lvbiBDcmVhdGUgaGVhZGVyXG5mdW5jdGlvbiBnZW5Uc0NyZWF0ZUhlYWRlcigpIHtcbiAgcmV0dXJuIHRzQ3JlYXRlSGVhZGVyLnZhbHVlO1xufVxuXG4vLyBHZW5lcmF0ZSBhIGZ1bGwgVHJhbnNwb3J0IFNlc3Npb24gRGVzdHJveSBoZWFkZXJcbmZ1bmN0aW9uIGdlblRzRGVzdHJveUhlYWRlcihzaWQpIHtcbiAgcmV0dXJuIChcbiAgICB0c0Rlc3Ryb3lIZWFkZXJQcmVTaWQudmFsdWUgK1xuICAgIHNpZCAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Vzc2lvbiBJRFxuICApO1xufVxuXG4vLyBHZW5lcmF0ZSBhIGRhdGEgdG9rZW4gbWVzc2FnZVxuZnVuY3Rpb24gZ2VuVHNEYXRhVG9rZW5Nc2coc2lkKSB7XG4gIHJldHVybiAoXG4gICAgdHNEYXRhVG9rZW5QcmVTaWQudmFsdWUgK1xuICAgIHNpZFxuICApO1xufVxuXG4vLyBHZW5lcmF0ZSBhIFNUUkVBTUlORyBkYXRhIHRva2VuIG1lc3NhZ2VcbmZ1bmN0aW9uIGdlblRzRGF0YVN0cmVhbVRva2VuTXNnKHNpZCwgcGFkZGluZ0J5dGVzKSB7XG4gIHJldHVybiAoXG4gICAgdHNEYXRhU3RyZWFtVG9rZW5QcmVTaWQudmFsdWUgK1xuICAgIHNpZCArXG4gICAgKChwYWRkaW5nQnl0ZXMgJiYgcGFkZGluZ0J5dGVzID4gMCkgPyBpbnQxNlRvU3RyKHBhZGRpbmdCeXRlcykgOiBpbnQxNlRvU3RyKDB4MDAwMCkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblRzRGF0YU1zZ0hlYWRlclBhcnRzKHNpZCkge1xuICByZXR1cm4gW1xuICAgIChpbnQzMlRvU3RyKDB4MDM5NDAwMDEpICsgaW50MzJUb1N0cigxMikpLFxuICAgIChpbnQxNlRvU3RyKDB4ODQwYSkgKyBzaWQpLFxuICBdO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRzU21mTXNnQXQoZGF0YSwgb2Zmc2V0LCBzbWZoZWFkZXIpIHtcbiAgY29uc3QgdHJhbnNwb3J0U01GTWVzc2FnZSA9IHBhcnNlVHNTbWZIZHJBdChkYXRhLCBvZmZzZXQsIHNtZmhlYWRlcik7XG4gIGlmICghdHJhbnNwb3J0U01GTWVzc2FnZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgICAvLyBuZWVkIHRvIEZGIHRvIHBvc1xuICBjb25zdCBwb3MgPSBvZmZzZXQgKyB0cmFuc3BvcnRTTUZNZXNzYWdlLnRzSGVhZGVyTGVuZ3RoO1xuXG4gICAgLy8gTGVuZ3RoIG9mIGVuY2Fwc3VsYXRlZCBtZXNzYWdlIHBheWxvYWQ6XG4gICAgLy8gdGhlIFNNRiBtc2cgcGF5bG9hZCBsZW5ndGggLSBieXRlcyBjb25zdW1lZCBpbiBUc1NtZlxuICBpZiAocmVtYWlucyhkYXRhLCBwb3MpIDwgdHJhbnNwb3J0U01GTWVzc2FnZS5wYXlsb2FkTGVuZ3RoKSB7XG4gICAgTE9HX0VSUk9SKGBDb3VsZG4ndCByZWFkIGZ1bGwgZW5jYXBzdWxhdGVkIFRzU21mIHBheWxvYWQsIGV4cGVjdGVkICR7dHJhbnNwb3J0U01GTWVzc2FnZS5wYXlsb2FkTGVuZ3RofUJgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyYW5zcG9ydFNNRk1lc3NhZ2UucGF5bG9hZCA9IGRhdGEuc3Vic3RyKHBvcywgdHJhbnNwb3J0U01GTWVzc2FnZS5wYXlsb2FkTGVuZ3RoKTsgLy8gcm91dGVyIHRhZ1xuICByZXR1cm4gdHJhbnNwb3J0U01GTWVzc2FnZTtcbn1cblxuY29uc3QgVHJhbnNwb3J0ID0ge1xuICBnZW5Uc0NyZWF0ZUhlYWRlcixcbiAgZ2VuVHNEZXN0cm95SGVhZGVyLFxuICBnZW5Uc0RhdGFUb2tlbk1zZyxcbiAgZ2VuVHNEYXRhU3RyZWFtVG9rZW5Nc2csXG4gIGdlblRzRGF0YU1zZ0hlYWRlclBhcnRzLFxuICBwYXJzZVRzU21mSGRyQXQsXG4gIHBhcnNlVHNTbWZNc2dBdCxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvdHJhbnNwb3J0LmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuY29uc3QgU01GVUggPSB7XG4gIElHTk9SRTogMHgwLFxuICBSRUpFQ1Q6IDB4Mixcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRlVIID0gRW51bS5uZXcoU01GVUgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9tZXNzYWdlLW9iamVjdHMvc21mLXVoLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlID0ge1xuICBPUEVOUFVCRkxPVzogICAgICAweDAwLFxuICAvLyBJTlRFUlJPVVRFUkFDSzogICAgICAgICAgMHgwMSxcbiAgLy8gSU5URVJST1VURVJIQU5EU0hBS0VBQ0s6IDB4MDIsXG4gIENMSUVOVEFDSzogICAgICAgIDB4MDMsXG4gIEJJTkQ6ICAgICAgICAgICAgIDB4MDQsXG4gIFVOQklORDogICAgICAgICAgIDB4MDUsXG4gIFVOU1VCU0NSSUJFOiAgICAgIDB4MDYsXG4gIENMT1NFUFVCRkxPVzogICAgIDB4MDcsXG4gIENSRUFURTogICAgICAgICAgIDB4MDgsXG4gIERFTEVURTogICAgICAgICAgIDB4MDksXG4gIC8vIEZMT1dSRUNPVkVSOiAgMHgwYSxcbiAgVFJBTlNBQ1RJT05DVFJMOiAgMHgwYixcbiAgRkxPV0NIQU5HRVVQREFURTogMHgwYyxcbiAgLy8gRVhURVJOQUxBQ0s6ICAgICAgMHgwZCxcbiAgWEFDVFJMOiAgICAgICAgICAgMHgwZSxcbiAgQ0xJRU5UTkFDSzogICAgICAgMHgwZixcbiAgLy8gVFhOQ1RSTDogICAgICAgICAgMHgxMCxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSA9IEVudW0ubmV3KFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1hZHByb3RvY29sLW1lc3NhZ2UtdHlwZXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTTUZBZFByb3RvY29sUGFyYW0gPSB7XG4gIExBU1RNU0dJRFNFTlQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMSxcbiAgTEFTVE1TR0lEQUNLRUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAweDAyLFxuICBXSU5ET1c6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDMsXG4gIFRSQU5TUE9SVF9QUklPUklUWTogICAgICAgICAgICAgICAgICAgICAgMHgwNCxcbiAgQVBQTElDQVRJT05fQUNLOiAgICAgICAgICAgICAgICAgICAgICAgICAweDA1LFxuICBGTE9XSUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDYsXG4gIFFVRVVFTkFNRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwNyxcbiAgRFRFTkFNRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDA4LFxuICBUT1BJQ05BTUU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDksXG4gIEZMT1dOQU1FOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwYSxcbiAgRVBfRFVSQUJMRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDBiLFxuICBBQ0NFU1NUWVBFOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MGMsXG4gIFNFTEVDVE9SOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwZCxcbiAgVFJBTlNQT1JUX1dJTkRPVzogICAgICAgICAgICAgICAgICAgICAgICAweDBlLFxuICBMSU5HRVJfT1BUSU9OOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MGYsXG4gIExBU1RNU0dJRFJFQ0VJVkVEOiAgICAgICAgICAgICAgICAgICAgICAgMHgxMCxcbiAgRVBfQUxMT1RIRVJfUEVSTUlTU0lPTjogICAgICAgICAgICAgICAgICAweDExLFxuICBGTE9XVFlQRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MTIsXG4gIEVQX1FVT1RBOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgxMyxcbiAgRVBfTUFYX01TR1NJWkU6ICAgICAgICAgICAgICAgICAgICAgICAgICAweDE0LFxuICBHUkFOVEVEX1BFUk1JU1NJT05TOiAgICAgICAgICAgICAgICAgICAgIDB4MTUsXG4gIEVQX1JFU1BFQ1RTX1RUTDogICAgICAgICAgICAgICAgICAgICAgICAgMHgxNixcbiAgVFJBTlNBQ1RJT05fQ1RSTF9NRVNTQUdFX1RZUEU6ICAgICAgICAgICAweDE3LFxuICBUUkFOU0FDVEVEX1NFU1NJT05fSUQ6ICAgICAgICAgICAgICAgICAgIDB4MTgsXG4gIFRSQU5TQUNURURfU0VTU0lPTl9OQU1FOiAgICAgICAgICAgICAgICAgMHgxOSxcbiAgVFJBTlNBQ1RJT05fSUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAweDFhLFxuICBUUkFOU0FDVEVEX1NFU1NJT05fU1RBVEU6ICAgICAgICAgICAgICAgIDB4MWIsXG4gIFRSQU5TQUNUSU9OX0ZMT1dfREVTQ1JJUFRPUl9QVUJfTk9USUZZOiAgMHgxYyxcbiAgVFJBTlNBQ1RJT05fRkxPV19ERVNDUklQVE9SX1BVQl9BQ0s6ICAgICAweDFkLFxuICBUUkFOU0FDVElPTl9GTE9XX0RFU0NSSVBUT1JfU1VCX0FDSzogICAgIDB4MWUsXG4gIE5PTE9DQUw6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgxZixcbiAgQUNUSVZFX0ZMT1dfSU5ESUNBVElPTjogICAgICAgICAgICAgICAgICAweDIwLFxuICBXQU5UX0ZMT1dfQ0hBTkdFX05PVElGWTogICAgICAgICAgICAgICAgIDB4MjEsXG4gIEVQX0JFSEFWSU9VUjogICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyMixcbiAgUFVCTElTSEVSX0lEOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDIzLFxuICBBUFBMSUNBVElPTl9QVUJfQUNLOiAgICAgICAgICAgICAgICAgICAgIDB4MjQsXG4gIE5VTV9NRVNTQUdFU19TUE9PTEVEOiAgICAgICAgICAgICAgICAgICAgMHgyNSxcbiAgQ1VUX1RIUk9VR0g6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDI2LFxuICBQVUJMSVNIRVJfRkxBR1M6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4MjcsXG4gIEFQUF9NU0dfSURfVFlQRTogICAgICAgICAgICAgICAgICAgICAgICAgMHgyOCxcbiAgUVVFVUVfRU5EUE9JTlRfSEFTSDogICAgICAgICAgICAgICAgICAgICAweDI5LFxuICBNQVhfUkVERUxJVkVSWTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4MmEsXG4gIFBBWUxPQUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyYixcbiAgRU5EUE9JTlRfSUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDJjLFxuICBBQ0tfU0VRVUVOQ0VfTlVNQkVSOiAgICAgICAgICAgICAgICAgICAgIDB4MmQsXG4gIEFDS19SRUNPTkNJTEVfUkVRVUVTVDogICAgICAgICAgICAgICAgICAgMHgyZSxcbiAgU1RBUlRfT0ZfQUNLX1JFQ09OQ0lMRTogICAgICAgICAgICAgICAgICAweDJmLFxuICBUSU1FU1RBTVA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MzAsXG4gIE1BWF9ERUxJVkVSRURfVU5BQ0tFRF9NRVNTQUdFU19QRVJfRkxPVzogMHgzMSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRkFkUHJvdG9jb2xQYXJhbSA9IEVudW0ubmV3KFNNRkFkUHJvdG9jb2xQYXJhbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1hZHByb3RvY29sLXBhcmFtcy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNNRkNsaWVudEN0cmxNZXNzYWdlVHlwZSA9IHtcbiAgTE9HSU46ICAweDAwLFxuICBVUERBVEU6IDB4MDEsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TTUZDbGllbnRDdHJsTWVzc2FnZVR5cGUgPSBFbnVtLm5ldyhTTUZDbGllbnRDdHJsTWVzc2FnZVR5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtY2xpZW50LWN0cmwtbWVzc2FnZS10eXBlcy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNNRkNsaWVudEN0cmxQYXJhbSA9IHtcbiAgU09GVFdBUkVWRVJTSU9OOiAgICAgICAgICAgICAgMHgwMCxcbiAgU09GVFdBUkVEQVRFOiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgUExBVEZPUk06ICAgICAgICAgICAgICAgICAgICAgMHgwMixcbiAgVVNFUklEOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ0xJRU5UREVTQzogICAgICAgICAgICAgICAgICAgMHgwNCxcbiAgQ0xJRU5UTkFNRTogICAgICAgICAgICAgICAgICAgMHgwNSxcbiAgTVNHVlBOTkFNRTogICAgICAgICAgICAgICAgICAgMHgwNixcbiAgREVMSVZFUlRPT05FUFJJT1JJVFk6ICAgICAgICAgMHgwNyxcbiAgUDJQVE9QSUM6ICAgICAgICAgICAgICAgICAgICAgMHgwOCxcbiAgUk9VVEVSX0NBUEFCSUxJVElFUzogICAgICAgICAgMHgwOSxcbiAgVlJJRE5BTUU6ICAgICAgICAgICAgICAgICAgICAgMHgwYSxcbiAgUEhZU0lDQUxST1VURVJOQU1FOiAgICAgICAgICAgMHgwYyxcbiAgQlJJREdFX01TR19WUE5fTkFNRTogICAgICAgICAgMHgwZCxcbiAgQlJJREdFX1JPVVRFUl9OQU1FOiAgICAgICAgICAgMHgwZSxcbiAgTk9fTE9DQUw6ICAgICAgICAgICAgICAgICAgICAgMHgwZixcbiAgQlJJREdFX1ZFUlNJT046ICAgICAgICAgICAgICAgMHgxMCxcbiAgQVVUSEVOVElDQVRJT05fU0NIRU1FOiAgICAgICAgMHgxMSxcbiAgQ09OTkVDVElPTl9UWVBFOiAgICAgICAgICAgICAgMHgxMixcbiAgUk9VVEVSX0NBUEFCSUxJVElFU19FWFRFTkRFRDogMHgxMyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlNNRkNsaWVudEN0cmxQYXJhbSA9IEVudW0ubmV3KFNNRkNsaWVudEN0cmxQYXJhbSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zbWYvbGliL3NtZi1jbGllbnQtY3RybC1wYXJhbXMuanMiLCJjb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBTTUZTTVBNZXNzYWdlVHlwZUZsYWdzID0ge1xuICBGTEFHX0ZJTFRFUjogICAgICAgICAgICAgICAgMSxcbiAgRkxBR19QRVJTSVNUOiAgICAgICAgICAgICAgIDIsXG4gIFNNRl9TTVBfRkxBR19UT1BJQzogICAgICAgICA0LFxuICBTTUZfU01QX0ZMQUdfUkVTUFJFUVVJUkVEOiAgOCxcbiAgU01GX1NNUF9GTEFHX0RFTElWRVJBTFdBWVM6IDE2LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU01GU01QTWVzc2FnZVR5cGVGbGFncyA9IEVudW0ubmV3KFNNRlNNUE1lc3NhZ2VUeXBlRmxhZ3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtc21wLW1lc3NhZ2UtdHlwZS1mbGFncy5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZSA9IHtcbiAgQ1JFQVRFOiAgICAgICAgICAgIDAsXG4gIENSRUFURV9SRVNQOiAgICAgICAxLFxuICBERVNUUk9ZOiAgICAgICAgICAgMixcbiAgREVTVFJPWV9SRVNQOiAgICAgIDMsXG4gIERBVEE6ICAgICAgICAgICAgICA0LFxuICBEQVRBX1RPS0VOOiAgICAgICAgNSxcbiAgREFUQV9TVFJFQU1fVE9LRU46IDYsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUgPSBFbnVtLm5ldyhTTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9zbWYtdHJhbnNwb3J0LXNlc3Npb24tbWVzc2FnZS10eXBlcy5qcyIsIi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgYnkgYSBjYWNoZSBzZXNzaW9uIHdoZW4gYSBjYWNoZSByZXF1ZXN0XG4gKiBjb21wbGV0ZXMuXG4gKlxuICogQGNhbGxiYWNrIHNvbGFjZS5DYWNoZUNCSW5mby5jYWNoZVJlcXVlc3RDYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcmVxdWVzdElEIFRoZSBJRCBvZiB0aGUgcmVxdWVzdCBvbiB3aGljaCB0aGUgZXZlbnQgaXMgbm90aWZpZWQuXG4gKiBAcGFyYW0ge3NvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHR9IHJlc3VsdCBUaGUgcmVzdWx0IG9mIHRoZSBjYWNoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJPYmplY3QgVGhlIHVzZXIgb2JqZWN0IHByb3ZpZGVkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFbmNhcHN1bGF0ZXMgYSB7QGxpbmsgc29sYWNlLkNhY2hlU2Vzc2lvbn0ncyByZXF1ZXN0IGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZFxuICogb3B0aW9uYWwgYXBwbGljYXRpb24tc3BlY2lmaWVkIGNvbnRleHQgb2JqZWN0LlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSByZXF1aXJlZCBhcyBhIHBhcmFtZXRlciB0b1xuICoge0BsaW5rIHNvbGFjZS5DYWNoZVNlc3Npb24jc2VuZENhY2hlUmVxdWVzdH0gd2hlbiBjcmVhdGluZyBhIENhY2hlU2Vzc2lvbiByZXF1ZXN0LlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgQ2FjaGVDQkluZm8ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENhY2hlQ0JJbmZvIHVzaW5nIHRoZSBwcm92aWRlZCBjYWxsYmFjayBhbmQgdXNlciBjb250ZXh0IG9iamVjdC5cbiAgICogQHBhcmFtIHtzb2xhY2UuQ2FjaGVDQkluZm8uY2FjaGVSZXF1ZXN0Q2FsbGJhY2t9IGNhY2hlQ0JGdW5jdGlvbiBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPYmplY3QgQSBjb250ZXh0IG9iamVjdCB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlQ0JGdW5jdGlvbiwgdXNlck9iamVjdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBjYWNoZSBzZXNzaW9uIHdoZW4gYSByZXF1ZXN0XG4gICAgICogY29tcGxldGVzLlxuICAgICAqIEB0eXBlIHtzb2xhY2UuQ2FjaGVDQkluZm8uY2FjaGVSZXF1ZXN0Q2FsbGJhY2t9XG4gICAgICovXG4gICAgdGhpcy5jYWNoZUNCRnVuY3Rpb24gPSBjYWNoZUNCRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXNlciBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgc3VwcGxpZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogd2hlbiB0aGUgY2FjaGUgcmVxdWVzdCBjb21wbGV0ZXMuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJPYmplY3QgPSB1c2VyT2JqZWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuQ2FjaGVDQkluZm8uY2FjaGVSZXF1ZXN0Q2FsbGJhY2t9IFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q2FsbGJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVDQkZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHsqfSBUaGUgdXNlciBjb250ZXh0IG9iamVjdCwgaWYgYW55XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRVc2VyT2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnVzZXJPYmplY3Q7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5DYWNoZUNCSW5mbyA9IENhY2hlQ0JJbmZvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtY2ItaW5mby5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogc29sYWNlLkNhY2hlTGl2ZURhdGFBY3Rpb25cbiAqIEVudW1lcmF0aW9uIG9mIENhY2hlTGl2ZURhdGFBY3Rpb24gdmFsdWVzLCBzcGVjaWZ5aW5nIGhvdyB0aGUgQ2FjaGVTZXNzaW9uIHNob3VsZCBoYW5kbGVcbiAqIGxpdmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggYSBjYWNoZSByZXF1ZXN0IGluIHByb2dyZXNzLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgQ2FjaGVMaXZlRGF0YUFjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBFbmQgdGhlIGNhY2hlIHJlcXVlc3Qgd2hlbiBsaXZlIGRhdGEgYXJyaXZlcyB0aGF0IG1hdGNoZXMgdGhlIHRvcGljLlxuICAgKiBOb3RlIHRoYXQgd2lsZGNhcmQgY2FjaGUgcmVxdWVzdHMgbXVzdCBhbHdheXMgYmUge0BsaW5rIENhY2hlTGl2ZURhdGFBY3Rpb24uRkxPV19USFJVfS5cbiAgICovXG4gIEZVTEZJTEw6ICAgMSxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBRdWV1ZSBhcnJpdmluZyBsaXZlIGRhdGEgdGhhdCBtYXRjaGVzIHRoZSB0b3BpYywgdW50aWwgdGhlIGNhY2hlIHJlcXVlc3RcbiAgICogY29tcGxldGVzLiBOb3RlIHRoYXQgd2lsZGNhcmQgY2FjaGUgcmVxdWVzdHMgbXVzdCBhbHdheXMgYmUge0BsaW5rXG4gICAqIHNvbGFjZS5DYWNoZUxpdmVEYXRhQWN0aW9uLkZMT1dfVEhSVX0uXG4gICAqL1xuICBRVUVVRTogICAgIDIsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gQ29udGludWUgdGhlIG91dHN0YW5kaW5nIGNhY2hlIHJlcXVlc3Qgd2hpbGUgYWxsb3dpbmcgbGl2ZSBkYXRhIHRvIGZsb3cgdGhyb3VnaCB0b1xuICAgKiB0aGUgYXBwbGljYXRpb24uXG4gICAqIE5vdGUgdGhhdCB3aWxkY2FyZCBjYWNoZSByZXF1ZXN0cyBtdXN0IGFsd2F5cyBiZSB7QGxpbmsgQ2FjaGVMaXZlRGF0YUFjdGlvbi5GTE9XX1RIUlV9LlxuICAgKi9cbiAgRkxPV19USFJVOiAzLFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVMaXZlRGF0YUFjdGlvbiA9IEVudW0ubmV3KENhY2hlTGl2ZURhdGFBY3Rpb24pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtbGl2ZS1kYXRhLWFjdGlvbnMuanMiLCIvKipcbiAqIEBjbGFzc2Rlc2NcbiAqIDxiPlRoaXMgY2xhc3MgaXMgbm90IGV4cG9zZWQgZm9yIGNvbnN0cnVjdGlvbiBieSBBUEkgdXNlcnMuIEEgQ2FjaGVSZXF1ZXN0UmVzdWx0IG9iamVjdCBpc1xuICogcHJvdmlkZWQgb24gdGhlIGNhbGxiYWNrIChzZWUge0BsaW5rIHNvbGFjZS5DYWNoZUNCSW5mby5jYWNoZVJlcXVlc3RDYWxsYmFja30gd2hlbiBhIGNhY2hlXG4gKiByZXF1ZXN0IGNvbXBsZXRlcy48L2I+XG4gKlxuICogQW4gb2JqZWN0IHRoYXQgaW5kaWNhdGVzIHRoZSB0ZXJtaW5hdGlvbiBvZiBhIGNhY2hlIHJlcXVlc3QsIGFuZCBwcm92aWRlcyBkZXRhaWxzIGhvdyBpdFxuICogY29uY2x1ZGVkLlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQGhpZGVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBDYWNoZVJlcXVlc3RSZXN1bHQge1xuICAvKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5DYWNoZVJldHVybkNvZGV9IHJjIFRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuXG4gICAqICAgKiBXaGVuIHJldHVybkNvZGUgPT09IENhY2hlUmV0dXJuQ29kZS5PSywgdGhlIGFwcGxpY2FibGUgc3ViY29kZXMgYXJlOlxuICAgKiAgICAgKiB7QGxpbmsgQ2FjaGVSZXR1cm5TdWJjb2RlLlJFUVVFU1RfQ09NUExFVEV9XG4gICAqICAgICAqIHtAbGluayBDYWNoZVJldHVyblN1YmNvZGUuTElWRV9EQVRBX0ZVTEZJTEx9XG4gICAqICAgKiBXaGVuIHJldHVybkNvZGUgPT09IENhY2hlUmV0dXJuQ29kZS5GQUlMLCBhcHBsaWNhYmxlIHN1YmNvZGVzIGFyZTpcbiAgICogICAgICoge0BsaW5rIENhY2hlUmV0dXJuU3ViY29kZS5FUlJPUl9SRVNQT05TRX1cbiAgICogICAgICoge0BsaW5rIENhY2hlUmV0dXJuU3ViY29kZS5JTlZBTElEX1NFU1NJT059XG4gICAqICAgICAqIHtAbGluayBDYWNoZVJldHVyblN1YmNvZGUuUkVRVUVTVF9BTFJFQURZX0lOX1BST0dSRVNTfVxuICAgKiAgICogV2hlbiByZXR1cm5Db2RlID09PSBDYWNoZVJldHVybkNvZGUuSU5DT01QTEVURSwgYXBwbGljYWJsZSBzdWJjb2RlcyBhcmU6XG4gICAqICAgICAqIHtAbGluayBDYWNoZVJldHVyblN1YmNvZGUuTk9fREFUQX1cbiAgICogICAgICoge0BsaW5rIENhY2hlUmV0dXJuU3ViY29kZS5SRVFVRVNUX1RJTUVPVVR9XG4gICAqICAgICAqIHtAbGluayBDYWNoZVJldHVyblN1YmNvZGUuU1VTUEVDVF9EQVRBfVxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5DYWNoZVJldHVyblN1YmNvZGV9IHN1YmNvZGUgVGhlIHN1YmNvZGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LiBQcm92aWRlc1xuICAgKiAgICBkZXRhaWxzIG9uIHRoZSBjb25kaXRpb24gdGhhdCBjYXVzZWQgdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIHtzb2xhY2UuRGVzdGluYXRpb259IHRvcGljIFRoZSB0b3BpYyBkZXN0aW5hdGlvbiBvbiB3aGljaCB0aGUgcmVxdWVzdCB3YXMgbWFkZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yIFRoZSBlcnJvciwgaWYgYW55LCB0aGF0IGNhdXNlZCB0aGUgY3VycmVudCByZXN1bHQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyYywgc3ViY29kZSwgdG9waWMsIGVycm9yKSB7XG4gICAgdGhpcy5fcmV0dXJuQ29kZSA9IHJjO1xuICAgIHRoaXMuX3N1YmNvZGUgPSBzdWJjb2RlO1xuICAgIHRoaXMuX3RvcGljID0gdG9waWM7XG4gICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZXR1cm4gY29kZSBmcm9tIHRoZSBjYWNoZSByZXF1ZXN0IHJlc3VsdC5cbiAgICpcbiAgICogQHJldHVybnMge3NvbGFjZS5DYWNoZVJldHVybkNvZGV9IFRoZSByZXR1cm4gY29kZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3VsdCBvZlxuICAgKiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGdldFJldHVybkNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHVybkNvZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmV0dXJuIHN1YmNvZGUgZnJvbSB0aGUgY2FjaGUgcmVxdWVzdCByZXN1bHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuQ2FjaGVSZXR1cm5TdWJjb2RlfSBBIHN1YmNvZGUgdGhhdCBnaXZlcyBtb3JlIGRldGFpbCB0aGFuXG4gICAqIHtAbGluayBDYWNoZVJlcXVlc3RSZXN1bHQjZ2V0UmV0dXJuQ29kZX0gYWJvdXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGdldFJldHVyblN1YmNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YmNvZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG9waWMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FjaGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybnMge3NvbGFjZS5EZXN0aW5hdGlvbn0gVGhlIHRvcGljIGRlc3RpbmF0aW9uIHN1cHBsaWVkIGZvciB0aGUgY2FjaGUgcmVxdWVzdC5cbiAgICovXG4gIGdldFRvcGljKCkge1xuICAgIHJldHVybiB0aGlzLl90b3BpYztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGVycm9yLCBpZiBhbnksIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmV0dXJuZWQgcmVzdWx0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXR1cm5lZCByZXN1bHQuXG4gICAqL1xuICBnZXRFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVSZXF1ZXN0UmVzdWx0ID0gQ2FjaGVSZXF1ZXN0UmVzdWx0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmVxdWVzdC1yZXN1bHQuanMiLCJjb25zdCB7IENhY2hlQ29udGV4dCB9ID0gcmVxdWlyZSgnLi9jYWNoZS1jb250ZXh0Jyk7XG5jb25zdCB7IExPR19ERUJVRyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuXG5jb25zdCB7IENBQ0hFX1JFUVVFU1RfUFJFRklYIH0gPSBDYWNoZUNvbnRleHQ7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2FjaGVSZXF1ZXN0IHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0NhY2hlU2Vzc2lvbn0gY2FjaGVTZXNzaW9uIFRoZSBvd25pbmcgc2Vzc2lvblxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdFR5cGV9IGNhY2hlTWVzc2FnZVR5cGUgVGhlIHR5cGUgb2YgcmVxdWVzdFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVxdWVzdElEIFRoZSBJRCBmb3IgdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtDYWNoZUNCSW5mb30gY2JJbmZvIENhbGxiYWNrIHRhcmdldFxuICAgKiBAcGFyYW0ge0NhY2hlTGl2ZURhdGFBY3Rpb259IGxpdmVEYXRhQWN0aW9uIEFjdGlvbiBvbiBsaXZlIGRhdGEgcmVjZWl2ZWRcbiAgICogQHBhcmFtIHtUb3BpY30gdG9waWMgQXNzb2NpYXRlZCB0b3BpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVOYW1lIEFzc29jaWF0ZWQgcmVtb3RlIGNhY2hlIG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlU2Vzc2lvbiwgY2FjaGVNZXNzYWdlVHlwZSwgcmVxdWVzdElELCBjYkluZm8sIGxpdmVEYXRhQWN0aW9uLCB0b3BpYywgY2FjaGVOYW1lKSB7XG4gICAgdGhpcy5jYWNoZVNlc3Npb24gPSBjYWNoZVNlc3Npb247XG4gICAgdGhpcy5jYWNoZU1lc3NhZ2VUeXBlID0gY2FjaGVNZXNzYWdlVHlwZTtcbiAgICB0aGlzLnJlcXVlc3RJRCA9IHJlcXVlc3RJRDtcbiAgICB0aGlzLmNiSW5mbyA9IGNiSW5mbztcbiAgICB0aGlzLmxpdmVEYXRhQWN0aW9uID0gbGl2ZURhdGFBY3Rpb247XG4gICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgIHRoaXMuY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25XYWl0aW5nID0gbnVsbDtcbiAgICB0aGlzLnJlcGx5UmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGFSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdXNwZWN0ID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvcnJlbGF0aW9uSUQgPSBgJHtDQUNIRV9SRVFVRVNUX1BSRUZJWH0ke0NhY2hlQ29udGV4dC5jYWNoZVJlcXVlc3RDb3JyZWxhdGlvbklkKyt9YDtcblxuICAgIHRoaXMuY2hpbGRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMucGFyZW50UmVxdWVzdCA9IG51bGw7XG5cbiAgICB0aGlzLnF1ZXVlZExpdmVEYXRhID0gW107XG4gICAgdGhpcy5saXZlRGF0YUZ1bGZpbGxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy50aW1lb3V0SGFuZGxlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q2FjaGVSZXF1ZXN0fSBUaGUgcm9vdCBjYWNoZSByZXF1ZXN0IGluIHRoZSBjdXJyZW50IHJlcXVlc3QgdHJlZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Um9vdFJlcXVlc3QoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudFJlcXVlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJlbnRSZXF1ZXN0LmdldFJvb3RSZXF1ZXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWNoZVJlcXVlc3R9IGNoaWxkSW4gQSByZXF1ZXN0IHRvIG1ha2UgYSBkZXNjZW5kYW50IG9mIHRoaXMgbm9kZSBpbiB0aGUgcmVxdWVzdCB0cmVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRDaGlsZChjaGlsZEluKSB7XG4gICAgaWYgKCEoY2hpbGRJbiBpbnN0YW5jZW9mIENhY2hlUmVxdWVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCAke2NoaWxkSW59YCk7XG4gICAgfVxuICAgIGlmIChjaGlsZEluID09PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnN0cnVjdGluZyBjaXJjdWxhciBjaGlsZCByZWZlcmVuY2UnKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZEluO1xuICAgIGNoaWxkLnBhcmVudFJlcXVlc3QgPSB0aGlzO1xuICAgIHRoaXMuY2hpbGRSZXF1ZXN0cy5wdXNoKGNoaWxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gY2hpbGRJbiBBIHJlcXVlc3QgdG8gcmVtb3ZlIGFzIGEgZGVzY2VuZGFudCBvZiB0aGlzIG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZUNoaWxkKGNoaWxkSW4pIHtcbiAgICBpZiAoY2hpbGRJbiA9PT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGRlY29uc3RydWN0IGludmFsaWQgY2lyY3VsYXIgY2hpbGQgcmVmZXJlbmNlJyk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRJbjtcbiAgICBjb25zdCBjaGlsZEluZGV4ID0gdGhpcy5jaGlsZFJlcXVlc3RzLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChjaGlsZEluZGV4ID09PSAtMSkge1xuICAgICAgTE9HX0RFQlVHKGBDaGlsZCAke2NoaWxkfSBub3QgZm91bmQgaW4gJHt0aGlzfWApO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkUmVxdWVzdHMuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgIGNoaWxkLnBhcmVudFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb2xsYXBzZSgpIHtcbiAgICBjb25zdCBwYXJlbnRSZXF1ZXN0ID0gdGhpcy5wYXJlbnRSZXF1ZXN0O1xuICAgIHBhcmVudFJlcXVlc3QuaXNTdXNwZWN0ID0gcGFyZW50UmVxdWVzdC5pc1N1c3BlY3QgfHwgdGhpcy5pc1N1c3BlY3Q7XG4gICAgcGFyZW50UmVxdWVzdC5kYXRhUmVjZWl2ZWQgPSBwYXJlbnRSZXF1ZXN0LmRhdGFSZWNlaXZlZCB8fCB0aGlzLmRhdGFSZWNlaXZlZDtcbiAgICBwYXJlbnRSZXF1ZXN0LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50UmVxdWVzdCkge1xuICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmNoaWxkUmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKGNoaWxkLmNoaWxkUmVxdWVzdHMpIHtcbiAgICAgICAgY2hpbGQuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyUmVxdWVzdFRpbWVvdXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgSUQgb2YgdGhpcyByZXF1ZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSZXF1ZXN0SUQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdElEO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybnMge0NhY2hlQ0JJbmZvfSBUaGUgY2FsbGJhY2sgb2JqZWN0IGZvciB0aGlzIHJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldENCSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5jYkluZm87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1RvcGljfSBUaGUgdG9waWMgZm9yIHRoaXMgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VG9waWMoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9waWM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q2FjaGVMaXZlRGF0YUFjdGlvbn0gVGhlIGxpdmUgZGF0YSBhY3Rpb24gZm9yIHRoaXMgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGl2ZURhdGFBY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGl2ZURhdGFBY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih7c29sYWNlLkNhY2hlUmVxdWVzdH0pfSBjYWNoZVNlc3Npb25UaW1lb3V0Q0IgQ2FsbGJhY2sgdG8gbm90aWZ5IG9uIHRpbWVvdXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRNc2VjIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFJlcXVlc3RUaW1lb3V0KGNhY2hlU2Vzc2lvblRpbWVvdXRDQiwgdGltZW91dE1zZWMpIHtcbiAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhY2hlU2Vzc2lvblRpbWVvdXRDQih0aGlzKTtcbiAgICB9LCB0aW1lb3V0TXNlYyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dEhhbmRsZSA9PT0gbnVsbCB8fCB0aGlzLnRpbWVvdXRIYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIExPR19ERUJVRyhgQ2xlYXJpbmcgdGltZW91dCBmb3IgJHt0aGlzfWApO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMudGltZW91dEhhbmRsZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEEgYnJpZWYgZGVzY3JpcHRpb24gb2YgdGhpcyBvYmplY3RcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgQ2FjaGVSZXF1ZXN0W2NvcnJlbGF0aW9uSUQ9JHt0aGlzLmNvcnJlbGF0aW9uSURcbiAgICAgICAgfSxyZXF1ZXN0SUQ9JHt0aGlzLnJlcXVlc3RJRFxuICAgICAgICB9LGNhY2hlTmFtZT0ke3RoaXMuY2FjaGVOYW1lXG4gICAgICAgIH0sdG9waWM9JHt0aGlzLnRvcGljLmdldE5hbWUoKX1dYDtcbiAgfVxuXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuQ2FjaGVSZXF1ZXN0LlZFUlNJT04gPSAxO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkNhY2hlUmVxdWVzdC5ERUZBVUxUX1JFUExZX1NJWkVfTElNSVQgPSAxMDAwMDAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkNhY2hlUmVxdWVzdC5SRVBMWV9TSVpFX0xJTUlUID0gQ2FjaGVSZXF1ZXN0LkRFRkFVTFRfUkVQTFlfU0laRV9MSU1JVDtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVSZXF1ZXN0ID0gQ2FjaGVSZXF1ZXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmVxdWVzdC5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgQ2FjaGVSZXR1cm5Db2RlIHR5cGVzLiAgVGhlIG1ldGhvZCB7QGxpbmsgc29sYWNlLkNhY2hlUmVxdWVzdFJlc3VsdCNnZXRSZXR1cm5Db2RlfVxuICogcmV0dXJucyBvbiBvZiB0aGVzZSBiYXNpYyByZXN1bHRzIG9mIGEgY2FjaGUgcmVxdWVzdC4gIE1vcmUgZGV0YWlscyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICogYXNzb2NpYXRlZCB7QGxpbmsgc29sYWNlLkNhY2hlUmV0dXJuU3ViY29kZX0sIHJldHJpZXZlZCBieVxuICoge0BsaW5rIHNvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHQjZ2V0UmV0dXJuU3ViY29kZX0uXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBDYWNoZVJldHVybkNvZGUgPSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGNhY2hlIHJlcXVlc3Qgc3VjY2VlZGVkLiAgU2VlIHRoZSBzdWJjb2RlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgT0s6ICAgICAgICAgMSxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgY2FjaGUgcmVxdWVzdCB3YXMgbm90IHByb2Nlc3NlZC4gIFNlZSB0aGUgc3ViY29kZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIEZBSUw6ICAgICAgIDIsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGNhY2hlIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZCBidXQgY291bGQgbm90IGJlIGNvbXBsZXRlZC4gIFNlZSB0aGUgc3ViY29kZSBmb3JcbiAgICogbW9yZSBpbmZvcm1hdGlvbi5cbiAgICovXG4gIElOQ09NUExFVEU6IDMsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJldHVybkNvZGUgPSBFbnVtLm5ldyhDYWNoZVJldHVybkNvZGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtcmV0dXJuLWNvZGVzLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBDYWNoZVJldHVyblN1YmNvZGUgdHlwZXMuXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBDYWNoZVJldHVyblN1YmNvZGUgPSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGNhY2hlIHJlcXVlc3QgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICovXG4gIFJFUVVFU1RfQ09NUExFVEU6ICAgICAgICAgICAgMCxcbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgY2FjaGUgcmVxdWVzdCBjb21wbGV0ZWQgd2hlbiBsaXZlIGRhdGEgYXJyaXZlZCBvbiB0aGUgdG9waWMgcmVxdWVzdGVkLlxuICAgKi9cbiAgTElWRV9EQVRBX0ZVTEZJTEw6ICAgICAgICAgICAxLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBjYWNoZSBpbnN0YW5jZSBvciBzZXNzaW9uIHJldHVybmVkIGFuIGVycm9yIHJlc3BvbnNlIHRvIHRoZSBjYWNoZSByZXF1ZXN0LlxuICAgKi9cbiAgRVJST1JfUkVTUE9OU0U6ICAgICAgICAgICAgICAyLFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBjYWNoZSByZXF1ZXN0IGZhaWxlZCBiZWNhdXNlIHRoZSB7QGxpbmsgU2Vzc2lvbn0gdXNlZCB0byBjb25zdHJ1Y3QgaXQgaGFzIGJlZW5cbiAgICogZGlzcG9zZWQuXG4gICAqL1xuICBJTlZBTElEX1NFU1NJT046ICAgICAgICAgICAgIDMsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIGNhY2hlIHJlcXVlc3QgZmFpbGVkIGJlY2F1c2UgdGhlIHJlcXVlc3QgdGltZW91dCBleHBpcmVkLlxuICAgKi9cbiAgUkVRVUVTVF9USU1FT1VUOiAgICAgICAgICAgICA0LFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBjYWNoZSByZXF1ZXN0IHdhcyBtYWRlIG9uIHRoZSBzYW1lIHRvcGljIGFzIGFuIGV4aXN0aW5nIHJlcXVlc3QsIGFuZFxuICAgKiB7QGxpbmsgQ2FjaGVMaXZlRGF0YUFjdGlvbi5GTE9XX1RIUlV9IHdhcyBub3Qgc2V0LlxuICAgKi9cbiAgUkVRVUVTVF9BTFJFQURZX0lOX1BST0dSRVNTOiA1LFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBjYWNoZSByZXBseSByZXR1cm5lZCBubyBkYXRhLlxuICAgKi9cbiAgTk9fREFUQTogICAgICAgICAgICAgICAgICAgICA2LFxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBjYWNoZSByZXBseSByZXR1cm5lZCBzdXNwZWN0IGRhdGEuXG4gICAqL1xuICBTVVNQRUNUX0RBVEE6ICAgICAgICAgICAgICAgIDcsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHJlcXVlc3Qgd2FzIHRlcm1pbmF0ZWQgYmVjYXVzZSB0aGUgY2FjaGUgc2Vzc2lvbiB3YXMgZGlzcG9zZWQuXG4gICAqL1xuICBDQUNIRV9TRVNTSU9OX0RJU1BPU0VEOiAgICAgIDgsXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHJlcXVlc3Qgd2FzIHRlcm1pbmF0ZWQgYmVjYXVzZSB0aGUgc3Vic2NyaXB0aW9uIHJlcXVlc3QgZm9yIHRoZSBzcGVjaWZpZWQgdG9waWMgZmFpbGVkLlxuICAgKi9cbiAgU1VCU0NSSVBUSU9OX0VSUk9SOiAgICAgICAgICA5LFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVSZXR1cm5TdWJjb2RlID0gRW51bS5uZXcoQ2FjaGVSZXR1cm5TdWJjb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLXJldHVybi1zdWJjb2Rlcy5qcyIsIi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyBvZiBhIGNhY2hlIHNlc3Npb24uXG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICpcbiAqL1xuY2xhc3MgQ2FjaGVTZXNzaW9uUHJvcGVydGllcyB7XG5cbiAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGNhY2hlTmFtZSBBIHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBjYWNoZSBuYW1lIHRvIHdoaWNoIENhY2hlU2Vzc2lvblxuICAgICogICBvcGVyYXRpb25zIHNob3VsZCBiZSBzZW50LlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhBZ2VTZWM9MF0gVGhlIG1heGltdW0gYWxsb3dhYmxlIG1lc3NhZ2UgYWdlIGluIHNlY29uZHMgdG8gZGVsaXZlciBpblxuICAgICogICByZXNwb25zZSB0byBhIGNhY2hlIHJlcXVlc3QuIDAgbWVhbnMgbm8gcmVzdHJpY3Rpb24gb24gYWdlLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhNZXNzYWdlcz0xXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWVzc2FnZXMgcGVyIFRvcGljIHRvIGRlbGl2ZXIgaW5cbiAgICAqICAgcmVzcG9uc2UgdG8gY2FjaGUgcmVxdWVzdHMuIDAgbWVhbnMgbm8gcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiBtZXNzYWdlcy5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dE1zZWM9MTAwMDBdIFRoZSB0aW1lb3V0IHBlcmlvZCAoaW4gbWlsbGlzZWNvbmRzKSB0byB3YWl0IGZvciBhXG4gICAgKiAgIHJlc3BvbnNlIGZyb20gdGhlIGNhY2hlLiBUaGlzIGlzIGEgcHJvdG9jb2wgdGltZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBBUEkgb24gZWFjaFxuICAgICogICBtZXNzYWdlIGV4Y2hhbmdlIHdpdGggU29sQ2FjaGUuIEEgc2luZ2xlIGNhbGwgdG9cbiAgICAqICAge0BsaW5rIHNvbGFjZS5DYWNoZVNlc3Npb24jc2VuZENhY2hlUmVxdWVzdH0gbWF5IGxlYWQgdG8gbWFueSByZXF1ZXN0LXJlcGx5IGV4Y2hhbmdlc1xuICAgICogICB3aXRoIFNvbENhY2hlIGFuZCBzbyBpcyBub3QgYm91bmRlZCBieSB0aGlzIHRpbWVyIGFzIGxvbmcgYXMgZWFjaCBpbnRlcm5hbCByZXF1ZXN0IGlzXG4gICAgKiAgIHNhdGlzZmllZCBpbiB0aW1lLlxuICAgICogICAqIFRoZSB2YWxpZCByYW5nZSBmb3IgdGhpcyBwcm9wZXJ0eSBpcyA+PSAzMDAwLlxuICAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSwgbWF4QWdlU2VjLCBtYXhNZXNzYWdlcywgdGltZW91dE1zZWMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEEgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIGNhY2hlIG5hbWUgdG8gd2hpY2ggQ2FjaGVTZXNzaW9uIG9wZXJhdGlvbnMgc2hvdWxkXG4gICAgICogYmUgc2VudC5cbiAgICAgKi9cbiAgICB0aGlzLmNhY2hlTmFtZSA9IGNhY2hlTmFtZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIG1heGltdW0gYWxsb3dhYmxlIG1lc3NhZ2UgYWdlIGluIHNlY29uZHMgdG8gZGVsaXZlciBpbiByZXNwb25zZSB0byBjYWNoZVxuICAgICAqIHJlcXVlc3RzLiAgMCBtZWFucyBubyByZXN0cmljdGlvbiBvbiBhZ2UuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5tYXhBZ2VTZWMgPSBtYXhBZ2VTZWMgfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHBlciBUb3BpYyB0byBkZWxpdmVyIGluIHJlc3BvbnNlIHRvIGNhY2hlXG4gICAgICogcmVxdWVzdHMuICAwIG1lYW5zIG5vIHJlc3RyaWN0aW9uIG9uIHRoZSBudW1iZXIgb2YgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5tYXhNZXNzYWdlcyA9IChtYXhNZXNzYWdlcyA9PT0gbnVsbCB8fCBtYXhNZXNzYWdlcyA9PT0gdW5kZWZpbmVkKSA/IDEgOiBtYXhNZXNzYWdlcztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHRpbWVvdXQgZm9yIGEgY2FjaGUgcmVxdWVzdCwgaW4gbWlsbGlzZWNvbmRzLiAgVGhlIHZhbGlkIHJhbmdlIGZvciB0aGlzXG4gICAgICogcHJvcGVydHkgaXMgPj0gMzAwMC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDEwMDAwXG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0TXNlYyA9IHRpbWVvdXRNc2VjIHx8IDEwMDAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gV2hldGhlciB0byBpbmNsdWRlIG90aGVyIGNsdXN0ZXJzIGluIHRoZSByZXF1ZXN0LlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLmluY2x1ZGVPdGhlckNsdXN0ZXJzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYWNoZVByZWZpeCA9ICcjUDJQL0NBQ0hFSU5TVC8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNhY2hlIG5hbWUgdG8gd2hpY2gge0BsaW5rIHNvbGFjZS5DYWNoZVNlc3Npb259IHJlcXVlc3RzIHNob3VsZCBiZSBzZW50LCBmb3JcbiAgICogc2Vzc2lvbnMgY29uc3RydWN0ZWQgdXNpbmcgdGhlc2UgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGNhY2hlIG5hbWUuXG4gICAqL1xuICBnZXRDYWNoZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhY2hlIG5hbWUgdG8gd2hpY2ggcmVxdWVzdHMgc2hvdWxkIGJlIHNlbnQuIENhbm5vdCBiZSBudWxsIG9yIGJsYW5rLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNhY2hlIG5hbWUgdG8gd2hpY2ggcmVxdWVzdHMgc2hvdWxkIGJlIHNlbnQuXG4gICAqL1xuICBzZXRDYWNoZU5hbWUodmFsdWUpIHtcbiAgICB0aGlzLmNhY2hlTmFtZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gYWxsb3dhYmxlIG1lc3NhZ2UgYWdlIGZvciBtZXNzYWdlcyB0byBiZSBkZWxpdmVyZWQgaW4gcmVzcG9uc2UgdG8gYSByZXF1ZXN0XG4gICAqIG1hZGUgb24gYSB7QGxpbmsgc29sYWNlLkNhY2hlU2Vzc2lvbn0gdGhhdCB3YXMgY29uc3RydWN0ZWQgdXNpbmcgdGhlc2UgcHJvcGVydGllcy4gIDAgbWVhbnMgbm9cbiAgICogcmVzdHJpY3Rpb24gb24gYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbWF4aW11bSBhbGxvd2FibGUgbWVzc2FnZSBhZ2UgdG8gYmUgcmV0dXJuZWQgYnkgYW4gYXNzb2NpYXRlZCB7QGxpbmtcbiAgICogc29sYWNlLkNhY2hlU2Vzc2lvbn0sIG9yIDAgZm9yIG5vIHJlc3RyaWN0aW9uLlxuICAgKi9cbiAgZ2V0TWF4TWVzc2FnZUFnZVNlYygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhBZ2VTZWM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBhbGxvd2FibGUgbWVzc2FnZSBhZ2UuIDAgbWVhbnMgbm8gcmVzdHJpY3Rpb24gb24gYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG1heGltdW0gYWxsb3dhYmxlIG1lc3NhZ2UgYWdlLCBvciAwIGZvciBubyByZXN0cmljdGlvbi5cbiAgICovXG4gIHNldE1heE1lc3NhZ2VBZ2VTZWModmFsdWUpIHtcbiAgICB0aGlzLm1heEFnZVNlYyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gY291bnQgb2YgbWVzc2FnZXMgdG8gYmUgZGVsaXZlcmVkLCBwZXIge0BsaW5rIHNvbGFjZS5EZXN0aW5hdGlvbn0sIGluXG4gICAqIHJlc3BvbnNlIHRvIGEgcmVxdWVzdCBpc3N1ZWQgb24gYSB7QGxpbmsgc29sYWNlLkNhY2hlU2Vzc2lvbn0gY29uc3RydWN0ZWQgdXNpbmcgdGhlc2VcbiAgICogcHJvcGVydGllcy4gIDAgbWVhbnMgbm8gcmVzdHJpY3Rpb24gb24gdGhlIG51bWJlciBvZiBtZXNzYWdlcy5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHBlciBUb3BpYyB0byBkZWxpdmVyLCBvciAwIGZvciBubyByZXN0cmljdGlvbi5cbiAgICovXG4gIGdldE1heE1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1heE1lc3NhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heGltdW0gY291bnQgb2YgbWVzc2FnZXMgdG8gYmUgZGVsaXZlcmVkIHBlciB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9ufSBpbiByZXNwb25zZVxuICAgKiB0byBhIGNhY2hlIHJlcXVlc3QuIDAgbWVhbnMgbm8gcmVzdHJpY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbWF4aW11bSBjb3VudCBvZiBtZXNzYWdlcyB0byBkZWxpdmVyLCBvciAwIGZvciBubyByZXN0cmljdGlvbi5cbiAgICovXG4gIHNldE1heE1lc3NhZ2VzKHZhbHVlKSB7XG4gICAgdGhpcy5tYXhNZXNzYWdlcyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRpbWVvdXQgZm9yIHJlcXVlc3RzIGlzc3VlZCBvbiBhIHtAbGluayBzb2xhY2UuQ2FjaGVTZXNzaW9ufSBjb25zdHJ1Y3RlZFxuICAgKiB1c2luZyB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiAgKiBUaGUgdmFsaWQgcmFuZ2UgaXMgPj0gMzAwMC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIHRpbWVvdXQsIGluIG1pbGxpc2Vjb25kcywgZm9yIGNhY2hlIHNlc3Npb24gcmVxdWVzdHMuXG4gICAqL1xuICBnZXRUaW1lb3V0TXNlYygpIHtcbiAgICByZXR1cm4gdGhpcy50aW1lb3V0TXNlYztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aW1lb3V0IGZvciByZXF1ZXN0cy5cbiAgICogICogVGhlIHZhbGlkIHJhbmdlIGlzID49IDMwMDAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdGltZW91dCBmb3IgcmVxdWVzdHMuXG4gICAqL1xuICBzZXRUaW1lb3V0TXNlYyh2YWx1ZSkge1xuICAgIHRoaXMudGltZW91dE1zZWMgPSB2YWx1ZTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLkNhY2hlU2Vzc2lvblByb3BlcnRpZXMgPSBDYWNoZVNlc3Npb25Qcm9wZXJ0aWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtc2Vzc2lvbi1wcm9wZXJ0aWVzLmpzIiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgU29sY2xpZW50U2Vzc2lvbkxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zZXNzaW9uJyk7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBMT0dfVFJBQ0UsIExPR19ERUJVRywgTE9HX1dBUk4gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcblxuLyoqXG4gKiBOb2RlIFRMUyBzb2NrZXQgb3B0aW9uIGdlbmVyYXRpb24gZmFjdG9yZWQgb3V0IGZyb20gV1MgdHJhbnNwb3J0LCBzaGFyZWQgd2l0aCBUY3AgdHJhbnNwb3J0LlxuICogSW50ZXJuYWwgbWl4aW4gY2xhc3MsIG5vdCBpbnRlbmRlZCB0byBiZSBwdWJsaWNseSB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuXG5jbGFzcyBOb2RlVExTT3B0c01peGluIHtcbiAgLyoqXG4gICAqIE92ZXJ3cml0ZSBOb2RlLmpzIGRlZmF1bHQgaG9zdG5hbWUgY2hlY2sgY2FsbGJhY2sgYnkgdmVyaWZ5aW5nIGNuTmFtZUxpc3QgYWdhaW5zdCBzdWJqZWN0IENOXG4gICAqIGluIHRoZSBzZXJ2ZXIgY2VydGlmaWNhdGUuIElmIGNuTmFtZUxpc3QgaXMgYSBlbXB0eSBzdHJpbmcsIGl0IG1lYW5zIGFsbCBDTnMgYXJlIGFjY2VwdGFibGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0IFRoZSBob3N0bmFtZSBmb3IgY2hlY2tpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNlcnQgVGhlIHNlcnZlciBjZXJ0aWZpY2F0ZSBmb3IgY2hlY2tpbmdcbiAgICogQG5hbWUgc29sYWNlLldlYlRyYW5zcG9ydFNlc3Npb24jY2hlY2tDZXJ0aWZpY2F0ZUNOc1xuICAgKiBAcmV0dXJucyB7P0Vycm9yfSBBbnkgZXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSBjZXJ0aWZpY2F0ZSBjaGVja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tDZXJ0aWZpY2F0ZUNOcyhob3N0LCBjZXJ0KSB7XG4gICAgaWYgKHRoaXMuX3Byb3BzLnNzbFRydXN0ZWRDb21tb25OYW1lTGlzdCAmJiB0aGlzLl9wcm9wcy5zc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgLy8gbm8gQ2xvc3VyZSBDb21waWxlciBleHRlcm5zIGZvciBjZXJ0aWZpY2F0ZXNcbiAgICAgIExPR19ERUJVRygnc2VydmVyIGNlcnQ6JywgY2VydCk7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gY2VydFsnc3ViamVjdCddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgbGV0IHZhbGlkID0gZmFsc2U7XG4gICAgICBpZiAoc3ViamVjdCkge1xuICAgICAgICBjb25zdCBjbiA9IHN1YmplY3RbJ0NOJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgIHZhbGlkID0gdGhpcy5fcHJvcHMuc3NsVHJ1c3RlZENvbW1vbk5hbWVMaXN0LnNvbWUobmFtZSA9PlxuICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gY24udG9Mb3dlckNhc2UoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU2VydmVyIGNlcnRpZmljYXRlIG5vdCB0cnVzdGVkIC0gbm8gY29tbW9uIG5hbWUgbWF0Y2gnKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gJ1NlcnZlciBjZXJ0aWZpY2F0ZSBub3QgdHJ1c3RlZCAtIG5vIGNvbW1vbiBuYW1lIG1hdGNoJztcbiAgICAgICAgZXJyb3IuaG9zdCA9IGhvc3Q7XG4gICAgICAgIGVycm9yLmNlcnQgPSBjZXJ0O1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBUTFMgb3B0aW9ucyBvYmplY3QgdXNlZCBpbiB3c3M6Ly8gYW5kIHRjcHM6Ly8gY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LlxuICAgKiBUaGUgc2FtZSBvcHRpb25zIGFyZSBuZWVkZWQgYnkgdGhlIHdzIGFuZCB0bHMgc29ja2V0IGNvbnN0cnVjdG9ycy5cbiAgICogQHJldHVybnMge09iamVjdH0gV2ViU29ja2V0L1RMU1NvY2tldCBvcHRpb25zIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlVExTT3B0aW9ucygpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCB1c2VDbGllbnRDZXJ0ID0gKFxuICAgICAgcHJvcHMuYXV0aGVudGljYXRpb25TY2hlbWUgPT09IFNvbGNsaWVudFNlc3Npb25MaWIuQXV0aGVudGljYXRpb25TY2hlbWUuQ0xJRU5UX0NFUlRJRklDQVRFXG4gICAgKTtcblxuICAgIC8vIGF2YWlsYWJsZSB0bHMgb3B0aW9uczpcbiAgICAvLyAgcGZ4LCBrZXksIHBhc3NwaHJhc2UsIGNlcnQsIGNhLCBjaXBoZXJzLCByZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgLy8gIHNlY3VyZVByb3RvY29sLCBzZWN1cmVPcHRpb25zLCBjaGVja1NlcnZlcklkZW50aXR5XG5cbiAgICAvLyBkZWZhdWx0IHRvIGFsbG93IGFsbCB2ZXJzaW9uIG9mIFNTTCBkdXJpbmcgbmVnb3RpYXRpb24gYnV0IGV4Y2x1ZGUgU1NMdjIgYW5kIFNTTHYzXG4gICAgb3B0aW9uc1snc2VjdXJlUHJvdG9jb2wnXSA9ICdTU0x2MjNfbWV0aG9kJztcbiAgICBjb25zdCBjb25zdE1hcCA9IFNvbGNsaWVudFNlc3Npb25MaWIuU2Vzc2lvblByb3BlcnRpZXMuU3NsUHJvdG9jb2xFeGNsdWRlQ29uc3RhbnRNYXA7XG4gICAgb3B0aW9uc1snc2VjdXJlT3B0aW9ucyddID0gY29uc3RNYXBbJ3NzbHYyJ10gfCBjb25zdE1hcFsnc3NsdjMnXTtcbiAgICAocHJvcHMuc3NsRXhjbHVkZWRQcm90b2NvbHMgfHwgW10pLmZvckVhY2goKHByb3RvY29sKSA9PiB7XG4gICAgICBvcHRpb25zWydzZWN1cmVPcHRpb25zJ10gfD0gY29uc3RNYXBbcHJvdG9jb2wudG9Mb3dlckNhc2UoKV07XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcHMuc3NsQ2lwaGVyU3VpdGVzKSB7XG4gICAgICBjb25zdCBjaXBoZXJzID0gcHJvcHMuc3NsQ2lwaGVyU3VpdGVzLnNwbGl0KCcsJyk7XG4gICAgICBjb25zdCB0cmltbWVkID0gY2lwaGVycy5tYXAoY2lwaGVyID0+IGNpcGhlci50cmltKCkpO1xuICAgICAgb3B0aW9uc1snY2lwaGVycyddID0gdHJpbW1lZC5qb2luKCc6Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNbJ2NpcGhlcnMnXSA9IHByb3BzLnNzbENpcGhlclN1aXRlcztcbiAgICB9XG5cbiAgICBvcHRpb25zWydyZWplY3RVbmF1dGhvcml6ZWQnXSA9IHByb3BzLnNzbFZhbGlkYXRlQ2VydGlmaWNhdGU7XG5cbiAgICAvLyBvbmx5IHNldCBjaGVja1NlcnZlcklkZW50aXR5IGNhbGxiYWNrIGlmIHJlamVjdFVuYXV0aG9yaXplZFxuICAgIGlmIChvcHRpb25zWydyZWplY3RVbmF1dGhvcml6ZWQnXSAmJiBBcnJheS5pc0FycmF5KHByb3BzLnNzbFRydXN0ZWRDb21tb25OYW1lTGlzdCkpIHtcbiAgICAgIG9wdGlvbnNbJ2NoZWNrU2VydmVySWRlbnRpdHknXSA9IHRoaXMuY2hlY2tDZXJ0aWZpY2F0ZUNOcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIG9ubHkgc2V0IHRydXN0IHN0b3JlcyBhbmQgYW5kIGNoZWNrU2VydmVySWRlbnRpdHkgY2FsbGJhY2tcbiAgICAvLyBpZiByZWplY3RVbmF1dGhvcml6ZWQgaXMgdHJ1ZSBvciBhdXRoQ2xpZW50Q2VydFxuICAgIGlmICgob3B0aW9uc1sncmVqZWN0VW5hdXRob3JpemVkJ10gfHwgdXNlQ2xpZW50Q2VydCkgJiZcbiAgICAgIHByb3BzLnNzbFRydXN0U3RvcmVzICYmIHByb3BzLnNzbFRydXN0U3RvcmVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHNDb250ZW50cyA9IFtdO1xuICAgICAgcHJvcHMuc3NsVHJ1c3RTdG9yZXMuZm9yRWFjaCgodHNGaWxlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHNDb250ZW50cy5wdXNoKGZzLnJlYWRGaWxlU3luYyh0c0ZpbGUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIExPR19XQVJOKGBGYWlsZWQgdG8gbG9hZCB0cnVzdCBzdG9yZSAke3RzRmlsZX1gLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgIExPR19UUkFDRSgnRXJyb3IgZGV0YWlsczonLCBlLnN0YWNrIHx8IGUpO1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgdHJ1c3Qgc3RvcmUgJHt0c0ZpbGV9YCxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5GQUlMRURfTE9BRElOR19UUlVTVFNUT1JFLFxuICAgICAgICAgICAgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3B0aW9uc1snY2EnXSA9IHRzQ29udGVudHM7XG4gICAgfVxuXG5cbiAgICBpZiAodXNlQ2xpZW50Q2VydCkge1xuICAgICAgaWYgKHByb3BzLnNzbFBmeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wdGlvbnNbJ3BmeCddID0gZnMucmVhZEZpbGVTeW5jKHByb3BzLnNzbFBmeCk7XG4gICAgICAgICAgb3B0aW9uc1sncGFzc3BocmFzZSddID0gcHJvcHMuc3NsUGZ4UGFzc3dvcmQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBMT0dfV0FSTihgRmFpbGVkIHRvIGxvYWQgcGZ4IGZpbGUgJHtwcm9wcy5zc2xQZnh9YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICBMT0dfVFJBQ0UoJ0Vycm9yIGRldGFpbHM6JywgZS5zdGFjayB8fCBlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYEZhaWxlZCB0byBsb2FkIHBmeCAke3Byb3BzLnNzbFBmeH1gLFxuICAgICAgICAgICAgRXJyb3JTdWJjb2RlLkZBSUxFRF9MT0FESU5HX0NFUlRJRklDQVRFX0FORF9LRVksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuc3NsUHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wdGlvbnNbJ2tleSddID0gZnMucmVhZEZpbGVTeW5jKHByb3BzLnNzbFByaXZhdGVLZXkpO1xuICAgICAgICAgIG9wdGlvbnNbJ3Bhc3NwaHJhc2UnXSA9IHByb3BzLnNzbFByaXZhdGVLZXlQYXNzd29yZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIExPR19XQVJOKGBGYWlsZWQgdG8gbG9hZCBwcml2YXRlIGtleSAke3Byb3BzLnNzbFByaXZhdGVLZXl9YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICBMT0dfVFJBQ0UoJ0Vycm9yIGRldGFpbHM6JywgZS5zdGFjayB8fCBlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYEZhaWxlZCB0byBsb2FkIHByaXZhdGUga2V5ICR7cHJvcHMuc3NsUHJpdmF0ZUtleX1gLFxuICAgICAgICAgICAgRXJyb3JTdWJjb2RlLkZBSUxFRF9MT0FESU5HX0NFUlRJRklDQVRFX0FORF9LRVksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuc3NsQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRpb25zWydjZXJ0J10gPSBmcy5yZWFkRmlsZVN5bmMocHJvcHMuc3NsQ2VydGlmaWNhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgTE9HX1dBUk4oYEZhaWxlZCB0byBsb2FkIGNlcnRpZmljYXRlIGZpbGUgJHtwcm9wcy5zc2xDZXJ0aWZpY2F0ZX1gLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgIExPR19UUkFDRSgnRXJyb3IgZGV0YWlsczonLCBlLnN0YWNrIHx8IGUpO1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgRmFpbGVkIHRvIGxvYWQgY2VydGlmaWNhdGUgJHtwcm9wcy5zc2xDZXJ0aWZpY2F0ZX1gLFxuICAgICAgICAgICAgRXJyb3JTdWJjb2RlLkZBSUxFRF9MT0FESU5HX0NFUlRJRklDQVRFX0FORF9LRVksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICAgIC8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uICovXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5Ob2RlVExTT3B0c01peGluID0gTm9kZVRMU09wdHNNaXhpbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvbm9kZS10bHMtb3B0cy1taXhpbi5qcyIsIi8qIGVzbGludC1kaXNhYmxlIGdsb2JhbC1yZXF1aXJlICovXG5jb25zdCB7IEJhc2VTTUZDbGllbnQgfSA9IHJlcXVpcmUoJy4vYmFzZS1zbWYtY2xpZW50Jyk7XG5cbmNvbnN0IFNNRkNsaWVudCA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDkuJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnLi9zdHJpbmctc21mLWNsaWVudCcpLlN0cmluZ1NNRkNsaWVudDtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVudiBzaGFyZWQtYnJvd3Nlci1ub2RlICovXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlci1zbWYtY2xpZW50JykuQnVmZmVyU01GQ2xpZW50O1xufSkoKTtcblxuU01GQ2xpZW50LlNNRl9DTElFTlRDVFJMX0xPR0lOX0ZBS0VfQ09SUkVMQVRJT05UQUcgPSBCYXNlU01GQ2xpZW50LlNNRl9NQVhfQ09SUkVMQVRJT047XG5cbm1vZHVsZS5leHBvcnRzLlNNRkNsaWVudCA9IFNNRkNsaWVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvc21mLWNsaWVudC5qcyIsIi8qKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBUcmFuc3BvcnRDbGllbnRTdGF0cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICB0aGlzLm1zZ1dyaXR0ZW4gPSAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydENsaWVudFN0YXRzID0gVHJhbnNwb3J0Q2xpZW50U3RhdHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1jbGllbnQtc3RhdHMuanMiLCJjb25zdCBEZWJ1Z0xpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZWJ1ZycpO1xuY29uc3Qge1xuICBDb252ZXJ0LFxuICBCYXNlNjQsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHtcbiAgTE9HX0RFQlVHLFxuICBMT0dfSU5GTyxcbiAgTE9HX1dBUk4sXG4gIExPR19FUlJPUixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7XG4gIHNlbmRYaHJCaW5hcnksXG4gIHNlbmRYaHJUZXh0LFxufSA9IHJlcXVpcmUoJy4vc2VuZC14aHInKTtcbmNvbnN0IHsgU3RyaW5nQnVmZmVyLCBUaW1pbmdCdWNrZXQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IFRyYW5zcG9ydFJldHVybkNvZGUgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zcG9ydC1yZXR1cm4tY29kZXMnKTtcbmNvbnN0IHsgWEhSRmFjdG9yeSB9ID0gcmVxdWlyZSgnLi94aHItZmFjdG9yeScpO1xuXG5jb25zdCB7IGFycmF5QnVmZmVyVG9TdHJpbmcgfSA9IENvbnZlcnQ7XG5cbmNvbnN0IFNPTF9DT05ORUNUSU9OX0RFQlVHID0gZmFsc2U7XG5cbi8qKlxuICogQSBVUkkgc3RhcnRpbmcgd2l0aCBhIFwiL1wiIGlzIGEgXCJwYXRoLWFic29sdXRlXCIgVVJJLCBhbmQgdGhvc2UgYXJlbid0XG4gKiBhbGxvd2VkIHRvIGhhdmUgYSBxdWVyeSBjb21wb25lbnQgKHN0YXJ0aW5nIHdpdGggXCI/XCIpLlxuICpcbiAqIElmIGFuIG9yaWdpbiBpc24ndCBkZWZpbmVkIGluIHRoZSB1cmwsIHRhY2sgb24gdGhlIG9uZSBmcm9tIHRoZSBwYWdlLlxuICpcbiAqIEBwYXJhbSB7VVJMfSB1cmwgVGhlIFVSTCB0byBjb25uZWN0IHRvXG4gKiBAcmV0dXJucyB7VVJMfSBBZGp1c3RlZCBVUkwgaWYgaW5jb21pbmcgVVJMIHdhcyByZWxhdGl2ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZE9yaWdpbih1cmwpIHtcbiAgaWYgKCF1cmwubWF0Y2goL14oaHR0cHx3cykocz8pOi9pKSAmJiB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgKCh1cmwuY2hhckF0KDApICE9PSAnLycpID8gJy8nIDogJycpICsgdXJsO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGdldFRzKCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59XG5cbmNsYXNzIFN0YXRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5XYWl0ZWRUb2tlbiA9IG5ldyBUaW1pbmdCdWNrZXQoJ1dhaXRlZFRva2VuJywgMTAwKTtcbiAgICB0aGlzLkhhZFRva2VuID0gbmV3IFRpbWluZ0J1Y2tldCgnSGFkVG9rZW4nLCAxMDApO1xuICAgIHRoaXMuUmV0dXJuZWRUb2tlbiA9IG5ldyBUaW1pbmdCdWNrZXQoJ1JldHVybmVkVG9rZW4nLCAxMDApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBzID0gJyc7XG4gICAgW3RoaXMuV2FpdGVkVG9rZW4sIHRoaXMuSGFkVG9rZW4sIHRoaXMuUmV0dXJuZWRUb2tlbl0uZm9yRWFjaCgoYikgPT4ge1xuICAgICAgaWYgKGIgJiYgYi5idWNrZXRDb3VudCgpID4gMCkge1xuICAgICAgICBzICs9IGAke2IubmFtZX0gPj4gJHtifVxcbmA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIGFsbCBzdGF0ZSBmb3IgYSBzaW5nbGUgSFRUUCBjb25uZWN0aW9uIChYSFIpLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEhUVFBDb25uZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodXJsLCBiYXNlNjRFbmMsIHN0cmVhbVByb2dyZXNzRXZlbnRzLCByeERhdGFDYixcbiAgICAgICAgICAgICAgY29ubmVjdGlvbkVycm9yQ2IsIGNvbnRlbnRUeXBlLCBjb25uZWN0aW9uQ2xvc2UpIHtcbiAgICB0aGlzLk9wdGlvbnMgPSB7XG4gICAgICB1cmw6IHByZXBlbmRPcmlnaW4odXJsKSxcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgYmFzZTY0RW5jLFxuICAgICAgc3RyZWFtUHJvZ3Jlc3NFdmVudHMsXG4gICAgICBjb25uZWN0aW9uQ2xvc2UsXG4gICAgfTtcblxuICAgIHRoaXMuX3N0cmVhbVByb2dyZXNzQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3hociA9IG51bGw7XG4gICAgdGhpcy5fcnhEYXRhQ2IgPSByeERhdGFDYjtcbiAgICB0aGlzLl9jb25uRXJyb3JDYiA9IGNvbm5lY3Rpb25FcnJvckNiO1xuICAgIHRoaXMuX3JlcUFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX1JFUUNPVU5URVIgPSAwO1xuICAgIHRoaXMuX1JFUUJBU0UgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKTtcblxuICAgIHRoaXMuX3hociA9IFhIUkZhY3RvcnkuY3JlYXRlKCk7XG4gICAgLy8gb2xkZXIgYnJvd3NlciBpZTlcbiAgICB0aGlzLl9oYW5kbGVBYm9ydGVkUmVxID0gIUhUVFBDb25uZWN0aW9uLmJyb3dzZXJTdXBwb3J0c1hockJpbmFyeSgpO1xuXG4gICAgdGhpcy5zdGF0cyA9IG5ldyBTdGF0cygpO1xuICB9XG5cbiAgcmVjU3RhdChzKSB7XG4gICAgaWYgKCFTT0xfQ09OTkVDVElPTl9ERUJVRykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgaWYgKHMgPT09ICdHb3RUb2tlbicpIHtcbiAgICAgIHN0YXRzLkxhc3RHb3RUb2tlbiA9IGdldFRzKCk7XG4gICAgICBpZiAoc3RhdHMuTGFzdFNlbmRNc2cpIHtcbiAgICAgICAgY29uc3Qgd2FpdGVkVG9rID0gc3RhdHMuTGFzdEdvdFRva2VuIC0gc3RhdHMuTGFzdFNlbmRNc2c7XG4gICAgICAgIHN0YXRzLldhaXRlZFRva2VuLmxvZyh3YWl0ZWRUb2spO1xuICAgICAgICBpZiAod2FpdGVkVG9rID4gMTAwKSB7XG4gICAgICAgICAgTE9HX1dBUk4oYEFibm9ybWFsbHkgbG9uZyB3YWl0VG9rZW4sIGxhc3QgcmVxdWVzdDogJHt0aGlzLl9SRVFCQVNFfV8ke3RoaXMuX1JFUUNPVU5URVJ9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHMgPT09ICdTZW5kTXNnJykge1xuICAgICAgc3RhdHMuTGFzdFNlbmRNc2cgPSBnZXRUcygpO1xuICAgICAgY29uc3QgaGFkVG9rZW4gPSBzdGF0cy5MYXN0U2VuZE1zZyAtIHN0YXRzLkxhc3RHb3RUb2tlbjtcbiAgICAgIHN0YXRzLkhhZFRva2VuLmxvZyhoYWRUb2tlbik7XG4gICAgfVxuICAgIGlmIChzID09PSAnR290RGF0YScpIHtcbiAgICAgIHN0YXRzLkxhc3RHb3REYXRhID0gZ2V0VHMoKTtcbiAgICB9XG4gICAgaWYgKHMgPT09ICdSZXR1cm5Ub2tlbicpIHtcbiAgICAgIHN0YXRzLkxhc3RSZXR1cm5Ub2tlbiA9IGdldFRzKCk7XG4gICAgICBpZiAoc3RhdHMuTGFzdEdvdERhdGEpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuZWRUb2tlbiA9IHN0YXRzLkxhc3RSZXR1cm5Ub2tlbiAtIHN0YXRzLkxhc3RHb3REYXRhO1xuICAgICAgICBzdGF0cy5SZXR1cm5lZFRva2VuLmxvZyhyZXR1cm5lZFRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBTZW5kIGRhdGEgb3ZlciB0aGUgY29ubmVjdGlvbiAtIHRoaXMgcmVxdWlyZXMgYSBzZW5kIHRva2VuXG4gICAqL1xuICBzZW5kKGRhdGEsIGF0dGVtcHQgPSAwLCBtYXhSZXRyeSA9IDEpIHtcbiAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuICAgICAgdGhpcy5feGhyID0gWEhSRmFjdG9yeS5jcmVhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5feGhyLm9wZW4oJ1BPU1QnLCB0aGlzLk9wdGlvbnMudXJsLCB0cnVlKTtcblxuICAgIHRoaXMuX3N0cmVhbVByb2dyZXNzQnl0ZXMgPSAwO1xuICAgIC8vIFdlIHBhc3MgdGhlIHdyaXRlIGRhdGEgdG8gdGhlIENCIHNvIHdlIGNhbiByZXRyeSB3aGVuIGl0IG15c3RlcmlvdXNseSBmYWlscy5cbiAgICB0aGlzLl94aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4gdGhpcy54aHJTdGF0ZUNoYW5nZShkYXRhLCBhdHRlbXB0LCBtYXhSZXRyeSk7XG5cbiAgICB0aGlzLl9yZXFBY3RpdmUgPSB0cnVlO1xuXG4gICAgaWYgKFNPTF9DT05ORUNUSU9OX0RFQlVHKSB7XG4gICAgICB0aGlzLl9SRVFDT1VOVEVSKys7XG4gICAgICB0aGlzLl94aHIuc2V0UmVxdWVzdEhlYWRlcignc29sLXJlcXVlc3QtdHJhY2snLCBgJHt0aGlzLl9SRVFCQVNFfV8ke3RoaXMuX1JFUUNPVU5URVJ9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLk9wdGlvbnMuYmFzZTY0RW5jKSB7XG4gICAgICBzZW5kWGhyVGV4dCh0aGlzLl94aHIsIGRhdGEsIHRoaXMuT3B0aW9ucy5jb250ZW50VHlwZSwgdGhpcy5PcHRpb25zLmNvbm5lY3Rpb25DbG9zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRYaHJCaW5hcnkodGhpcy5feGhyLCBkYXRhLCB0aGlzLk9wdGlvbnMuY29udGVudFR5cGUsIHRoaXMuT3B0aW9ucy5jb25uZWN0aW9uQ2xvc2UpO1xuICAgIH1cbiAgICB0aGlzLnJlY1N0YXQoJ1NlbmRNc2cnKTtcbiAgfVxuXG5cbiAgLy8gWG1sSFRUUFJlcXVlc3QgQ2FsbGJhY2tcbiAgeGhyU3RhdGVDaGFuZ2Uoc2VudGRhdGEsIGF0dGVtcHQsIG1heFJldHJ5KSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMuX3hoci5yZWFkeVN0YXRlO1xuICAgIGNvbnN0IFJTX0xPQURJTkcgPSB0aGlzLl94aHIuTE9BRElORztcbiAgICBjb25zdCBSU19ET05FID0gdGhpcy5feGhyLkRPTkU7XG5cbiAgICBpZiAoISgodGhpcy5PcHRpb25zLnN0cmVhbVByb2dyZXNzRXZlbnRzICYmIHJlYWR5U3RhdGUgPT09IFJTX0xPQURJTkcpXG4gICAgICAgICAgfHwgcmVhZHlTdGF0ZSA9PT0gUlNfRE9ORSkpIHtcbiAgICAgIC8vIHdlIHByb2NlZWQgd2l0aCBub3RpZmljYXRpb25zIGlmIHdlJ3JlIExPQURJTkcgYW5kIHdlIHJlcXVlc3RlZCBzdHJlYW1pbmcgZXZlbnRzLFxuICAgICAgLy8gb3Igd2UncmUgRE9ORS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcUFjdGl2ZSkge1xuICAgICAgICAgIC8vIHJlcXVlc3QgYWJvcnRlZCwgRE8gTk9UIHByb3BhZ2F0ZSBldmVudFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzdGF0dXMgPSBudWxsO1xuICAgIGlmICh0aGlzLl9oYW5kbGVBYm9ydGVkUmVxKSB7XG4gICAgICAvLyBUbyBhdm9pZCB0aGUgZm9sbG93aW5nIElFOSBlcnJvciB3aGVuIHJlcXVlc3QgaXMgYWJvcnRlZCBieSBzZXJ2ZXIgb3IgY2xpZW50IGFuZFxuICAgICAgLy8gYXBwbGljYXRpb24gdHJpZXMgdG8gYWNjZXNzIGFueSBwcm9wZXJ0eSBpbiB0aGUgWEhSIG90aGVyIHRoYW4gcmVhZHlTdGF0ZSB3aG9zZSB2YWx1ZSBpc1xuICAgICAgLy8gNCAoWE1MSFRUUFJlcXVlc3QuRE9ORSk6XG4gICAgICAvLyAtIFRoZSBkYXRhIG5lY2Vzc2FyeSB0byBjb21wbGV0ZSB0aGlzIG9wZXJhdGlvbiBpcyBub3QgeWV0IGF2YWlsYWJsZVxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy93ZWJzeW5jL3lzQkV2dHZNeWIwIGZvciBkZXRhaWxzXG4gICAgICAvLyBfcmVxdWVzdEFjdGl2ZSBpcyB1c2VkIHRvIGhhbmRsZSBjbGllbnQgaW5pdGlhdGVkIGFib3J0LCBidXQgaXQgZG9lcyBub3QgaGFuZGxlXG4gICAgICAvLyB0aGUgY2FzZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGFib3J0ZWQgb24gdGhlIHNlcnZlciBzaWRlIG9yIHByb3h5IHNlcnZlclxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdHVzID0gdGhpcy5feGhyLnN0YXR1cztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTE9HX0lORk8oYEVycm9yIHRyeWluZyB0byBhY2Nlc3Mgc3RhdHVzIGluIFhIUiBkdWUgdG8gcmVxdWVzdCBhYm9ydGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0dXMgPSB0aGlzLl94aHIuc3RhdHVzO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgLy8gU3VjY2VzcyBzdGF0dXMgY29kZVxuICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3hoci5yZXNwb25zZVR5cGUgJiYgdGhpcy5feGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBkYXRhID0gYXJyYXlCdWZmZXJUb1N0cmluZyh0aGlzLl94aHIucmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuX3hoci5yZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgICBkYXRhID0gZGF0YS5zdWJzdHJpbmcodGhpcy5fc3RyZWFtUHJvZ3Jlc3NCeXRlcywgZGF0YS5sZW5ndGgpO1xuICAgICAgdGhpcy5fc3RyZWFtUHJvZ3Jlc3NCeXRlcyArPSBkYXRhLmxlbmd0aDtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwICYmIHJlYWR5U3RhdGUgPT09IFJTX0xPQURJTkcpIHtcbiAgICAgICAgLy8gd2UgYXJlIHN0cmVhbWluZyBMT0FESU5HIGV2ZW50cyBidXQgaGF2ZSBubyBkYXRhXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuT3B0aW9ucy5iYXNlNjRFbmMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhID0gQmFzZTY0LmRlY29kZShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIEZhaWxlZCB0aGUgZGVjb2RlIC0gY2FsbCB0aGUgZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICBMT0dfRVJST1IoYERhdGEgZGVjb2RlIGVycm9yIG9uOiAke2RhdGF9YCk7XG4gICAgICAgICAgTE9HX0VSUk9SKGBEYXRhIGRlY29kZSBlcnJvciBpczogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5fcnhEYXRhQ2IoVHJhbnNwb3J0UmV0dXJuQ29kZS5EQVRBX0RFQ09ERV9FUlJPUiwgZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0YWtlIGxvd2VyLTggYml0c1xuICAgICAgICBjb25zdCBkZWNvZGVkRGF0YSA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVjb2RlZERhdGEucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEuY2hhckNvZGVBdChpKSAmIDB4RkYpKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZGVjb2RlZERhdGEuam9pbignJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gUlNfRE9ORSkge1xuICAgICAgICAvLyBNVVNUIGRvIHRoaXMgQkVGT1JFIHRoZSBjYWxsYmFjayBpbnZvY2F0aW9uLCBiZWNhdXNlIHRoZSBjYWxsYmFjayBjYW4gdHJpZ2dlciBhIG5ldyBzZW5kLlxuICAgICAgICB0aGlzLl9yZXFBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3J4RGF0YUNiKFRyYW5zcG9ydFJldHVybkNvZGUuT0ssIGRhdGEpO1xuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IFJTX0RPTkUgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3J4RGF0YUNiKFRyYW5zcG9ydFJldHVybkNvZGUuT0ssICcnKTsgLy8gaW5kaWNhdGUgZW5kIG9mIHN0cmVhbVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZSBzdGF0dXMgY29kZS5cbiAgICBjb25zdCBzdGF0dXNUZXh0ID0gdGhpcy5feGhyLnN0YXR1c1RleHQ7XG4gICAgbGV0IHJlc3BvbnNlVGV4dCA9ICcnO1xuICAgIGlmICh0aGlzLl94aHIucmVzcG9uc2VUeXBlICYmIHRoaXMuX3hoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgIHJlc3BvbnNlVGV4dCA9IGFycmF5QnVmZmVyVG9TdHJpbmcodGhpcy5feGhyLnJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2VUZXh0ID0gdGhpcy5feGhyLnJlc3BvbnNlVGV4dCB8fCAnJztcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZVRleHRMZW4gPSByZXNwb25zZVRleHQubGVuZ3RoO1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSB0aGlzLk9wdGlvbnMudXJsO1xuICAgIGNvbnN0IHNlbnRkYXRhTGVuID0gc2VudGRhdGEgPyBzZW50ZGF0YS5sZW5ndGggOiAwO1xuICAgIGNvbnN0IHsgZm9ybWF0RHVtcEJ5dGVzIH0gPSBEZWJ1Z0xpYi5EZWJ1ZztcbiAgICBjb25zdCByZXNwb25zZVRleHREdW1wID0gZm9ybWF0RHVtcEJ5dGVzKFxuICAgICAgcmVzcG9uc2VUZXh0LnN1YnN0cigwLCBNYXRoLm1pbihyZXNwb25zZVRleHRMZW4sIDY0KSksIHRydWUsIDApO1xuICAgIGNvbnN0IHNlbnRUZXh0RHVtcCA9IGZvcm1hdER1bXBCeXRlcyhcbiAgICAgIChzZW50ZGF0YSB8fCAnJykuc3Vic3RyKDAsIE1hdGgubWluKHNlbnRkYXRhTGVuLCAyNTYpKSwgdHJ1ZSwgMCk7XG4gICAgaWYgKEJVSUxEX0VOVi5NT0RFX0RFQlVHKSB7XG4gICAgICBjb25zdCBzdG10ID0gbmV3IFN0cmluZ0J1ZmZlcihcbiAgICAgICAgYEh0dHAgcmVxdWVzdCBmYWlsZWQuICB1cmw9JHtyZXF1ZXN0VXJsfSwgc3RhdHVzPSR7c3RhdHVzfSwgc3RhdHVzVGV4dD0ke3N0YXR1c1RleHR9LCBgLFxuICAgICAgICBgcmVzcG9uc2VUZXh0IGxlbmd0aD0ke3Jlc3BvbnNlVGV4dExlbn0sIGAsXG4gICAgICAgICdyZXNwb25zZVRleHQgKGZpcnN0IDY0IGJ5dGVzIG9yIGZld2VyKT1cXG4nLFxuICAgICAgICBgJHtyZXNwb25zZVRleHREdW1wfSwgYCxcbiAgICAgICAgYFhIUiBlcnJvckNvZGU9JHt0aGlzLl94aHIuX2Vycm9yID8gdGhpcy5feGhyLl9lcnJvci5jb2RlIDogJyd9LCBgLFxuICAgICAgICBgYXR0ZW1wdD0ke2F0dGVtcHR9LCByZXFBY3RpdmU9JHt0aGlzLl9yZXFBY3RpdmV9LCByZWFkeVN0YXRlPSR7cmVhZHlTdGF0ZX0sIGAsXG4gICAgICAgIGBzZW50IGRhdGEgbGVuZ3RoPSR7c2VudGRhdGFMZW59LCBgLFxuICAgICAgICAnc2VudCBkYXRhIChmaXJzdCAyNTYgYnl0ZXMgb3IgZmV3ZXIpPVxcbicsXG4gICAgICAgIGAke3NlbnRUZXh0RHVtcH1gKS50b1N0cmluZygpO1xuICAgICAgTE9HX0RFQlVHKHN0bXQpO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHRNYXhSZXRyeSA9IG1heFJldHJ5O1xuICAgIGlmICh0aGlzLl9yZXFBY3RpdmVcbiAgICAgICAgICAmJiBzdGF0dXMgIT09IDQwMFxuICAgICAgICAgICYmIHJlc3BvbnNlVGV4dC5sZW5ndGggPT09IDBcbiAgICAgICAgICAmJiAoYXR0ZW1wdCA9PT0gMCB8fCBhdHRlbXB0IDwgbmV4dE1heFJldHJ5KSkge1xuICAgICAgTE9HX0RFQlVHKGBYSFIgZmFpbGVkIHdoaWxlIHJlcXVlc3QgYWN0aXZlLCB3aWxsIHJldHJ5IHNlbmQsIHJldHJ5PSR7YXR0ZW1wdCArIDF9YCk7XG4gICAgICAgIC8vIFJFVFJZIChjb3VsZCBiZSBhIHRyYW5zaWVudCBicm93c2VyIGNvbm5lY3Rpb24gcHJvYmxlbSlcbiAgICAgIHRoaXMuc2VuZChzZW50ZGF0YSwgYXR0ZW1wdCArIDEsIG5leHRNYXhSZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29ubkVycm9yQ2IoXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIG5ldyBTdHJpbmdCdWZmZXIoXG4gICAgICAgICAgICBgSFRUUCByZXF1ZXN0IGZhaWxlZChzdGF0dXM9JHtzdGF0dXN9IHN0YXR1c1RleHQ9JHtzdGF0dXNUZXh0fSwgYCxcbiAgICAgICAgICAgIGByZXNwb25zZVRleHQgbGVuZ3RoPSR7cmVzcG9uc2VUZXh0TGVufSwgcmVzcG9uc2VUZXh0WzAuLjY0XT1cXG5gLFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0RHVtcCxcbiAgICAgICAgICAgIGBYSFIgZXJyb3JDb2RlPSR7dGhpcy5feGhyLl9lcnJvciA/IHRoaXMuX3hoci5fZXJyb3IuY29kZSA6ICcnfSlgKS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICBpc1VzaW5nQmFzZTY0KCkge1xuICAgIHJldHVybiB0aGlzLk9wdGlvbnMuYmFzZTY0RW5jO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGFib3J0IHRoZSBjdXJyZW50IHhociByZXF1ZXN0IGlmIGl0IGlzIGFjdGl2ZVxuICBhYm9ydCgpIHtcbiAgICAgIC8vIG1hcmsgcmVxdWVzdCBhcyBpbmFjdGl2ZSwgc28gd2Ugd29uJ3QgcHJvY2VzcyBzdGF0ZWNoYW5nZSBldmVudHNcbiAgICB0aGlzLl9yZXFBY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5feGhyICYmIHRoaXMuX3hoci5hYm9ydCkge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHdlIGNhbiB0cnkgYmluYXJ5IFhIUiBvbiB0aGlzIGJyb3dzZXIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgWEhSIGJpbmFyeSBzaG91bGQgd29yazsgYGZhbHNlYCBvdGhlcndpc2VcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGJyb3dzZXJTdXBwb3J0c1hockJpbmFyeSgpIHtcbiAgICByZXR1cm4gc2VuZFhockJpbmFyeSAhPT0gc2VuZFhoclRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0cyBzdHJlYW1pbmcgcmVzcG9uc2VzIChwcm9ncmVzc2l2ZSByZWFkaW5nIG9mIFhIUikuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZmVhdHVyZSB3YXMgZGV0ZWN0ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBicm93c2VyU3VwcG9ydHNTdHJlYW1pbmdSZXNwb25zZSgpIHtcbiAgICBjb25zdCB4aHIgPSBYSFJGYWN0b3J5LmNyZWF0ZSgpO1xuICAgIC8vIEEgY29uZm9ybWluZyBYSFIyIGltcGxlbWVudGF0aW9uIG11c3QgaW5jbHVkZSBwcm9ncmVzcyBldmVudHMuXG4gICAgLy8gQ2FuIHdlIGFzc3VtZSB0aGF0IHRoZSBldmVudCBwcm9wZXJ0eSB3aWxsIGJlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQ/XG4gICAgLy8gQSBjb25mb3JtaW5nIFhIUjIgaW1wbGVtZW50YXRpb24gbXVzdCBhbHNvIGluY2x1ZGUgd2l0aENyZWRlbnRpYWxzLlxuICAgIGNvbnN0IGNoZWNrID0geGhyICYmIHhoci5vbnByb2dyZXNzID09PSBudWxsOyAvLyB4aHIud2l0aENyZWRlbnRpYWxzID09PSBmYWxzZTtcbiAgICBMT0dfREVCVUcoYGh0dHAgYnJvd3NlclN0cmVhbWluZ0NoZWNrIC0gaWYgWE1MSFRUUFJlcXVlc3Qgc3VwcG9ydGVkIGFuZCBYTUxIVFRQUmVxdWVzdCBzdXBwb3J0IG9ucHJvZ3Jlc3M6ICR7Y2hlY2t9YCk7XG4gICAgcmV0dXJuIGNoZWNrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkhUVFBDb25uZWN0aW9uID0gSFRUUENvbm5lY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL2h0dHAtY29ubmVjdGlvbi5qcyIsImNvbnN0IHsgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgVHJhbnNwb3J0RXJyb3IgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zcG9ydC1lcnJvcicpO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbmNvbnN0IFhIUkZhY3RvcnkgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIFhIUiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbG93RmFpbD1mYWxzZV0gSWYgYHRydWVgLCByZXR1cm4gbnVsbCBvbiBmYWlsdXJlOyBvdGhlcndpc2UgdGhyb3cuXG4gICAqIEB0aHJvd3Mge1RyYW5zcG9ydEVycm9yfVxuICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9IFRoZSBuZXcgWEhSIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlKGFsbG93RmFpbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgeGhyID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBYTUxIdHRwUmVxdWVzdCgpIDogbnVsbDtcbiAgICBpZiAoIWFsbG93RmFpbCAmJiAheGhyKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhbnNwb3J0RXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYW4gWE1MSFRUUFJlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLkNSRUFURV9YSFJfRkFJTEVEKTtcbiAgICB9XG4gICAgcmV0dXJuIHhocjtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlhIUkZhY3RvcnkgPSBYSFJGYWN0b3J5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvaHR0cC94aHItZmFjdG9yeS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgV2ViIFRyYW5zcG9ydCBldmVudHMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgV2ViVHJhbnNwb3J0RXZlbnQgPSB7XG4gIC8qKlxuICAgKiBUaGUgU2Vzc2lvbiBMYXllciBoYXMgaXNzdWVkIGEgY29ubmVjdCByZXF1ZXN0XG4gICAqL1xuICBDT05ORUNUOiAgICAgICAgICAnQ29ubmVjdCcsXG4gIC8qKlxuICAgKiBUaGUgU2Vzc2lvbiBMYXllciBoYXMgaXNzdWVkIGEgZGVzdHJveSByZXF1ZXN0XG4gICAqL1xuICBERVNUUk9ZOiAgICAgICAgICAnRGVzdHJveScsXG4gIC8qKlxuICAgKiBBIGRvd25ncmFkZSByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gYW4gRlNNLlxuICAgKi9cbiAgRE9XTkdSQURFOiAgICAgICAgJ0Rvd25ncmFkZScsXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyB0cmFuc3BvcnQgaGFzIGJlZW4gZGVzdHJveWVkLiBTZWVuIGluXG4gICAqIHJlc3BvbnNlIHRvIGNhbGxpbmcgZGVzdHJveSgpIGFuZCBpbiBzb21lIGNhc2VzIHdoZW5cbiAgICogdGhlIHRyYW5zcG9ydCBpcyBkZXN0cm95ZWQgYnkgdGhlIHBlZXIuXG4gICAqL1xuICBERVNUUk9ZRURfTk9USUNFOiAnRGVzdHJveWVkTm90aWNlJyxcbiAgLyoqXG4gICAqIFRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCB0aW1lZCBvdXQgaW4gaXRzIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogVGhlIG1hbmFnaW5nIGNvbXBvbmVudCBzaG91bGQgYWJvcnQgdGhpcyBjb25uZWN0aW9uIGF0dGVtcHRcbiAgICogYW5kIGJlZ2luIGEgZG93bmdyYWRlIGlmIGF2YWlsYWJsZS5cbiAgICovXG4gIENPTk5FQ1RfVElNRU9VVDogICdDb25uZWN0VGltZW91dCcsXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyB0cmFuc3BvcnQgaXMgYWN0aXZlIGFuZCByZWFkeSBmb3IgdHJhZmZpYy5cbiAgICovXG4gIFVQX05PVElDRTogICAgICAgICdVcE5vdGljZScsXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNwb3J0IGVuY291bnRlcmVkIGFuIGVycm9yIHNlbmRpbmcgZGF0YS5cbiAgICovXG4gIFNFTkRfRVJST1I6ICAgICAgICdTZW5kRXJyb3InLFxufTtcblxubW9kdWxlLmV4cG9ydHMuV2ViVHJhbnNwb3J0RXZlbnQgPSBFbnVtLm5ldyhXZWJUcmFuc3BvcnRFdmVudCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi93ZWItdHJhbnNwb3J0LWV2ZW50cy5qcyIsImNvbnN0IHtcbiAgTE9HX0RFQlVHLFxuICBMT0dfVFJBQ0UsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBUcmFuc3BvcnRCYXNlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtYmFzZScpO1xuY29uc3QgeyBUcmFuc3BvcnRDbGllbnRTdGF0cyB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LWNsaWVudC1zdGF0cycpO1xuY29uc3QgeyBUcmFuc3BvcnRSZXR1cm5Db2RlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtcmV0dXJuLWNvZGVzJyk7XG5jb25zdCB7IFRyYW5zcG9ydFNlc3Npb25TdGF0ZSB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXNlc3Npb24tc3RhdGVzJyk7XG5cbmNvbnN0IE1BWF9CVUZGRVJFRF9BTU9VTlRfUVVFUllfSU5URVJWQUxfTVMgPSA0MDAwO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHdlYiByZWxhdGVkIHRyYW5zcG9ydHNcbiAqIEBleHRlbmRzIFRyYW5zcG9ydEJhc2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFdlYlRyYW5zcG9ydFNlc3Npb25CYXNlIGV4dGVuZHMgVHJhbnNwb3J0QmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtVUkx9IHVybCBUaGUgVVJMIHRvIGNvbm5lY3QgdG9cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnRDQiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBldmVudHNcbiAgICogQHBhcmFtIHtTTUZDbGllbnR9IGNsaWVudCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBkYXRhIHJlY2VpdmVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQWRkaXRpb25hbCBvYmplY3QgcHJvcGVydGllcyBmb3IgdGhpcyB0cmFuc3BvcnQgc2Vzc2lvblxuICAgKi9cbiAgY29uc3RydWN0b3IodXJsLCBldmVudENCLCBjbGllbnQsIHByb3BzKSB7XG4gICAgLy8gaW5zdGFuaXRhdGUgaW5zdGFuY2UgcHJvcGVydGllcyBkZWZpbmVkIGluIFRyYW5zcG9ydEJhc2VcbiAgICBzdXBlcih1cmwsIGV2ZW50Q0IsIGNsaWVudCwgcHJvcHMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9jb25uZWN0VGltZW91dCA9IHByb3BzLnRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fY29ubmVjdFRpbWVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUcmFuc3BvcnRDbGllbnRTdGF0c31cbiAgICAgKi9cbiAgICB0aGlzLl9jbGllbnRzdGF0cyA9IG5ldyBUcmFuc3BvcnRDbGllbnRTdGF0cygpO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhbW91bnQgb2Ygc2VuZCBkYXRhIHRoYW4gY2FuIGJlIHF1ZXVlZFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc2VuZEJ1ZmZlck1heFNpemUgPSBwcm9wcy5zZW5kQnVmZmVyTWF4U2l6ZTtcblxuICAgIC8qKlxuICAgICAqIE1heGltdW0gcGF5bG9hZCBjaHVuayBzaXplIGluIHdlYiB0cmFuc3BvcnRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX21heFBheWxvYWRCeXRlcyA9IHByb3BzLm1heFdlYlBheWxvYWQ7XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSB0byBob2xkIGRhdGEgdG8gYmUgc2VudCB0byB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIHdoZW4gd2UgZ2V0IGJhY2sgYVxuICAgICAqIGRhdGEgdG9rZW5cbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5fcXVldWVkRGF0YSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGJ5dGVzIG9mIHF1ZXVlZCBkYXRhXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9xdWV1ZWREYXRhU2l6ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZW1lbWJlciBpZiB3ZSBoYXZlIHRvIHNlbmQgYW4gZXZlbnQgd2hlbiB0aGVyZSBpcyByb29tIGluIHRoZSBxdWV1ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2NhblNlbmROZWVkZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUcmFuc3BvcnRTZXNzaW9uU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTjtcblxuICAgIC8qKlxuICAgICAqIEFueSBjb25uZWN0aW9uIGVycm9yIHRoYXQgbmVlZHMgdG8gYmUgcHJvcGFnYXRlZCB1cFxuICAgICAqIEB0eXBlIHs/RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5fY29ubkVycm9yID0gbnVsbDtcbiAgfVxuXG4gIC8vIG92ZXJyaWRlXG4gIGdldENsaWVudFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzdGF0cztcbiAgfVxuXG4gIGNyZWF0ZUNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0VGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lckV4cGlyeSgpO1xuICAgICAgfSwgdGhpcy5fY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbENvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uZWN0VGltZXIpO1xuICAgICAgdGhpcy5fY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKiBvdmVycmlkZSBtZSAqL1xuICBjb25uZWN0VGltZXJFeHBpcnkoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBhbGxvd0VucXVldWUoZGF0YWxlbikge1xuICAgICAgLy8gQnVnIDMyMDA2OiBpZiB0aGVyZSdzIG5vIHF1ZXVlZCBkYXRhLCB3ZSBhbHdheXMgYWNjZXB0IGF0IGxlYXN0IG9uZSBtZXNzYWdlLCBldmVuIGlmIGl0XG4gICAgICAvLyBleGNlZWRzIHRoZSBzZW5kQnVmZmVyTWF4U2l6ZS5cbiAgICAgIC8vIElmIHdlIHJlamVjdCBlbnF1ZXVlaW5nIHNvbWV0aGluZyB0b28gbGFyZ2UgYmVjYXVzZSB3ZSBhbHJlYWR5IGhhdmUgcXVldWVkIGRhdGEsXG4gICAgICAvLyB0aGF0IGd1YXJhbnRlZXMgd2hlbiB0aGUgZGF0YSBpcyBmbHVzaGVkIHdlIHdpbGwgZW1pdCB0aGUgYWxlcnRPbkRlcXVldWUgZXZlbnQuXG4gICAgcmV0dXJuICh0aGlzLl9xdWV1ZWREYXRhU2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgKChkYXRhbGVuICsgdGhpcy5fcXVldWVkRGF0YVNpemUpIDw9IHRoaXMuX3NlbmRCdWZmZXJNYXhTaXplKSk7XG4gIH1cblxuICBlbnF1ZXVlRmFpbE5vU3BhY2UoKSB7XG4gICAgdGhpcy5fY2FuU2VuZE5lZWRlZCA9IHRydWU7XG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuTk9fU1BBQ0U7XG4gIH1cblxuICAvKiBvdmVycmlkZSBtZSAqL1xuICBmbHVzaChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgZ2V0UXVldWVkRGF0YVRvU2VuZCgpIHtcbiAgICAvLyBUcmFjayBtZXNzYWdlcyBkZXF1ZXVlZC5cbiAgICBsZXQgZGF0YSA9ICcnO1xuXG4gICAgLy8gU3RhcnQgYnkgdHJ5aW5nIHRvIGZpbGwgYSBjb21wbGV0ZSBwYXlsb2FkLlxuICAgIGxldCBieXRlc0FsbG93ZWQgPSB0aGlzLl9tYXhQYXlsb2FkQnl0ZXM7XG4gICAgTE9HX1RSQUNFKGBnZXRRdWV1ZWREYXRhVG9TZW5kOiBieXRlc0FsbG93ZWQ9JHtieXRlc0FsbG93ZWR9LCBidWZmZXJlZEFtb3VudD0ke3RoaXMuZ2V0QnVmZmVyZWRBbW91bnQgPyB0aGlzLmdldEJ1ZmZlcmVkQW1vdW50KCkgOiAndW5kZWZpbmVkJ31gKTtcbiAgICBpZiAodGhpcy5nZXRCdWZmZXJlZEFtb3VudCkge1xuICAgICAgYnl0ZXNBbGxvd2VkID0gdGhpcy5fbWF4UGF5bG9hZEJ5dGVzIC0gdGhpcy5nZXRCdWZmZXJlZEFtb3VudCgpO1xuICAgICAgaWYgKGJ5dGVzQWxsb3dlZCA8PSAwKSB7XG4gICAgICAgIExPR19ERUJVRyhgJCQgYnl0ZXNBbGxvd2VkPSR7Ynl0ZXNBbGxvd2VkfSwgbWF4UGF5bG9hZEJ5dGVzPSR7dGhpcy5fbWF4UGF5bG9hZEJ5dGVzXG4gICAgICAgICAgICAgICAgICB9LCBidWZmZXJlZEFtb3VudD0ke3RoaXMuZ2V0QnVmZmVyZWRBbW91bnQoKX1gKTtcbiAgICAgICAgaWYgKEJVSUxEX0VOVi5UQVJHRVRfQlJPV1NFUiAmJlxuICAgICAgICAgICAgKHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbEluTXNlY3MgKlxuICAgICAgICAgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxEZWxheU11bHRpcGxpZXIgPD1cbiAgICAgICAgICAgICAgTUFYX0JVRkZFUkVEX0FNT1VOVF9RVUVSWV9JTlRFUlZBTF9NUykpIHtcbiAgICAgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxEZWxheU11bHRpcGxpZXIgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChCVUlMRF9FTlYuVEFSR0VUX0JST1dTRVIpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsRGVsYXlNdWx0aXBsaWVyID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcXVldWVkRGF0YVNpemUgPiBieXRlc0FsbG93ZWQpIHtcbiAgICAgIGxldCBwYXlsb2FkU2l6ZSA9IGJ5dGVzQWxsb3dlZDtcbiAgICAgIC8vIFNsb3cgcGF0aDogZGVxdWV1ZSBhbmQgYXBwZW5kIHVudGlsIHdlIGZpbGwgdGhlIHBheWxvYWQuXG4gICAgICB3aGlsZSAocGF5bG9hZFNpemUgJiYgdGhpcy5fcXVldWVkRGF0YVNpemUpIHtcbiAgICAgICAgLy8gSXMgdGhpcyBlbGVtZW50IGxhcmdlciB0aGFuIHRoZSBwYXlsb2FkP1xuICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5fcXVldWVkRGF0YVswXTtcbiAgICAgICAgY29uc3QgZWxlbUxlbmd0aCA9IGVsZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoZWxlbUxlbmd0aCA+IHBheWxvYWRTaXplKSB7XG4gICAgICAgICAgLy8gVGhpcyBlbGVtZW50IGlzIGxhcmdlciB0aGFuIHRoZSBwYXlsb2FkLlxuICAgICAgICAgIGRhdGEgKz0gZWxlbS5zdWJzdHIoMCwgcGF5bG9hZFNpemUpO1xuICAgICAgICAgIHRoaXMuX3F1ZXVlZERhdGFbMF0gPSBlbGVtLnN1YnN0cihwYXlsb2FkU2l6ZSk7XG5cbiAgICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgcGF5bG9hZCBzcGFjZSB3YXMgY29uc3VtZWQuXG4gICAgICAgICAgdGhpcy5fcXVldWVkRGF0YVNpemUgLT0gcGF5bG9hZFNpemU7XG4gICAgICAgICAgcGF5bG9hZFNpemUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgKz0gdGhpcy5fcXVldWVkRGF0YS5zaGlmdCgpO1xuICAgICAgICAgIHBheWxvYWRTaXplIC09IGVsZW1MZW5ndGg7XG4gICAgICAgICAgdGhpcy5fcXVldWVkRGF0YVNpemUgLT0gZWxlbUxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9jbGllbnRzdGF0cy5tc2dXcml0dGVuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvcnRjdXQ6IHVzZSB0aGUgd2hvbGUgYnVmZmVyLCBpbmNyZWFzZSB0aGUgbWVzc2FnZSBzZW50IGNvdW50IGJ5IHRoZSBsZW5ndGggb2YgdGhlIHNpemVcbiAgICAgIC8vIHF1ZXVlLCBhbmQgcmVzZXQgdGhlIGJ1ZmZlci5cbiAgICAgIGRhdGEgPSB0aGlzLl9xdWV1ZWREYXRhLmpvaW4oJycpO1xuICAgICAgdGhpcy5fY2xpZW50c3RhdHMubXNnV3JpdHRlbiArPSB0aGlzLl9xdWV1ZWREYXRhLmxlbmd0aDtcblxuICAgICAgdGhpcy5fcXVldWVkRGF0YSA9IFtdO1xuICAgICAgdGhpcy5fcXVldWVkRGF0YVNpemUgPSAwO1xuICAgIH1cblxuICAgIExPR19ERUJVRyhgU2VuZGluZyAke2RhdGEubGVuZ3RofSBieXRlcyBmcm9tIHF1ZXVlZCBkYXRhYCk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuV2ViVHJhbnNwb3J0U2Vzc2lvbkJhc2UgPSBXZWJUcmFuc3BvcnRTZXNzaW9uQmFzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtc2Vzc2lvbi1iYXNlLmpzIiwiY29uc3QgU29sY2xpZW50RmFjdG9yeUxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5jb25zdCB7XG4gIExPR19UUkFDRSxcbiAgTE9HX0RFQlVHLFxuICBMT0dfV0FSTixcbiAgTE9HX0VSUk9SIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IEFycmF5VXRpbHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IENvbnZlcnQsXG4gICAgICAgIEhleCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgbWl4aW4gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBUcmFuc3BvcnRFcnJvciB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LWVycm9yJyk7XG5jb25zdCB7IFRyYW5zcG9ydFJldHVybkNvZGUgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1yZXR1cm4tY29kZXMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50IH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudCcpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uU3RhdGUgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1zZXNzaW9uLXN0YXRlcycpO1xuY29uc3QgeyBXZWJTb2NrZXRDbG9zZUNvZGVzIH0gPSByZXF1aXJlKCcuL3dlYnNvY2tldC1jbG9zZS1jb2RlcycpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRTZXNzaW9uQmFzZSB9ID0gcmVxdWlyZSgnLi93ZWItdHJhbnNwb3J0LXNlc3Npb24tYmFzZScpO1xuXG5jb25zdCB7XG4gIHN0cmluZ1RvQXJyYXlCdWZmZXIsXG59ID0gQ29udmVydDtcbmNvbnN0IHtcbiAgZm9ybWF0SGV4U3RyaW5nLFxufSA9IEhleDtcbmNvbnN0IHtcbiAgaW5jbHVkZXMsXG59ID0gQXJyYXlVdGlscztcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vLyBjbG9zdXJlIG1hbmdsZXMgd2luZG93LldlYlNvY2tldFxuY29uc3QgZ2xvYmFsQ29udGV4dCA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyk7XG5sZXQgTXlXZWJTb2NrZXQgPSBnbG9iYWxDb250ZXh0LldlYlNvY2tldDtcbmlmIChCVUlMRF9FTlYuVEFSR0VUX05PREUpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tZ2xvYmFsLWFzc2lnbiAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBnbG9iYWwtcmVxdWlyZSAqL1xuICBNeVdlYlNvY2tldCA9IC8qKiBAdHlwZSB7V2ViU29ja2V0fSAqLyAocmVxdWlyZSgnd3MnKSk7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZ2xvYmFsLWFzc2lnbiAqL1xuICAvKiBlc2xpbnQtZW5hYmxlIGdsb2JhbC1yZXF1aXJlICovXG59XG4vKiBlc2xpbnQtZW52IHNoYXJlZC1icm93c2VyLW5vZGUgKi9cblxuZnVuY3Rpb24gYWRhcHRVUkwodXJsKSB7XG4gIGNvbnN0IHYgPSB1cmwubWF0Y2goLyh3c3xodHRwKShzPzpcXC9cXC8uKykvKTtcbiAgcmV0dXJuIGB3cyR7dlsyXX1gO1xufVxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgV2ViU29ja2V0VHJhbnNwb3J0U2Vzc2lvbiBleHRlbmRzIFdlYlRyYW5zcG9ydFNlc3Npb25CYXNlIHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byBjb25uZWN0IHRvXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50Q0IgVGhlIGNhbGxiYWNrIGZvciB0cmFuc3BvcnQgZXZlbnRzXG4gICAqIEBwYXJhbSB7U01GQ2xpZW50fSBjbGllbnQgVGhlIFNNRiBjbGllbnQgZm9yIGRhdGEgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNwb3J0IHNlc3Npb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKHVybCwgZXZlbnRDQiwgY2xpZW50LCBwcm9wcykge1xuICAgIHN1cGVyKHVybCwgZXZlbnRDQiwgY2xpZW50LCBwcm9wcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLl91cmwgPSBhZGFwdFVSTCh1cmwpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9XZWJTb2NrZXR9XG4gICAgICovXG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb25JZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgaWYgKEJVSUxEX0VOVi5UQVJHRVRfQlJPV1NFUikge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzID0gcHJvcHMuYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsSW5Nc2VjcztcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlUaW1lciA9IG51bGw7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbERlbGF5TXVsdGlwbGllciA9IDE7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uT3BlbigpIHtcbiAgICB0aGlzLmNhbmNlbENvbm5lY3RUaW1lb3V0KCk7XG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuU0VTU0lPTl9VUDtcbiAgICAgIC8vIFNlbmQgdGhlIGV2ZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBsZXR0aW5nIGl0IGtub3cgdGhhdCB0aGUgc2Vzc2lvbiBpcyB1cFxuICAgIHRoaXMuX2V2ZW50Q0IoXG4gICAgICAgICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChcbiAgICAgICAgICAgICAgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5VUF9OT1RJQ0UsXG4gICAgICAgICAgICAgICdDb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uSWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgd2Vic29ja2V0IGV2ZW50IGNhdXNpbmcgdGhlIGNsb3NlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNsb3NlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgTE9HX1RSQUNFKCdXZWJTb2NrZXQgdHJhbnNwb3J0IGlzIGJlaW5nIGRlc3Ryb3llZCwgaWdub3JlIGVycm9yJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1zZ0J1ZiA9IFtdO1xuICAgIGNvbnN0IGNvZGUgPSBXZWJTb2NrZXRDbG9zZUNvZGVzW2V2ZW50LmNvZGVdIHx8IFdlYlNvY2tldENsb3NlQ29kZXNbMF07XG4gICAgbXNnQnVmLnB1c2goYCR7ZXZlbnQuY29kZX0gJHtjb2RlLm5hbWV9ICgke2NvZGUuZGVzY3JpcHRpb259KWApO1xuICAgIGlmIChldmVudC53YXNDbGVhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtc2dCdWYucHVzaChgY2xlYW4gY2xvc3VyZTogJHtldmVudC53YXNDbGVhbn1gKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnJlYXNvbikge1xuICAgICAgbXNnQnVmLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IG1zZ0J1Zi5qb2luKCcsICcpO1xuICAgIExPR19ERUJVRyhgV2ViU29ja2V0IHRyYW5zcG9ydCBjb25uZWN0aW9uIGlzIGNsb3NlZCAke21zZ31gKTtcbiAgICBMT0dfVFJBQ0UoYEV2ZW50IHsgdHlwZTogJHtldmVudC50eXBlfSB3YXNDbGVhbjogJHtldmVudC53YXNDbGVhbn0gY29kZTogJHtldmVudC5jb2RlfSByZWFzb246ICR7ZXZlbnQucmVhc29ufSB9YCk7XG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuQ09OTkVDVElPTl9GQUlMRUQ7XG4gICAgdGhpcy5kZXN0cm95KGBDb25uZWN0aW9uIGNsb3NlZDogJHttc2d9YCwgRXJyb3JTdWJjb2RlLkNPTU1VTklDQVRJT05fRVJST1IpO1xuICB9XG5cbiAgb25EcmFpbigpIHtcbiAgICBMT0dfVFJBQ0UoJ0RyYWluZWQgc29ja2V0Jyk7XG4gICAgdGhpcy5tYXliZUVtaXRDYW5TZW5kKCk7XG4gICAgdGhpcy5tYXliZUVtaXRGbHVzaCgpO1xuICB9XG5cbiAgb25CdWZmZXJlZEFtb3VudFBvbGwoKSB7XG4gICAgaWYgKHRoaXMuZ2V0QnVmZmVyZWRBbW91bnQoKSA9PT0gMCkge1xuICAgICAgdGhpcy5vbkRyYWluKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVkdWxlUXVlcnkpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVRdWVyeSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zcG9ydFNlc3Npb25FdmVudH0gZXZlbnQgVGhlIGV2ZW50IGNhdXNpbmcgdGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkVycm9yKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgTE9HX0RFQlVHKCdXZWJTb2NrZXQgdHJhbnNwb3J0IGlzIGJlaW5nIGRlc3Ryb3llZCwgaWdub3JlIGVycm9yJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IChldmVudC5tZXNzYWdlKSA/IChgOiAke2V2ZW50Lm1lc3NhZ2V9YCkgOiAnJztcbiAgICBMT0dfREVCVUcoYFdlYlNvY2tldCB0cmFuc3BvcnQgY29ubmVjdGlvbiBlcnJvciAke21zZ31gKTtcbiAgICB0aGlzLl9ldmVudENCKFxuICAgICAgICAgIG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoXG4gICAgICAgICAgICAgIFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuU0VORF9FUlJPUixcbiAgICAgICAgICAgICAgYENvbm5lY3Rpb24gZXJyb3Ike21zZ31gLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUiwgbnVsbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNwb3J0U2Vzc2lvbkV2ZW50fSBldmVudCBUaGUgZGF0YSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2NsaWVudCkge1xuICAgICAgdGhpcy5fY2xpZW50LnJ4RGF0YUFycmF5QnVmZmVyKGV2ZW50LmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbm5lY3RUaW1lckV4cGlyeSgpIHtcbiAgICBMT0dfREVCVUcoJ1dlYlNvY2tldCB0cmFuc3BvcnQgY29ubmVjdCB0aW1lb3V0Jyk7XG4gICAgdGhpcy5zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICB0aGlzLl9ldmVudENCKG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoXG4gICAgICBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLkNPTk5FQ1RfVElNRU9VVCxcbiAgICAgICdDb25uZWN0aW9uIHRpbWVkIG91dCcsXG4gICAgICBudWxsLFxuICAgICAgRXJyb3JTdWJjb2RlLlRJTUVPVVRcbiAgICApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTikge1xuICAgICAgTE9HX0VSUk9SKGBJbnZhbGlkIHN0YXRlIGZvciBvcGVyYXRpb246ICR7VHJhbnNwb3J0U2Vzc2lvblN0YXRlLm5hbWVPZih0aGlzLl9zdGF0ZSl9YCk7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5JTlZBTElEX1NUQVRFX0ZPUl9PUEVSQVRJT047XG4gICAgfVxuICAgIGlmICghdGhpcy5fdXJsKSB7XG4gICAgICBMT0dfV0FSTignQ2Fubm90IGNvbm5lY3QgdG8gbnVsbCBVUkwnKTtcbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLkNPTk5FQ1RJT05fRVJST1I7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMub25FcnJvcignU29ja2V0IGFscmVhZHkgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCdFc3RhYmxpc2hpbmcgV2ViU29ja2V0IHRyYW5zcG9ydCBzZXNzaW9uJyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY3JlYXRlQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0NSRUFURTtcbiAgICAgIGlmIChCVUlMRF9FTlYuVEFSR0VUX05PREUgJiYgIXRoaXMuX3NvY2tldE9wdGlvbnMpIHtcbiAgICAgICAgTE9HX0RFQlVHKCdDcmVhdGluZyBOb2RlIHdlYnNvY2tldCBvcHRpb25zJyk7XG4gICAgICAgIHRoaXMuX3NvY2tldE9wdGlvbnMgPSB0aGlzLmNyZWF0ZVdlYlNvY2tldE9wdGlvbnMoKTtcbiAgICAgIH1cbiAgICAgIExPR19ERUJVRygnQ29uc3RydWN0aW5nIHNvY2tldCcpO1xuICAgICAgaWYgKEJVSUxEX0VOVi5UQVJHRVRfQlJPV1NFUikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1dlYlNvY2tldH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NvY2tldCA9IG5ldyBNeVdlYlNvY2tldCh0aGlzLl91cmwsICdzbWYuc29sYWNlc3lzdGVtcy5jb20nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NvY2tldCA9IG5ldyBNeVdlYlNvY2tldCh0aGlzLl91cmwsICdzbWYuc29sYWNlc3lzdGVtcy5jb20nLCB0aGlzLl9zb2NrZXRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uZHJhaW4gPSB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsb3N1cmUgaXMgZ2VuZXJhbGx5IGZhc3RlciB0aGFuIGJpbmRcbiAgICAgIExPR19UUkFDRSgnQXNzaWduaW5nIHByb3BlcnRpZXMgdG8gc29ja2V0Jyk7XG4gICAgICAvLyBDbG9zdXJlIHVzaW5nIEJyb3dzZXIgcHJvZmlsZSB0byBhdm9pZCBtYW5nbGluZyB0aGlzXG4gICAgICB0aGlzLl9zb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB0aGlzLl9zb2NrZXQub25vcGVuID0gdGhpcy5vbk9wZW4uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbmVycm9yID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICBMT0dfVFJBQ0UoJ1ByZXBhcmVkIHNvY2tldCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBMT0dfREVCVUcoYEVycm9yIGNvbm5lY3Rpbmc6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIExPR19UUkFDRSgnRXJyb3IgZGV0YWlscycsIGVycm9yLnN0YWNrIHx8IGVycm9yKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkNPTk5FQ1RJT05fRkFJTEVEO1xuICAgICAgdGhpcy5jYW5jZWxDb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgdGhpcy5fY29ubkVycm9yID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHJhbnNwb3J0RXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgV2ViU29ja2V0OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN1YmNvZGUgfHwgRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuQ09OTkVDVElPTl9FUlJPUjtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ1dlYlNvY2tldCBpcyBjb25uZWN0aW5nJyk7XG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSBiaW5hcnkgc3RyaW5nIGRhdGEgdG8gc2VuZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2U9ZmFsc2VdIElmIHRydWUsIHNlbmQgZXZlbiBpZiBidWZmZXIgaXMgZnVsbC5cbiAgICovXG4gIHNlbmQoZGF0YSwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLlNFU1NJT05fVVApIHtcbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLklOVkFMSURfU1RBVEVfRk9SX09QRVJBVElPTjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyQWxsb3cgPSAodGhpcy5fc2VuZEJ1ZmZlck1heFNpemUgLSB0aGlzLmdldEJ1ZmZlcmVkQW1vdW50KCkpID49IDA7XG4gICAgLy8gTE9HX0RFQlVHKCdXZWJzb2NrZXQgc2VuZDonLCBkYXRhTGVuLCBmb3JjZSwgYnVmZmVyQWxsb3cpO1xuICAgIGlmICghKGZvcmNlIHx8IGJ1ZmZlckFsbG93KSkge1xuICAgICAgdGhpcy5fY2FuU2VuZE5lZWRlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5zY2hlZHVsZVF1ZXJ5KSB0aGlzLnNjaGVkdWxlUXVlcnkoKTtcbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk5PX1NQQUNFO1xuICAgIH1cblxuICAgIC8vIExPR19UUkFDRShgd2Vic29ja2V0LnNlbmQ6IGxlbj0ke2RhdGEubGVuZ3RofWApO1xuICAgIC8vIFNsaWNlIG1lc3NhZ2VzIHBlciBtYXhQYXlsb2FkQnl0ZXNcbiAgICBjb25zdCBtYXhQYXlsb2FkQnl0ZXMgPSB0aGlzLl9tYXhQYXlsb2FkQnl0ZXM7XG4gICAgY29uc3QgYWIgPSBzdHJpbmdUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgIGlmIChkYXRhTGVuID4gbWF4UGF5bG9hZEJ5dGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMZW47IGkgKz0gbWF4UGF5bG9hZEJ5dGVzKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5zZW5kKGFiLnNsaWNlKGksIGkgKyBtYXhQYXlsb2FkQnl0ZXMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LnNlbmQoYWIpO1xuICAgIH1cbiAgICAvLyBMT0dfVFJBQ0UoYHdlYnNvY2tldC5zZW5kOiBhZnRlciBzZW5kIGdldEJ1ZmZlcmVkQW1vdW50PSR7dGhpcy5nZXRCdWZmZXJlZEFtb3VudCgpfWApO1xuICAgIHRoaXMuX2NsaWVudHN0YXRzLmJ5dGVzV3JpdHRlbiArPSBkYXRhTGVuO1xuICAgICsrdGhpcy5fY2xpZW50c3RhdHMubXNnV3JpdHRlbjtcbiAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGFscmVhZHkgYnVmZmVyZWQgYnl0ZXMgaW4gdGhpcyB0cmFuc3BvcnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCdWZmZXJlZEFtb3VudCgpIHtcbiAgICAvLyBBY2Nlc3MgYXMgc3RyaW5nIHByb3BlcnR5IGJlY2F1c2UgdGhpcyBpcyBhIGRlZmluZVByb3BlcnR5IG9uIG5vZGUgd2Vic29ja2V0LFxuICAgIC8vIG1lYW5pbmcgaXQgaXMgbm90IG1hbmdsZWQgYnkgQ2xvc3VyZSBDb21waWxlclxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQgPyB0aGlzLl9zb2NrZXRbJ2J1ZmZlcmVkQW1vdW50J10gOiAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZmx1c2goY2FsbGJhY2spIHtcbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5tYXliZUVtaXRGbHVzaCgpO1xuICB9XG5cbiAgbWF5YmVFbWl0Q2FuU2VuZCgpIHtcbiAgICBpZiAodGhpcy5fY2FuU2VuZE5lZWRlZCAmJiB0aGlzLmdldEJ1ZmZlcmVkQW1vdW50KCkgPCB0aGlzLl9zZW5kQnVmZmVyTWF4U2l6ZSkge1xuICAgICAgTE9HX1RSQUNFKCdUcmFuc3BvcnQgZW1pdHRpbmcgQ0FOX0FDQ0VQVF9EQVRBJyk7XG4gICAgICB0aGlzLl9jYW5TZW5kTmVlZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9ldmVudENCKFxuICAgICAgICBuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuQ0FOX0FDQ0VQVF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnLCBudWxsLCAwLCB0aGlzLl9zZXNzaW9uSWQpKTtcbiAgICB9XG4gIH1cblxuICBtYXliZUVtaXRGbHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX2ZsdXNoQ2FsbGJhY2spIHJldHVybjtcbiAgICBpZiAoQlVJTERfRU5WLlRBUkdFVF9CUk9XU0VSICYmIHRoaXMuZ2V0QnVmZmVyZWRBbW91bnQoKSA+IDApIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgcXVlcnkgc2NoZWR1bGVkLCBidXQgZG9uJ3QgaW50ZXJydXB0IGEgcXVlcnkgaW4gcHJvZ3Jlc3NcbiAgICAgIGlmICghdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeVRpbWVyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVRdWVyeSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vZGUgaXMgYXV0b21hdGljYWxseSBmbHVzaGVkIGJ5IHNvY2tldC5lbmQoKSwgd2hpY2ggaXMgY2FsbGVkIGluIG5vbi1lcnJvciBjYXNlc1xuICAgIExPR19ERUJVRygnVHJhbnNwb3J0IGVtaXR0aW5nIEZMVVNIJyk7XG4gICAgY29uc3QgY2IgPSB0aGlzLl9mbHVzaENhbGxiYWNrO1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBudWxsO1xuICAgIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkZXN0cm95KG1lc3NhZ2UsIHN1YmNvZGUpIHtcbiAgICAvLyBXZSBjYW4gZGVzdHJveSAoYW5kIGdldCBhIG5vdGljZSkgZXZlbiBpZiB0aGUgc29ja2V0IGlzIGZyZXNobHkgY3JlYXRlZC5cbiAgICAvLyBCdXQgdGhpcyB3aWxsIG9ubHkgd29yayBvbmNlLlxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkRPV04pIHtcbiAgICAgIExPR19ERUJVRyhgRGVzdHJveSBXZWJTb2NrZXQgdHJhbnNwb3J0OiAke21lc3NhZ2V9YCk7XG5cbiAgICAgIC8vIFNldCBzdGF0ZSBmb3IgY29ubmVjdGlvbiB0ZWFyZG93bi5cbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0RFU1RST1k7XG5cbiAgICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9zb2NrZXQub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3JTdHViKCkgeyB9OyAvLyBQcmV2ZW50IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY29ubmVjdFRpbWVyKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoQlVJTERfRU5WLlRBUkdFVF9CUk9XU0VSKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsUXVlcnkoKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsRGVsYXlNdWx0aXBsaWVyID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FuU2VuZE5lZWRlZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5ET1dOO1xuXG4gICAgICB0aGlzLl9jbGllbnQgPSBudWxsOyAvLyBEb24ndCBhY2NlcHQgZGF0YS5cbiAgICB9XG4gICAgLy8gYWx3YXlzIHNlbmQgYSBERVNUUk9ZRURfTk9USUNFIGluIHJlc3BvbnNlIHRvIGEgZGVzdHJveSgpIGV2ZW5cbiAgICAvLyBpZiB3ZSB0aGluayB0aGUgdHJhbnNwb3J0IGlzIGFscmVhZHkgZGVzdHJveWVkXG4gICAgaWYgKHRoaXMuX2V2ZW50Q0IpIHtcbiAgICAgIC8vIEZpcmUgdGhpcyAqYWxtb3N0KiBpbnN0YW50bHksIGJ1dCBmb2xsb3cgdGhlIEhUVFBcbiAgICAgIC8vIHRyYW5zcG9ydCBwYXR0ZXJuIGJ5IGd1YXJhbnRlZWluZyBhbiBhc3luYyBjYWxsYmFjay5cbiAgICAgIHRoaXMuX2V2ZW50Q0IobmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLkRFU1RST1lFRF9OT1RJQ0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSB8fCAnU2Vzc2lvbiBpcyBkZXN0cm95ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY29kZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25JZCkpO1xuICAgICAgLy8gUmVsZWFzZSByZWZlcmVuY2VzIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICAgIHRoaXMuX2V2ZW50Q0IgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIGRlc2NyaXB0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgKi9cbiAgZ2V0SW5mb1N0cigpIHtcbiAgICBjb25zdCBzdHIgPSBgV2ViU29ja2V0VHJhbnNwb3J0U2Vzc2lvbjsgc2lkPSR7Zm9ybWF0SGV4U3RyaW5nKHRoaXMuX3Nlc3Npb25JZCl9YDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgc3RhdGljIGJyb3dzZXJTdXBwb3J0c0JpbmFyeVdlYlNvY2tldHMoKSB7XG4gICAgTE9HX0RFQlVHKCd3ZWJzb2NrZXQgYnJvd3NlclN1cHBvcnRCaW5hcnlDaGVjayAtICcgK1xuICAgICAgICAgICAgICAnaWYgV2ViU29ja2V0LCBBcnJheUJ1ZmZlciBhbmQgVWludDhBcnJheSBhcmUgc3VwcG9ydGVkJyk7XG5cbiAgICBjb25zdCBleGlzdHMgPSBbJ2Z1bmN0aW9uJywgJ29iamVjdCddO1xuICAgIGlmICghaW5jbHVkZXMoZXhpc3RzLCB0eXBlb2YgTXlXZWJTb2NrZXQpIHx8XG4gICAgICAgICFpbmNsdWRlcyhleGlzdHMsIHR5cGVvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIWluY2x1ZGVzKGV4aXN0cywgdHlwZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBMT0dfREVCVUcoJ3dlYnNvY2tldCBicm93c2VyU3VwcG9ydEJpbmFyeUNoZWNrOiBmYWxzZSAtIHNvbWUgcmVxdWlyZWQgY2xhc3NlcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCd3ZWJzb2NrZXQgYnJvd3NlclN1cHBvcnRCaW5hcnlDaGVjayAtIGlmIFdlYlNvY2tldCBzdXBwb3J0cyBiaW5hcnlUeXBlJyk7XG4gICAgaWYgKCdiaW5hcnlUeXBlJyBpbiBNeVdlYlNvY2tldC5wcm90b3R5cGUpIHtcbiAgICAgIExPR19ERUJVRygnd2Vic29ja2V0IGJyb3dzZXJTdXBwb3J0QmluYXJ5Q2hlY2s6IHRydWUgLSBXZWJTb2NrZXQgc3VwcG9ydHMgYmluYXJ5VHlwZScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCd3ZWJzb2NrZXQgYnJvd3NlclN1cHBvcnRCaW5hcnlDaGVjazogZmFsc2UgLSBXZWJTb2NrZXQgZG9lcyBub3Qgc3VwcG9ydCBiaW5hcnlUeXBlJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuaWYgKEJVSUxEX0VOVi5UQVJHRVRfQlJPV1NFUikge1xuICBtaXhpbihXZWJTb2NrZXRUcmFuc3BvcnRTZXNzaW9uLCBjbGFzcyBXZWJTb2NrZXRUcmFuc3BvcnRTZXNzaW9uQnJvd3NlciB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzY2hlZHVsZVF1ZXJ5KCkge1xuICAgICAgY29uc3QgYnVmZmVyZWRBbW91bnQgPSB0aGlzLmdldEJ1ZmZlcmVkQW1vdW50KCk7XG4gICAgICBpZiAoYnVmZmVyZWRBbW91bnQgPiAwICYmIHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbEluTXNlY3MgPiAwKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsUXVlcnkoKTtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbERlbGF5TXVsdGlwbGllciA+IDEpIHtcbiAgICAgICAgICBMT0dfREVCVUcoYCQkIHNjaGVkdWxlIGJ1ZmZlcmVkQW1vdW50IHF1ZXJ5IHRpbWVyIGluICR7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbEluTXNlY3MgKlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxEZWxheU11bHRpcGxpZXJ9IG1zYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuX2J1ZmZlcmVkQW1vdW50UXVlcnlJbnRlcnZhbEluTXNlY3MgKlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeUludGVydmFsRGVsYXlNdWx0aXBsaWVyO1xuICAgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbmNlbFF1ZXJ5KCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMub25CdWZmZXJlZEFtb3VudFBvbGwoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBMT0dfRVJST1IoYEVycm9yIG9jY3VycmVkIGluIG9uQnVmZmVyZWRBbW91bnRQb2xsOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIExPR19UUkFDRSgnRXJyb3IgZGV0YWlsczonLCBlLnN0YWNrIHx8IGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FuY2VsUXVlcnkoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRBbW91bnRRdWVyeVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5VGltZXIpO1xuICAgICAgICB0aGlzLl9idWZmZXJlZEFtb3VudFF1ZXJ5VGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICAvLyBOb2RlIFRMUyBzb2NrZXQgb3B0aW9ucyBmb3JtdWxhdGlvbiBzaGFyZWQgd2l0aCBUQ1AgdHJhbnNwb3J0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICBjb25zdCB7IE5vZGVUTFNPcHRzTWl4aW4gfSA9IHJlcXVpcmUoJy4uL25vZGUtdGxzLW9wdHMtbWl4aW4nKTtcbiAgbWl4aW4oV2ViVHJhbnNwb3J0U2Vzc2lvbkJhc2UsIE5vZGVUTFNPcHRzTWl4aW4pO1xuICAvLyBOb2RlLXNwZWNpZmljIG1ldGhvZHMgb2YgdGhpcyBjbGFzcyBnbyBoZXJlXG4gIG1peGluKFdlYlRyYW5zcG9ydFNlc3Npb25CYXNlLCBjbGFzcyBXZWJUcmFuc3BvcnRTZXNzaW9uQmFzZU5vZGUge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc29sYWNlLldlYlRyYW5zcG9ydFNlc3Npb24jY3JlYXRlV2ViU29ja2V0T3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgV2ViU29ja2V0IG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGVXZWJTb2NrZXRPcHRpb25zKCkge1xuICAgICAgaWYgKHRoaXMuX3NzbCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5jcmVhdGVUTFNPcHRpb25zKCk7XG4gICAgICAgIC8vIHVzZSBjdXN0b20gYWdlbnQgZm9yIGNsaWVudCBjZXJ0aWZpY2F0ZSBzdXBwb3J0LCBzc2wgcmVzdW1lIHNlc3Npb24gc3VwcG9ydFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgIG9wdGlvbnNbJ2FnZW50J10gPSBTb2xjbGllbnRGYWN0b3J5TGliLlNvbGNsaWVudEZhY3Rvcnkud3NTc2xBZ2VudDtcbiAgICAgICAgTE9HX0RFQlVHKCdXZWJTb2NrZXQgb3B0aW9ucycsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5XZWJTb2NrZXRUcmFuc3BvcnRTZXNzaW9uID0gV2ViU29ja2V0VHJhbnNwb3J0U2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYnNvY2tldC10cmFuc3BvcnQtc2Vzc2lvbi5qcyIsIi8qKlxuICogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGVmZmljaWVudGx5IGNvbmNhdGVuYXRlIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdHJpbmdCdWZmZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBJbml0aWFsIGJ1ZmZlciBjb250ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmFwcGVuZCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBzdHJpbmdzIHRvIHRoZSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIE9iamVjdHMgdG8gYWRkIHRvIHRoZSBidWZmZXIuIFRoZXNlIGFyZSBpbW1lZGlhdGVseVxuICAgKiAgICAgICAgICAgICAgICAgICAgY29lcmNlZCB0byBzdHJpbmdzLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nQnVmZmVyfSB0aGlzXG4gICAqL1xuICBhcHBlbmQoLi4uYXJncykge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKChhcmcpID0+IHtcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK10gPSBTdHJpbmcoYXJnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGJ1ZmZlci5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnVmZmVyIGFzIGEgc3RyaW5nLiBBZGRpdGlvbmFsIGNvbmNhdGVuYXRpb25zIGFuZCByZW5kZXJpbmdzXG4gICAqIGNhbiBiZSBwZXJmb3JtZWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBidWZmZXIncyBjb250ZW50cyBjb25jYXRlbmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuam9pbignJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuU3RyaW5nQnVmZmVyID0gU3RyaW5nQnVmZmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdXRpbC9saWIvc3RyaW5nLWJ1ZmZlci5qcyIsImNvbnN0IHsgQmFzZUNoZWNrcyB9ID0gcmVxdWlyZSgnLi9iYXNlLWNoZWNrcycpO1xuXG4vKipcbiAqXG4gKiBHZW5lcmF0ZXMgYSB0aGVuIGNsb3N1cmUuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBkb09wIFdoZXRoZXIgdGhlIHJldHVybmVkIHRoZW4gZnVuY3Rpb24gc2hvdWxkIGNhbGwgaXRzIGFyZ3VtZW50LlxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHsgdGhlbihmbiwgZWxzZUZuPXVuZGVmaW5lZCkgfS4gSWYgZG9PcCB3YXMgdHJ1ZSwgdGhlbihmbikgd2lsbFxuICogICAgICAgICAgICAgICAgICAgICAgY2FsbCBmbi4gSWYgbm90LCBlbHNlRm4gd2lsbCBiZSBjYWxsZWQgaWYgc3VwcGxpZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0aGVuR2VuKGRvT3ApIHtcbiAgcmV0dXJuIHtcbiAgICB0aGVuOiBkb09wID8gZiA9PiBmKCkgOiAoXywgZWxzZUZuKSA9PiBlbHNlRm4oKSxcbiAgfTtcbn1cblxuLyoqXG4gKlxuICogbm9uZSwgYW55dGhpbmcsIGJvb2xlYW4sIC4uLiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIHdoZW4oY29uZGl0aW9uKSBAcmV0dXJucyB0aGVuKGZuLCBlbHNlRm4pID0+IGlmIGNvbmRpdGlvbiBmbigpIGVsc2UgZWxzZUZuICYmIGVsc2VGbigpXG4gKiB1bmxlc3MoY29uZGl0aW9uLCBlbHNlKSBAcmV0dXJucyB0aGVuKGZuLCBlbHNlRm4pID0+IGlmICFjb25kaXRpb24gZm4oKSBlbHNlIGVsc2VGbiAmJiBlbHNlRm5cbiAqIHdoZW5Ob25lLCB3aGVuQW55dGhpbmcsIHdoZW5Cb29sZWFuLCAuLi4gQHJldHVybnMge2Z1bmN0aW9ufSB0aGVuKGZuLCBlbHNlRm4pXG4gKiB1bmxlc3NOb25lLCB1bmxlc3NBbnl0aGluZywgdW5sZXNzQm9vbGVhbiAuLi4gQHJldHVybnMge2Z1bmN0aW9ufSB1bmxlc3MoZm4sIGVsc2VGbilcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IENoZWNrID0gKCgpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgQmFzZUNoZWNrcyk7XG4gIHJlc3VsdC53aGVuID0gY29uZGl0aW9uID0+IHRoZW5HZW4oY29uZGl0aW9uKTtcbiAgcmVzdWx0LnVubGVzcyA9IGNvbmRpdGlvbiA9PiB0aGVuR2VuKCFjb25kaXRpb24pO1xuICByZXR1cm4gcmVzdWx0O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMuQ2hlY2sgPSBDaGVjaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXZhbGlkYXRlL2xpYi9jaGVjay5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNsb25lXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY2xvbmVcIlxuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxvbmdcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsb25nXCJcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIDxoMT4gT3ZlcnZpZXcgPC9oMT5cbiAqXG4gKiBUaGlzIGlzIHRoZSBTb2xhY2UgQ29ycG9yYXRpb24gTWVzc2FnaW5nIEFQSSBmb3IgSmF2YVNjcmlwdC4gQ29uY2VwdHMgZGVmaW5lZCBpbiB0aGlzIEFQSSBhcmVcbiAqIHNpbWlsYXIgdG8gdGhvc2UgZGVmaW5lZCBpbiBvdGhlciBTb2xhY2UgTWVzc2FnaW5nIEFQSXMgZm9yIEphdmEsIEMsIGFuZCAuTkVULlxuICpcbiAqIDxoMT4gQ29uY2VwdHMgPC9oMT5cbiAqXG4gKiBTb21lIGdlbmVyYWwgY29uY2VwdHM6XG4gKlxuICogPGxpPiBBbGwgZnVuY3Rpb24gY2FsbHMgYXJlIG5vbi1ibG9ja2luZzsgY29uZmlybWF0aW9uLCBpZiByZXF1ZXN0ZWQsIGlzIHJldHVybmVkIHRvIHRoZSBjYWxsaW5nXG4gKiBjbGllbnQgYXBwbGljYXRpb24gaW4gdGhlIGZvcm0gb2YgY2FsbGJhY2tzLiA8L2xpPlxuICpcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBzb3J0LXJlcXVpcmVzL3NvcnQtcmVxdWlyZXMgKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUG9seWZpbGxzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbmNsdWRlIGNvbXBhdGliaWxpdHkgZW50cnkgcG9pbnRzIGhlcmUuIFRoZXNlIGFyZSBleHBlY3RlZCB0byBtb2RpZnkgdGhlXG4vLyBnbG9iYWwgZW52aXJvbm1lbnQuXG5pZiAoQlVJTERfRU5WLlRBUkdFVF9CUk9XU0VSIHx8XG4gICAgZ2xvYmFsICYmIGdsb2JhbC5wcm9jZXNzICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb24gPCAndjYuMCcpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZ2xvYmFsLXJlcXVpcmUgKi9cbiAgLy8gU2VsZWN0IGVzNiBzaGltcyByZXF1aXJlZCBieSB0aGUgQVBJIGZvciBvbGRlciBicm93c2VycyBhbmQgTm9kZVxuICByZXF1aXJlKCdjb3JlLWpzL2VzNi9hcnJheScpO1xuICByZXF1aXJlKCdjb3JlLWpzL2VzNi9kYXRlJyk7XG4gIHJlcXVpcmUoJ2NvcmUtanMvZXM2L2Z1bmN0aW9uJyk7XG4gIHJlcXVpcmUoJ2NvcmUtanMvZXM2L21hcCcpO1xuICByZXF1aXJlKCdjb3JlLWpzL2VzNi9tYXRoJyk7XG4gIHJlcXVpcmUoJ2NvcmUtanMvZXM2L251bWJlcicpO1xuICByZXF1aXJlKCdjb3JlLWpzL2VzNi9vYmplY3QnKTtcbiAgcmVxdWlyZSgnY29yZS1qcy9lczYvcGFyc2UtZmxvYXQnKTtcbiAgcmVxdWlyZSgnY29yZS1qcy9lczYvcGFyc2UtaW50Jyk7XG4gIHJlcXVpcmUoJ2NvcmUtanMvZXM2L3JlZ2V4cCcpO1xuICByZXF1aXJlKCdjb3JlLWpzL2VzNi9zZXQnKTtcbiAgcmVxdWlyZSgnY29yZS1qcy9lczYvc3RyaW5nJyk7XG4gIHJlcXVpcmUoJ2NvcmUtanMvZXM2L3N5bWJvbCcpO1xuICByZXF1aXJlKCdjb3JlLWpzL2VzNi90eXBlZCcpO1xuXG4gIHJlcXVpcmUoJy4vbGliL25vZGUtZm9yd2FyZCcpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGdsb2JhbC1yZXF1aXJlICovXG59XG5yZXF1aXJlKCdjb3JlLWpzL2ZuL2FycmF5L2luY2x1ZGVzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL2ZuL3NldC9mcm9tJyk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU29sY2xpZW50IEZhY3RvcnkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMb2FkIG1lIGJlZm9yZSB0aGUgcmVzdCBvZiB0aGUgQVBJIGFzIGEgcGx1Zy1pbiBwb2ludCBmb3IgbW9kdWxlc1xuY29uc3QgRmFjdG9yeUxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qge1xuICBTb2xjbGllbnRGYWN0b3J5LFxuICBTb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMsXG4gIFNvbGNsaWVudEZhY3RvcnlQcm9wZXJ0aWVzLFxufSA9IEZhY3RvcnlMaWI7XG5cbmNvbnN0IHtcbiAgTG9uZyxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuY29uc3Qge1xuICBEZXN0aW5hdGlvbixcbiAgRGVzdGluYXRpb25UeXBlLFxuICBUb3BpYyxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHtcbiAgRXJyb3JTdWJjb2RlLFxuICBOb3RJbXBsZW1lbnRlZEVycm9yLFxuICBPcGVyYXRpb25FcnJvcixcbiAgUmVxdWVzdEVycm9yLFxuICBSZXF1ZXN0RXZlbnRDb2RlLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3Qge1xuICBtYWtlSXRlcmF0b3IsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7XG4gIENvbnNvbGVMb2dJbXBsLFxuICBMb2dJbXBsLFxuICBMb2dMZXZlbCxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7XG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VDYWNoZVN0YXR1cyxcbiAgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUsXG4gIE1lc3NhZ2VEdW1wRmxhZyxcbiAgTWVzc2FnZVR5cGUsXG4gIE1lc3NhZ2VVc2VyQ29zVHlwZSxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZScpO1xuY29uc3Qge1xuICBNZXNzYWdlQ29uc3VtZXIsXG4gIE1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSxcbiAgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLFxuICBNZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyJyk7XG5jb25zdCB7XG4gIE1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUsXG4gIE1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlcicpO1xuY29uc3Qge1xuICBBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvcixcbiAgUXVldWVBY2Nlc3NUeXBlLFxuICBRdWV1ZURlc2NyaXB0b3IsXG4gIFF1ZXVlRGlzY2FyZEJlaGF2aW9yLFxuICBRdWV1ZVBlcm1pc3Npb25zLFxuICBRdWV1ZVByb3BlcnRpZXMsXG4gIFF1ZXVlVHlwZSxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtcXVldWUnKTtcbmNvbnN0IHtcbiAgU0RURmllbGQsXG4gIFNEVEZpZWxkVHlwZSxcbiAgU0RUTWFwQ29udGFpbmVyLFxuICBTRFRTdHJlYW1Db250YWluZXIsXG4gIFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcixcbiAgU0RUVmFsdWVFcnJvclN1YmNvZGUsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LXNkdCcpO1xuY29uc3Qge1xuICBBdXRoZW50aWNhdGlvblNjaGVtZSxcbiAgQ2FwYWJpbGl0eVR5cGUsXG4gIE1lc3NhZ2VSeENCSW5mbyxcbiAgTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSxcbiAgU2Vzc2lvbixcbiAgU2Vzc2lvbkV2ZW50LFxuICBTZXNzaW9uRXZlbnRDQkluZm8sXG4gIFNlc3Npb25FdmVudENvZGUsXG4gIFNlc3Npb25Qcm9wZXJ0aWVzLFxuICBTZXNzaW9uU3RhdGUsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LXNlc3Npb24nKTtcbmNvbnN0IHtcbiAgQ2FjaGVDQkluZm8sXG4gIENhY2hlTGl2ZURhdGFBY3Rpb24sXG4gIENhY2hlUmVxdWVzdFJlc3VsdCxcbiAgQ2FjaGVSZXR1cm5Db2RlLFxuICBDYWNoZVJldHVyblN1YmNvZGUsXG4gIENhY2hlU2Vzc2lvbixcbiAgQ2FjaGVTZXNzaW9uUHJvcGVydGllcyxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbicpO1xuY29uc3Qge1xuICBTdGF0VHlwZSxcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtc3RhdHMnKTtcbmNvbnN0IHtcbiAgVHJhbnNwb3J0RXJyb3IsXG4gIFRyYW5zcG9ydFByb3RvY29sLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC10cmFuc3BvcnQnKTtcbmNvbnN0IHtcbiAgVmVyc2lvbixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSW50ZXJuYWwgQVBJIC0tIGRvIG5vdCB1c2UgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExvYWQgbWUgbGFzdC4gSSBkaXNhcHBlYXIgaW4gcHJvZHVjdGlvbiBtb2RlXG5jb25zdCBfaW50ZXJuYWwgPSByZXF1aXJlKCcuL2FwaS1pbnRlcm5hbC5qcycpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHNvbGFjZSA9IHtcbiAgQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3IsXG4gIEF1dGhlbnRpY2F0aW9uU2NoZW1lLFxuICBDYWNoZUNCSW5mbyxcbiAgQ2FjaGVMaXZlRGF0YUFjdGlvbixcbiAgQ2FjaGVSZXF1ZXN0UmVzdWx0LFxuICBDYWNoZVJldHVybkNvZGUsXG4gIENhY2hlUmV0dXJuU3ViY29kZSxcbiAgQ2FjaGVTZXNzaW9uLFxuICBDYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLFxuICBDYXBhYmlsaXR5VHlwZSxcbiAgQ29uc29sZUxvZ0ltcGwsXG4gIERlc3RpbmF0aW9uLFxuICBEZXN0aW5hdGlvblR5cGUsXG4gIEVycm9yU3ViY29kZSxcbiAgTG9nSW1wbCxcbiAgTG9nTGV2ZWwsXG4gIExvbmcsXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VDYWNoZVN0YXR1cyxcbiAgTWVzc2FnZUNvbnN1bWVyLFxuICBNZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGUsXG4gIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSxcbiAgTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyxcbiAgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUsXG4gIE1lc3NhZ2VEdW1wRmxhZyxcbiAgTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSxcbiAgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMsXG4gIE1lc3NhZ2VSeENCSW5mbyxcbiAgTWVzc2FnZVR5cGUsXG4gIE1lc3NhZ2VVc2VyQ29zVHlwZSxcbiAgTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSxcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgT3BlcmF0aW9uRXJyb3IsXG4gIFF1ZXVlQWNjZXNzVHlwZSxcbiAgUXVldWVEZXNjcmlwdG9yLFxuICBRdWV1ZURpc2NhcmRCZWhhdmlvcixcbiAgUXVldWVQZXJtaXNzaW9ucyxcbiAgUXVldWVQcm9wZXJ0aWVzLFxuICBRdWV1ZVR5cGUsXG4gIFJlcXVlc3RFcnJvcixcbiAgUmVxdWVzdEV2ZW50Q29kZSxcbiAgU0RURmllbGQsXG4gIFNEVEZpZWxkVHlwZSxcbiAgU0RUTWFwQ29udGFpbmVyLFxuICBTRFRTdHJlYW1Db250YWluZXIsXG4gIFNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcixcbiAgU0RUVmFsdWVFcnJvclN1YmNvZGUsXG4gIFNlc3Npb24sXG4gIFNlc3Npb25FdmVudCxcbiAgU2Vzc2lvbkV2ZW50Q0JJbmZvLFxuICBTZXNzaW9uRXZlbnRDb2RlLFxuICBTZXNzaW9uUHJvcGVydGllcyxcbiAgU2Vzc2lvblN0YXRlLFxuICBTb2xjbGllbnRGYWN0b3J5LFxuICBTb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMsXG4gIFNvbGNsaWVudEZhY3RvcnlQcm9wZXJ0aWVzLFxuICBTdGF0VHlwZSxcbiAgVG9waWMsXG4gIFRyYW5zcG9ydEVycm9yLFxuICBUcmFuc3BvcnRQcm90b2NvbCxcbiAgVmVyc2lvbixcblxuICBtYWtlSXRlcmF0b3IsXG5cbiAgX2ludGVybmFsLCAvL1xufTtcblxuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywgc29sYWNlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWNvcmUvYXBpLmpzIiwiLy8gVGhpcyBjb2RlIHdhcyB3cml0dGVuIGJ5IFR5bGVyIEFraW5zIGFuZCBoYXMgYmVlbiBwbGFjZWQgaW4gdGhlXG4vLyBwdWJsaWMgZG9tYWluLiAgSXQgd291bGQgYmUgbmljZSBpZiB5b3UgbGVmdCB0aGlzIGhlYWRlciBpbnRhY3QuXG4vLyBCYXNlNjQgY29kZSBmcm9tIFR5bGVyIEFraW5zIC0tIGh0dHA6Ly9ydW1raW4uY29tXG5cbi8vIEl0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IG1lIChFZHdhcmQgRnVubmVrb3R0ZXIpIHRvIGltcHJvdmUgaXRzXG4vLyBlZmZpY2llbmN5XG5cbi8vIEl0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IG1lIChKdXN0aW4gQm93ZXMpIHRvIGF2b2lkIHVzaW5nIGl0IHdoZW5ldmVyXG4vLyBwb3NzaWJsZSBpbiBmYXZvdXIgb2YgYnJvd3NlciBvciBidWZmZXIgaW1wbGVtZW50YXRpb25zLlxuXG5jb25zdCBLRVlfU1RSID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbmNvbnN0IEVOQ19MVVQgPSBbXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCA5OSwgLTEsIC0xLCA5OSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgOTksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCA2MiwgLTEsIC0xLCAtMSwgNjMsXG4gIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSxcbiAgNjAsIDYxLCAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLFxuXG4gICAgLy8gNjRcbiAgLTEsIDAsIDEsIDIsIDMsIDQsIDUsIDYsXG4gIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCxcbiAgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLFxuICAyMywgMjQsIDI1LCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMixcbiAgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLFxuICA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsXG4gIDQ5LCA1MCwgNTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuICAgIC8vIDEyOFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuICAgIC8vIDE5MlxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV07XG5cbmNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG59XG5cbmNvbnN0IExlZ2FjeUVuY29kZXIgPSB7XG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgc3RyaW5nIGluIGJhc2U2NFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0byBlbmNvZGUgaW4gYmFzZTY0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBpbnB1dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmFzZTY0X2VuY29kZShpbnB1dCkge1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgY29uc3QgY2hyMSA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGNvbnN0IGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBjb25zdCBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICBjb25zdCBlbmMxID0gY2hyMSA+PiAyO1xuICAgICAgY29uc3QgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICBsZXQgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuICAgICAgbGV0IGVuYzQgPSBjaHIzICYgNjM7XG5cbiAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCArPSBLRVlfU1RSLmNoYXJBdChlbmMxKTtcbiAgICAgIG91dHB1dCArPSBLRVlfU1RSLmNoYXJBdChlbmMyKTtcbiAgICAgIG91dHB1dCArPSBLRVlfU1RSLmNoYXJBdChlbmMzKTtcbiAgICAgIG91dHB1dCArPSBLRVlfU1RSLmNoYXJBdChlbmM0KTtcbiAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGJhc2U2NCBzdHJpbmcgdG8gZGVjb2RlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBiaW5hcnkgb3V0cHV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiYXNlNjRfZGVjb2RlKGlucHV0KSB7XG4gICAgbGV0IG91dHB1dCA9ICcnO1xuICAgIGxldCBpID0gMDtcblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChFTkNfTFVUW2lucHV0LmNoYXJDb2RlQXQoaSldID4gNjQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5jMSA9IEVOQ19MVVRbaW5wdXQuY2hhckNvZGVBdChpKyspXTtcbiAgICAgIGNvbnN0IGVuYzIgPSBFTkNfTFVUW2lucHV0LmNoYXJDb2RlQXQoaSsrKV07XG4gICAgICBjb25zdCBlbmMzID0gRU5DX0xVVFtpbnB1dC5jaGFyQ29kZUF0KGkrKyldO1xuICAgICAgY29uc3QgZW5jNCA9IEVOQ19MVVRbaW5wdXQuY2hhckNvZGVBdChpKyspXTtcblxuICAgICAgaWYgKGVuYzEgPCAwIHx8IGVuYzIgPCAwIHx8IGVuYzMgPCAwIHx8IGVuYzQgPCAwKSB7XG4gICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyIGluIGJhc2U2NCB0ZXh0XG4gICAgICAgIC8vIGFsZXJ0KFwiZW5jIGF0IFwiICsgaSArIFwiOiBcIiArIGVuYzEgKyBcIiwgXCIgKyBlbmMyICsgXCIsIFwiICsgZW5jMyArIFwiLCBcIiArIGVuYzQpO1xuICAgICAgICB0aHJvdyBuZXcgRGVjb2RlRXJyb3IoJ0ludmFsaWQgYmFzZTY0IGNoYXJhY3RlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICAgIGNvbnN0IGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgIGNvbnN0IGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xuXG4gICAgICBpZiAoZW5jMyAhPT0gNjQpIHtcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICB9XG4gICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMyk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCAtIDMpO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbn07XG5cbmNvbnN0IGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyAvLyAhbm9kZVxuY29uc3QgaGFzQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnOyAvLyAhbm9kZSwgIWllOVxuY29uc3QgQnVmZmVyRW5jb2RlciA9IChoYXNCdWZmZXIgJiYgKGhhc0Jsb2IgfHwgaXNOb2RlKSlcbiAgPyB7XG4gICAgYmFzZTY0X2VuY29kZTogc3RyID0+IEJ1ZmZlci5mcm9tKHN0ciwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICBiYXNlNjRfZGVjb2RlOiBzdHIgPT4gQnVmZmVyLmZyb20oc3RyLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpLFxuICB9XG4gIDoge307XG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGVzbGludC1kaXNhYmxlIGRvdC1ub3RhdGlvbiAqL1xuY29uc3QgV2luZG93RW5jb2RlciA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgPyB7XG4gICAgYmFzZTY0X2VuY29kZTogd2luZG93WydidG9hJ10gPyBiID0+IHdpbmRvd1snYnRvYSddKGIpIDogbnVsbCxcbiAgICBiYXNlNjRfZGVjb2RlOiB3aW5kb3dbJ2F0b2InXSA/IGEgPT4gd2luZG93WydhdG9iJ10oYSkgOiBudWxsLFxuICB9XG4gIDoge307XG4vKiBlc2xpbnQtZW5hYmxlIGRvdC1ub3RhdGlvbiAqL1xuXG5jb25zdCBCYXNlNjQgPSB7XG4gIGVuY29kZTogKFdpbmRvd0VuY29kZXIuYmFzZTY0X2VuY29kZSB8fFxuICAgICAgICAgICBCdWZmZXJFbmNvZGVyLmJhc2U2NF9lbmNvZGUgfHxcbiAgICAgICAgICAgTGVnYWN5RW5jb2Rlci5iYXNlNjRfZW5jb2RlKSxcbiAgZGVjb2RlOiAoV2luZG93RW5jb2Rlci5iYXNlNjRfZGVjb2RlIHx8XG4gICAgICAgICAgIEJ1ZmZlckVuY29kZXIuYmFzZTY0X2RlY29kZSB8fFxuICAgICAgICAgICBMZWdhY3lFbmNvZGVyLmJhc2U2NF9kZWNvZGUpLFxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzZTY0ID0gQmFzZTY0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29udmVydC9saWIvYmFzZTY0LmpzIiwiY29uc3QgQml0cyA9IHtcbiAgZ2V0KHZhbCwgc2hpZnQsIG51bUJpdHMpIHtcbiAgICByZXR1cm4gKHZhbCA+Pj4gc2hpZnQpICYgKCgweDAxIDw8IG51bUJpdHMpIC0gMSk7XG4gIH0sXG5cbiAgc2V0KGRhdGFJbiwgdmFsLCBzaGlmdCwgbnVtQml0cykge1xuICAgIGNvbnN0IGN1ck1hc2sgPSAoMSA8PCBudW1CaXRzKSAtIDE7XG4gICAgY29uc3Qgc2hpZnRlZFZhbCA9ICh2YWwgJiBjdXJNYXNrKSA8PCBzaGlmdDtcbiAgICBjb25zdCBkYXRhID0gZGF0YUluICYgfihjdXJNYXNrIDw8IHNoaWZ0KTtcbiAgICByZXR1cm4gKGRhdGEgfCBzaGlmdGVkVmFsKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJpdHMgPSBCaXRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29udmVydC9saWIvYml0cy5qcyIsImNvbnN0IExvbmcgPSByZXF1aXJlKCdsb25nJyk7XG5cbi8qKlxuICogQG1vZHVsZVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb252ZXJ0XG4gKlxuICogVGhpcyBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBwZXJmb3JtcyBhbGwgcmVxdWlyZWQgc3RyaW5nIHRvIG51bWJlciBhbmQgbnVtYmVyIHRvIHN0cmluZ1xuICogY29udmVyc2lvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgVFdPX1pFUk9FU19TVFIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDApO1xuY29uc3QgVEhSRUVfWkVST0VTX1NUUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMCwgMCk7XG5jb25zdCBGT1VSX1pFUk9FU19TVFIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDAsIDAsIDApO1xuXG5jb25zdCBCWVRFQVJSQVlfQ09OVkVSVF9DSFVOSyA9IDgxOTI7XG5jb25zdCBVTlNJR05FRF9MU0hJRlRfMjQgPSAoMjU2ICogMjU2ICogMjU2KTtcblxuY29uc3QgQVJSQVlfQlVGRkVSX0NPTlZFUlRfQ0hVTksgPSAzMjc2ODtcblxuZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KGRhdGEpIHtcbiAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICBjb25zdCBhcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhTGVuZ3RoKTtcbiAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmLCAwLCBkYXRhTGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICB1aW50OEFycmF5W2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiB1aW50OEFycmF5O1xufVxuXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvU3RyaW5nKGFiKSB7XG4gIGlmICghYWIpIHJldHVybiAnJztcbiAgY29uc3QgbGVuID0gYWIuYnl0ZUxlbmd0aDtcbiAgY29uc3QgdTggPSBuZXcgVWludDhBcnJheShhYik7XG4gIGlmIChsZW4gPCBBUlJBWV9CVUZGRVJfQ09OVkVSVF9DSFVOSykge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHU4KTtcbiAgfVxuXG4gIGxldCBrID0gMDtcbiAgbGV0IHIgPSAnJztcbiAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAvLyBzbGljZSBpcyBjbGFtcGVkLCBpbmNsdXNpdmUgb2Ygc3RhcnRJbmRleCwgZXhjbHVzaXZlIG9mIGxhc3RJbmRleFxuICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1OC5zdWJhcnJheShrLCBrICsgQVJSQVlfQlVGRkVSX0NPTlZFUlRfQ0hVTkspKTtcbiAgICBrICs9IEFSUkFZX0JVRkZFUl9DT05WRVJUX0NIVU5LO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5QnVmZmVyKHN0cikge1xuICByZXR1cm4gc3RyaW5nVG9VaW50OEFycmF5KHN0cikuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBpbnQ4VG9TdHIoaW50OCkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpbnQ4ICYgMHhmZik7XG59XG5cbmZ1bmN0aW9uIGludDE2VG9TdHIoaW50MTYpIHtcbiAgcmV0dXJuIChcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDE2ID4+IDgpICYgMHhmZikgK1xuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpbnQxNiAmIDB4ZmYpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGludDI0VG9TdHIoaW50MjQpIHtcbiAgcmV0dXJuIChcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDI0ID4+IDE2KSAmIDB4ZmYpICtcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDI0ID4+IDgpICYgMHhmZikgK1xuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpbnQyNCAmIDB4ZmYpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGludDMyVG9TdHIoaW50MzIpIHtcbiAgLy8gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGVyZSBhcmUgYSBsb3Qgb2Ygc21hbGwgbnVtYmVyc1xuICAvLyBiZWluZyBjb252ZXJ0ZWQsIHNvIGl0IGlzIHdvcnRoIGRvaW5nIGEgZmV3IGNoZWNrcyBmb3JcbiAgLy8gZWZmaWNpZW5jeSAob24gZmlyZWZveCBpdCBpcyBhYm91dCAzIHRpbWVzIHF1aWNrZXIgZm9yIHNtYWxsIG51bWJlcnNcbiAgLy8gdG8gZG8gdGhlIGNoZWNrIC0gaXQgaXMgMiB0aW1lcyBxdWlja2VyIGZvciBjaHJvbWUpXG5cbiAgaWYgKGludDMyID09PSAwKSByZXR1cm4gRk9VUl9aRVJPRVNfU1RSO1xuICBpZiAoaW50MzIgPiAwKSB7XG4gICAgaWYgKGludDMyIDwgMjU2KSB7XG4gICAgICByZXR1cm4gVEhSRUVfWkVST0VTX1NUUiArIFN0cmluZy5mcm9tQ2hhckNvZGUoaW50MzIpO1xuICAgIH1cbiAgICBpZiAoaW50MzIgPCA2NTUzNikge1xuICAgICAgcmV0dXJuIFRXT19aRVJPRVNfU1RSICsgU3RyaW5nLmZyb21DaGFyQ29kZShpbnQzMiA+PiA4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaW50MzIgJiAweGZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKFxuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50MzIgPj4gMjQpICYgMHhmZikgK1xuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50MzIgPj4gMTYpICYgMHhmZikgK1xuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50MzIgPj4gOCkgJiAweGZmKSArXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGludDMyICYgMHhmZilcbiAgKTtcbn1cblxuZnVuY3Rpb24gaW50NjRUb1N0cihpbnQ2NCkge1xuICBpZiAodHlwZW9mIGludDY0ICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBpbnQzMlRvU3RyKGludDY0LmhpZ2gpICsgaW50MzJUb1N0cihpbnQ2NC5sb3cpO1xuICB9XG5cbiAgLy8gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGVyZSBhcmUgYSBsb3Qgb2Ygc21hbGwgbnVtYmVyc1xuICAvLyBiZWluZyBjb252ZXJ0ZWQsIHNvIGl0IGlzIHdvcnRoIGRvaW5nIGEgZmV3IGNoZWNrcyBmb3JcbiAgLy8gZWZmaWNpZW5jeSAob24gZmlyZWZveCBpdCBpcyBhYm91dCAzIHRpbWVzIHF1aWNrZXIgZm9yIHNtYWxsIG51bWJlcnNcbiAgLy8gdG8gZG8gdGhlIGNoZWNrIC0gaXQgaXMgMiB0aW1lcyBxdWlja2VyIGZvciBjaHJvbWUpXG4gIGlmIChpbnQ2NCA+PSAwKSB7XG4gICAgaWYgKGludDY0IDwgMjU2KSB7XG4gICAgICByZXR1cm4gRk9VUl9aRVJPRVNfU1RSICsgVEhSRUVfWkVST0VTX1NUUiArIFN0cmluZy5mcm9tQ2hhckNvZGUoaW50NjQpO1xuICAgIH1cbiAgICBpZiAoaW50NjQgPCA2NTUzNikge1xuICAgICAgcmV0dXJuIEZPVVJfWkVST0VTX1NUUiArIFRXT19aRVJPRVNfU1RSICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpbnQ2NCA+PiA4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaW50NjQgJiAweGZmKTtcbiAgICB9XG4gICAgaWYgKGludDY0IDwgNDI5NDk2NzI5Nikge1xuICAgICAgcmV0dXJuIEZPVVJfWkVST0VTX1NUUiArIChTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnQ2NCA+PiAyNCkgJiAweGZmKSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDY0ID4+IDE2KSAmIDB4ZmYpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50NjQgPj4gOCkgJiAweGZmKSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaW50NjQgJiAweGZmKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnQ2NCA+PiA1NikgJiAweEZGKSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDY0ID4+IDQ4KSAmIDB4RkYpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50NjQgPj4gNDApICYgMHhGRikgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnQ2NCA+PiAzMikgJiAweEZGKSArXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGludDY0ID4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgoaW50NjQgPj4gMTYpICYgMHhmZikgK1xuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnQ2NCA+PiA4KSAmIDB4ZmYpICtcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShpbnQ2NCAmIDB4ZmYpO1xufVxuXG5mdW5jdGlvbiBieXRlQXJyYXlUb1N0cihieXRlQXJyYXkpIHtcbiAgY29uc3QgbGVuID0gYnl0ZUFycmF5Lmxlbmd0aDtcbiAgaWYgKGxlbiA8IEJZVEVBUlJBWV9DT05WRVJUX0NIVU5LKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZUFycmF5KTtcbiAgfVxuXG4gIGxldCBrID0gMDtcbiAgbGV0IHIgPSAnJztcblxuICB3aGlsZSAoayA8IGxlbikge1xuICAgIC8vIHNsaWNlIGlzIGNsYW1wZWQsIGluY2x1c2l2ZSBvZiBzdGFydEluZGV4LCBleGNsdXNpdmUgb2YgbGFzdEluZGV4XG4gICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVBcnJheS5zbGljZShrLCBrICsgQllURUFSUkFZX0NPTlZFUlRfQ0hVTkspKTtcbiAgICBrICs9IEJZVEVBUlJBWV9DT05WRVJUX0NIVU5LO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHN0clRvQnl0ZUFycmF5KHN0cikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzdHJUb0hleEFycmF5KHN0cikge1xuICBmdW5jdGlvbiB0b0hleChjKSB7XG4gICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChzdHIuc3BsaXQoJycpLCB0b0hleCk7XG59XG5cbmZ1bmN0aW9uIHN0clRvSW50OChkYXRhKSB7XG4gIHJldHVybiBkYXRhLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBzdHJUb0ludDE2KGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICAgIChkYXRhLmNoYXJDb2RlQXQoMCkgPDwgOCkgK1xuICAgICAgKGRhdGEuY2hhckNvZGVBdCgxKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gc3RyVG9JbnQyNChkYXRhKSB7XG4gIHJldHVybiAoXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDApIDw8IDE2KSArXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcbiAgICAgIChkYXRhLmNoYXJDb2RlQXQoMikpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHN0clRvSW50MzIoZGF0YSkge1xuICAgIC8vIFNJR05FRCBpbnRlZ2VyXG4gIHJldHVybiAoXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDApIDw8IDI0KSArXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDEpIDw8IDE2KSArXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDIpIDw8IDgpICtcbiAgICAgIChkYXRhLmNoYXJDb2RlQXQoMykpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHN0clRvVUludDMyKGRhdGEpIHtcbiAgLy8gV0FSTklORzogeW91IGNhbm5vdCB1c2UgYSA8PCAyNCB0byBzaGlmdCBhIGJ5dGUgaW50b1xuICAvLyBhIDMyLWJpdCBzdHJpbmcsIGJlY2F1c2UgYWxsIHNoaWZ0cyBpbiBKUyBhcmUgc2lnbmVkXG4gIHJldHVybiAoXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDApICogVU5TSUdORURfTFNISUZUXzI0KSArXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDEpIDw8IDE2KSArXG4gICAgICAoZGF0YS5jaGFyQ29kZUF0KDIpIDw8IDgpICtcbiAgICAgIChkYXRhLmNoYXJDb2RlQXQoMykpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHN0clRvVUludDY0KGRhdGEpIHtcbiAgcmV0dXJuIExvbmcuZnJvbUJpdHMoc3RyVG9VSW50MzIoZGF0YS5zdWJzdHIoNCwgNCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBzdHJUb1VJbnQzMihkYXRhLnN1YnN0cigwLCA0KSksXG4gICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xufVxuXG5mdW5jdGlvbiB1Y3MyVG9VdGY4KHVjczIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1Y3MyKSk7XG59XG5cbmZ1bmN0aW9uIHV0ZjhUb1VjczIodXRmOCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1dGY4KSk7XG59XG5cbmNvbnN0IENvbnZlcnQgPSB7XG4gIGFycmF5QnVmZmVyVG9TdHJpbmcsXG4gIHN0cmluZ1RvQXJyYXlCdWZmZXIsXG4gIHN0cmluZ1RvVWludDhBcnJheSxcblxuICBpbnQ4VG9TdHIsXG4gIHN0clRvSW50OCxcblxuICBpbnQxNlRvU3RyLFxuICBzdHJUb0ludDE2LFxuXG4gIGludDI0VG9TdHIsXG4gIHN0clRvSW50MjQsXG5cbiAgaW50MzJUb1N0cixcbiAgc3RyVG9JbnQzMixcbiAgc3RyVG9VSW50MzIsXG5cbiAgaW50NjRUb1N0cixcbiAgc3RyVG9VSW50NjQsXG5cbiAgYnl0ZUFycmF5VG9TdHIsXG4gIHN0clRvQnl0ZUFycmF5LFxuXG4gIHN0clRvSGV4QXJyYXksXG5cbiAgdWNzMlRvVXRmOCxcbiAgdXRmOFRvVWNzMixcbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbnZlcnQgPSBDb252ZXJ0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29udmVydC9saWIvY29udmVydC5qcyIsImZ1bmN0aW9uIG51bVRvSGV4KG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBzID0gbi50b1N0cmluZygxNik7XG4gIHJldHVybiAocy5sZW5ndGggPCAyKSA/IGAwJHtzfWAgOiBzO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEhleFN0cmluZyhvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGAweCR7bnVtVG9IZXgob2JqKX1gO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKG51bVRvSGV4KS5qb2luKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9iaiwgKF8sIGkpID0+IG51bVRvSGV4KG9iai5jaGFyQ29kZUF0KGkpKSkuam9pbignJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgSGV4ID0ge1xuICBmb3JtYXRIZXhTdHJpbmcsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5IZXggPSBIZXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1jb252ZXJ0L2xpYi9oZXguanMiLCJtb2R1bGUuZXhwb3J0cy5Mb25nID0gcmVxdWlyZSgnbG9uZycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29udmVydC9saWIvbG9uZy5qcyIsIi8qKlxuICogU29sY2xpZW50SlMgaW50ZXJuYWwgQVBJIGZvciB3aGl0ZS1ib3ggaW50ZWdyYXRpb24gdGVzdGluZ1xuICogQHByaXZhdGVcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBzb3J0LXJlcXVpcmVzL3NvcnQtcmVxdWlyZXMgKi9cblxuY29uc3QgQ29udmVydCA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCBEZWJ1ZyA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZWJ1ZycpO1xuY29uc3QgRGVzdGluYXRpb24gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IEVycm9yID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCBFU0tpdCA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgRmFjdG9yeSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5jb25zdCBGU00gPSByZXF1aXJlKCdzb2xjbGllbnQtZnNtJyk7XG5jb25zdCBMb2cgPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnc29sY2xpZW50LW1lc3NhZ2UnKTtcbmNvbnN0IFB1Ymxpc2hlciA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlcicpO1xuY29uc3QgU0RUID0gcmVxdWlyZSgnc29sY2xpZW50LXNkdCcpO1xuY29uc3QgU2Vzc2lvbiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zZXNzaW9uJyk7XG5jb25zdCBTTUYgPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5jb25zdCBTb2xjYWNoZVNlc3Npb24gPSByZXF1aXJlKCdzb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbicpO1xuY29uc3QgVGVzdEVudiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lbnYnKTtcbmNvbnN0IFRyYW5zcG9ydCA9IHJlcXVpcmUoJ3NvbGNsaWVudC10cmFuc3BvcnQnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuY29uc3QgVmFsaWRhdGUgPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENvbnZlcnQsXG4gIERlYnVnLFxuICBEZXN0aW5hdGlvbixcbiAgRXJyb3IsXG4gIEVTS2l0LFxuICBGYWN0b3J5LFxuICBGU00sXG4gIExvZyxcbiAgTWVzc2FnZSxcbiAgUHVibGlzaGVyLFxuICBTRFQsXG4gIFNlc3Npb24sXG4gIFNNRixcbiAgU29sY2FjaGVTZXNzaW9uLFxuICBUZXN0RW52LFxuICBUcmFuc3BvcnQsXG4gIFV0aWwsXG4gIFZhbGlkYXRlLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWNvcmUvYXBpLWludGVybmFsLmpzIiwiLy8gTW9kaWZ5IHRoZSBOb2RlIChvciBlbXVsYXRlZCBOb2RlKSBlbnZpcm9ubWVudCBzbyB0aGF0XG4vLyB3ZSBjYW4gdXNlIG5vbi1kZXByZWNhdGVkIHN5bnRheC5cblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20gPT09IHVuZGVmaW5lZCkge1xuICAvLyBJbnNwZWN0IHdpbGwgdXNlIGN1c3RvbUluc3BlY3QgKGRlcHJlY2F0ZWQpIG9yIGEgbWV0aG9kIHdpdGggdGhpcyBuYW1lLlxuICAvLyBXZSBjYW4ganVzdCBkZWZpbmUgdGhlIG5hbWUgdG8gYmUgZXF1YWwgdG8gJ2luc3BlY3QnIGZvciBjb21wYXRpYmlsaXR5XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHN1Y2ggc3ltYm9sLlxuICB1dGlsLmluc3BlY3QuY3VzdG9tID0gJ2luc3BlY3QnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtY29yZS9saWIvbm9kZS1mb3J3YXJkLmpzIiwiLyogZXNsaW50LWRpc2FibGUgZ2xvYmFsLXJlcXVpcmUgKi9cbi8vIERvIGxhdGUgYmluZGluZyBmb3IgdGhlc2UgZGVidWcgdXRpbGl0aWVzIHRvIGJyZWFrIGN5Y2xpYyBkZXBlbmRlbmNpZXMuXG5cbmNvbnN0IFBSSU5UQUJMRV9MVVQgPSAoKCkgPT4ge1xuICBjb25zdCB0bXAgPSBbXTtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCAyNTY7ICsrYykge1xuICAgIHRtcFtjXSA9IChjIDwgMzMgfHwgYyA+IDEyNikgPyAnLicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIHJldHVybiB0bXA7XG59KSgpO1xuXG5jb25zdCBTUEFDRVIgPSAnICAgJztcbmNvbnN0IFVOUFJJTlRBQkxFID0gJy4nO1xuXG5cbmZ1bmN0aW9uIGZvcm1hdER1bXBCeXRlcyhkYXRhLCBzaG93RGVjb2RlLCBsZWZ0UGFkZGluZykge1xuICBjb25zdCB7IFN0cmluZ0J1ZmZlciwgU3RyaW5nVXRpbHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG4gIGNvbnN0IHsgaXNFbXB0eSwgcGFkTGVmdCwgcGFkUmlnaHQgfSA9IFN0cmluZ1V0aWxzO1xuXG4gIGlmIChpc0VtcHR5KGRhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBjb25zdCBhc2NpaSA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgY29uc3QgbGluZSA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgbGV0IGxpbmVCeXRlcyA9IDA7XG4gIGNvbnN0IGFzY2lpT2Zmc2V0ID0gNTQ7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGRhdGFMZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGRhdGFMZW47ICsraSkge1xuICAgIGNvbnN0IGNjb2RlID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGxpbmUuYXBwZW5kKHBhZExlZnQoY2NvZGUudG9TdHJpbmcoMTYpLCAyLCAnMCcpLCAnICcpO1xuICAgIGFzY2lpLmFwcGVuZChQUklOVEFCTEVfTFVUW2Njb2RlXSB8fCBVTlBSSU5UQUJMRSk7XG4gICAgbGluZUJ5dGVzKys7XG5cbiAgICBpZiAobGluZUJ5dGVzID09PSA4KSB7XG4gICAgICBsaW5lLmFwcGVuZChTUEFDRVIpO1xuICAgIH1cblxuICAgIGlmIChsaW5lQnl0ZXMgPT09IDE2IHx8IGkgPT09IGRhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgaWYgKGxlZnRQYWRkaW5nID4gMCkge1xuICAgICAgICBvdXRwdXQuYXBwZW5kKHBhZFJpZ2h0KCcnLCBsZWZ0UGFkZGluZywgJyAnKSk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5hcHBlbmQocGFkUmlnaHQobGluZS50b1N0cmluZygpLCBhc2NpaU9mZnNldCwgJyAnKSk7XG5cbiAgICAgIGlmIChzaG93RGVjb2RlKSB7XG4gICAgICAgIG91dHB1dC5hcHBlbmQoYXNjaWkpO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQuYXBwZW5kKCdcXG4nKTtcbiAgICAgIGxpbmUuY2xlYXIoKTtcbiAgICAgIGFzY2lpLmNsZWFyKCk7XG4gICAgICBsaW5lQnl0ZXMgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTTUZTdHJlYW0oZGF0YSkge1xuICBjb25zdCB7IENvZGVjOiB7IERlY29kZTogeyBkZWNvZGVDb21wb3VuZE1lc3NhZ2UgfSB9IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG4gIGNvbnN0IHsgTE9HX1dBUk4sIExPR19FUlJPUiB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuXG4gIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgTE9HX0VSUk9SKCdkYXRhIG51bGwgaW4gZGVidWdQYXJzZVNtZlN0cmVhbScpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcG9zID0gMDtcbiAgTE9HX1dBUk4oYHBhcnNlU01GU3RyZWFtKCk6IFN0YXJ0aW5nIHBhcnNlLCBsZW5ndGggJHtkYXRhLmxlbmd0aH1gKTtcbiAgd2hpbGUgKHBvcyA8IGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5jb21pbmdNc2cgPSBkZWNvZGVDb21wb3VuZE1lc3NhZ2UoZGF0YSwgcG9zKTtcbiAgICBjb25zdCBzbWYgPSBpbmNvbWluZ01zZyA/IGluY29taW5nTXNnLnNtZkhlYWRlciA6IG51bGw7XG4gICAgaWYgKCEoaW5jb21pbmdNc2cgJiYgc21mKSkge1xuICAgICAgLy8gY291bGRuJ3QgZGVjb2RlISBMb3N0IFNNRiBmcmFtaW5nLlxuICAgICAgTE9HX1dBUk4oXCJwYXJzZVNNRlN0cmVhbSgpOiBjb3VsZG4ndCBkZWNvZGUgbWVzc2FnZS5cIik7XG4gICAgICBMT0dfV0FSTihgUG9zaXRpb246ICR7cG9zfSBsZW5ndGg6ICR7ZGF0YS5sZW5ndGh9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTE9HX1dBUk4oYD4+IFBvcygke3Bvc30pIFByb3RvY29sICR7c21mLnNtZl9wcm90b2NvbH0sIExlbmd0aDogJHtzbWYubWVzc2FnZUxlbmd0aH1gKTtcbiAgICBwb3MgKz0gc21mLm1lc3NhZ2VMZW5ndGg7XG4gIH1cbn1cblxuY29uc3QgRGVidWcgPSB7XG4gIGZvcm1hdER1bXBCeXRlcyxcbiAgcGFyc2VTTUZTdHJlYW0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5EZWJ1ZyA9IERlYnVnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVidWcvbGliL2RlYnVnLmpzIiwiY29uc3QgeyBEZXN0aW5hdGlvblR5cGUgfSA9IHJlcXVpcmUoJy4vZGVzdGluYXRpb24tdHlwZScpO1xuY29uc3QgeyBEZXN0aW5hdGlvblV0aWwgfSA9IHJlcXVpcmUoJy4vZGVzdGluYXRpb24tdXRpbCcpO1xuY29uc3QgeyBRdWV1ZSB9ID0gcmVxdWlyZSgnLi9xdWV1ZScpO1xuY29uc3QgeyBUb3BpYyB9ID0gcmVxdWlyZSgnLi90b3BpYycpO1xuXG5jb25zdCBRVUVVRV9QUkVGSVggPSAnI1AyUC9RVUUvJztcbmNvbnN0IFFVRVVFX1BSRUZJWF9MRU4gPSBRVUVVRV9QUkVGSVgubGVuZ3RoO1xuY29uc3QgVEVNUE9SQVJZX1FVRVVFX1BSRUZJWCA9ICcjUDJQL1FUTVAvJztcblxuZnVuY3Rpb24gY3JlYXRlRGVzdGluYXRpb25Gcm9tTmFtZShuZXR3b3JrVG9waWNOYW1lLCBuZXR3b3JrVG9waWNCeXRlcyA9IHVuZGVmaW5lZCkge1xuICBpZiAobmV0d29ya1RvcGljTmFtZSA9PT0gbnVsbCB8fCBuZXR3b3JrVG9waWNOYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgc3BlYyA9IHtcbiAgICBuYW1lOiAgbmV0d29ya1RvcGljTmFtZSxcbiAgICBieXRlczogbmV0d29ya1RvcGljQnl0ZXMgfHwgRGVzdGluYXRpb25VdGlsLmVuY29kZUJ5dGVzKG5ldHdvcmtUb3BpY05hbWUpLFxuICB9O1xuICBpZiAobmV0d29ya1RvcGljTmFtZVswXSA9PT0gJyMnKSB7XG4gICAgaWYgKG5ldHdvcmtUb3BpY05hbWUuc3RhcnRzV2l0aChRVUVVRV9QUkVGSVgpKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBRVUVVRV9QUkVGSVhfTEVOO1xuICAgICAgc3BlYy5uYW1lID0gbmV0d29ya1RvcGljTmFtZS5zdWJzdHIob2Zmc2V0KTtcbiAgICAgIHNwZWMudHlwZSA9IERlc3RpbmF0aW9uVHlwZS5RVUVVRTtcbiAgICAgIHNwZWMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgcmV0dXJuIG5ldyBRdWV1ZShzcGVjKTtcbiAgICB9IGVsc2UgaWYgKG5ldHdvcmtUb3BpY05hbWUuc3RhcnRzV2l0aChURU1QT1JBUllfUVVFVUVfUFJFRklYKSkge1xuICAgICAgc3BlYy5uYW1lID0gbmV0d29ya1RvcGljTmFtZTtcbiAgICAgIHNwZWMudHlwZSA9IERlc3RpbmF0aW9uVHlwZS5URU1QT1JBUllfUVVFVUU7XG4gICAgICBzcGVjLm9mZnNldCA9IDA7XG4gICAgICByZXR1cm4gbmV3IFF1ZXVlKHNwZWMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFRvcGljKHNwZWMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXN0aW5hdGlvbkZyb21CeXRlcyhuZXR3b3JrVG9waWNCeXRlcykge1xuICBpZiAobmV0d29ya1RvcGljQnl0ZXMgPT09IG51bGwgfHwgbmV0d29ya1RvcGljQnl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBuZXR3b3JrVG9waWNOYW1lID0gRGVzdGluYXRpb25VdGlsLmRlY29kZUJ5dGVzKG5ldHdvcmtUb3BpY0J5dGVzKTtcbiAgcmV0dXJuIGNyZWF0ZURlc3RpbmF0aW9uRnJvbU5hbWUobmV0d29ya1RvcGljTmFtZSwgbmV0d29ya1RvcGljQnl0ZXMpO1xufVxuXG5jb25zdCBEZXN0aW5hdGlvbkZyb21OZXR3b3JrID0ge1xuICBjcmVhdGVEZXN0aW5hdGlvbkZyb21CeXRlcyxcbiAgY3JlYXRlRGVzdGluYXRpb25Gcm9tTmFtZSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkRlc3RpbmF0aW9uRnJvbU5ldHdvcmsgPSBEZXN0aW5hdGlvbkZyb21OZXR3b3JrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZGVzdGluYXRpb24vbGliL2Rlc3RpbmF0aW9uLWZyb20tbmV0d29yay5qcyIsImZ1bmN0aW9uIGFwaUVudihlbnZPYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBCVUlMRF9FTlYgIT09ICd1bmRlZmluZWQnICYmICFCVUlMRF9FTlYuVEVTVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBlbnZpcm9ubWVudCB3aWxsIG5vdCBvdmVycmlkZSBidWlsZCBlbnZpcm9ubWVudCcpO1xuICB9XG4gIGdsb2JhbC5CVUlMRF9FTlYgPSBPYmplY3QuYXNzaWduKHt9LCBlbnZPYmplY3QsIHsgVEVTVDogdHJ1ZSB9KTtcbiAgcmV0dXJuIGdsb2JhbC5CVUlMRF9FTlY7XG59XG5cbmlmICh0eXBlb2YgQlVJTERfRU5WICE9PSAndW5kZWZpbmVkJyAmJiBCVUlMRF9FTlYuVEVTVCA9PT0gZmFsc2UpIHtcbiAgYXBpRW52LnRhcmdldCA9ICgpID0+IGFwaUVudigpO1xufSBlbHNlIHtcbiAgY29uc3QgY29uZmlncyA9IHtcbiAgICBub2RlOiB7XG4gICAgICBUQVJHRVRfTkFNRTogJ25vZGUnLFxuICAgICAgVEFSR0VUX05PREU6IHRydWUsXG4gICAgfSxcbiAgICBicm93c2VyOiB7XG4gICAgICBUQVJHRVRfTkFNRTogICAgJ2Jyb3dzZXInLFxuICAgICAgVEFSR0VUX0JST1dTRVI6IHRydWUsXG4gICAgfSxcbiAgICBkZWJ1Zzoge1xuICAgICAgTU9ERV9OQU1FOiAgICAnZGVidWcnLFxuICAgICAgTU9ERV9ERUJVRzogICB0cnVlLFxuICAgICAgTU9ERV9SRUxFQVNFOiBmYWxzZSxcbiAgICB9LFxuICAgIHJlbGVhc2U6IHtcbiAgICAgIE1PREVfTkFNRTogICAgJ3JlbGVhc2UnLFxuICAgICAgTU9ERV9ERUJVRzogICBmYWxzZSxcbiAgICAgIE1PREVfUkVMRUFTRTogdHJ1ZSxcbiAgICB9LFxuICB9O1xuXG4gIGFwaUVudi50YXJnZXQgPSBmdW5jdGlvbiBuYW1lZCguLi5hcmdzKSB7XG4gICAgY29uc3Qgb2JqZWN0cyA9IGFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBvYmogPSBjb25maWdzW2FyZ107XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnZpcm9ubWVudCAke2FyZ30gaXMgbm90IGRlZmluZWQ7IHVzZSAke09iamVjdC5rZXlzKGNvbmZpZ3MpLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSBpZiAoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBhcmc7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGFyZ3VtZW50ICR7YXJnfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBhcGlFbnYoT2JqZWN0LmFzc2lnbiguLi5vYmplY3RzKSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGFwaUVudjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVudi9hcGkuanMiLCJjb25zdCB7IEVycm9yU3ViY29kZSB9ID0gcmVxdWlyZSgnLi9lcnJvci1zdWJjb2RlcycpO1xuY29uc3QgeyBtYWtlTWFwIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5jb25zdCBTQyA9IEVycm9yU3ViY29kZTtcblxuY29uc3QgUk9PVF9NQVBQSU5HID0gbWFrZU1hcChcbiAgNDAwLCBtYWtlTWFwKFxuICAgICdjbGllbnQgbmFtZSBwYXJzZSBlcnJvcicsIFNDLkNMSUVOVF9OQU1FX0lOVkFMSUQsXG4gICAgJ2RvY3VtZW50IGlzIHRvbyBsYXJnZScsIFNDLk1FU1NBR0VfVE9PX0xBUkdFLFxuICAgICdpbmFjdGl2aXR5IHRpbWVvdXQnLCBTQy5JTkFDVElWSVRZX1RJTUVPVVQsXG4gICAgJ21heCBudW0gc3Vic2NyaXB0aW9ucyBleGNlZWRlZCcsIFNDLlNVQlNDUklQVElPTl9UT09fTUFOWSxcbiAgICAnbWVzc2FnZSB0b28gbG9uZycsIFNDLk1FU1NBR0VfVE9PX0xBUkdFLFxuICAgICdub2xvY2FsIGRpc2NhcmQnLCBTQy5OT0xPQ0FMX0RJU0NBUkQsXG4gICAgJ25vdCBlbm91Z2ggc3BhY2UnLCBTQy5PVVRfT0ZfUkVTT1VSQ0VTLFxuICAgICdzdWJzY3JpcHRpb24gYWxyZWFkeSBleGlzdHMnLCBTQy5TVUJTQ1JJUFRJT05fQUxSRUFEWV9QUkVTRU5ULFxuICAgICdzdWJzY3JpcHRpb24gYXR0cmlidXRlcyBjb25mbGljdCB3aXRoIGV4aXN0aW5nIHN1YnNjcmlwdGlvbicsIFNDLlNVQlNDUklQVElPTl9BVFRSSUJVVEVTX0NPTkZMSUNULFxuICAgICdzdWJzY3JpcHRpb24gbm90IGZvdW5kJywgU0MuU1VCU0NSSVBUSU9OX05PVF9GT1VORCxcbiAgICAnc3Vic2NyaXB0aW9uIHBhcnNlIGVycm9yJywgU0MuU1VCU0NSSVBUSU9OX0lOVkFMSUQsXG4gICAgJ3RvcGljIHBhcnNlIGVycm9yJywgU0MuSU5WQUxJRF9UT1BJQ19TWU5UQVgsXG4gICAgJ3Vua25vd24gdHJhbnNwb3J0IHNlc3Npb24gaWRlbnRpZmllcicsIFNDLlVOS05PV05fVFJBTlNQT1JUX1NFU1NJT05fSUQsXG4gICAgJ3htbCBwYXJzZSBlcnJvcicsIFNDLlhNTF9QQVJTRV9FUlJPUlxuICApLFxuICA0MDEsIG1ha2VNYXAoXG4gICAgJycsIFNDLkxPR0lOX0ZBSUxVUkVcbiAgKSxcbiAgNDAzLCBtYWtlTWFwKFxuICAgICdiYXNpYyBhdXRoZW50aWNhdGlvbiBpcyBzaHV0ZG93bicsIFNDLkJBU0lDX0FVVEhFTlRJQ0FUSU9OX0lTX1NIVVRET1dOLFxuICAgICdjbGllbnQgY2VydGlmaWNhdGUgYXV0aGVudGljYXRpb24gaXMgc2h1dGRvd24nLCBTQy5DTElFTlRfQ0VSVElGSUNBVEVfQVVUSEVOVElDQVRJT05fSVNfU0hVVERPV04sXG4gICAgJ2NsaWVudCBuYW1lIGFscmVhZHkgaW4gdXNlJywgU0MuQ0xJRU5UX05BTUVfQUxSRUFEWV9JTl9VU0UsXG4gICAgJ2NsaWVudCB1c2VybmFtZSBpcyBzaHV0ZG93bicsIFNDLkNMSUVOVF9VU0VSTkFNRV9JU19TSFVURE9XTixcbiAgICAnZHluYW1pYyBjbGllbnRzIG5vdCBhbGxvd2VkJywgU0MuRFlOQU1JQ19DTElFTlRTX05PVF9BTExPV0VELFxuICAgICdpbnZhbGlkIHZpcnR1YWwgcm91dGVyIGFkZHJlc3MnLCBTQy5JTlZBTElEX1ZJUlRVQUxfQUREUkVTUyxcbiAgICAnZm9yYmlkZGVuJywgU0MuQ0xJRU5UX0FDTF9ERU5JRUQsXG4gICAgJ21lc3NhZ2UgdnBuIG5vdCBhbGxvd2VkJywgU0MuTUVTU0FHRV9WUE5fTk9UX0FMTE9XRUQsXG4gICAgJ3B1Ymxpc2ggYWNsIGRlbmllZCcsIFNDLlBVQkxJU0hfQUNMX0RFTklFRCxcbiAgICAncmVwbGljYXRpb24gaXMgc3RhbmRieScsIFNDLlJFUExJQ0FUSU9OX0lTX1NUQU5EQlksXG4gICAgJ3NlbGVjdG9yIGRvZXMgbm90IG1hdGNoJywgU0MuU0VMRUNUT1JfRE9FU19OT1RfTUFUQ0gsXG4gICAgJ3N1YnNjcmlwdGlvbiBhY2wgZGVuaWVkJywgU0MuU1VCU0NSSVBUSU9OX0FDTF9ERU5JRUQsXG4gICAgJ3N1YnNjcmlwdGlvbiBkb2VzIG5vdCBtYXRjaCcsIFNDLlNVQlNDUklQVElPTl9ET0VTX05PVF9NQVRDSFxuICApLFxuICA0MDQsIG1ha2VNYXAoXG4gICAgJycsIFNDLkxPR0lOX0ZBSUxVUkVcbiAgKSxcbiAgNTAzLCBtYWtlTWFwKFxuICAgICdsb3cgcHJpb3JpdHkgbXNnIGNvbmdlc3Rpb24nLCBTQy5MT1dfUFJJT1JJVFlfTVNHX0NPTkdFU1RJT04sXG4gICAgJ21lc3NhZ2UgdnBuIHVuYXZhaWxhYmxlJywgU0MuTUVTU0FHRV9WUE5fVU5BVkFJTEFCTEUsXG4gICAgJ3JlcGxpY2F0aW9uIGlzIHN0YW5kYnknLCBTQy5SRVBMSUNBVElPTl9JU19TVEFOREJZLFxuICAgICdzZXJ2aWNlIHVuYXZhaWxhYmxlJywgU0MuR01fVU5BVkFJTEFCTEUsXG4gICAgJ3Nwb29sIG92ZXIgcXVvdGEnLCBTQy5TUE9PTF9PVkVSX1FVT1RBLFxuICAgICdzdWJzY3JpYmVyIGRlbGV0ZSBpbiBwcm9ncmVzcycsIFNDLkNMSUVOVF9ERUxFVEVfSU5fUFJPR1JFU1MsXG4gICAgJ3RvbyBtYW55IGNsaWVudHMnLCBTQy5UT09fTUFOWV9DTElFTlRTLFxuICAgICd0b28gbWFueSBjb25uZWN0aW9ucyBmb3IgdnBuJywgU0MuVE9PX01BTllfQ0xJRU5UUyxcbiAgICAnbWF4IG1lc3NhZ2UgdXNhZ2UgZXhjZWVkZWQnLCBTQy5NQVhfTUVTU0FHRV9VU0FHRV9FWENFRURFRFxuICApLFxuICA1MDcsIG1ha2VNYXAoXG4gICAgJ2FkIG5vdCByZWFkeScsIFNDLkdNX05PVF9SRUFEWVxuICApXG4pO1xuXG5jb25zdCBBRF9NQVBQSU5HID0gbWFrZU1hcChcbiAgJ1BBUkVOVCcsIFJPT1RfTUFQUElORyxcbiAgNDAwLCBtYWtlTWFwKFxuICAgICdhbHJlYWR5IGJvdW5kJywgU0MuQUxSRUFEWV9CT1VORCxcbiAgICAnZW5kcG9pbnQgYWxyZWFkeSBleGlzdHMnLCBTQy5FTkRQT0lOVF9BTFJFQURZX0VYSVNUUyxcbiAgICAnZW5kcG9pbnQgcHJvcGVydHkgbWlzbWF0Y2gnLCBTQy5FTkRQT0lOVF9QUk9QRVJUWV9NSVNNQVRDSCxcbiAgICAnaW52YWxpZCBkdXJhYmxlIHRvcGljIGVuZHBvaW50IG5hbWUnLCBTQy5JTlZBTElEX0RURV9OQU1FLFxuICAgICdpbnZhbGlkIHNlbGVjdG9yJywgU0MuSU5WQUxJRF9TRUxFQ1RPUixcbiAgICAnaW52YWxpZCB0b3BpYyBuYW1lJywgU0MuSU5WQUxJRF9UT1BJQ19OQU1FX0ZPUl9UT1BJQ19FTkRQT0lOVCxcbiAgICAncXVldWUgbm90IGZvdW5kJywgU0MuUVVFVUVfTk9UX0ZPVU5ELFxuICAgICdxdW90YSBvdXQgb2YgcmFuZ2UnLCBTQy5RVU9UQV9PVVRfT0ZfUkFOR0UsXG4gICAgJ3Vua25vd24gZmxvdyBuYW1lJywgU0MuVU5LTk9XTl9GTE9XX05BTUUsXG4gICAgJ3Vuc3Vic2NyaWJlIG5vdCBhbGxvd2VkJywgU0MuVU5TVUJTQ1JJQkVfTk9UX0FMTE9XRURfQ0xJRU5UU19CT1VORFxuICApLFxuICA0MDMsIG1ha2VNYXAoXG4gICAgJ3Blcm1pc3Npb24gbm90IGFsbG93ZWQnLCBTQy5QRVJNSVNTSU9OX05PVF9BTExPV0VEXG4gICksXG4gIDUwMywgbWFrZU1hcChcbiAgICAnZHVyYWJsZSB0b3BpYyBlbmRwb2ludCBzaHV0ZG93bicsIFNDLlRPUElDX0VORFBPSU5UX1NIVVRET1dOLFxuICAgICdlbmRwb2ludCBzaHV0ZG93bicsIFNDLlRPUElDX0VORFBPSU5UX1NIVVRET1dOLFxuICAgICdtYXggY2xpZW50cyBleGNlZWRlZCBmb3IgZHVyYWJsZSB0b3BpYyBlbmRwb2ludCcsIFNDLk1BWF9DTElFTlRTX0ZPUl9URSxcbiAgICAnbWF4IGNsaWVudHMgZXhjZWVkZWQgZm9yIHF1ZXVlJywgU0MuTUFYX0NMSUVOVFNfRk9SX1FVRVVFLFxuICAgICdubyBtb3JlIG5vbi1kdXJhYmxlIHF1ZXVlIG9yIHRvcGljIGVuZHBvaW50JywgU0MuTk9fTU9SRV9OT05fRFVSQUJMRV9RVUVVRV9PUl9UT1BJQ19FTkRQT0lOVCxcbiAgICAnbm8gc3Vic2NyaXB0aW9uIG1hdGNoJywgU0MuTk9fU1VCU0NSSVBUSU9OX01BVENILFxuICAgICdxdWV1ZSBzaHV0ZG93bicsIFNDLlFVRVVFX1NIVVRET1dOLFxuICAgICd0ZSBzaHV0ZG93bicsIFNDLlRPUElDX0VORFBPSU5UX1NIVVRET1dOLFxuICAgICd1bmtub3duIGR1cmFibGUgdG9waWMgZW5kcG9pbnQnLCBTQy5VTktOT1dOX1RPUElDX0VORFBPSU5UX05BTUUsXG4gICAgJ3Vua25vd24gcXVldWUnLCBTQy5VTktOT1dOX1FVRVVFX05BTUVcbiAgKVxuKTtcblxuZnVuY3Rpb24gZ2V0U3ViY29kZU1hcHBpbmdJbm5lcihyb290LCByZXNwRXJyb3JDb2RlLCByZXNwU3RyKSB7XG4gIGlmIChyZXNwRXJyb3JDb2RlID09PSAyMDApIHtcbiAgICAvLyBzdWNjZXNzIHJlc3BvbnNlLCBlcnJvciBzdWJjb2RlIGlzIDAgLSAgdHJhbnNwb3J0IHNlc3Npb24gdXNlIDAgYXMgT0tcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBjb2RlTWFwID0gcm9vdFtyZXNwRXJyb3JDb2RlXSB8fCB7fTtcbiAgY29uc3Qgc2VhcmNoS2V5ID0gKHJlc3BTdHIgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGZvdW5kS2V5ID0gT2JqZWN0LmtleXMoY29kZU1hcClcbiAgICAuZmluZChtYXBLZXkgPT4gbWFwS2V5ID09PSBzZWFyY2hLZXkgfHwgc2VhcmNoS2V5LmluZGV4T2YobWFwS2V5KSA+PSAwKTtcblxuICBpZiAoZm91bmRLZXkpIHtcbiAgICByZXR1cm4gY29kZU1hcFtmb3VuZEtleV07XG4gIH1cblxuICBpZiAoY29kZU1hcFsnJ10pIHtcbiAgICByZXR1cm4gY29kZU1hcFsnJ107XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cbiAgLy8gRG9uJ3QgYWNjZXNzIHN0cmluZyBrZXlzIHZpYSBkb3QgcHJvcGVydGllc1xuICBpZiAocm9vdFsnUEFSRU5UJ10pIHtcbiAgICByZXR1cm4gZ2V0U3ViY29kZU1hcHBpbmdJbm5lcihyb290WydQQVJFTlQnXSwgcmVzcEVycm9yQ29kZSwgcmVzcFN0cik7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBkb3Qtbm90YXRpb24gKi9cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRTdWJjb2RlTWFwcGluZyhyb290LCByZXNwRXJyb3JDb2RlLCByZXNwU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldFN1YmNvZGVNYXBwaW5nSW5uZXIocm9vdCwgcmVzcEVycm9yQ29kZSwgcmVzcFN0cik7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBTQy5VTktOT1dOX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmV0dXJuIHtFcnJvclN1YmNvZGV9IGJhc2VkIG9uIHJlc3BvbnNlIGNvZGUgYW5kIHJlc3BvbnNlIHN0cmluZ1xuICogZnJvbSB0aGUgcm91dGVyLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVzcEVycm9yQ29kZSBUaGUgcmVzcG9uc2UgY29kZSAoYW4gSFRUUC1saWtlIGludGVnZXIpIHRvIHVzZSBpbiB0aGUgbG9va3VwLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzcFN0ciBUaGUgcmVzcG9uc2Ugc3RyaW5nIHRvIHVzZSBpbiB0aGUgbG9va3VwLlxuICAgKiBAcmV0dXJucyB7c29sYWNlLkVycm9yU3ViY29kZX0gVGhlIHN1YmNvZGUgZm91bmQsIG9yIEVycm9yU3ViY29kZS5VTktOT1dOX0VSUk9SIGlmIG5vdCBmb3VuZC5cbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RXJyb3JTdWJjb2RlKHJlc3BFcnJvckNvZGUsIHJlc3BTdHIpIHtcbiAgICByZXR1cm4gZ2V0U3ViY29kZU1hcHBpbmcoUk9PVF9NQVBQSU5HLCByZXNwRXJyb3JDb2RlLCByZXNwU3RyKTtcbiAgfSxcblxuICBnZXRBREVycm9yU3ViY29kZShyZXNwRXJyb3JDb2RlLCByZXNwU3RyKSB7XG4gICAgcmV0dXJuIGdldFN1YmNvZGVNYXBwaW5nKEFEX01BUFBJTkcsIHJlc3BFcnJvckNvZGUsIHJlc3BTdHIpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVycm9yL2xpYi9lcnJvci1yZXNwb25zZS1zdWJjb2RlLW1hcHBlci5qcyIsImNvbnN0IHsgU29sYWNlRXJyb3IgfSA9IHJlcXVpcmUoJy4vc29sYWNlLWVycm9yJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+XG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBjYWxsaW5nIGFuIEFQSSB0aGF0IGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZC5cbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtzb2xhY2UuU29sYWNlRXJyb3J9XG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgU29sYWNlRXJyb3Ige1xuICAvKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE5vdEltcGxlbWVudGVkRXJyb3IuXG4gICAqIEBwYXJhbSB7YW55fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICAgKiBAbWVtYmVyb2YgTm90SW1wbGVtZW50ZWRFcnJvclxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKCdOb3RJbXBsZW1lbnRlZEVycm9yJywgbWVzc2FnZSB8fCAnJywgTm90SW1wbGVtZW50ZWRFcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvci5cbiAgICogQG5hbWUgc29sYWNlLk5vdEltcGxlbWVudGVkRXJyb3IjbmFtZVxuICAgKiBAdHlwZSB7Q29uc3RhbnR9XG4gICAqIEBkZXNjcmlwdGlvbiAnTm90SW1wbGVtZW50ZWRFcnJvcidcbiAgICovXG59XG5cbm1vZHVsZS5leHBvcnRzLk5vdEltcGxlbWVudGVkRXJyb3IgPSBOb3RJbXBsZW1lbnRlZEVycm9yO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lcnJvci9saWIvbm90LWltcGxlbWVudGVkLWVycm9yLmpzIiwiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCcuL2Vycm9yLXN1YmNvZGVzJyk7XG5jb25zdCB7IE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCcuL29wZXJhdGlvbi1lcnJvcicpO1xuY29uc3QgeyBSZXF1ZXN0RXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuL3JlcXVlc3QtZXZlbnQtY29kZXMnKTtcblxuXG5jb25zdCBTVUJDT0RFX0ZST01fRUMgPSB7XG4gIFtSZXF1ZXN0RXZlbnRDb2RlLlJFUVVFU1RfQUJPUlRFRF06IEVycm9yU3ViY29kZS5TRVNTSU9OX05PVF9DT05ORUNURUQsXG4gIFtSZXF1ZXN0RXZlbnRDb2RlLlJFUVVFU1RfVElNRU9VVF06IEVycm9yU3ViY29kZS5USU1FT1VULFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiA8Yj5UaGlzIGNsYXNzIGlzIG5vdCBleHBvc2VkIGZvciBjb25zdHJ1Y3Rpb24gYnkgQVBJIHVzZXJzLjwvYj5cbiAqXG4gKiBSZXByZXNlbnRzIGEgcmVxdWVzdCBmYWlsdXJlIGV2ZW50OyByZXF1ZXN0IGZhaWx1cmUgZXZlbnRzIGFyZSBwYXNzZWQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gKiBldmVudCBoYW5kbGluZyBjYWxsYmFjayBwcm92aWRlZCB3aGVuIHNlbmRpbmcgdGhlIHJlcXVlc3Qge0BsaW5rIHNvbGFjZS5TZXNzaW9uI3NlbmRSZXF1ZXN0fVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQGV4dGVuZHMgc29sYWNlLk9wZXJhdGlvbkVycm9yXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIFJlcXVlc3RFcnJvciBleHRlbmRzIE9wZXJhdGlvbkVycm9yIHtcbiAgLypcbiAgICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy48L2I+IEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdCB3aWxsXG4gICAqIGJlIHBhc3NlZCB0byB0aGUgYXBwbGljYXRpb24gaW4gY2FsbHMgdG8gdGhlIGFwcGxpY2F0aW9uJ3NcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uLnJlcXVlc3RGYWlsZWRDYWxsYmFja30sIHByb3ZpZGVkIHdoZW4gaW52b2tpbmdcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uLnNlbmRSZXFldXN0fS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIEluZm9ybWF0aW9uIHN0cmluZ1xuICAgKiBAcGFyYW0ge3NvbGFjZS5SZXF1ZXN0RXZlbnRDb2RlfSBldmVudENvZGUgVGhlIGV2ZW50IGNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb3JyZWxhdGlvbktleV0gQW55IGFzc29jaWF0ZWQgY29ycmVsYXRpb24ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcmVhc29uXSBBbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXZlbnRDb2RlLCBjb3JyZWxhdGlvbktleSwgcmVhc29uKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgU1VCQ09ERV9GUk9NX0VDW2V2ZW50Q29kZV0sIHJlYXNvbik7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgICAqIEBuYW1lIHNvbGFjZS5SZXF1ZXN0RXJyb3IjbmFtZVxuICAgICAqIEB0eXBlIHtDb25zdGFudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gJ1JlcXVlc3RFcnJvcidcbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdEVycm9yJztcbiAgICB0aGlzLl9ldmVudENvZGUgPSBldmVudENvZGU7XG4gICAgdGhpcy5fY29ycmVsYXRpb25LZXkgPSBjb3JyZWxhdGlvbktleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c29sYWNlLlNlc3Npb25FdmVudENvZGV9XG4gICAqIEBuYW1lIHNvbGFjZS5SZXF1ZXN0RXJyb3IjcmVxdWVzdEV2ZW50Q29kZVxuICAgKiBAZGVzY3JpcHRpb24gQSBjb2RlIHRoYXQgcHJvdmlkZXMgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IgZXZlbnQuXG4gICAqL1xuICBnZXQgcmVxdWVzdEV2ZW50Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdEV2ZW50Q29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHNvbGFjZS5SZXF1ZXN0RXJyb3Ijc3ViY29kZX1cbiAgICogQHR5cGUgez9zb2xhY2UuRXJyb3JTdWJjb2RlfVxuICAgKiBAZGVzY3JpcHRpb24gaWYgYXBwbGljYWJsZSwgYW4gZXJyb3Igc3ViY29kZS4gRGVmaW5lZCBpbiB7QGxpbmsgRXJyb3JTdWJjb2RlfVxuICAgKi9cbiAgZ2V0IGVycm9yU3ViY29kZSgpIHtcbiAgICByZXR1cm4gc3VwZXIuc3ViY29kZTtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICBjb25zdCBzdXBlck9iaiA9IHN1cGVyW3V0aWwuaW5zcGVjdC5jdXN0b21dID8gc3VwZXJbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSA6IHt9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1cGVyT2JqLCB7XG4gICAgICAncmVxdWVzdEV2ZW50Q29kZSc6IFJlcXVlc3RFdmVudENvZGUuZGVzY3JpYmUodGhpcy5yZXF1ZXN0RXZlbnRDb2RlKSxcbiAgICAgICdpbmZvU3RyJzogICAgICAgICAgdGhpcy5pbmZvU3RyLFxuICAgICAgJ2NvcnJlbGF0aW9uS2V5JzogICB0aGlzLmNvcnJlbGF0aW9uS2V5LFxuICAgIH0pO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzLlJlcXVlc3RFcnJvciA9IFJlcXVlc3RFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVycm9yL2xpYi9yZXF1ZXN0LWVycm9yLmpzIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuICBjb25zdCBhc3RyID0gU3RyaW5nKGEpO1xuICBjb25zdCBic3RyID0gU3RyaW5nKGIpO1xuICByZXR1cm4gYXN0ciA+IGJzdHIgPyAxIDogKGFzdHIgPCBic3RyID8gLTEgOiAwKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JkZXJlZChhcnJheSwgZWxlbWVudCwgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFsuLi5hcnJheV07XG4gIHJldHVybiB0aGlzLmlucGxhY2VJbnNlcnRPcmRlcmVkKHJlc3VsdCwgZWxlbWVudCwgY29tcGFyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGlucGxhY2VJbnNlcnRPcmRlcmVkKGFycmF5LCBlbGVtZW50LCBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3IpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IG1pbiA9IDA7XG4gIGxldCBtYXggPSBhcnJheS5sZW5ndGg7XG4gIC8vIE9wdGltaXplIGZvciBlbXB0eSBhcnJheVxuICBpZiAobWF4ID4gMCkge1xuICAgIC8vIE9wdGltaXplIGZvciBhcHBlbmRcbiAgICBpZiAoY29tcGFyYXRvcihlbGVtZW50LCBhcnJheVttYXggLSAxXSkgPiAwKSB7XG4gICAgICBpbmRleCA9IG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmluYXJ5IHNlYXJjaFxuICAgICAgaW5kZXggPSAobWluICsgbWF4KSA+PiAxOyAvLyBtYXRoLmZsb29yKChtaW4gKyBtYXgpIC8gMilcbiAgICAgIHdoaWxlIChtYXggPiBtaW4pIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoZWxlbWVudCwgYXJyYXlbaW5kZXhdKSA8IDApIHtcbiAgICAgICAgICBtYXggPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW4gPSBpbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAobWluICsgbWF4KSA+PiAxOyAvLyBtYXRoLmZsb29yKChtaW4gKyBtYXgpIC8gMilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXJyYXkuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFycmF5T3BlcmF0aW9uczoge1xuICAgIGRlZmF1bHRDb21wYXJhdG9yLFxuICAgIGluc2VydE9yZGVyZWQsXG4gICAgaW5wbGFjZUluc2VydE9yZGVyZWQsXG4gIH0sXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXNraXQvbGliL2FycmF5LW9wZXJhdGlvbnMuanMiLCJsZXQgYXNzZXJ0O1xuXG4vKipcbiAqIEJyb3dzZXJzIGFuZCBOb2RlIHNoYXJlIGEgY29tbW9uIGNvbnNvbGUuYXNzZXJ0IGludGVyZmFjZSwgY29uc29sZS5hc3NlcnQoYXNzZXJ0aW9uLCAuLi4pO1xuICogSW4gTm9kZSwgY29uc29sZS5hc3NlcnQgdGhyb3dzIEFzc2VydGlvbkVycm9yIGlmIGl0cyBhc3NlcnRpb24gaXMgZmFsc3kuXG4gKiBJbiBicm93c2VycywgdGhleSBwcmludCB0byB0aGUgY29uc29sZS5cbiAqIEV4dGVuZCBicm93c2VyIGJlaGF2aW91ciB0byBhbHNvIHRocm93LlxuICovXG5cbmlmIChCVUlMRF9FTlYuTU9ERV9ERUJVRykge1xuICBsZXQgaW50ZXJuYWxBc3NlcnQ7XG4gIGlmIChCVUlMRF9FTlYuVEFSR0VUX05PREUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGludGVybmFsQXNzZXJ0ID0gY29uc29sZS5hc3NlcnQ7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxBc3NlcnQgPSBmdW5jdGlvbiBicm93c2VyQXNzZXJ0KGFzc2VydGlvbiwgLi4uYXJncykge1xuICAgICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZXJyb3I6ICR7dHlwZW9mIGFzc2VydGlvbn0gJHthc3NlcnRpb259ICgke2FyZ3Muam9pbignICcpfSlgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8vIE5vdywgd3JhcCB0aGUgYXNzZXJ0IGluIGEgY2F0Y2ggYW5kIHJldGhyb3cgdG8gZ2l2ZSB1cyBhIHNpbmdsZSBwbGFjZVxuICAvLyB0byBzZXQgYXNzZXJ0IGJyZWFrcG9pbnRzLlxuICBhc3NlcnQgPSBmdW5jdGlvbiBvdXRlckFzc2VydCguLi5hcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGludGVybmFsQXNzZXJ0KC4uLmFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIChCVUlMRF9FTlYuTU9ERV9ERUJVRykgZGVidWdnZXI7XG4gICAgICB0aHJvdyAoZSk7XG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gSW4gcHJvZHVjdGlvbiBtb2RlLCBhc3NlcnRzIGFyZSBnZW5lcmFsbHkgZGlzYWJsZWQuXG4gIGFzc2VydCA9ICgpID0+IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvYXNzZXJ0LmpzIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBCaWRpTWFwIHtcbiAgY29uc3RydWN0b3IoLi4ucGFpcnMpIHtcbiAgICB0aGlzLmZvcndhcmQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZXZlcnNlID0gbmV3IE1hcCgpO1xuICAgIHBhaXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHBbMF0sIHBbMV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGtleSA9PiB2YWx1ZSBhbmQgdmFsdWUgPT4ga2V5IHJlbGF0aW9uc2hpcHMgZm9yIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBNZXRob2QgbmFtZSBpcyAjc2V0LCBub3QgI3B1dCwgZm9yIGFsaWdubWVudCB3aXRoIEVTIG1hcCBtZXRob2QgbmFtZXMuXG4gICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgZm9yIHRoZSBmb3J3YXJkIG1hcHBpbmcgKHZhbHVlIGluIHRoZSByZXZlcnNlIG1hcHBpbmcpXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIGZvciB0aGUgZm9yd2FyZCBtYXBwaW5nIChrZXkgaW4gdGhlIHJldmVyc2UgbWFwcGluZylcbiAgICovXG4gIHNldFZhbHVlcyhrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5mb3J3YXJkLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnJldmVyc2Uuc2V0KHZhbHVlLCBrZXkpO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuQmlkaU1hcCA9IEJpZGlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvYmlkaS1tYXAuanMiLCJmdW5jdGlvbiBlbnVtTmFtZShpbnN0YW5jZSwga2V5cywgdmFsdWUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGtleXMuZmlsdGVyKGsgPT4gaW5zdGFuY2Vba10gPT09IHZhbHVlKTtcbiAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID8gbWF0Y2hlc1swXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGVudW1WYWx1ZXMoaW5zdGFuY2UsIGtleXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChrZXlzLm1hcChrID0+IGluc3RhbmNlW2tdKSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGZvciBhbGwgZW51bWVyYXRlZCB0eXBlcy4gUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgc3VjaCBhc1xuICogY29sbGVjdGlvbnMgb2Yga2V5cyBhbmQgdmFsdWVzLCByZXZlcnNlIG1hcHBpbmcsIGFuZCByZWFkYWJsZSBkZXNjcmlwdGlvbnMuIEFsc29cbiAqIHN1cHBvcnRzIG92ZXJyaWRpbmcgdGhlIGNhbm9uaWNhbCBrZXktdmFsdWUgbWFwcGluZyB0byBtYWludGFpbiByZWFkYWJpbGl0eSBpblxuICogbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBFbnVtIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBFbnVtIHdpdGggdGhlIGdpdmVuIGtleS12YWx1ZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIFRoZSBrZXktdmFsdWUgbWFwcGluZyB0byB1c2UuIFRoaXMgbWFwcGluZyBpcyBzZXQgYXMgdGhlIGluaXRpYWxcbiAgICogY2Fub25pY2FsIGtleS12YWx1ZSBtYXBwaW5nLiBUbyBvdmVycmlkZSwgdXNlIHtAbGluayBzb2xhY2UuRW51bSNfc2V0Q2Fub25pY2FsfS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIF9jYW5vbmljYWw6IHtcbiAgICAgICAgdmFsdWU6ICAgICAgICBudWxsLFxuICAgICAgICBlbnVtZXJhYmxlOiAgIGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogICAgIHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5fc2V0Q2Fub25pY2FsKHZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjYW5vbmljYWwga2V5IHZhbHVlIG1hcHBpbmcgZm9yIHRoZSBlbnVtZXJhdGlvbi4gVXNpbmcgdGhpcyBtZXRob2QsXG4gICAqIHlvdSBhZGQgYWRkaXRpb25hbCBzZXRzIG9mIGtleXMgdGhhdCBtYXAgdG8gdGhlIHNhbWUgdmFsdWVzLCBhbmQgc3BlY2lmeSB0aGF0XG4gICAqIHRoZXNlIG5ldyBrZXlzIHRha2UgcHJlY2VkZW5jZSBmb3IgcmV2ZXJzZSBtYXBwaW5nLiBBbnkgb2xkZXIgc2V0IG9mIGtleXMgaXMgbWFkZVxuICAgKiBub24tY2Fub25pY2FsIGFuZCBub24tZW51bWVyYWJsZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYyA9IG5ldyBFbnVtKHsgSEVMTE86ICd3b3JsZCcgfSk7XG4gICAqIGMuX3NldENhbm9uaWNhbCh7IE1BRDogJ3dvcmxkJyB9KTtcbiAgICogYy5uYW1lT2YoJ3dvcmxkJykgPT09ICdNQUQnOyAvLyB0cnVlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgVGhlIG5ldyBrZXktdmFsdWUgbWFwcGluZyB0byBhZGQgdG8gdGhlIG9iamVjdCBhbmQgc2V0IGFzIGNhbm9uaWNhbC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW5hbCBXaGV0aGVyIHRoaXMgZW51bWVyYXRpb24gc2hvdWxkIGFjY2VwdCBmdXJ0aGVyIHJlY29uZmlndXJhdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRDYW5vbmljYWwodmFsdWVzLCBmaW5hbCA9IGZhbHNlKSB7XG4gICAgdGhpcy5fY2Fub25pY2FsID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIGtleSk7XG4gICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAgIGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiAgICAgdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6ICAgICAgICBkZXNjcmlwdG9yLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiAgIHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiAgICAgIWZpbmFsLFxuICAgICAgICBjb25maWd1cmFibGU6ICFmaW5hbCxcbiAgICAgICAgdmFsdWU6ICAgICAgICB2YWx1ZXNba2V5XSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnaXZlbiBlbnVtZXJhdGlvbiB2YWx1ZS4gVGhpc1xuICAgKiByZXN1bHQgaXMgaW5mb3JtYXRpb25hbCBhbmQgbWF5IHZhcnkgYmV0d2VlbiBTREsgdmVyc2lvbnMuXG4gICAqXG4gICAqIEN1cnJlbnRseSwgaXQgZWl0aGVyIHJldHVybnMgdGhlIHZhbHVlIHByb3ZpZGVkIChpZiB0aGUgYXNzb2NpYXRlZCBrZXkgaXNcbiAgICogdGhlIHNhbWUpLCBvciBhIHN0cmluZyBvZiB0aGUgZm9ybSBga2V5ICh2YWx1ZSlgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zb2xlLmxvZyhuZXcgRW51bSh7IEFOU1dFUjogNDIgfSkuZGVzY3JpYmUoNDIpKTsgLy8gQU5TV0VSICg0MilcbiAgICogY29uc29sZS5sb2cobmV3IEVudW0oeyBFQ0hPOiAnRUNITycgfSkpLmRlc2NyaWJlKCdFQ0hPJyk7IC8vIEVDSE9cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVudW1WYWx1ZSBUaGUgdmFsdWUgb24gd2hpY2ggdG8gcGVyZm9ybSByZXZlcnNlIG1hcHBpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbm9uZVZhbHVlPScnXSBUaGUgc3RyaW5nIHRvIHJldHVybiBpZiB0aGUgZW51bWVyYXRpb24gdmFsdWUgaXNcbiAgICogICAgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdW5rbm93blZhbHVlPSc8dW5rbm93bj4nXSBUaGUgc3RyaW5nIHRvIHJldHVybiBpZiB0aGUgZW51bWVyYXRpb25cbiAgICogICAgdmFsdWUgd2FzIG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGNhbm9uaWNhbCBrZXlzLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSByZXZlcnNlIG1hcHBpbmcgZm9yIHRoZSB2YWx1ZS5cbiAgICovXG4gIGRlc2NyaWJlKGVudW1WYWx1ZSwgbm9uZVZhbHVlID0gJzxub25lPicsIHVua25vd25WYWx1ZSA9ICc8dW5rbm93bj4nKSB7XG4gICAgaWYgKGVudW1WYWx1ZSA9PT0gbnVsbCB8fCBlbnVtVmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5vbmVWYWx1ZTtcbiAgICBjb25zdCBuYW1lID0gZW51bU5hbWUodGhpcy5fY2Fub25pY2FsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jYW5vbmljYWwgfHwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWUpXG4gICAgICAgICAgICAgICAgIHx8IHVua25vd25WYWx1ZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gZW51bVZhbHVlID8gbmFtZSA6IGAke25hbWV9ICgke2VudW1WYWx1ZX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYW5vbmljYWwgbmFtZSBpbiB0aGlzIGVudW1lcmF0aW9uIGZvciB0aGUgZ2l2ZW4gdmFsdWUuIFRoaXMgZnVuY3Rpb24gaXNcbiAgICogZGVzaWduZWQgdG8gZmFjaWxpdGF0ZSByZWZsZWN0aW9uLCB3aGVyZWFzIGZvciBkaXNwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBlbnVtVmFsdWUgVGhlIHZhbHVlIGZvciB3aGljaCB0byBnZXQgdGhlIGVudW1lcmF0aW9uIGtleS5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5hbWUgZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICovXG4gIG5hbWVPZihlbnVtVmFsdWUpIHtcbiAgICByZXR1cm4gZW51bU5hbWUodGhpcy5fY2Fub25pY2FsLCBPYmplY3Qua2V5cyh0aGlzLl9jYW5vbmljYWwgfHwge30pLCBlbnVtVmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGNhbm9uaWNhbCBuYW1lcy9rZXlzIGluIHRoaXMgZW51bWVyYXRpb24uXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IEFsbCBjYW5vbmljYWwgbmFtZXMgaW4gdGhpcyBlbnVtZXJhdGlvbi5cbiAgICovXG4gIGdldCBuYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY2Fub25pY2FsIHx8IHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCB2YWx1ZXMgYXNzaWduZWQgdG8gY2Fub25pY2FsIGtleXMgaW4gdGhpcyBlbnVtZXJhdGlvbi5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIHtBcnJheX0gQWxsIHZhbHVlcyBkZWZpbmVkIGZvciBlbnVtZXJhdGlvbiBrZXlzLlxuICAgKi9cbiAgZ2V0IHZhbHVlcygpIHtcbiAgICByZXR1cm4gZW51bVZhbHVlcyh0aGlzLl9jYW5vbmljYWwsIE9iamVjdC5rZXlzKHRoaXMuX2Nhbm9uaWNhbCB8fCB7fSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcHJvcGVydHkgcmV0dXJuaW5nIHRydWUgdG8gZmFjaWxpYXRlIGR1Y2stdHlwaW5nIHdpdGgge3NvbGFjZS5FbnVtfSBvYmplY3RzLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgVGhpcyBpcyBhbiBlbnVtZXJhdGlvbi5cbiAgICovXG4gIGdldCBpc0VudW0oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgYW4gZW51ZXJhdGVkIHZhbHVlIGdpdmVuIHRoZVxuICAgKiBlbnVtZXJhdGlvbiBhbmQgdGhlIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgVGhlIGVudW1lcmF0aW9uIGluc3RhbmNlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBrZXkgbmFtZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGtleSBuYW1lIGZvciB0aGUgZ2l2ZW4gZW51bWVyYXRpb24gdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgbmFtZU9mKGluc3RhbmNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS5uYW1lT2YodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWVzIGRlZmluZWQgb24gdGhpcyBlbnVtZXJhdGlvbiBmb3IgdGhlIGdpdmVuIGtleXMuIFRvIGdldCB0aGUgZW51bWVyYXRpb24ga2V5cyxcbiAgICogdXNlIHtAbGluayBPYmplY3Qja2V5c30uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZSBUaGUgZW51bWVyYXRpb24gb24gd2hpY2ggdG8gcmV0dXJuIHZhbHVlcy5cbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgdmFsdWVzIGRlZmluZWQgb24gdGhlIGdpdmVuIGVudW1lcmF0aW9uLlxuICAgKiovXG4gIHN0YXRpYyB2YWx1ZXMoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UudmFsdWVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQWx0ZXJuYXRlIGNvbnN0cnVjdGlvbiBtZXRob2QgZm9yIGVudW1lcmF0aW9ucy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIEluaXRpYWwga2V5LXZhbHVlIG1hcHBpbmdcbiAgICogQHJldHVybnMge3NvbGFjZS5FbnVtfSBBIG5ldyBlbnVtZXJhdGlvbiBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5ldyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IEVudW0odmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgcHJpdmF0ZSBlbnVtZXJhdGlvbiBpbiB3aGljaCB0aGUgdmFsdWVzIGFyZSBlcXVhbCB0byB0aGUga2V5cy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBzdHJpbmdzIEtleSBuYW1lcy4gVGhlIHZhbHVlcyB3aWxsIGJlIGVxdWFsIHRvIHRoZSBrZXlzLlxuICAgKiBAcmV0dXJucyB7c29sYWNlLkVudW19IEFuIGVudW1lcmF0aW9uIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBzdHJpbmdzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgb2ZTdHJpbmdzKHN0cmluZ3MpIHtcbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICBzdHJpbmdzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIG1hcFtzXSA9IHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIEVudW0ubmV3KG1hcCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiBpbiB3aGljaCBlYWNoIGtleSBpcyBhc3NpZ25lZCBhIGRpc3RpbmN0IGludGVnZXIgdmFsdWUuXG4gICAqIEVudW1zIGNyZWF0ZWQgdGhpcyB3YXkgYXJlIHN1YmplY3QgdG8gcmVudW1iZXJpbmcgaWYga2V5cyBhcmUgcmVvcmRlcmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGtleXMgS2V5IG5hbWVzLiBUaGUgdmFsdWVzIHdpbGwgYmUgc2VxdWVudGlhbCBmcm9tIHplcm8uXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuRW51bX0gQW4gZW51bWVyYXRpb24gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG9mTnVtYmVycyhrZXlzKSB7XG4gICAgY29uc3QgbWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICBtYXBba2V5XSA9IGluZGV4O1xuICAgIH0pO1xuICAgIHJldHVybiBFbnVtLm5ldyhtYXApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkVudW0gPSBFbnVtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXNraXQvbGliL2VudW0uanMiLCIvKipcbiAqIEFuIG9iamVjdCBtYW5hZ2luZyBhIHRyYXZlcnNhbCBvZiBhbiBBcnJheS1saWtlIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBkZXJlZiBSZXR1cm5zIHRoZSB2YWx1ZSB0aGUgaXRlcmF0b3IgaXNcbiAqICAgICAgcmVmZXJlbmNpbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBpbmNyIEluY3JlbWVudHMgdGhlIGl0ZXJhdG9yJ3MgcmVmZXJlbmNlIGluIHRoZVxuICogICAgICBpdGVyYXRvcidzIGRhdGEgc2V0LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZW5kIFRlc3RzIHdoZXRoZXIgdGhlIGl0ZXJhdG9yIGlzIGF0IHRoZSBlbmQgb2ZcbiAqICAgICAgdGhlIGRhdGEgc2V0LiAgVGhpcyBNVVNUIHJldHVybiBmYWxzZSB3aGVuIGNhbGxpbmcgZGVyZWYoKSBvclxuICogICAgICBpbmNyKCkuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBJdGVyYXRvciB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaXRlcmF0b3IgdG8gZm9yd2FyZCBpdGVyYXRlIG92ZXIgYSBzcGVjaWZpYyBjb250aWd1b3VzXG4gICAqIHNlY3Rpb24gb2YgYW4gYXJyYXksIHNwZWNpZmljYWxseSBpbiB0aGUgcmFuZ2UgW3N0YXJ0LCBlbmQpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gVGhlIGZpcnN0IGl0ZW0gdGhlIGl0ZXJhdG9yIHNob3VsZFxuICAgKiAgZGVyZWZlcmVuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQ9YXJyLmxlbmd0aF0gT25lIGJleW9uZCB0aGUgbGFzdCBpdGVtIGluIHRoZSBhcnJheVxuICAgKiAgdGhhdCB0aGUgaXRlcmF0b3Igc2hvdWxkIGRlcmVmZXJlbmNlLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyciwgc3RhcnQgPSAwLCBlbmQgPSBhcnIubGVuZ3RoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGFycmF5IGJlaW5nIGl0ZXJhdGVkLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FyciA9IGFycjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgZW51bWVyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2luZGV4ID0gc3RhcnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGV4Y2x1c2l2ZSBlbmQgaW5kZXgsIG9yIHRoZSBsZW5ndGgsIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGF0IHRoZSBpdGVyYXRvcidzIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYXJyYXkgZWxlbWVudCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICovXG4gIGRlcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbdGhpcy5faW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIGl0ZXJhdG9yLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBpdGVyYXRvci5cbiAgICovXG4gIGluY3IoKSB7XG4gICAgcmV0dXJuICsrdGhpcy5faW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBpdGVyYXRvciBoYXMgY29tcGxldGVkIGl0cyBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBpdGVyYXRvciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpdGVyYXRpb24uXG4gICAqL1xuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ID49IHRoaXMuX2VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIHRvIGZvcndhcmQgaXRlcmF0ZSBvdmVyIGEgc3BlY2lmaWMgY29udGlndW91c1xuICAgKiBzZWN0aW9uIG9mIGFuIGFycmF5LCBzcGVjaWZpY2FsbHkgaW4gdGhlIHJhbmdlIFtzdGFydCwgZW5kKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIFRoZSBmaXJzdCBpdGVtIHRoZSBpdGVyYXRvciBzaG91bGRcbiAgICogIGRlcmVmZXJlbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kPWFyci5sZW5ndGhdIE9uZSBiZXlvbmQgdGhlIGxhc3QgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICogIHRoYXQgdGhlIGl0ZXJhdG9yIHNob3VsZCBkZXJlZmVyZW5jZS5cbiAgICogQHJldHVybnMge3NvbGFjZS5JdGVyYXRvcn0gQW4gaXRlcmF0b3IgdG8gdGhlIHNwZWNpZmllZCBzZXQgb2YgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBtYWtlSXRlcmF0b3IoYXJyLCBzdGFydCA9IDAsIGVuZCA9IGFyci5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGFyciwgc3RhcnQsIGVuZCk7XG4gIH1cblxufVxuXG4vLyBFeHBvc2UgYm90aCB0aGUgc3RhdGljIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGFuZCB0aGUgY2xhc3MuXG5tb2R1bGUuZXhwb3J0cy5JdGVyYXRvciA9IEl0ZXJhdG9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXNraXQvbGliL2l0ZXJhdG9yLmpzIiwiXG4vLyBBdm9pZCBjbG9zdXJlIGNvbXBpbGVyIG5vbnNlbnNlXG5tb2R1bGUuZXhwb3J0cy5tYWtlTWFwID0gZnVuY3Rpb24gbWFrZU1hcCguLi5rZXlWYWx1ZVBhaXJzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleVZhbHVlUGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXN1bHRba2V5VmFsdWVQYWlyc1tpXV0gPSBrZXlWYWx1ZVBhaXJzW2kgKyAxXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVza2l0L2xpYi9tYWtlLW1hcC5qcyIsImNvbnN0IE1peGluID0ge1xuICAvKipcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXQgVGhlIGNsYXNzIHRvIGF1Z21lbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhZGQgVGhlIGNsYXNzIHRvIG1peCBpbi5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGF1Z21lbnRlZCBjbGFzc1xuICAgKi9cbiAgbWl4aW4odGFyZ2V0LCBhZGQpIHtcbiAgICBjb25zdCB0YXJnZXRQcm90byA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgY29uc3QgYWRkUHJvdG8gPSBhZGQucHJvdG90eXBlO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFkZFByb3RvKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBpZiAobmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykgcmV0dXJuO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldFByb3RvLCBuYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFkZFByb3RvLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1peGluID0gTWl4aW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1lc2tpdC9saWIvbWl4aW4uanMiLCJjb25zdCB7IExhenkgfSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuXG5jb25zdCB7IGxhenlQcm9wZXJ0eSB9ID0gTGF6eTtcblxuZnVuY3Rpb24gdHJhdmVyc2VQYXRoKGNvbW1vblNvdXJjZSwga2V5U291cmNlLCBwYXRoQXJyKSB7XG4gIHJldHVybiBwYXRoQXJyLnJlZHVjZSgoc291cmNlLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc291cmNlW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCBrZXlTb3VyY2UpO1xufVxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIERlZmVycmVkIHJlc29sdXRpb24gZm9yIGltcG9ydHMuIEEgaGVhdnl3ZWlnaHQgbWV0aG9kIG9mIGJyZWFraW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAqIEVhY2ggc3BlY2lmaWVkIGtleSAoc2VlIGJlbG93KSBpcyByZXNvbHZlZCBvbmNlIGJ5IGEgZnVuY3Rpb24gdGhhdCBsYXppbHkgZXZhbHVhdGVzIGFcbiAqIHBhdGguXG4gKiA8cHJlPlxuICogY29uc3QgcmVzb2x2ZWQgPSBuZXcgUmVzb2x2ZXIoe1xuICogIGZvbzogW0Zvb0xpYiwgJ2Zvb0NvbnRhaW5lciddLCAgICAgICAgLy8gUmVzb2x2ZXMgZm9vIGZyb20gRm9vTGliLmZvb0NvbnRhaW5lci5mb28gbGF6aWx5XG4gKiAgYmFyOiBbJ2ZvbyddLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlcyBiYXIgZnJvbSBwcmV2aW91c2x5IGRlZmluZWQgZm9vIGxhemlseVxuICogICdiYXoscXV1eCc6IFtGb29MaWIsICdiYXpzQW5kUXV1eGVzJ10gLy8gYmF6ID0gRm9vTGliLmJhenNBbmRRdXV4ZXMuYmF6LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXV1eCA9IEZvb0xpYi5iYXpzQW5kUXV1eGVzLnF1dXhcbiAqIH0pO1xuICogPC9wcmU+XG4gKiBJbiBtb3N0IGNhc2VzIHRoaXMgaXMgZXF1aXZhbGVudCB0byB1c2luZyBGb29MaWIuZm9vQ29udGFpbmVyLmZvbywgZXQgY2V0ZXJhLCBkaXJlY3RseS5cbiAqIFByZWZlciB0aGF0IGFwcHJvYWNoIHVubGVzcyB0aGUgZGVwZW5kZW5jaWVzIGFyZSBkZWVwbHkgaGllcmFyY2hpY2FsLiBQcmVmZXIgdGhlIFJlc29sdmVyXG4gKiB3aGVuIG9uZS10aW1lIGV2YWx1YXRpb24gYW5kIGFsaWFzaW5nIGEgcGF0aCBtYWtlcyB0aGUgY29kZSBtb3JlIERSWSBhbmQgcmVhZGFibGUuXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBSZXNvbHZlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHNvdXJjZSkge1xuICAgIC8vIEZvciBldmVyeSBrZXkuLi5cbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKChjb21wb3VuZEtleSkgPT4ge1xuICAgICAgLy8gU3BsaXQgb3V0IGtleSBuYW1lcyBpZiBtdWx0aXBsZSB3ZXJlIHByb3ZpZGVkXG4gICAgICBjb21wb3VuZEtleS5zcGxpdCgnLCcpLm1hcChrID0+IGsudHJpbSgpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgLy8gQnVpbGQgYSBwYXRoIGFycmF5LiBUaGUga2V5IG5hbWUgaXMgdGhlIGltcGxpY2l0IGxhc3QgZWxlbWVudC5cbiAgICAgICAgY29uc3QgcmF3UGF0aCA9IG9wdGlvbnNbY29tcG91bmRLZXldO1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIHJhd1BhdGggPT09ICdzdHJpbmcnID8gcmF3UGF0aC5zcGxpdCgnLicpIDogcmF3UGF0aDtcbiAgICAgICAgY29uc3QgcGF0aEFyciA9IChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IFtwYXRoXSkuY29uY2F0KGtleSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGRlZmVyIGZvciB0aGlzIGtleS5cbiAgICAgICAgbGF6eVByb3BlcnR5KHRoaXMsIGtleSwgKCkgPT4gdHJhdmVyc2VQYXRoKHNvdXJjZSwgdGhpcywgcGF0aEFycikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZShvcHRpb25zLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFJlc29sdmVyKG9wdGlvbnMsIHNvdXJjZSk7XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5SZXNvbHZlciA9IFJlc29sdmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXNraXQvbGliL3Jlc29sdmVyLmpzIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cblxuZnVuY3Rpb24gaXNTdXBlcnNldChzZXQsIHN1YnNldCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShzdWJzZXQpLmV2ZXJ5KGVsZW0gPT4gc2V0LmhhcyhlbGVtKSk7XG59XG5cbmZ1bmN0aW9uIGlucGxhY2VVbmlvbihzZXRBLCBzZXRCKSB7XG4gIHNldEIuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgIHNldEEuYWRkKGVsZW0pO1xuICB9KTtcbiAgcmV0dXJuIHNldEE7XG59XG5cbmZ1bmN0aW9uIHVuaW9uKHNldEEsIHNldEIpIHtcbiAgcmV0dXJuIGlucGxhY2VVbmlvbihuZXcgU2V0KHNldEEpLCBzZXRCKTtcbn1cblxuZnVuY3Rpb24gaW5wbGFjZUludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gIHNldEEuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgIGlmICghc2V0Qi5oYXMoZWxlbSkpIHtcbiAgICAgIHNldEEuZGVsZXRlKGVsZW0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzZXRBO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKHNldEEpLmZpbHRlcihlbGVtID0+IHNldEIuaGFzKGVsZW0pKSk7XG59XG5cbmZ1bmN0aW9uIGlucGxhY2VEaWZmZXJlbmNlKHNldEEsIHNldEIpIHtcbiAgc2V0Qi5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgc2V0QS5kZWxldGUoZWxlbSk7XG4gIH0pO1xuICByZXR1cm4gc2V0QTtcbn1cblxuZnVuY3Rpb24gZGlmZmVyZW5jZShzZXRBLCBzZXRCKSB7XG4gIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20oc2V0QSkuZmlsdGVyKGVsZW0gPT4gIXNldEIuaGFzKGVsZW0pKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTZXRPcGVyYXRpb25zOiB7XG4gICAgaW5wbGFjZURpZmZlcmVuY2UsXG4gICAgaW5wbGFjZUludGVyc2VjdGlvbixcbiAgICBpbnBsYWNlVW5pb24sXG4gICAgaXNTdXBlcnNldCxcbiAgICBkaWZmZXJlbmNlLFxuICAgIGludGVyc2VjdGlvbixcbiAgICB1bmlvbixcbiAgfSxcbn1cbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWVza2l0L2xpYi9zZXQtb3BlcmF0aW9ucy5qcyIsImNvbnN0IE5vZGVFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCB7IEFycmF5VXRpbHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBMT0dfV0FSTiB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuXG5jb25zdCB7IGZsYXR0ZW4sIGluY2x1ZGVzIH0gPSBBcnJheVV0aWxzO1xuY29uc3QgTk9ERV9ERUZBVUxUX0VWRU5UUyA9IFsnZXJyb3InLCAnbmV3TGlzdGVuZXInLCAncmVtb3ZlTGlzdGVuZXInXTtcbmNvbnN0IEJMQUNLTElTVF9ESVJFQ1QgPSBbJ25ld0xpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ107XG5cbmZ1bmN0aW9uIGJ1aWxkRmlsdGVyKGVtaXRzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBrID0+IGluY2x1ZGVzKE5PREVfREVGQVVMVF9FVkVOVFMsIGspIHx8IGVtaXRzKGspO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW1pdHMpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgZW1pdFNldCA9IG5ldyBTZXQoZmxhdHRlbihlbWl0cykpO1xuICBOT0RFX0RFRkFVTFRfRVZFTlRTLmZvckVhY2goZWwgPT4gZW1pdFNldC5hZGQoZWwpKTtcbiAgY29uc3QgZW1pdEFycmF5ID0gQXJyYXkuZnJvbShlbWl0U2V0KTtcbiAgcmV0dXJuIGsgPT4gaW5jbHVkZXMoZW1pdEFycmF5LCBrKTtcbn1cblxuY29uc3QgRElTQUJMRURfQUNUSU9OUyA9IHtcbiAgaWdub3JlKCkge30sXG4gIGZhaWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbWl0dGVyIGRpc2FibGVkJyk7XG4gIH0sXG59O1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIgZXh0ZW5kcyBOb2RlRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyLlxuICAgKlxuICAgKiBBbiBFdmVudEVtaXR0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgcGVyaW9kaWNhbGx5IGVtaXRzIGV2ZW50cyB0aGF0IGNhdXNlIGZ1bmN0aW9uIG9iamVjdHMsIGtub3duXG4gICAqIGFzIGxpc3RlbmVycywgdG8gYmUgY2FsbGVkLiBJdCBleHBvc2VzIGZ1bmN0aW9ucyB0byBhdHRhY2ggcGFzc2VkIGZ1bmN0aW9ucyB0byBuYW1lZCBldmVudHMuXG4gICAqXG4gICAqIFR5cGljYWxseSwgZXZlbnQgbmFtZXMgYXJlIGNhbWVsLWNhc2VkIHN0cmluZ3MsIGJ1dCBhbnkgdmFsaWQgSmF2YVNjcmlwdCBwcm9wZXJ0eSBrZXkgY2FuIGJlXG4gICAqIHVzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgZW1pdHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGlyZWN0XSBBbiBldmVudCB0aGF0IGlzIHRvIGJlIGRpcmVjdGx5IGRpc3BhdGNoZWQgd2hlbiBwb3NzaWJsZS5cbiAgICogIERpcmVjdCBkaXNwYXRjaCBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0aGF0IG1pbmltaXplcyBFdmVudEVtaXR0ZXIgb3ZlcmhlYWQuIERpcmVjdFxuICAgKiAgZGlzcGF0Y2ggc2tpcHMgdGhlIHNhZmUgZXJyb3IgaGFuZGxpbmcgcGF0aDsgdXNlIF9mb3JtYXRFcnJvckV2ZW50IGlmIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbb3B0aW9ucy5lbWl0c10gVmFsaWQgZXZlbnQgbmFtZXMuIElmIHNwZWNpZmllZCwgbGlzdGVuZXJzIGZvciBvdGhlclxuICAgKiAgZXZlbnRzIGFyZSByZWplY3RlZC4gQXJyYXkgY2FuIGJlIG5lc3RlZCwgZS5nLiBgWydmb28nLCBbJ2JhcjEnLCAnYmFyMiddXWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51bnNhZmVdIERldGVybWluZXMgd2hldGhlciBkaXNwYXRjaCBpcyBsZXNzIGV4Y2VwdGlvbi1zYWZlLlxuICAgKiAgKiBXaGVuIGBmYWxzZWAsIGlmIGFuIGV2ZW50IGxpc3RlbmVyIHRocm93cyBhbiBlcnJvciwgdGhlIGVycm9yIGlzIHRocm93biBhbGwgdGhlIHdheSBiYWNrXG4gICAqICAgIHRvIHRoZSBlbWl0dGluZyBzdGFjayBmcmFtZS4gVGhpcyBtYWtlcyBpdCB0aGUgZW1pdHRlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICogICAgaW4gbGlzdGVuZXJzLiBUaGlzIGF2b2lkcyBhIHRyeS1jYXRjaCBmcmFtZSBhbmQgbWF5IGJlIG1vcmUgcGVyZm9ybWFudC5cbiAgICogICogV2hlbiBgdHJ1ZWAsIGlmIGFuIGV2ZW50IGxpc3RlbmVyIHRocm93cyBhbiBlcnJvciwgYW5kIGFuIGBlcnJvcmAgbGlzdGVuZXIgZXhpc3RzLCB0aGVcbiAgICogICAgZXhjZXB0aW9uIGlzIGRpc3BhdGNoZWQgdG8gdGhhdCBsaXN0ZW5lciB3cmFwcGVkIGluIGFuIHtAbGluayBzb2xhY2UuT3BlcmF0aW9uRXJyb3J9LFxuICAgKiAgICBgc3ViY29kZT17QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5DQUxMQkFDS19FUlJPUn1gLiBUaGUgb3JpZ2luYXRpbmcgZXZlbnQgYW5kIHRoZSBlcnJvclxuICAgKiAgICB0aHJvd24gYnkgdGhlIGxpc3RlbmVyIGFyZSBhdmFpbGFibGUgb24gYGV2ZW50YCBhbmQgYGVycm9yYCBmaWVsZHMgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKiAgSW4gYWxsIGNhc2VzLCB0aHJvd2luZyBhbiBleGNlcHRpb24gaW4gYSBsaXN0ZW5lciBwcmV2ZW50cyB0aGUgZXZlbnQgYmVpbmcgcmVjZWl2ZWQgYnlcbiAgICogIGxhdGVyIGxpc3RlbmVycy5cbiAgICpcbiAgICogIFRoaXMgb3B0aW9uIGRvZXMgbm90IGFmZmVjdCBhbnkgZXZlbnQgc2VsZWN0ZWQgZm9yIGBvcHRpb25zLmRpcmVjdGAsIHdoaWNoIGFsd2F5cyB1c2VzXG4gICAqICB1bnNhZmUgZGlzcGF0Y2guXG4gICAqXG4gICAqIEBtZW1iZXJvZiBzb2xhY2VcbiAgICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgZGlyZWN0LCBlbWl0cywgdW5zYWZlLCBmb3JtYXRFdmVudE5hbWUgfSA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5mb3JtYXRFdmVudE5hbWUgPSBmb3JtYXRFdmVudE5hbWUgfHwgKG5hbWUgPT4gbmFtZSk7XG5cbiAgICAvLyBEaXJlY3QgbW9kZSBwYXRoOlxuICAgIC8vICBlbWl0IC0tPiAoZGlyZWN0IGVtaXQgfHwgYmFyZUVtaXQpLlxuICAgIGNvbnN0IGJhcmVFbWl0ID0gdGhpcy5lbWl0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faW5zdGFsbERpcmVjdEZpbHRlcihkaXJlY3QsIGJhcmVFbWl0KTtcblxuICAgIC8vIEluZGlyZWN0IG1vZGUgcGF0aDpcbiAgICAvLyAgdmVyaWZpZXIgLT4gZXJyb3IgaGFuZGxlcnMgLT4gZW1pdCAtLT4gYmFyZUVtaXRcbiAgICB0aGlzLl9pbnN0YWxsRXJyb3JIYW5kbGVycyh1bnNhZmUpO1xuICAgIHRoaXMuX2luc3RhbGxFbWl0VmVyaWZpZXIoKTtcblxuICAgIHRoaXMuX2xpc3RlbmVyVmVyaWZpY2F0aW9uRmlsdGVyID0gYnVpbGRGaWx0ZXIoZW1pdHMpO1xuICAgIHRoaXMuX2VtaXRzID0gZW1pdHM7XG4gIH1cblxuICBfaW5zdGFsbERpcmVjdEZpbHRlcihkaXJlY3QsIGJhcmVFbWl0KSB7XG4gICAgaWYgKCFkaXJlY3QpIHJldHVybjtcbiAgICAgIC8vIERpcmVjdCBtb2RlIGNsYXNzIGluc3RhbmNlIG1vZGlmaWNhdGlvbnNcblxuICAgIGlmIChpbmNsdWRlcyhCTEFDS0xJU1RfRElSRUNULCBkaXJlY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgY29uZmlndXJlIGxpc3RlbmVyIGNvbGxlY3Rpb24gZXZlbnRzIFske0JMQUNLTElTVF9ESVJFQ1Quam9pbignLCAnKX1dIGFzIGRpcmVjdGAsXG4gICAgICAgIEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlZmF1bHQgZGlyZWN0IGVtaXR0ZXIgaXMgdGhlIGJhc2UgZW1pdHRlci4gU2tpcCBhbnkgb3ZlcnJpZGVzIHdlIGluc3RhbGxlZC5cbiAgICB0aGlzLl9kZWZhdWx0RW1pdERpcmVjdCA9ICguLi5hcmdzKSA9PiBiYXJlRW1pdChkaXJlY3QsIC4uLmFyZ3MpO1xuXG4gICAgLy8gSW5pdGFsbHkgbm90IGRpcmVjdCBmb3IgMCBsaXN0ZW5lcnNcbiAgICB0aGlzLmVtaXREaXJlY3QgPSB0aGlzLl9kZWZhdWx0RW1pdERpcmVjdDtcbiAgICB0aGlzLl9kaXJlY3RFdmVudE5hbWUgPSBkaXJlY3Q7XG5cbiAgICB0aGlzLm9uID0gKGV2ZW50TmFtZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMuX3ZlcmlmeUxpc3RlbmVyRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc2V0RW1pdERpcmVjdChldmVudE5hbWUsIHRydWUsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHRoaXMuYWRkTGlzdGVuZXIgPSAoZXZlbnROYW1lLCBsaXN0ZW5lcikgPT4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHRoaXMub25jZSA9IChldmVudE5hbWUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICB0aGlzLl92ZXJpZnlMaXN0ZW5lckV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5vbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc2V0RW1pdERpcmVjdChldmVudE5hbWUsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHRoaXMucHJlcGVuZExpc3RlbmVyID0gKGV2ZW50TmFtZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHRoaXMuX3ZlcmlmeUxpc3RlbmVyRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3NldEVtaXREaXJlY3QoZXZlbnROYW1lLCB0cnVlLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB0aGlzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSAoZXZlbnROYW1lLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgdGhpcy5fdmVyaWZ5TGlzdGVuZXJFdmVudChldmVudE5hbWUpO1xuICAgICAgY29uc3QgcmV0ID0gc3VwZXIucHJlcGVuZE9uY2VMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX3NldEVtaXREaXJlY3QoZXZlbnROYW1lLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyA9IChldmVudE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgaWYgKChldmVudE5hbWUgPT09IHRoaXMuX2RpcmVjdEV2ZW50TmFtZSkgfHwgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLmVtaXREaXJlY3QgPSB0aGlzLl9kZWZhdWx0RW1pdERpcmVjdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSAoZXZlbnROYW1lLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gc3VwZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICBpZiAoKGV2ZW50TmFtZSA9PT0gdGhpcy5fZGlyZWN0RXZlbnROYW1lKSAmJiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPT09IDApKSB7XG4gICAgICAgIHRoaXMuZW1pdERpcmVjdCA9IHRoaXMuX2RlZmF1bHRFbWl0RGlyZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdGhpcy5kaXJlY3RMaXN0ZW5lckNvdW50ID0gKCkgPT4gdGhpcy5saXN0ZW5lckNvdW50KHRoaXMuX2RpcmVjdEV2ZW50TmFtZSk7XG5cbiAgICB0aGlzLnNldE9uRmlyc3REaXJlY3RMaXN0ZW5lciA9IChmaXJzdERpcmVjdCkgPT4ge1xuICAgICAgdGhpcy5fb25GaXJzdERpcmVjdExpc3RlbmVyID0gZmlyc3REaXJlY3Q7XG4gICAgfTtcbiAgfVxuXG4gIF9zZXRFbWl0RGlyZWN0KGV2ZW50TmFtZSwgb25MaXN0ZW5lciwgbGlzdGVuZXIpIHtcbiAgICBpZiAoZXZlbnROYW1lICE9PSB0aGlzLl9kaXJlY3RFdmVudE5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob25MaXN0ZW5lciAmJiAodGhpcy5kaXJlY3RMaXN0ZW5lckNvdW50KCkgPT09IDEpKSB7XG4gICAgICB0aGlzLmVtaXREaXJlY3QgPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0RGlyZWN0ID0gdGhpcy5fZGVmYXVsdEVtaXREaXJlY3Q7XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLmRpcmVjdExpc3RlbmVyQ291bnQoKSA9PT0gMSkgJiYgKHRoaXMuX29uRmlyc3REaXJlY3RMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhpcy5fb25GaXJzdERpcmVjdExpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgX3ZlcmlmeUxpc3RlbmVyRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyVmVyaWZpY2F0aW9uRmlsdGVyKSByZXR1cm47XG5cbiAgICBpZiAoZXZlbnQgPT09IHVuZGVmaW5lZCB8fCBldmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy50aHJvd0ludGVybmFsKFxuICAgICAgICAgIG5ldyBPcGVyYXRpb25FcnJvcihgRW1pdHRlciByZWplY3RzIGxpc3RlbmVyIGZvciBuby1uYW1lIGV2ZW50OiAke2V2ZW50fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVyVmVyaWZpY2F0aW9uRmlsdGVyKGV2ZW50KSkge1xuICAgICAgdGhpcy50aHJvd0ludGVybmFsKFxuICAgICAgICBuZXcgT3BlcmF0aW9uRXJyb3IoYEVtaXR0ZXIgcmVqZWN0cyBsaXN0ZW5lcnMgZm9yICR7ZXZlbnR9LCBlbWl0cyAke3RoaXMuX2VtaXRzfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpKTtcbiAgICB9XG4gIH1cblxuICBfaW5zdGFsbEVtaXRWZXJpZmllcigpIHtcbiAgICBpZiAoQlVJTERfRU5WLk1PREVfREVCVUcpIHtcbiAgICAgIC8vIERlYnVnIG1vZGU6IGFsd2F5cyBhZGQgYXNzZXJ0IGZvciBlbXB0eSBldmVudCBuYW1lXG4gICAgICBjb25zdCBlbWl0QmFzZSA9IHRoaXMuZW1pdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5lbWl0ID0gKG5hbWUsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy50aHJvd0ludGVybmFsKG5ldyBPcGVyYXRpb25FcnJvcihgRW1pdHRlciByZWplY3RzIG5vLW5hbWUgZXZlbnQ6ICR7bmFtZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdEJhc2UobmFtZSwgLi4uYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF9pbnN0YWxsRXJyb3JIYW5kbGVycyh1bnNhZmUpIHtcbiAgICBpZiAodW5zYWZlKSB7XG4gICAgICAvLyBJZiB1bnNhZmUsIHRoZXJlJ3Mgbm8gdHJ5L2NhdGNoL2VtaXQgc28gdGhyb3dJbnRlcm5hbCBqdXN0IHRocm93c1xuICAgICAgdGhpcy50aHJvd0ludGVybmFsID0gKGVycikgPT4geyB0aHJvdyBlcnI7IH07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5zdGFsbCB0cnkvY2F0Y2gvZW1pdC1hcy1ldmVudCBpZiBub3QgdW5zYWZlIG1vZGUuXG4gICAgLy8gSW50cm9kdWNlcyB0aHJvd0ludGVybmFsLCB3aGljaCBzZXRzIHRoZSBfaW50ZXJuYWxFcnJvciBmbGFnIHJlc3RvcmVcbiAgICAvLyBvcmlnbmFsIHRocm93LXRvLWVtaXR0ZXIgZnVuY3Rpb25hbGl0eSBpbiBjYXNlIG9mIGludGVybmFsIGVycm9yXG5cbiAgICBjb25zdCBlbWl0QmFzZSA9IHRoaXMuZW1pdC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50aHJvd0ludGVybmFsID0gZnVuY3Rpb24gdGhyb3dJbnRlcm5hbChlcnIpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsRXJyb3IgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG5cbiAgICB0aGlzLmVtaXQgPSAobmFtZSwgLi4uYXJncykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW1pdEJhc2UobmFtZSwgLi4uYXJncyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxFcnJvcikge1xuICAgICAgICAgIHRoaXMuX2ludGVybmFsRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhyb3cgZXg7IC8vIHJldGhyb3dcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVyciA9IHRoaXMuZm9ybWF0RXJyb3JFdmVudChleCwgbmFtZSwgLi4uYXJncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgTE9HX1dBUk4oYExpc3RlbmVyIGZvciAnJHtlcnIuaW5mby5ldmVudC5mb3JtYXR0ZWROYW1lfScgdGhyZXcgZXhjZXB0aW9uLCBkaXNwYXRjaGluZyB0byAnZXJyb3InYCk7XG4gICAgICAgICAgZW1pdEJhc2UoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoaW5uZXJFeCkge1xuICAgICAgICAgIExPR19XQVJOKFwiTGlzdGVuZXIgZm9yICdlcnJvcicgdGhyZXcgZXhjZXB0aW9uOlwiLCBpbm5lckV4LCAnXFxuT3JpZ2luYWwgZXhjZXB0aW9uOicsIGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXQgaXNEaXJlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdERpcmVjdCAmJiAodGhpcy5lbWl0RGlyZWN0ICE9PSB0aGlzLl9kZWZhdWx0RW1pdERpcmVjdCk7XG4gIH1cblxuICBmb3JtYXRFcnJvckV2ZW50KGV4LCBuYW1lLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkTmFtZSA9IHRoaXMuZm9ybWF0RXZlbnROYW1lKG5hbWUpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBPcGVyYXRpb25FcnJvcihcbiAgICAgIGBVbmhhbmRsZWQgZXJyb3IgaW4gZXZlbnQgaGFuZGxlciBmb3IgJyR7Zm9ybWF0dGVkTmFtZX0nYCxcbiAgICAgIEVycm9yU3ViY29kZS5DQUxMQkFDS19FUlJPUixcbiAgICAgIGBPbiBldmVudDogJHtbbmFtZSwgLi4uYXJnc119ICR7ZXh9YFxuICAgICksIHtcbiAgICAgIHN0YWNrOiBleC5zdGFjayxcbiAgICAgIGluZm86ICB7XG4gICAgICAgIGV2ZW50OiB7IG5hbWUsIGZvcm1hdHRlZE5hbWUsIGFyZ3MgfSxcbiAgICAgICAgZXJyb3I6IGV4LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2FibGVFbWl0dGVyKCkge1xuICAgIHRoaXMuX2RlZmF1bHRFbWl0RGlyZWN0ID0gRElTQUJMRURfQUNUSU9OUy5pZ25vcmU7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGRpcmVjdC1lbmFibGVkIGVtaXR0ZXIsIHRoaXMgd2lsbCBhbHNvIGNhdXNlIGVtaXREaXJlY3QgdG8gYmUgc2V0IHRvXG4gICAgLy8gX2RlZmF1bHRFbWl0RGlyZWN0LCB3aGljaCBpcyBub3cgRElTQUxCRURfQUNUSU9OUy5pZ25vcmUuXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmVtaXQgPSBESVNBQkxFRF9BQ1RJT05TLmlnbm9yZTtcbiAgICAvLyBGcmVlemUgbGlzdGVuZXJzIGJ5IGZpcnN0IGRpc2FibGluZyByZW1vdmUsIHRoZW4gYWRkLlxuICAgIHRoaXMuYWRkTGlzdGVuZXIoJ3JlbW92ZUxpc3RlbmVyJywgRElTQUJMRURfQUNUSU9OUy5mYWlsKTtcbiAgICB0aGlzLmFkZExpc3RlbmVyKCduZXdMaXN0ZW5lcicsIERJU0FCTEVEX0FDVElPTlMuZmFpbCk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1ldmVudHMvbGliL2V2ZW50LWVtaXR0ZXIuanMiLCIvKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFRpbWVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGltZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbmNlbCBUaGUgYWN0aW9uIHRvIHBlcmZvcm0gb24gY2FuY2VsbGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYW5jZWwpIHtcbiAgICB0aGlzLmNhbmNlbCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsID0gKCkgPT4ge307IC8vIGNoYW5nZSB0byBuby1vcFxuICAgICAgY2FuY2VsKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCBUaGUgaW50ZXJ2YWwgZm9yIHRoZSB0aW1lciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkludGVydmFsIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugb24gZXhwaXJhdGlvbi5cbiAgICogQHBhcmFtIHthbnl9IFthcmdzXSBBbnkgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG9uRXhwaXJlIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7VGltZXJ9IEEgbmV3IHRpbWVyIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBuZXdJbnRlcnZhbChpbnRlcnZhbCwgb25JbnRlcnZhbCwgLi4uYXJncykge1xuICAgIGNvbnN0IHRpbWVyUmVmID0gc2V0SW50ZXJ2YWwob25JbnRlcnZhbCwgaW50ZXJ2YWwsIC4uLmFyZ3MpO1xuICAgIHJldHVybiBuZXcgVGltZXIoKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lclJlZikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgVGhlIHRpbWVvdXQgZm9yIHRoZSB0aW1lciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkV4cGlyZSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIG9uIGV4cGlyYXRpb24uXG4gICAqIEBwYXJhbSB7YW55fSBbYXJnc10gQW55IGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBvbkV4cGlyZSBjYWxsYmFjay5cbiAgICogQHJldHVybnMge1RpbWVyfSBBIG5ldyB0aW1lciBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgbmV3VGltZW91dCh0aW1lb3V0LCBvbkV4cGlyZSwgLi4uYXJncykge1xuICAgIGNvbnN0IHRpbWVyUmVmID0gc2V0VGltZW91dChvbkV4cGlyZSwgdGltZW91dCwgLi4uYXJncyk7XG4gICAgcmV0dXJuIG5ldyBUaW1lcigoKSA9PiBjbGVhclRpbWVvdXQodGltZXJSZWYpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5UaW1lciA9IFRpbWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZXZlbnRzL2xpYi90aW1lci5qcyIsImNvbnN0IHtcbiAgRXJyb3JTdWJjb2RlLFxuICBPcGVyYXRpb25FcnJvcixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgRmFjdG9yeVByb2ZpbGUsIFNvbGNsaWVudEZhY3RvcnlQcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9zb2xjbGllbnQtZmFjdG9yeS1wcm9maWxlcycpO1xuY29uc3QgeyBQYXJhbWV0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBQcm9maWxlQmluZGluZyB9ID0gcmVxdWlyZSgnLi9wcm9maWxlLWJpbmRpbmcnKTtcbmNvbnN0IHsgU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vc29sY2xpZW50LWZhY3RvcnktcHJvcGVydGllcycpO1xuXG5jb25zdCBmYWN0b3J5U3RhdGUgPSB7XG4gIGluaXRpYWxpemVDb3VudDogMCxcbiAgaW5pdGlhbGl6ZXJzOiAgICBbXSxcbn07XG4vKipcbiAqIEBnbG9iYWxcbiAqIEBuYW1lIHNvbENsaWVudEpTXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxiPnNvbENsaWVudEpTPC9iPiBpcyBhIGZ1bGwgZnVuY3Rpb25lZCBTb2xhY2UgTWVzc2FnaW5nIEFQSSB3cml0dGVuIGVudGlyZWx5IGluIEphdmFTY3JpcHQuXG4gKiBBcHBsaWNhdGlvbnMgdXNpbmcgdGhlIDxpPnNvbENsaWVudEpTPC9pPiBBUEkgY2FuIGFjY2VzcyBhbGwgdGhlIGZlYXR1cmVzIG9mIGFcbiAqIFNvbGFjZSBNZXNzYWdlIFJvdXRlci5cbiAqXG4gKiBUaGUgQVBJIGlzIGludGVuZGVkIGZvciB1c2UgYnkgYXBwbGljYXRpb25zIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCwgdGFyZ2V0dGluZ1xuICogZWl0aGVyIDxiPk5PREU8L2I+IG9yIGEgdHJhZGl0aW9uYWwgd2ViIGJyb3dzZXIuXG4gKlxuICogQWxsIGNsYXNzZXMsIG9iamVjdHMsIG1ldGhvZHMgb2YgdGhlIEFQSSBhcmUgZW5jYXBzdWxhdGVkIGluIHRoZSB7QGxpbmsgc29sYWNlfSBuYW1lc3BhY2UuXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIGFsbCBhcHBsaWNhdGlvbnMgaXMge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5fS4gVGhpcyBmYWN0b3J5IG9iamVjdFxuICogZ2VuZXJhdGVzIHRoZSB7QGxpbmsgc29sYWNlLlNlc3Npb259IGZvciBjb25uZWN0aW5nIHRvIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gKiB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3Rvcnl9IGFsc28gZ2VuZXJhdGVzIHRoZSB7QGxpbmsgc29sYWNlLk1lc3NhZ2V9IG9iamVjdFxuICogd2hpY2ggZW5uY2Fwc3VsYXRlcyB0aGUgbWVzc2FnZXMgYW5kIHtAbGluayBzb2xhY2UuRGVzdGluYXRpb259IHRoZSBhcHBsaWNhdGlvbiB3aWxsIHVzZVxuICogdG8gc2VuZCBhbmQgcmVjZWl2ZSBkYXRhLlxuICogQHN1bW1hcnkgVGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBNZXNzYWdpbmcgQVBJIGZvciBKYXZhc2NyaXB0LlxuICovXG5cbi8qKlxuICogQSBzaW5nbGV0b24gdXNlZCBhcyB0aGUgbWFpbiBmYWN0b3J5IGZvciB0aGUgbWVzc2FnaW5nIEFQSXMuIFRoZSB2ZXJ5IGZpcnN0IG9wZXJhdGlvbiBieVxuICogYW55IGFwcGxpY2F0aW9uIG11c3QgYmUgdG8gaW5pdGlhbGl6ZSB0aGUgQVBJOlxuICogKiBAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeSNpbml0fVxuICpcbiAqIDxpPlNvbGNsaWVudEZhY3Rvcnk8L2k+IHByb3ZpZGVzIG1ldGhvZHMgdG8gY29uc3RydWN0OlxuICogKiB7QGxpbmsgc29sYWNlLlNlc3Npb259XG4gKiAqIHtAbGluayBzb2xhY2UuTWVzc2FnZX1cbiAqICoge0BsaW5rIHNvbGFjZS5EZXN0aW5hdGlvbn1cbiAqXG4gKiBBZGRpdGlvbmFsbHkgPGk+U29sY2xpZW50RmFjdG9yeTwvaT4gbWFuYWdlcyB0aGVcbiAqIGxvZ2dpbmcgbGV2ZWwgaW4gdGhlIEFQSS5cbiAqIEBuYW1lc3BhY2VcbiAqIEBwdWJsaWNcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY29uc3QgU29sY2xpZW50RmFjdG9yeSA9IHtcblxuICAvKipcbiAgICogQWRkcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBmYWN0b3J5IGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZmFjdG9yeVByb3BzLCBmYWN0b3J5U3RhdGUpfSBmdW5jIGluaXRpYWxpemVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZEluaXRpYWxpemVyKGZ1bmMpIHtcbiAgICBmYWN0b3J5U3RhdGUuaW5pdGlhbGl6ZXJzLnB1c2goZnVuYyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IG5ldyBmYWN0b3J5IG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZUZhY3RvcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmYWN0b3J5TWV0aG9kKC4uLmFyZ3MpIHtcbiAgICAgIGlmIChmYWN0b3J5U3RhdGUuaW5pdGlhbGl6ZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignU29sY2xpZW50RmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQnLCBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoLi4uYXJncyk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBnbG9iYWwgcHJvcGVydGllcy4gVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIEFQSSBjYWxsIGlzIG1hZGUuXG4gICAqXG4gICAqIE5vdGU6IEFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIHRoaXMgbWV0aG9kLCBzdWJzZXF1ZW50IGNhbGxzIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvcGVydGllc30gW2ZhY3RvcnlQcm9wc10gVGhlIGluaXRpYWxpemF0aW9uIHByb3BlcnRpZXMgZm9yXG4gICAqICB0aGUgZmFjdG9yeSwgaWYgcmVxdWlyZWQuXG4gICAqIEBwYXJhbSB7c29sYWNlLkxvZ0ltcGx9IFtmYWN0b3J5UHJvcHMubG9nZ2VyXSBBIGxvZ2dpbmcgaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtzb2xhY2UuTG9nTGV2ZWx9W2ZhY3RvcnlQcm9wcy5sb2dMZXZlbF0gVGhlIGxvZ2dpbmcgbGV2ZWwgdG8gdXNlXG4gICAqICBmb3IgZmlsdGVyaW5nIGxvZyBldmVudHMuXG4gICAqIEBwYXJhbSB7c29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlc31cbiAgICogIFtmYWN0b3J5UHJvcHMucHJvZmlsZT1zb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLnZlcnNpb243XVxuICAgKiAgICAgVGhlIGZhY3RvcnkgcHJvZmlsZS4gVGhpcyBjbGFzcyBjYW5ub3QgYmUgY3JlYXRlZCBieSBhbiBBUEkgdXNlcjsgY2hvb3NlIG9uZSBvZiB0aGUgc3RhdGljXG4gICAqICAgICBpbnN0YW5jZXMgZnJvbSB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlc30uXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gSW52YWxpZCBsb2dnZXIgaW1wbGVtZW50YXRpb25cbiAgICogQHJldHVybnMge3NvbGFjZS5Tb2xjbGllbnRGYWN0b3J5fSBGb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuICBpbml0KGZhY3RvcnlQcm9wcykge1xuICAgIGlmIChmYWN0b3J5U3RhdGUuaW5pdGlhbGl6ZUNvdW50ID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcHMgPSBuZXcgU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXMoZmFjdG9yeVByb3BzKTtcbiAgICBjb25zdCBwcm9maWxlID0gZmFjdG9yeVByb3BzICYmIGZhY3RvcnlQcm9wcy5wcm9maWxlIHx8IFNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52ZXJzaW9uNztcbiAgICBQYXJhbWV0ZXIuaXNJbnN0YW5jZU9mKCdmYWN0b3J5UHJvcHMucHJvZmlsZScsIHByb2ZpbGUsIEZhY3RvcnlQcm9maWxlKTtcbiAgICBQcm9maWxlQmluZGluZy52YWx1ZSA9IHByb2ZpbGU7XG5cbiAgICBmYWN0b3J5U3RhdGUuaW5pdGlhbGl6ZXJzLmZvckVhY2goKGluaXRpYWxpemVyKSA9PiB7XG4gICAgICBpbml0aWFsaXplci5jYWxsKHRoaXMsIHByb3BzLCBmYWN0b3J5U3RhdGUpO1xuICAgIH0pO1xuICAgICsrZmFjdG9yeVN0YXRlLmluaXRpYWxpemVDb3VudDtcblxuICAgIGlmICgoZmFjdG9yeVByb3BzICE9PSB1bmRlZmluZWQpICYmIChmYWN0b3J5UHJvcHMgIT09IG51bGwpKSB7XG4gICAgICAvLyBGYWN0b3J5IHNob3VsZCBub3QgZGVwZW5kIG9uIG90aGVyIHBhY2thZ2VzIGF0IGZpbGUgc2NvcGVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICAgICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbiAgICAgIExPR19ERUJVRygnRmFjdG9yeSBwcm9wZXJ0aWVzOlxcbicsIGZhY3RvcnlQcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgZmFjdG9yeVN0YXRlLmluaXRpYWxpemVDb3VudCA9IDA7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcn0gQ291bnQgb2YgZmFjdG9yeSBpbml0aWFsaXphdGlvbnMuXG4gICAqICAgIE5vbnplcm8gbWVhbnMgY2Fubm90IGJlIGluaXRpYWxpemVkIGFnYWluLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRJbml0aWFsaXplQ291bnQoKSB7XG4gICAgcmV0dXJuIGZhY3RvcnlTdGF0ZS5pbml0aWFsaXplQ291bnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LnByb2ZpbGVzXG4gICAqIEB0eXBlIHtzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uIFRoZSBjb2xsZWN0aW9uIG9mIHtAbGluayBzb2xhY2UuRmFjdG9yeVByb2ZpbGV9LiBTZWUgYSBkZXNjcmlwdGlvbiBvZlxuICAgKiBlYWNoIGluIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzfS5cbiAgICovXG4gIGdldCBwcm9maWxlcygpIHtcbiAgICByZXR1cm4gU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU29sY2xpZW50RmFjdG9yeSA9IFNvbGNsaWVudEZhY3Rvcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mYWN0b3J5L2xpYi9zb2xjbGllbnQtZmFjdG9yeS5qcyIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7XG4gIEVycm9yU3ViY29kZSxcbiAgTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgT3BlcmF0aW9uRXJyb3IsXG59ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWV2ZW50cycpO1xuY29uc3QgeyBGbG93T3BlcmF0aW9uIH0gPSByZXF1aXJlKCcuL2Zsb3ctb3BlcmF0aW9uJyk7XG5jb25zdCB7IExvZ0Zvcm1hdHRlciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBQcml2YXRlRmxvd0V2ZW50TmFtZSB9ID0gcmVxdWlyZSgnLi9wcml2YXRlLWZsb3ctZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgU3RhdHMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zdGF0cycpO1xuXG4vLyBVbmxlc3MgZmxvdyBpcyBkaXNwb3NlZCwgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgYWx3YXlzIGFsbG93ZWRcbmNvbnN0IEFMV0FZU19PUFMgPSBbXG4gIEZsb3dPcGVyYXRpb24uRElTUE9TRSxcbiAgRmxvd09wZXJhdGlvbi5HRVRfU1RBVFMsXG4gIEZsb3dPcGVyYXRpb24uR0VUX1BST1BFUlRJRVMsXG4gIEZsb3dPcGVyYXRpb24uUkVTRVRfU1RBVFMsXG5dO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzYyBGbG93XG4gKiAqIDxiPlRoaXMgY2xhc3MgaXMgbm90IGV4cG9zZWQgZm9yIGNvbnN0cnVjdGlvbiBieSBBUEkgdXNlcnMuPC9iPlxuICogQSBGbG93IGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3MuIEEgRmxvdyByZXByZXNlbnRzIGEgZ3VhcmFudGVlZCBtZXNzYWdlIGNvbm5lY3Rpb24gdG8gdGhlXG4gKiBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuIFRoZXJlIG1heSBiZSBtYW55IEd1YXJhbnRlZWQgTWVzc2FnZVxuICogQ29uc3VtZXJzIG9uIGEge0BsaW5rIHNvbGFjZS5TZXNzaW9ufSwgZWFjaFxuICogaW5zdGFudGlhdGVkIGFzIGEge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9LlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQGV4dGVuZHMge3NvbGFjZS5FdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBGbG93IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEZsb3cgaW5zdGFuY2UuXG4gICAqIEBjb25zdHJ1Y3RvciBGbG93XG4gICAqIEBwYXJhbSB7QVBJUHJvcGVydGllc30gZmxvd1Byb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgb2JqZWN0IGZvciB0aGlzIGZsb3cuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uSW50ZXJmYWNlRmFjdG9yeSBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgc2Vzc2lvbiBpbnRlcmZhY2UgbWV0aG9kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2VtaXR0ZXJPcHRpb25zXSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBFdmVudEVtaXR0ZXIgY29uc3RydWN0b3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmbG93UHJvcGVydGllcywgc2Vzc2lvbkludGVyZmFjZUZhY3RvcnksIGVtaXR0ZXJPcHRpb25zKSB7XG4gICAgY29uc3QgZW1pdHRlck9wdGlvbnNGdWxsID0gT2JqZWN0LmFzc2lnbih7fSwgZW1pdHRlck9wdGlvbnMpO1xuICAgIGVtaXR0ZXJPcHRpb25zRnVsbC5lbWl0cyA9IChlbWl0dGVyT3B0aW9uc0Z1bGwuZW1pdHMgfHwgW10pLmNvbmNhdChcbiAgICAgIFByaXZhdGVGbG93RXZlbnROYW1lLnZhbHVlc1xuICAgICk7XG4gICAgc3VwZXIoZW1pdHRlck9wdGlvbnNGdWxsKTtcbiAgICBjb25zdCBzZXNzaW9uSW50ZXJmYWNlID0gc2Vzc2lvbkludGVyZmFjZUZhY3RvcnkodGhpcyk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nRm9ybWF0dGVyKCguLi5hcmdzKSA9PlxuICAgICAgW2Bbc2Vzc2lvbj0ke3Nlc3Npb25JbnRlcmZhY2Uuc2Vzc2lvbklkSGV4fV1gLCBgW2Zsb3c9JHtzZWxmLmZsb3dJZERlY31dYCwgLi4uYXJnc10pO1xuICAgIHRoaXMubG9nID0gdGhpcy5sb2dnZXIud3JhcCh0aGlzLmxvZywgdGhpcyk7XG4gICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gZmxvd1Byb3BlcnRpZXM7XG4gICAgdGhpcy5fc2Vzc2lvbkludGVyZmFjZSA9IHNlc3Npb25JbnRlcmZhY2U7XG4gICAgdGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoc2Vzc2lvbkludGVyZmFjZSk7XG4gICAgdGhpcy5fcHJpdmF0ZUV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoZW1pdHRlck9wdGlvbnNGdWxsKTtcbiAgfVxuXG4gIC8vIFByaXZhdGUgZXZlbnQgZW1pdHRlciBmdW5jdGlvbnMsIGhpZGRlbiBmcm9tIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICBfZW1pdCh0eXBlLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5fcHJpdmF0ZUV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIC4uLmFyZ3MpO1xuICAgIHRoaXMuZW1pdCh0eXBlLCAuLi5hcmdzKTtcbiAgfVxuICBfb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcml2YXRlRXZlbnRFbWl0dGVyLm9uKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICBfb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX3ByaXZhdGVFdmVudEVtaXR0ZXIub25jZSh0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgX3JlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJpdmF0ZUV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBzdGF0aXN0aWNzIGZvciB0aGlzIEd1YXJhbnRlZWQgTWVzc2FnZSBDb25uZWN0aW9uLiBBbGwgcHJldmlvdXMgR3VhcmFudGVlZFxuICAgKiBNZXNzYWdlIENvbm5lY3Rpb24gc3RhdGlzdGljcyBhcmUgbG9zdFxuICAgKiB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9XG4gICAqICAqIGlmIHRoZSBNZXNzYWdlIENvbnN1bWVyIGlzIGRpc3Bvc2VkLiBzdWJjb2RlID0ge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059XG4gICAqL1xuICBjbGVhclN0YXRzKCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfVFJBQ0UoJ0NsZWFyaW5nIHN0YXRzJyk7XG4gICAgdGhpcy5fb3BlcmF0aW9uQ2hlY2soRmxvd09wZXJhdGlvbi5SRVNFVF9TVEFUUyk7XG4gICAgdGhpcy5fc3RhdHMucmVzZXRTdGF0cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIEd1YXJhbnRlZWQgTWVzc2FnaW5nIGNvbm5lY3Rpb24uXG4gICAqIFRoZSBNZXNzZ2UgQ29uc3VtZXIgbWF5IGltbWVkaWF0ZWx5IGJlZ2luIGVtaXR0aW5nIGV2ZW50cy4gVGhlIGFwcGxpY2F0aW9uIGlzIGV4cGVjdGVkIHRvXG4gICAqIGFkZCBsaXN0ZW5lcnMgZm9yIGV2ZW50cyBvbiB0aGlzIE1lc3NhZ2UgQ29uc3VtZXIgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoJ0Nvbm5lY3RpbmcnKTtcbiAgICB0aGlzLnVzZXJEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9vcGVyYXRpb25DaGVjayhGbG93T3BlcmF0aW9uLkNPTk5FQ1QpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSBHdWFyYW50ZWVkIE1lc3NhZ2UgY29ubmVjdGlvbiwgcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyBhbmQgcmVsZWFzaW5nIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFLCBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIC8vIFRoZSBzZXNzaW9uIG1heSBkaXNwb3NlIHRoZSBwdWJsaXNoZXIgb3IgY29uc3VtZXIsIHNvIGJlIHRvbGVyYW50IG9mXG4gICAgLy8gbXVsdGlwbGUgYXR0ZW1wdHMgdG8gZG8gc28uXG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBMT0dfVFJBQ0UoJ0lnbm9yaW5nICNkaXNwb3NlIG9uIGRpc3Bvc2VkIEd1YXJhbnRlZWQgTWVzc2FnZSBjb25uZWN0aW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIExPR19UUkFDRSgnRGlzcG9zaW5nJyk7XG5cbiAgICB0aGlzLl9vcGVyYXRpb25DaGVjayhGbG93T3BlcmF0aW9uLkRJU1BPU0UpO1xuXG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG51bGw7XG4gICAgdGhpcy5fdXNlckRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIGNvbnN0IHRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VtaXQodGhpcy5nZXREaXNwb3NlZEV2ZW50KCkpO1xuICAgICAgdGhpcy5kaXNhYmxlRW1pdHRlcigpO1xuICAgICAgdGhpcy5fcHJpdmF0ZUV2ZW50RW1pdHRlci5kaXNhYmxlRW1pdHRlcigpO1xuICAgICAgTE9HX0RFQlVHKCdEaXNwb3NlZCcpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZzbS5pc1J1bm5pbmcoKSkge1xuICAgICAgLy8gR3VhcmQgdGhpcyBpbiBhIHRpbWVvdXRcbiAgICAgIGNvbnN0IHRlcm1pbmF0ZVdpdGhSdW5uaW5nRlNNID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mc20udGVybWluYXRlRnNtKCk7XG4gICAgICAgIHRlcm1pbmF0ZSgpO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gdGVybWluYXRlIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gTWF5IHRocm93IGlmIGNhbGxlZCBmcm9tIGFuIGV2ZW50IGRpc3BhdGNoXG4gICAgICAgIHRlcm1pbmF0ZVdpdGhSdW5uaW5nRlNNKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRlcm1pbmF0ZSBhc3luY2hyb25vdXNseVxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGVybWluYXRlV2l0aFJ1bm5pbmdGU00oKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgTWVzc2FnZSBDb25zdW1lciBpbiBzdWNoIGEgd2F5IHRoYXQgaXQgY2FuIGJlIHJlY29ubmVjdGVkLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb25DaGVjayhGbG93T3BlcmF0aW9uLkRJU0NPTk5FQ1QpO1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoJ0Rpc2Nvbm5lY3RpbmcnKTtcbiAgICB0aGlzLnVzZXJEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEJlZ2lucyBhIGRpc2Nvbm5lY3QgdGhhdCBpcyBub3QgdXNlci1pbml0aWF0ZWQuXG4gICAqXG4gICAqIE11c3QgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1lbWJlcm9mIEZsb3dcbiAgICovXG4gIF9kaXNjb25uZWN0U2Vzc2lvbigpIHtcbiAgICB0aGlzLl9vcGVyYXRpb25DaGVjayhGbG93T3BlcmF0aW9uLkRJU0NPTk5FQ1QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGV2ZW50IHRvIGJlIHJldHVybmVkIHdoZW4gdGhlIENvbnN1bWVyIG9yIFB1Ymxpc2hlciBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogTXVzdCBiZSBvdmVycmlkZGVuLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgRmxvd1xuICAgKi9cbiAgZ2V0RGlzcG9zZWRFdmVudCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ0Fic3RyYWN0IG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgY29weSBvZiB0aGUgcHJvcGVydGllcyBmb3IgdGhpcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHs/fSBUaGUgcHJvcGVydGllcyBvYmplY3RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQcm9wZXJ0aWVzKCkge1xuICAgIHRoaXMuX29wZXJhdGlvbkNoZWNrKEZsb3dPcGVyYXRpb24uR0VUX1BST1BFUlRJRVMpO1xuICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0aWVzLmNsb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0YXRpc3RpYyBmb3IgdGhpcyBHdWFyYW50ZWVkIE1lc3NhZ2UgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuU3RhdFR5cGV9IHN0YXRUeXBlIFRoZSBzdGF0aXN0aWMgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgdmFsdWUgZm9yIHRoZSBzdGF0aXN0aWMuXG4gICAqL1xuICBnZXRTdGF0KHN0YXRUeXBlKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uQ2hlY2soRmxvd09wZXJhdGlvbi5HRVRfU1RBVFMpO1xuICAgIHJldHVybiB0aGlzLl9zdGF0cy5nZXRTdGF0KHN0YXRUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FkTWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBoYW5kbGVkIGJ5IHRoaXMgQ29uc3VtZXIgb3IgUHVibGlzaGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVVbmNvcnJlbGF0ZWRDb250cm9sTWVzc2FnZShtZXNzYWdlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdHdWFyYW50ZWVkIE1lc3NhZ2UgQ29ubmVjdGlvbiBkb2VzIG5vdCBpbXBsZW1lbnQgYSBjb250cm9sIG1lc3NhZ2UgaGFuZGxlcicsIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RhdFR5cGV9IHN0YXRUeXBlIFRoZSBzdGF0IHRvIGluY3JlbWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBzdGF0aXN0aWMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmNTdGF0KHN0YXRUeXBlLCB2YWx1ZSkge1xuICAgIHRoaXMuX3N0YXRzLmluY1N0YXQoc3RhdFR5cGUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnQgVGhlIGV2ZW50IHRvIGJlIGhhbmRsZWQgYnkgdGhpcyBvYmplY3RzJ3MgRlNNXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm9jZXNzRlNNRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLl9mc20ucHJvY2Vzc0V2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBbiBpbnNwZWN0aW9uIG9mIHRoaXMgb2JqZWN0J3MgcHJvcGVydGllc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b21dKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnZmxvd0lkJzogdGhpcy5mbG93SWREZWMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIGRlc2NyaXB0aW9uIG9mIHRoaXMgR3VhcmFudGVlZCBNZXNzYWdlIENvbm5lY3Rpb25cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGlzIFB1Ymxpc2hlciBvciBDb25zdW1lciBjYW4gYmUgY29ubmVjdGVkLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBjYW5BY2soKSB7XG4gICAgcmV0dXJuICF0aGlzLmRpc3Bvc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIEd1YXJhbnRlZWQgTWVzc2FnZSBDb25zdW1lciB3YXMgZGlzcG9zZWQuXG4gICAqL1xuICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICB9XG5cbiAgZ2V0IGZsb3dJZERlYygpIHtcbiAgICByZXR1cm4gdGhpcy5mbG93SWQgfHwgJyhOL0EpJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgSUQgZm9yIHRoaXMgZmxvd1xuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBmbG93SWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignRmxvdyBkb2VzIG5vdCBpbXBsZW1lbnQgSUQgYWNjZXNzb3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c29sYWNlLlNlc3Npb259IFRoZSBvd25pbmcgc2Vzc2lvbiBmb3IgdGhpcyBNZXNzYWdlQ29uc3VtZXIuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb247XG4gIH1cblxuICBnZXQgdXNlckRpc2Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRpc2Nvbm5lY3RlO1xuICB9XG4gIHNldCB1c2VyRGlzY29ubmVjdGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fdXNlckRpc2Nvbm5lY3RlZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Rmxvd09wZXJhdGlvbn0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gY2hlY2tcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb3BlcmF0aW9uIGlzIGFsbG93ZWQuXG4gICAqIEB0aHJvd3Mge0BsaW5rIHNvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdGhlIG9wZXJhdGlvbiBpcyBub3QgYWxsb3dlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vcGVyYXRpb25DaGVjayhvcGVyYXRpb24pIHtcbiAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX1RSQUNFKGBDaGVja2luZyBvcGVyYXRpb24gJHtGbG93T3BlcmF0aW9uLmRlc2NyaWJlKG9wZXJhdGlvbil9YCk7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ09wZXJhdGlvbiBpcyBpbnZhbGlkIGZvciBNZXNzYWdlIENvbnN1bWVyIGluIGRpc3Bvc2VkIHN0YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04pO1xuICAgIH1cblxuICAgIC8vIEFueSByZWFkLW9ubHkgb3BlcmF0aW9uIGlzIGFsd2F5cyB2YWxpZCB1bmxlc3MgdGhlIG9iamVjdCB3YXMgZGlzcG9zZWRcbiAgICAvLyAod2hpY2ggcHVyZ2VzIHByb3BlcnRpZXMpXG4gICAgaWYgKEFMV0FZU19PUFMuc29tZSh2ID0+IHYgPT09IG9wZXJhdGlvbikpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKG9wZXJhdGlvbiA9PT0gRmxvd09wZXJhdGlvbi5ESVNDT05ORUNUICYmIHRoaXMuX2lzRGlzY29ubmVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcbiAgICAgICAgJ09wZXJhdGlvbiBpcyBpbnZhbGlkIGZvciBNZXNzYWdlIENvbnN1bWVyIGluIGRpc2Nvbm5lY3RlZCBzdGF0ZScsXG4gICAgICAgIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTlxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGRpdGlvbmFsIHZhbGlkYXRpb25cbiAgICAvLyBjb25zdCBmc21TdGF0ZSA9IHRoaXMuX2ZzbS5nZXRDdXJyZW50U3RhdGUoKS5nZXROYW1lKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9pc0Rpc2Nvbm5lY3RlZCgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ0Zsb3cjX2lzRGlzY29ubmVjdGVkIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuRmxvdyA9IEZsb3c7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mbG93L2xpYi9mbG93LmpzIiwiY29uc3QgU3RhdGVMaWIgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5jb25zdCB7IEZzbU9iamVjdCB9ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGlzIG9iamVjdCB0eXBlIHJlcHJlc2VudHMgYW4gZW50cnlQb2ludCBmb3IgYSBwYXJ0aWN1bGFyIEZTTSBzdGF0ZS5cbiAqXG4gKiBOb3RlIHRoaXMgaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBpc24ndCBwYXJ0aWN1bGFybHkgZWZmaWNpZW50LCBidXQgaXQgaXNcbiAqIHZlcnkgc2ltcGxlIGJ5IG1ha2luZyB1c2Ugb2YgdHdvIHN0YXRlIG9iamVjdHMgKG9uZSBqdXN0IGluc2lkZSBvZiBhbmRcbiAqIG9uZSBqdXN0IG91dHNpZGUgb2YpIHRoZSBzdGF0ZSB0aGUgZW50cnlQb2ludCBiZWxvbmdzIHRvLiAgSWYgbmVjZXNzYXJ5LCB3ZVxuICogY291bGQgb3B0aW1pemUgdGhpcyBpZiB3ZSB3aXNoLlxuICogQGV4dGVuZHMgRnNtT2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFbnRyeVBvaW50IGV4dGVuZHMgRnNtT2JqZWN0IHtcblxuICAvKipcbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge09iamVjdH0gc3BlYyBUaGUgb2JqZWN0IHNwZWNpZmllciB1c2VkIHRvIGltcGxlbWVudCB0aGUgbmFtZWRcbiAgKiAgICAgIHBhcmFtZXRlciBpZGlvbS5cbiAgKiBAcGFyYW0ge2ZzbS5TdGF0ZX0gc3BlYy5zdGF0ZSBUaGUgc3RhdGUgdGhhdCB0aGUgZW50cnlQb2ludCBiZWxvbmdzXG4gICogICAgICB0by5cbiAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5lbnRyeVBvaW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZW50cnlQb2ludC5cbiAgKiBAcGFyYW0ge2ZzbS5TdGF0ZUNvbnRleHR+cmVhY3Rpb25DYWxsYmFja30gc3BlYy5mdW5jIFRoZSByZWFjdGlvblxuICAqICAgICAgZnVuY3Rpb24gZm9yIHRoZSBlbnRyeVBvaW50LCB3aGljaCBkZWZpbmVzIHdoZXJlIHRvIHRyYW5zaXRpb24gdG9cbiAgKiAgICAgIGFmdGVyIHN0YXRlIGhhcyBiZWVuIGVudGVyZWQuXG4gICovXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBzdXBlcih7IG5hbWU6IHNwZWMuZW50cnlQb2ludE5hbWUgfSk7XG5cbiAgICBsZXQgaW5uZXJTdGF0ZTtcbiAgICB0aGlzLmltcGwgPSB0aGlzLmltcGwgfHwge307XG4gICAgLy8gVGhlIG91dGVyIHBvcnRpb24gb2YgdGhlIGVudHJ5UG9pbnQgYWNjZXB0cyBpbmNvbWluZyB0cmFuc2l0aW9ucyBiZWZvcmVcbiAgICAvLyBlbnRlcmluZyB0aGUgZW50cnlQb2ludCdzIHN0YXRlLiAgVGhlbiB0aGUgZW50cnlQb2ludCdzIHN0YXRlIGlzXG4gICAgLy8gZW50ZXJlZCB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIG91dGVyRW50cnlQb2ludCdzIGluaXRpYWwgdHJhbnNpdGlvbi5cbiAgICB0aGlzLmltcGwub3V0ZXJTdGF0ZSA9IG5ldyBTdGF0ZUxpYi5TdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBgJHtzcGVjLnN0YXRlLmdldE5hbWUoKX0gb3V0ZXJFbnRyeVBvaW50OiAke3NwZWMuZW50cnlQb2ludE5hbWV9YCxcbiAgICAgIHBhcmVudENvbnRleHQ6IHNwZWMuc3RhdGUuZ2V0UGFyZW50KCksXG4gICAgfSkuaW5pdGlhbCgoKSA9PiBzcGVjLnN0YXRlLnRyYW5zaXRpb25Ubyhpbm5lclN0YXRlKSk7XG5cbiAgICAvLyBUaGUgam9iIG9mIHRoZSBpbm5lciBwb3J0aW9uIG9mIHRoZSBlbnRyeVBvaW50IGlzIHRvIGZvbGxvdyBhXG4gICAgLy8gdHJhbnNpdGlvbiBhcyBzcGVjaWZpZWQgYnkgdGhlIGFwcGxpY2F0aW9uJ3MgcmVhY3Rpb24gZnVuY3Rpb24uXG4gICAgaW5uZXJTdGF0ZSA9IG5ldyBTdGF0ZUxpYi5TdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBgJHtzcGVjLnN0YXRlLmdldE5hbWUoKX0gaW5uZXJFbnRyeVBvaW50OiAke3NwZWMuZW50cnlQb2ludE5hbWV9YCxcbiAgICAgIHBhcmVudENvbnRleHQ6IHNwZWMuc3RhdGUsXG4gICAgfSkuaW5pdGlhbChzcGVjLmZ1bmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtmc20uU3RhdGV9IFRoZSBkZXN0aW5hdGlvbiBzdGF0ZSBmb3IgYSB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiAgICAgIEVudHJ5UG9pbnQuXG4gICAqL1xuICBnZXREZXN0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wbC5vdXRlclN0YXRlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkVudHJ5UG9pbnQgPSBFbnRyeVBvaW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtZnNtL2xpYi9lbnRyeS1wb2ludC5qcyIsImNvbnN0IHsgRnNtT2JqZWN0IH0gPSByZXF1aXJlKCcuL29iamVjdCcpO1xuXG5jbGFzcyBGc21FdmVudCBleHRlbmRzIEZzbU9iamVjdCB7XG59XG5cbm1vZHVsZS5leHBvcnRzLkZzbUV2ZW50ID0gRnNtRXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vbGliL2V2ZW50LmpzIiwiY29uc3QgU3RhdGVMaWIgPSByZXF1aXJlKCcuL3N0YXRlJyk7XG5jb25zdCB7IEZzbU9iamVjdCB9ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGlzIG9iamVjdCB0eXBlIHJlcHJlc2VudHMgYW4gZXhpdFBvaW50IGZvciBhIHBhcnRpY3VsYXIgRlNNIHN0YXRlLlxuICpcbiAqIE5vdGUgdGhpcyBpbml0aWFsIGltcGxlbWVudGF0aW9uIGlzbid0IHBhcnRpY3VsYXJseSBlZmZpY2llbnQsIGJ1dCBpdCBpc1xuICogdmVyeSBzaW1wbGUgYnkgbWFraW5nIHVzZSBvZiB0d28gc3RhdGUgb2JqZWN0cyAob25lIGp1c3QgaW5zaWRlIG9mIGFuZFxuICogb25lIGp1c3Qgb3V0c2lkZSBvZikgdGhlIHN0YXRlIHRoZSBleGl0UG9pbnQgYmVsb25ncyB0by4gIElmIG5lY2Vzc2FyeSwgd2VcbiAqIGNvdWxkIG9wdGltaXplIHRoaXMgaWYgd2Ugd2lzaC5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEV4aXRQb2ludCBleHRlbmRzIEZzbU9iamVjdCB7XG5cbiAgLyoqXG4gICogQGNvbnN0cnVjdG9yXG4gICogQHBhcmFtIHtPYmplY3R9IHNwZWMgVGhlIG9iamVjdCBzcGVjaWZpZXIgdXNlZCB0byBpbXBsZW1lbnQgdGhlIG5hbWVkXG4gICogICAgICBwYXJhbWV0ZXIgaWRpb20uXG4gICogQHBhcmFtIHtmc20uU3RhdGV9IHNwZWMuc3RhdGUgVGhlIHN0YXRlIHRoYXQgdGhlIGV4aXRQb2ludCBiZWxvbmdzXG4gICogICAgICB0by5cbiAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5leGl0UG9pbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBleGl0UG9pbnQuXG4gICogQHBhcmFtIHtmc20uU3RhdGVDb250ZXh0fnJlYWN0aW9uQ2FsbGJhY2t9IHNwZWMuZnVuYyBUaGUgcmVhY3Rpb25cbiAgKiAgICAgIGZ1bmN0aW9uIGZvciB0aGUgZXhpdFBvaW50LCB3aGljaCBkZWZpbmVzIHdoZXJlIHRvIHRyYW5zaXRpb24gdG9cbiAgKiAgICAgIGFmdGVyIHN0YXRlIGhhcyBiZWVuIGV4aXRlZC5cbiAgKi9cbiAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgIHN1cGVyKHsgbmFtZTogc3BlYy5leGl0UG9pbnROYW1lIH0pO1xuXG4gICAgbGV0IG91dGVyU3RhdGU7XG4gICAgLy8gVGhlIGlubmVyIHBvcnRpb24gb2YgdGhlIGV4aXRQb2ludCBhY2NlcHRzIGluY29taW5nIHRyYW5zaXRpb25zIGJlZm9yZVxuICAgIC8vIGV4aXRpbmcgdGhlIGV4aXRQb2ludCdzIHN0YXRlLiAgVGhlbiB0aGUgZXhpdFBvaW50J3Mgc3RhdGUgaXMgZXhpdGVkXG4gICAgLy8gdGhyb3VnaCB0aGUgdXNlIG9mIHRoZSBpbm5lckV4aXRQb2ludCdzIGluaXRpYWwgdHJhbnNpdGlvbi5cbiAgICB0aGlzLmltcGwuaW5uZXJTdGF0ZSA9IG5ldyBTdGF0ZUxpYi5TdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBgJHtzcGVjLnN0YXRlLmdldE5hbWUoKX0gaW5uZXJFeGl0UG9pbnQ6ICR7c3BlYy5leGl0UG9pbnROYW1lfWAsXG4gICAgICBwYXJlbnRDb250ZXh0OiBzcGVjLnN0YXRlLFxuICAgIH0pLmluaXRpYWwoKCkgPT4gc3BlYy5zdGF0ZS50cmFuc2l0aW9uVG8ob3V0ZXJTdGF0ZSkpO1xuXG4gICAgICAgIC8vIFRoZSBqb2Igb2YgdGhlIG91dGVyIHBvcnRpb24gb2YgdGhlIGV4aXRQb2ludCBpcyB0byBmb2xsb3cgYVxuICAgICAgICAvLyB0cmFuc2l0aW9uIGFzIHNwZWNpZmllZCBieSB0aGUgYXBwbGljYXRpb24ncyByZWFjdGlvbiBmdW5jdGlvbi5cbiAgICBvdXRlclN0YXRlID0gbmV3IFN0YXRlTGliLlN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIGAke3NwZWMuc3RhdGUuZ2V0TmFtZSgpfSBvdXRlckV4aXRQb2ludDogJHtzcGVjLmV4aXRQb2ludE5hbWV9YCxcbiAgICAgIHBhcmVudENvbnRleHQ6IHNwZWMuc3RhdGUuZ2V0UGFyZW50KCksXG4gICAgfSkuaW5pdGlhbChzcGVjLmZ1bmMpO1xuICB9XG5cbiAgZ2V0RGVzdFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmltcGwuaW5uZXJTdGF0ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5FeGl0UG9pbnQgPSBFeGl0UG9pbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vbGliL2V4aXQtcG9pbnQuanMiLCJjb25zdCB7IExPR19FUlJPUiB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBTdGF0ZSB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xuY29uc3QgeyBTdGF0ZUNvbnRleHQgfSA9IHJlcXVpcmUoJy4vc3RhdGUtY29udGV4dCcpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFRoaXMgaXMgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgY2FuIGhvc3Qgc3RhdGVzLiAgU3RhdGVzIHRoZW1zZWx2ZXMgY2FuIGFsc29cbiAqIGhvc3QgaW5uZXIgc3RhdGVzIGluIGEgaGllcmFyY2hpY2FsIG1hbm5lci4gIFRoaXMgY2xhc3MgYWxzbyBwcm92aWRlcyB0aGVcbiAqIGJhc2ljIGludGVyZmFjZSBmb3IgbWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHZpYSBwcm9jZXNzaW5nIG9mXG4gKiBldmVudHMsIGFuZCBxdWVyeWluZyB0aGUgY3VycmVudCBzdGF0ZSB0aHJvdWdoICdnZXRBY3RpdmVTdGF0ZScgbWV0aG9kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBTdGF0ZU1hY2hpbmUgZXh0ZW5kcyBTdGF0ZUNvbnRleHQge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjIFRoZSBvYmplY3Qgc3BlY2lmaWVyIGZvciB0aGUgRlNNLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3BlYy5uYW1lIFRoZSBuYW1lIG9mIHRoZSBGU00sIHVzZWQgaW4gZGVidWcgbG9ncy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICBpZiAoc3BlYy5wYXJlbnRDb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlIG1hY2hpbmUgY2Fubm90IGhhdmUgcGFyZW50IHN0YXRlOiAke3NwZWMucGFyZW50Q29udGV4dH1gKTtcbiAgICB9XG4gICAgc3VwZXIoc3BlYyk7XG4gICAgdGhpcy5pbXBsLmFuY2VzdG9yTGlzdCA9IFt0aGlzXTtcbiAgICB0aGlzLmltcGwuZXZlbnRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuaW1wbC5maW5hbFN0YXRlID0gbmV3IFN0YXRlKHsgbmFtZTogJ2ltcGwuZmluYWwnLCBwYXJlbnRDb250ZXh0OiB0aGlzIH0pO1xuICAgIHRoaXMuaW1wbC5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiA9IChldiwgZXhjKSA9PiB7XG4gICAgICBMT0dfRVJST1IoYFVuY2F1Z2h0IGV4Y2VwdGlvbiBpbiAke3RoaXN9IHdoaWxlIHByb2Nlc3NpbmcgJHtldn06ICR7ZXhjLnN0YWNrfWApO1xuICAgICAgcmV0dXJuIHRoaXMudGVybWluYXRlKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGFuZCBiZWdpbnMgZXhlY3V0aW9uIG9mIHF1ZXVlZCBmdW5jdGlvbnMgaWZcbiAgICogdGhleSBhcmVuJ3QgYWxyZWFkeSBleGVjdXRpbmcuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGVucXVldWUgYW5kIGV4ZWN1dGUuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQ7IGZhbHNlIGlmIGl0IHdhcyBkZWZlcnJlZC5cbiAgICovXG4gIHByb2Nlc3MoZnVuYykge1xuICAgIGNvbnN0IHsgaW1wbCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV2ZW50UXVldWUgfSA9IGltcGw7XG5cbiAgICBldmVudFF1ZXVlLnB1c2goZnVuYyk7XG4gICAgaWYgKGltcGwucHJvY2Vzc2luZ0V2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbXBsLnByb2Nlc3NpbmdFdmVudHMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGV2ZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBldnQgPSBldmVudFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBldnQuYXBwbHkodGhpcyk7XG4gICAgfVxuXG4gICAgaW1wbC5wcm9jZXNzaW5nRXZlbnRzID0gZmFsc2U7XG4gICAgdGhpcy5fb25FdmVudENvbXBsZXRpb24oKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzdGFydHMgYSBzdGF0ZSBtYWNoaW5lIGFmdGVyIGl0IGhhcyBiZWVuIGNyZWF0ZWQgYW5kIHN0YXRlc1xuICAgKiBoYXZlIGJlZW4gYXNzb2NpYXRlZCBhbmQgY29uZmlndXJlZCBhbnkgdGltZSBnZXRDdXJyZW50U3RhdGUoKSByZXR1cm5zXG4gICAqIHVuZGVmaW5lZC4gIFRoaXMgd291bGQgYmUgYWZ0ZXIgaW5pdGlhbCBjcmVhdGlvbiBhbmQgYWZ0ZXIgdGhlIHN0YXRlXG4gICAqIG1hY2hpbmUgaGFzIHRlcm1pbmF0ZWQgKGkuZS4gdHJhbnNpdGlvbmVkIHRvIHRoZSBmaW5hbCBzdGF0ZSkuXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5nZXRDdXJyZW50U3RhdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3RhcnQgJHt0aGlzLmdldE5hbWUoKX07IGl0IGlzIGFscmVhZHkgc3RhcnRlZC5gKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2Nlc3MoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vbkluaXRpYWwoKTtcblxuICAgICAgLy8gQSBzdGF0ZSBtYWNoaW5lJ3Mgb25Jbml0aWFsIG11c3Qgc3BlY2lmeSBhIGRlc3RTdGF0ZSwgdGhlIHN0YXRlXG4gICAgICAvLyBjYW5ub3QgYmUgdGhlIHN0YXRlIG1hY2hpbmUgaXRzZWxmLCBhbmQgdGhlIHN0YXRlIG11c3QgaGF2ZSB0aGVcbiAgICAgIC8vIHN0YXRlIG1hY2hpbmUgYXMgdGhlIHRvcCBhbmNlc3Rvci5cbiAgICAgIGlmIChyZXN1bHQuZGVzdFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGRlc3RpbmF0aW9uIHN0YXRlIGZyb20gaW5pdGlhbCB0cmFuc2l0aW9uIGZvciAke3RoaXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZGVzdFN0YXRlID09PSB0aGlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVzdGluYXRpb24gc3RhdGUgZm9yIGluaXRpYWwgdHJhbnNpdGlvbiBmb3IgJHt0aGlzfSBjYW5ub3QgYmUgdGhlIEZTTS5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzdEFuY2VzdG9yTGlzdCA9IHJlc3VsdC5kZXN0U3RhdGUuZ2V0QW5jZXN0b3JMaXN0KCk7XG4gICAgICBpZiAoZGVzdEFuY2VzdG9yTGlzdFswXSAhPT0gdGhpcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGVzdGluYXRpb24gc3RhdGUgKCR7cmVzdWx0LmRlc3RTdGF0ZVxuICAgICAgICAgIH0pIGZyb20gaW5pdGlhbCB0cmFuc2l0aW9uIGZvciBzdGF0ZSBtYWNoaW5lICgke3RoaXNcbiAgICAgICAgICB9KTsgZGVzdFN0YXRlIGFuY2VzdG9yICgke2Rlc3RBbmNlc3Rvckxpc3RbMF19KWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltcGwuY3VycmVudFN0YXRlID0gdGhpcy5wcm9jZXNzUmVhY3Rpb25SZXN1bHQocmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHF1ZXJ5IHdoZXRoZXIgdGhlIHN0YXRlIG1hY2hpbmUgaXMgY3VycmVudGx5IHJ1bm5pbmdcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdGUgbWFjaGluZSBpcyBwcm9jZXNzaW5nIGV2ZW50czsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmltcGwucHJvY2Vzc2luZ0V2ZW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIGludm9rZSBhbiBGU00gd2l0aCBhbiBldmVudC5cbiAgICogQHBhcmFtIHtGc21FdmVudH0gZXZ0IFRoZSBldmVudCB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIEZTTS5cbiAgICovXG4gIHByb2Nlc3NFdmVudChldnQpIHtcbiAgICBjb25zdCB7IGltcGwgfSA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3MoKCkgPT4ge1xuICAgICAgdGhpcy5sb2coYFByb2Nlc3NpbmcgZXZlbnQgJHtldnR9YCk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKGltcGwuY3VycmVudFN0YXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gaW1wbC5jdXJyZW50U3RhdGUuaGFuZGxlRXZlbnQoZXZ0KTtcbiAgICAgICAgICBpbXBsLmN1cnJlbnRTdGF0ZSA9IGltcGwuY3VycmVudFN0YXRlLnByb2Nlc3NSZWFjdGlvblJlc3VsdChyZXN1bHQsIGV2dCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgIHRoaXMubG9nKGBDYXVnaHQgZXhjZXB0aW9uICR7ZXhjfSwgY29udGludWluZ2ApO1xuICAgICAgICAgIHJlc3VsdCA9IGltcGwuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb24uY2FsbChpbXBsLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGMpO1xuICAgICAgICAgIGltcGwuY3VycmVudFN0YXRlID0gaW1wbC5jdXJyZW50U3RhdGUucHJvY2Vzc1JlYWN0aW9uUmVzdWx0KHJlc3VsdCwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKSB7XG4gICAgICAvLyBEaWRuJ3QgcnVuIGltbWVkaWF0ZWx5XG4gICAgICB0aGlzLmxvZyhgRGVmZXJyaW5nIGV2ZW50ICR7ZXZ0fWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXJtaW5hdGVzIHRoZSBGU00gYnkgdHJhbnNpdGlvbmluZyB0aGUgRlNNIHRvIGl0cyBmaW5hbCBzdGF0ZS4gQWZ0ZXJcbiAgICogdGhpcyByZXR1cm5zLCB0aGUgRlNNIG1heSBiZSBzdGFydGVkIGFnYWluIHdpdGggQGxpbmsgc3RhcnQuICBUaGlzIG1ldGhvZFxuICAgKiBzaG91bGQgb25seSBiZSBjYWxsZWQgZXh0ZXJuYWxseSBmcm9tIHRoZSBGU00sIG5vdCBmcm9tIHdpdGhpbiBhIHJlYWN0aW9uLlxuICAgKiBUbyB0ZXJtaW5hdGUgdGhlIEZTTSB3aXRoaW4gYSByZWFjdGlvbiwgdXNlIHRoZVxuICAgKiB7QGxpbmsgU3RhdGVDb250ZXh0LlJlYWN0aW9uUmVzdWx0fSByZXR1cm5lZCBieSB7QGxpbmsgU3RhdGUjdGVybWluYXRlfS5cbiAgICovXG4gIHRlcm1pbmF0ZUZzbSgpIHtcbiAgICBjb25zdCBjdXJTdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudFN0YXRlKCk7XG4gICAgaWYgKCFjdXJTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbXBsLnByb2Nlc3NpbmdFdmVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHRlcm1pbmF0ZSBzdGF0ZSBtYWNoaW5lIHdoaWxlIEZTTSBpcyBwcm9jZXNzaW5nICcgK1xuICAgICAgICAgICAgJ2V2ZW50cy4gVG8gdGVybWluYXRlIHRoZSBGU00gZnJvbSB3aXRoaW4gYSByZWFjdGlvbiwgcmV0dXJuICcgK1xuICAgICAgICAgICAgJ1N0YXRlfnRlcm1pbmF0ZSgpIGZyb20gYSByZWFjdGlvbi4nKTtcbiAgICB9XG4gICAgdGhpcy5wcm9jZXNzKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGN1clN0YXRlLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy5pbXBsLmN1cnJlbnRTdGF0ZSA9IGN1clN0YXRlLnByb2Nlc3NSZWFjdGlvblJlc3VsdChyZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIHRoZSBjb250ZXh0IG9mIGEgcmVhY3Rpb25cbiAgICogZnVuY3Rpb24sIHdoaWNoIGlzIHRvIHNheSBhIGZ1bmN0aW9uIGNhbGxlZCBieSB0aGUgRlNNIGluZnJhc3RydWN0dXJlXG4gICAqIHRoYXQgcmV0dXJucyB7QGxpbmsgU3RhdGVDb250ZXh0flJlYWN0aW9uUmVzdWx0fS4gIFRoZSBwdXJwb3NlIG9mIHRoaXNcbiAgICogZnVuY3Rpb24gaXMgdG8gc2V0IGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSBjdXJyZW50bHlcbiAgICogZXhlY3V0aW5nIGV2ZW50IGlzIGNvbXBsZXRlbHkgaGFuZGxlZCwgd2hpY2ggaW5jbHVkZXMgdGhlIGV4ZWN1dGlvbiBvZlxuICAgKiBhbnkgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIG9yIHdpbGwgYmUgcXVldWVkIGFzIGEgcmVzdWx0IG9mIHByb2Nlc3NpbmdcbiAgICogdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqXG4gICAqIFR5cGljYWwgdXNlcyBvZiB0aGlzIHdvdWxkIGJlIHRvIHNldCBhIGZ1bmN0aW9uIHRoYXQgZG9lcyBvbmUgb2Y6XG4gICAqIDEuIFRocm93cyBhbiBleGNlcHRpb24gdG8gdGhlIGNhbGxlci5cbiAgICogMi4gQ2FsbHMgYW4gYXBwbGljYXRpb24gY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHBvc3RFdmVudEFjdGlvbiBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIEZTTSBoYXMgZmluaXNoZWRcbiAgICogIHByb2Nlc3NpbmcgZXZlbnRzLiAgVGhlIGNvbnRleHQgKGkuZS4gJ3RoaXMnKSB3aWxsIGJlIHRoZSBGU00gd2hlbiBpdFxuICAgKiAgaXMgY2FsbGVkLlxuICAgKi9cbiAgc2V0UG9zdEV2ZW50QWN0aW9uKHBvc3RFdmVudEFjdGlvbikge1xuICAgIGlmICghdGhpcy5pbXBsLnByb2Nlc3NpbmdFdmVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBwb3N0IGV2ZW50IGhvb2sgdW5sZXNzIEZTTSBpcyBwcm9jZXNzaW5nIGV2ZW50cy4nKTtcbiAgICB9XG4gICAgaWYgKCFwb3N0RXZlbnRBY3Rpb24gfHwgdHlwZW9mIHBvc3RFdmVudEFjdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVEJEOiBEbyB3ZSBuZWVkIHRvIGFsbG93IGNsZWFyaW5nIG9mIHRoZSBob29rPyAgTm90IHRoYXRcbiAgICAgIC8vIEknbSBhd2FyZSBvZiBmb3IgdGhlIGtub3duIHVzZSBjYXNlcy4gIElmIHdlIHdhbnQgdG8gYWxsb3dcbiAgICAgIC8vIGl0LCBJIHByb3Bvc2UgYWRkaW5nIGEgJ2NsZWFyUG9zdEV2ZW50QWN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gYWxsb3dpbmcgbnVsbCBvciB1bmRlZmluZWQgYXMgdGhlIGFyZ3VtZW50LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwb3N0RXZlbnRBY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uOyBnb3QgKCR7cG9zdEV2ZW50QWN0aW9ufSlgKTtcbiAgICB9XG4gICAgdGhpcy5pbXBsLnBvc3RFdmVudEFjdGlvbiA9IHBvc3RFdmVudEFjdGlvbi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgRlNNIHdoZW4gaXQgZmluaXNoZXMgcHJvY2Vzc2luZyBldmVudHMuICBJZiBhXG4gICAqIHBvc3RFdmVudEFjdGlvbiBoYWQgYmVlbiBzZXQsIGl0IHdpbGwgYmUgY2FsbGVkLCB0aGVuIGNsZWFyZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25FdmVudENvbXBsZXRpb24oKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5pbXBsLnBvc3RFdmVudEFjdGlvbjtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICB0aGlzLmltcGwucG9zdEV2ZW50QWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sb2coJ1J1bm5pbmcgcG9zdCBldmVudCBhY3Rpb24nKTtcbiAgICAgIGFjdGlvbi5hcHBseSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5uZXJtb3N0IGFjdGl2ZSBzdGF0ZS5cbiAgICpcbiAgICogSWYgcmVnaW9ucyB3ZXJlIGltcGxlbWVudGVkLCB0aGlzIHdvdWxkIHJldHVybiBhbiBpdGVyYXRvciB0byBpbm5lcm1vc3RcbiAgICogYWN0aXZlIHN0YXRlcy5cbiAgICpcbiAgICogQHJldHVybnMge1N0YXRlQ29udGV4dH0gVGhlIGlubmVybW9zdCBhY3RpdmUgc3RhdGUuXG4gICAqL1xuICBnZXRDdXJyZW50U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wbC5jdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhY3RpdmUgc3RhdGUgYnkgbmFtZS4gIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBuYW1lZCBzdGF0ZSBpc1xuICAgKiBub3QgY3VycmVudGx5IGFjdGl2ZS5cbiAgICpcbiAgICogTm90ZSB0aGUgcmV0dXJuZWQgc3RhdGUgbWF5IG5vdCBiZSB0aGUgaW5uZXJtb3N0IHN0YXRlIGFzIHJldHVybmVkIGJ5XG4gICAqIHtAbGluayBTdGF0ZU1hY2hpbmUjZ2V0Q3VycmVudFN0YXRlfS4gIElmIHRoZSBpbm5lcm1vc3QgYWN0aXZlIHN0YXRlIGlzIG5vdFxuICAgKiByZXR1cm5lZCwgdGhlIHJldHVybmVkIHN0YXRlIGlzIGd1YXJhbnRlZWQgdG8gY29udGFpbiB0aGUgaW5uZXJtb3N0IGFjdGl2ZVxuICAgKiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGJlIHJldHJpZXZlZC5cbiAgICogQHJldHVybnMgez9TdGF0ZUNvbnRleHR9IFRoZSBzdGF0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSwgaWYgdGhlXG4gICAqICAgICAgc3RhdGUgaXMgYWN0aXZlOyB1bmRlZmluZWQgb3RoZXJ3aXNlLiAgTm90ZSB0aGUgcmV0dXJuZWQgc3RhdGUgbWF5IG5vdFxuICAgKiAgICAgIGJlIHRoZSBpbm5lcm1vc3QgYWN0aXZlIHN0YXRlLlxuICAgKi9cbiAgZ2V0QWN0aXZlU3RhdGUobmFtZSkge1xuICAgIGNvbnN0IGFjdGl2ZVN0YXRlcyA9IHRoaXMuaW1wbC5jdXJyZW50U3RhdGUuZ2V0QW5jZXN0b3JMaXN0KCk7XG4gICAgLy8gRG9uJ3QgaW5jbHVkZSB0aGUgZmlyc3QgYW5jZXN0b3IgaW4gdGhlIGxvb3Agc2luY2UgaXQgaXMgdGhlIHN0YXRlXG4gICAgLy8gbWFjaGluZSBpdHNlbGYsIG5vdCBhIHN0YXRlLlxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYWN0aXZlU3RhdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYWN0aXZlU3RhdGVzW2ldLmdldE5hbWUoKSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlU3RhdGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbmFtZWQgc3RhdGUgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGJlIHF1ZXJpZWQuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgbmFtZWQgc3RhdGUgaXMgYWN0aXZlLlxuICAgKi9cbiAgaXNTdGF0ZUFjdGl2ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlU3RhdGUobmFtZSkgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSByZWFjdGlvbiB0byBiZSByZWdpc3RlcmVkIGZvciB1bmhhbmRsZWQgZXZlbnRzIGluIHRoZSBGU00uICBUaGVcbiAgICogZGVmYXVsdCByZWFjdGlvbiBpcyB0byBsb2cgdGhlIHVuaGFuZGxlZCBldmVudCBhdCBkZWJ1ZyBhbmQgcmVtYWluIGluIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHdpdGggbm8gb3RoZXIgc2lkZSBlZmZlY3RzLlxuICAgKiBAcGFyYW0ge1N0YXRlQ29udGV4dC5yZWFjdGlvbkNhbGxiYWNrfSByIFRoZSByZWFjdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gYW5cbiAgICogICAgICBldmVudCBpcyB1bmhhbmRsZWQgYnkgdGhlIEZTTS5cbiAgICogQHJldHVybnMge1N0YXRlTWFjaGluZX0gVGhpcyBTdGF0ZU1hY2hpbmUgb2JqZWN0LlxuICAgKi9cbiAgdW5oYW5kbGVkRXZlbnRSZWFjdGlvbihyKSB7XG4gICAgaWYgKHR5cGVvZiByICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluICR7dGhpc306IHVuaGFuZGxlZCBldmVudCByZWFjdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb247IGdvdCAke3J9YCk7XG4gICAgfVxuICAgIHRoaXMuaW1wbC5oYW5kbGVVbmhhbmRsZWRFdmVudCA9IHIuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGFsbG93cyBhIHJlYWN0aW9uIHRvIGJlIHJlZ2lzdGVyZWQgZm9yIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2hpbGVcbiAgICogcHJvY2Vzc2luZyBldmVudHMuICBHZW5lcmFsbHksIGl0IGlzIHByZWZlcnJlZCB0byBjYXRjaCBleGNlcHRpb25zIGZyb21cbiAgICogd2l0aGluIHJlYWN0aW9uIGZ1bmN0aW9ucy4gIEhvd2V2ZXIsIHRoaXMgaXMgYSBnb29kIHdheSB0byBzYWZlZ3VhcmRcbiAgICogYWdhaW5zdCBtaXNzZWQgZXhjZXB0aW9ucy4gIFVzdWFsbHkgYW4gZXJyb3Igc2hvdWxkIGJlIGxvZ2dlZCBoZXJlLFxuICAgKiB3aGljaCBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuXG4gICAqXG4gICAqIEFsc28gbm90ZSB0aGF0IHRoaXMgaXMgb25seSBjYWxsZWQgZm9yIGVpdGhlcjpcbiAgICogLSBhbiBleGNlcHRpb24gdGhyb3duIGZyb20gYW4gZXZlbnQgcmVhY3Rpb247XG4gICAqIC0gYW4gZXhjZXB0aW9uIHRocm93biBmcm9tIGEgdHJhbnNpdGlvbiBhY3Rpb25cbiAgICogSWYgZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20gd2l0aGluIHN0YXRlIGVudHJ5LCBleGl0LCBpbml0aWFscywgZXRjLFxuICAgKiB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnZva2VkLiAgVGhlc2UgZnVuY3Rpb25zIG1heSBlbmQgdXAgZ2V0dGluZ1xuICAgKiBpbnZva2VkIGZyb20gdGhlIHRyYW5zaXRpb24gdGFrZW4gYXMgYSByZXN1bHQgb2YgdGhlIGV4Y2VwdGlvbiBpbiB0aGVcbiAgICogZmlyc3QgcGxhY2UuICBUaGUgZ2VuZXJhdGUgYW5vdGhlciBleGNlcHRpb24gd291bGQgYmUgZGlmZmljdWx0IHRvXG4gICAqIGhhbmRsZSBpbiBhIHNlbnNpYmxlIHdheS4gIFVzZXJzIG9mIHRoaXMgaW5mcmFzdHJ1Y3R1cmUgbXVzdCBhbHdheXNcbiAgICogY2F0Y2ggZXhjZXB0aW9ucyBmcm9tIHRoZXNlIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtmc20uU3RhdGVDb250ZXh0LnJlYWN0aW9uQ2FsbGJhY2t9IHIgVGhlIHJlYWN0aW9uIHRvIGJlXG4gICAqICAgICAgaW52b2tlZCB3aGVuIGFuIGV4Y2VwdGlvbiBoYXMgbm90IGJlZW4gY2F1Z2h0IGJ5IGFub3RoZXIgb2YgdGhlXG4gICAqICAgICAgRlNNJ3MgcmVhY3Rpb25DYWxsYmFja3MuICBXaGVuIHRoaXMgZnVuY3Rpb24gaXMgaW52b2tlZCwgJ3RoaXMnXG4gICAqICAgICAgd2lsbCBiZSB0aGUgRlNNJ3MgY3VycmVudCBzdGF0ZS5cbiAgICogQHJldHVybnMge1N0YXRlTWFjaGluZX0gYHRoaXNgLCBmb3IgbWV0aG9kIGNoYWluaW5nLlxuICAgKi9cbiAgdW5jYXVnaHRFeGNlcHRpb25SZWFjdGlvbihyKSB7XG4gICAgaWYgKHR5cGVvZiByICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluICR7dGhpc306IFVuY2F1Z2h0IGV4Y2VwdGlvbiByZWFjdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb247IGdvdCAke3J9YCk7XG4gICAgfVxuICAgIHRoaXMuaW1wbC5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbiA9IHI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSB0aGUgaW1wbGVtZW50YXRpb24gdG8gZ2V0IHRoZSBmaW5hbCBzdGF0ZS4gIFRoaXMgc2hvdWxkIG5ldmVyIGJlXG4gICAqIHVzZWQgYnkgYXBwbGljYXRpb25zLiAgVGhlaXIgb25seSBuZWVkIHRvIHJlZmVyZW5jZSB0aGlzIHN0YXRlIHNob3VsZCBiZVxuICAgKiBpbmRpcmVjdGx5IHZpYSB0aGUge0BsaW5rIFN0YXRlI3Rlcm1pbmF0ZX0gZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtTdGF0ZX0gVGhlIEZTTSdzIGZpbmFsIHN0YXRlLCB3aGljaCBpcyBhIGhpZGRlbiBpbXBsZW1lbnRhdGlvblxuICAgKiAgICAgIGRldGFpbCBvZiB0aGUgRlNNLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRGaW5hbFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmltcGwuZmluYWxTdGF0ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TdGF0ZU1hY2hpbmUgPSBTdGF0ZU1hY2hpbmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1mc20vbGliL3N0YXRlLW1hY2hpbmUuanMiLCJjb25zdCB7IExvZ0ltcGwgfSA9IHJlcXVpcmUoJy4vbG9nLWltcGwnKTtcblxuY29uc3QgU1RVQiA9ICgpID0+IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZ2VuZXJhdGVMb2dIZWFkZXIobGV2ZWxTdHIpIHtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGxldmVsU3RyUGFkZGluZyA9ICcgJy5yZXBlYXQoNiAtIGxldmVsU3RyLmxlbmd0aCk7XG4gIGxldCBZWSA9IFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICBsZXQgTU0gPSBTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSk7XG4gIGxldCBERCA9IFN0cmluZyhkYXRlLmdldERhdGUoKSk7XG4gIGxldCBoaCA9IFN0cmluZyhkYXRlLmdldEhvdXJzKCkpO1xuICBsZXQgbW0gPSBTdHJpbmcoZGF0ZS5nZXRNaW51dGVzKCkpO1xuICBsZXQgc3MgPSBTdHJpbmcoZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICBsZXQgbXMgPSBTdHJpbmcoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG5cbiAgWVkgPSAnMCcucmVwZWF0KDQgLSBZWS5sZW5ndGgpICsgWVk7XG4gIE1NID0gTU0ubGVuZ3RoIDwgMiA/IGAwJHtNTX1gIDogTU07XG4gIEREID0gREQubGVuZ3RoIDwgMiA/IGAwJHtERH1gIDogREQ7XG4gIGhoID0gaGgubGVuZ3RoIDwgMiA/IGAwJHtoaH1gIDogaGg7XG4gIG1tID0gbW0ubGVuZ3RoIDwgMiA/IGAwJHttbX1gIDogbW07XG4gIHNzID0gc3MubGVuZ3RoIDwgMiA/IGAwJHtzc31gIDogc3M7XG4gIG1zID0gbXMubGVuZ3RoIDwgMyA/IGAwJHttc31gIDogbXM7XG4gIG1zID0gbXMubGVuZ3RoIDwgMyA/IGAwJHttc31gIDogbXM7IC8vIHR3aWNlOiBwYWQgdG8gM1xuXG4gIHJldHVybiBbYCR7WVl9LSR7TU19LSR7RER9ICR7aGh9OiR7bW19OiR7c3N9LiR7bXN9YCwgYCR7bGV2ZWxTdHJ9JHtsZXZlbFN0clBhZGRpbmd9YF07XG59XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBsb2cgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIHRoZSBnbG9iYWwgb3Igd2luZG93IGNvbnNvbGUuXG4gKlxuICogVGhpcyBpcyB0aGUgZGVmYXVsdCBsb2cgaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgQVBJIGlmIG5vIGxvZ2dlciB3YXNcbiAqIHN1cHBsaWVkIHZpYSB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9wZXJ0aWVzfS5cbiAqXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb25zb2xlTG9nSW1wbCBleHRlbmRzIExvZ0ltcGwge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uc29sZUluXSBUaGUgY29uc29sZSB0byB3aGljaCB0byBhcHBseSB0aGlzIGltcGxlbWVudGF0aW9uLiBJZlxuICAgKiAgbm90IHNwZWNpZmllZCwgdXNlcyB0aGUgZ2xvYmFsIG9yIHdpbmRvdyBjb25zb2xlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uc29sZUluKSB7XG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgZ2l2ZW4gYXJndW1lbnRzIGF0IFRSQUNFIGxldmVsLiBUaGlzIGlzIGJvdW5kIHRvIHRoZSBmaXJzdCB2YWxpZCBtZXRob2Qgb2YgdGhlXG4gICAgICogZm9sbG93aW5nIG9uIHRoZSBnbG9iYWwgb3Igd2luZG93IGNvbnNvbGUgb2JqZWN0LCBpbiBwcmlvcml0eSBvcmRlcjpcbiAgICAgKiAgKiBjb25zb2xlLmxvZ1xuICAgICAqICAqIGNvbnNvbGUuZGVidWdcbiAgICAgKlxuICAgICAqIEBuYW1lIHNvbGFjZS5Db25zb2xlTG9nSW1wbCN0cmFjZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGxldCBfdHJhY2UgPSBTVFVCO1xuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgZ2l2ZW4gYXJndW1lbnRzIGF0IERFQlVHIGxldmVsLiBUaGlzIGlzIGJvdW5kIHRvIHRoZSBmaXJzdCB2YWxpZCBtZXRob2Qgb2YgdGhlXG4gICAgICogZm9sbG93aW5nIG9uIHRoZSBnbG9iYWwgb3Igd2luZG93IGNvbnNvbGUgb2JqZWN0LCBpbiBwcmlvcml0eSBvcmRlcjpcbiAgICAgKiAgKiBjb25zb2xlLmxvZ1xuICAgICAqICAqIGNvbnNvbGUuZGVidWdcbiAgICAgKlxuICAgICAqIEBuYW1lIHNvbGFjZS5Db25zb2xlTG9nSW1wbCNkZWJ1Z1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGxldCBfZGVidWcgPSBTVFVCO1xuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgZ2l2ZW4gYXJndW1lbnRzIGF0IElORk8gbGV2ZWwuIFRoaXMgaXMgYm91bmQgdG8gdGhlIGZpcnN0IHZhbGlkIG1ldGhvZCBvZiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgb24gdGhlIGdsb2JhbCBvciB3aW5kb3cgY29uc29sZSBvYmplY3QsIGluIHByaW9yaXR5IG9yZGVyOlxuICAgICAqICAqIGNvbnNvbGUuaW5mb1xuICAgICAqICAqIGNvbnNvbGUubG9nXG4gICAgICpcbiAgICAgKiBAbmFtZSBzb2xhY2UuQ29uc29sZUxvZ0ltcGwjaW5mb1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIHRvIGJlIGxvZ2dlZFxuICAgICAqL1xuICAgIGxldCBfaW5mbyA9IFNUVUI7XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBnaXZlbiBhcmd1bWVudHMgYXQgV0FSTiBsZXZlbC4gVGhpcyBpcyBib3VuZCB0byB0aGUgZmlyc3QgdmFsaWQgbWV0aG9kIG9mIHRoZVxuICAgICAqIGZvbGxvd2luZyBvbiB0aGUgZ2xvYmFsIG9yIHdpbmRvdyBjb25zb2xlIG9iamVjdCwgaW4gcHJpb3JpdHkgb3JkZXI6XG4gICAgICogICogY29uc29sZS53YXJuXG4gICAgICogICogY29uc29sZS5sb2dcbiAgICAgKlxuICAgICAqIEBuYW1lIHNvbGFjZS5Db25zb2xlTG9nSW1wbCN3YXJuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgbGV0IF93YXJuID0gU1RVQjtcblxuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgZ2l2ZW4gYXJndW1lbnRzIGF0IEVSUk9SIGxldmVsLiBUaGlzIGlzIGJvdW5kIHRvIHRoZSBmaXJzdCB2YWxpZCBtZXRob2Qgb2YgdGhlXG4gICAgICogZm9sbG93aW5nIG9uIHRoZSBnbG9iYWwgb3Igd2luZG93IGNvbnNvbGUgb2JqZWN0LCBpbiBwcmlvcml0eSBvcmRlcjpcbiAgICAgKiAgKiBjb25zb2xlLmluZm9cbiAgICAgKiAgKiBjb25zb2xlLmxvZ1xuICAgICAqXG4gICAgICogQG5hbWUgc29sYWNlLkNvbnNvbGVMb2dJbXBsI2Vycm9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgdG8gYmUgbG9nZ2VkXG4gICAgICovXG4gICAgbGV0IF9lcnJvciA9IFNUVUI7XG5cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBnaXZlbiBhcmd1bWVudHMgYXQgRkFUQUwgbGV2ZWwuIFRoaXMgaXMgYm91bmQgdG8gdGhlIGZpcnN0IHZhbGlkIG1ldGhvZCBvZiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgb24gdGhlIGdsb2JhbCBvciB3aW5kb3cgY29uc29sZSBvYmplY3QsIGluIHByaW9yaXR5IG9yZGVyOlxuICAgICAqICAqIGNvbnNvbGUuaW5mb1xuICAgICAqICAqIGNvbnNvbGUubG9nXG4gICAgICpcbiAgICAgKiBAbmFtZSBzb2xhY2UuQ29uc29sZUxvZ0ltcGwjZmF0YWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyB0byBiZSBsb2dnZWRcbiAgICAgKi9cbiAgICBsZXQgX2ZhdGFsID0gU1RVQjtcblxuICAgIGNvbnN0IGNvbnNvbGUgPSBjb25zb2xlSW4gfHwgKFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgLyogZXNsaW50LWVudiBub2RlICovID8gZ2xvYmFsXG4gICAgICAgIC8qIGVzbGludC1lbnYgYnJvd3NlciAqLyA6IHdpbmRvd1xuICAgICAgKS5jb25zb2xlO1xuICAgIC8qIGVzbGludC1lbnYgc2hhcmVkLW5vZGUtYnJvd3NlciAqL1xuXG4gICAgaWYgKGNvbnNvbGUgJiYgKGNvbnNvbGUubG9nIHx8IGNvbnNvbGUud2FybikpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgIC8vIFdoZXJlIGNvbnNvbGUubG9nIGlzIHN1cHBvcnRlZCwgaXQgaXMgcHJlZmVycmVkIG92ZXIgY29uc29sZS5kZWJ1Z1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vY29uc29sZVxuICAgICAgLy8gY29uc29sZSBtZXRob2RzIGluIElFOSBhcmUgb2JqZWN0LCBub3QgZnVuY3Rpb24sIHVuZm9ydHVuYXRlbHlcbiAgICAgIC8vXG4gICAgICAvLyBBbHNvLCBjb25zb2xlLnRyYWNlIG91dHB1dHMgYSBzdGFjayB0cmFjZSBvbiBzb21lIHBsYXRmb3Jtcy4gIFNvIHdlXG4gICAgICAvLyB1c2UgdGhlIHNhbWUgdW5kZXJseWluZyBsb2dnZXIgYXMgZGVidWcgZm9yIHRyYWNlIHRvIGF2b2lkIHRoZVxuICAgICAgLy8gZXhjZXNzaXZlIHZlcmJvc2l0eSB0aGF0IHdvdWxkIHJlc3VsdC5cbiAgICAgIGlmIChjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF90cmFjZSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgICAgICBfZGVidWcgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5kZWJ1ZyAmJiB0eXBlb2YgY29uc29sZS5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfdHJhY2UgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZGVidWcsIGNvbnNvbGUpO1xuICAgICAgICBfZGVidWcgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZGVidWcsIGNvbnNvbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVyZSBjb25zb2xlLmluZm8gZXhpc3RzLCBpdCBpcyBwcmVmZXJyZWQuIE90aGVyd2lzZSwgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBjb25zb2xlLmxvZy5cbiAgICAgIGlmIChjb25zb2xlLmluZm8gJiYgY29uc29sZS5pbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX2luZm8gPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuaW5mbywgY29uc29sZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaW5mbyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVyZSBjb25zb2xlLndhcm4gZXhpc3RzLCBpdCBpcyBwcmVmZXJyZWQuIE90aGVyd2lzZSwgZmFsbCBiYWNrIHRvXG4gICAgICAvLyBjb25zb2xlLmxvZy5cbiAgICAgIGlmIChjb25zb2xlLndhcm4gJiYgY29uc29sZS53YXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3dhcm4gPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUud2FybiwgY29uc29sZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FybiA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVyZSBjb25zb2xlLmVycm9yIGV4aXN0cywgaXQgaXMgcHJlZmVycmVkLiBPdGhlcndpc2UsIGZhbGwgYmFjayB0b1xuICAgICAgLy8gY29uc29sZS5sb2cuXG4gICAgICAvL1xuICAgICAgLy8gY29uc29sZS5mYXRhbCBpcyBub3QgcHJlc2VudCBpbiBhbnkga25vd24gY29uc29sZSBpbXBsZW1lbnRhdGlvbi4gVXNlXG4gICAgICAvLyBjb25zb2xlLmVycm9yIG9yIGNvbnNvbGUubG9nLlxuICAgICAgaWYgKGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9lcnJvciA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5lcnJvciwgY29uc29sZSk7XG4gICAgICAgIF9mYXRhbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5lcnJvciwgY29uc29sZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZXJyb3IgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICAgICAgX2ZhdGFsID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH0gLy8gZWxzZSBubyBjb25zb2xlIGltcGxlbWVudGF0aW9uIHdhcyBmb3VuZCwgc28gdGhlIGRlZmF1bHQgKHN0dWIpIGlzIHVzZWQgZm9yIGVhY2ggbGV2ZWwuXG5cbiAgICBzdXBlcigoLi4uYXJncykgPT4geyBfdHJhY2UoLi4uZ2VuZXJhdGVMb2dIZWFkZXIoJ1RSQUNFJyksIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICguLi5hcmdzKSA9PiB7IF9kZWJ1ZyguLi5nZW5lcmF0ZUxvZ0hlYWRlcignREVCVUcnKSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgKC4uLmFyZ3MpID0+IHsgX2luZm8oLi4uZ2VuZXJhdGVMb2dIZWFkZXIoJ0lORk8nKSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgKC4uLmFyZ3MpID0+IHsgX3dhcm4oLi4uZ2VuZXJhdGVMb2dIZWFkZXIoJ1dBUk4nKSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgKC4uLmFyZ3MpID0+IHsgX2Vycm9yKC4uLmdlbmVyYXRlTG9nSGVhZGVyKCdFUlJPUicpLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAoLi4uYXJncykgPT4geyBfZmF0YWwoLi4uZ2VuZXJhdGVMb2dIZWFkZXIoJ0ZBVEFMJyksIC4uLmFyZ3MpOyB9KTtcbiAgfVxuXG5cbn1cblxubW9kdWxlLmV4cG9ydHMuQ29uc29sZUxvZ0ltcGwgPSBDb25zb2xlTG9nSW1wbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LWxvZy9saWIvY29uc29sZS1sb2ctaW1wbC5qcyIsImNvbnN0IHsgTG9nTGV2ZWwgfSA9IHJlcXVpcmUoJy4vbG9nLWxldmVscycpO1xuXG5jb25zdCBzdGF0ZSA9IHtcbiAgaW1wbDogIG51bGwsXG4gIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxufTtcblxuY29uc3QgTG9nQmluZGluZyA9IHtcbiAgZ2V0SW1wbCgpIHtcbiAgICByZXR1cm4gc3RhdGUuaW1wbDtcbiAgfSxcblxuICBzZXRJbXBsKGltcGwpIHtcbiAgICBzdGF0ZS5pbXBsID0gaW1wbDtcbiAgfSxcblxuICBnZXRMb2dMZXZlbCgpIHtcbiAgICByZXR1cm4gc3RhdGUubGV2ZWw7XG4gIH0sXG5cbiAgc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgICBzdGF0ZS5sZXZlbCA9IGxldmVsO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuR2xvYmFsQmluZGluZyA9IExvZ0JpbmRpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1sb2cvbGliL2dsb2JhbC1iaW5kaW5nLmpzIiwiY29uc3QgeyBFbnVtLCBhc3NlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBMT0dfREVCVUcgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBBcHBsaWNhdGlvbkFja1N0YXRlID0gRW51bS5uZXcoe1xuICBVTkFDS0VEOiAgICAgICAgJ1VOQUNLRUQnLFxuICBBQ0tFRF9OT1RfU0VOVDogJ0FDS0VEX05PVF9TRU5UJyxcbiAgQUNLRURfU0VOVDogICAgICdBQ0tFRF9TRU5UJyxcbn0pO1xuXG4vLyBGb3IgdGhlIHJpbmcgYnVmZmVyIHVwZGF0ZSBpbmRleCwgd2UgaGF2ZSB0d28ga2V5LXZhbHVlIG9wdGlvbnM6XG4vLyAgTWFwKCkgLSBnZW5lcmFsbHkgZmFzdGVyIHdoZXJlIHN1cHBvcnRlZFxuLy8gIE9iamVjdCAtIHNlZW1zIHRvIGF1dG9tYXRpY2FsbHkgY29lcmNlIGtleXMgdG8gc3RyaW5nLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQgaW4gdGhpcyBjYXNlXG4vLyBCeSB1c2luZyBNYXAgYW5kIGV4cGxpY2x5IGNyZWF0aW5nIGEgLmtleSBhdHRyaWJ1dGUgYW5kIHVzaW5nIGl0IHdoZW5ldmVyIHBvc3NpYmxlLFxuLy8gd2Ugc2hvdWxkIGdldCBwZXJmb3JtYW5jZSB0aGF0IGlzIG5vIHdvcnNlIHRoYW4gT2JqZWN0LCB3aGljaCBtYXkgaGF2ZSB0byBwZXJmb3JtIHRoYXRcbi8vIGNvZXJjaW9uIG1vcmUgb2Z0ZW4uXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQXBwbGljYXRpb25BY2sge1xuICBjb25zdHJ1Y3RvcihpZCwgc3RhdGUpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuZXhpc3RzID0gdHJ1ZTtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIHRoaXMua2V5ID0gaWQudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCBBcHBsaWNhdGlvbkFja1N0YXRlLlVOQUNLRUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhpc3RzID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0KGlkLCBzdGF0ZSkge1xuICAgIHRoaXMuZXhpc3RzID0gdHJ1ZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5rZXkgPSBpZC50b1N0cmluZygpO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZSB8fCBBcHBsaWNhdGlvbkFja1N0YXRlLlVOQUNLRUQ7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmV4aXN0cyA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEFwcGxpY2F0aW9uQWNrUmluZ0J1ZmZlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFwcGxpY2F0aW9uQWNrUmluZ0J1ZmZlci4gQSBzdGFuZGFyZCByaW5nIGJ1ZmZlciBleGNlcHQgdGhhdFxuICAgKiBpdCByZXNlcnZlcyBhbiBlbXB0eSBlbnRyeSBzbyB0aGF0IGFuIG9wZXJhdGlvbiBjYW4gb2NjdXIgZHVyaW5nIGluc2VydCB0aGF0IGluY2x1ZGVzXG4gICAqIGJvdGggdGhlIG5ldyBlbGVtZW50IGFuZCBhbnkgZWxlbWVudCB0byBiZSBldmljdGVkLiBBbHNvIGluY2x1ZGVzIGFuIElELXRvLWluZGV4IG1hcFxuICAgKiB0byBzcGVlZCB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIHJpbmcuIEVmZmVjdGl2ZSBzaXplIGlzIChzaXplIC0gMSkuXG4gICAqIEBtZW1iZXJvZiBBcHBsaWNhdGlvbkFja1JpbmdCdWZmZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICBMT0dfREVCVUcoJ0NyZWF0aW5nIGFwcGxpY2F0aW9uIGFjayByaW5nIGJ1ZmZlciB3aXRoIHNpemUgJywgc2l6ZSwgJyByZXRhaW5lZCBzaXplJywgc2l6ZSAtIDEpO1xuICAgIGFzc2VydChzaXplID49IDIpOyAvLyBvbmUgYWx3YXlzIGZyZWUgZG9lc24ndCB3b3JrIHdpdGggPCAyIGVsZW1lbnRzXG4gICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5faW5zZXJ0SW5kZXggPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPD9BcHBsaWNhdGlvbkFjaz59XG4gICAgICovXG4gICAgdGhpcy5fYnVmZmVyID0gQXJyYXkoc2l6ZSkuZmlsbChudWxsKS5tYXAoKCkgPT4gbmV3IEFwcGxpY2F0aW9uQWNrKCkpO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TWFwLjxTdHJpbmcsIE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5faW5kZXggPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtMb25nfSBpZCBUaGUgaWQgb2YgdGhlIG5ldyBlbnRyeVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFwcGxpY2F0aW9uQWNrKX0gYmVmb3JlRXZpY3RDYWxsYmFjayBDYWxsIHRoaXMgYmVmb3JlIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAgICogQHJldHVybnMge2FueX0gUmV0dXJuIHZhbHVlIG9mIGJlZm9yZUV2aWN0Q2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluc2VydChpZCwgYmVmb3JlRXZpY3RDYWxsYmFjaykge1xuICAgIGFzc2VydChiZWZvcmVFdmljdENhbGxiYWNrKTtcbiAgICBhc3NlcnQoaWQpO1xuXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgY29uc3QgaW5zZXJ0SW5kZXggPSB0aGlzLl9pbnNlcnRJbmRleDtcblxuICAgIC8qXG4gICAgICogQmVjYXVzZSBvZiB0aGUgcG9zdHByb2Nlc3Npbmcgc3RlcCwgd2UgYXJlIG5vdCByZS1lbnRyYW50IHNhZmUuIEl0IGlzIGV4cGVjdGVkXG4gICAgICogdGhhdCB3ZSBhcmUgY2FsbGVkIGZyb20gVENQIC0+IFRyYW5zcG9ydCAtPiBTZXNzaW9uIC0+IGFjY2VwdE1lc3NhZ2UoKS5cbiAgICAgKiBUaGlzIGFzc2VydCB2ZXJpZmllcyB0aGF0IHRoZSBwb3N0cHJvY2VzcyBjbGVhbnVwIGhhcyBoYXBwZW5lZC5cbiAgICAgKi9cbiAgICBhc3NlcnQoIWJ1ZmZlcltpbnNlcnRJbmRleF0uZXhpc3RzLCAnSW52YXJpYW50IG5vdCBlbmZvcmNlZCAoYmVmb3JlKTogaW5zZXJ0IGluZGV4IG5vdCBlbXB0eScpO1xuXG4gICAgLy8gRmlyc3QsIGluc2VydC5cbiAgICBjb25zdCBpbnNlcnRpbmcgPSBidWZmZXJbaW5zZXJ0SW5kZXhdO1xuICAgIGluc2VydGluZy5zZXQoaWQsIEFwcGxpY2F0aW9uQWNrU3RhdGUuVU5BQ0tFRCk7XG4gICAgaW5kZXguc2V0KGluc2VydGluZy5rZXksIGluc2VydEluZGV4KTtcblxuICAgIGNvbnN0IGV2aWN0aW5nSW5kZXggPSAoaW5zZXJ0SW5kZXggKyAxKSAlIHNpemU7XG4gICAgY29uc3QgZXZpY3RpbmcgPSBidWZmZXJbZXZpY3RpbmdJbmRleF07XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYmVmb3JlRXZpY3RDYWxsYmFjayhldmljdGluZy5leGlzdHMgPyBldmljdGluZyA6IG51bGwpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBBbHdheXMgY2xlYW4gdXAgdG8ga2VlcCB0aGUgUkIgaW4gYSBjb25zaXN0ZW50IHN0YXRlLlxuICAgICAgLy8gSWYgaW5Qcm9ncmVzc0NhbGxiYWNrIHRocmV3LCB0aGlzIHJ1bnMgYmVmb3JlIHRoZSBleGNlcHRpb24gcHJvcGFnYXRlcy5cblxuICAgICAgLy8gVXBkYXRlIGluc2VydCBpbmRleCBmb3IgbmV4dCBvcGVyYXRpb24uXG4gICAgICB0aGlzLl9pbnNlcnRJbmRleCA9IChpbnNlcnRJbmRleCArIDEpICUgc2l6ZTtcblxuICAgICAgaWYgKGV2aWN0aW5nLmV4aXN0cykge1xuICAgICAgICBpbmRleC5kZWxldGUoZXZpY3Rpbmcua2V5KTtcbiAgICAgICAgZXZpY3RpbmcuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQoIWJ1ZmZlclt0aGlzLl9pbnNlcnRJbmRleF0uZXhpc3RzLCAnSW52YXJpYW50IG5vdCBlbmZvcmNlZCAoYWZ0ZXIpOiBpbnNlcnQgaW5kZXggbm90IGVtcHR5Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyByaW5nYnVmZmVyLiBXaWxsIGluY3JlYXNlIHRvXG4gICAqIG9uZSBsZXNzIHRoYW4gdGhlIHNpemUgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIGFzIHRoZSBidWZmZXIgaXMgdXNlZC5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqIEBtZW1iZXJvZiBBcHBsaWNhdGlvbkFja1JpbmdCdWZmZXJcbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4LnNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcmluZyBidWZmZXIuXG4gICAqXG4gICAqIFRoaXMgY291bGQgYmUgY2FsbGVkIGZyb20gdGhlIGV2aWN0IGNhbGxiYWNrLCBzbyBpbnNlcnQgbmVlZHMgdG8gYmUgc3VyZVxuICAgKiB0aGF0IGludGVybmFsIHN0YXRlIGlzIGNvcnJlY3QgZm9yIHRoYXQgc2NlbmFyaW8uXG4gICAqXG4gICAqIFRoZSBleHBlY3RlZCBjYXNlIGlzIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYXQgaW5zZXJ0SW5kZXggKyAxLCBidXQgaWYgdGhlXG4gICAqIGJ1ZmZlciBoYXMgbm90IGJlZW4gZmlsbGVkIHlldCwgd2Ugd2lsbCBpdGVyYXRlIHRoZSBidWZmZXIgYW5kIHNraXAgbm9uZXhpc3RlbnRcbiAgICogZWxlbWVudHMgdG8gZmluZCBpdC5cbiAgICpcbiAgICogVGhpcyBpcyBhIGxpdHRsZSBpbmVmZmljaWVudCB1bnRpbCB3ZSBoYXZlIHJlY2VpdmVkIHRoaXMuX3NpemUgbWVzc2FnZXMsIGJ1dCBhZnRlclxuICAgKiB0aGF0IGl0IGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gbWFpbnRhaW5pbmcgYSByZWFkIHBvaW50ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHs/QXBwbGljYXRpb25BY2t9IFRoZSBmaXJzdCBhY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICovXG4gIGZyb250KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgY29uc3QgaW5zZXJ0SW5kZXggPSB0aGlzLl9pbnNlcnRJbmRleDtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICBjb25zdCBmaXJzdEluZGV4ID0gKGluc2VydEluZGV4ICsgMSkgJSBzaXplO1xuICAgIC8vIENhbm5vdCBhc3NlcnQgaW52YXJpYW50IGhlcmU6IGluc2VydCBpcyB1c3VhbGx5IGluIHByb2dyZXNzLlxuXG4gICAgLy8gQnVmZmVyIGZ1bGwgY2FzZVxuICAgIGlmIChidWZmZXJbZmlyc3RJbmRleF0uZXhpc3RzKSByZXR1cm4gYnVmZmVyW2ZpcnN0SW5kZXhdO1xuXG4gICAgLy8gTm90IHlldCBmaWxsZWQgY2FzZVxuICAgIC8vIFRoZSBsYXN0IGNoZWNrZWQgZWxlbWVudCBmb3IgdGhlIGl0ZXJhdGlvbiBpcyB0aGUgc3RhcnQgcG9pbnQsXG4gICAgLy8gIHBsdXMgc2l6ZSwgYSBmdWxsIGxhcCBpbmNsdWRpbmcgdGhlIHN0YXJ0IGluZGV4LFxuICAgIC8vICBtaW51cyAxLCB0byBleGNsdWRlIHRoZSBzdGFydFxuICAgIC8vICBtaW51cyAxLCB0byBleGNsdWRlIHRoZSBpbnZhcmlhbnQgbnVsbCBlbnRyeVxuICAgIGZvciAobGV0IHJhd0luZGV4ID0gZmlyc3RJbmRleCwgbGFzdEluZGV4ID0gZmlyc3RJbmRleCArIHNpemUgLSAxO1xuICAgICAgICAgcmF3SW5kZXggPD0gbGFzdEluZGV4O1xuICAgICAgICAgKytyYXdJbmRleCkge1xuICAgICAgY29uc3QgcmVhZEluZGV4ID0gcmF3SW5kZXggJSBzaXplO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGJ1ZmZlcltyZWFkSW5kZXhdO1xuICAgICAgaWYgKGVsZW1lbnQuZXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBpcyBjb21wbGV0ZWx5IGVtcHR5XG4gICAgYXNzZXJ0KHRoaXMuX2luZGV4LnNpemUgPT09IDAsICcjZnJvbnQoKSBmYWlsZWQgc28gYnVmZmVyIG11c3QgYmUgZW1wdHknKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgdGhlIGl0ZXJhdG9yIHByb3RvY29sLCB3aGljaCByZXF1aXJlcyBTeW1ib2wgc3VwcG9ydCxcbiAgICogd2UnbGwgaW1wbGVtZW50IGEgZm9yRWFjaCB0aGF0IGJlaGF2ZXMgYXMgdGhvdWdoIHRoaXMgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXBwbGljYXRpb25BcHBTdGF0ZSwgaW5kZXgsIGNvbGxlY3Rpb24pfSBjYWxsYmFjayBUaGUgaXRlcmF0aW9uIGNhbGxiYWNrXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IHJhd0luZGV4ID0gdGhpcy5faW5zZXJ0SW5kZXggKyAxLCBsYXN0SW5kZXggPSB0aGlzLl9pbnNlcnRJbmRleCArIHNpemU7XG4gICAgICAgICByYXdJbmRleCA8PSBsYXN0SW5kZXg7XG4gICAgICAgICArK3Jhd0luZGV4KSB7XG4gICAgICBjb25zdCByZWFkSW5kZXggPSByYXdJbmRleCAlIHNpemU7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYnVmZmVyW3JlYWRJbmRleF07XG4gICAgICBpZiAoZWxlbWVudC5leGlzdHMpIHtcbiAgICAgICAgY2FsbGJhY2soZWxlbWVudCwgaW5kZXgrKywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KGluZGV4ID4gMCwgJ05vdCBlbXB0eSBidXQgZGlkIG5vdCBkaXNwYXRjaCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TG9uZ30gaWQgVGhlIElEIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0ge0FwcGxpY2F0aW9uQWNrU3RhdGV9IHN0YXRlIFRoZSBuZXcgc3RhdGUgZm9yIHRoZSBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlQWNrU3RhdGUoaWQsIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gaWQudG9TdHJpbmcoKTsgYXNzZXJ0KHRoaXMuX2luZGV4LmhhcyhrZXkpLCAnQWNrIGtleSBub3QgZm91bmQnKTtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9idWZmZXI7XG4gICAgY29uc3QgdXBkYXRlSW5kZXggPSB0aGlzLl9pbmRleC5nZXQoa2V5KTtcbiAgICBjb25zdCBleGlzdGluZyA9IGJ1ZmZlclt1cGRhdGVJbmRleF07IGFzc2VydChleGlzdGluZywgJ0FjayBrZXkgaGFzIG5vIGVudHJ5Jyk7XG4gICAgZXhpc3Rpbmcuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0xvbmd9IGlkIFRoZSBJRCB0byBsb29rIHVwXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhpcyBJRCBleGlzdHMgaW4gdGhlIHJpbmdidWZmZXJcbiAgICovXG4gIGhhcyhpZCkge1xuICAgIGNvbnN0IGtleSA9IGlkLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4LmhhcyhrZXkpO1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24obW9kdWxlLmV4cG9ydHMsIHtcbiAgQXBwbGljYXRpb25BY2tTdGF0ZSxcbiAgQXBwbGljYXRpb25BY2ssXG4gIEFwcGxpY2F0aW9uQWNrUmluZ0J1ZmZlcixcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvYXBwbGljYXRpb24tYWNrcy5qcyIsImNvbnN0IHsgYXNzZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXInKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItZXZlbnQtbmFtZXMnKTtcblxuY2xhc3MgQ29uc3VtZXJGbG93cyB7XG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgc2V0IG9mIEd1YXJhbnRlZWQgTWVzc2FnaW5nIEZsb3dzLiAgVGhlcmUgYXJlIHR3byBzZXRzIGFsbG9jYXRlZCwgb25lXG4gICAqIGZvciBwdWJsaXNoZXJzICh0eXBpY2FsbHkganVzdCBvbmUgZW50cnkpIGFuZCBvbmUgZm9yIFN1YnNjcmliZXJzLlxuICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucyBDb25zdHJ1Y3Rpb24gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYWxsRmxvd3MgPSBuZXcgU2V0KCk7XG4gICAgLy8gRmxvd3MgYnkgaWQgKFVQKVxuICAgIHRoaXMuX2Zsb3dzQnlJZCA9IHt9O1xuICB9XG5cbiAgYWRkKGZsb3cpIHtcbiAgICBhc3NlcnQoZmxvdyBpbnN0YW5jZW9mIE1lc3NhZ2VDb25zdW1lciwgJ0Zsb3cgd2FzIG5vdCBhIGNvbnN1bWVyJyk7XG4gICAgaWYgKHRoaXMuX2FsbEZsb3dzLmhhcyhmbG93KSkge1xuICAgICAgcmV0dXJuIGZsb3c7XG4gICAgfVxuXG4gICAgY29uc3QgZmxvd1VwID0gKCkgPT4ge1xuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgZmxvdyBjb2xsaXNpb25zIC0tIHRoZSByb3V0ZXIgYXNzaWduZWQgdGhlIG5ldyBmbG93IHRvIHRoZSBzYW1lIElEXG4gICAgICAvLyBzbyBpdCB3b24ndCBhZGRyZXNzIHRoZSBvbGQgZmxvdy4gUmV0YWluIHRoZSBvbGQgZmxvdyBpbiBfYWxsRmxvd3MgYW5kIG1ha2Ugc3VyZSB3ZVxuICAgICAgLy8gZGlzcG9zZSB0aGUgcmlnaHQgZmxvdy5cbiAgICAgIHRoaXMuX2Zsb3dzQnlJZFtmbG93LmZsb3dJZF0gPSBmbG93O1xuICAgIH07XG4gICAgY29uc3QgZmxvd0Rpc3Bvc2VkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmxvd0lkID0gZmxvdy5mbG93SWQ7XG4gICAgICB0aGlzLl9hbGxGbG93cy5kZWxldGUoZmxvdyk7XG4gICAgICBjb25zdCBmbG93QnlJZCA9IHRoaXMuX2Zsb3dzQnlJZFtmbG93SWRdO1xuICAgICAgLy8gSWYgdGhpcyB0ZXN0IGZhaWxzLCB0aGUgcm91dGVyIHJlYXNzaWduZWQgdGhlIGZsb3cgSUQsIGFuZCB3ZSB3ZXJlIG9ubHkga2VlcGluZyB0aGVcbiAgICAgIC8vIF9hbGxGbG93cyBzZXQgcmVmZXJlbmNlIGZvciBibGFua2V0IGNsZWFudXAuXG4gICAgICBpZiAoZmxvd0J5SWQgPT09IGZsb3cpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Zsb3dzQnlJZFtmbG93SWRdO1xuICAgICAgfVxuICAgICAgLy8gRmxvdyB3aWxsIGJlIGRpc3Bvc2VkIGFuZCB0aGlzIHdpbGwgaGFwcGVuIGF1dG9tYXRpY2FsbHlcbiAgICB9O1xuXG4gICAgZmxvdy5fb24oTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLlVQLCBmbG93VXApO1xuICAgIGZsb3cuX29uKE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5ESVNQT1NFRCwgZmxvd0Rpc3Bvc2VkKTtcblxuICAgIHRoaXMuX2FsbEZsb3dzLmFkZChmbG93KTtcbiAgICByZXR1cm4gZmxvdztcbiAgfVxuXG4gIGdldCBmbG93cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9hbGxGbG93cyk7XG4gIH1cblxuICBnZXRGbG93QnlJZChmbG93SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZmxvd3NCeUlkW2Zsb3dJZF07XG4gIH1cblxuICBkaXNwb3NlQWxsKCkge1xuICAgIHRoaXMuX2FsbEZsb3dzLmZvckVhY2goZmxvdyA9PiBmbG93LmRpc3Bvc2UoKSk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25zdW1lckZsb3dzID0gQ29uc3VtZXJGbG93cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL2NvbnN1bWVyLWZsb3dzLmpzIiwiY29uc3QgU01GTGliID0gcmVxdWlyZSgnc29sY2xpZW50LXNtZicpO1xuY29uc3QgeyBBcHBsaWNhdGlvbkFjayxcbiAgICAgICAgQXBwbGljYXRpb25BY2tSaW5nQnVmZmVyLFxuICAgICAgICBBcHBsaWNhdGlvbkFja1N0YXRlIH0gPSByZXF1aXJlKCcuL2FwcGxpY2F0aW9uLWFja3MnKTtcbmNvbnN0IHsgYXNzZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgQ2FwYWJpbGl0eVR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zZXNzaW9uJyk7XG5jb25zdCB7IENvbnN1bWVyRlNNRXZlbnQgfSA9IHJlcXVpcmUoJy4vY29uc3VtZXItZnNtLWV2ZW50Jyk7XG5jb25zdCB7IENvbnN1bWVyRlNNRXZlbnROYW1lcyB9ID0gcmVxdWlyZSgnLi9jb25zdW1lci1mc20tZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgQ29uc3VtZXJTdGF0ZU5hbWVzIH0gPSByZXF1aXJlKCcuL2NvbnN1bWVyLXN0YXRlLW5hbWVzJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uRnJvbU5ldHdvcmssXG4gICAgICAgIERlc3RpbmF0aW9uVHlwZSxcbiAgICAgICAgUXVldWUsXG4gICAgICAgIFRvcGljIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIsXG4gICAgICAgIEVycm9yU3ViY29kZSxcbiAgICAgICAgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBMb2dGb3JtYXR0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItYWNrbm93bGVkZ2UtbW9kZXMnKTtcbmNvbnN0IHsgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtY29uc3VtZXItZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgTWVzc2FnZURpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kaXNwYXRjaGVyJyk7XG5jb25zdCB7IFByaXZhdGVGbG93RXZlbnROYW1lIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZmxvdycpO1xuY29uc3QgeyBRdWV1ZUFjY2Vzc1R5cGUsXG4gICAgICAgIFF1ZXVlRGVzY3JpcHRvcixcbiAgICAgICAgUXVldWVUeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtcXVldWUnKTtcbmNvbnN0IHsgU3RhdGUsIFN0YXRlTWFjaGluZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWZzbScpO1xuY29uc3QgeyBTdGF0cyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXN0YXRzJyk7XG5jb25zdCB7IFN0YXRUeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc3RhdHMnKTtcbmNvbnN0IHsgVGltZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1ldmVudHMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0QWNrcyxcbiAgICAgICAgVHJhbnNwb3J0QWNrUmVzdWx0IH0gPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1hY2tzJyk7XG5cbmNvbnN0IFJJTkdfQlVGRkVSX1NJWkUgPSA1MTI7XG5jb25zdCBaRVJPX0FQUF9BQ0sgPSBuZXcgQXBwbGljYXRpb25BY2soTG9uZy5VWkVSTywgQXBwbGljYXRpb25BY2tTdGF0ZS5BQ0tFRF9TRU5UKTtcblxuY2xhc3MgQ29uc3VtZXJGU00gZXh0ZW5kcyBTdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGNvbnN1bWVyLCBzZXNzaW9uSW50ZXJmYWNlLCBwcm9wZXJ0aWVzIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZSB9KTtcblxuICAgIGNvbnN0IGZzbSA9IHRoaXM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZnVuY3Rpb24gZm9ybWF0dGVyKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGBbc2Vzc2lvbj0ke3Nlc3Npb25JbnRlcmZhY2Uuc2Vzc2lvbklkSGV4fV1gLFxuICAgICAgICBgW21lc3NhZ2UtY29uc3VtZXItZnNtPSR7Y29uc3VtZXIuZmxvd0lkRGVjfV1gLFxuICAgICAgICAuLi5hcmdzLFxuICAgICAgXTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyID0gbmV3IExvZ0Zvcm1hdHRlcihmb3JtYXR0ZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIExPR19UUkFDRSxcbiAgICAgIExPR19ERUJVRyxcbiAgICAgIExPR19JTkZPLFxuICAgICAgTE9HX1dBUk4sXG4gICAgICBMT0dfRVJST1IsXG4gICAgfSA9IGxvZ2dlcjtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci53cmFwKHRoaXMubG9nLCB0aGlzKTtcblxuICAgIGNvbnN0IGF1dG9BY2sgPSBwcm9wZXJ0aWVzLmFja25vd2xlZGdlTW9kZSA9PT0gTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlLkFVVE87XG5cbiAgICB0aGlzLl9jb25zdW1lciA9IGNvbnN1bWVyO1xuICAgIHRoaXMuX3Nlc3Npb25JbnRlcmZhY2UgPSBzZXNzaW9uSW50ZXJmYWNlO1xuXG4gICAgdGhpcy5fYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcyA9IHByb3BlcnRpZXMuYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcztcbiAgICB0aGlzLl9hY2tub3dsZWRnZVRocmVzaG9sZCA9IHByb3BlcnRpZXMuYWNrbm93bGVkZ2VUaHJlc2hvbGQ7XG5cbiAgICB0aGlzLl9iaW5kVGltZW91dEluTXNlY3MgPSBwcm9wZXJ0aWVzLmNvbm5lY3RUaW1lb3V0SW5Nc2VjcztcblxuICAgIHRoaXMuX2xvY2FsUHJlZmVycmVkV2luZG93U2l6ZSA9IHByb3BlcnRpZXMud2luZG93U2l6ZTtcbiAgICB0aGlzLl9sb2NhbE1heFdpbmRvd1NpemUgPSBwcm9wZXJ0aWVzLndpbmRvd1NpemU7XG5cbiAgICB0aGlzLl9tZXNzYWdlRGlzcGF0Y2ggPSBuZXcgTWVzc2FnZURpc3BhdGNoZXIoeyBlbWl0dGVyOiBjb25zdW1lciwgYXV0b0FjaywgbG9nZ2VyIH0pO1xuXG4gICAgdGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcblxuICAgIHRoaXMuX3Jlc2V0UmVtb3RlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgdGhpcy5fcmVzZXRMb2NhbENvbm5lY3Rpb25TdGF0ZSgpO1xuXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgLy8gQSBiaXQgb2YgaW5mcmFzdHJ1Y3R1cmUgYXJvdW5kIHBvc3QtZXZlbnQgYWN0aW9ucywgd2hpY2ggaW5jbHVkZXMgbWFpbnRhaW5pbmcgYSBxdWV1ZSBvZlxuICAgIC8vIHBlbmRpbmcgYWN0aW9ucywgYW5kIHNvbWUgbG9naWMgdG8gcHJlLXByb2Nlc3MgdGhlIGFjdGlvbnMgYmVmb3JlIHBlcmZvcm1pbmcgdGhlbS5cblxuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgdGhlIHNhbWUgYXMgYW55IE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSB2YWx1ZSBvciB0aGV5IHdpbGwgY29sbGlkZSBpblxuICAgIC8vIHRoZSBhY3Rpb25Mb2NhdGlvbnMgb2JqZWN0IGR1cmluZyBldmVudCBwcmUtcHJvY2Vzc2luZy5cbiAgICBjb25zdCBlbWl0RXZlbnRBY3Rpb25UeXBlID0gJ0VNSVQnO1xuICAgIGNvbnN0IHN0YXJ0RGlzcGF0Y2hBY3Rpb25UeXBlID0gJ0RJU1BBVENIJztcbiAgICBjb25zdCBzdG9wRGlzcGF0Y2hBY3Rpb25UeXBlID0gJ05PX0RJU1BBVENIJztcblxuICAgIGxldCBwb3N0RXZlbnRBY3Rpb25zID0gW107XG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1Bvc3RFdmVudEFjdGlvbnMoc3RhcnRJbmRleCkge1xuICAgICAgLy8gZmlyc3QgcHJlLXByb2Nlc3MgcG9zdCBldmVudCBhY3Rpb25zLiAgVGhpcyBpc24ndCBhbiBleGhhdXN0aXZlIHNlYXJjaCBvZiBldmVyeSBwb3NzaWJsZVxuICAgICAgLy8gY29tYmluYXRpb24gb2YgZXZlbnQgc2VxdWVuY2VzLCBhcyBtYW55IGFyZSBwcmFjdGljYWxseSBpbXBvc3NpYmxlLCBhbmQgdGhlcmVmb3JlXG4gICAgICAvLyBpbXBvc3NpYmxlIHRvIHRlc3QuICBXZSBvbmx5IGhhbmRsZSBzZXF1ZW5jZXMgdGhhdCBhcmUga25vd24gdG8gYmUgcG9zc2libGUuICBJZiB0aGVyZVxuICAgICAgLy8gYXJlIG90aGVyIHNlcXVlbmNlcyB0aGF0IG5lZWQgdG8gYmUgY29uc2lkZXJlZCwgd2UgY2FuIGFkZCBwcm9jZXNzaW5nIGZvciB0aGVtIHdoZW4gd2VcbiAgICAgIC8vIGtub3cgdGhleSBhcmUgcG9zc2libGUuXG4gICAgICBMT0dfVFJBQ0UoYFByZS1wcm9jZXNzaW5nIHBvc3QgZXZlbnQgYWN0aW9uIGxpc3QgQCR7c3RhcnRJbmRleH1gLCBwb3N0RXZlbnRBY3Rpb25zKTtcbiAgICAgIGNvbnN0IGFjdGlvbkxvY2F0aW9ucyA9IHt9O1xuICAgICAgcG9zdEV2ZW50QWN0aW9ucy5mb3JFYWNoKChhY3Rpb24sIGksIGFycikgPT4ge1xuICAgICAgICBmdW5jdGlvbiBjYW5jZWxBY3Rpb24oZmlyc3RBY3Rpb25OYW1lLCBjYW5jZWxsaW5nQWN0aW9uTmFtZSkge1xuICAgICAgICAgIGlmIChhY3Rpb25Mb2NhdGlvbnNbZmlyc3RBY3Rpb25OYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0TG9jYXRpb24gPSBhY3Rpb25Mb2NhdGlvbnNbZmlyc3RBY3Rpb25OYW1lXTtcbiAgICAgICAgICBMT0dfVFJBQ0UoYENhbmNlbGxpbmcgcG9zdCBldmVudCBhY3Rpb24gJHtmaXJzdEFjdGlvbk5hbWV9QCR7Zmlyc3RMb2NhdGlvbn0gd2l0aCAke1xuICAgICAgICAgICAgY2FuY2VsbGluZ0FjdGlvbk5hbWV9QCR7aX1gKTtcbiAgICAgICAgICBhY3Rpb25Mb2NhdGlvbnNbZmlyc3RBY3Rpb25OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBhcnJbZmlyc3RMb2NhdGlvbl0gPSBudWxsO1xuICAgICAgICAgIGFycltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpIDwgc3RhcnRJbmRleCkgfHwgKCFhY3Rpb24pKSB7XG4gICAgICAgICAgTE9HX1RSQUNFKGBTa2lwIG4vYSBhY3Rpb25AJHtpfSwgc3RhcnQ6ICR7c3RhcnRJbmRleH0sIGFjdGlvbjpgLCBhY3Rpb24pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSBlbWl0RXZlbnRBY3Rpb25UeXBlOlxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24uZGF0YSkge1xuICAgICAgICAgICAgICBjYXNlIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5VUDpcbiAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuQUNUSVZFOlxuICAgICAgICAgICAgICAgIGFjdGlvbkxvY2F0aW9uc1thY3Rpb24uZGF0YV0gPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLkRPV046XG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLkRPV05fRVJST1I6XG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aW9uKE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5VUCwgYWN0aW9uLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLklOQUNUSVZFOlxuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGlvbihNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuQUNUSVZFLCBhY3Rpb24uZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBMT0dfRVJST1IoYFVuZXhwZWN0ZWQgZXZlbnQgaW4gcG9zdC1ldmVudCBhY3Rpb246ICR7YWN0aW9uLmRhdGF9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugc3RhcnREaXNwYXRjaEFjdGlvblR5cGU6XG4gICAgICAgICAgICBhY3Rpb25Mb2NhdGlvbnNbYWN0aW9uLnR5cGVdID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBzdG9wRGlzcGF0Y2hBY3Rpb25UeXBlOlxuICAgICAgICAgICAgY2FuY2VsQWN0aW9uKHN0YXJ0RGlzcGF0Y2hBY3Rpb25UeXBlLCBhY3Rpb24udHlwZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Bvc3RFdmVudEFjdGlvbnMoKSB7XG4gICAgICBsZXQgcHJlcHJvY2Vzc2VkQWN0aW9ucyA9IDA7XG4gICAgICBsZXQgaTtcblxuICAgICAgLy8gTm93IHdlJ3ZlIHByZS1wcm9jZXNzZWQgdGhlIGxpc3QsIGV4ZWN1dGUgYW55IHJlbWFpbmluZyBub24tbnVsbCBlbnRyaWVzLiAgV2UgZG9uJ3QgdXNlIGFcbiAgICAgIC8vIGZvcmVhY2ggbG9vcCBzaW5jZSBmb3JlYWNoIHdvbid0IGluY2x1ZGUgZWxlbWVudHMgYWRkZWQgYWZ0ZXIgcHJvY2Vzc2luZyBoYXMgc3RhcnRlZC4gIFRoaXNcbiAgICAgIC8vIGNhbiBvY2N1ciBpZiBhIGNhbGxiYWNrIGNhdXNlcyBtb3JlIHBvc3RFdmVudEFjdGlvbnMgdG8gYmUgYWRkZWQuXG4gICAgICBMT0dfVFJBQ0UoJ0V4ZWN1dGluZyBwb3N0IGV2ZW50IGFjdGlvbiBsaXN0JywgcG9zdEV2ZW50QWN0aW9ucyk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdEV2ZW50QWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAocHJlcHJvY2Vzc2VkQWN0aW9ucyA8IHBvc3RFdmVudEFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJlcHJvY2Vzc1Bvc3RFdmVudEFjdGlvbnMoaSk7XG4gICAgICAgICAgcHJlcHJvY2Vzc2VkQWN0aW9ucyA9IHBvc3RFdmVudEFjdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHBvc3RFdmVudEFjdGlvbnNbaV07XG4gICAgICAgIExPR19UUkFDRShgQWN0aW9uICR7aX06YCwgYWN0aW9uKTtcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSBlbWl0RXZlbnRBY3Rpb25UeXBlOlxuICAgICAgICAgICAgY29uc3VtZXIuX2VtaXQoYWN0aW9uLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHN0b3BEaXNwYXRjaEFjdGlvblR5cGU6XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBkbyB0aGUgc3RvcCBoZXJlIC0tIGl0IGlzIGFsd2F5cyBkb25lIHdoZW4gdGhpcyBpcyBlbnF1ZXVlZC5cbiAgICAgICAgICAgIC8vIFRoZSByZWFzb24gZm9yIGVucXVldWluZyB0aGlzIGV2ZW50IGlzIHRvIHRoYXQgaXQgY2FuIGNlbmNlbCBhIHN0YXJ0RGlzcGF0Y2gsIGlmXG4gICAgICAgICAgICAvLyBwcmVzZW50LlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHN0YXJ0RGlzcGF0Y2hBY3Rpb25UeXBlOlxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhcnREaXNwYXRjaEZTTSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgTE9HX0VSUk9SKGBVbmhhbmRsZWQgcG9zdCBldmVudCBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3N0RXZlbnRBY3Rpb25zID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUG9zdEV2ZW50QWN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgIGxldCBuZXdFdmVudDtcbiAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3RXZlbnQgPSB7IHR5cGUsIGRhdGEgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0V2ZW50ID0geyB0eXBlIH07XG4gICAgICB9XG4gICAgICBwb3N0RXZlbnRBY3Rpb25zLnB1c2gobmV3RXZlbnQpO1xuICAgICAgTE9HX1RSQUNFKGBBZGRlZCBwb3N0IGV2ZW50IGFjdGlvbiAke3Bvc3RFdmVudEFjdGlvbnMubGVuZ3RofTpgLCBuZXdFdmVudCk7XG4gICAgICBpZiAocG9zdEV2ZW50QWN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZnNtLnNldFBvc3RFdmVudEFjdGlvbihwcm9jZXNzUG9zdEV2ZW50QWN0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWRkRXZlbnRUb0VtaXQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghcHJvcGVydGllcy5hY3RpdmVJbmRpY2F0aW9uRW5hYmxlZCkge1xuICAgICAgICBpZiAoKGV2ZW50ID09PSBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuSU5BQ1RJVkUpIHx8XG4gICAgICAgICAgICAoZXZlbnQgPT09IE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5BQ1RJVkUpKSB7XG4gICAgICAgICAgTE9HX1RSQUNFKGBTa2lwIGVtaXR0aW5nICR7ZXZlbnR9IGR1ZSB0byBkaXNhYmxlZCBmbG93IGFjdGl2ZSBpbmRpY2F0aW9uc2ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkUG9zdEV2ZW50QWN0aW9uKGVtaXRFdmVudEFjdGlvblR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3RTdGFydERpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgYWRkUG9zdEV2ZW50QWN0aW9uKHN0YXJ0RGlzcGF0Y2hBY3Rpb25UeXBlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3RTdG9wRGlzcGF0Y2ggPSAoKSA9PiB7XG4gICAgICAvLyBXZSBkbyB0aGUgc3RvcCBpbmxpbmUsIHRoZW4gYWRkIGEgcG9zdC1ldmVudCBhY3Rpb24gc28gdGhhdCBpdCBjYW4gaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBjYW5jZWxsaW5nIGEgcHJldmlvdXMgc3RhcnQuICBJdCB3aWxsIG5vdCBleGVjdXRlIHRoZSBzdG9wIHdoZW4gcHJvY2Vzc2VkIGhvd2V2ZXIgc2luY2Ugd2VcbiAgICAgIC8vIGhhdmUgYWxyZWFkeSBkb25lIGl0IGhlcmUuXG4gICAgICB0aGlzLnJlcXVlc3RTdG9wRGlzcGF0Y2hGU00oKTtcbiAgICAgIGFkZFBvc3RFdmVudEFjdGlvbihzdG9wRGlzcGF0Y2hBY3Rpb25UeXBlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fYWRkRXZlbnRUb0VtaXQgPSBhZGRFdmVudFRvRW1pdDtcbiAgICB0aGlzLl9yZXF1ZXN0U3RhcnREaXNwYXRjaCA9IHJlcXVlc3RTdGFydERpc3BhdGNoO1xuICAgIHRoaXMuX3JlcXVlc3RTdG9wRGlzcGF0Y2ggPSByZXF1ZXN0U3RvcERpc3BhdGNoO1xuXG4gICAgLy8gRW5kIG9mIHBvc3QtZXZlbnQgYWN0aW9uIGluZnJhc3RydWN0dXJlXG4gICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAvLyBGU00gY29uZmlnXG4gICAgdGhpcy51bmhhbmRsZWRFdmVudFJlYWN0aW9uKGZ1bmN0aW9uIG9uVW5oYW5kbGVkRXZlbnQoZXZlbnQpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQuZ2V0TmFtZSgpKSB7XG4gICAgICAgIGNhc2UgQ29uc3VtZXJGU01FdmVudE5hbWVzLlZJUlRVQUxST1VURVJfTkFNRV9DSEFOR0VEOlxuICAgICAgICAgIExPR19JTkZPKCdWaXJ0dWFsUm91dGVyIG5hbWUgY2hhbmdlOiBjbGVhcmluZyBhbGwgYWNrbm93bGVkZ2VtZW50IHN0YXRlJyk7XG4gICAgICAgICAgZnNtLl9yZXNldFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjYXNlIENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX1VOQk9VTkQ6XG4gICAgICAgICAgTE9HX0lORk8oJ1JlY2VpdmVkIHVuc29saWNpdGVkIHVuYmluZC4gRmxvdyBtYXkgYmUgbWFudWFsbHkgcmVjb25uZWN0ZWQuJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvVW5ib3VuZChNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuRE9XTl9FUlJPUik7XG4gICAgICAgIGNhc2UgQ29uc3VtZXJGU01FdmVudE5hbWVzLkRJU1BPU0U6XG4gICAgICAgICAgZnNtLl9kaXNwb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIGZzbS5nZXRDdXJyZW50U3RhdGUoKS50ZXJtaW5hdGUoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBMT0dfVFJBQ0UoYElnbm9yaW5nIGV2ZW50ICR7ZXZlbnQuZ2V0TmFtZSgpfSBpbiBzdGF0ZSAke3RoaXMuZ2V0Q3VycmVudFN0YXRlKCkuZ2V0TmFtZSgpfWApO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbml0aWFsKGZ1bmN0aW9uIG9uSW5pdGlhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uVW5ib3VuZCwgKGNvbnRleHQpID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKGBTdGFydGluZyAke2NvbnRleHQuZ2V0U3RhdGVNYWNoaW5lKCkuZ2V0TmFtZSgpfWApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAgV2UgZG9uJ3QgdHJhbnNpdGlvbiBkaXJlY3RseSBmcm9tIFVuYm91bmQgdG8gQmluZFNlbnQuXG4gICAgICBXZSBuZWVkIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICAgICAgICogRkxPV19PUEVOXG4gICAgICAgKiBTRVNTSU9OX1VQXG4gICAgICAoVGhlIHNlc3Npb24gZW5zdXJlcyB3ZSBnZXQgU0VTU0lPTl9VUCBvciBTRVNTSU9OX1VQX05PX0FEIGlmIHdlIGFyZSBjcmVhdGVkXG4gICAgICBhbmQgdGhlcmUgaXMgYSBzZXNzaW9uIGFscmVhZHkgdXAuKVxuICAgICAgVGhlIFVuYm91bmQgYmFzZSBzdGF0ZSBpbXBsZW1lbnRzIHRyYW5zaXRpb25zIHRvIGl0cyB3YWl0IHN0YXRlIGNoaWxkcmVuOlxuICAgICAgICogRkxPV19PUEVOIC0+IEF3YWl0U2Vzc2lvblVwXG4gICAgICAgKiBTRVNTSU9OX1VQIC0+IEF3YWl0Rmxvd09wZW5cbiAgICAgIEl0IGFsc28gaGFzIHRoZSBmb2xsb3dpbmcgdHJhbnNpdGlvbnMgdGhhdCBwdWxsIHRoZSBGU00gb3V0IG9mIGl0cyBjaGlsZHJlblxuICAgICAgYW5kIGJhY2sgdG8gaXRzZWxmOlxuICAgICAgICogRkxPV19DTE9TRVxuICAgICAgICogU0VTU0lPTl9ET1dOXG4gICAgICBUaGUgY2hpbGQgc3RhdGVzIGNhbiBvdmVycmlkZSB0aGVzZSB3aXRoIGludGVybmFsIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuVW5ib3VuZCA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBDb25zdW1lclN0YXRlTmFtZXMuVU5CT1VORCxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbSxcbiAgICB9LCB7XG4gICAgICBlbWl0RGlzYWJsZWRFdmVudCgpIHtcbiAgICAgICAgY29uc3VtZXIuX2VtaXQoTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLkdNX0RJU0FCTEVEKTtcbiAgICAgIH0sXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19DTE9TRSwgZnVuY3Rpb24gb25GbG93Q2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oQ29uc3VtZXJGU01FdmVudE5hbWVzLlNFU1NJT05fRE9XTiwgZnVuY3Rpb24gb25TZXNzaW9uRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRoaXMpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9ESVNDT05ORUNULCBmdW5jdGlvbiBvblNlc3NzaW9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRoaXMpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19PUEVOLCBmdW5jdGlvbiBvbkZsb3dPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlVuYm91bmQuQXdhaXRTZXNzaW9uVXApOyAvLyBFbnRlciBjaGlsZCBzdGF0ZVxuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9VUCwgZnVuY3Rpb24gb25TZXNzaW9uVXAoKSB7XG4gICAgICAgIGlmIChmc20uX3Nlc3Npb25JbnRlcmZhY2UuaXNDYXBhYmxlKENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uVW5ib3VuZC5Bd2FpdEZsb3dPcGVuKTsgLy8gRW50ZXIgY2hpbGQgc3RhdGVcbiAgICAgICAgfVxuICAgICAgICBMT0dfV0FSTihgQ29uc3VtZXIgaXMgbm90IHN1cHBvcnRlZCBieSByb3V0ZXIgZm9yIHRoaXMgY2xpZW50IG9uIHNlc3Npb25JZCAweCR7XG4gICAgICAgICAgICAgICAgIGZzbS5fc2Vzc2lvbkludGVyZmFjZS5zZXNzaW9uSWRIZXh9YCk7XG4gICAgICAgIC8vIEFjdCBhcyBpZiB0aGUgY2hpbGQgc3RhdGUgaGFuZGxlZCB0aGlzXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbigoKSA9PiB0aGlzLmVtaXREaXNhYmxlZEV2ZW50KCkpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9VUF9OT19BRCwgZnVuY3Rpb24gb25TZXNzaW9uVXBOb0FEKCkge1xuICAgICAgICAvLyBBY3QgYXMgaWYgdGhlIGNoaWxkIHN0YXRlIGhhbmRsZWQgdGhpc1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRyYW5zaXRpb24oKCkgPT4gdGhpcy5lbWl0RGlzYWJsZWRFdmVudCgpKTtcbiAgICAgIH0pXG4gICAgICAuZXhpdCgoKSA9PiB7XG4gICAgICAgIGZzbS5iaW5kUmV0cnlDb3VudCA9IHByb3BlcnRpZXMuYmluZFJldHJ5Q291bnQ7XG4gICAgICB9KTtcblxuICAgIC8qXG4gICAgICBJbiB0aGlzIHN0YXRlLCB3ZSBoYXZlIHJlY2VpdmVkIEZMT1dfT1BFTiwgYnV0IG5vIFNFU1NJT05fVVAuXG4gICAgICBTRVNTSU9OX0RPV04gZG9lcyBub3QgY2FuY2VsIHRoaXMgd2FpdCwgc28gd2UgbXVzdCBvdmVycmlkZSB0aGVcbiAgICAgIHBhcmVudCBhbmQgZXhwbGljaXRseSBkbyBub3RoaW5nLlxuICAgICovXG4gICAgdGhpcy5VbmJvdW5kLkF3YWl0U2Vzc2lvblVwID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIENvbnN1bWVyU3RhdGVOYW1lcy5VTkJPVU5EX0FXQUlUX1NFU1NJT05fVVAsXG4gICAgICBwYXJlbnRDb250ZXh0OiB0aGlzLlVuYm91bmQsXG4gICAgfSwge1xuICAgICAgZW1pdEJpbmRXYWl0aW5nKCkge1xuICAgICAgICBjb25zdW1lci5fZW1pdChQcml2YXRlRmxvd0V2ZW50TmFtZS5CSU5EX1dBSVRJTkcpO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmVudHJ5KGZ1bmN0aW9uIG9uRW50cnkoKSB7XG4gICAgICAgIHRoaXMuZW1pdEJpbmRXYWl0aW5nKCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RPV04sIGZ1bmN0aW9uIG9uU2Vzc2lvbkRvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbigpOyAvLyBEb24ndCBleGl0OyBjb250aW51ZSB3YWl0aW5nXG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RJU0NPTk5FQ1QsIGZ1bmN0aW9uIG9uU2Vzc2lvbkRvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbigpOyAvLyBEb24ndCBleGl0OyBjb250aW51ZSB3YWl0aW5nXG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX1VQLCBmdW5jdGlvbiBvblNlc3Npb25VcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5CaW5kU2VudCk7IC8vIE9LIHRvIGJpbmRcbiAgICAgIH0pO1xuXG4gICAgLypcbiAgICAgIEluIHRoaXMgc3RhdGUsIHdlIGhhdmUgcmVjZWl2ZWQgU0VTU0lPTl9VUCBidXQgbm90IEZMT1dfT1BFTi5cbiAgICAgIElmIHdlIGdldCBGTE9XX09QRU4sIGF0dGVtcHQgdG8gYmluZC4gQW55IG90aGVyIGV2ZW50IGlzIGhhbmRsZWRcbiAgICAgIGJ5IHRoZSBwYXJlbnQuXG4gICAgICovXG4gICAgdGhpcy5VbmJvdW5kLkF3YWl0Rmxvd09wZW4gPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgQ29uc3VtZXJTdGF0ZU5hbWVzLlVOQk9VTkRfQVdBSVRfRkxPV09QRU4sXG4gICAgICBwYXJlbnRDb250ZXh0OiB0aGlzLlVuYm91bmQsXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19PUEVOLCBmdW5jdGlvbiBvbkZsb3dPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLkJpbmRTZW50KTsgLy8gT0sgdG8gYmluZFxuICAgICAgfSk7XG5cbiAgICB0aGlzLkJpbmRTZW50ID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIENvbnN1bWVyU3RhdGVOYW1lcy5CSU5EX1NFTlQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20sXG4gICAgfSwge1xuICAgICAgZW1pdEJpbmRGYWlsZWQoZXJyb3IpIHtcbiAgICAgICAgYXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgT3BlcmF0aW9uRXJyb3IpO1xuICAgICAgICBjb25zdW1lci5fZW1pdChNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuQ09OTkVDVF9GQUlMRURfRVJST1IsIGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBzZW5kQmluZFJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uVGFnID0gc2Vzc2lvbkludGVyZmFjZS5nZXRDb3JyZWxhdGlvblRhZygpO1xuICAgICAgICBjb25zdCB0cmFuc3BvcnRBY2tzID0gZnNtLl90cmFuc3BvcnRBY2tzO1xuXG4gICAgICAgIGZzbS5fZW5kcG9pbnRFbnN1cmUoKTtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBmc20uX2VuZHBvaW50O1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBmc20uX3N1YnNjcmlwdGlvbjtcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gU01GTGliLkFkUHJvdG9jb2xNZXNzYWdlLmdldE9wZW5NZXNzYWdlQ29uc3VtZXIoXG4gICAgICAgICAgcHJvcGVydGllcy5xdWV1ZURlc2NyaXB0b3IsXG4gICAgICAgICAgcHJvcGVydGllcy5xdWV1ZVByb3BlcnRpZXMsXG4gICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgIGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgIHByb3BlcnRpZXMud2luZG93U2l6ZSxcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vTG9jYWwsXG4gICAgICAgICAgcHJvcGVydGllcy5hY3RpdmVJbmRpY2F0aW9uRW5hYmxlZCxcbiAgICAgICAgICB0cmFuc3BvcnRBY2tzLmxhc3RBY2tlZCxcbiAgICAgICAgICB0cmFuc3BvcnRBY2tzLmxhc3RSZWNlaXZlZCk7XG4gICAgICAgIHNlc3Npb25JbnRlcmZhY2Uuc2VuZENvbnRyb2wobWVzc2FnZSk7XG4gICAgICAgIHNlc3Npb25JbnRlcmZhY2UuZW5xdWV1ZVJlcXVlc3QoY29ycmVsYXRpb25UYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCaW5kVGltZW91dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzbS5fYmluZFRpbWVvdXRJbk1zZWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCaW5kUmVzcG9uc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIExPR19UUkFDRSgnU2VudCBjb25zdW1lciBiaW5kIHJlcXVlc3Qgd2l0aCBhcmd1bWVudHMnLCBbXG4gICAgICAgICAgcHJvcGVydGllcy5xdWV1ZURlc2NyaXB0b3IsXG4gICAgICAgICAgcHJvcGVydGllcy5xdWV1ZVByb3BlcnRpZXMsXG4gICAgICAgICAgZW5kcG9pbnQsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgIGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgIHByb3BlcnRpZXMud2luZG93U2l6ZSxcbiAgICAgICAgICBwcm9wZXJ0aWVzLm5vTG9jYWwsXG4gICAgICAgICAgcHJvcGVydGllcy5hY3RpdmVJbmRpY2F0aW9uRW5hYmxlZCxcbiAgICAgICAgICB0cmFuc3BvcnRBY2tzLmxhc3RBY2tlZCxcbiAgICAgICAgICB0cmFuc3BvcnRBY2tzLmxhc3RSZWNlaXZlZF0pO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbEJpbmRSZXF1ZXN0VGltZXIoKSB7XG4gICAgICAgIHRoaXMuYmluZFJlcXVlc3RUaW1lci5jYW5jZWwoKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVCaW5kVGltZW91dCgpIHtcbiAgICAgICAgTE9HX0lORk8oJ0JpbmQgdGltZW91dCcpO1xuICAgICAgICBmc20ucHJvY2Vzc0V2ZW50KG5ldyBDb25zdW1lckZTTUV2ZW50KHsgbmFtZTogQ29uc3VtZXJGU01FdmVudE5hbWVzLkJJTkRfVElNRU9VVCB9KSk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQmluZFJlc3BvbnNlKG1zZykge1xuICAgICAgICBpZiAobXNnLm1zZ1R5cGUgIT09IFNNRkxpYi5TTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQklORCkge1xuICAgICAgICAgIC8vIFRPRE86IG1vcmUgdXNlZnVsIGFjdGlvbiBoZXJlP1xuICAgICAgICAgIExPR19JTkZPKGBVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZSBpbiBiaW5kIHJlc3BvbnNlOiAke1NNRkxpYi5TTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuZGVzY3JpYmUobXNnLm1zZ1R5cGUpfWApO1xuICAgICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgbmV3IENvbnN1bWVyRlNNRXZlbnQoXG4gICAgICAgICAgICAgIHsgbmFtZTogQ29uc3VtZXJGU01FdmVudE5hbWVzLkZMT1dfRkFJTEVEIH0sXG4gICAgICAgICAgICAgIG5ldyBPcGVyYXRpb25FcnJvcihgVW5leHBlY3RlZCBiaW5kIHJlc3BvbnNlOiAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU01GTGliLlNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZS5kZXNjcmliZShtc2cubXNnVHlwZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QUk9UT1RPQ09MX0VSUk9SKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGVhZGVyID0gbXNnLnNtZkhlYWRlcjtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VDb2RlID0gaGVhZGVyLnBtX3Jlc3Bjb2RlO1xuXG4gICAgICAgIGlmIChyZXNwb25zZUNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBEcm9wIG1lc3NhZ2UgYW5kIGluY3JlbWVudCBzdGF0cy4gRmxvdyB3aWxsIHRpbWUgb3V0XG4gICAgICAgICAgdGhpcy5fY29uc3VtZXIuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX1NNRl9VTktOT1dOX0VMRU1FTlQpO1xuICAgICAgICAgIExPR19ERUJVRyhgRHJvcCBPcGVuLVB1Ymxpc2hlci1GbG93IFJlcXVlc3QgbWVzc2FnZSBvbiBzZXNzaW9uSWQgMHgke1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uSW50ZXJmYWNlLnNlc3Npb25JZEhleH1gKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBoZWFkZXIucG1fcmVzcHN0cjtcbiAgICAgICAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRBREVycm9yU3ViY29kZShyZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24pO1xuICAgICAgICAgIExPR19ERUJVRygnRmxvdyBmYWlsZWQ6JywgcmVzcG9uc2VDb2RlLCBkZXNjcmlwdGlvbiwgRXJyb3JTdWJjb2RlLmRlc2NyaWJlKGVycm9yU3ViY29kZSkpO1xuICAgICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KG5ldyBDb25zdW1lckZTTUV2ZW50KFxuICAgICAgICAgICAgICB7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX0ZBSUxFRCB9LFxuICAgICAgICAgICAgICBuZXcgT3BlcmF0aW9uRXJyb3IoZGVzY3JpcHRpb24sIGVycm9yU3ViY29kZSwgeyByZXNwb25zZUNvZGUgfSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFjY2Vzc1R5cGVPckRlZmF1bHQgPSB4ID0+ICh4ID09PSB1bmRlZmluZWQgPyBRdWV1ZUFjY2Vzc1R5cGUuRVhDTFVTSVZFIDogeCk7XG5cbiAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgbGFzdE1zZ0lkQWNrZWQ6ICAgICAgIG1zZy5nZXRMYXN0TXNnSWRBY2tlZCgpLFxuICAgICAgICAgIGZsb3dJZDogICAgICAgICAgICAgICBtc2cuZ2V0Rmxvd0lkKCksXG4gICAgICAgICAgYWNjZXNzVHlwZTogICAgICAgICAgIGFjY2Vzc1R5cGVPckRlZmF1bHQobXNnLmdldEFjY2Vzc1R5cGUoKSksXG4gICAgICAgICAgdG9waWNFbmRwb2ludEJ5dGVzOiAgIG1zZy5nZXRUb3BpY0VuZHBvaW50Qnl0ZXMoKSxcbiAgICAgICAgICBncmFudGVkUGVybWlzc2lvbnM6ICAgbXNnLmdldEdyYW50ZWRQZXJtaXNzaW9ucygpLFxuICAgICAgICAgIHJlc3BlY3RzVFRMOiAgICAgICAgICBtc2cuZ2V0UmVzcGVjdHNUVEwoKSxcbiAgICAgICAgICBhY3RpdmVGbG93OiAgICAgICAgICAgbXNnLmdldEFjdGl2ZUZsb3coKSxcbiAgICAgICAgICB3YW50Rmxvd0NoYW5nZU5vdGlmeTogbXNnLmdldFdhbnRGbG93Q2hhbmdlTm90aWZ5KCksXG4gICAgICAgICAgZGlzY2FyZEJlaGF2aW9yOiAgICAgIG1zZy5nZXRRdWV1ZURpc2NhcmRCZWhhdmlvcigpLFxuICAgICAgICAgIGVuZHBvaW50SWQ6ICAgICAgICAgICBtc2cuZ2V0RW5kcG9pbnRJZCgpLFxuICAgICAgICAgIG1heFVuYWNrZWRNZXNzYWdlczogICBtc2cuZ2V0TWF4VW5hY2tlZE1lc3NhZ2VzKCksXG4gICAgICAgIH07XG4gICAgICAgIExPR19ERUJVRygnQklORCByZXNwb25zZSBhdHRyaWJ1dGVzOicsIGF0dHJzKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbnN1bWVyLCB7XG4gICAgICAgICAgYWNjZXNzVHlwZTogICAgICAgICAgIGF0dHJzLmFjY2Vzc1R5cGUsXG4gICAgICAgICAgcXVldWVEaXNjYXJkQmVoYXZpb3I6IGF0dHJzLmRpc2NhcmRCZWhhdmlvcixcbiAgICAgICAgICBlbmRwb2ludElkOiAgICAgICAgICAgYXR0cnMuZW5kcG9pbnRJZCxcbiAgICAgICAgICByZXNwZWN0c1RUTDogICAgICAgICAgYXR0cnMucmVzcGVjdHNUVEwsXG4gICAgICAgICAgZmxvd0lkOiAgICAgICAgICAgICAgIGF0dHJzLmZsb3dJZCxcbiAgICAgICAgICBwZXJtaXNzaW9uczogICAgICAgICAgYXR0cnMuZ3JhbnRlZFBlcm1pc3Npb25zLFxuICAgICAgICAgIHdhbnRGbG93Q2hhbmdlTm90aWZ5OiBhdHRycy53YW50Rmxvd0NoYW5nZU5vdGlmeSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGF0dHJzLnRvcGljRW5kcG9pbnRCeXRlcyAmJiBhdHRycy50b3BpY0VuZHBvaW50Qnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYXR0cnMuZW5kcG9pbnQgPSBEZXN0aW5hdGlvbkZyb21OZXR3b3JrLmNyZWF0ZURlc3RpbmF0aW9uRnJvbUJ5dGVzKFxuICAgICAgICAgICAgYXR0cnMudG9waWNFbmRwb2ludEJ5dGVzKTtcbiAgICAgICAgICBMT0dfREVCVUcoJ092ZXJ3cml0aW5nIGxvY2FsIGVuZHBvaW50OicsIGZzbS5fZW5kcG9pbnQsICd3aXRoIHJlbW90ZTonLCBhdHRycy5lbmRwb2ludCk7XG4gICAgICAgICAgZnNtLl9lbmRwb2ludCA9IGF0dHJzLmVuZHBvaW50O1xuICAgICAgICAgIGNvbnN0IGNvbnN1bWVyUHJvcGVydGllcyA9IGZzbS5fY29uc3VtZXIuX3Byb3BlcnRpZXM7XG4gICAgICAgICAgY29uc3VtZXJQcm9wZXJ0aWVzLnF1ZXVlRGVzY3JpcHRvciA9IG5ldyBRdWV1ZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgbmFtZTogICAgYXR0cnMuZW5kcG9pbnQubmFtZSxcbiAgICAgICAgICAgIHR5cGU6ICAgIGNvbnN1bWVyUHJvcGVydGllcy5xdWV1ZURlc2NyaXB0b3IudHlwZSxcbiAgICAgICAgICAgIGR1cmFibGU6IGNvbnN1bWVyUHJvcGVydGllcy5xdWV1ZURlc2NyaXB0b3IuZHVyYWJsZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZnNtLCB7XG4gICAgICAgICAgX2FjdGl2ZTogICAgICAgICAgIGF0dHJzLmFjdGl2ZUZsb3csXG4gICAgICAgICAgX3JlbW90ZVdpbmRvd1NpemU6IGF0dHJzLm1heFVuYWNrZWRNZXNzYWdlcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKExvbmcuVVpFUk8uZXEoZnNtLl90cmFuc3BvcnRBY2tzLmxhc3RBY2tlZCkpIHtcbiAgICAgICAgICBmc20uX3RyYW5zcG9ydEFja3MubGFzdEFja2VkID0gYXR0cnMubGFzdE1zZ0lkQWNrZWQgfHwgTG9uZy5VWkVSTztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMT0dfREVCVUcoYFJldGFpbmluZyBsYXN0IGFja2VkL2xhc3QgcmVjZWl2ZWQ6ICR7ZnNtLl90cmFuc3BvcnRBY2tzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZzbS5wcm9jZXNzRXZlbnQobmV3IENvbnN1bWVyRlNNRXZlbnQoeyBuYW1lOiBDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19VUCB9KSk7XG4gICAgICB9LFxuICAgIH0pXG4gICAgICAuZW50cnkoZnVuY3Rpb24gb25FbnRyeSgpIHtcbiAgICAgICAgdGhpcy5zZW5kQmluZFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5iaW5kUmVxdWVzdFRpbWVyID0gVGltZXIubmV3VGltZW91dChjb25zdW1lci5fcHJvcGVydGllcy5jb25uZWN0VGltZW91dEluTXNlY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCaW5kVGltZW91dCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RPV04sIGZ1bmN0aW9uIG9uU2Vzc2lvbkRvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uVW5ib3VuZC5Bd2FpdFNlc3Npb25VcCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RJU0NPTk5FQ1QsIGZ1bmN0aW9uIG9uU2Vzc2lvbkRvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uVW5ib3VuZC5Bd2FpdFNlc3Npb25VcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IGZzbS5fYWRkRXZlbnRUb0VtaXQoTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLkRPV04pKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oQ29uc3VtZXJGU01FdmVudE5hbWVzLkZMT1dfQ0xPU0UsIGZ1bmN0aW9uIG9uRmxvd0Nsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlVuYmluZFNlbnQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuQklORF9USU1FT1VULCBmdW5jdGlvbiBvbkJpbmRUaW1lb3V0KCkge1xuICAgICAgICBpZiAoZnNtLmJpbmRSZXRyeUNvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxUcmFuc2l0aW9uVG8oZnNtLkJpbmRTZW50LCAoKSA9PiAtLWZzbS5iaW5kUmV0cnlDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5VbmJvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5lbWl0QmluZEZhaWxlZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBPcGVyYXRpb25FcnJvcignQmluZCBmYWlsZWQgZHVlIHRvIHRpbWVvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5USU1FT1VUKSkpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19GQUlMRUQsIGZ1bmN0aW9uIG9uRmxvd0ZhaWxlZChldnQpIHtcbiAgICAgICAgLy8gQWN0IGxpa2UgYSBuZXdseSBjcmVhdGVkIGZsb3dcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5VbmJvdW5kLCAoKSA9PiB0aGlzLmVtaXRCaW5kRmFpbGVkKGV2dC5kZXRhaWxzKSk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX1VQLCBmdW5jdGlvbiBvbkZsb3dVcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5GbG93VXApO1xuICAgICAgfSlcbiAgICAgIC5leGl0KGZ1bmN0aW9uIG9uRXhpdCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxCaW5kUmVxdWVzdFRpbWVyKCk7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IGZsb3dVcEZTTSA9IHRoaXMuRmxvd1VwID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIENvbnN1bWVyU3RhdGVOYW1lcy5GTE9XX1VQLFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLFxuICAgIH0pXG4gICAgICAuaW5pdGlhbChcbiAgICAgICAgZnVuY3Rpb24gb25Jbml0aWFsKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uX2FjdGl2ZSA9PT0gMFxuICAgICAgICAgICAgPyBmbG93VXBGU00uWGZlckluYWN0aXZlXG4gICAgICAgICAgICA6IGZsb3dVcEZTTS5YZmVyKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgZnNtLl9hZGRFdmVudFRvRW1pdChNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuVVApO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9ET1dOLCBmdW5jdGlvbiBvblNlc3Npb25Eb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlVuYm91bmQuQXdhaXRTZXNzaW9uVXApO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9ESVNDT05ORUNULCBmdW5jdGlvbiBvblNlc3Npb25EaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlVuYm91bmQuQXdhaXRTZXNzaW9uVXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiBmc20uX2FkZEV2ZW50VG9FbWl0KE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5ET1dOKSk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX0NMT1NFLCBmdW5jdGlvbiBvbkZsb3dDbG9zZSgpIHtcbiAgICAgICAgLy8gQWNrcyB3aWxsIGJlIHNlbnQgYnkgVW5iaW5kU2VudFxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlVuYmluZFNlbnQpO1xuICAgICAgfSk7XG5cbiAgICBmbG93VXBGU00uWGZlciA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBDb25zdW1lclN0YXRlTmFtZXMuRkxPV19VUF9YRkVSLFxuICAgICAgcGFyZW50Q29udGV4dDogZmxvd1VwRlNNLFxuICAgIH0pXG4gICAgICAuZW50cnkoKCkgPT4ge1xuICAgICAgICBmc20uX2FkZEV2ZW50VG9FbWl0KE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5BQ1RJVkUpO1xuICAgICAgICBmc20uX3NlbmRBY2tzKHRydWUpO1xuICAgICAgICBmc20uX3JlcXVlc3RTdGFydERpc3BhdGNoKCk7XG4gICAgICB9KVxuICAgICAgLmV4aXQoKCkgPT4ge1xuICAgICAgICBmc20uX2FkZEV2ZW50VG9FbWl0KE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5JTkFDVElWRSk7XG4gICAgICAgIGZzbS5fcmVxdWVzdFN0b3BEaXNwYXRjaCgpO1xuICAgICAgfSlcbiAgICAgIC8vIEhlcmUgd2Ugc2VuZCBhY2tzIG9uIGRpc2Nvbm5lY3QuICBBY2tzIGZvciB0aGUgRkxPV19DTE9TRSBldmVudCBhcmUgY291cGxlZCB0byB0aGUgc2VuZGluZ1xuICAgICAgLy8gb2YgdGhlIHVuYmluZC5cbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9ESVNDT05ORUNULCBmdW5jdGlvbiBvblNlc3Npb25Eb3duKCkge1xuICAgICAgICBmc20uX3NlbmRBY2tzKHRydWUpOyAgICAgICAgICAgIC8vIHNlbmQgYWNrcywgdGhlbi4uLlxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFVuaGFuZGxlZCgpOyAgIC8vIGxldCB0aGUgcGFyZW50IHN0YXRlIGhhbmRsZSB0aGUgcmVtYWluaW5nIHN0ZXBzLlxuICAgICAgfSk7XG5cbiAgICBmbG93VXBGU00uWGZlckluYWN0aXZlID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIENvbnN1bWVyU3RhdGVOYW1lcy5GTE9XX1VQX1hGRVJfSU5BQ1RJVkUsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmbG93VXBGU00sXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihDb25zdW1lckZTTUV2ZW50TmFtZXMuRkxPV19BQ1RJVkVfSU5ELCBmdW5jdGlvbiBvbkZsb3dBY3RpdmVJbmRpY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZmxvd1VwRlNNLlhmZXIpO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLlVuYmluZFNlbnQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgQ29uc3VtZXJTdGF0ZU5hbWVzLlVOQklORF9TRU5ULFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLFxuICAgIH0sIHtcblxuICAgICAgc2VuZFVuYmluZFJlcXVlc3QoKSB7XG4gICAgICAgIC8vIERvbid0IGRvIHRoaXMgb24gZW50cnkgdG8gVU5CSU5ELCBkbyBpdCB3aGVuIHRoZSB1c2VyXG4gICAgICAgIC8vIHdhbnRzIHRvIHVuYmluZFxuICAgICAgICBmc20uX2VuZHBvaW50Q2xlYXIoKTtcblxuICAgICAgICBjb25zdCBjb3JyZWxhdGlvblRhZyA9IHNlc3Npb25JbnRlcmZhY2UuZ2V0Q29ycmVsYXRpb25UYWcoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFNNRkxpYi5BZFByb3RvY29sTWVzc2FnZS5nZXRDbG9zZU1lc3NhZ2VDb25zdW1lcihjb25zdW1lci5mbG93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25UYWcpO1xuICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLnNlbmRDb250cm9sKG1lc3NhZ2UpO1xuICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLmVucXVldWVSZXF1ZXN0KFxuICAgICAgICAgIGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICgpID0+IHRoaXMuaGFuZGxlVW5iaW5kVGltZW91dCgpLFxuICAgICAgICAgIHByb3BlcnRpZXMuY29ubmVjdFRpbWVvdXRJbk1zZWNzLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcmVzcG9uc2UgPT4gdGhpcy5oYW5kbGVVbmJpbmRSZXNwb25zZShyZXNwb25zZSkpO1xuICAgICAgICBMT0dfREVCVUcoJ1NlbnQgY29uc3VtZXIgdW5iaW5kIHJlcXVlc3Qgd2l0aCBhcmd1bWVudHMnLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmbG93SWQ6IGNvbnN1bWVyLmZsb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25UYWcsXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZVVuYmluZFRpbWVvdXQoKSB7XG4gICAgICAgIExPR19JTkZPKCdVbmJpbmQgdGltZW91dCcpO1xuICAgICAgICByZXR1cm4gZnNtLnByb2Nlc3NFdmVudChcbiAgICAgICAgICBuZXcgQ29uc3VtZXJGU01FdmVudCh7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5VTkJJTkRfVElNRU9VVCB9KVxuICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgaGFuZGxlVW5iaW5kUmVzcG9uc2UobXNnKSB7XG4gICAgICAgIGlmIChtc2cubXNnVHlwZSAhPT0gU01GTGliLlNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZS5VTkJJTkQpIHtcbiAgICAgICAgICBMT0dfSU5GTyhgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGUgaW4gYmluZCByZXNwb25zZTogJHtTTUZMaWIuU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLmRlc2NyaWJlKG1zZy5tc2dUeXBlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnNtLnByb2Nlc3NFdmVudChcbiAgICAgICAgICBuZXcgQ29uc3VtZXJGU01FdmVudCh7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5GTE9XX1VOQk9VTkQgfSlcbiAgICAgICAgKTtcbiAgICAgIH0sXG5cbiAgICB9KVxuICAgICAgLmVudHJ5KGZ1bmN0aW9uIG9uRW50cnkoKSB7XG4gICAgICAgIHRoaXMuc2VuZFVuYmluZFJlcXVlc3QoKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oQ29uc3VtZXJGU01FdmVudE5hbWVzLlVOQklORF9USU1FT1VULCBmdW5jdGlvbiBvblVuYmluZFRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsVHJhbnNpdGlvblRvKGZzbS5VbmJpbmRTZW50KTtcbiAgICAgIH0pXG4gICAgICAvLyBUaGUgY2hvaWNlIHBvaW50IHdpbGwgZW1pdCBvbiB0aGlzIHRyYW5zaXRpb24sIG5vdCBvbiBleGl0LCB3aGljaCBpcyBPSzpcbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gcmVwZWF0ZWRseSBkaXNwYXRjaCBcInVuYm91bmRcIiB3aGVuIHRoZSB1bmJpbmRzIGFyZSB0aW1pbmcgb3V0XG4gICAgICAucmVhY3Rpb24oQ29uc3VtZXJGU01FdmVudE5hbWVzLkZMT1dfVU5CT1VORCxcbiAgICAgICAgICAgICAgICAoKSA9PiBmc20udHJhbnNpdGlvblRvVW5ib3VuZChNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuRE9XTikpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgYmVpbmcgYWNjZXB0ZWQgYnkgdGhlIGZsb3cuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtZXNzYWdlIHdhcyBhY2NlcHRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBjb25zdCBtZXNzYWdlSUQgPSBtZXNzYWdlLmdldEd1YXJhbnRlZWRNZXNzYWdlSWQoKTtcbiAgICBjb25zdCBpZHN0ciA9IG1lc3NhZ2VJRC50b1N0cmluZygpO1xuICAgIGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fY29uc3VtZXI7XG5cbiAgICBpZiAoIXRoaXMuX2ZzbURpc3BhdGNoKSB7XG4gICAgICAvLyBXZSdyZSBkaXNjb25uZWN0aW5nLiBEcm9wIHRoZSBtZXNzYWdlLlxuICAgICAgTE9HX1RSQUNFKCdEcm9wcGluZyBtZXNzYWdlIGJlY2F1c2UgdGhpcyBmbG93IGNhbm5vdCBhY2tub3dsZWRnZSBpdCcpO1xuICAgICAgY29uc3VtZXIuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX05PX01BVENISU5HX0NPTlNVTUVSKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc3BvcnRBY2tzID0gdGhpcy5fdHJhbnNwb3J0QWNrcztcbiAgICBjb25zdCBhY2tSZXN1bHQgPSB0cmFuc3BvcnRBY2tzLnRyeVJlY2VpdmUobWVzc2FnZUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdldEd1YXJhbnRlZWRQcmV2aW91c01lc3NhZ2VJZCgpKTtcbiAgICBjb25zdCB0cmFuc3BvcnRBY2tSZXF1aXJlZCA9IHRyYW5zcG9ydEFja3MuYWNrc1BlbmRpbmcgPiB0aGlzLm1heFBlbmRpbmdBY2tzO1xuICAgIHN3aXRjaCAoYWNrUmVzdWx0KSB7XG4gICAgICBjYXNlIFRyYW5zcG9ydEFja1Jlc3VsdC5PSzpcbiAgICAgICAgYnJlYWs7IC8vIGNhcnJ5IG9uXG4gICAgICBjYXNlIFRyYW5zcG9ydEFja1Jlc3VsdC5EVVBMSUNBVEU6XG4gICAgICAgIGNvbnN1bWVyLmluY1N0YXQoU3RhdFR5cGUuUlhfRElTQ0FSRF9EVVBMSUNBVEUpO1xuICAgICAgICAvLyBUd28gb3B0aW9ucyBoZXJlOiBjb3VsZCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByaW5nYnVmZmVyLFxuICAgICAgICAvLyBvciBjb3VsZCBjaGVjayB3aGV0aGVyIHRoZSBJRCBpcyBsZXNzIHRoYW4gcmluZ2J1ZmZlci5mcm9udCgpLlxuICAgICAgICAvLyBVbnRlc3RlZCBhc3N1bXB0aW9uOiBhcml0aG1ldGljIGNvbXBhcmlzb24gb24gYm94ZWQgTG9uZyBhdCBmcm9udCgpXG4gICAgICAgIC8vIGlzIG1vcmUgY29tcHV0YXRpb25hbGx5IGV4cGVuc2l2ZSB0aGFuIG5hdGl2ZSBNYXAoKSBsb29rdXAuXG4gICAgICAgIGlmICghdGhpcy5fYXBwbGljYXRpb25BY2tzLmhhcyhtZXNzYWdlSUQpICYmXG4gICAgICAgICAgICAhdGhpcy5fb2xkVW5hY2tlZC5oYXMoaWRzdHIpKSB7XG4gICAgICAgICAgTE9HX1RSQUNFKCdXaWxsIGFwcGxpY2F0aW9uIGFjayB1bmtub3duIGR1cGxpY2F0ZSBJRCcsIGlkc3RyKTtcbiAgICAgICAgICB0aGlzLl9zZW5kQWNrKFtbbWVzc2FnZUlELCBtZXNzYWdlSURdXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNwb3J0QWNrUmVxdWlyZWQpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kQWNrcyh0cmFuc3BvcnRBY2tSZXF1aXJlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIHJlY2VpdmluZyBkdXBzIHdlIHNob3VsZCBtYWtlIHN1cmUgd2Ugc2VuZFxuICAgICAgICAgIC8vIGFuZCBhY2sgaW4gY2FzZSB3ZSBkb24ndCByZWNlaXZlIGFueSBub24gZHVwbGljYXRlc1xuICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCByZWNlaXZlIGVub3VnaCBkdXBsaWNhdGVzIHRvIGV4Y2VlZFxuICAgICAgICAgIC8vIG1heFBlbmRpbmdBY2tzLiAgRXZlbnR1YWxseSB3ZSB3b3VsZCBidXQgb25seSBhZnRlclxuICAgICAgICAgIC8vIHRoZSAgcm91dGVyIHJldHJhbnNtaXR0ZWQgbWFueSB0aW1lcy5cbiAgICAgICAgICB0aGlzLl9zZXRUcmFuc3BvcnRBY2tUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgVHJhbnNwb3J0QWNrUmVzdWx0Lk9VVF9PRl9PUkRFUjpcbiAgICAgICAgY29uc3VtZXIuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX09VVF9PRl9PUkRFUik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuaGFuZGxlZCB0cmFuc3BvcnQgYWNrIHJlc3VsdCcsIGFja1Jlc3VsdCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25BY2tzLmluc2VydChtZXNzYWdlSUQsIChldmljdGluZykgPT4ge1xuICAgICAgbGV0IGFwcGxpY2F0aW9uQWNrUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIGlmIChldmljdGluZykge1xuICAgICAgICBzd2l0Y2ggKGV2aWN0aW5nLnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBBcHBsaWNhdGlvbkFja1N0YXRlLlVOQUNLRUQ6XG4gICAgICAgICAgICB0aGlzLl9vbGRVbmFja2VkLmFkZChldmljdGluZy5rZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBBcHBsaWNhdGlvbkFja1N0YXRlLkFDS0VEX05PVF9TRU5UOlxuICAgICAgICAgICAgYXBwbGljYXRpb25BY2tSZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFwcGxpY2F0aW9uQWNrU3RhdGUuQUNLRURfU0VOVDpcbiAgICAgICAgICAgIC8vIE9LIHRvIGV2aWN0XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICdVbmhhbmRsZWQgYXBwbGljYXRpb24gYWNrIHN0YXRlJyxcbiAgICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvbkFja1N0YXRlLmRlc2NyaWJlKGV2aWN0aW5nLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWVzc2FnZURpc3BhdGNoLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgIGlmICh0cmFuc3BvcnRBY2tSZXF1aXJlZCB8fCBhcHBsaWNhdGlvbkFja1JlcXVpcmVkKSB7XG4gICAgICAgIExPR19UUkFDRSgnTmVlZCB0byBzZW5kIGFja3M6JyxcbiAgICAgICAgICAgICAgICAgICd0cmFuc3BvcnQnLCB0cmFuc3BvcnRBY2tSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICdhcHBsaWNhdGlvbicsIGFwcGxpY2F0aW9uQWNrUmVxdWlyZWQpO1xuICAgICAgICB0aGlzLl9zZW5kQWNrcyh0cmFuc3BvcnRBY2tSZXF1aXJlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRUcmFuc3BvcnRBY2tUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGxpY2F0aW9uQWNrKG1lc3NhZ2VJZCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIGNvbnN0IGlkc3RyID0gbWVzc2FnZUlkLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5fY29uc3VtZXIuaW5jU3RhdChTdGF0VHlwZS5SWF9BQ0tFRCk7XG5cbiAgICAvLyBXYXMgdGhlIG1lc3NhZ2Ugb2xkLCBhbmQgZGVtb3RlZCB0byBfb2xkVW5hY2tlZD9cbiAgICBpZiAodGhpcy5fb2xkVW5hY2tlZC5kZWxldGUoaWRzdHIpKSB7IC8vIFRydWUgaWYgaWRzdHIgd2FzIG1lbWJlclxuICAgICAgLy8gSXQgd2FzIG9sZC4gQWNrIGltbWVkaWF0ZXNseS5cbiAgICAgIExPR19UUkFDRSgnQXBwbGljYXRpb24gYWNraW5nIG9sZCBtZXNzYWdlIGltbWVkaWF0ZWx5Jyk7XG4gICAgICB0aGlzLl9zZW5kQWNrKFtbbWVzc2FnZUlkLCBtZXNzYWdlSWRdXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVncmVzcyB0aGUgYWNrX3N0YXRlIHRoaXMgd2F5OyBtZXNzYWdlLmFja25vd2xlZGdlKCkgdGhyb3dzIGlmIGNhbGxlZFxuICAgIC8vIG1vcmUgdGhhbiBvbmNlLlxuICAgIHRoaXMuX2FwcGxpY2F0aW9uQWNrcy51cGRhdGVBY2tTdGF0ZShtZXNzYWdlSWQsIEFwcGxpY2F0aW9uQWNrU3RhdGUuQUNLRURfTk9UX1NFTlQpO1xuICAgIHRoaXMuX3NldFRyYW5zcG9ydEFja1RpbWVyKCk7XG4gIH1cblxuICBnZXREZXN0aW5hdGlvbigpIHtcbiAgICB0aGlzLl9lbmRwb2ludEVuc3VyZSgpO1xuICAgIHJldHVybiB0aGlzLl9kZXN0aW5hdGlvbjtcbiAgfVxuXG4gIGlzRGlzY29ubmVjdGVkKCkge1xuICAgIGlmICghdGhpcy5nZXRDdXJyZW50U3RhdGUoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZ2V0QWN0aXZlU3RhdGUoQ29uc3VtZXJTdGF0ZU5hbWVzLlVOQk9VTkQpIHx8XG4gICAgICB0aGlzLmdldEFjdGl2ZVN0YXRlKENvbnN1bWVyU3RhdGVOYW1lcy5VTkJPVU5EX0FXQUlUSU5HX0ZMT1dPUEVOKVxuICAgICk7XG4gIH1cblxuICByZXF1ZXN0U3RhcnREaXNwYXRjaFVzZXIoKSB7XG4gICAgdGhpcy5fdXNlckRpc3BhdGNoID0gdHJ1ZTtcbiAgICB0aGlzLmFwcGx5U3RhcnREaXNwYXRjaCgpO1xuICB9XG5cbiAgcmVxdWVzdFN0YXJ0RGlzcGF0Y2hGU00oKSB7XG4gICAgdGhpcy5fZnNtRGlzcGF0Y2ggPSB0cnVlO1xuICAgIHRoaXMuYXBwbHlTdGFydERpc3BhdGNoKCk7XG4gIH1cblxuICBhcHBseVN0YXJ0RGlzcGF0Y2goKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEaXNwYXRjaCAmJiB0aGlzLl9mc21EaXNwYXRjaCkge1xuICAgICAgdGhpcy5sb2coYFN0YXJ0aW5nIG1lc3NhZ2UgZGlzcGF0Y2ggKGZzbSAke3RoaXMuX2ZzbURpc3BhdGNofSwgdXNlciAke3RoaXMuX3VzZXJEaXNwYXRjaH0pYCk7XG4gICAgICB0aGlzLl9tZXNzYWdlRGlzcGF0Y2guc3RhcnQoKTtcbiAgICAgIHRoaXMuX2xvY2FsTWF4V2luZG93U2l6ZSA9IHRoaXMuX2xvY2FsUHJlZmVycmVkV2luZG93U2l6ZTtcbiAgICAgIHRoaXMuX3NlbmRBY2tzKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgTm90IHN0YXJ0aW5nIG1lc3NhZ2UgZGlzcGF0Y2ggKGZzbSAke3RoaXMuX2ZzbURpc3BhdGNofSwgdXNlciAke3RoaXMuX3VzZXJEaXNwYXRjaH0pYCk7XG4gICAgfVxuICB9XG5cbiAgdHJhbnNpdGlvblRvVW5ib3VuZChldmVudE5hbWUpIHtcbiAgICBjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVyO1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIExPR19UUkFDRSgnRmxvdyBkb3duLCB1c2VyIGRpc2Nvbm5lY3RlZD8nLCBjb25zdW1lci51c2VyRGlzY29ubmVjdGVkKTtcblxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLlVuYm91bmQuQXdhaXRGbG93T3BlbiwgKCkgPT4gdGhpcy5fYWRkRXZlbnRUb0VtaXQoZXZlbnROYW1lKSk7XG4gIH1cblxuICByZXF1ZXN0U3RvcERpc3BhdGNoVXNlcigpIHtcbiAgICB0aGlzLl91c2VyRGlzcGF0Y2ggPSBmYWxzZTtcbiAgICB0aGlzLmxvZyhgU3RvcCBkaXNwYXRjaCB1c2VyIChmc20gJHt0aGlzLl9mc21EaXNwYXRjaH0sIHVzZXIgJHt0aGlzLl91c2VyRGlzcGF0Y2h9KWApO1xuICAgIHRoaXMuX21lc3NhZ2VEaXNwYXRjaC5zdG9wKCk7XG4gIH1cblxuICByZXF1ZXN0U3RvcERpc3BhdGNoRlNNKCkge1xuICAgIHRoaXMuX2ZzbURpc3BhdGNoID0gZmFsc2U7XG4gICAgdGhpcy5sb2coYFN0b3AgZGlzcGF0Y2ggRlNNIChmc20gJHt0aGlzLl9mc21EaXNwYXRjaH0sIHVzZXIgJHt0aGlzLl91c2VyRGlzcGF0Y2h9KWApO1xuICAgIHRoaXMuX3NlbmRBY2tzKHRydWUpO1xuICB9XG5cbiAgX2NsZWFyVHJhbnNwb3J0QWNrVGltZXIoKSB7XG4gICAgaWYgKCF0aGlzLl90cmFuc3BvcnRBY2tUaW1lcikgcmV0dXJuO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydEFja1RpbWVyKTtcbiAgICB0aGlzLl90cmFuc3BvcnRBY2tUaW1lciA9IG51bGw7XG4gIH1cblxuICBfZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRyYW5zcG9ydEFja1RpbWVyKCk7XG4gICAgdGhpcy5fZW5kcG9pbnRDbGVhcigpO1xuICAgIHRoaXMuX2Rlc3RpbmF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VuYWNrZWQgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VEaXNwYXRjaCA9IG51bGw7XG4gICAgdGhpcy5fdHJhbnNwb3J0QWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29uc3VtZXIgPSBudWxsO1xuICAgIHRoaXMuX3Nlc3Npb25JbnRlcmZhY2UgPSBudWxsO1xuICB9XG5cbiAgX2VuZHBvaW50Q2xlYXIoKSB7XG4gICAgdGhpcy5fZW5kcG9pbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgX2VuZHBvaW50RW5zdXJlKCkge1xuICAgIGlmICh0aGlzLl9lbmRwb2ludCkge1xuICAgICAgLy8gVGhlIGVuZHBvaW50LCBkZXN0aW5hdGlvbiBhbmQgYW55IHBvc3NpYmxlIHRvcGljIHN1YnNjcmlwdGlvbiBhcmUgZ2VuZXJhdGVkXG4gICAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLiBVc2UgdGhlIHByZXNlbmNlIG9mIHRoZSBlbmRwb2ludCB0byBkZXRlcm1pbmUgd2hldGhlclxuICAgICAgLy8gYW55IG9mIHRoaXMgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlc3Npb25JbnRlcmZhY2UgPSB0aGlzLl9zZXNzaW9uSW50ZXJmYWNlO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB0aGlzLl9jb25zdW1lci5fcHJvcGVydGllcztcbiAgICBjb25zdCB7IHF1ZXVlRGVzY3JpcHRvciB9ID0gcHJvcGVydGllcztcblxuICAgIGxldCBkZXN0aW5hdGlvbjtcbiAgICBsZXQgZW5kcG9pbnQ7XG4gICAgbGV0IHN1YnNjcmlwdGlvbjtcbiAgICBpZiAocXVldWVEZXNjcmlwdG9yLnR5cGUgPT09IFF1ZXVlVHlwZS5RVUVVRSkge1xuICAgICAgLy8gVGhlIHB1Ymxpc2ggZGVzdGluYXRpb24gbmVlZHMgYSBwcmVmaXguIENyZWF0ZSBhIGRlc3RpbmF0aW9uIGZyb21cbiAgICAgIC8vIHRoZSBkZXNjcmlwdG9yLCB0aGVuIGRlcml2ZSB0aGUgZW5kcG9pbnQgbmFtZSBmcm9tIHRoYXQuXG4gICAgICBkZXN0aW5hdGlvbiA9IHNlc3Npb25JbnRlcmZhY2UuY3JlYXRlRGVzdGluYXRpb25Gcm9tRGVzY3JpcHRvcihxdWV1ZURlc2NyaXB0b3IpO1xuXG4gICAgICAvLyBUaGUgYmluZCB0YXJnZXQgaXMgdGhlIHF1ZXVlIG5hbWUgZW5jb2RlZCBhcyB0aG91Z2ggYSB0b3BpYyAtLSBubyBwcmVmaXhcbiAgICAgIC8vIFVzZSB0aGUgb2Zmc2V0IGluZm9ybWF0aW9uIHRvIGJ1aWxkIGEgYmluZCB0YXJnZXRcbiAgICAgIGVuZHBvaW50ID0gbmV3IFF1ZXVlKHtcbiAgICAgICAgbmFtZTogICBkZXN0aW5hdGlvbi5uYW1lLFxuICAgICAgICB0eXBlOiAgIERlc3RpbmF0aW9uVHlwZS5RVUVVRSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBieXRlczogIGRlc3RpbmF0aW9uLmJ5dGVzLnN1YnN0cihkZXN0aW5hdGlvbi5vZmZzZXQpLFxuICAgICAgfSk7XG5cbiAgICAgIHN1YnNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUXVldWVUeXBlLlRPUElDX0VORFBPSU5UXG4gICAgICBlbmRwb2ludCA9IHF1ZXVlRGVzY3JpcHRvci5uYW1lXG4gICAgICAgID8gc2Vzc2lvbkludGVyZmFjZS5jcmVhdGVEZXN0aW5hdGlvbkZyb21EZXNjcmlwdG9yKHF1ZXVlRGVzY3JpcHRvcilcbiAgICAgICAgOiBuZXcgVG9waWMoeyBuYW1lOiAnXFwwPycsIG9mZnNldDogMCwgYnl0ZXM6ICdcXDAnIH0pO1xuICAgICAgc3Vic2NyaXB0aW9uID0gcHJvcGVydGllcy50b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uIHx8XG4gICAgICAgIHNlc3Npb25JbnRlcmZhY2UuY3JlYXRlVGVtcG9yYXJ5RGVzdGluYXRpb24oRGVzdGluYXRpb25UeXBlLlRPUElDKTtcbiAgICAgIGRlc3RpbmF0aW9uID0gc3Vic2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIFVzaW5nIE9iamVjdC5hc3NpZ24gdG8gZW5mb3JjZSB0aGUgaW52YXJpYW50IHRoYXQgdGhlc2UgdGhyZWUgcHJvcGVydGllcyBhcmUgc2V0IHRvZ2V0aGVyXG4gICAgLy8gb3Igbm90IGF0IGFsbC5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIF9kZXN0aW5hdGlvbjogIGRlc3RpbmF0aW9uLFxuICAgICAgX2VuZHBvaW50OiAgICAgZW5kcG9pbnQsXG4gICAgICBfc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHByb3BlcnRpZXMgb2JqZWN0IChpZiBUVE1QLCB3ZSBtYXkgbW9kaWZ5IGl0IGFnYWluKVxuICAgIHByb3BlcnRpZXMucXVldWVEZXNjcmlwdG9yID0gbmV3IFF1ZXVlRGVzY3JpcHRvcih7XG4gICAgICBuYW1lOiAgICBlbmRwb2ludC5uYW1lLFxuICAgICAgdHlwZTogICAgcXVldWVEZXNjcmlwdG9yLnR5cGUsXG4gICAgICBkdXJhYmxlOiBxdWV1ZURlc2NyaXB0b3IuZHVyYWJsZSxcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXNldExvY2FsQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgX3JlbW90ZVdpbmRvd1NpemU6IDAsXG4gICAgICBfYWN0aXZlOiAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgX2ZzbURpc3BhdGNoOiAgICAgIGZhbHNlLFxuICAgICAgX3VzZXJEaXNwYXRjaDogICAgIHRydWUsIC8vIFVzZXIgZmxvdyBpcyBpbml0aWFsbHkgc3RhcnRlZFxuICAgIH0pO1xuICB9XG5cbiAgX3Jlc2V0UmVtb3RlQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIExPR19UUkFDRSgnSW5pdGlhbGl6aW5nIHRyYW5zcG9ydCBhY2tzJyk7XG4gICAgdGhpcy5fdHJhbnNwb3J0QWNrcyA9IG5ldyBUcmFuc3BvcnRBY2tzKCk7XG5cbiAgICBMT0dfVFJBQ0UoJ0luaXRpYWxpemluZyBhcHBsaWNhdGlvbiBhY2tzJyk7XG4gICAgdGhpcy5fYXBwbGljYXRpb25BY2tzID0gbmV3IEFwcGxpY2F0aW9uQWNrUmluZ0J1ZmZlcihSSU5HX0JVRkZFUl9TSVpFKTtcbiAgICB0aGlzLl9vbGRVbmFja2VkID0gbmV3IFNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgc2luZ2xlIGFjay5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheS48YWNrcGFpcj59IGFwcGxpY2F0aW9uQWNrcyBUaGUgYXBwbGljYXRpb24gYWNrIHJhbmdlcyB0byBzZW5kXG4gICAqIEBtZW1iZXJvZiBDb25zdW1lckZTTVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmRBY2soYXBwbGljYXRpb25BY2tzKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0QWNrID0gU01GTGliLkFkUHJvdG9jb2xNZXNzYWdlLmdldEFjayhcbiAgICAgIHRoaXMuX2NvbnN1bWVyLmZsb3dJZCxcbiAgICAgIHRoaXMuX3RyYW5zcG9ydEFja3MubGFzdFJlY2VpdmVkLFxuICAgICAgdGhpcy53aW5kb3dTaXplLFxuICAgICAgYXBwbGljYXRpb25BY2tzKTtcbiAgICB0aGlzLl9zZXNzaW9uSW50ZXJmYWNlLnNlbmRDb250cm9sKHRyYW5zcG9ydEFjayk7IC8vIE11c3Qgc3VjY2VlZCBvciB0aHJvd1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGN1cnJlbnQgYWNrIHJhbmdlcyB0byBhbiBhY2N1bXVsYXRvci4gQ2FsbCB0aGlzIGZvciBlYWNoIGFwcGxpY2F0aW9uQWNrLlxuICAgKiBXaGVuIGEgcmFuZ2UgZW5kcyAod2UgcmVjZWl2ZSBhbiB1bmFja2VkKSwgb3Igd2UgYXJlIGV4cGxpY3RseSBmbHVzaGluZ1xuICAgKiAoYXBwbGljYXRpb25BY2sgPT09IG51bGwpLCB3ZSBjb252ZXJ0IHRoZSBhY2N1bXVsYXRvciB0byBhY2tzLCBzZW5kIHRoZW0sIHVwZGF0ZSBzdGF0ZSxcbiAgICogYW5kIHJlc2V0IGFjY3VtdWxhdG9ycy5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGF0IGxlYXN0IG9uY2Ugd2l0aCB0aGUgbGFzdCBpbnZvY2F0aW9uIGhhdmluZyBhY2tSYW5nZSA9IG51bGwuXG4gICAqIFRoaXMgaW52b2tlcyB0aGUgZmx1c2ggcGF0aCwgd2hpY2ggaXMgbmVjZXNzYXJ5IGlmIGFueSByYW5nZXMgd2VyZSBpbiBwcm9ncmVzcyxcbiAgICogYW5kIHRoaXMgaXMgdGhlIG9ubHkgcGF0aCB0aGF0IHJlcGVjdHMgdGhlIGZvcmNlVHJhbnNwb3J0QWNrIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2tzUGVuZGluZ1N0YXRlIFN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdGl2aXR5XG4gICAqIEBwYXJhbSB7QXBwbGljYXRpb25BY2t9IGFwcGxpY2F0aW9uQWNrIFRoZSBhY2sgdG8gcHJvY2VzcyBmb3IgYWNrIHJhbmdlcy5cbiAgICogICAgSWYgYG51bGxgLCBhbnkgcGVuZGluZyBhY2tzIGFyZSBmbHVzaGVkIGFuZCBhIHRyYW5zcG9ydCBhY2sgaXMgc2VudCwgaWZcbiAgICogICAgcmVxdWlyZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkQWNrVG9SYW5nZXMoYWNrc1BlbmRpbmdTdGF0ZSwgYXBwbGljYXRpb25BY2sgPSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudFJhbmdlID0gYWNrc1BlbmRpbmdTdGF0ZS5jdXJyZW50UmFuZ2U7XG4gICAgY29uc3QgYWNrUmFuZ2VzID0gYWNrc1BlbmRpbmdTdGF0ZS5hY2tSYW5nZXM7XG5cbiAgICBpZiAoYXBwbGljYXRpb25BY2sgJiYgYXBwbGljYXRpb25BY2suc3RhdGUgIT09IEFwcGxpY2F0aW9uQWNrU3RhdGUuVU5BQ0tFRCkge1xuICAgICAgY3VycmVudFJhbmdlLnB1c2goYXBwbGljYXRpb25BY2spO1xuICAgICAgcmV0dXJuOyAvLyBXYWl0IGZvciBlbmQgb2YgcmFuZ2Ugb3IgZmx1c2hcbiAgICB9XG5cbiAgICAvLyBXZSByZWNlaXZlZCBhbiBVTkFDS0VEIG9yIGEgbnVsbCBhY2sgKGZsdXNoKS4gQ29tcGxldGUgdGhpcyByYW5nZS5cbiAgICBpZiAoY3VycmVudFJhbmdlLmxlbmd0aCkge1xuICAgICAgYWNrUmFuZ2VzLnB1c2goY3VycmVudFJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBmbHVzaGluZyBvciB3ZSd2ZSBoaXQgdGhlIHByb3RvY29sIGxpbWl0IGZvciByYW5nZXMgaW4gYSBzaW5nbGUgYWNrLFxuICAgIC8vIHdlIHNlbmQgYWNrIG1lc3NhZ2VzLCB1cGRhdGUgYWNrIHN0YXRlcyBhbmQgY2xlYXIgdGhlIGFjY3VtdWxhdG9yLlxuICAgIC8vIFRoaXMgY29uZGl0aW9uIHdpbGwgYmUgdHJ1ZSBhdCBsZWFzdCBvbmNlIChtdXN0IGZsdXNoIGF0IHRoZSBlbmQpLlxuICAgIGlmIChhcHBsaWNhdGlvbkFjayA9PT0gbnVsbCB8fFxuICAgICAgICBhY2tSYW5nZXMubGVuZ3RoID09PSBTTUZMaWIuQWRQcm90b2NvbE1lc3NhZ2UuTUFYX0NMSUVOVF9BQ0tfUkFOR0VTKSB7XG4gICAgICAvLyBSZWR1Y2UgZWFjaCByYW5nZSB0byBhIGZpcnN0IGFuZCBsYXN0IElELlxuICAgICAgY29uc3QgYmFyZVJhbmdlcyA9IGFja1Jhbmdlcy5tYXAocmFuZ2UgPT4gW3JhbmdlWzBdLmlkLCByYW5nZVtyYW5nZS5sZW5ndGggLSAxXS5pZF0pO1xuXG4gICAgICBpZiAoYmFyZVJhbmdlcy5sZW5ndGggfHwgYWNrc1BlbmRpbmdTdGF0ZS5mb3JjZVRyYW5zcG9ydEFjaykge1xuICAgICAgICAvLyBXZSBzZW5kIHRoZSByYW5nZXMuIFRoaXMgY291bGQgdGhyb3cuXG4gICAgICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgdGhpcy5fc2VuZEFjayhiYXJlUmFuZ2VzKTtcbiAgICAgICAgLy8gV2FybmluZzogdGhpcyBsb2cgc3RhdGVtZW50IHJlZHVjZXMgZGVidWcgcGVyZm9ybWFuY2UgYnkgMjUlIVxuICAgICAgICBMT0dfVFJBQ0UoXG4gICAgICAgICAgJ1NlbnQgYWNrOiAnLFxuICAgICAgICAgIGBUcmFuc3BvcnQgYWNrOiAke3RoaXMuX3RyYW5zcG9ydEFja3MubGFzdFJlY2VpdmVkfWAsXG4gICAgICAgICAgYEFwcGxpY2F0aW9uIGFja3M6ICR7YmFyZVJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gYmFyZVJhbmdlcy5tYXAoZyA9PiBgWyR7Z1swXX0uLiR7Z1sxXX1dYClcbiAgICAgICAgICAgIDogJ1tdJ31gXG4gICAgICAgICk7XG4gICAgICAgIC8vIElmIHRoZSBpbnRlbnQgd2FzIHRvIGZvcmNlIGEgdHJhbnNwb3J0IGFjaywgdGhhdCBjb25kaXRpb24gaXMgZnVsZmlsbGVkLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRBY2tzLnNldEFja2VkKCk7XG4gICAgICAgIGFja3NQZW5kaW5nU3RhdGUuZm9yY2VUcmFuc3BvcnRBY2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2luY2UgdGhlIHJhbmdlIHNlbmQgc3VjY2VlZGVkLCB1cGRhdGUgdGhlIGFjayBzdGF0ZXMuXG4gICAgICBhY2tSYW5nZXMuZm9yRWFjaCgoYWNrUmFuZ2UpID0+IHtcbiAgICAgICAgYWNrUmFuZ2UuZm9yRWFjaCgoYWNrKSA9PiB7XG4gICAgICAgICAgaWYgKGFjay5zdGF0ZSAhPT0gQXBwbGljYXRpb25BY2tTdGF0ZS5BQ0tFRF9TRU5UKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbkFja3MudXBkYXRlQWNrU3RhdGUoYWNrLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uQWNrU3RhdGUuQUNLRURfU0VOVCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDbGVhciB0aGUgbWFpbiBhY2N1bXVsYXRvciBzaW5jZSBpdCBoYXMgaGl0IHRoZSB3aXJlLlxuICAgICAgYWNrc1BlbmRpbmdTdGF0ZS5hY2tSYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGFjY3VtdWxhdG9yIGZvciB0aGlzIHJhbmdlLlxuICAgIGFja3NQZW5kaW5nU3RhdGUuY3VycmVudFJhbmdlID0gW107XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYWNrbm93bGVkZ2VtZW50cywgYWxvbmcgd2l0aCBhIHdpbmRvdyB1cGRhdGUgZm9yIHRoaXMgZmxvdy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVRyYW5zcG9ydEFjayBgdHJ1ZWAgc2VuZHMgdHJhbnNwb3J0IGFjayBldmVuIGlmIG5vIGFja3MgcGVuZGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmRBY2tzKGZvcmNlVHJhbnNwb3J0QWNrID0gZmFsc2UpIHtcbiAgICB0aGlzLl9jbGVhclRyYW5zcG9ydEFja1RpbWVyKCk7XG5cbiAgICBjb25zdCBhcHBsaWNhdGlvbkFja3MgPSB0aGlzLl9hcHBsaWNhdGlvbkFja3M7XG4gICAgY29uc3QgdHJhbnNwb3J0QWNrcyA9IHRoaXMuX3RyYW5zcG9ydEFja3M7XG5cbiAgICAvLyBUaGlzIHN0YXRlIGlzIHRlbXBvcmFyeSBhbmQgc2hhcmVkIHdpdGggdGhlIGFjayBnZW5lcmF0aW5nIGZ1bmN0aW9uLlxuICAgIGNvbnN0IGFja3NQZW5kaW5nU3RhdGUgPSB7XG4gICAgICBmb3JjZVRyYW5zcG9ydEFjazogZm9yY2VUcmFuc3BvcnRBY2sgfHwgKHRyYW5zcG9ydEFja3MuYWNrc1BlbmRpbmcgPiAwKSxcbiAgICAgIGFja1JhbmdlczogICAgICAgICBbXSxcbiAgICAgIGN1cnJlbnRSYW5nZTogICAgICBbXSxcbiAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGZpcnN0IHJpbmdidWZmZXIgYWNrIHN0YXRlIGlzIGFja2VkIGFuZCB0aGVyZSBhcmUgbm8gdW5hY2tlZCBiZWZvcmUgdGhpcyxcbiAgICAvLyB3ZSBjYW4gY3JlYXRlIGFuIGFjayByYW5nZSB0aGF0IGluY2x1ZGVzIHplcm8uXG4gICAgLy8gSWYgdGhlIGZpcnN0IHJpbmdidWZmZXIgYWNrIHN0YXRlIGlzIHVuYWNrZWQsIHdlIGNhbiBzYXkgbm90aGluZyBhYm91dCB0aGVcbiAgICAvLyByYW5nZSBiZWZvcmUgdGhlIGZpcnN0IGFja2VkIElEIGluIHRoZSByaW5nYnVmZmVyLlxuICAgIGNvbnN0IGZyb250ID0gdGhpcy5fYXBwbGljYXRpb25BY2tzLmZyb250KCk7XG4gICAgaWYgKHRoaXMuX29sZFVuYWNrZWQuc2l6ZSA9PT0gMCAmJiBmcm9udCAmJiBmcm9udC5zdGF0ZSAhPT0gQXBwbGljYXRpb25BY2tTdGF0ZS5VTkFDS0VEKSB7XG4gICAgICAvLyBTdGF0ZSBpcyBhY2tlZF9zZW50IHNvIHdlIGRvbid0IHRyeSB0byB1cGRhdGUgdGhlIHJpbmcgYnVmZmVyLlxuICAgICAgdGhpcy5fYWRkQWNrVG9SYW5nZXMoYWNrc1BlbmRpbmdTdGF0ZSwgWkVST19BUFBfQUNLKTtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCBmcm9udCB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgcmFuZ2UgYnkgdGhlIGl0ZXJhdGlvbi5cbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhY2sgcmFuZ2VzIHVzaW5nIHRoZSBhY2N1bXVsYXRvclxuICAgIGFwcGxpY2F0aW9uQWNrcy5mb3JFYWNoKGFjayA9PiB0aGlzLl9hZGRBY2tUb1JhbmdlcyhhY2tzUGVuZGluZ1N0YXRlLCBhY2spKTtcbiAgICAvLyBGbHVzaCB0aGUgbGFzdCBwZW5kaW5nIGFjayByYW5nZS5cbiAgICB0aGlzLl9hZGRBY2tUb1JhbmdlcyhhY2tzUGVuZGluZ1N0YXRlKTtcblxuICAgIC8vIE9uIHN1Y2Nlc3NmdWwgZXhpdCwgd2UndmUgc2VudCBhbmQgY2xlYXJlZCBhbGwgYWNjdW11bGF0b3JzLCBhbmQgd2UndmUgc2VudFxuICAgIC8vIGEgdHJhbnNwb3J0IGFjayBpZiB3ZSB3ZXJlIHN1cHBvc2VkIHRvIGRvIHRoYXQuXG4gICAgYXNzZXJ0KGFja3NQZW5kaW5nU3RhdGUuZm9yY2VUcmFuc3BvcnRBY2sgPT09IGZhbHNlKTtcbiAgICBhc3NlcnQoYWNrc1BlbmRpbmdTdGF0ZS5jdXJyZW50UmFuZ2UubGVuZ3RoID09PSAwKTtcbiAgICBhc3NlcnQoYWNrc1BlbmRpbmdTdGF0ZS5hY2tSYW5nZXMubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIF9zZXRUcmFuc3BvcnRBY2tUaW1lcigpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0QWNrVGltZXIpIHJldHVybjtcbiAgICBpZiAodGhpcy5fY29uc3VtZXIuZGlzcG9zZWQpIHJldHVybjtcbiAgICB0aGlzLl90cmFuc3BvcnRBY2tUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB0aGlzLl9zZW5kQWNrcyh0cnVlKSxcbiAgICAgIHRoaXMuX2Fja25vd2xlZGdlVGltZW91dEluTXNlY3NcbiAgICApO1xuICB9XG5cbiAgZ2V0IG1heFdpbmRvd1NpemUoKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHRoaXMuX2xvY2FsTWF4V2luZG93U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3RlV2luZG93U2l6ZSB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgZ2V0IHdpbmRvd1NpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4V2luZG93U2l6ZSAtIHRoaXMuX21lc3NhZ2VEaXNwYXRjaC5sZW5ndGg7XG4gIH1cblxuICBnZXQgbWF4UGVuZGluZ0Fja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMud2luZG93U2l6ZSAqIHRoaXMuX2NvbnN1bWVyLl9wcm9wZXJ0aWVzLmFja25vd2xlZGdlVGhyZXNob2xkIC8gMTAwLjA7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25zdW1lckZTTSA9IENvbnN1bWVyRlNNO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1jb25zdW1lci9saWIvY29uc3VtZXItZnNtLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuY29uc3QgQ29uc3VtZXJTdGF0ZU5hbWVzID0ge1xuICBVTkJPVU5EOiAgICAgICAgICAgICAgICAgICdVTkJPVU5EJyxcbiAgVU5CT1VORF9BV0FJVF9TRVNTSU9OX1VQOiAnVU5CT1VORF9BV0FJVF9TRVNTSU9OX1VQJyxcbiAgVU5CT1VORF9BV0FJVF9GTE9XT1BFTjogICAnVU5CT1VORF9BV0FJVF9GTE9XT1BFTicsXG4gIFVOQk9VTkRfQVdBSVRfQU5ZOiAgICAgICAgJ1VOQk9VTkRfQVdBSVRfQU5ZJyxcbiAgQklORF9TRU5UOiAgICAgICAgICAgICAgICAnQklORF9TRU5UJyxcbiAgRkxPV19VUDogICAgICAgICAgICAgICAgICAnRkxPV19VUCcsXG4gIEZMT1dfVVBfWEZFUjogICAgICAgICAgICAgJ0ZMT1dfVVBfWEZFUicsXG4gIEZMT1dfVVBfWEZFUl9JTkFDVElWRTogICAgJ0ZMT1dfVVBfWEZFUl9JTkFDVElWRScsXG4gIFVOQklORF9TRU5UOiAgICAgICAgICAgICAgJ1VOQklORF9TRU5UJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbnN1bWVyU3RhdGVOYW1lcyA9IEVudW0ubmV3KENvbnN1bWVyU3RhdGVOYW1lcyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyL2xpYi9jb25zdW1lci1zdGF0ZS1uYW1lcy5qcyIsImNvbnN0IHtcbiAgQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3IsXG4gIFF1ZXVlRGVzY3JpcHRvcixcbiAgUXVldWVEZXNjcmlwdG9yVmFsaWRhdG9yLFxuICBRdWV1ZVByb3BlcnRpZXMsXG4gIFF1ZXVlUHJvcGVydGllc1ZhbGlkYXRvcixcbiAgUXVldWVUeXBlLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1xdWV1ZScpO1xuY29uc3QgeyBBUElQcm9wZXJ0aWVzVmFsaWRhdG9ycyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgQ2hlY2sgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBNZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1jb25zdW1lci1hY2tub3dsZWRnZS1tb2RlcycpO1xuY29uc3QgeyBPcGVyYXRpb25FcnJvciwgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcblxuY29uc3Qge1xuICB2YWxpZGF0ZUluc3RhbmNlLFxuICB2YWxCb29sZWFuLFxuICB2YWxJbnN0YW5jZSxcbiAgdmFsSXNNZW1iZXIsXG4gIHZhbE51bWJlcixcbiAgdmFsUmFuZ2UsXG4gIHZhbFRvcGljU3RyaW5nT3JFbXB0eSxcbn0gPSBBUElQcm9wZXJ0aWVzVmFsaWRhdG9ycztcblxuZnVuY3Rpb24gdmFsVG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbih0eXBlRGVzYywgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLnF1ZXVlRGVzY3JpcHRvci5nZXRUeXBlKCkgPT09IFF1ZXVlVHlwZS5UT1BJQ19FTkRQT0lOVCkge1xuICAgIGlmIChpbnN0YW5jZS5xdWV1ZURlc2NyaXB0b3IuaXNEdXJhYmxlKCkpIHtcbiAgICAgIGlmICghaW5zdGFuY2UudG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ3RvcGljRW5kcG9pbnRTdWJzY3JpcHRpb24gbXVzdCBiZSBzZXQgd2hlbiBxdWV1ZURlc2NyaXB0b3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWZlcnMgdG8gYSBkdXJhYmxlIHRvcGljIGVuZHBvaW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGluc3RhbmNlLnRvcGljRW5kcG9pbnRTdWJzY3JpcHRpb24pIHtcbiAgICAvLyBpcyBRdWV1ZVR5cGUuUVVFVUVcbiAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ3RvcGljRW5kcG9pbnRTdWJzY3JpcHRpb24gaXMgc2V0LCBidXQgcXVldWVEZXNjcmlwdG9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVycyB0byBhIHF1ZXVlIHRoYXQgaXMgbm90IG9mIHR5cGUgUXVldWVUeXBlLlRPUElDX0VORFBPSU5UJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICB9XG59XG5cbmNvbnN0IE1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXNWYWxpZGF0b3IgPSB7XG4gIHZhbGlkYXRlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgdiA9IHZhbGlkYXRlSW5zdGFuY2UuYmluZChudWxsLCAnTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcycsIGluc3RhbmNlKTtcbiAgICBpZiAoIShpbnN0YW5jZS5xdWV1ZURlc2NyaXB0b3IgaW5zdGFuY2VvZiBBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvciB8fFxuICAgICAgICAgIGluc3RhbmNlLnF1ZXVlRGVzY3JpcHRvciBpbnN0YW5jZW9mIFF1ZXVlRGVzY3JpcHRvcikpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllcyB2YWxpZGF0aW9uOiBxdWV1ZSBkZXNjcmlwdG9yIG11c3QgYmUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhbiBBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvciBvciBhIFF1ZXVlRGVzY3JpcHRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gICAgUXVldWVEZXNjcmlwdG9yVmFsaWRhdG9yLnZhbGlkYXRlKGluc3RhbmNlLnF1ZXVlRGVzY3JpcHRvcik7XG5cbiAgICBpZiAoaW5zdGFuY2UucXVldWVQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucXVldWVEZXNjcmlwdG9yLmR1cmFibGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdxdWV1ZVByb3BlcnRpZXMgY2Fubm90IGJlIHNldCB1bmxlc3MgcXVldWVEZXNjcmlwdG9yIHJlZmVycyB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhIHRlbXBvcmFyeSBxdWV1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0NPTkZMSUNUKTtcbiAgICAgIH1cbiAgICAgIHYoJ3F1ZXVlUHJvcGVydGllcycsIFt2YWxJbnN0YW5jZSwgUXVldWVQcm9wZXJ0aWVzLCAnUXVldWVQcm9wZXJ0aWVzJ10pO1xuICAgICAgUXVldWVQcm9wZXJ0aWVzVmFsaWRhdG9yLnZhbGlkYXRlKGluc3RhbmNlLnF1ZXVlUHJvcGVydGllcyk7XG4gICAgICBpZiAoQ2hlY2suc29tZXRoaW5nKGluc3RhbmNlLnF1ZXVlUHJvcGVydGllcy5hY2Nlc3NUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ3F1ZXVlUHJvcGVydGllcyBjYW5ub3Qgc3BlY2lmeSBhY2Nlc3NUeXBlIGluIGNyZWF0aW9uIG9mIGEgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGVtcG9yYXJ5IHF1ZXVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIFRFIHN1YnNjcmlwdGlvblxuICAgIGlmIChpbnN0YW5jZS5xdWV1ZURlc2NyaXB0b3IudHlwZSA9PT0gUXVldWVUeXBlLlRPUElDX0VORFBPSU5UKSB7XG4gICAgICAvLyBRdWV1ZVR5cGUuVE9QSUNfRU5EUE9JTlRcbiAgICAgIGlmIChpbnN0YW5jZS5xdWV1ZURlc2NyaXB0b3IuZHVyYWJsZSAmJiAhaW5zdGFuY2UudG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ3RvcGljRW5kcG9pbnRTdWJzY3JpcHRpb24gbXVzdCBiZSBzZXQgZm9yIGR1cmFibGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9waWMgZW5kcG9pbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UudG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCd0b3BpY0VuZHBvaW50U3Vic2NyaXB0aW9uIGNhbm5vdCBiZSBzZXQgdW5sZXNzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZXNjcmlwdG9yLnR5cGUgaXMgVE9QSUNfRU5EUE9JTlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICAgIH1cblxuICAgIHYoJ2Nvbm5lY3RUaW1lb3V0SW5Nc2VjcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDUwLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG4gICAgdignY29ubmVjdEF0dGVtcHRzJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgTnVtYmVyLk1BWF9WQUxVRV0pO1xuICAgIHYoJ3RvcGljRW5kcG9pbnRTdWJzY3JpcHRpb24nLCBbdmFsVG9waWNFbmRwb2ludFN1YnNjcmlwdGlvbl0sIFt2YWxUb3BpY1N0cmluZ09yRW1wdHldKTtcblxuICAgIHYoJ2Fja25vd2xlZGdlTW9kZScsIFt2YWxJc01lbWJlciwgTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlLCAnTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlJ10pO1xuICAgIHYoJ2Fja25vd2xlZGdlVGltZW91dEluTXNlY3MnLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAyMCwgMTUwMF0pO1xuICAgIHYoJ2Fja25vd2xlZGdlVGhyZXNob2xkJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgNzVdKTtcbiAgICB2KCdhY3RpdmVJbmRpY2F0aW9uRW5hYmxlZCcsIFt2YWxCb29sZWFuXSk7XG4gICAgdignbm9Mb2NhbCcsIFt2YWxCb29sZWFuXSk7XG4gICAgdignd2luZG93U2l6ZScsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDEsIDI1NV0pO1xuXG4gICAgaWYgKGluc3RhbmNlLmFjdGl2ZUluZGljYXRpb25FbmFibGVkICYmXG4gICAgICBpbnN0YW5jZS5xdWV1ZURlc2NyaXB0b3IudHlwZSAhPT0gUXVldWVUeXBlLlFVRVVFKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgICdNZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzIHZhbGlkYXRpb246IGFjdGl2ZUluZGljYXRpb25FbmFibGVkIG1heSBvbmx5IGJlIHRydWUgZm9yICcgK1xuICAgICAgICAnUVVFVUUgZGVzdGluYXRpb25zJyxcbiAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzVmFsaWRhdG9yID0gTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllc1ZhbGlkYXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL21lc3NhZ2UtY29uc3VtZXItcHJvcGVydGllcy12YWxpZGF0b3IuanMiLCJjb25zdCB7IE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSB9ID0gcmVxdWlyZSgnLi9tZXNzYWdlLWNvbnN1bWVyLWV2ZW50LW5hbWVzJyk7XG5cbmZ1bmN0aW9uIGZvcm1hdEV2ZW50TmFtZSh4KSB7XG4gIHJldHVybiBgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLiR7TWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLmRlc2NyaWJlKHgpfWA7XG59XG5cbmNsYXNzIE1lc3NhZ2VEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IoeyBlbWl0dGVyLCBhdXRvQWNrLCBsb2dnZXIgfSA9IHt9KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICBlbWl0dGVyLFxuICAgICAgcXVldWU6ICAgIFtdLFxuICAgICAgZGlzcGF0Y2g6IHRydWUsXG4gICAgICBmb3JtYXRFdmVudE5hbWUsXG4gICAgICBsb2dnZXIsXG4gICAgfSk7XG4gICAgdGhpcy5fZGlzcGF0Y2hPbmUgPSBhdXRvQWNrID8gdGhpcy5fZGlzcGF0Y2hPbmVBdXRvQWNrIDogdGhpcy5fZGlzcGF0Y2hPbmVCYXJlO1xuICAgIHRoaXMuZW1pdHRlci5zZXRPbkZpcnN0RGlyZWN0TGlzdGVuZXIodGhpcy5fb25GaXJzdE1lc3NhZ2VMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAvLyBBbHRob3VnaCBhIGxpc3RlbmVyIG1heSBub3QgYmUgYXZhaWxhYmxlLCB3ZSBzZXQgaXQgdG8gdHJ1ZSBzbyB0aGF0IHdlIGRldGVjdCBhIHRyYW5zaXRpb24gdG9cbiAgICAvLyBmYWxzZSB3aGVuIHdlIGF0dGVtcHQgdG8gZGlzcGF0Y2ggdGhlIGZpcnN0IG1lc3NhZ2UsIHdoaWNoIHdpbGwgZ2VuZXJhdGUgYSBsb2cgdGhhdFxuICAgIC8vIGRpc3BhdGNoaW5nIGlzIHN0b3BwZWQgZHVlIHRvIGEgbWlzc2luZyBsaXN0ZW5lci5cbiAgICB0aGlzLl9hdmFpbGFibGVMaXN0ZW5lciA9IHRydWU7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoID0gdHJ1ZTtcbiAgICB0aGlzLl9mbHVzaCgpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmRpc3BhdGNoID0gZmFsc2U7XG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxuXG4gIHB1c2gobWVzc2FnZSkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG5cbiAgICBpZiAodGhpcy5kaXNwYXRjaCkge1xuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTE9HX1RSQUNFKGBEaXNwYXRjaCBkaXNhYmxlZCwgbWVzc2FnZSAke21lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpfSBxdWV1ZWQgbG9jYWxseWApO1xuICAgIH1cbiAgfVxuXG4gIF9vbkZpcnN0TWVzc2FnZUxpc3RlbmVyKCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBpZiAoIXRoaXMuX2F2YWlsYWJsZUxpc3RlbmVyKSB7XG4gICAgICBMT0dfREVCVUcoYE1lc3NhZ2UgbGlzdGVuZXIgYXZhaWxhYmxlIGZvciBkaXNwYXRjaGVyLCAke3RoaXMucXVldWUubGVuZ3RofSBtZXNzYWdlcyBxdWV1ZWRgKTtcbiAgICAgIExPR19ERUJVRyhgRGlzcGF0Y2hlciBzdGFydGVkIGFuZCBjb25uZWN0ZWQ6ICR7dGhpcy5kaXNwYXRjaCA/ICd0cnVlJyA6ICdmYWxzZSd9YCk7XG4gICAgICB0aGlzLl9hdmFpbGFibGVMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoKCk7XG4gIH1cblxuICBfZmx1c2goKSB7XG4gICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIC8vIENoZWNrIHdoZXRoZXIgZGlzcGF0Y2ggZW5hYmxlZCBmb3IgZXZlcnkgZWxlbWVudCxcbiAgICAvLyB0byBoYW5kbGUgd2hlbiAjc3RvcCBpcyBjYWxsZWQgZnJvbSBhIG1lc3NhZ2UgaGFuZGxlclxuICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCAmJiB0aGlzLmRpc3BhdGNoICYmICh0aGlzLmVtaXR0ZXIuZGlyZWN0TGlzdGVuZXJDb3VudCgpID4gMCkpIHtcbiAgICAgIHRoaXMuX2Rpc3BhdGNoT25lKHRoaXMucXVldWUuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMuZGlzcGF0Y2ggJiZcbiAgICAgICAgKHRoaXMuZW1pdHRlci5kaXJlY3RMaXN0ZW5lckNvdW50KCkgPT09IDApICYmIHRoaXMuX2F2YWlsYWJsZUxpc3RlbmVyKSB7XG4gICAgICBMT0dfREVCVUcoJ01lc3NhZ2UgZGlzcGF0Y2hpbmcgc3RvcHBlZDogTm8gbWVzc2FnZSBsaXN0ZW5lciByZWdpc3RlcmVkJyk7XG4gICAgICB0aGlzLl9hdmFpbGFibGVMaXN0ZW5lciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIF9kaXNwYXRjaE9uZUF1dG9BY2sobWVzc2FnZSkge1xuICAgIGNvbnN0IHsgTE9HX1dBUk4gfSA9IHRoaXMubG9nZ2VyO1xuICAgIC8vIFNldCB0aGUgY3VycmVudCBvdXRib3VuZCBtZXNzYWdlLCBkaXNwYXRjaCBpdCwgYW5kIGNsZWFyIHRoZSBjdXJyZW50IG91dGJvdW5kIG1lc3NhZ2VcbiAgICBsZXQgY2F1Z2h0ID0gbnVsbDtcblxuICAgIC8vIEF1dG8tYWNrIHVubGVzcyB0aGUgcmVjZWl2ZXIgdGhyb3dzLlxuICAgIGNhdWdodCA9IHRoaXMuX2Rpc3BhdGNoT25lQmFyZShtZXNzYWdlKTtcbiAgICAvLyBPdXRzaWRlIG9mIGV4Y2VwdGlvbiBibG9jayBiZWNhdXNlIHdlIHdhbnQgdG8gdGhyb3cgbm9ybWFsbHkgZnJvbSBtZXNzYWdlLmFja25vd2xlZGdlKClcbiAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICBMT0dfV0FSTihgU3VwcHJlc3NpbmcgbWVzc2FnZSBhY2tub3dsZWRnZW1lbnQgZm9yIG1lc3NhZ2UgJHttZXNzYWdlLmdldEd1YXJhbnRlZWRNZXNzYWdlSWQoKVxuICAgICAgICAgICAgICAgfSBiZWNhdXNlIGNsaWVudCB0aHJldyBleGNlcHRpb24gZnJvbSBsaXN0ZW5lcmAsIGNhdWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERpZCB0aGUgdXNlciBtYW51YWxseSBhY2sgZm9yIHNvbWUgcmVhc29uP1xuICAgICAgaWYgKG1lc3NhZ2UuaXNBY2tub3dsZWRnZWQpIHtcbiAgICAgICAgTE9HX1dBUk4oYENvbnN1bWVyIGNvbmZpZ3VyZWQgdG8gYXV0by1hY2tub3dsZWRnZSBtZXNzYWdlcywgYnV0IG1lc3NhZ2UgJHtcbiAgICAgICAgICAgICAgICAgbWVzc2FnZS5nZXRHdWFyYW50ZWVkTWVzc2FnZUlkKCl9IHdhcyBhcHBsaWNhdGlvbiBhY2tub3dsZWRnZWRgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5hY2tub3dsZWRnZSgpOyAvLyBObywgc28gYWNrIHRoZSBtZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgX2Rpc3BhdGNoT25lQmFyZShtZXNzYWdlKSB7XG4gICAgY29uc3QgeyBMT0dfV0FSTiB9ID0gdGhpcy5sb2dnZXI7XG4gICAgbGV0IGNhdWdodDtcbiAgICAvLyBSZXF1aXJlcyB0aGUgZW1pdHRlcidzIGRpcmVjdCBvcHRpb24gdG8gYmUgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLk1FU1NBR0VcbiAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICBMT0dfV0FSTihgTm8gbGlzdGVuZXJzIHRvIGRpc3BhdGNoIG1lc3NhZ2UgJHttZXNzYWdlLmdldEd1YXJhbnRlZWRNZXNzYWdlSWQoKX1gKTtcbiAgICB9XG4gICAgLy8gU2luY2UgX2Rpc3BhdGNoT25lQmFyZSB1c2VzIGVtaXREaXJlY3QsIHRoaXMgYmVoYXZpb3VyIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiBhbiAnZXJyb3InIGhhbmRsZXIuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0RGlyZWN0KG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAvLyBVc2VyIGNvZGUgdGhyZXcgYW4gZXhjZXB0aW9uXG4gICAgICBjYXVnaHQgPSB0aGlzLmVtaXR0ZXIuZm9ybWF0RXJyb3JFdmVudChleCwgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLk1FU1NBR0UsIG1lc3NhZ2UpO1xuICAgICAgLy8gQWxzbyBwcm9wYWdhdGluZyB0byB0aGUgY29tbW9uIGVycm9yIGhhbmRsZXJcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KCdlcnJvcicsIGNhdWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjYXVnaHQ7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgTWVzc2FnZURpc3BhdGNoZXIgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL21lc3NhZ2UtZGlzcGF0Y2hlci5qcyIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB7IEVudW0gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBMT0dfVFJBQ0UsXG4gICAgICAgIExPR19ERUJVRyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBMb25nIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtY29udmVydCcpO1xuXG5jb25zdCBUcmFuc3BvcnRBY2tSZXN1bHQgPSBFbnVtLm5ldyh7XG4gIE9LOiAgICAgICAgICAgMCxcbiAgRFVQTElDQVRFOiAgICAxLFxuICBPVVRfT0ZfT1JERVI6IDIsXG59KTtcblxuY2xhc3MgVHJhbnNwb3J0QWNrcyB7XG4gIGNvbnN0cnVjdG9yKGlkID0gMCkge1xuICAgIGNvbnN0IGJhc2UgPSB0eXBlb2YgaWQgPT09ICdudW1iZXInID8gTG9uZy5mcm9tTnVtYmVyKGlkLCB0cnVlKSA6IExvbmcuZnJvbVZhbHVlKGlkKTtcbiAgICB0aGlzLmxhc3RBY2tlZCA9IGJhc2U7XG4gICAgdGhpcy5fYWNrc1BlbmRpbmcgPSAwO1xuICB9XG5cbiAgdHJ5UmVjZWl2ZShtZXNzYWdlSUQsIHByZXZNZXNzYWdlSUQpIHtcbiAgICBpZiAodGhpcy5fbGFzdFJlY2VpdmVkLmx0KHByZXZNZXNzYWdlSUQpKSB7XG4gICAgICBMT0dfREVCVUcoYFJlamVjdGluZyBvdXQgb2Ygb3JkZXIgbWVzc2FnZTogJHtwcmV2TWVzc2FnZUlEfSAobGFzdCByZWNlaXZlZDogJHt0aGlzLl9sYXN0UmVjZWl2ZWR9KWApO1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydEFja1Jlc3VsdC5PVVRfT0ZfT1JERVI7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0UmVjZWl2ZWQuZ3RlKG1lc3NhZ2VJRCkpIHtcbiAgICAgIExPR19ERUJVRyhgUmVqZWN0aW5nIGR1cGxpY2F0ZSBtZXNzYWdlOiAke21lc3NhZ2VJRH0gKGxhc3QgcmVjZWl2ZWQ6ICR7dGhpcy5fbGFzdFJlY2VpdmVkfSlgKTtcbiAgICAgIC8vIGR1cGxpY2F0ZSBtZXNzYWdlcyBpbmRpY2F0ZSB0aGUgcm91dGVyIGlzIHJldHJhbnNtaXR0aW5nIGJlY2F1c2UgaXQgZXhwZWN0cyBhIHRyYW5zcG9ydCBhY2tcbiAgICAgIHRoaXMuX2Fja3NQZW5kaW5nKys7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0QWNrUmVzdWx0LkRVUExJQ0FURTtcbiAgICB9XG4gICAgTE9HX1RSQUNFKGBBY2NlcHRpbmcgbWVzc2FnZTogJHttZXNzYWdlSUR9YCk7XG4gICAgdGhpcy5fbGFzdFJlY2VpdmVkID0gbWVzc2FnZUlEO1xuICAgIHRoaXMuX2Fja3NQZW5kaW5nKys7XG4gICAgcmV0dXJuIFRyYW5zcG9ydEFja1Jlc3VsdC5PSztcbiAgfVxuXG4gIHNldEFja2VkKCkge1xuICAgIHRoaXMuX2xhc3RBY2tlZCA9IExvbmcuZnJvbVZhbHVlKHRoaXMuX2xhc3RSZWNlaXZlZCk7XG4gICAgdGhpcy5fYWNrc1BlbmRpbmcgPSAwO1xuICB9XG5cbiAgZ2V0IGFja3NQZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2tzUGVuZGluZztcbiAgfVxuXG4gIGdldCBsYXN0QWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RBY2tlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGJlZ2lubmluZyBvZiB0aGUgYWNrIHNlcXVlbmNlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtMb25nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGFzIGxhc3QgYWNrbm93bGVkZ2VkIElELlxuICAgKi9cbiAgc2V0IGxhc3RBY2tlZCh2YWx1ZSkge1xuICAgIExPR19UUkFDRSgnU2V0dGluZyBsYXN0IGFja2VkOicsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgX2xhc3RBY2tlZDogICAgTG9uZy5mcm9tVmFsdWUodmFsdWUpLFxuICAgICAgX2xhc3RSZWNlaXZlZDogTG9uZy5mcm9tVmFsdWUodmFsdWUpLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGxhc3RSZWNlaXZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdFJlY2VpdmVkO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVHJhbnNwb3J0QWNrcyxcbiAgVHJhbnNwb3J0QWNrUmVzdWx0LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtY29uc3VtZXIvbGliL3RyYW5zcG9ydC1hY2tzLmpzIiwiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIF9sYXN0QWNrZWQ6IExvbmcuZnJvbU51bWJlcigwLCB0cnVlKSxcbiAgX2xhc3RTZW50OiAgTG9uZy5mcm9tTnVtYmVyKDAsIHRydWUpLFxuICBfbmV4dDogICAgICBMb25nLmZyb21OdW1iZXIoMSwgdHJ1ZSksXG59O1xuXG5jb25zdCBsb25nVG9TdHJpbmcgPSB2ID0+IHYudG9TdHJpbmcoMTApO1xuXG5jbGFzcyBNZXNzYWdlSWRzIHtcbiAgY29uc3RydWN0b3IoYXR0cnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIERFRkFVTFRTLCBhdHRycyk7XG4gIH1cblxuICBnZXQgbGFzdEFja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0QWNrZWQ7XG4gIH1cbiAgc2V0IGxhc3RBY2tlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2xhc3RBY2tlZCA9IExvbmcuZnJvbVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGdldCBsYXN0U2VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdFNlbnQ7XG4gIH1cbiAgc2V0TGFzdFNlbnQoaWQpIHtcbiAgICB0aGlzLl9sYXN0U2VudCA9IExvbmcuZnJvbVZhbHVlKGlkKTtcbiAgICB0aGlzLl9uZXh0ID0gdGhpcy5fbGFzdFNlbnQuYWRkKDEpO1xuICB9XG5cbiAgZ2V0IG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHQ7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdsYXN0QWNrZWQnOiBsb25nVG9TdHJpbmcodGhpcy5sYXN0QWNrZWQpLFxuICAgICAgJ2xhc3RTZW50JzogIGxvbmdUb1N0cmluZyh0aGlzLmxhc3RTZW50KSxcbiAgICAgICduZXh0JzogICAgICBsb25nVG9TdHJpbmcodGhpcy5uZXh0KSxcbiAgICB9O1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlSWRzID0gTWVzc2FnZUlkcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9tZXNzYWdlLWlkcy5qcyIsImNvbnN0IHsgQVBJUHJvcGVydGllc1ZhbGlkYXRvcnMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IE1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1wdWJsaXNoZXItYWNrbm93bGVkZ2UtbW9kZXMnKTtcblxuY29uc3Qge1xuICB2YWxpZGF0ZUluc3RhbmNlLFxuICB2YWxCb29sZWFuLFxuICB2YWxJc01lbWJlcixcbiAgdmFsTnVtYmVyLFxuICB2YWxSYW5nZSxcbn0gPSBBUElQcm9wZXJ0aWVzVmFsaWRhdG9ycztcblxuXG5jb25zdCBNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllc1ZhbGlkYXRvciA9IHtcbiAgdmFsaWRhdGUoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB2ID0gdmFsaWRhdGVJbnN0YW5jZS5iaW5kKG51bGwsICdNZXNzYWdlUHVibGlzaGVyUHJvcGVydGllcycsIGluc3RhbmNlKTtcbiAgICB2KCdlbmFibGVkJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCd3aW5kb3dTaXplJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgMjU1XSk7XG4gICAgdignYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2VjcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDIwLCA2MDAwMF0pO1xuICAgIHYoJ2Fja25vd2xlZGdlTW9kZScsIFt2YWxJc01lbWJlciwgTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSwgJ01lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGUnXSk7XG4gICAgdignY29ubmVjdFJldHJ5Q291bnQnLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAwLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG4gICAgdignY29ubmVjdFRpbWVvdXRJbk1zZWNzJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgNTAsIE51bWJlci5NQVhfVkFMVUVdKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzVmFsaWRhdG9yID0gTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXNWYWxpZGF0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvbWVzc2FnZS1wdWJsaXNoZXItcHJvcGVydGllcy12YWxpZGF0b3IuanMiLCJjb25zdCBTTUZMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBGbG93LCBQcml2YXRlRmxvd0V2ZW50TmFtZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWZsb3cnKTtcbmNvbnN0IHsgTG9nRm9ybWF0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1wdWJsaXNoZXItZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1wdWJsaXNoZXItcHJvcGVydGllcycpO1xuY29uc3QgeyBQdWJsaXNoZXJGU00gfSA9IHJlcXVpcmUoJy4vcHVibGlzaGVyLWZzbScpO1xuY29uc3QgeyBQdWJsaXNoZXJGU01FdmVudCB9ID0gcmVxdWlyZSgnLi9wdWJsaXNoZXItZnNtLWV2ZW50Jyk7XG5jb25zdCB7IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMgfSA9IHJlcXVpcmUoJy4vcHVibGlzaGVyLWZzbS1ldmVudC1uYW1lcycpO1xuXG5jb25zdCB7IExPR19XQVJOIH0gPSBuZXcgTG9nRm9ybWF0dGVyKCk7XG5cbmNsYXNzIE1lc3NhZ2VQdWJsaXNoZXIgZXh0ZW5kcyBGbG93IHtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaGVyLiAgVGhpcyBvYmplY3QgbXVzdCBiZSB1c2VkIHRvIHB1Ymxpc2hcbiAgICogR3VhcmFudGVlZCBNZXNzYWdlcyBvbiBhIHNlc3Npb24uXG4gICAqXG4gICAqIFB1Ymxpc2hlcnMgYXJlIGNyZWF0ZWQgb24gc2Vzc2lvbnMuICBJbiB0aGlzIGltcGxlbWVudGF0aW9uIHRoZSBzZXNzaW9uIGZ1bmN0aW9ucyBhcmUgcHJvdmlkZWRcbiAgICogYnkgdGhlIHNlc3Npb25GU00uICBQdWJsaXNoZXJzIHJlcXVpcmUgdGhlIHNlc3Npb24gdG8gcHJvdmlkZVxuICAgKiBiYXNpYyBjb21tdW5pY2F0aW9ucyBmdW5jdGlvbnM6XG4gICAqICAqIHNlbmQgLSBzZW5kIGEgbWVzc2FnZSB0byB0aGUgdHJhbnNwb3J0XG4gICAqICAqIGdldENvcnJlbGF0aW9uVGFnIC0gcmV0dXJuIGEgdW5pcXVlIHRyYW5zcG9ydCBjb3JyZWxhdGlvbiB0YWdcbiAgICogICogZW5xdWV1ZU91dHN0YW5kaW5nQ29ycmVsYXRlZFJlcSAtIGVucXVldWUgYSBjYWxsYmFjayBmb3IgYSByZWNlaXZlZCBtZXNzYWdlXG4gICAqICAgIG9uIGEgY29ycmVsYXRpb24gdGFnXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBFeHBlY3RlZCBzY2hlbWEgaXNcbiAgICogIHtAbGluayBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXN9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uSW50ZXJmYWNlRmFjdG9yeSBUaGUgc2Vzc2lvbiBmb3IgdGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgcHJvcGVydGllcywgc2Vzc2lvbkludGVyZmFjZUZhY3RvcnkgfSA9IHt9KSB7XG4gICAgY29uc3QgYXBwbHlQcm9wZXJ0aWVzID0gbmV3IE1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgIHN1cGVyKGFwcGx5UHJvcGVydGllcywgc2Vzc2lvbkludGVyZmFjZUZhY3RvcnksIHtcbiAgICAgIGRpcmVjdDogTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5BQ0tOT1dMRURHRURfTUVTU0FHRSxcbiAgICAgIGVtaXRzOiAgTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS52YWx1ZXMsIC8vIHN1cGVyIGFkZHMgTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lXG4gICAgfSk7XG4gICAgdGhpcy5fZnNtID0gdGhpcy5fbWFrZUZTTSgpO1xuICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dGb3JtYXR0ZXIoKTtcbiAgICBsb2dnZXIuZm9ybWF0dGVyID0gZnVuY3Rpb24gZm9ybWF0dGVyKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICdbbWVzc2FnZS1wdWJsaXNoZXJdJyxcbiAgICAgICAgLi4uYXJncyxcbiAgICAgIF07XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci53cmFwKHRoaXMubG9nLCB0aGlzKTtcblxuICAgIC8vIERvZXNuJ3QgZW1pdCBhbnl0aGluZyB1bmxlc3Mgc3RhcnRlZDsgd29uJ3Qgc3RhcnQgdW5sZXNzIGJpbmRXYWl0aW5nXG4gICAgdGhpcy5fYmluZFdhaXRpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5vbihQcml2YXRlRmxvd0V2ZW50TmFtZS5CSU5EX1dBSVRJTkcsIHRoaXMuX29uQmluZFdhaXRpbmcuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbihNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkNPTk5FQ1RfRkFJTEVEX0VSUk9SLCB0aGlzLl9vbkJpbmRGYWlsZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vbihNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkRPV04sIHRoaXMuX29uRG93bi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uKE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUuVVAsIHRoaXMuX29uVXAuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfb25CaW5kRmFpbGVkKCkge1xuICAgIHRoaXMuX2JpbmRXYWl0aW5nID0gZmFsc2U7XG4gIH1cblxuICBfb25CaW5kV2FpdGluZygpIHtcbiAgICB0aGlzLl9iaW5kV2FpdGluZyA9IHRydWU7XG4gIH1cblxuICBfb25Eb3duKCkge1xuICAgIHRoaXMuX2JpbmRXYWl0aW5nID0gZmFsc2U7XG4gIH1cblxuICBfb25VcCgpIHtcbiAgICB0aGlzLl9iaW5kV2FpdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21ha2VGU00oKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaXNoZXJGU00oe1xuICAgICAgcHVibGlzaGVyOiAgICAgICAgdGhpcyxcbiAgICAgIG5hbWU6ICAgICAgICAgICAgICdQdWJsaXNoZXJGU00nLFxuICAgICAgc2Vzc2lvbkludGVyZmFjZTogdGhpcy5fc2Vzc2lvbkludGVyZmFjZSxcbiAgICAgIHByb3BlcnRpZXM6ICAgICAgIHRoaXMuX3Byb3BlcnRpZXMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBmbG93IElEIG9mIHRoaXMgZmxvd1xuICAgKi9cbiAgZ2V0IGZsb3dJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmxvd0lkO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xvbmd9IHZhbHVlIFRoZSBmbG93IElEIGZvciB0aGlzIGZsb3dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldCBmbG93SWQodmFsdWUpIHtcbiAgICB0aGlzLl9mbG93SWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcHVibGlzaGVyIG5hbWUgc2V0IGZvciB0aGlzIGZsb3dcbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mbG93TmFtZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBuYW1lIHRvIHNldCBvbiB0aGlzIGZsb3dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgdGhpcy5fZmxvd05hbWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcHVibGlzaGVyIElEIHNldCBvbiB0aGlzIGZsb3dcbiAgICovXG4gIGdldCBwdWJsaXNoZXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaGVySWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcHVibGlzaGVyIElEIHRvIHNldCBvbiB0aGlzIGZsb3dcbiAgICovXG4gIHNldCBwdWJsaXNoZXJJZCh2YWx1ZSkge1xuICAgIHRoaXMuX3B1Ymxpc2hlcklkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXN9IEEgY2xvbmUgb2YgdGhlIHB1Ymxpc2hlcidzIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcy5jbG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAbWVtYmVyb2YgTWVzc2FnZVB1Ymxpc2hlclxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBzdXBlci5jb25uZWN0KCk7XG4gICAgaWYgKCF0aGlzLl9mc20uZ2V0Q3VycmVudFN0YXRlKCkpIHtcbiAgICAgIHRoaXMuX2ZzbS5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWNhdGlvbiBoYXMgZGlzY29ubmVjdGVkIHRoZSBzZXNzaW9uLCBzb1xuICAgKiBkaXNjb25uZWN0cyB0aGUgR3VhcmFudGVlZCBNZXNzYWdlIFB1Ymxpc2hlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXNjb25uZWN0U2Vzc2lvbigpIHtcbiAgICBzdXBlci5fZGlzY29ubmVjdFNlc3Npb24oKTtcbiAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfQ0xPU0UgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZX0gVGhlIG5hbWUgb2YgdGhlIGRpc3Bvc2VkIGV2ZW50IGZvciB0aGlzIGZsb3dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERpc3Bvc2VkRXZlbnQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiBNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkRJU1BPU0VEO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW5jb21pbmcgQUNLIGZvciB0aGUgZ2l2ZW4gbWVzc2FnZSBJRC5cbiAgICogQHBhcmFtIHtMb25nfSBpZCBUaGUgbWVzc2FnZSBpZCBmb3IgYWNrbm93bGVkZ2VtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQWNrKGlkKSB7XG4gICAgdGhpcy5wcm9jZXNzRlNNRXZlbnQobmV3IFB1Ymxpc2hlckZTTUV2ZW50KFxuICAgICAgeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkFDSyB9LFxuICAgICAgeyBhY2s6IGlkIH1cbiAgICApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGluY29taW5nIE5BQ0sgZm9yIHRoZSBnaXZlbiBtZXNzYWdlIElELlxuICAgKiBAcGFyYW0ge0xvbmd9IGlkIFRoZSBtZXNzYWdlIGlkIGZvciBhY2tub3dsZWRnZW1lbnQuXG4gICAqIEBwYXJhbSB7QWRDdHJsTWVzc2FnZX0gY3RybE1lc3NhZ2UgVGhlIE5BQ0sgbWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTmFjayhpZCwgY3RybE1lc3NhZ2UpIHtcbiAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgUHVibGlzaGVyRlNNRXZlbnQoXG4gICAgICB7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuQUNLIH0sXG4gICAgICB7IG5hY2s6IGlkLCBjdHJsTWVzc2FnZSB9XG4gICAgKSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBoYW5kbGVVbmNvcnJlbGF0ZWRDb250cm9sTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgbXNnVHlwZSA9IG1lc3NhZ2UubXNnVHlwZTtcbiAgICBjb25zdCB7IFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSB9ID0gU01GTGliO1xuICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgY2FzZSBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xJRU5UQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaWQgPSBtZXNzYWdlLmdldExhc3RNc2dJZEFja2VkKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc21mSGVhZGVyLnBtX3Jlc3Bjb2RlID4gMjk5KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU5hY2soaWQsIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUFjayhpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZS5DTElFTlROQUNLOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaWQgPSBtZXNzYWdlLmdldExhc3RNc2dJZEFja2VkKCk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVOYWNrKGlkLCBtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xPU0VQVUJGTE9XOlxuICAgICAgICB0aGlzLnByb2Nlc3NGU01FdmVudChuZXcgUHVibGlzaGVyRlNNRXZlbnQoXG4gICAgICAgICAgeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfVU5CT1VORCB9KVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIExPR19XQVJOKGBEcm9wcGluZyB1bmhhbmRsZWQgQUQgY29udHJvbCBtZXNzYWdlIGZvciAke3RoaXN9YCxcbiAgICAgICAgICAgICAgICAgU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLmRlc2NyaWJlKG1zZ1R5cGUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgYW4gQUQgbWVzc2FnZSBmb3IgcHVibGlzaGluZyBvbiB0aGlzIGZsb3cuXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gZGF0YU1zZyBUaGUgbWVzc2FnZSB0byBiZSBwcmVwYXJlZCBmb3IgcHVibGlzaGluZy5cbiAgICogQHJldHVybnMge1RyYW5zcG9ydFJldHVybkNvZGV9IHRyYW5zcG9ydCBsZXZlbCByZXR1cm5Db2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlQWRNZXNzYWdlQW5kU2VuZChkYXRhTXNnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZzbS5wcmVwYXJlQWRNZXNzYWdlQW5kU2VuZChkYXRhTXNnKTtcbiAgfVxuXG4gIGlzQmluZFdhaXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmRXYWl0aW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IEZvcm1hdHRlZCBpbnNwZWN0b3Igb3V0cHV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3VwZXJbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSwge1xuICAgICAgJ25hbWUnOiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgJ3B1Ymxpc2hlcklkJzogdGhpcy5wdWJsaXNoZXJJZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3QodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhlIEZTTSBhc3NvY2lhdGVkIHdpdGggdGhpcyBmbG93LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2Rpc3Bvc2VGU00oKSB7XG4gICAgdGhpcy5wcm9jZXNzRlNNRXZlbnQobmV3IFB1Ymxpc2hlckZTTUV2ZW50KHsgbmFtZTogUHVibGlzaGVyRlNNRXZlbnROYW1lcy5ESVNQT1NFIH0pKTtcbiAgfVxuXG4gIF9pc0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnNtLmlzRGlzY29ubmVjdGVkKCk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5NZXNzYWdlUHVibGlzaGVyID0gTWVzc2FnZVB1Ymxpc2hlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LW1lc3NhZ2UtcHVibGlzaGVyL2xpYi9tZXNzYWdlLXB1Ymxpc2hlci5qcyIsImNvbnN0IFNNRkxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zbWYnKTtcbmNvbnN0IHsgRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIsXG4gICAgICAgIEVycm9yU3ViY29kZSxcbiAgICAgICAgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBMb2dGb3JtYXR0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTWVzc2FnZUlkcyB9ID0gcmVxdWlyZSgnLi9tZXNzYWdlLWlkcycpO1xuY29uc3QgeyBNZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtcHVibGlzaGVyLWFja25vd2xlZGdlLW1vZGVzJyk7XG5jb25zdCB7IE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1wdWJsaXNoZXItZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgUHJpdmF0ZUZsb3dFdmVudE5hbWUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mbG93Jyk7XG5jb25zdCB7IFB1Ymxpc2hlckZTTUV2ZW50IH0gPSByZXF1aXJlKCcuL3B1Ymxpc2hlci1mc20tZXZlbnQnKTtcbmNvbnN0IHsgUHVibGlzaGVyRlNNRXZlbnROYW1lcyB9ID0gcmVxdWlyZSgnLi9wdWJsaXNoZXItZnNtLWV2ZW50LW5hbWVzJyk7XG5jb25zdCB7IFB1Ymxpc2hlclN0YXRlTmFtZXMgfSA9IHJlcXVpcmUoJy4vcHVibGlzaGVyLXN0YXRlLW5hbWVzJyk7XG5jb25zdCB7IFN0YXRlLCBTdGF0ZU1hY2hpbmUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mc20nKTtcbmNvbnN0IHsgU3RhdFR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zdGF0cycpO1xuY29uc3QgeyBUcmFuc3BvcnRSZXR1cm5Db2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdHJhbnNwb3J0Jyk7XG5cbmNvbnN0IENvbm5lY3RSZWFzb24gPSB7XG4gIElOSVQ6ICAgICAwLCAvLyBuZXZlciBjb25uZWN0ZWQ6IG1lc3NhZ2UgcmVudW1iZXJpbmcgcmVxdWlyZWRcbiAgUkVTVU1FOiAgIDEsIC8vIGNvbm5lY3RlZCBiZWZvcmVcbiAgRkFJTE9WRVI6IDIsIC8vIGFmdGVyIGEgRFIgZmFpbG92ZXI6IG1lc3NhZ2UgcmVudW1iZXJpbmcgYW5kIG1lc3NhZ2UgcmVwdWJsaXNoIGV2ZW50IHJlcXVpcmVkXG59O1xuXG5jbGFzcyBQdWJsaXNoZXJGU00gZXh0ZW5kcyBTdGF0ZU1hY2hpbmUge1xuICBjb25zdHJ1Y3Rvcih7IHB1Ymxpc2hlciwgbmFtZSwgc2Vzc2lvbkludGVyZmFjZSwgcHJvcGVydGllcyB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWUgfSk7XG4gICAgLyoqIEB0eXBlIHtNZXNzYWdlUHVibGlzaGVyfSAqL1xuICAgIGNvbnN0IGZzbSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBmc20uZ2V0Q3VycmVudFN0YXRlKCk7XG4gICAgICByZXR1cm4gc3RhdGUgPyBzdGF0ZS5nZXROYW1lKCkgOiAnPG5vdCBydW5uaW5nPic7XG4gICAgfTtcbiAgICB0aGlzLmxvZ2dlciA9IG5ldyBMb2dGb3JtYXR0ZXIoKC4uLmFyZ3MpID0+IFtcbiAgICAgIGBbc2Vzc2lvbj0ke3Nlc3Npb25JbnRlcmZhY2Uuc2Vzc2lvbklkSGV4fV1gLFxuICAgICAgYFttZXNzYWdlLXB1Ymxpc2hlci1mc209JHtwdWJsaXNoZXIuZmxvd0lkRGVjfV1gLFxuICAgICAgYFske2N1cnJlbnRTdGF0ZSgpfV1gLFxuICAgICAgLi4uYXJncyxcbiAgICBdKTtcbiAgICB0aGlzLmxvZyA9IHRoaXMubG9nZ2VyLndyYXAodGhpcy5sb2csIHRoaXMpO1xuICAgIGNvbnN0IHtcbiAgICAgIExPR19UUkFDRSxcbiAgICAgIExPR19ERUJVRyxcbiAgICAgIExPR19JTkZPLFxuICAgIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgX3B1Ymxpc2hlcjogICAgICAgICAgICAgICAgIHB1Ymxpc2hlcixcbiAgICAgIF9hY2tub3dsZWRnZU1vZGU6ICAgICAgICAgICBwcm9wZXJ0aWVzLmFja25vd2xlZGdlTW9kZSxcbiAgICAgIF9hY2tub3dsZWRnZVRpbWVvdXRJbk1zZWNzOiBwcm9wZXJ0aWVzLmFja25vd2xlZGdlVGltZW91dEluTXNlY3MsXG4gICAgICBfc2Vzc2lvbkludGVyZmFjZTogICAgICAgICAgc2Vzc2lvbkludGVyZmFjZSxcbiAgICAgIF93aW5kb3dTaXplOiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLndpbmRvd1NpemUsXG4gICAgICBfc3RhdGVFdmVudHM6ICAgICAgICAgICAgICAgW10sXG4gICAgfSk7XG4gICAgLy8gVGhlIHB1Ymxpc2hlciBpcyBub3QgZXZlbiBjb25zdHJ1Y3RlZCB3aGVuIHB1Ymxpc2hlclByb3BlcnRpZXMuZW5hYmxlZCBpcyBmYWxzZVxuICAgIC8vIHNvIHdlIGNvdWxkIGp1c3Qgc2V0IF9ndWFyYW50ZWVkRW5hYmxlZCB0byB0cnVlLCBidXQgbGV0cyBiZSB0aG9yb3VnaCBhcyBhdFxuICAgIC8vIHNvbWUgcG9pbnQgd2UgbWF5IHdhbnQgdG8gaGF2ZSBzZW5kQURNZXNzYWdlKCkgYmUgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIGFsbFxuICAgIC8vIGVycm9ycy4gQXMgaXQgaXMsIHdoZW4gcHVibGlzaGVyIHByb3BlcnRpZXMgZW5hYmxlZCBpcyBmYWxzZSwgdGhlIHNlc3Npb24tZnNtXG4gICAgLy8gdGhyb3dzIGFuIGVycm9yIGFuZCB3aGVuIHRoZSBtZXNzYWdlLXNwb29sIGlzIHNodXRkb3duIChjbG9zZS1mbG93IHJlY2VpdmVkKSB0aGVcbiAgICAvLyBwdWJsaXNoZXItZnNtIHRodG93cyBhbmQgZXJyb3IuXG4gICAgdGhpcy5fZ3VhcmFudGVlZEVuYWJsZWQgPSBwcm9wZXJ0aWVzLmVuYWJsZWQ7XG4gICAgdGhpcy5fc2VuZFdpbmRvdyA9IHByb3BlcnRpZXMud2luZG93U2l6ZTtcbiAgICB0aGlzLl9yZXNldENvbm5lY3RlZEluZm8oKTtcbiAgICB0aGlzLl9ub3RpZmllZFdpbmRvd0Nsb3NlZCA9IGZhbHNlO1xuICAgIC8vIFdlIG5lZWQgYSBib29sZWFuIHRvIHRyYWNrIHRoZSB0cmFuc3BvcnQgZmxvd1xuICAgIC8vIGNvbnRyb2xsZWQgc3RhdGUuIHByZXBhcmVBZE1lc3NhZ2VBbmRTZW5kIGlzIGNhbGxlZCBieSB0aGVcbiAgICAvLyBzZXNzaW9uIHRvIHByZXBhcmUgYSBtZXNzYWdlIGZvciBwdWJsaXNoIGFuZCB3ZVxuICAgIC8vIG5lZWQgdG8gcmV0dXJuIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBmbG93IGNvbnRyb2xsZWRcbiAgICAvLyB3aXRob3V0IGludm9raW5nIHRoZSBGU00gb3IgY2FsbGluZyBtZXRob2RzIG9uIHRoZVxuICAgIC8vIEZTTS5cbiAgICAvLyBXZSBjb25zaWRlciBhbGwgZG93biBzdGF0ZXMgYW5kIGFsbCByZXNlbmRpbmcgc3RhdGVzIGVxdWFsXG4gICAgLy8gdG8gZmxvdy1jb250cm9sbGVkIGFzIGluIGFsbCBzdGF0ZXMgbWUgbXVzdCBxdWV1ZSB0aGUgbWVzc2FnZVxuICAgIC8vIHRvIHRoZSB1bmFja2VkIGxpc3QgYW5kIG5vdCBhdHRlbXB0IHRvIHNlbmQgZGlyZWN0bHkuXG4gICAgLy8gVGhpcyBpcyBzdHJpY3RseSBhIHBlcmZvcm1hbmNlIGlzc3VlLlxuICAgIHRoaXMuX3RyYW5zcG9ydEZsb3dDb250cm9sbGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuaW5pdGlhbChmdW5jdGlvbiBvbkluaXRpYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlclVuYm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExPR19UUkFDRShgU3RhcnRpbmcgJHtjb250ZXh0LmdldFN0YXRlTWFjaGluZSgpLmdldE5hbWUoKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgZnNtLnVuaGFuZGxlZEV2ZW50UmVhY3Rpb24oZnVuY3Rpb24gb25VbmhhbmRsZWRFdmVudChldmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC5nZXROYW1lKCkpIHtcbiAgICAgICAgY2FzZSBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfVU5CT1VORDpcbiAgICAgICAgICAvLyB0aGUgcm91dGVyIGhhcyBjbG9zZWQgdGhlIGZsb3csIGxpa2VseSBkdWUgdG8gb3BlcmF0b3JcbiAgICAgICAgICAvLyBzaHV0ZG93biBvbiB0aGUgbWVzc2FnZSBzcG9vbC4gVGhyb3cgb24gYW55IGF0dGVtcHRcbiAgICAgICAgICAvLyB0byBwdWJsaXNoXG4gICAgICAgICAgdGhpcy5fZ3VhcmFudGVlZEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9wdWJsaXNoZXIuZW1pdChNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkdVQVJBTlRFRURfTUVTU0FHSU5HX0RPV04pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25UbyhcbiAgICAgICAgICAgIGZzbS5QdWJsaXNoZXJVbmJvdW5kLFxuICAgICAgICAgICAgKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgTE9HX1RSQUNFKGBSZWNlaXZlZCBjbG9zZSBwdWJsaXNoZXIgZm9yICR7Y29udGV4dC5nZXRTdGF0ZU1hY2hpbmUoKS5nZXROYW1lKCl9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkRJU1BPU0U6XG4gICAgICAgICAgTE9HX1RSQUNFKCdSZWNlaXZlZCBkaXNwb3NlIHJlcXVlc3QnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlRSQU5TUE9SVF9GVUxMOlxuICAgICAgICAgIExPR19UUkFDRSgnUmVjZWl2ZWQgVFJBTlNQT1JUX0ZVTEwnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkNBTl9TRU5EOlxuICAgICAgICAgIC8vIFRoaXMgaXMgb2sgYmVjYXVzZSB0aGUgc2Vzc2lvbiBqdXN0IHNlbmRzIHRoZSBwdWJsaXNoZXIgQ0FOX1NFTkQgd2hlbmV2ZXIgcmVjZWl2ZWRcbiAgICAgICAgICAvLyBmcm9tIHRyYW5zcG9ydCwgZXZlbiBpZiB0aGUgcHVibGlzaGVyIGlzIG5vdCBpbiB1c2UsIG9yIGhhc24ndCBjYXVzZWQgdGhlIGZsb3cgY29udHJvbFxuICAgICAgICAgIExPR19UUkFDRSgnUmVjZWl2ZWQgQ0FOX1NFTkQgd2hlbiBub3QgZmxvdyBjb250cm9sbGVkJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgTE9HX1RSQUNFKGBJZ25vcmluZyBldmVudCAke2V2ZW50LmdldE5hbWUoKX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuXG4gICAgZnNtLlB1Ymxpc2hlclVuYm91bmQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgUHVibGlzaGVyU3RhdGVOYW1lcy5VTkJPVU5ELFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLFxuICAgIH0sIHtcbiAgICAgIGVtaXREb3duQW5kQmluZFdhaXRpbmcoKSB7XG4gICAgICAgIExPR19UUkFDRSgnRW1pdCBkb3duIGFuZCBiaW5kIHdhaXRpbmcnKTtcbiAgICAgICAgcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5ET1dOKTtcbiAgICAgICAgcHVibGlzaGVyLmVtaXQoUHJpdmF0ZUZsb3dFdmVudE5hbWUuQklORF9XQUlUSU5HKTtcbiAgICAgIH0sXG4gICAgfSlcbiAgICAgIC5lbnRyeShmdW5jdGlvbiBvbkVudHJ5KCkge1xuICAgICAgICB0aGlzLmVtaXREb3duQW5kQmluZFdhaXRpbmcoKTtcbiAgICAgICAgZnNtLl9iaW5kUmV0cnlDb3VudCA9IHByb3BlcnRpZXMuYmluZFJldHJ5Q291bnQ7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19VTkJPVU5ELCBmdW5jdGlvbiBvbkZsb3dVbmJpbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbigpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihQdWJsaXNoZXJGU01FdmVudE5hbWVzLlNFU1NJT05fVVAsIGZ1bmN0aW9uIG9uU2Vzc2lvblVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlck9wZW5GbG93U2VudCk7XG4gICAgICB9KTtcblxuICAgIGZzbS5QdWJsaXNoZXJPcGVuRmxvd1NlbnQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgUHVibGlzaGVyU3RhdGVOYW1lcy5PUEVORkxPV1NFTlQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20sXG4gICAgfSwge1xuICAgICAgZW1pdE9wZW5GbG93RmFpbGVkRXJyb3IoZGV0YWlscykge1xuICAgICAgICBwdWJsaXNoZXIuZW1pdChNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkNPTk5FQ1RfRkFJTEVEX0VSUk9SLCBkZXRhaWxzKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QWRQcm90b2NvbE1lc3NhZ2V9IGFkcE1zZyBBbiBPUEVORkxPVyByZXNwb25zZS5cbiAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGUgYW4gaW5jb21pbmcgR3VhcmFudGVlZCBNZXNzYWdpbmcgUHJvdG9jb2wgTWVzc2FnZS5cbiAgICAgICAqIEByZXR1cm5zIHs/fSBUaGUgcmVzdWx0IG9mIHByb2Nlc3NpbmcgYW4gZXZlbnQsIG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGRpc3BhdGNoZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBoYW5kbGVPcGVuRmxvd1Jlc3BvbnNlKGFkcE1zZykge1xuICAgICAgICBjb25zdCBzbWZSZXNwSGVhZGVyID0gYWRwTXNnLnNtZkhlYWRlcjtcbiAgICAgICAgY29uc3QgcmVzcENvZGUgPSBzbWZSZXNwSGVhZGVyLnBtX3Jlc3Bjb2RlO1xuICAgICAgICAvKlxuICAgICAgICAgKiBBc3N1cmVkIENvbnRyb2wgUHJvdG9jb2wgbWVzc2FnZXMgYXJlIHJlY2VpdmVkIG9uIHB1Ymxpc2hlciBhbmQgY29uc3VtZXIgZmxvd3MuIFRoZVxuICAgICAgICAgKiBtZXNzYWdlIHR5cGVzIGZvciBlYWNoIGFyZSB1bmlxdWUsIHNvIHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciBpdCBpcyBhIHB1Ymxpc2hlciBvclxuICAgICAgICAgKiBjb25zdW1lciBieSBtZXNzYWdlIHR5cGUuICBBIHNwZWNpZmljIHB1Ymxpc2hlciBvciBjb25zdW1lciBpcyBmb3VuZCBieSB0aGUgZmxvd0lkLCBvclxuICAgICAgICAgKiBieSB0aGUgY29ycmVsYXRpb24gdGFnIGluIHRoZSBjYXNlIG9mIE9QRU4tRkxPVyAocHVibGlzaGVyKSBvciBCSU5EIChjb25zdW1lcikgcmVzcG9uc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGFkcE1zZy5tc2dUeXBlICE9PSBTTUZMaWIuU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLk9QRU5QVUJGTE9XKSB7XG4gICAgICAgICAgcmV0dXJuIGZzbS5wcm9jZXNzRXZlbnQobmV3IFB1Ymxpc2hlckZTTUV2ZW50KFxuICAgICAgICAgICAgICB7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19GQUlMRUQgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybkNvZGU6ICByZXNwQ29kZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFVuZXhwZWN0ZWQgcmVzcG9uc2U6ICR7U01GTGliLlNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZS5kZXNjcmliZShhZHBNc2cubXNnVHlwZSl9YCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIHJlc3BvbnNlIGNvZGUgd2lsbCBpbmRpY2F0ZSB3aGV0aGVyIHdlIGNyZWF0ZSBhIFBVQl9GTE9XX1VQICgyMDAgT0spIGV2ZW50XG4gICAgICAgICAqIG9yIGEgUFVCX0ZMT1dfRkFJTCAoYW55IG90aGVyIHJlc3BvbnNlKSBldmVudCwgb3IgdHJlYXQgdGhpcyBhcyBhbiBpbnZhbGlkXG4gICAgICAgICAqIG1lc3NhZ2UgKHJlY2VpdmVkIGEgT1BFTi1QVUItRkxPVyByZXF1ZXN0KS5cbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKHJlc3BDb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gRHJvcCBtZXNzYWdlIGFuZCBpbmNyZW1lbnQgc3RhdHNcbiAgICAgICAgICBwdWJsaXNoZXIuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX1NNRl9VTktOT1dOX0VMRU1FTlQpO1xuICAgICAgICAgIExPR19ERUJVRyhgRHJvcCBPcGVuLVB1Ymxpc2hlci1GbG93IFJlcXVlc3QgbWVzc2FnZSBvbiBzZXNzaW9uSWQgMHgke1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLnNlc3Npb25JZEhleH1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgY29uc3QgcmVzcFN0ciA9IHNtZlJlc3BIZWFkZXIucG1fcmVzcHN0cjtcbiAgICAgICAgICBjb25zdCBtYXBwZWRTdWJjb2RlID0gRXJyb3JSZXNwb25zZVN1YmNvZGVNYXBwZXIuZ2V0QURFcnJvclN1YmNvZGUocmVzcENvZGUsIHJlc3BTdHIpO1xuICAgICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KG5ldyBQdWJsaXNoZXJGU01FdmVudChcbiAgICAgICAgICAgIHsgbmFtZTogUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX0ZBSUxFRCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdWJjb2RlOiAgICAgbWFwcGVkU3ViY29kZSxcbiAgICAgICAgICAgICAgcmV0dXJuQ29kZTogIHJlc3BDb2RlLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcmVzcFN0cixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIExPR19UUkFDRSgnSGFuZGxpbmcgT1BFTlBVQkZMT1cgbWVzc2FnZScpO1xuXG4gICAgICAgIC8vIHR5cGljYWwgcmVzcG9uc2U6IHsgbGFzdG1zZ2lkYWNrZWQgd2luZG93IGZsb3dpZCBmbG93bmFtZSBwdWJsaXNoZXJfaWQgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RNc2dJREFja2VkID0gYWRwTXNnLmdldExhc3RNc2dJZEFja2VkKCk7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGFkcE1zZy5nZXRXaW5kb3coKTtcbiAgICAgICAgY29uc3QgZmxvd0lkID0gYWRwTXNnLmdldEZsb3dJZCgpO1xuICAgICAgICBjb25zdCBmbG93TmFtZSA9IGFkcE1zZy5nZXRGbG93TmFtZSgpO1xuICAgICAgICBjb25zdCBwdWJsaXNoZXJJZCA9IGFkcE1zZy5nZXRQdWJsaXNoZXJJZCgpO1xuXG4gICAgICAgIExPR19ERUJVRyhgT1BFTlBVQkZMT1cgcmVzcG9uc2UgYXR0cmlidXRlczogbGFzdE1zZ0lEQWNrZWQ9JHtsYXN0TXNnSURBY2tlZH0gd2luZG93PSR7d2luZG93fSBmbG93SWQ9JHtmbG93SWR9IGZsb3dOYW1lPSR7Zmxvd05hbWV9IHB1Ymxpc2hlcklkPSR7cHVibGlzaGVySWR9YCk7XG5cbiAgICAgICAgTE9HX1RSQUNFKGBMb2NhbCBiZWZvcmUgaGFuZGxpbmcgcmVzcG9uc2U6ICR7ZnNtLl9tZXNzYWdlSWRzfWApO1xuXG4gICAgICAgIGlmICh3aW5kb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgbmV3IFB1Ymxpc2hlckZTTUV2ZW50KHsgbmFtZTogUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX0ZBSUxFRCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246ICdXaW5kb3cgcGFyYW1ldGVyIG5vdCBmb3VuZCcgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cgPiB0aGlzLl93aW5kb3dTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGZzbS5wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfRkFJTEVEIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogJ0ludmFsaWQgd2luZG93IG5lZ290aWF0aW9uJyB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlIHNlbmRXaW5kb3cgYnkgdGhlIHNpemUgb2YgdW5BY2tlZExpc3QgYnV0IGRvIG5vdCByZWR1Y2UgYmVsb3cgemVyb1xuICAgICAgICBmc20uX3NlbmRXaW5kb3cgPSB3aW5kb3cgLSBmc20uX3VuYWNrZWRMaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGZzbS5fc2VuZFdpbmRvdyA8IDApIGZzbS5fc2VuZFdpbmRvdyA9IDA7XG5cbiAgICAgICAgLy8gdXBkYXRlIHB1Ymxpc2hlciBpbmZvIGJlZm9yZSByZW51bWJlcmluZ1xuICAgICAgICBPYmplY3QuYXNzaWduKGZzbS5fcHVibGlzaGVyLCB7XG4gICAgICAgICAgbmFtZTogZmxvd05hbWUsXG4gICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgIHB1Ymxpc2hlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgbWF5IGhhdmUgYmVlbiBkaXNhYmxlZCBieSBhIHByZXZpb3VzIGNsb3NlRmxvdyBtZXNzc2FnZSwgbm93IHRoYXRcbiAgICAgICAgLy8gd2Uga25vdyBodGUgbWVzc2FnZSBzcG9vbCBpcyBlbmFibGVkIGFnYWluLCBzZXQgX2d1YXJhbnRlZWRFbmFibGVkIGJhY2tcbiAgICAgICAgLy8gdG8gdHJ1ZVxuICAgICAgICBmc20uX2d1YXJhbnRlZWRFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKGZzbS5fY29ubmVjdFJlYXNvbiA9PT0gQ29ubmVjdFJlYXNvbi5JTklUKSB8fFxuICAgICAgICAgIChmc20uX2Nvbm5lY3RSZWFzb24gPT09IENvbm5lY3RSZWFzb24uRkFJTE9WRVIpKSB7XG4gICAgICAgICAgLy8gcmVzZXQgJ2xhc3RTZW50JyBiZWZvcmUgcmVudW1iZXJpbmdcbiAgICAgICAgICBmc20uX21lc3NhZ2VJZHMuc2V0TGFzdFNlbnQobGFzdE1zZ0lEQWNrZWQpO1xuXG4gICAgICAgICAgTE9HX0RFQlVHKGBSZW51bWJlcmluZyB1bmFja2VkL3Vuc2VudCBtZXNzYWdlczogZnNtLl9tZXNzYWdlSWRzPSR7ZnNtLl9tZXNzYWdlSWRzfSwgbGFzdE1zZ0lEQWNrZWQ9JHtsYXN0TXNnSURBY2tlZH0sIHR5cGU9JHtmc20uX2Nvbm5lY3RSZWFzb259YCk7XG4gICAgICAgICAgaWYgKGZzbS5fY29ubmVjdFJlYXNvbiA9PT0gQ29ubmVjdFJlYXNvbi5GQUlMT1ZFUikge1xuICAgICAgICAgICAgcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5GTE9XX05BTUVfQ0hBTkdFRCwge1xuICAgICAgICAgICAgICBtZXNzYWdlczogWy4uLmZzbS5fdW5hY2tlZExpc3RdLFxuICAgICAgICAgICAgICBjb3VudDogICAgZnNtLl91bmFja2VkTGlzdC5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnNtLl9jb25uZWN0UmVhc29uID0gQ29ubmVjdFJlYXNvbi5SRVNVTUU7XG4gICAgICAgICAgZnNtLl91bmFja2VkTGlzdC5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRJZCA9IG1lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpO1xuICAgICAgICAgICAgZnNtLl9yZW51bWJlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIExPR19UUkFDRShgUmVudW1iZXJpbmcgbWVzc2FnZSBJRDogZnJvbSAke29sZElkfSB0byAke21lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpfWApO1xuICAgICAgICAgICAgZnNtLl9tZXNzYWdlSWRzLnNldExhc3RTZW50KG1lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGUgZmxvd0lkIGNoYW5nZXMgb24gZXZlcnkgb3BlbiBGbG93IHNvIHNldCBpdCBwcm9wZXJseSBpbiB0aGUgdW5hY2tlZCBMaXN0XG4gICAgICAgICAgLy8gaWYgdGhlIHJvdXRlciBoYXMgZW5hYmxlZCAnQWxsb3cgVW5rbm93biBQdWJsaXNoZXIgRmxvdycgdGhlIHB1Ymxpc2hlcklkIGNhblxuICAgICAgICAgIC8vIGNoYW5nZSB0b28uICBJdCdzIHF1dWVzdGlvbmFibGUgd2hhdCB3ZSBkbyBoZXJlIGF0IGFsbCwgYnV0IHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAgICAgIC8vIG90aGVyIEFQSXMsIHNldCB0aGUgcHVibGlzaGVySUQganVzdCBpbiBjYXNlLlxuICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyBjb2RlIGluIHRoZSBuZXh0IHJlbGVhc2UsIHdlIGNvdWxkIGhhdmUgdGhlIGdldHRlciBmb3JcbiAgICAgICAgICAvLyBwdWJsaXNoZXJJRCByZXRyaWV2ZSBpdCBmcm9tIHRoZSBmbG93IChhcyBDQ1NNUCBkb2VzKSBhdCBlbmNvZGluZyB0aW1lIGFuZFxuICAgICAgICAgIC8vIGF2b2lkIHRoaXMuIEluIHRoZSBtaW5pbXVtIGNvbnNpZGVyIGdhdGhlcmluZyB0aGVzZSBzZXR0ZXJzIGludG8gYSBmdW5jdGlvblxuICAgICAgICAgIC8vIHRoYXQgaXMgaW52b2tlZCBib3RoIGhlcmUgYW5kIGJ5ICdyZW51bWJlcidcbiAgICAgICAgICBmc20uX3VuYWNrZWRMaXN0LmZvckVhY2goKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2V0Rmxvd0lkKGZsb3dJZCk7XG4gICAgICAgICAgICBtZXNzYWdlLnNldFB1Ymxpc2hlcklkKHB1Ymxpc2hlci5wdWJsaXNoZXJJZCk7XG4gICAgICAgICAgICBMT0dfVFJBQ0UoYFNldCBGbG93SWQgdG8gJHtmbG93SWR9IGluIG1zZyMgJHttZXNzYWdlLmdldEd1YXJhbnRlZWRNZXNzYWdlSWQoKX1gKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmc20uX3VuYWNrZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIGZzbS5faGFuZGxlQWNrKGxhc3RNc2dJREFja2VkLCBmYWxzZSwgYWRwTXNnLCB0cnVlKTtcbiAgICAgICAgICAvLyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJldHJhbnNtaXR0aW5nLiAgSWYgbGFzdE1zZ0lkQWNrZWQgZG9lc24ndFxuICAgICAgICAgIC8vIGFjayBhbnl0aGluZyB0aGlzIGRvZXMgbm90IGdldCB1cGRhdGVzLCBjYXVzaW5nIHVzIHRvIHBvc3NpYmxlIHNlbmRcbiAgICAgICAgICAvLyBtZXNzYWdlcyBvdXQgb2Ygb3JkZXIsIG9yIG5vdCBzdGFydCBzZW5kaW5nIGF0IGFsbFxuICAgICAgICAgIGZzbS5fZmlyc3RVbmFja2VkVG9TZW5kID0gZnNtLl91bmFja2VkTGlzdFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmc20uX21lc3NhZ2VJZHMubGFzdEFja2VkID0gTG9uZy5mcm9tVmFsdWUobGFzdE1zZ0lEQWNrZWQpO1xuICAgICAgICB9XG4gICAgICAgIExPR19UUkFDRShgTG9jYWwgYWZ0ZXIgYXBwbHlpbmcgbGFzdE1zZ0lEQWNrZWQ6ICR7ZnNtLl9tZXNzYWdlSWRzfWApO1xuXG4gICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgIG5ldyBQdWJsaXNoZXJGU01FdmVudCh7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19VUCB9KSk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7P30gVGhlIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGFuIEJJTkRfVElNRU9VVCBldmVudFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgaGFuZGxlT3BlbkZsb3dUaW1lb3V0KCkge1xuICAgICAgICBMT0dfSU5GTygnT3BlbiBwdWJsaXNoZXIgY29ubmVjdGlvbiB0aW1lb3V0Jyk7XG4gICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgIG5ldyBQdWJsaXNoZXJGU01FdmVudCh7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuQklORF9USU1FT1VUIH0pKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVVbmtub3duRmxvd05hbWUoKSB7XG4gICAgICAgIExPR19JTkZPKCdGbG93IG5hbWUgdW5rbm93biwgcmVwdWJsaXNoIHJlcXVpcmVkJyk7XG4gICAgICAgIC8vIERvbid0IHNlbmQgdGhlIEZMT1dfTkFNRV9DSEFOR0VEIG1lc3NhZ2UgeWV0IC0tIGl0IHNwZWNpZmljYWxseSBpbmRpY2F0ZXNcbiAgICAgICAgLy8gdGhhdCBkdXBsaWNhdGUgbWVzc2FnZXMgc2hvdWxkIGJlIGV4cGVjdGVkLiBXYWl0IHVudGlsIHRoZSBmbG93IGlzIHN1Y2Nlc3NmdWxseVxuICAgICAgICAvLyBjb25uZWN0ZWQgYW5kIG1lc3NhZ2VzIGFyZSBiZWluZyByZW51bWJlcmVkLlxuICAgICAgICBmc20uX3Jlc2V0Q29ubmVjdGVkSW5mbyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxUcmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlck9wZW5GbG93U2VudCk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBTZW5kIGEgUHVibGlzaGVyIE9wZW4gRmxvdyBSZXF1ZXN0LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgc2VuZE9wZW5GbG93KCkge1xuICAgICAgICBjb25zdCBjb3JyZWxhdGlvblRhZyA9IHNlc3Npb25JbnRlcmZhY2UuZ2V0Q29ycmVsYXRpb25UYWcoKTtcbiAgICAgICAgY29uc3Qgb3BlblB1YkZsb3dNc2cgPSBTTUZMaWIuQWRQcm90b2NvbE1lc3NhZ2UuZ2V0T3Blbk1lc3NhZ2VQdWJsaXNoZXIoXG4gICAgICAgICAgZnNtLl9tZXNzYWdlSWRzLmxhc3RBY2tlZCxcbiAgICAgICAgICBmc20uX21lc3NhZ2VJZHMubGFzdFNlbnQsXG4gICAgICAgICAgcHJvcGVydGllcy53aW5kb3dTaXplLFxuICAgICAgICAgIGZzbS5fcHVibGlzaGVyLl9mbG93TmFtZSxcbiAgICAgICAgICBjb3JyZWxhdGlvblRhZ1xuICAgICAgICApO1xuICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLnNlbmRDb250cm9sKG9wZW5QdWJGbG93TXNnKTtcbiAgICAgICAgc2Vzc2lvbkludGVyZmFjZS5lbnF1ZXVlUmVxdWVzdChjb3JyZWxhdGlvblRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZU9wZW5GbG93VGltZW91dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuY29ubmVjdFRpbWVvdXRJbk1zZWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnhNc2dPYmogPT4gdGhpcy5oYW5kbGVPcGVuRmxvd1Jlc3BvbnNlKHJ4TXNnT2JqKSk7XG4gICAgICAgIExPR19UUkFDRSgnU2VudCBvcGVuIHB1Ymxpc2hlciBjb25uZWN0aW9uJyk7XG4gICAgICB9LFxuICAgIH0pXG4gICAgICAuZW50cnkoZnVuY3Rpb24gb25FbnRyeSgpIHtcbiAgICAgICAgdGhpcy5zZW5kT3BlbkZsb3coKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX0NMT1NFLCBmdW5jdGlvbiBvbkZsb3dDbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJDbG9zZUZsb3dTZW50KTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX1VQLCBmdW5jdGlvbiBvbkZsb3dVcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJVcCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9ET1dOLCBmdW5jdGlvbiBvblNlc3Npb25Eb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlclVuYm91bmQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihQdWJsaXNoZXJGU01FdmVudE5hbWVzLkJJTkRfVElNRU9VVCwgZnVuY3Rpb24gb25PcGVuRmxvd1RpbWVvdXQoKSB7XG4gICAgICAgIGlmIChmc20uX2JpbmRSZXRyeUNvdW50ID4gMCkge1xuICAgICAgICAgIGZzbS5fYmluZFJldHJ5Q291bnQtLTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFRyYW5zaXRpb25Ubyhmc20uUHVibGlzaGVyT3BlbkZsb3dTZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRPcGVuRmxvd0ZhaWxlZEVycm9yKHtcbiAgICAgICAgICBzdWJjb2RlOiAgICAgRXJyb3JTdWJjb2RlLlRJTUVPVVQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdPcGVuIHB1Ymxpc2hlciBjb25uZWN0aW9uIGZhaWxlZCBkdWUgdG8gdGltZW91dCcsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlclVuYm91bmQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfRkFJTEVELCBmdW5jdGlvbiBvbkZsb3dGYWlsZWQocEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc3ViY29kZSwgcmV0dXJuQ29kZSwgZGVzY3JpcHRpb24gfSA9IHBFdmVudDtcbiAgICAgICAgc3dpdGNoIChwRXZlbnQuc3ViY29kZSkge1xuICAgICAgICAgIGNhc2UgRXJyb3JTdWJjb2RlLlVOS05PV05fRkxPV19OQU1FOlxuICAgICAgICAgICAgLy8gRFIgb3IgbG9uZyBIQSBmYWlsb3ZlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5rbm93bkZsb3dOYW1lKCk7XG4gICAgICAgICAgLy8gY2FzZSBFcnJvclN1YmNvZGUuR01fTk9UX1JFQURZOiBGYWlsIHRoZSBzZXNzaW9uXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZW1pdE9wZW5GbG93RmFpbGVkRXJyb3Ioe1xuICAgICAgICAgICAgICBldmVudDogcEV2ZW50LFxuICAgICAgICAgICAgICBzdWJjb2RlLFxuICAgICAgICAgICAgICByZXR1cm5Db2RlLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZmxvdyBpcyBpbnZhbGlkXG4gICAgICAgICAgICBmc20uX3Jlc2V0Q29ubmVjdGVkSW5mbygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uUHVibGlzaGVyVW5ib3VuZCk7XG4gICAgICB9KTtcblxuICAgIGZzbS5QdWJsaXNoZXJDbG9zZUZsb3dTZW50ID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFB1Ymxpc2hlclN0YXRlTmFtZXMuQ0xPU0VGTE9XU0VOVCxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbSxcbiAgICB9LCB7XG4gICAgICBoYW5kbGVDbG9zZUZsb3dSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBzbWZSZXNwSGVhZGVyID0gcmVzcG9uc2Uuc21mSGVhZGVyO1xuICAgICAgICBjb25zdCByZXNwQ29kZSA9IHNtZlJlc3BIZWFkZXIucG1fcmVzcGNvZGU7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm1zZ1R5cGUgIT09IFNNRkxpYi5TTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xPU0VQVUJGTE9XKSB7XG4gICAgICAgICAgcmV0dXJuIGZzbS5wcm9jZXNzRXZlbnQobmV3IFB1Ymxpc2hlckZTTUV2ZW50KFxuICAgICAgICAgICAgeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLkZMT1dfRkFJTEVEIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybkNvZGU6ICByZXNwQ29kZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBVbmV4cGVjdGVkIHJlc3BvbnNlOiAke1NNRkxpYi5TTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuZGVzY3JpYmUocmVzcG9uc2UubXNnVHlwZSl9YCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwQ29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIERyb3AgbWVzc2FnZSAgYW5kIGluY3JlbWVudCBzdGF0c1xuICAgICAgICAgIHB1Ymxpc2hlci5pbmNTdGF0KFN0YXRUeXBlLlJYX0RJU0NBUkRfU01GX1VOS05PV05fRUxFTUVOVCk7XG4gICAgICAgICAgTE9HX0RFQlVHKGBEcm9wIENsb3NlLVB1Ymxpc2hlci1GbG93IFJlcXVlc3QgbWVzc2FnZSBvbiBzZXNzaW9uSWQgMHgke1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLnNlc3Npb25JZEhleH1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgICAgZnNtLnByb2Nlc3NFdmVudChcbiAgICAgICAgICAgIG5ldyBQdWJsaXNoZXJGU01FdmVudCh7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19GQUlMRUQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Db2RlOiAgcmVzcENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc21mUmVzcEhlYWRlci5wbV9yZXNwc3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgIG5ldyBQdWJsaXNoZXJGU01FdmVudCh7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19VTkJPVU5EIH0pKTtcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZUNsb3NlRmxvd1RpbWVvdXQoKSB7XG4gICAgICAgIExPR19JTkZPKCdDbG9zZSBwdWJsaXNoZXIgY29ubmVjdGlvbiB0aW1lb3V0LicpO1xuICAgICAgICByZXR1cm4gZnNtLnByb2Nlc3NFdmVudChcbiAgICAgICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlVOQklORF9USU1FT1VUIH0pKTtcbiAgICAgIH0sXG5cbiAgICAgIHNlbmRDbG9zZUZsb3coKSB7XG4gICAgICAgIGNvbnN0IGNvcnJlbGF0aW9uVGFnID0gc2Vzc2lvbkludGVyZmFjZS5nZXRDb3JyZWxhdGlvblRhZygpO1xuICAgICAgICBjb25zdCBjbG9zZVB1YkZsb3dNc2cgPSBTTUZMaWIuQWRQcm90b2NvbE1lc3NhZ2UuZ2V0Q2xvc2VNZXNzYWdlUHVibGlzaGVyKFxuICAgICAgICAgIGZzbS5fcHVibGlzaGVyLmZsb3dJZCxcbiAgICAgICAgICBjb3JyZWxhdGlvblRhZ1xuICAgICAgICApO1xuICAgICAgICBzZXNzaW9uSW50ZXJmYWNlLnNlbmRDb250cm9sKGNsb3NlUHViRmxvd01zZyk7XG4gICAgICAgIHNlc3Npb25JbnRlcmZhY2UuZW5xdWV1ZVJlcXVlc3QoY29ycmVsYXRpb25UYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVDbG9zZUZsb3dUaW1lb3V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5jb25uZWN0VGltZW91dEluTXNlY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByeE1zZ09iaiA9PiB0aGlzLmhhbmRsZUNsb3NlRmxvd1Jlc3BvbnNlKHJ4TXNnT2JqKSk7XG4gICAgICAgIExPR19UUkFDRSgnU2VudCBjbG9zZSBwdWJsaXNoZXIgY29ubmVjdGlvbicpO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmVudHJ5KGZ1bmN0aW9uIG9uRW50cnkoKSB7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlRmxvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5BQ0ssIGZ1bmN0aW9uIG9uQWNrKGV2ZW50KSB7XG4gICAgICAgIGZzbS5faGFuZGxlQWNrRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRyYW5zaXRpb24oKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX1VOQk9VTkQsIGZ1bmN0aW9uIG9uRmxvd1VuYm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uUHVibGlzaGVyVW5ib3VuZCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuRkxPV19GQUlMRUQsIGZ1bmN0aW9uIG9uQ2xvc2VGbG93RmFpbGVkKC8qcEV2ZW50Ki8pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlclVuYm91bmQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihQdWJsaXNoZXJGU01FdmVudE5hbWVzLlVOQklORF9USU1FT1VULCBmdW5jdGlvbiBvbkNsb3NlRmxvd1RpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uUHVibGlzaGVyQ2xvc2VGbG93U2VudCk7XG4gICAgICB9KTtcblxuICAgIGZzbS5QdWJsaXNoZXJVcCA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBQdWJsaXNoZXJTdGF0ZU5hbWVzLlVQLFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLFxuICAgIH0sIHtcbiAgICAgIGVtaXRGbG93VXAoKSB7XG4gICAgICAgIHB1Ymxpc2hlci5lbWl0KE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUuVVApO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmluaXRpYWwoZnVuY3Rpb24gaW5pdGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgICAgIGZzbS5fdW5hY2tlZExpc3QubGVuZ3RoXG4gICAgICAgICAgICA/IGZzbS5QdWJsaXNoZXJSZXRyYW5zbWl0dGluZ1xuICAgICAgICAgICAgOiBmc20uUHVibGlzaGVyRGF0YVhmZXJcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAuZW50cnkoZnVuY3Rpb24gb25FbnRyeSgpIHtcbiAgICAgICAgLy8gVGhlIHN0YXRlIGlzbid0IGNoYW5nZWQgb24gZW50cnksIHNvIGRvbid0IGVtaXQgeWV0LlxuICAgICAgICBMT0dfREVCVUcoJ0Zsb3cgaXMgVVAnKTtcbiAgICAgICAgZnNtLl9zY2hlZHVsZVN0YXRlRXZlbnRzKGZzbS5QdWJsaXNoZXJVcCwgKCkgPT4gdGhpcy5lbWl0Rmxvd1VwKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5BQ0ssIGZ1bmN0aW9uIG9uQWNrKGV2ZW50KSB7XG4gICAgICAgIExPR19ERUJVRygnQWNrIHJlY2VpdmVkJyk7XG4gICAgICAgIGZzbS5faGFuZGxlQWNrRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRyYW5zaXRpb24oKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5BQ0tfVElNRU9VVCwgZnVuY3Rpb24gb25BY2tUaW1lb3V0KCkge1xuICAgICAgICAvLyB0aGUgc3RhcnRpbmcgcG9pbnQgd2hlbiB3ZSBnZXQgdGhlIENBTl9TRU5EXG4gICAgICAgIGZzbS5fZmlyc3RVbmFja2VkVG9TZW5kID0gZnNtLl91bmFja2VkTGlzdFswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJSZXRyYW5zbWl0dGluZyk7XG4gICAgICB9KVxuICAgICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX0NMT1NFLCBmdW5jdGlvbiBvbkZsb3dDbG9zZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlckNsb3NlRmxvd1NlbnQpO1xuICAgICAgICB9KVxuICAgICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RPV04sIGZ1bmN0aW9uIG9uU2Vzc2lvbkRvd24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJVbmJvdW5kKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuVFJBTlNQT1JUX0ZVTEwsIGZ1bmN0aW9uIG9uV2luZG93Q2xvc2VkKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgIGZzbS5QdWJsaXNoZXJEYXRhWGZlciA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBQdWJsaXNoZXJTdGF0ZU5hbWVzLkRBVEFfWEZFUixcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5QdWJsaXNoZXJVcCxcbiAgICB9KVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgLy8gcHVibGlzaGVyIGlzIHVwIGFuZCBjYXBhYmxlIG9mIHNlbmRpbmcgR00gbWVzc2FnZXMgZGlyZWN0bHkgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgZnNtLl90cmFuc3BvcnRGbG93Q29udHJvbGxlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUT0RPOiBXZSBkb24ndCBuZWVkIGEgQ0FOX1NFTkQgaWYgd2UncmUgZ29pbmcgdG8gZW1pdCBhIEZMT1dfVVAsXG4gICAgICAgIC8vIGJ1dCB3ZSBuZWVkIGEgYmV0dGVyIHdheSB0byBtYW5hZ2UgdGhlc2UgZGVmZXJyZWQgZXZlbnRzLlxuICAgICAgICBmc20uX3NjaGVkdWxlU3RhdGVFdmVudHMoZnNtLlB1Ymxpc2hlckRhdGFYZmVyLCAoKSA9PiBmc20uX21heWJlRW1pdENhblNlbmQoKSk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuVFJBTlNQT1JUX0ZVTEwsIGZ1bmN0aW9uIG9uVHJhbnNwb3J0RnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJGbG93Q29udHJvbGxlZCk7XG4gICAgICB9KVxuICAgICAgLmV4aXQoKCkgPT4ge1xuICAgICAgICAvLyBwdWJsaXNoZXIgY2Fubm90IHNlbmQgbWVzc2FnZXMgdG8gdHJhbnNwb3J0IGFuZCBtdXN0IHF1ZXVlIGluIHVuQWNrZWRMaXN0IHVudGlsXG4gICAgICAgIC8vIHJlLWVudGVyaW5nIFB1Ymxpc2hlckRhdGFYZmVyXG4gICAgICAgIC8vIHNldCBhIEZTTSBib29sZWFuIHRoYXQgaXMgY2hlY2tlZCBpbiBwcmVwYXJlQURNZXNzYWdlQW5kU2VuZCgpIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gYXZvaWQgRlNNIGludGVyYWN0aW9ucyBvbiB0aGUgZmFzdCBwYXRoIHNvIHJlc29ydCB0b1xuICAgICAgICAvLyB0aGlzIGJvb2xlYW4uXG4gICAgICAgIGZzbS5fdHJhbnNwb3J0Rmxvd0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICBmc20uUHVibGlzaGVyRmxvd0NvbnRyb2xsZWQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgUHVibGlzaGVyU3RhdGVOYW1lcy5GTE9XX0NPTlRST0xMRUQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uUHVibGlzaGVyVXAsXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihQdWJsaXNoZXJGU01FdmVudE5hbWVzLlRSQU5TUE9SVF9GVUxMLCBmdW5jdGlvbiBvblRyYW5zcG9ydEZ1bGwoKSB7XG4gICAgICAgIC8vIFVudXN1YWwgZXZlbnQsIGFzIG9ubHkgdGhlIEZTTSBjYW4gc2VuZCBtZXNzYWdlcyB3aGVuIHdlJ3JlIGluIGZsb3ctY29udHJvbGxlZCBzdGF0ZVxuICAgICAgICBMT0dfSU5GTygnQXR0ZW1wdCB0byBzZW5kIHdoaWxlIGZsb3cgY29udHJvbGxlZCcpO1xuICAgICAgICAvLyBGYWxsIG91dCBhbmQgZG8gdGhlIGFjdGlvbiBmb3IgUHVibGlzaGVyVXBcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUcmFuc2l0aW9uKCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuQ0FOX1NFTkQsIGZ1bmN0aW9uIG9uQ2FuU2VuZCgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gc3RhcnQgc2VuZGluZyBmcm9tIHR1bmUgdW5BY2tlZCBsaXN0LlxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlclJldHJhbnNtaXR0aW5nKTtcbiAgICAgIH0pO1xuXG4gICAgZnNtLlB1Ymxpc2hlclJldHJhbnNtaXR0aW5nID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFB1Ymxpc2hlclN0YXRlTmFtZXMuUkVUUkFOU01JVFRJTkcsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uUHVibGlzaGVyVXAsXG4gICAgfSwge1xuICAgICAgcmV0cmFuc21pdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmc20uX3Jlc2VuZEZyb21VbmFja2VkKCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgLy8gUmVzZW5kIGZhaWxlZDpcbiAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBPcGVyYXRpb25FcnJvciAmJiBleC5zdWJjb2RlID09PSBFcnJvclN1YmNvZGUuSU5TVUZGSUNJRU5UX1NQQUNFKSB7XG4gICAgICAgICAgICBMT0dfREVCVUcoJ1B1Ymxpc2hlciByZXNlbmRGcm9tVW5hY2tlZCBibG9ja2VkIGR1ZSB0byBpbnN1ZmZpY2llbnQgc3BhY2UsIHdhaXQgZm9yIENBTl9TRU5EJyk7XG4gICAgICAgICAgICBmc20ucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlRSQU5TUE9SVF9GVUxMIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VuZCBmYWlsZWQuICBGYWlsIHRoZSBwdWJsaXNoZXJcbiAgICAgICAgICAgIExPR19JTkZPKGBQdWJsaXNoZXIgcmVzZW5kRnJvbVVuYWNrZWQgZmFpbGVkOiAke2V4fWApO1xuICAgICAgICAgICAgZnNtLnByb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgbmV3IFB1Ymxpc2hlckZTTUV2ZW50KHsgbmFtZTogUHVibGlzaGVyRlNNRXZlbnROYW1lcy5GTE9XX0ZBSUxFRCB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pXG4gICAgICAuZW50cnkoZnVuY3Rpb24gb25FbnRyeSgpIHtcbiAgICAgICAgdGhpcy5yZXRyYW5zbWl0KCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuUkVTRU5EX0NPTVBMRVRFLCBmdW5jdGlvbiBvblJlc2VuZENvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlB1Ymxpc2hlckRhdGFYZmVyKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oUHVibGlzaGVyRlNNRXZlbnROYW1lcy5UUkFOU1BPUlRfRlVMTCwgZnVuY3Rpb24gb25UcmFuc3BvcnRGdWxsKCkge1xuICAgICAgICAvLyBUcmFuc3BvcnQgZmxvdyBjb250cm9sbGVkIHdoaWxlIHJlc2VuZGluZy9yZWNvdmVyaW5nIGZyb20gZmxvdyBjb250cm9sLiBHb1xuICAgICAgICAvLyB0byBmbG93IGNvbnRyb2xsZWQgc3RhdGUgYW5kIHdhaXQgZm9yIENBTl9TRU5EXG4gICAgICAgIExPR19ERUJVRyhgVHJhbnNwb3J0IGZ1bGwgd2hpbGUgcmV0cmFuc21pdHRpbmcsIHVuYWNrZWQgcmVtYWluaW5nOiAke2ZzbS5fdW5hY2tlZExpc3QubGVuZ3RofWApO1xuICAgICAgICAvLyBGYWxsIG91dCBhbmQgZG8gdGhlIGFjdGlvbiBmb3IgUHVibGlzaGVyVXBcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5QdWJsaXNoZXJGbG93Q29udHJvbGxlZCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGlzRGlzY29ubmVjdGVkKCkge1xuICAgIGlmICghdGhpcy5nZXRDdXJyZW50U3RhdGUoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRBY3RpdmVTdGF0ZShQdWJsaXNoZXJTdGF0ZU5hbWVzLlVOQk9VTkQpO1xuICB9XG5cbiAgLyoqXG5cbiAgICogUHJlcGFyZSBhbmQgc2VuZCBhIEd1YXJhbnRlZWQgTWVzc2FnZS4gVGhpcyBtZXRob2QgdXBkYXRlcyBGU00gdmFyaWFibGVzIGluY2x1ZGluZ1xuICAgKiBsYXN0U2VuZE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gZGF0YU1zZyBUaGUgbWVzc2FnZSB0byBwcmVwYXJlXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSByZXR1cm4gdGhlIHN0YXR1cyBmcm9tIHRoZSB0cmFuc3BvcnQgc2VuZFxuICAgKi9cbiAgcHJlcGFyZUFkTWVzc2FnZUFuZFNlbmQoZGF0YU1zZykge1xuICAgIGlmICghdGhpcy5fZ3VhcmFudGVlZEVuYWJsZWQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignU2Vzc2lvbiBkb2VzIG5vdCBwcm92aWRlIEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoIGNhcGFiaWxpdHknLFxuICAgICAgICBFcnJvclN1YmNvZGUuR01fVU5BVkFJTEFCTEUsXG4gICAgICAgICdjbG9zZSBmbG93IHJlY2VpdmVkIGZyb20gbWVzc2FnZS1yb3V0ZXInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NlbmRXaW5kb3cgPD0gMCkge1xuICAgICAgdGhpcy5fcHVibGlzaGVyLmluY1N0YXQoU3RhdFR5cGUuVFhfV0lORE9XX0NMT1NFRCk7XG4gICAgICB0aGlzLl9ub3RpZmllZFdpbmRvd0Nsb3NlZCA9IHRydWU7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgICdHdWFyYW50ZWVkIE1lc3NhZ2UgV2luZG93IENsb3NlZCcsXG4gICAgICAgIEVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5hY2tlZExpc3QgPSB0aGlzLl91bmFja2VkTGlzdDtcbiAgICBjb25zdCB7XG4gICAgICBMT0dfVFJBQ0UsXG4gICAgICBMT0dfREVCVUcsXG4gICAgfSA9IHRoaXMubG9nZ2VyO1xuXG4gICAgLS10aGlzLl9zZW5kV2luZG93O1xuXG4gICAgdGhpcy5fcmVudW1iZXIoZGF0YU1zZyk7XG4gICAgY29uc3QgZHVwTXNnID0gZGF0YU1zZy5jbG9uZSgpO1xuICAgIHVuYWNrZWRMaXN0LnB1c2goZHVwTXNnKTtcbiAgICAvLyBVcGRhdGUgdGhlIG1lc3NnZUlkcywgbGFzdFNlbmQvbmV4dCB2YWx1ZXMgb25seSBvbiBhIHN1Y2Nlc3NmdWwgc2VuZCBvciBlbnF1ZXVlLFxuICAgIC8vIGZyb20gdGhpcyBwb2ludCBvbiB3ZSB3aWxsIHJldHVybiBPSyBmcm9tIHRoaXMgc2VuZCBtZXRob2QuXG4gICAgY29uc3QgbXNnSWQgPSBkdXBNc2cuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpO1xuICAgIHRoaXMuX21lc3NhZ2VJZHMuc2V0TGFzdFNlbnQobXNnSWQpO1xuICAgIExPR19UUkFDRShgUHJlcGFyZSBhbmQgc2VuZCBBRCBtZXNzYWdlIElEID0gJHttc2dJZH0sIFxuICAgICAgdW5hY2tlZExpc3RTaXplID0gJHt1bmFja2VkTGlzdC5sZW5ndGh9LCBzZW5kV2luZG93ID0gJHt0aGlzLl9zZW5kV2luZG93fWApO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgdHJhbnNwb3J0IHNlbmRlciBjYW4gYmUgZmxvdyBjb250cm9sbGVkIGF0IHRoZSB0cmFuc3BvcnRcbiAgICAvLyBsZXZlbCwgd2hpY2ggbWVhbnMgdGhlIG1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBzZW50LiBTbyBzaW1wbHkgcmV0dXJuXG4gICAgLy8gV2UgYWxzbyBjb25zaWRlciBzZXQtdXAvZG93bi1zdGF0ZXMgYXMgX3RyYW5zcG9ydEZsb3dDb250cm9sbGVkLiBXZSBtdXN0IGJlIHVwXG4gICAgLy8gYW5kIG5vdCByZXRyYW5zbWl0dGluZyB0b1xuICAgIC8vIHNlbmQgZGlyZWN0bHkgZnJvbSBhcHBsaWNhdGlvbiBzcGFjZS5cbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Rmxvd0NvbnRyb2xsZWQpIHtcbiAgICAgIC8vIHdlIG1heSByZWNlaXZlIGFja25vd2xlZGdlbWVudHMgd2hpbGUgdHJhbnNwb3J0IGZsb3cgY29udHJvbGxlZCB3aGljaCBjYW5cbiAgICAgIC8vIGNhdXNlIG91ciBmaXJzdFVuQWNrZWRUb1NlbmQgdG8gYmVjb21lIHVuZGVmaW5lZCwgaWYgdGhpcyBpcyB0aGUgZmlyc3QgbWVzc2FnZVxuICAgICAgLy8gcXVldWVkIGluIHRoYXQgY2FzZSwgc2V0IGZpcnN0VW5BY2tlZFRvU2VuZFxuICAgICAgaWYgKHRoaXMuX2ZpcnN0VW5hY2tlZFRvU2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0VW5hY2tlZFRvU2VuZCA9IGR1cE1zZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICAgIH1cbiAgICAvLyBXZSB1c2UgdGhlIHNlc3Npb24gc2VuZFRvVHJhbnNwb3J0IGRpcmVjdGx5IHdoaWNoIG1heSB0aHJvdyBvciAgb3RoZXJ3aXNlXG4gICAgLy8gcmV0dXJuIGFuIGVycm9yLiBJZiBzbywgY2F0Y2ggdGhlIGVyb3IgYW5kIHJlbW92ZSB0aGUgbWVzc2FnZSBmcm9tIHRoZSB1bmFja2VkbGlzdFxuICAgIC8vIGJlZm9yZSByZXRocm93aW5nIHRoZSBlcnJvci5cbiAgICBsZXQgcmV0dXJuQ29kZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuQ29kZSA9IHRoaXMuX3Nlc3Npb25JbnRlcmZhY2Uuc2VuZFRvVHJhbnNwb3J0KGR1cE1zZyk7XG4gICAgICBpZiAocmV0dXJuQ29kZSAhPT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgICBpZiAocmV0dXJuQ29kZSA9PT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5OT19TUEFDRSkge1xuICAgICAgICAgIHJldHVybkNvZGUgPSBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VW5hY2tlZFRvU2VuZCA9IGR1cE1zZzsgIC8vIHRoZSBzdGFydGluZyBwb2ludCB3aGVuIHdlIGdldCB0aGUgQ0FOX1NFTkRcbiAgICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlRSQU5TUE9SVF9GVUxMIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL1xuICAgICAgICAgIExPR19ERUJVRyhgcHJlcGFyZUFkTWVzc2FnZUFuZFNlbmQ6IHNhdyByZXR1cm5Db2RlID0gJHtyZXR1cm5Db2RlfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbWVzc2FnZSBoYXMgc3VjY2Vzc2Z1bGx5IGJlZW4gc2VudCBvbmNlLiBTZXQgdGhlIHJlZGVsaXZlcmVkIGZsYWcgaW4gY2FzZSB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHJlc2VuZCBpdCBsYXRlci5cbiAgICAgICAgZHVwTXNnLnNldFJlZGVsaXZlcmVkKHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gVEJEOiBTaG91bGQgd2Ugc3RhcnQgQWNrVGltZXIgd2hlbiBmbG93IGNvbnRyb2xsZWQ/XG4gICAgICB0aGlzLl9zdGFydEFja1RpbWVyKCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIE9wZXJhdGlvbkVycm9yKSB7XG4gICAgICAgIExPR19ERUJVRyhgcHJlcGFyZUFkTWVzc2FnZUFuZFNlbmQ6IGNhdWdodCBPcGVyYXRpb25FcnJvcjogJHtFcnJvclN1YmNvZGUuZGVzY3JpYmUoZXguc3ViY29kZSl9IC0gJHtleC5tZXNzYWdlfWApO1xuICAgICAgICAvLyBPcGVyYXRpb25FcnJvcnMgYXJlIGVuY29kaW5nIG9yIG90aGVyIGVycm9ycyBjYXVzZWQgYnkgdGhlIGZpZWxkIGNvbnRlbnRzIHRoZVxuICAgICAgICAvLyBhcHBsaWNhdGlvbiBoYXMgc2V0IG9uIHRoZSBtZXNzYWdlLiAgU28gd2UgdGhyb3cgdGhlIGVycm9yIGJhY2sgYXQgdGhlXG4gICAgICAgIC8vIGFwcGxpY2F0aW9uIGFmdGVyIHVuZG9pbmcgdGhlIHF1ZXVlaW5nIG9wZXJhdGlvbnMuXG4gICAgICAgIHVuYWNrZWRMaXN0LnBvcCgpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSWRzLnNldExhc3RTZW50KGR1cE1zZy5nZXRHdWFyYW50ZWVkUHJldmlvdXNNZXNzYWdlSWQoKSk7XG4gICAgICAgICsrdGhpcy5fc2VuZFdpbmRvdztcbiAgICAgICAgdGhyb3cgKGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExPR19ERUJVRyhgcHJlcGFyZUFkTWVzc2FnZUFuZFNlbmQ6IGNhdWdodCAke2V4Lm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICB9XG5cbiAgX2hhbmRsZUFja0V2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5fcHVibGlzaGVyLmluY1N0YXQoU3RhdFR5cGUuVFhfQUNLU19SWEVEKTtcbiAgICB0aGlzLl9oYW5kbGVBY2soZXZlbnQuYWNrIHx8IGV2ZW50Lm5hY2ssICEhZXZlbnQubmFjaywgZXZlbnQuY3RybE1lc3NhZ2UpO1xuICB9XG5cbiAgX2hhbmRsZUFjayhpZCwgbmFjaywgY3RybE1lc3NhZ2UgPSB1bmRlZmluZWQsIG9wZW5GbG93ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7XG4gICAgICBfbWVzc2FnZUlkczogbWVzc2FnZUlkcyxcbiAgICAgIF91bmFja2VkTGlzdDogdW5hY2tlZExpc3QsXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBMT0dfREVCVUcsIExPR19JTkZPIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIGlmIChtZXNzYWdlSWRzLmxhc3RBY2tlZC5ndGUoaWQpKSB7XG4gICAgICBpZiAob3BlbkZsb3cpIHtcbiAgICAgICAgTE9HX0RFQlVHKGBJbXBsaWNpdCBhY2tzIHVwIHRvIGRhdGU6IHJlbW90ZSBhY2sgZm9yICR7aWR9LCBsb2NhbCBpZHMgJHt0aGlzLl9tZXNzYWdlSWRzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTE9HX0lORk8oYERyb3BwaW5nIGFjazogcmVtb3RlIGFjayBmb3IgJHtpZH0sIGxvY2FsIGlkcyAke3RoaXMuX21lc3NhZ2VJZHN9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVwb3J0QWNrZWQgPSBbXTtcblxuICAgIC8vIEFzc3VtcHRpb246IHRoZSB1bmFja2VkIG1lc3NhZ2UgbGlzdCBpcyBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIG1lc3NhZ2UgSUQuXG4gICAgLy8gVGhlIGFzc3VyZWQgbWVzc2FnZSBJRCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQsIGltbXV0YWJsZSBhbmRcbiAgICAvLyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5cbiAgICAvLyBXaGlsZSB0aGUgYWNrZWQgSUQgaXMgZ3JlYXRlciB0aGFuIGFuIGVsZW1lbnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdW5hY2tlZCBsaXN0Li4uXG4gICAgd2hpbGUgKHVuYWNrZWRMaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICBpZC5ndGUodW5hY2tlZExpc3RbMF0uZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpKSkge1xuICAgICAgLy8gVGhhdCB1bmFja2VkIG1lc3NhZ2UgaXMgbm93IGFja2VkLiBTaGlmdCBpdCBvZmYgYW5kIGFwcGVuZCB0byBsaXN0IG9mIGFja2VkLlxuICAgICAgcmVwb3J0QWNrZWQucHVzaCh1bmFja2VkTGlzdC5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIHJlbW92ZWQgdGhlIGZpcnN0VW5hY2tlZCwgcmVzZXQgaXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuICAgIGlmICh1bmFja2VkTGlzdC5pbmRleE9mKHRoaXMuX2ZpcnN0VW5hY2tlZFRvU2VuZCkgPT09IC0xKSB7XG4gICAgICB0aGlzLl9maXJzdFVuYWNrZWRUb1NlbmQgPSB1bmFja2VkTGlzdFswXTtcbiAgICB9XG5cblxuICAgIC8vIFJlY292ZXIgc29tZSB3aW5kb3cgc3BhY2UgZnJvbSB0aGUgYWNrZWQgSURzLlxuICAgIHRoaXMuX3NlbmRXaW5kb3cgKz0gcmVwb3J0QWNrZWQubGVuZ3RoO1xuICAgIExPR19ERUJVRygnU2VuZCB3aW5kb3cgc2l6ZSBpcyBub3cnLCB0aGlzLl9zZW5kV2luZG93KTtcblxuXG4gICAgLy8gVGhlIGxhc3QgYWNrZWQgSUQgaXMgbm93IHRoZSBvbmUgd2UgcmVjZWl2ZWQuXG4gICAgLy8gRG9uJ3QgbGV0IGFuIGV4Y2VwdGlvbiBpbiBldmVudCBkaXNwYXRjaGluZyBwcmV2ZW50IHRoaXMgZnJvbSBiZWluZyBzZXQgLS0gZG8gaXQgbm93LlxuICAgIG1lc3NhZ2VJZHMubGFzdEFja2VkID0gaWQ7XG5cbiAgICAvLyBJZiB3ZSdyZSBOQUNLaW5nLCBpdCdzIG9ubHkgdGhlIGxhc3QgbWVzc2FnZS5cbiAgICBjb25zdCByZXBvcnROYWNrZWQgPSBuYWNrID8gcmVwb3J0QWNrZWQucG9wKCkgOiBudWxsO1xuXG4gICAgLy8gQW55IEFDS3M/XG4gICAgLy8gcmVwb3J0QWNrZWQgaXMgY29uc3RhbnQgZnJvbSBoZXJlIG9uXG4gICAgY29uc3QgbnVtQWNrZWQgPSByZXBvcnRBY2tlZC5sZW5ndGg7XG4gICAgaWYgKG51bUFja2VkKSB7XG4gICAgICBpZiAodGhpcy5fYWNrbm93bGVkZ2VNb2RlID09PSBNZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlLlBFUl9NRVNTQUdFKSB7XG4gICAgICAgIExPR19ERUJVRyhgQWNrIHJlY2VpdmVkOiBsYXN0QWNrZWRNc2dJZD0ke2lkfSwgbnVtQWNrZWRNc2dzPSR7bnVtQWNrZWR9LCBudW1VbmFja2VkTXNncz0ke3VuYWNrZWRMaXN0Lmxlbmd0aH1gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BY2tlZDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5fcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5BQ0tOT1dMRURHRURfTUVTU0FHRSwgcmVwb3J0QWNrZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0QWNrZWRNZXNzYWdlID0gcmVwb3J0QWNrZWRbbnVtQWNrZWQgLSAxXTtcbiAgICAgICAgTE9HX0RFQlVHKGBBY2tpbmcgc2luZ2xlIG1lc3NhZ2Ugd2l0aCBJRCAke2xhc3RBY2tlZE1lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpfSBmcm9tIHJvdXRlciBhY2sgb24gJHtpZH1gKTtcbiAgICAgICAgdGhpcy5fcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5BQ0tOT1dMRURHRURfTUVTU0FHRSwgbGFzdEFja2VkTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVybWluYXRpbmcgTkFDSz9cbiAgICBpZiAocmVwb3J0TmFja2VkKSB7XG4gICAgICBMT0dfREVCVUcoYE5hY2tpbmcgc2luZ2xlIG1lc3NhZ2Ugd2l0aCBJRCAke3JlcG9ydE5hY2tlZC5nZXRHdWFyYW50ZWVkTWVzc2FnZUlkKCl9IGZyb20gcm91dGVyIGFjayBvbiAke2lkfWApO1xuICAgICAgdGhpcy5fcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5SRUpFQ1RFRF9NRVNTQUdFLCByZXBvcnROYWNrZWQsIGN0cmxNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ1VuYWNrZWQgbWVzc2FnZXMgcmVtYWluaW5nOiAnLCB1bmFja2VkTGlzdC5sZW5ndGgpO1xuXG4gICAgaWYgKHVuYWNrZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgLy8gVGhlcmUgYXJlIG1vcmUgbWVzc2FnZXMgdG8gYmUgYWNrZWQuIFJlc2V0IHRoZSBhY2sgdGltZXIuXG4gICAgICB0aGlzLl9yZXNldEFja1RpbWVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsZWFyQWNrVGltZXIoKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBzZW5kIGNhbi1zZW5kIHRvIGFwcGxpY2F0aW5vIGlmIG5lY2Vzc2FyeS5cbiAgICB0aGlzLl9tYXliZUVtaXRDYW5TZW5kKCk7XG4gIH1cblxuICBfbWF5YmVFbWl0Q2FuU2VuZCgpIHtcbiAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgaWYgKCF0aGlzLl9ub3RpZmllZFdpbmRvd0Nsb3NlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9zZW5kV2luZG93ID09PSAwKSB7XG4gICAgICAvLyBTaG91bGQgbG9nIHRoaXMgc2luY2UgaXQgaXMgY2FsbGVkIEFGVEVSIHRoZSBzdGF0ZSBjaGFuZ2VcbiAgICAgIExPR19UUkFDRSgnU3VwcHJlc3NpbmcgQ0FOX1NFTkQgd2l0aCB6ZXJvIHdpbmRvdyBhdmFpbGFibGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbm90aWZpZWRXaW5kb3dDbG9zZWQgPSBmYWxzZTsgLy8gU2V0IGJlZm9yZSBlbWl0dGluZyBpbiBjYXNlIHdlIHJlLWVudGVyXG4gICAgdGhpcy5fcHVibGlzaGVyLmVtaXQoTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5DQU5fU0VORCk7XG4gIH1cblxuICBfcmVzZW5kRnJvbVVuYWNrZWQoKSB7XG4gICAgY29uc3QgeyBMT0dfRVJST1IsIExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgLy8gV2UgY2hvb3NlIHRvIHN0YXJ0IHRoZSBhY2sgdGltZXIgYWZ0ZXIgdGhlIG1lc3NhZ2UgcmVzZW5kLiBUaGUgcmVzZW5kIGNvdWxkXG4gICAgLy8gdGFrZSBsb25nZXIgdGhhbiB0aGUgYWNrIHRpbWVvdXQgaW4gcG9vciBjb25kaXRpb25zLlxuICAgIC8vXG4gICAgLy8gSWYgYW55IG1lc3NhZ2UgaXMgc3VjY2Vzc2Z1bGx5IHJlc2VudCwgd2UgbmVlZCB0byByZXN0YXJ0IHRoZSBhY2sgdGltZXIsXG4gICAgLy8gZXZlbiBpZiB3ZSBhcmUgdGhyb3dpbmcuXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuX3VuYWNrZWRMaXN0O1xuICAgIGxldCByZXNlbmRJbmRleCA9IGxpc3QuaW5kZXhPZih0aGlzLl9maXJzdFVuYWNrZWRUb1NlbmQpO1xuICAgIGlmIChyZXNlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IFVuYWNrZWQgbWF5IGJlIG51bGwgaWYgYWxsIGhhdmUgYmVlbiByZXNlbnQgYWxyZWFkeWdydW50IC1cbiAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlIGxpc3QgIHNob3VsZCBiZSBlbXB0eVxuICAgICAgaWYgKHRoaXMuX2ZpcnN0VW5hY2tlZFRvU2VuZCkge1xuICAgICAgICBMT0dfRVJST1IoYENvdWxkIG5vdCBmaW5kIGZpcnN0IFVuYWNrZWQgTWVzc2FnZXMgaW4gdW5hY2tlZCBtZXNzYWdlIGxpc3Q6IG1zZ0lkID0gJHt0aGlzLl9maXJzdFVuYWNrZWRUb1NlbmQuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIHJlc2VuZDogcmV0dXJuIHRvIERhdGFYZmVyXG4gICAgICAgIExPR19ERUJVRyhgTm90aGluZyB0byByZXNlbmQ6ICR7dGhpcy5fbWVzc2FnZUlkcy50b1N0cmluZygpfWApO1xuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChcbiAgICAgICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlJFU0VORF9DT01QTEVURSB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBMT0dfREVCVUcoYFJlc2VuZGluZyB1bmFja2VkIG1lc3NhZ2VzIGZyb20gJHtyZXNlbmRJbmRleH0gdG8gJHtsaXN0Lmxlbmd0aCAtIDF9OiBgLFxuICAgICAgICAgICAgICBsaXN0Lm1hcChtID0+IG0uZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpLnRvU3RyaW5nKCkpKTtcbiAgICB3aGlsZSAocmVzZW5kSW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgaWYgKGxpc3RbcmVzZW5kSW5kZXhdLmdldFB1Ymxpc2hlcklkKCkgIT09IHRoaXMuX3B1Ymxpc2hlci5wdWJsaXNoZXJJZCkge1xuICAgICAgICBMT0dfRVJST1IoYFJlc2VuZGluZyBvbiBpbnZhbGlkIHB1Ymxpc2hlcklkICcke2xpc3RbcmVzZW5kSW5kZXhdLmdldFB1Ymxpc2hlcklkKCl9J3doZW4gaXQgc2hvdWxkIGJlICcke3RoaXMuX3B1Ymxpc2hlci5wdWJsaXNoZXJJZH0nYCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXR1cm5Db2RlID0gdGhpcy5fc2Vzc2lvbkludGVyZmFjZS5zZW5kRGF0YShsaXN0W3Jlc2VuZEluZGV4XSk7XG4gICAgICBpZiAocmV0dXJuQ29kZSA9PT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5OT19TUEFDRSkge1xuICAgICAgICAvLyB0aGUgc3RhcnRpbmcgcG9pbnQgd2hlbiB3ZSBnZXQgdGhlIENBTl9TRU5EIGZyb20gdGhlIHRyYW5zcG9ydFxuICAgICAgICB0aGlzLl9maXJzdFVuYWNrZWRUb1NlbmQgPSBsaXN0W3Jlc2VuZEluZGV4XTtcbiAgICAgICAgTE9HX0RFQlVHKCdQdWJsaXNoZXIgc2VuZE1lc3NhZ2UgYmxvY2tlZCBkdWUgdG8gaW5zdWZmaWNpZW50IHNwYWNlLCB3YWl0IGZvciBDQU5fU0VORCcpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChcbiAgICAgICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlRSQU5TUE9SVF9GVUxMIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJldHVybkNvZGUgIT09IFRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgICAgLy8gc2Vzc2lvbi1GU00gaXMgYWxyZWFkeSBwcm9jZXNzaW5nIHRoZSBlcnJvclxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUaGUgbWVzc2FnZSBoYXMgc3VjY2Vzc2Z1bGxseSBiZWVuIHNlbnQgb25jZS4gU2V0IHRoZSByZWRlbGl2ZXJlZCBmbGFnIGluIGNhc2Ugd2UgbmVlZCB0b1xuICAgICAgLy8gcmVzZW5kIGl0IGxhdGVyXG4gICAgICBsaXN0W3Jlc2VuZEluZGV4XS5zZXRSZWRlbGl2ZXJlZCh0cnVlKTtcbiAgICAgIHJlc2VuZEluZGV4Kys7XG4gICAgICB0aGlzLl9zdGFydEFja1RpbWVyKCk7XG4gICAgfVxuICAgIC8vIFJlc2VuZCBzdWNjZXNzZnVsOiByZXR1cm4gdG8gRGF0YVhmZXJcbiAgICBMT0dfREVCVUcoYFJlc2VuZCBjb21wbGV0ZTogJHt0aGlzLl9tZXNzYWdlSWRzLnRvU3RyaW5nKCl9YCk7XG4gICAgdGhpcy5wcm9jZXNzRXZlbnQoXG4gICAgICBuZXcgUHVibGlzaGVyRlNNRXZlbnQoeyBuYW1lOiBQdWJsaXNoZXJGU01FdmVudE5hbWVzLlJFU0VORF9DT01QTEVURSB9KVxuICAgICk7XG4gIH1cblxuICBfcmVzZXRDb25uZWN0ZWRJbmZvKGZhaWxvdmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKCdSZXNldHRpbmcgY29ubmVjdGVkIGZsb3cgaW5mbycpO1xuXG4gICAgaWYgKHRoaXMuX2Fja1RpbWVyKSB0aGlzLl9jbGVhckFja1RpbWVyKCk7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIF9tZXNzYWdlSWRzOiBuZXcgTWVzc2FnZUlkcygpLFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wdWJsaXNoZXIsIHtcbiAgICAgIHB1Ymxpc2hlcklkOiB1bmRlZmluZWQsXG4gICAgICBmbG93SWQ6ICAgICAgdW5kZWZpbmVkLFxuICAgICAgZmxvd05hbWU6ICAgIG51bGwsXG4gICAgfSk7XG5cbiAgICBpZiAoZmFpbG92ZXIpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RSZWFzb24gPSBDb25uZWN0UmVhc29uLkZBSUxPVkVSO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGdWxsIHJlc2V0XG4gICAgICB0aGlzLl91bmFja2VkTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fY29ubmVjdFJlYXNvbiA9IENvbm5lY3RSZWFzb24uSU5JVDtcbiAgICB9XG4gIH1cblxuICBfY2xlYXJBY2tUaW1lcigpIHtcbiAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX1RSQUNFKGBDbGVhciBhY2sgdGltZXIgJHt0aGlzLl9hY2tUaW1lciA/IHRoaXMuX2Fja1RpbWVyIDogJ3VuZGVmaW5lZCBvciBudWxsIG9yIHplcm8nfWApO1xuICAgIGlmICghdGhpcy5fYWNrVGltZXIpIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fYWNrVGltZXIpO1xuICAgIHRoaXMuX2Fja1RpbWVyID0gbnVsbDtcbiAgfVxuXG4gIF9lbWl0U3RhdGVFdmVudHMoKSB7XG4gICAgY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19UUkFDRSgnRW1pdHRpbmcgZGVmZXJyZWQgc3RhdGUgZXZlbnRzJyk7XG4gICAgd2hpbGUgKHRoaXMuX3N0YXRlRXZlbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFpciA9IHRoaXMuX3N0YXRlRXZlbnRzLnNoaWZ0KCk7XG4gICAgICBjb25zdCBzdGF0ZSA9IHBhaXJbMF07XG4gICAgICBjb25zdCBldmVudCA9IHBhaXJbMV07XG4gICAgICAvLyBJZiB0aGUgc3RhdGUgcmVxdWVzdGluZyB0aGlzIGV2ZW50IGlzIHN0aWxsIGFjdGl2ZS4uLlxuICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlU3RhdGUoc3RhdGUuZ2V0TmFtZSgpKSkge1xuICAgICAgICAvLyB0aGVuIGRvIGl0cyBhY3Rpb25cbiAgICAgICAgZXZlbnQuYXBwbHkoc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUFja1RpbWVvdXQoKSB7XG4gICAgY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19UUkFDRSgnQWNrIFRpbWVvdXQnKTtcbiAgICB0aGlzLl9hY2tUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fcHVibGlzaGVyLmluY1N0YXQoU3RhdFR5cGUuVFhfQUNLX1RJTUVPVVQpO1xuICAgIHRoaXMucHJvY2Vzc0V2ZW50KG5ldyBQdWJsaXNoZXJGU01FdmVudCh7IG5hbWU6IFB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuQUNLX1RJTUVPVVQgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSByZW1vdGUgZmxvdyBjaGFuZ2VzLCBhbnkgcmVtb3RlIHN0YXRlIGFwcGxpZWQgdG8gdGhlIHVuYWNrZWQgbWVzc2FnZXMgbmVlZHMgdG9cbiAgICogYmUgcmVhcHBsaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHJlbnVtYmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbnVtYmVyKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlSWRzID0gdGhpcy5fbWVzc2FnZUlkcztcbiAgICBjb25zdCBjdXJyZW50ID0gbWVzc2FnZUlkcy5uZXh0O1xuICAgIG1lc3NhZ2Uuc2V0R3VhcmFudGVlZFByZXZpb3VzTWVzc2FnZUlkKG1lc3NhZ2VJZHMubGFzdFNlbnQpO1xuICAgIG1lc3NhZ2Uuc2V0R3VhcmFudGVlZE1lc3NhZ2VJZChjdXJyZW50KTtcblxuICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMuX3B1Ymxpc2hlcjtcbiAgICBtZXNzYWdlLnNldEZsb3dJZChwdWJsaXNoZXIuZmxvd0lkKTtcbiAgICBtZXNzYWdlLnNldFB1Ymxpc2hlcklkKHB1Ymxpc2hlci5wdWJsaXNoZXJJZCk7XG4gIH1cblxuICBfcmVzZXRBY2tUaW1lcigpIHtcbiAgICB0aGlzLl9jbGVhckFja1RpbWVyKCk7XG4gICAgdGhpcy5fc3RhcnRBY2tUaW1lcigpO1xuICB9XG5cbiAgX3NjaGVkdWxlU3RhdGVFdmVudHMoc3RhdGUsIGV2ZW50KSB7XG4gICAgdGhpcy5fc3RhdGVFdmVudHMucHVzaChbc3RhdGUsIGV2ZW50XSk7XG4gICAgdGhpcy5fc2V0UG9zdEV2ZW50QWN0aW9uKCgpID0+IHRoaXMuX2VtaXRTdGF0ZUV2ZW50cygpLCAnRW1pdCBzdGF0ZSBldmVudHMnKTtcbiAgfVxuXG4gIF9zZXRQb3N0RXZlbnRBY3Rpb24oYWN0aW9uLCBkZXNjID0gJ05vIGFjdGlvbicpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRywgTE9HX1dBUk4gfSA9IHRoaXMubG9nZ2VyO1xuICAgIGlmICh0aGlzLl9wb3N0RXZlbnRBY3Rpb24gJiYgdGhpcy5fcG9zdEV2ZW50QWN0aW9uLmRlc2MgPT09IGRlc2MpIHtcbiAgICAgIExPR19ERUJVRygnS2VlcGluZyBzYW1lIHBvc3QgZXZlbnQgYWN0aW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Bvc3RFdmVudEFjdGlvbiAmJiB0aGlzLl9wb3N0RXZlbnRBY3Rpb24uZGVzYykge1xuICAgICAgTE9HX1dBUk4oYFJlcGxhY2luZyBwb3N0IGV2ZW50IGFjdGlvbiAke3RoaXMuX3Bvc3RFdmVudEFjdGlvbi5kZXNjfSB3aXRoICR7ZGVzY31gKTtcbiAgICB9XG4gICAgdGhpcy5fcG9zdEV2ZW50QWN0aW9uID0geyBhY3Rpb246IGFjdGlvbiB8fCAoKCkgPT4ge30pLCBkZXNjIH07XG4gICAgdGhpcy5zZXRQb3N0RXZlbnRBY3Rpb24oKCkgPT4ge1xuICAgICAgdGhpcy5fcG9zdEV2ZW50QWN0aW9uLmFjdGlvbigpO1xuICAgICAgdGhpcy5fcG9zdEV2ZW50QWN0aW9uID0gbnVsbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0YXJ0QWNrVGltZXIoKSB7XG4gICAgLy8gY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHRoaXMubG9nZ2VyO1xuICAgIC8vIExPR19UUkFDRShgU3RhcnQgYWNrIHRpbWVyICR7dGhpcy5fYWNrVGltZXIgPyB0aGlzLl9hY2tUaW1lciA6ICd1bmRlZmluZWQgb3IgbnVsbCBvciB6ZXJvJ1xuICAgIC8vICAgICAgICAgICB9OiAke3RoaXMuX2Fja25vd2xlZGdlVGltZW91dEluTXNlY3N9IG1zYCk7XG4gICAgaWYgKHRoaXMuX2Fja1RpbWVyKSByZXR1cm47XG4gICAgdGhpcy5fYWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2hhbmRsZUFja1RpbWVvdXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWNrbm93bGVkZ2VUaW1lb3V0SW5Nc2Vjcyk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5QdWJsaXNoZXJGU00gPSBQdWJsaXNoZXJGU007XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1tZXNzYWdlLXB1Ymxpc2hlci9saWIvcHVibGlzaGVyLWZzbS5qcyIsImNvbnN0IHsgRW51bSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQHByaXZhdGVcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBTdGF0ZSBuYW1lcyBvbiB0aGUgUHVibGlzaGVyIEZTTVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuY29uc3QgUHVibGlzaGVyU3RhdGVOYW1lcyA9IHtcbiAgVU5CT1VORDogICAgICAgICAnUHVibGlzaGVyVW5ib3VuZCcsXG4gIE9QRU5GTE9XU0VOVDogICAgJ1B1Ymxpc2hlck9wZW5GbG93U2VudCcsXG4gIFVQOiAgICAgICAgICAgICAgJ1B1Ymxpc2hlclVwJyxcbiAgRkFJTEVEOiAgICAgICAgICAnUHVibGlzaGVyRmFpbGVkJyxcbiAgQ0xPU0VGTE9XU0VOVDogICAnUHVibGlzaGVyQ2xvc2VGbG93U2VudCcsXG4gIERBVEFfWEZFUjogICAgICAgJ1B1Ymxpc2hlckRhdGFYZmVyJyxcbiAgRkxPV19DT05UUk9MTEVEOiAnTWVzc2FnZVB1Ymxpc2hlckZsb3dDb250cm9sbGVkJyxcbiAgUkVUUkFOU01JVFRJTkc6ICAnUHVibGlzaGVyUmV0cmFuc21pdHRpbmcnLFxufTtcblxubW9kdWxlLmV4cG9ydHMuUHVibGlzaGVyU3RhdGVOYW1lcyA9IEVudW0ubmV3KFB1Ymxpc2hlclN0YXRlTmFtZXMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXIvbGliL3B1Ymxpc2hlci1zdGF0ZS1uYW1lcy5qcyIsImNvbnN0IGNsb25lID0gcmVxdWlyZSgnY2xvbmUnKTtcbmNvbnN0IHsgQ29kZWM6IFNEVENvZGVjIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2R0Jyk7XG5jb25zdCB7IENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IERlc3RpbmF0aW9uIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlLCBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IExPR19ERUJVRyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBNZXNzYWdlQ2FjaGVTdGF0dXMgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1jYWNoZS1zdGF0dXMnKTtcbmNvbnN0IHsgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUgfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1kZWxpdmVyeS1tb2RlLXR5cGVzJyk7XG5jb25zdCB7IE1lc3NhZ2VEdW1wRmxhZyB9ID0gcmVxdWlyZSgnLi9tZXNzYWdlLWR1bXAtZmxhZ3MnKTtcbmNvbnN0IHsgTWVzc2FnZUR1bXBVdGlsIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtZHVtcC11dGlsJyk7XG5jb25zdCB7IE1lc3NhZ2VUeXBlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtdHlwZXMnKTtcbmNvbnN0IHsgTWVzc2FnZVVzZXJDb3NUeXBlIH0gPSByZXF1aXJlKCcuL21lc3NhZ2UtdXNlci1jb3MtdHlwZXMnKTtcbmNvbnN0IHsgUGFyYW1ldGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcbmNvbnN0IHsgU0RURmllbGQsIFNEVEZpZWxkVHlwZSwgU0RUTWFwQ29udGFpbmVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2R0Jyk7XG5cbmNvbnN0IHtcbiAgdXRmOFRvVWNzMixcbn0gPSBDb252ZXJ0O1xuY29uc3Qge1xuICBpc0Jvb2xlYW4sXG4gIGlzRW51bU1lbWJlcixcbiAgaXNJbnN0YW5jZU9mLFxuICBpc0luc3RhbmNlT2ZPck5vdGhpbmcsXG4gIGlzTnVtYmVyT3JOb3RoaW5nLFxuICBpc1N0cmluZ09yTm90aGluZyxcbn0gPSBQYXJhbWV0ZXI7XG5cbi8vIFdoZW4gYSBtZXNzYWdlIGlzIGNsb25lZCBmb3Igc2VuZGluZyxcbi8vICogV2UgYXNzdW1lIHRoYXQgaXQgbWF5IE5PVCBpbmNsdWRlIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4vLyAgIFRoZXNlIGFyZSBhbHNvIHVuc3VwcG9ydGVkIGluIHRoZSBlbmNvZGVyLlxuLy8gKiBXZSBhc3N1bWUgdGhhdCBhbGwgcHJvcGVydGllcyB0byBiZSBjbG9uZWQgYXJlIGVudW1lcmFibGUuXG4vLyAgIFRoaXMgaGFzIHNpZ25pZmljYW50ICh+MTAlIEFEIHNlbmQgcmF0ZSkgcGVyZm9ybWFuY2UgaW1wYWN0LlxuXG5jb25zdCBNRVNTQUdFX0NMT05FX09QVElPTlMgPSB7IGNpcmN1bGFyOiBmYWxzZSwgaW5jbHVkZU5vbkVudW1lcmFibGU6IGZhbHNlIH07XG5cbi8qKlxuICogRnVuY3Rpb24gY2FsbGVkIG9uIGNvbnN0cnVjdC9yZXNldC4gU2V0cyB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIGZpZWxkcyB0aGF0IGhhdmUgdGhlbS5cbiAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBpbml0aWFsaXplXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5pdE1lc3NhZ2UobWVzc2FnZSkge1xuICBtZXNzYWdlLl9kZWxpdmVyeU1vZGUgPSBNZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5ESVJFQ1Q7XG4gIG1lc3NhZ2UuX3VzZXJDb3MgPSBNZXNzYWdlVXNlckNvc1R5cGUuQ09TMTtcbiAgbWVzc2FnZS5fY2FjaGVTdGF0dXMgPSBNZXNzYWdlQ2FjaGVTdGF0dXMuTElWRTtcbiAgbWVzc2FnZS5fcHJpb3JpdHkgPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY2FsbGVkIG9uIHJlc2V0IG9ubHkuIENsZWFycyBldmVyeSBmaWVsZCBpbiB0aGUgbWVzc2FnZS4gQ2FsbCAjaW5pdE1lc3NhZ2VcbiAqIHRvIHNldCBpbml0aWFsIHZhbHVlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBjbGVhclxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNsZWFyTWVzc2FnZShtZXNzYWdlKSB7XG4gIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKG1lc3NhZ2UpO1xuICBmaWVsZHMuZm9yRWFjaChmID0+IGRlbGV0ZSBtZXNzYWdlW2ZdKTtcbn1cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiA8Yj5UaGlzIGNsYXNzIGlzIG5vdCBleHBvc2VkIGZvciBjb25zdHJ1Y3Rpb24gYnkgQVBJIHVzZXJzLiBVc2VycyBzaG91bGQgb2J0YWluIGFuIGluc3RhbmNlIGZyb21cbiAqIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVNZXNzYWdlfTwvYj5cbiAqIDxwPlxuICogQSBtZXNzYWdlIGlzIGEgY29udGFpbmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYW5kIHNlbmQgbWVzc2FnZXMgdG8gYW5kIGZyb20gdGhlXG4gKiBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuXG4gKlxuICogQXBwbGljYXRpb25zIG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mIGEgbWVzc2FnZTsgYSBtZXNzYWdlIGlzIGNyZWF0ZWQgYnkgY2FsbGluZ1xuICoge0BsaW5rIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LmNyZWF0ZU1lc3NhZ2V9IGFuZCBpcyBmcmVlZCBieSBkZXJlZmVyZW5jaW5nIGl0LlxuICpcbiAqIEFQSSBvcGVyYXRpb25zIHRoYXQgY2FjaGUgb3IgbXV0YXRlIG1lc3NhZ2VzIGFsd2F5cyB0YWtlIGEgY29weS4gQSBtZXNzYWdlIG1heVxuICogYmUgY3JlYXRlZCwgbXV0YXRlZCBieSB0aGUgQVBJIHVzZXIsIGFuZCBzZW50IG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFRoZSBNZXNzYWdlIE9iamVjdCBwcm92aWRlcyBtZXRob2RzIHRvIG1hbmlwdWxhdGUgdGhlIGNvbW1vbiBTb2xhY2VcbiAqIG1lc3NhZ2UgaGVhZGVyIGZpZWxkcyB0aGF0IGFyZSBvcHRpb25hbGx5IHNlbnQgaW4gdGhlIGJpbmFyeSBtZXRhZGF0YVxuICogcG9ydGlvbiBvZiB0aGUgU29sYWNlIG1lc3NhZ2UuXG4gKlxuICogQXBwbGljYXRpb25zIGNhbiBhbHNvIHVzZSB0aGUgc3RydWN0dXJlZCBkYXRhIEFQSSB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0U2R0Q29udGFpbmVyfVxuICogdG8gYWRkIGNvbnRhaW5lcnMgKG1hcHMgb3Igc3RyZWFtcykgYW5kIHRoZWlyIGZpZWxkcyB0byB0aGUgYmluYXJ5IHBheWxvYWQgb3JcbiAqIHRvIHRoZSBVc2VyIFByb3BlcnR5IG1hcCBjb250YWluZWQgd2l0aGluIHRoZSBiaW5hcnkgbWV0YWRhdGEuXG4gKlxuICogVGhpcyBkb2VzIG5vdCBwcmV2ZW50IGFwcGxpY2F0aW9ucyBmcm9tIGlnbm9yaW5nIHRoZXNlXG4gKiBtZXRob2RzIGFuZCBzZW5kaW5nIHBheWxvYWQgaW4gdGhlIGJpbmFyeSBwYXlsb2FkIGFzIGFuIG9wYXF1ZSBiaW5hcnkgZmllbGQgZm9yXG4gKiBlbmQtdG8tZW5kIGNvbW11bmljYXRpb25zXG4gKlxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jbGFzcyBNZXNzYWdlIHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICoqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpbml0TWVzc2FnZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXlsb2FkIHR5cGUgKHtAbGluayBzb2xhY2UuTWVzc2FnZVR5cGV9KSBvZiB0aGUgbWVzc2FnZS4gQSBtZXNzYWdlIGhhcyBhXG4gICAqIHN0cnVjdHVyZWQgcGF5bG9hZCBpZiBvbmUgd2FzIGF0dGFjaGVkIHZpYSB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0U2R0Q29udGFpbmVyfSBvdGhlcndpc2VcbiAgICogaWYgdGhlIHBheWxvYWQgaXMgYXR0YWNoZWQgdmlhIHtAbGluayBNZXNzYWdlQHNldEJpbmFyeUF0dGFjaG1lbnR9IHRoZW4gaXRcbiAgICogaXMgdW5zdHJ1Y3R1cmVkICgoQGxpbmsgc29sYWNlLk1lc3NhZ2VUeXBlI0JJTkFSWX0pXG4gICAqXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZVR5cGV9IFRoZSBzdHJ1Y3R1cmVkIHBheWxvYWQgdHlwZS5cbiAgICogQGRlZmF1bHQge3NvbGFjZS5NZXNzYWdlVHlwZS5CSU5BUll9XG4gICAqL1xuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlVHlwZSB8fCBNZXNzYWdlVHlwZS5CSU5BUlk7IC8vIFRoaXMgaXMgT0s7IEJJTkFSWSA9PT0gMC5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhcHBsaWNhdGlvbi1wcm92aWRlZCBtZXNzYWdlIElELlxuICAgKiBAcGFyYW0gez9TdHJpbmd9IHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBhcHBsaWNhdGlvbi1wcm92aWRlZCBtZXNzYWdlIElELlxuICAgKi9cbiAgc2V0QXBwbGljYXRpb25NZXNzYWdlSWQodmFsdWUpIHtcbiAgICB0aGlzLl9hcHBsaWNhdGlvbk1lc3NhZ2VJZCA9IGlzU3RyaW5nT3JOb3RoaW5nKCdhcHBsaWNhdGlvbk1lc3NhZ2VJZCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhcHBsaWNhdGlvbi1wcm92aWRlZCBtZXNzYWdlIElELlxuICAgKiBAcmV0dXJucyB7P1N0cmluZ30gVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIG1lc3NhZ2UgSUQuXG4gICAqL1xuICBnZXRBcHBsaWNhdGlvbk1lc3NhZ2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25NZXNzYWdlSWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXBwbGljYXRpb24gbWVzc2FnZSB0eXBlLiBUaGlzIHZhbHVlIGlzIHVzZWQgYnkgYXBwbGljYXRpb25zXG4gICAqIG9ubHksIGFuZCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgQVBJIGFuZCBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIgdW50b3VjaGVkLlxuICAgKiBAcGFyYW0gez9TdHJpbmd9IHZhbHVlIFRoZSBhcHBsaWNhdGlvbiBtZXNzYWdlIHR5cGUuXG4gICAqL1xuICBzZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy5fYXBwbGljYXRpb25NZXNzYWdlVHlwZSA9IGlzU3RyaW5nT3JOb3RoaW5nKCdhcHBsaWNhdGlvbk1lc3NhZ2VUeXBlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFwcGxpY2F0aW9uIG1lc3NhZ2UgdHlwZS4gVGhpcyB2YWx1ZSBpcyB1c2VkIGJ5IGFwcGxpY2F0aW9uc1xuICAgKiBvbmx5LCBhbmQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIEFQSSBhbmQgU29sYWNlIE1lc3NhZ2UgUm91dGVyIHVudG91Y2hlZC5cbiAgICogQHJldHVybnMgez9TdHJpbmd9IFRoZSBhcHBsaWNhdGlvbiBtZXNzYWdlIHR5cGUuXG4gICAqL1xuICBnZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcHBsaWNhdGlvbk1lc3NhZ2VUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJpbmFyeSBhdHRhY2htZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UuIFRoZSBiaW5hcnkgYXR0YWNobWVudFxuICAgKiBpcyByZXR1cm5lZCBhcyBhIHN0cmluZywgd2hlcmVpbiBlYWNoIGNoYXJhY3RlciBoYXMgYSBjb2RlIGluIHRoZSByYW5nZVxuICAgKiAwLTI1NSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIHJlY2VpdmVkIGJ5dGUgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgez9TdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYmluYXJ5IGF0dGFjaG1lbnQuXG4gICAqL1xuICBnZXRCaW5hcnlBdHRhY2htZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlBdHRhY2htZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJpbmFyeSBhdHRhY2htZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UuIFRoZSBiaW5hcnkgYXR0YWNobWVudFxuICAgKiBtdXN0IGJlIGEgc3RyaW5nLCB3aGVyZWluIGVhY2ggY2hhcmFjdGVyIGhhcyBhIGNvZGUgaW4gdGhlIHJhbmdlIDAtMjU1XG4gICAqIHJlcHJlc2VudGluZyBleGFjdGx5IG9uZSBieXRlIGluIHRoZSBhdHRhY2htZW50LiBXaGVuIHRoaXMgbWV0aG9kIGlzXG4gICAqIHVzZWQsIHRoZSBtZXNzYWdlIHBheWxvYWQgdHlwZSBpcyB7QGxpbmsgc29sYWNlLk1lc3NhZ2VUeXBlI0JJTkFSWX1cbiAgICogU2VlIHtzb2xhY2UuTWVzc2FnZSNnZXRUeXBlfS5cbiAgICpcbiAgICogQXBwbGljYXRpb25zIG1heSBzZXQgdGhlIGJpbmFyeSBhdHRhY2htZW50IHRvIE5VTEwgb3IgdW5kZWZpbmVkIHRvXG4gICAqIHJlbW92ZSB0aGUgYmluYXJ5IGF0dGFjaG1lbnQgYW5kIGNyZWF0ZSBhIG1lc3NhZ2Ugd2l0aCBubyBwYXlsb2FkLlxuICAgKlxuICAgKiBAcGFyYW0gez9TdHJpbmd9IHZhbHVlIFNldHMgdGhlIGJpbmFyeSBhdHRhY2htZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRCaW5hcnlBdHRhY2htZW50KHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0QmluYXJ5QXR0YWNobWVudChpc1N0cmluZ09yTm90aGluZygnYmluYXJ5QXR0YWNobWVudCcsIHZhbHVlKSk7XG4gICAgdGhpcy5fbWVzc2FnZVR5cGUgPSBNZXNzYWdlVHlwZS5CSU5BUlk7XG4gIH1cbiAgX3NldEJpbmFyeUF0dGFjaG1lbnQodmFsdWUpIHtcbiAgICB0aGlzLl9iaW5hcnlBdHRhY2htZW50ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBNZXNzYWdlIGNvbnRhaW5pbmcgYSBjYWNoZWQgbWVzc2FnZSwgcmV0dXJuIHRoZSBjYWNoZSBSZXF1ZXN0IElkIHRoYXRcbiAgICogdGhlIGFwcGxpY2F0aW9uIHNldCBpbiB0aGUgY2FsbCB0byB7QGxpbmsgc29sYWNlLkNhY2hlU2Vzc2lvbiNzZW5kQ2FjaGVSZXF1ZXN0fS5cbiAgICpcbiAgICogQHJldHVybnMgez9OdW1iZXJ9IFRoZSByZXF1ZXN0IElEIG9mIHRoZSBjYWNoZSByZXF1ZXN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICBnZXRDYWNoZVJlcXVlc3RJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVSZXF1ZXN0SWQ7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNhY2hlUmVxdWVzdElEIFRoZSBjYWNoZSByZXF1ZXN0IElEIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1lc3NhZ2VcbiAgICovXG4gIF9zZXRDYWNoZVJlcXVlc3RJRChjYWNoZVJlcXVlc3RJRCkge1xuICAgIHRoaXMuX2NhY2hlUmVxdWVzdElkID0gY2FjaGVSZXF1ZXN0SUQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29ycmVsYXRpb24gSUQuICBUaGUgbWVzc2FnZSBDb3JyZWxhdGlvbiBJZFxuICAgKiBpcyBjYXJyaWVkIGluIHRoZSBTb2xhY2UgbWVzc2FnZSBoZWFkZXJzIHVubW9kaWZpZWQgYnkgdGhlIEFQSSBhbmRcbiAgICogdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci4gVGhpcyBmaWVsZCBtYXkgYmUgdXNlZCBmb3IgcGVlci10by1wZWVyXG4gICAqIG1lc3NhZ2Ugc3luY2hyb25pemF0aW9uIGFuZCBpcyBjb21tb25seSB1c2VkIGZvciBjb3JyZWxhdGluZ1xuICAgKiBhIHJlcXVlc3QgdG8gYSByZXBseS4gU2VlIHtAbGluayBzb2xhY2UuU2Vzc2lvbiNzZW5kUmVxdWVzdH0uXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBUaGUgY29ycmVsYXRpb24gSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgZ2V0Q29ycmVsYXRpb25JZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ycmVsYXRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb3JyZWxhdGlvbiBJRC4gVGhlIG1lc3NhZ2UgQ29ycmVsYXRpb24gSWRcbiAgICogaXMgY2FycmllZCBpbiB0aGUgU29sYWNlIG1lc3NhZ2UgaGVhZGVycyB1bm1vZGlmaWVkIGJ5IHRoZSBBUEkgYW5kXG4gICAqIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIuIFRoaXMgZmllbGQgbWF5IGJlIHVzZWQgZm9yIHBlZXItdG8tcGVlclxuICAgKiBtZXNzYWdlIHN5bmNocm9uaXphdGlvbiBhbmQgaXMgY29tbW9ubHkgdXNlZCBmb3IgY29ycmVsYXRpbmdcbiAgICogYSByZXF1ZXN0IHRvIGEgcmVwbHkuIFNlZSB7QGxpbmsgc29sYWNlLnNlc3Npb24jc2VuZFJlcXVlc3R9LlxuICAgKiBAcGFyYW0gez9TdHJpbmd9IHZhbHVlIFRoZSBjb3JyZWxhdGlvbiBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHNldENvcnJlbGF0aW9uSWQodmFsdWUpIHtcbiAgICB0aGlzLl9jb3JyZWxhdGlvbklkID0gaXNTdHJpbmdPck5vdGhpbmcoJ2NvcnJlbGF0aW9uSWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29ycmVsYXRpb24gS2V5LiBBIGNvcnJlbGF0aW9uIGtleSBpcyB1c2VkIHRvIGNvcnJlbGF0ZVxuICAgKiBhIG1lc3NhZ2Ugd2l0aCBpdHMgYWNrbm93bGVkZ2VtZW50IG9yIHJlamVjdGlvbi4gVGhlIGNvcnJlbGF0aW9uIGtleSBpcyBhbiBvYmplY3QgdGhhdCBpc1xuICAgKiBwYXNzZWQgYmFjayB0byB0aGUgY2xpZW50IGR1cmluZyB0aGUgcm91dGVyIGFja25vd2xlZGdlbWVudCBvciByZWplY3Rpb24uXG4gICAqXG4gICAqIFRoZSBjb3JyZWxhdGlvbiBrZXkgaXMgYSBsb2NhbCByZWZlcmVuY2VcbiAgICogdXNlZCBieSBhcHBsaWNhdGlvbnMgZ2VuZXJhdGluZyBHdWFyYW50ZWVkIG1lc3NhZ2VzLiBNZXNzYWdlcyB0aGF0IGFyZVxuICAgKiBzZW50IGluIGVpdGhlciB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlR9IG9yXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuTk9OX1BFUlNJU1RFTlR9IG1vZGUgbWF5IHNldCB0aGUgY29ycmVsYXRpb24ga2V5LlxuICAgKiBAcmV0dXJucyB7P09iamVjdH0gVGhlIGNvcnJlbGF0aW9uIEtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UsXG4gICAqIG9yIDxjb2RlPm51bGw8L2NvZGU+LCBpZiB1bnNldC5cbiAgICovXG4gIGdldENvcnJlbGF0aW9uS2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9jb3JyZWxhdGlvbktleSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvcnJlbGF0aW9uIEtleS4gQSBjb3JyZWxhdGlvbiBrZXkgaXMgdXNlZCB0byBjb3JyZWxhdGVcbiAgICogYSBtZXNzYWdlIHdpdGggaXRzIGFja25vd2xlZGdlbWVudCBvciByZWplY3Rpb24uIFRoZSBjb3JyZWxhdGlvbiBrZXkgaXMgYW4gb2JqZWN0IHRoYXQgaXNcbiAgICogcGFzc2VkIGJhY2sgdG8gdGhlIGNsaWVudCBkdXJpbmcgdGhlIHJvdXRlciBhY2tub3dsZWRnZW1lbnQgb3IgcmVqZWN0aW9uLlxuICAgKlxuICAgKiBUaGUgY29ycmVsYXRpb24ga2V5IGlzIGEgbG9jYWwgcmVmZXJlbmNlXG4gICAqIHVzZWQgYnkgYXBwbGljYXRpb25zIGdlbmVyYXRpbmcgR3VhcmFudGVlZCBNZXNzYWdlcy4gTWVzc2FnZXMgdGhhdCBhcmVcbiAgICogc2VudCBpbiBlaXRoZXIge0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5QRVJTSVNURU5UfSBvclxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLk5PTl9QRVJTSVNURU5UfSBtb2RlIG1heSBzZXQgdGhlIGNvcnJlbGF0aW9uIGtleS4gSWYgdGhpc1xuICAgKiBtZXRob2QgaXMgdXNlZCwgdGhlIGNvcnJlbGF0aW9uIGluZm9ybWF0aW9uIGlzIHJldHVybmVkXG4gICAqIHdoZW4gdGhlIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpBQ0tOT1dMRURHRURfTUVTU0FHRX0gZXZlbnRcbiAgICogaXMgbGF0ZXIgcmVjZWl2ZWQgZm9yIGFuIGFja25vd2xlZGdlZCBtZXNzYWdlIG9yIHdoZW4gdGhlXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpSRUpFQ1RFRF9NRVNTQUdFX0VSUk9SfSBpcyByZWNlaXZlZCBmb3IgYSByZWplY3RlZFxuICAgKiBtZXNzYWdlLlxuICAgKlxuICAgKiBUaGUgQVBJIG9ubHkgbWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXNzZWQgb2JqZWN0LiAgSWYgdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIHRoZVxuICAgKiBjb250ZW50cyBhcmUgdW5tb2RpZmllZCBmb3IgcHJvcGVyIGNvcnJlbGF0aW9uLCB0aGVuIGl0IGlzIHRoZSBhcHBsaWNhdGlvbidzIHJlc3BvbnNpYmlsaXR5XG4gICAqIHRvIGVuc3VyZSB0aGUgY29udGVudHMgb2YgdGhlIG9iamVjdCBhcmUgbm90IG1vZGlmaWVkLlxuICAgKlxuICAgKiBJbXBvcnRhbnQ6IDxiPlRoZSBDb3JyZWxhdGlvbiBLZXkgaXMgbm90IGluY2x1ZGVkIGluIHRoZVxuICAgKiB0cmFuc21pdHRlZCBtZXNzYWdlIGFuZCBpcyBvbmx5IHVzZWQgd2l0aCB0aGUgbG9jYWwgQVBJPC9iPlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgVGhlIGNvcnJlbGF0aW9uIEtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHNldENvcnJlbGF0aW9uS2V5KHZhbHVlKSB7XG4gICAgdGhpcy5fY29ycmVsYXRpb25LZXkgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgY29uZmlndXJlZCBmb3IgZGVsaXZlcmluZyB0byBvbmUgY2xpZW50IG9ubHkuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBjb25maWd1cmVkIGZvclxuICAgKiBkZWxpdmVyaW5nIHRvIG9uZSBjbGllbnQgb25seS5cbiAgICovXG4gIGlzRGVsaXZlclRvT25lKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxpdmVyVG9PbmUgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGNvbmZpZ3VyZWQgZm9yIGRlbGl2ZXJpbmcgdG8gb25lIGNsaWVudCBvbmx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgY29uZmlndXJlZCBmb3IgZGVsaXZlcmluZyB0byBvbmUgY2xpZW50IG9ubHkuXG4gICAqL1xuICBzZXREZWxpdmVyVG9PbmUodmFsdWUpIHtcbiAgICB0aGlzLl9zZXREZWxpdmVyVG9PbmUodGhpcy5fZGVsaXZlclRvT25lID0gaXNCb29sZWFuKCdkZWxpdmVyVG9PbmUnLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXREZWxpdmVyVG9PbmUodmFsdWUpIHtcbiAgICB0aGlzLl9kZWxpdmVyVG9PbmUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZWxpdmVyeSBtb2RlIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyB7c29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlfSByZXByZXNlbnRpbmcgdGhlIGRlbGl2ZXJ5IG1vZGUgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBnZXREZWxpdmVyeU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGl2ZXJ5TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZWxpdmVyeSBtb2RlIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZX0gdmFsdWUgVGhlIG1lc3NhZ2UgZGVsaXZlcnkgbW9kZS5cbiAgICovXG4gIHNldERlbGl2ZXJ5TW9kZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NldERlbGl2ZXJ5TW9kZShpc0VudW1NZW1iZXIoJ2RlbGl2ZXJ5TW9kZScsIHZhbHVlLCBNZXNzYWdlRGVsaXZlcnlNb2RlVHlwZSkpO1xuICB9XG4gIF9zZXREZWxpdmVyeU1vZGUodmFsdWUpIHtcbiAgICB0aGlzLl9kZWxpdmVyeU1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkZXN0aW5hdGlvbiB0byB3aGljaCB0aGUgbWVzc2FnZSB3YXMgcHVibGlzaGVkLlxuICAgKiBAcmV0dXJucyB7P0Rlc3RpbmF0aW9ufSBUaGUgZGVzdGluYXRpb24gdG8gd2hpY2ggYSBtZXNzYWdlIHdhcyBwdWJsaXNoZWQuXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzdGluYXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGVzdGluYXRpb24gKHtAbGluayBzb2xhY2UuRGVzdGluYXRpb25UeXBlI3RvcGljfSBvclxuICAgKiB7QGxpbmsgc29sYWNlLkRlc3RpbmF0aW9uVHlwZSNxdWV1ZX0pIHRvIHB1Ymxpc2ggdGhlIG1lc3NhZ2UgdG8uXG4gICAqIEBwYXJhbSB7RGVzdGluYXRpb259IHZhbHVlIFRoZSBkZXN0aW5hdGlvbiB0byBwdWJsaXNoIHRoZSBtZXNzYWdlIHRvLlxuICAgKi9cbiAgc2V0RGVzdGluYXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9zZXREZXN0aW5hdGlvbihpc0luc3RhbmNlT2YoJ2Rlc3RpbmF0aW9uJywgdmFsdWUsIERlc3RpbmF0aW9uKSk7XG4gIH1cbiAgX3NldERlc3RpbmF0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fZGVzdGluYXRpb24gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvbmUgb3IgbW9yZSBtZXNzYWdlcyBoYXZlIGJlZW4gZGlzY2FyZGVkIHByaW9yXG4gICAqIHRvIHRoZSBjdXJyZW50IG1lc3NhZ2UuIFRoaXMgaW5kaWNhdGVzIGNvbmdlc3Rpb24gZGlzY2FyZHMgb25seSBhbmRcbiAgICogaXMgbm90IGFmZmVjdGVkIGJ5IG1lc3NhZ2UgZWxpZGluZy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBvbmUgb3IgbW9yZSBtZXNzYWdlcyBoYXZlIGJlZW5cbiAgICogZGlzY2FyZGVkIHByaW9yIHRvIHRoZSBjdXJyZW50IG1lc3NhZ2U7IG90aGVyd2lzZSwgaXQgcmV0dXJucyBmYWxzZS5cbiAgICovXG4gIGlzRGlzY2FyZEluZGljYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2NhcmRJbmRpY2F0aW9uIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgZGlzY2FyZCBpbmRpY2F0aW9uXG4gICAqL1xuICBzZXREaXNjYXJkSW5kaWNhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3NldERpc2NhcmRJbmRpY2F0aW9uKGlzQm9vbGVhbignZGlzY2FyZEluZGljYXRpb24nLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXREaXNjYXJkSW5kaWNhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2Rpc2NhcmRJbmRpY2F0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGVsaWdpYmxlIGZvciBlbGlkaW5nLlxuICAgKiA8cD5cbiAgICogTWVzc2FnZSBlbGlkaW5nIGVuYWJsZXMgZmlsdGVyaW5nIG9mIGRhdGEgdG8gYXZvaWQgdHJhbnNtaXR0aW5nXG4gICAqIGV2ZXJ5IHNpbmdsZSB1cGRhdGUgdG8gYSBzdWJzY3JpYmluZyBjbGllbnQuXG4gICAqIDxwPlxuICAgKiBUaGlzIHByb3BlcnR5IGRvZXMgbm90IGluZGljYXRlIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugd2FzIGVsaWRlZC5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGVsaWdpYmxlIGZvciBlbGlkaW5nLlxuICAgKi9cbiAgaXNFbGlkaW5nRWxpZ2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsaWRpbmdFbGlnaWJsZSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgZWxpZ2libGUgZm9yIGVsaWRpbmcuXG4gICAqIDxwPlxuICAgKiBNZXNzYWdlIGVsaWRpbmcgZW5hYmxlcyBmaWx0ZXJpbmcgb2YgZGF0YSB0byBhdm9pZCB0cmFuc21pdHRpbmdcbiAgICogZXZlcnkgc2luZ2xlIHVwZGF0ZSB0byBhIHN1YnNjcmliaW5nIGNsaWVudC5cbiAgICogPHA+XG4gICAqIFRoaXMgcHJvcGVydHkgZG9lcyBub3QgaW5kaWNhdGUgd2hldGhlciB0aGUgbWVzc2FnZSB3YXMgZWxpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHNldHMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBlbGlnaWJsZSBmb3IgZWxpZGluZy5cbiAgICovXG4gIHNldEVsaWRpbmdFbGlnaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NldEVsaWRpbmdFbGlnaWJsZShpc0Jvb2xlYW4oJ3NldEVsaWRpbmdFbGlnaWJsZScsIHZhbHVlKSk7XG4gIH1cbiAgX3NldEVsaWRpbmdFbGlnaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2VsaWRpbmdFbGlnaWJsZSA9IHZhbHVlO1xuICB9XG5cbiAgLy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAqIEludGVybmFsIHVzZSBvbmx5IG1ldGhvZHMgb24gdGhlIG1lc3NhZ2UsIGZvciBmaWVsZHMgc2V0IGJ5IHRoZSBpbnRlcm5hbFxuICAvLyAqIHB1Ymxpc2hlclxuICAvLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBwdWJsaXNoZXIgSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFB1Ymxpc2hlcklkKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXJJZDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlICBUaGUgcHVibGlzaGVyIElEIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0UHVibGlzaGVySWQodmFsdWUpIHtcbiAgICB0aGlzLl9wdWJsaXNoZXJJZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBwdWJsaXNoZXIgbWVzc2FnZSBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UHVibGlzaGVyTWVzc2FnZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXJNc2dJZDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwdWJsaXNoZXIgbWVzc2FnZSBJRCB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFB1Ymxpc2hlck1lc3NhZ2VJZCh2YWx1ZSkge1xuICAgIHRoaXMuX3B1Ymxpc2hlck1zZ0lkID0gdmFsdWU7XG4gIH1cblxuICAvLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAqIFVzZXItc2V0dGFibGUgcHJvcGVydGllcyBmb3IgcHVibGlzaGluZ1xuICAvLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgR3VhcmFudGVlZCBNZXNzYWdlIFRUTCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKi9cbiAgZ2V0VGltZVRvTGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZVRvTGl2ZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBHdWFyYW50ZWVkIE1lc3NhZ2UgVFRMIHRvIHNldCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBUaGUgdGltZSB0byBsaXZlIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoZSBtZXNzYWdlIG1heSBiZSBzdG9yZWQgb24gdGhlXG4gICAqIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBiZWZvcmUgdGhlIG1lc3NhZ2UgaXMgZGlzY2FyZGVkIG9yIG1vdmVkIHRvIGEgRGVhZCBNZXNzYWdlXG4gICAqIFF1ZXVlLiBTZWUge0BsaW5rIHNvbGFjZS5NZXNzYWdlLnNldERNUUVsaWdpYmxlfS5cbiAgICpcbiAgICogU2V0dGluZyB0aGUgVGltZSBUbyBMaXZlIHRvIHplcm8gZGlzYWJsZXMgVFRMIGZvciB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IHZhbGlkIGZvciBHdWFyYW50ZWVkIG1lc3NhZ2VzIChQZXJzaXN0ZW50IGFuZCBOb24tUGVyc2lzdGVudCkuXG4gICAqIEl0IGhhcyBubyBlZmZlY3Qgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgbWVzc2FnZSB0eXBlcyB1bmxlc3MgdGhlIG1lc3NhZ2VcbiAgICogaXMgcHJvbW90ZWQgYnkgdGhlIGFwcGxpYW5jZSB0byBhIEd1YXJhbnRlZWQgbWVzc2FnZS5cbiAgICpcbiAgICogVGhlIG1heGl1bSBhbGxvd2VkIHRpbWUgdG8gbGl2ZSBpcyAzLjE1MzZFMTEgKDMxNTM2MDAwMDAwMCkgd2hpY2ggaXNcbiAgICogYXBwcm94aW1hdGVseSAxMCB5ZWFycy5cbiAgICovXG4gIHNldFRpbWVUb0xpdmUodmFsdWUpIHtcbiAgICBjb25zdCBNQVhfTUVTU0FHRV9UVExfTVMgPSAoMTAgKiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gYXBwcm94aW1hdGVseSAxMCB5ZWFyc1xuXG4gICAgLy8gQWxsb3cgcGFyc2VyIGFuZCBpbml0aWFsaXplciB0byBzZXQgdGltZVRvTGl2ZSB0byB1bmRlZmluZWRcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fdGltZVRvTGl2ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCB0eXBlIGZvciB0aW1lIHRvIGxpdmUnLFxuICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiBNQVhfTUVTU0FHRV9UVExfTVMpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCB0aW1lIHRvIGxpdmUgdmFsdWUnLFxuICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICAgIHRoaXMuX3RpbWVUb0xpdmUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P051bWJlcn0gVGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBleHBpcmF0aW9uIHZhbHVlLlxuICAgKiBUaGUgZXhwaXJhdGlvbiB0aW1lIGlzIHRoZSBVVEMgdGltZVxuICAgKiAodGhhdCBpcywgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSBtaWRuaWdodCBKYW51YXJ5IDEsIDE5NzAgVVRDKSB3aGVuIHRoZVxuICAgKiBtZXNzYWdlIGlzIHRvIGV4cGlyZS5cbiAgICovXG4gIGdldEdNRXhwaXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwaXJhdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBleHBpcmF0aW9uIHRpbWUgZmllbGQuIFRoZSBleHBpcmF0aW9uIHRpbWUgaXMgdGhlIFVUQyB0aW1lXG4gICAqICh0aGF0IGlzLCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIG1pZG5pZ2h0IEphbnVhcnkgMSwgMTk3MCBVVEMpIHdoZW4gdGhlXG4gICAqIG1lc3NhZ2UgaXMgdG8gZXhwaXJlLiBUaGUgZXhwaXJhdGlvbiB0aW1lIGlzIGNhcnJpZWQgaW4gdGhlIG1lc3NhZ2Ugd2hlbiBzZXQgdG9cbiAgICogYSBub24temVybyB2YWx1ZS4gRXhwaXJhdGlvbiB0aW1lIGlzIG5vdCBpbmNsdWRlZCB3aGVuIHRoaXMgdmFsdWUgaXMgc2V0IHRvIHplcm8gb3JcbiAgICogdW5kZWZpbmVkXG4gICAqXG4gICAqIFRoZSBtZXNzYWdlIGV4cGlyYXRpb24gdGltZSBpcyBjYXJyaWVkIHRvIGNsaWVudHMgdGhhdCByZWNlaXZlIHRoZSBtZXNzYWdlXG4gICAqIHVubW9kaWZpZWQgYW5kIGRvZXMgbm90IGVmZmVjdCB0aGUgbGlmZSBjeWNsZSBvZiB0aGUgbWVzc2FnZS4gVXNlXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXRUaW1lVG9MaXZlfSB0byBlbmZvcmNlIG1lc3NhZ2UgZXhwaXJ5IGluIHRoZSBuZXR3b3JrLlxuICAgKlxuICAgKiBAcGFyYW0gez9OdW1iZXJ9IHZhbHVlIFRoZSBuZXcgR3VhcmFudGVlZCBNZXNzYWdlIGV4cGlyYXRpb24gdmFsdWVcbiAgICovXG4gIHNldEdNRXhwaXJhdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX2V4cGlyYXRpb24gPSBpc051bWJlck9yTm90aGluZygnR01FeHBpcmF0aW9uJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgbWVzc2FnZSBpcyBHdWFyYW50ZWVkIE1lc3NhZ2UgRE1RIGVsaWdpYmxlXG4gICAqL1xuICBpc0RNUUVsaWdpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9kbXFFbGlnaWJsZSB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciBHdWFyYW50ZWVkIE1lc3NhZ2UgRE1RIChEZWFkIE1lc3NhZ2UgUXVldWUpIEVsaWdpYmxlLlxuICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0LCB3aGVuIHRoZSBtZXNzYWdlIGV4cGlyZXMgaW4gdGhlIG5ldHdvcmtcbiAgICogdGhlIG1lc3NhZ2UgaXMgc2F2ZWQgb24gYSBhcHBsaWFuY2UgZGVhZCBtZXNzYWdlIHF1ZXVlLiBPdGhlcndpc2UgdGhlIGV4cGlyZWQgbWVzc2FnZSBpc1xuICAgKiBkaXNjYXJkZWQuIFNlZSB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0VGltZVRvTGl2ZX0uXG4gICAqL1xuICBzZXRETVFFbGlnaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX3NldERNUUVsaWdpYmxlKGlzQm9vbGVhbignRE1RRWxpZ2libGUnLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXRETVFFbGlnaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuX2RtcUVsaWdpYmxlID0gdmFsdWU7XG4gIH1cblxuICAvLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vICogSW50ZXJuYWwgdXNlIG9ubHkgbWV0aG9kcyBvbiB0aGUgbWVzc2FnZSwgZm9yIGZpZWxkcyBzZXQgYnkgdGhlIGNvbnN1bWVyIGZsb3dcbiAgLy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIElEIG9mIHRoZSBmbG93IHRoYXQgcmVjZWl2ZWQgdGhpcyBtZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRGbG93SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zsb3dJZDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtMb25nfSB2YWx1ZSBUaGUgZmxvdyBJRCB0aGF0IHJlY2VpdmVkIHRoaXMgbWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Rmxvd0lkKHZhbHVlKSB7XG4gICAgdGhpcy5fZmxvd0lkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0xvbmd9IFRoZSBHdWFyYW50ZWVkIE1lc3NhZ2UgcHJldk1zZ0lkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRHdWFyYW50ZWVkUHJldmlvdXNNZXNzYWdlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1YXJhbnRlZWRQcmV2TXNnSWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7TG9uZ30gdmFsdWUgVGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBwcmV2TXNnSWQgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRHdWFyYW50ZWVkUHJldmlvdXNNZXNzYWdlSWQodmFsdWUpIHtcbiAgICB0aGlzLl9ndWFyYW50ZWVkUHJldk1zZ0lkID0gdmFsdWU7XG4gIH1cblxuICAvLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vICogUHJvcGVydGllcyBzZXQgYnkgdGhlIE1lc3NhZ2UgQ29uc3VtZXJcbiAgLy8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P3NvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9IFRoZSBhc3NvY2lhdGVkIE1lc3NhZ2UgQ29uc3VtZXIsIGlmIHJlY2VpdmVkIGJ5IGEgY29uc3VtZXJcbiAgICovXG4gIGdldE1lc3NhZ2VDb25zdW1lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3VtZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2VDb25zdW1lcn0gdmFsdWUgVGhlIE1lc3NhZ2UgQ29uc3VtZXIgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBtZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRNZXNzYWdlQ29uc3VtZXIodmFsdWUpIHtcbiAgICB0aGlzLl9jb25zdW1lciA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBNZXNzYWdlSUQgZm9yIHRoaXMgbWVzc2FnZS5cbiAgICogQHJldHVybnMgez9Mb25nfSBUaGUgR3VhcmFudGVlZCBNZXNzYWdlIE1lc3NhZ2VJRCBhc3NpZ25lZCB0byB0aGlzIG1lc3NhZ2VcbiAgICogIGJ5IHRoZSByb3V0ZXIuXG4gICAqL1xuICBnZXRHdWFyYW50ZWVkTWVzc2FnZUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9ndWFyYW50ZWVkTXNnSWQ7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7TG9uZ30gdmFsdWUgVGhlIEd1YXJhbnRlZWQgTWVzc2FnZSBtc2dJZCB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldEd1YXJhbnRlZWRNZXNzYWdlSWQodmFsdWUpIHtcbiAgICB0aGlzLl9ndWFyYW50ZWVkTXNnSWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBUb3BpYyBTZXF1ZW5jZSBOdW1iZXIuICBJZiB0aGVyZSBpcyBubyB0b3BpYyBzZXF1ZW5jZSBudW1iZXJcbiAgICogdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJucyB7P0xvbmd9IFRoZSBUb3BpYyBTZXF1ZW5jZSBudW1iZXIgYXNzaWduZWQgdG8gdGhpcyBtZXNzYWdlIGJ5IHRoZSBNZXNzYWdlIFJvdXRlci5cbiAgICovXG4gIGdldFRvcGljU2VxdWVuY2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvcGljU2VxdWVuY2VOdW1iZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtMb25nfSB0b3BpY1NlcU5vIFRoZSBUb3BpYyBTZXF1ZW5jZSBOdW1iZXIgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRUb3BpY1NlcXVlbmNlTnVtYmVyKHRvcGljU2VxTm8pIHtcbiAgICB0aGlzLl90b3BpY1NlcXVlbmNlTnVtYmVyID0gdG9waWNTZXFObztcbiAgfVxuICAvKipcbiAgICogQWNrbm93bGVkZ2VzIHRoaXMgbWVzc2FnZS5cbiAgICpcbiAgICogSWYgdGhlIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSBvbiB3aGljaCB0aGlzIG1lc3NhZ2Ugd2FzIHJlY2VpdmVkIGlzIGNvbmZpZ3VyZWQgdG8gdXNlXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyQWNrTW9kZS5DTElFTlR9LCB0aGVuIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGJ5IGFuXG4gICAqIGFwcGxpY2F0aW9uLCB0aGUgYXBwbGljYXRpb24gbXVzdCBjYWxsIHRoaXMgbWV0aG9kIHRvIGV4cGxpY2l0bHkgYWNrbm93bGVkZ2UgcmVjZXB0aW9uIG9mIHRoZVxuICAgKiBtZXNzYWdlLiBUaGlzIGZyZWVzIGxvY2FsIGFuZCByb3V0ZXIgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCBhbiB1bmFja25vd2xlZGdlZCBtZXNzYWdlLlxuICAgKlxuICAgKiBUaGUgQVBJIGRvZXMgbm90IHNlbmQgYWNrbm93bGVkZ21lbnRzIGltbWVkaWF0ZWx5LiBJdCBzdG9yZXMgdGhlIHN0YXRlIGZvclxuICAgKiBhY2tub3dsZWRnZWQgbWVzc2FnZXMgaW50ZXJuYWxseSBhbmQgYWNrbm93bGVkZ2VzIG1lc3NhZ2VzLCBpbiBidWxrLCB3aGVuIGFcbiAgICogdGhyZXNob2xkIG9yIHRpbWVyIGlzIHJlYWNoZWQuXG4gICAqXG4gICAqIEB0aHJvd3Mge0BsaW5rIHNvbGFjZS5PcGVyYXRpb25FcnJvcn1cbiAgICogICogaWYgdGhpcyBtZXNzYWdlIHdhcyBub3QgcmVjZWl2ZWQgdmlhIEd1YXJhbnRlZWQgTWVzc2FnZTtcbiAgICogICAgc3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuTUVTU0FHRV9ERUxJVkVSWV9NT0RFX01JU01BVENIfVxuICAgKiAgKiBpZiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgc29sYWNlLlNlc3Npb259IGlzIG5vdCBjb25uZWN0ZWQ7XG4gICAqICAgIHN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlNFU1NJT05fTk9UX0NPTk5FQ1RFRH1cbiAgICogICogaWYgdGhlIGFzc29jaWF0ZWQge0BsaW5rIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJ9IGlzIG5vdCBjb25uZWN0ZWRsXG4gICAqICAgIHN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfVxuICAgKi9cbiAgYWNrbm93bGVkZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Fja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ01lc3NhZ2UgY2FuIG9ubHkgYmUgYWNrbm93bGVkZ2VkIG9uY2UnLFxuICAgICAgICBFcnJvclN1YmNvZGUuTUVTU0FHRV9BTFJFQURZX0FDS05PV0xFREdFRCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWxpdmVyeU1vZGUgPT09IE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLkRJUkVDVCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdDYW5ub3QgYWNrbm93bGVkZ2UgYSBESVJFQ1QgbWVzc2FnZScsXG4gICAgICAgIEVycm9yU3ViY29kZS5NRVNTQUdFX0RFTElWRVJZX01PREVfTUlTTUFUQ0gpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NvbnN1bWVyKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0Nhbm5vdCBhY2tub3dsZWRnZSBhIGxvY2FsbHktY3JlYXRlZCBtZXNzYWdlJyxcbiAgICAgICAgRXJyb3JTdWJjb2RlLk1FU1NBR0VfREVMSVZFUllfTU9ERV9NSVNNQVRDSCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY29uc3VtZXIuX3Nlc3Npb25JbnRlcmZhY2UuY2FuQWNrKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0Nhbm5vdCBhY2tub3dsZWRnZSB1c2luZyBhc3NvY2lhdGVkIHNlc3Npb24nLFxuICAgICAgICBFcnJvclN1YmNvZGUuU0VTU0lPTl9OT1RfQ09OTkVDVEVEKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jb25zdW1lci5jYW5BY2spIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignQ2Fubm90IGFja25vd2xlZGdlIHVzaW5nIGFzc29jaWF0ZWQgTWVzc2FnZSBDb25zdW1lcicsXG4gICAgICAgIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTik7XG4gICAgfVxuICAgIHRoaXMuX2NvbnN1bWVyLmFwcGxpY2F0aW9uQWNrKHRoaXMuX2d1YXJhbnRlZWRNc2dJZCk7XG4gICAgdGhpcy5fYWNrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhY2tub3dsZWRnZSgpIGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIG1lc3NhZ2UuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzQWNrbm93bGVkZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2tlZCB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBBY2tub3dsZWRnZSBJbW1lZGlhdGVseSBtZXNzYWdlIHByb3BlcnR5IGlzIHNldCBvciBub3QuXG4gICAqIFdoZW4gdGhlIEFja25vd2xlZGdlIEltbWVkaWF0ZWx5IHByb3BlcnR5IGlzIHNldCB0byB0cnVlIG9uIGFuIG91dGdvaW5nXG4gICAqIEd1YXJhbnRlZWQgTWVzc2FnZSxcbiAgICogaXQgaW5kaWNhdGVzIHRoYXQgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBzaG91bGQgQWNrbm93bGVkZ2UgdGhpcyBtZXNzYWdlXG4gICAqIGltbWVkaWF0ZWx5IHVwb24gcmVjZWlwdC5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSwgd2hlbiBzZXQgYnkgYSBwdWJsaXNoZXIsIG1heSBvciBtYXkgbm90IGJlIHJlbW92ZWQgYnkgdGhlXG4gICAqIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBwcmlvciB0byBkZWxpdmVyeSB0byBhIGNvbnN1bWVyLCBzbyBtZXNzYWdlIGNvbnN1bWVyc1xuICAgKiBtdXN0IG5vdCBleHBlY3QgdGhlIHByb3BlcnR5IHZhbHVlIGluZGljYXRlcyBob3cgdGhlIG1lc3NhZ2Ugd2FzXG4gICAqIG9yaWdpbmFsbHkgcHVibGlzaGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgbWVzc2FnZSB3YXMgc2V0IHRvIGFja25vd2xlZGdlIGltbWVkaWF0ZWx5LlxuICAgKi9cbiAgaXNBY2tub3dsZWRnZUltbWVkaWF0ZWx5KCkge1xuICAgIHJldHVybiB0aGlzLl9hY2tJbW1lZGlhdGVseSB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBvcHRpb25hbCBBY2tub3dlbGVkZ2UgSW1tZWRpYXRlbHkgbWVzc2FnZSBwcm9wZXJ0eS5cbiAgICogV2hlbiB0aGUgQWNrbm93bGVkZ2UgSW1tZWRpYXRlbHkgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUgb24gYW4gb3V0Z29pbmcgR3VhcmFudGVlZCBNZXNzYWdlLFxuICAgKiBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIHNob3VsZCBhY2tub3dlbGVkZ2UgdGhpcyBtZXNzYWdlXG4gICAqIGltbWVkaWF0ZWx5IHVwb24gcmVjZWlwdC4gQnkgZGVmYXVsdCB0aGUgcHJvcGVydHkgaXMgc2V0IHRvIGZhbHNlIG9uIG5ld2x5IGNyZWF0ZWQgbWVzc2FnZXMuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHksIHdoZW4gc2V0IGJ5IGEgcHVibGlzaGVyLCBtYXkgb3IgbWF5IG5vdCBiZSByZW1vdmVkIGJ5IHRoZSBhcHBsaWFuY2VcbiAgICogcHJpb3IgdG8gZGVsaXZlcnkgdG8gYSBjb25zdW1lciwgc28gbWVzc2FnZSBjb25zdW1lcnMgbXVzdCBub3QgZXhwZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBpbmRpY2F0ZXMgaG93IHRoZSBtZXNzYWdlIHdhcyBvcmlnaW5hbGx5IHB1Ymxpc2hlZC4gVGhlcmVmb3JlIGlmIGEgcmVjZWl2ZWQgbWVzc2FnZVxuICAgKiBpcyBmb3J3YXJkZWQgYnkgdGhlIGFwcGxpY2F0aW9uLCB0aGUgQWNrbm93bGVkZ2UgSW1tZWRpYXRlbHkgcHJvcGVydHkgc2hvdWxkIGJlXG4gICAqIGV4cGxpY2l0bHkgc2V0IHRvIHRoZSBkZXNpcmVkIHZhbHVlICh0cnVlIG9yIGZhbHNlKS5cbiAgICpcbiAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9uIGFuIG91dGdvaW5nIGRpcmVjdCBtZXNzYWdlIGhhcyBubyBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgV2hldGhlciB0byBhY2tub3dsZWRnZSB0aGlzIG1lc3NhZ2UgaW1tZWRpYXRlbHkuXG4gICAqL1xuICBzZXRBY2tub3dsZWRnZUltbWVkaWF0ZWx5KHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0QWNrbm93bGVkZ2VJbW1lZGlhdGVseShpc0Jvb2xlYW4oJ2Fja25vd2xlZGdlSW1tZWRpYXRlbHknLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXRBY2tub3dsZWRnZUltbWVkaWF0ZWx5KHZhbHVlKSB7XG4gICAgdGhpcy5fYWNrSW1tZWRpYXRlbHkgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjYWNoZSBzdGF0dXMgb2YgdGhpcyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7P3NvbGFjZS5NZXNzYWdlQ2FjaGVTdGF0dXN9IFRoZSBjYWNoZSBzdGF0dXMgb2YgdGhpcyBtZXNzYWdlLiBUaGUgc3RhdHVzXG4gICAqIHdpbGwgYmUgTWVzc2FnZUNhY2hlU3RhdHVzLkxJVkUgdW5sZXNzIHRoZSBtZXNzYWdlIHdhcyByZXR1cm5lZCBpbiBhXG4gICAqIHJlcGx5IHRvIGEgY2FjaGUgcmVxdWVzdC5cbiAgICovXG4gIGdldENhY2hlU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZVN0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlQ2FjaGVTdGF0dXN9IGNhY2hlU3RhdHVzIFRoZSBuZXcgY2FjaGUgc3RhdHVzIGZvciB0aGlzIG1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRDYWNoZVN0YXR1cyhjYWNoZVN0YXR1cykge1xuICAgIHRoaXMuX2NhY2hlU3RhdHVzID0gY2FjaGVTdGF0dXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBtZXNzYWdlJ3MgcmVwbHkgZmllbGQgaXMgc2V0LCBpbmRpY2F0aW5nXG4gICAqIHRoYXQgdGhpcyBtZXNzYWdlIGlzIGEgcmVwbHkgdG8gYSBwcmV2aW91cyByZXF1ZXN0LiBTZWUge0BsaW5rIHNvbGFjZS5TZXNzaW9uI3NlbmRSZXF1ZXN0fS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB0aGUgc3RhdGUgb2YgdGhlIHJlcGx5IGZpZWxkLlxuICAgKi9cbiAgaXNSZXBseU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGx5TWVzc2FnZSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVzc2FnZSBoYXMgYmVlbiBtYXJrZWQgYXMgcmVkZWxpdmVyZWQgYnkgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlci5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSByZWRlbGl2ZXJlZCBmbGFnIGlzIHNldC5cbiAgICovXG4gIGlzUmVkZWxpdmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZGVsaXZlcmVkIHx8IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFRoZSByZWRlbGl2ZXJlZCBmbGFnXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRSZWRlbGl2ZXJlZCh2YWx1ZSkge1xuICAgIHRoaXMuX3JlZGVsaXZlcmVkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgPGk+cmVwbHk8L2k+IGZpZWxkIG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFNldHMgd2hldGhlciB0byBmbGFnIHRoZSBtZXNzYWdlIGFzIGEgcmVwbHkuXG4gICAqL1xuICBzZXRBc1JlcGx5TWVzc2FnZSh2YWx1ZSkge1xuICAgIHRoaXMuX3JlcGx5TWVzc2FnZSA9IGlzQm9vbGVhbignYXNSZXBseU1lc3NhZ2UnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVjZWl2ZSB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcywgZnJvbSBtaWRuaWdodCwgSmFudWFyeSAxLCAxOTcwIFVUQykuXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgcmVjZWl2ZSB0aW1lc3RhbXAsIGlmIHNldC5cbiAgICovXG4gIGdldFJlY2VpdmVyVGltZXN0YW1wKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlaXZlclRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZXBseVRvIGRlc3RpbmF0aW9uXG4gICAqIEByZXR1cm5zIHs/c29sYWNlLkRlc3RpbmF0aW9ufSBUaGUgdmFsdWUgb2YgdGhlIHJlcGx5VG8gZGVzdGluYXRpb24sIGlmIHNldC5cbiAgICovXG4gIGdldFJlcGx5VG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGx5VG87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVwbHlUbyBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0ge3NvbGFjZS5EZXN0aW5hdGlvbn0gdmFsdWUgVGhlIHJlcGx5VG8gZGVzdGluYXRpb24uXG4gICAqL1xuICBzZXRSZXBseVRvKHZhbHVlKSB7XG4gICAgdGhpcy5fcmVwbHlUbyA9IGlzSW5zdGFuY2VPZk9yTm90aGluZygncmVwbHlUbycsIHZhbHVlLCBEZXN0aW5hdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgU2VuZGVyJ3MgSUQuXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBUaGUgU2VuZGVyJ3MgSUQsIGlmIHNldC5cbiAgICovXG4gIGdldFNlbmRlcklkKCkge1xuICAgIHJldHVybiB0aGlzLl9zZW5kZXJJZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBTZW5kZXIgSUQgZm9yIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgU2VuZGVyIElEIGZvciB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHNldFNlbmRlcklkKHZhbHVlKSB7XG4gICAgdGhpcy5fc2VuZGVySWQgPSBpc1N0cmluZ09yTm90aGluZygnc2VuZGVySWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2VuZCB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcywgZnJvbSBtaWRuaWdodCwgSmFudWFyeSAxLFxuICAgKiAxOTcwIFVUQykuXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgc2VuZCB0aW1lc3RhbXAsIGlmIHNldC5cbiAgICovXG4gIGdldFNlbmRlclRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyVGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbmQgdGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMsIGZyb20gbWlkbmlnaHQsIEphbnVhcnkgMSxcbiAgICogMTk3MCBVVEMpLiBUaGlzIGZpZWxkIGNhbiBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgbWVzc2FnZVxuICAgKiBwdWJsaXNoaW5nLCBidXQgaXQgd2lsbCBub3QgYmUgZ2VuZXJhdGVkIGlmIHByZXZpb3VzbHkgc2V0IHRvIGEgbm9uLW51bGwgdmFsdWUgYnkgdGhpcyBtZXRob2QuXG4gICAqIFNlZSB7QGxpbmsgc29sYWNlLlNlc3Npb25Qcm9wZXJ0aWVzI2dlbmVyYXRlU2VuZFRpbWVzdGFtcHN9LlxuICAgKlxuICAgKiBBbiBhcHBsaWNhdGlvbiB0aGF0IHB1Ymxpc2hlcyB0aGUgc2FtZSB7QGxpbmsgc29sYWNlLk1lc3NzYWdlfSBtdWx0aXBsZSB0aW1lcyBhbmRcbiAgICogYWxzbyB3YW50cyBnZW5lcnRlZCB0aW1lc3RhbXBzIG9uIGVhY2ggbWVzc2FnZXMsIHNob3VsZCBzZXQgdGhlIHNlbmRlciB0aW1lc3RhbXBcbiAgICogdG8gdW5kZWZpbmVkIGFmdGVyIGVhY2ggY2FsbCB0byB7QGxpbmsgc29sYWNlLlNlc3Npb24jc2VuZH0uXG4gICAqIEBwYXJhbSB7P051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBhcyB0aGUgc2VuZCB0aW1lc3RhbXAuXG4gICAqL1xuICBzZXRTZW5kZXJUaW1lc3RhbXAodmFsdWUpIHtcbiAgICB0aGlzLl9zZW5kZXJUaW1lc3RhbXAgPSBpc051bWJlck9yTm90aGluZygnc2VuZGVyVGltZXN0YW1wJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNlcXVlbmNlIG51bWJlci5cbiAgICogPHA+XG4gICAqIFRoaXMgaXMgYW4gYXBwbGljYXRpb24tZGVmaW5lZCBmaWVsZCxcbiAgICogc2VlIDxjb2RlPntAbGluayBzb2xhY2UuTWVzc2FnZSNzZXRTZXF1ZW5jZU51bWJlcn0oKTwvY29kZT4uXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgc2VxdWVuY2UgbnVtYmVyLCBpZiBzZXRcbiAgICovXG4gIGdldFNlcXVlbmNlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXF1ZW5jZU51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhcHBsaWNhdGlvbi1kZWZpbmVkIHNlcXVlbmNlIG51bWJlci4gSWYgdGhlIHNlcXVlbmNlIG51bWJlclxuICAgKiBpcyBub3Qgc2V0LCBvciBzZXQgdG8gdW5kZWZpbmVkLCBhbmQge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNnZW5lcmF0ZVNlcXVlbmNlTnVtYmVyfVxuICAgKiBpcyB0cnVlLCB0aGVuIGEgc2VxdWVuY2UgbnVtYmVyIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZvciBlYWNoIHNlbnQgbWVzc2FnZS5cbiAgICogQHBhcmFtIHs/TnVtYmVyfSB2YWx1ZSBUaGUgc2VxdWVuY2UgbnVtYmVyLlxuICAgKi9cbiAgc2V0U2VxdWVuY2VOdW1iZXIodmFsdWUpIHtcbiAgICB0aGlzLl9zZXF1ZW5jZU51bWJlciA9IGlzTnVtYmVyT3JOb3RoaW5nKCdzZXF1ZW5jZU51bWJlcicsIHZhbHVlKTtcbiAgICB0aGlzLl9hdXRvU2VxdWVuY2VOdW1iZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBDbGFzcyBvZiBTZXJ2aWNlIChDb1MpIHZhbHVlIGZvciB0aGUgbWVzc2FnZS5cbiAgICogVGhlIENsYXNzIG9mIFNlcnZpY2UgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGRpcmVjdCBhbmQgZ3VhcmFudGVlZCBtZXNzYWdlcy5cbiAgICpcbiAgICogRm9yIG1lc3NhZ2VzIHB1Ymxpc2hlZCB3aXRoIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUfSwgdGhlXG4gICAqIGNsYXNzIG9mIHNlcnZpY2Ugc2VsZWN0cyB0aGUgd2VpZ2h0ZWQgcm91bmQtcm9iaW4gZGVsaXZlcnkgcXVldWUgd2hlbiB0aGVcbiAgICogbWVzc2FnZSBpcyBmb3J3YXJkZWQgdG8gYSBjb25zdW1lci4gIHtAbGluayBzb2xhY2UuTWVzc2FnZVVzZXJDb3NUeXBlLkNPUzF9IGFyZSB0aGVcbiAgICogbG93ZXN0IHByaW9yaXR5IG1lc3NhZ2VzIGFuZCB3aWxsIHVzZSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIEQtMSBkZWxpdmVyeSBxdWV1ZXMuXG4gICAqXG4gICAqIEZvciBtZXNzYWdlcyBwdWJsaXNoZWQgYXMgZ3VhcmFudGVlZCBtZXNzYWdlc1xuICAgKiAoe0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5QRVJTSVNURU5UfSBvclxuICAgKiB7QGxpbmsgc29sYWNlLnNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5OT05fUEVSU0lTVEVOVH0pLCBtZXNzYWdlcyBwdWJsaXNoZWRcbiAgICogd2l0aCB7QGxpbmsgc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZS5DT1MxfSBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBpZlxuICAgKiB0aGF0IG1lc3NhZ2Ugd291bGQgY2F1c2UgYW55IHF1ZXVlIG9yIHRvcGljLWVuZHBvaW50IHRvIGV4Y2VlZCBpdHMgY29uZmlndXJlZFxuICAgKiBsb3ctcHJpb3JpdHktbWF4LW1zZy1jb3VudC5cbiAgICpcbiAgICogQHJldHVybnMge3NvbGFjZS5NZXNzYWdlVXNlckNvc1R5cGV9IFRoZSBDT1MgdmFsdWUuXG4gICAqL1xuICBnZXRVc2VyQ29zKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyQ29zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIE1lc3NhZ2UgUHJpb3JpdHkgUGFyYW1ldGVyIChKTVMgUHJpb3JpdHkpIHZhbHVlIGZvciB0aGUgbWVzc2FnZS5cbiAgICogTnVtZXJpY2FsIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDI1NSBhcmUgdmFsaWQgcmV0dXJuIHZhbHVlcyxcbiAgICogdW5kZWZpbmVkIG1lYW5zIHRoZSBwYXJhbWV0ZXIgaXMgbm90IHByZXNlbnQuXG4gICAqXG4gICAqIElmIGRlc3RpbmF0aW9uIHF1ZXVlcyBhbmQgdG9waWMgZW5kcG9pbnRzIGZvciB0aGlzIG1lc3NhZ2VcbiAgICogYXJlIGNvbmZpZ3VyZWQgdG8gcmVzcGVjdCBtZXNzYWdlIHByaW9yaXR5LFxuICAgKiB0aGUgdmFsdWVzIDAgdGhyb3VnaCA5IGNhbiBiZSB1c2VkIHRvIGFmZmVjdCB0aGUgcHJpb3JpdHlcbiAgICogb2YgZGVsaXZlcnkgdG8gY29uc3VtZXJzIG9mIHRob3NlIHF1ZXVlcyBvciB0b3BpYyBlbmRwb2ludHMuXG4gICAqIEZvciB0aGUgcHVycG9zZXMgb2YgcHJpb3JpdGl6ZWQgbWVzc2FnZSBkZWxpdmVyeSxcbiAgICogdmFsdWVzIGxhcmdlciB0aGFuIDkgYXJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgOS5cbiAgICpcbiAgICogQHJldHVybnMgez9OdW1iZXJ9IFRoZSBNZXNzYWdlIFByaW9yaXR5IFBhcmFtZXRlciB2YWx1ZS5cbiAgICovXG4gIGdldFByaW9yaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wcmlvcml0eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBDbGFzcyBvZiBTZXJ2aWNlIChDb1MpIHZhbHVlIGZvciB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogVGhlIENsYXNzIG9mIFNlcnZpY2UgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGRpcmVjdCBhbmQgZ3VhcmFudGVlZCBtZXNzYWdlcy5cbiAgICpcbiAgICogRm9yIG1lc3NhZ2VzIHB1Ymxpc2hlZCB3aXRoIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUfSwgdGhlXG4gICAqIGNsYXNzIG9mIHNlcnZpY2Ugc2VsZWN0cyB0aGUgd2VpZ2h0ZWQgcm91bmQtcm9iaW4gZGVsaXZlcnkgcXVldWUgd2hlbiB0aGVcbiAgICogbWVzc2FnZSBpcyBmb3J3YXJkZWQgdG8gYSBjb25zdW1lci4gIHtAbGluayBzb2xhY2UuTWVzc2FnZVVzZXJDb3NUeXBlI0NPUzF9IGFyZSB0aGVcbiAgICogbG93ZXN0IHByaW9yaXR5IG1lc3NhZ2VzIGFuZCB3aWxsIHVzZSB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIEQtMSBkZWxpdmVyeSBxdWV1ZXMuXG4gICAqXG4gICAqIEZvciBtZXNzYWdlcyBwdWJsaXNoZWQgYXMgZ3VhcmFudGVlZCBtZXNzYWdlc1xuICAgKiAoe0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5QRVJTSVNURU5UfSBvclxuICAgKiB7QGxpbmsgc29sYWNlLnNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5OT05fUEVSU0lTVEVOVH0pLCBtZXNzYWdlcyBwdWJsaXNoZWRcbiAgICogd2l0aCB7QGxpbmsgc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZSNDT1MxfSBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlciBpZlxuICAgKiB0aGF0IG1lc3NhZ2Ugd291bGQgY2F1c2UgYW55IHF1ZXVlIG9yIHRvcGljLWVuZHBvaW50IHRvIGV4Y2VlZCBpdHMgY29uZmlndXJlZFxuICAgKiBsb3ctcHJpb3JpdHktbWF4LW1zZy1jb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuTWVzc2FnZVVzZXJDb3NUeXBlfSB2YWx1ZSBUaGUgQ09TIHZhbHVlLlxuICAgKiBAZGVmYXVsdCB7c29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZSNDT1MxfVxuICAgKi9cbiAgc2V0VXNlckNvcyh2YWx1ZSkge1xuICAgIHRoaXMuX3NldFVzZXJDb3MoaXNFbnVtTWVtYmVyKCd1c2VyQ29zJywgdmFsdWUsIE1lc3NhZ2VVc2VyQ29zVHlwZSkpO1xuICB9XG4gIF9zZXRVc2VyQ29zKHZhbHVlKSB7XG4gICAgdGhpcy5fdXNlckNvcyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIE1lc3NhZ2UgUHJpb3JpdHkgUGFyYW1ldGVyIChKTVMgUHJpb3JpdHkpIHZhbHVlIGZvciB0aGUgbWVzc2FnZS5cbiAgICogTnVtZXJpY2FsIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDI1NSBhcmUgYWNjZXB0ZWQsXG4gICAqIHVzZSB1bmRlZmluZWQgdG8gdW5zZXQuXG4gICAqXG4gICAqIElmIGRlc3RpbmF0aW9uIHF1ZXVlcyBhbmQgdG9waWMgZW5kcG9pbnRzIGZvciB0aGlzIG1lc3NhZ2VcbiAgICogYXJlIGNvbmZpZ3VyZWQgdG8gcmVzcGVjdCBtZXNzYWdlIHByaW9yaXR5LFxuICAgKiB0aGUgdmFsdWVzIDAgdGhyb3VnaCA5IGNhbiBiZSB1c2VkIHRvIGFmZmVjdCB0aGUgcHJpb3JpdHlcbiAgICogb2YgZGVsaXZlcnkgdG8gY29uc3VtZXJzIG9mIHRob3NlIHF1ZXVlcyBvciB0b3BpYyBlbmRwb2ludHMuXG4gICAqIEZvciB0aGUgcHVycG9zZXMgb2YgcHJpb3JpdGl6ZWQgbWVzc2FnZSBkZWxpdmVyeSwgdmFsdWVzIGxhcmdlciB0aGFuIDlcbiAgICogYXJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgOS5cbiAgICpcbiAgICogQHBhcmFtIHs/TnVtYmVyfSB2YWx1ZSBUaGUgcHJpb3JpdHkgdmFsdWUuXG4gICAqL1xuICBzZXRQcmlvcml0eSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXRQcmlvcml0eSh1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCB0eXBlIGZvciBtZXNzYWdlIHByaW9yaXR5JyxcbiAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMjU1KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0ludmFsaWQgcHJpb3JpdHkgdmFsdWUnLFxuICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICAgIHRoaXMuX3NldFByaW9yaXR5KHZhbHVlKTtcbiAgfVxuXG4gIF9zZXRQcmlvcml0eSh2YWx1ZSkge1xuICAgIHRoaXMuX3ByaW9yaXR5ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBkYXRhIHBhcnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB1c2VyIGRhdGEgcGFydCBvZiB0aGUgbWVzc2FnZSwgaWYgc2V0LlxuICAgKi9cbiAgZ2V0VXNlckRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHVzZXIgZGF0YSBwYXJ0IG9mIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHVzZXIgZGF0YSBwYXJ0IG9mIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc2V0VXNlckRhdGEodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRVc2VyRGF0YShpc1N0cmluZ09yTm90aGluZygndXNlckRhdGEnLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXRVc2VyRGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuX3VzZXJEYXRhID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgWE1MIGNvbnRlbnQgcGFydCBvZiB0aGUgbWVzc2FnZS5cbiAgICogTm90aWNlIHRoYXQgdGhlIGNvbnRlbnQgaXMgZW5jb2RlZCBhcyBVVEYtOCBjaGFyYWN0ZXJzLFxuICAgKiBpdCBuZWVkcyB0byBiZSBkZWNvZGVkIGFzIEphdmFTY3JpcHQgc3Vycm9nYXRlIHBhaXI6IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUodmFsdWUpKVxuICAgKiBAcmV0dXJucyB7P1N0cmluZ30gVGhlIFhNTCBjb250ZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UsIGlmIHNldC5cbiAgICovXG4gIGdldFhtbENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3htbENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgWE1MIGNvbnRlbnQgcGFydCBvZiB0aGUgbWVzc2FnZSBkZWNvZGVkIGZyb20gVVRGLTggZW5jb2Rpbmcgb2YgdGhlIGNoYXJhY3RlcnMuXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBUaGUgWE1MIGNvbnRlbnQgcGFydCBvZiB0aGUgbWVzc2FnZS4gUmV0dXJucyA8Y29kZT5udWxsPC9jb2RlPiBpZiBub3RcbiAgICogcHJlc2VudC5cbiAgICovXG4gIGdldFhtbENvbnRlbnREZWNvZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl94bWxDb250ZW50ID8gdXRmOFRvVWNzMih0aGlzLl94bWxDb250ZW50KSA6IHRoaXMuX3htbENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgWE1MIGNvbnRlbnQgcGFydCBvZiB0aGUgbWVzc2FnZS5cbiAgICogVGhlIGNvbnRlbnQgaXMgZW5jb2RlZCBieSByZXBsYWNpbmcgZWFjaCBpbnN0YW5jZSBvZiBjZXJ0YWluIGNoYXJhY3RlcnNcbiAgICogYnkgb25lLCB0d28sIHRocmVlLCBvciBmb3VyIGVzY2FwZSBzZXF1ZW5jZXMgcmVwcmVzZW50aW5nIHRoZVxuICAgKiBVVEYtOCBlbmNvZGluZyBvZiB0aGUgY2hhcmFjdGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIFhNTCBjb250ZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRYbWxDb250ZW50KHZhbHVlKSB7XG4gICAgY29uc3Qgc2V0VmFsdWUgPSBpc1N0cmluZ09yTm90aGluZygneG1sQ29udGVudCcsIHZhbHVlKTtcbiAgICB0aGlzLl94bWxDb250ZW50ID0gc2V0VmFsdWUgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc2V0VmFsdWUpKSA6IHNldFZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHNldCBmb3IgdGhlIFhNTCBjb250ZW50IHBhcnQgb2YgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgWE1MIGNvbnRlbnQgcGFydCBvZiB0aGUgbWVzc2FnZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRYbWxDb250ZW50SW50ZXJuYWwodmFsdWUpIHtcbiAgICB0aGlzLl94bWxDb250ZW50ID0gaXNTdHJpbmdPck5vdGhpbmcoJ3htbENvbnRlbnRJbnRlcm5hbCcsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtZXNzYWdlJ3MgWE1MIG1ldGFkYXRhIHNlY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgWE1MIG1ldGFkYXRhLlxuICAgKi9cbiAgc2V0WG1sTWV0YWRhdGEodmFsdWUpIHtcbiAgICB0aGlzLl9zZXRYbWxNZXRhZGF0YShpc1N0cmluZ09yTm90aGluZygneG1sTWV0YWRhdGEnLCB2YWx1ZSkpO1xuICB9XG4gIF9zZXRYbWxNZXRhZGF0YSh2YWx1ZSkge1xuICAgIHRoaXMuX3htbE1ldGFkYXRhID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVzc2FnZSdzIFhNTCBtZXRhZGF0YSBzZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7P1N0cmluZ30gVGhlIFhNTCBtZXRhZGF0YSwgaWYgc2V0LlxuICAgKi9cbiAgZ2V0WG1sTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3htbE1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgYmluYXJ5TWV0YWRhdGFDaHVuaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5TWV0YUNodW5rIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7P1N0cmluZ30gbWV0YSBUaGUgbWV0YSBjaHVuayB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldCBiaW5hcnlNZXRhZGF0YUNodW5rKG1ldGEpIHtcbiAgICB0aGlzLl9iaW5hcnlNZXRhQ2h1bmsgPSBtZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgc21mSGVhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zbWZIZWFkZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7U01GSGVhZGVyfSB2YWwgVGhlIFNNRiBoZWFkZXIgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXQgc21mSGVhZGVyKHZhbCkge1xuICAgIHRoaXMuX3NtZkhlYWRlciA9IHZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGhhc0F1dG9TZXF1ZW5jZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1NlcXVlbmNlTnVtYmVyIHx8IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0IGhhc0F1dG9TZXF1ZW5jZU51bWJlcih2YWx1ZSkge1xuICAgIHRoaXMuX2F1dG9TZXF1ZW5jZU51bWJlciA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgaGFzQXV0b1NlbmRlclRpbWVzdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1NlbmRlclRpbWVzdGFtcCB8fCBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0IGhhc0F1dG9TZW5kZXJUaW1lc3RhbXAodmFsdWUpIHtcbiAgICB0aGlzLl9hdXRvU2VuZGVyVGltZXN0YW1wID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlciBwcm9wZXJ0eSBtYXAgY2FycmllZCBpbiB0aGUgbWVzc2FnZSBiaW5hcnkgbWV0YWRhdGEuXG4gICAqXG4gICAqIEByZXR1cm5zIHs/c29sYWNlLlNEVE1hcENvbnRhaW5lcn0gVGhlIHVzZXIgcHJvcGVydGllcyBtYXAsIGlmIHNldC5cbiAgICovXG4gIGdldFVzZXJQcm9wZXJ0eU1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlclByb3BlcnR5TWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB1c2VycyB0byBzcGVjaWZ5IHRoZWlyIG93biB1c2VyIHByb3BlcnRpZXMgdG8gYmUgY2FycmllZFxuICAgKiBpbiB0aGUgbWVzc2FnZSBiaW5hcnkgbWV0YWRhdGEgc2VwYXJhdGUgZnJvbSB0aGUgcGF5bG9hZC5cbiAgICogQHBhcmFtIHs/U0RUTWFwQ29udGFpbmVyfSB2YWx1ZSBUaGUgdXNlciBwcm9wZXJ0eSBtYXAuXG4gICAqL1xuICBzZXRVc2VyUHJvcGVydHlNYXAodmFsdWUpIHtcbiAgICB0aGlzLl91c2VyUHJvcGVydHlNYXAgPSBpc0luc3RhbmNlT2ZPck5vdGhpbmcoJ3VzZXJQcm9wZXJ0eU1hcCcsIHZhbHVlLCBTRFRNYXBDb250YWluZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIHRoaXMgbWVzc2FnZSBhIHN0cnV0dXJlZCBkYXRhIG1lc3NhZ2UgYnkgYXNzaWduaW5nIGl0IGFcbiAgICogc3RydWN0dXJlZCBkYXRhIHR5cGUgKFNEVCkgY29udGFpbmVyIHBheWxvYWQgKHN1Y2ggYXMgYVxuICAgKiB7QGxpbmsgc29sYWNlLlNEVE1hcENvbnRhaW5lcn0sIHtAbGluayBzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyfVxuICAgKiBvciBhIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlLlN0cmluZ30sIHdoaWNoIGlzIHRyYW5zcG9ydGVkIGluIHRoZSBiaW5hcnkgYXR0YWNobWVudCBmaWVsZC5cbiAgICpcbiAgICogQXNzaWduaW5nIGEgU0RUIGNvbnRhaW5lciB1cGRhdGVzIHRoZSBtZXNzYWdlJ3MgVHlwZSBwcm9wZXJ0eSB0b1xuICAgKiB0aGUgYXBwcm9wcmlhdGUgdmFsdWUuXG4gICAqXG4gICAqIFRoZSBjb250YWluZXIgYXJndW1lbnQgbXVzdCBiZSBhIHtAbGluayBzb2xhY2UuU0RURmllbGR9IHdpdGggYSB0eXBlXG4gICAqIG9mIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlLk1BUH0sIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlLlNUUkVBTX0sXG4gICAqIG9yIHtAbGluayBzb2xhY2UuU0RURmllbGRUeXBlLlNUUklOR30uXG4gICAqXG4gICAqIEBwYXJhbSB7P3NvbGFjZS5TRFRGaWVsZH0gY29udGFpbmVyIFRoZSBTRFRGaWVsZCBjb250YWluZXIgdG8gc2VuZCBpbiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRTZHRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3Qgc3RydWN0dXJlZENvbnRhaW5lciA9IGlzSW5zdGFuY2VPZk9yTm90aGluZygnc2R0Q29udGFpbmVyJywgY29udGFpbmVyLCBTRFRGaWVsZCk7XG4gICAgaWYgKHN0cnVjdHVyZWRDb250YWluZXIgPT09IG51bGwgfHwgc3RydWN0dXJlZENvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjbGVhclxuICAgICAgdGhpcy5fc3RydWN0dXJlZENvbnRhaW5lciA9IG51bGw7XG4gICAgICB0aGlzLnNldEJpbmFyeUF0dGFjaG1lbnQobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QmluYXJ5QXR0YWNobWVudChudWxsKTtcbiAgICBjb25zdCBzZHRUeXBlID0gc3RydWN0dXJlZENvbnRhaW5lci5nZXRUeXBlKCk7XG4gICAgc3dpdGNoIChzZHRUeXBlKSB7XG4gICAgICBjYXNlIFNEVEZpZWxkVHlwZS5NQVA6XG4gICAgICAgIHRoaXMuX21lc3NhZ2VUeXBlID0gTWVzc2FnZVR5cGUuTUFQO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU0RURmllbGRUeXBlLlNUUkVBTTpcbiAgICAgICAgdGhpcy5fbWVzc2FnZVR5cGUgPSBNZXNzYWdlVHlwZS5TVFJFQU07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTRFRGaWVsZFR5cGUuU1RSSU5HOlxuICAgICAgICB0aGlzLl9tZXNzYWdlVHlwZSA9IE1lc3NhZ2VUeXBlLlRFWFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogZXhwZWN0ZWQgU0RURmllbGQgVHlwZSBvZiAnICtcbiAgICAgICAgICAnTUFQLCBTVFJFQU0sIG9yIFNUUklORy4nLFxuICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICB9XG4gICAgdGhpcy5fc3RydWN0dXJlZENvbnRhaW5lciA9IHN0cnVjdHVyZWRDb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVzc2FnZSdzIHN0cnVjdHVyZWQgZGF0YSBjb250YWluZXIsIGlmIHRoaXMgaXMgYSBzdHJ1Y3R1cmVkIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybnMge1NEVEZpZWxkfG51bGx9IEEgZmllbGQgd2l0aCBhIHBheWxvYWQgb2Yge1N0cmluZ30sIHtAbGluayBTRFRNYXBDb250YWluZXJ9LFxuICAgKiBvciB7QGxpbmsgU0RUU3RyZWFtQ29udGFpbmVyfSBpZiBvbmUgd2FzIHNldCBpbiB0aGUgbWVzc2FnZTsgb3RoZXJ3aXNlLCBudWxsLlxuICAgKi9cbiAgZ2V0U2R0Q29udGFpbmVyKCkge1xuICAgIGNvbnN0IG1zZ1R5cGUgPSB0aGlzLmdldFR5cGUoKTtcbiAgICBjb25zdCBiaW5hcnlBdHRhY2htZW50ID0gdGhpcy5nZXRCaW5hcnlBdHRhY2htZW50KCk7XG4gICAgY29uc3QgYmluYXJ5QXR0YWNobWVudExlbmd0aCA9IGJpbmFyeUF0dGFjaG1lbnQgPyBiaW5hcnlBdHRhY2htZW50Lmxlbmd0aCA6IDA7XG5cbiAgICBpZiAobXNnVHlwZSA9PT0gTWVzc2FnZVR5cGUuQklOQVJZKSB7XG4gICAgICBMT0dfREVCVUcoYGdldFNkdENvbnRhaW5lciByZXR1cm5lZCBudWxsLCByZWFzb246IG1zZ1R5cGU9JHttc2dUeXBlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTUFQLCBTVFJFQU0gb3IgVEVYVFxuICAgIC8vIFVzZSBjYWNoZWQgc3RydWN0dXJlZCBjb250YWluZXIgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJ1Y3R1cmVkQ29udGFpbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cnVjdHVyZWRDb250YWluZXI7XG4gICAgfVxuXG4gICAgaWYgKGJpbmFyeUF0dGFjaG1lbnRMZW5ndGggPT09IDApIHtcbiAgICAgIExPR19ERUJVRyhgZ2V0U2R0Q29udGFpbmVyIHJldHVybmVkIG51bGwsIHJlYXNvbjogbGVuPSR7YmluYXJ5QXR0YWNobWVudExlbmd0aH1gKTtcbiAgICAgIHRoaXMuX3N0cnVjdHVyZWRDb250YWluZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMYXN0IHJlc29ydDogRGVjb2RlIGJpbmFyeSBhdHRhY2htZW50LlxuICAgICAgLy8gQ2FjaGUgc3RydWN0dXJlZCBjb250YWluZXIgZm9yIGxhdGVyIGFjY2Vzc1xuICAgICAgdGhpcy5fc3RydWN0dXJlZENvbnRhaW5lciA9IFNEVENvZGVjLnBhcnNlU2luZ2xlRWxlbWVudChiaW5hcnlBdHRhY2htZW50LCAwKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB0aGlzLl9zdHJ1Y3R1cmVkQ29udGFpbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgaHVtYW4tcmVhZGFibGUgZHVtcCBvZiB0aGUgbWVzc2FnZSdzIHByb3BlcnRpZXMgYW5kXG4gICAqIGNvbnRlbnRzLiBBcHBsaWNhdGlvbnMgbXVzdCBub3QgcGFyc2UgdGhlIG91dHB1dCwgYXMgaXRzIGZvcm1hdCBpc1xuICAgKiBub3QgYSBkZWZpbmVkIHBhcnQgb2YgdGhlIEFQSSBhbmQgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAqXG4gICAqIDxwPlxuICAgKiBPdXRwdXQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgdGhlIDxjb2RlPmZsYWdzPC9jb2RlPiBwYXJhbWV0ZXIuIFRoZSB2YWx1ZXMgYXJlOlxuICAgKiA8dWw+XG4gICAqIDxsaT57QGxpbmsgTWVzc2FnZUR1bXBGbGFnLk1TR0RVTVBfQlJJRUZ9IERpc3BsYXkgb25seSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5IGF0dGFjaG1lbnQsIHhtbCBhdHRhY2htZW50LCBhbmQgdXNlciBwcm9wZXJ0eSBtYXBcbiAgICogPGxpPntAbGluayBNZXNzYWdlRHVtcEZsYWcuTVNHRFVNUF9GVUxMfSBEaXNwbGF5IHRoZSBlbnRpcmUgbWVzc2FnZS5cbiAgICogPC91bD5cbiAgICogPC9wPlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZsYWdzXSAgT3B0aW9uYWwgZmxhZ3MgY29udHJvbGxpbmcgdGhlIG91dHB1dCwgc3VjaCBhcyB3aGV0aGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0byBpbmNsdWRlIHZlcmJvc2UgKGJpbmFyeSBkdW1wKSBpbmZvcm1hdGlvblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGR1bXAoZmxhZ3MgPSBNZXNzYWdlRHVtcEZsYWcuTVNHRFVNUF9GVUxMKSB7XG4gICAgY29uc3QgdmFsaWRGbGFncyA9IGlzRW51bU1lbWJlcignZmxhZ3MnLCBmbGFncywgTWVzc2FnZUR1bXBGbGFnKTtcbiAgICByZXR1cm4gTWVzc2FnZUR1bXBVdGlsLmR1bXAodGhpcywgdmFsaWRGbGFncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtNZXNzYWdlfSBBIGNsb25lIG9mIHRoaXMgbWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIE1FU1NBR0VfQ0xPTkVfT1BUSU9OUyk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhpcyBtZXNzYWdlLiBBbGwgdmFsdWVzIGFyZSByZWluaXRpYWxpemVkXG4gICAqIHRvIGRlZmF1bHRzLiBUaGUgbWVzc2FnZSBpcyBubyBsb25nZXIgYXNzb2NpYXRlZCB3aXRoIGFueSBzZXNzaW9uIG9yIGNvbnN1bWVyLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgY2xlYXJNZXNzYWdlKHRoaXMpO1xuICAgIGluaXRNZXNzYWdlKHRoaXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2UgPSBNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtbWVzc2FnZS9saWIvbWVzc2FnZS5qcyIsImNvbnN0IHsgQVBJUHJvcGVydGllc1ZhbGlkYXRvcnMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IFF1ZXVlRGVzY3JpcHRvciB9ID0gcmVxdWlyZSgnLi9xdWV1ZS1kZXNjcmlwdG9yJyk7XG5jb25zdCB7IFF1ZXVlVHlwZSB9ID0gcmVxdWlyZSgnLi9xdWV1ZS10eXBlcycpO1xuXG5jb25zdCB7XG4gIHZhbGlkYXRlSW5zdGFuY2UsXG4gIHZhbEJvb2xlYW4sXG4gIHZhbElzTWVtYmVyLFxuICB2YWxUb3BpY1N0cmluZyxcbn0gPSBBUElQcm9wZXJ0aWVzVmFsaWRhdG9ycztcblxuXG5jb25zdCBRdWV1ZURlc2NyaXB0b3JWYWxpZGF0b3IgPSB7XG4gIHZhbGlkYXRlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgdiA9IHZhbGlkYXRlSW5zdGFuY2UuYmluZChudWxsLCAnUXVldWVEZXNjcmlwdG9yJywgaW5zdGFuY2UpO1xuICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFF1ZXVlRGVzY3JpcHRvcikge1xuICAgICAgdignbmFtZScsIFt2YWxUb3BpY1N0cmluZ10pO1xuICAgIH0gLy8gZWxzZSBpcyBhYnN0cmFjdDsgZG9uJ3QgY2hlY2sgbmFtZVxuICAgIHYoJ3R5cGUnLCBbdmFsSXNNZW1iZXIsIFF1ZXVlVHlwZSwgJ1F1ZXVlVHlwZSddKTtcbiAgICB2KCdkdXJhYmxlJywgW3ZhbEJvb2xlYW5dKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVzY3JpcHRvclZhbGlkYXRvciA9IFF1ZXVlRGVzY3JpcHRvclZhbGlkYXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1kZXNjcmlwdG9yLXZhbGlkYXRvci5qcyIsImNvbnN0IHsgQVBJUHJvcGVydGllc1ZhbGlkYXRvcnMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IFF1ZXVlQWNjZXNzVHlwZSB9ID0gcmVxdWlyZSgnLi9xdWV1ZS1hY2Nlc3MtdHlwZXMnKTtcbmNvbnN0IHsgUXVldWVEaXNjYXJkQmVoYXZpb3IgfSA9IHJlcXVpcmUoJy4vcXVldWUtZGlzY2FyZC1iZWhhdmlvcnMnKTtcbmNvbnN0IHsgUXVldWVQZXJtaXNzaW9ucyB9ID0gcmVxdWlyZSgnLi9xdWV1ZS1wZXJtaXNzaW9ucycpO1xuXG5jb25zdCB7XG4gIHZhbGlkYXRlSW5zdGFuY2UsXG4gIHZhbEJvb2xlYW4sXG4gIHZhbElzTWVtYmVyLFxuICB2YWxOdW1iZXIsXG4gIHZhbFJhbmdlLFxufSA9IEFQSVByb3BlcnRpZXNWYWxpZGF0b3JzO1xuXG5cbmNvbnN0IFF1ZXVlUHJvcGVydGllc1ZhbGlkYXRvciA9IHtcbiAgdmFsaWRhdGUoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB2ID0gdmFsaWRhdGVJbnN0YW5jZS5iaW5kKG51bGwsICdRdWV1ZVByb3BlcnRpZXMnLCBpbnN0YW5jZSk7XG4gICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gYmV0dGVyIGNvZGUgdG8gaGFuZGxlIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICBpZiAoaW5zdGFuY2UucGVybWlzc2lvbnMpIHtcbiAgICAgIHYoJ3Blcm1pc3Npb25zJywgW3ZhbElzTWVtYmVyLCBRdWV1ZVBlcm1pc3Npb25zLCAnUXVldWVQZXJtaXNzaW9ucyddKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmFjY2Vzc1R5cGUpIHtcbiAgICAgIHYoJ2FjY2Vzc1R5cGUnLCBbdmFsSXNNZW1iZXIsIFF1ZXVlQWNjZXNzVHlwZSwgJ1F1ZXVlQWNjZXNzVHlwZSddKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnF1b3RhTUIpIHtcbiAgICAgIHYoJ3F1b3RhTUInLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICB2KCdtYXhNZXNzYWdlU2l6ZScsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0pO1xuICAgIH1cbiAgICB2KCdyZXNwZWN0c1RUTCcsIFt2YWxCb29sZWFuXSk7XG4gICAgaWYgKGluc3RhbmNlLmRpc2NhcmRCZWhhdmlvcikge1xuICAgICAgdignZGlzY2FyZEJlaGF2aW9yJywgW3ZhbElzTWVtYmVyLCBRdWV1ZURpc2NhcmRCZWhhdmlvciwgJ1F1ZXVlRGlzY2FyZEJlaGF2aW9yJ10pO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UubWF4TWVzc2FnZVJlZGVsaXZlcnkpIHtcbiAgICAgIHYoJ21heE1lc3NhZ2VSZWRlbGl2ZXJ5JywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMCwgMjU1XSk7XG4gICAgfVxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVQcm9wZXJ0aWVzVmFsaWRhdG9yID0gUXVldWVQcm9wZXJ0aWVzVmFsaWRhdG9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtcXVldWUvbGliL3F1ZXVlLXByb3BlcnRpZXMtdmFsaWRhdG9yLmpzIiwiY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHsgQVBJUHJvcGVydGllcyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgQ2hlY2sgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBRdWV1ZUFjY2Vzc1R5cGUgfSA9IHJlcXVpcmUoJy4vcXVldWUtYWNjZXNzLXR5cGVzJyk7XG5jb25zdCB7IFF1ZXVlRGlzY2FyZEJlaGF2aW9yIH0gPSByZXF1aXJlKCcuL3F1ZXVlLWRpc2NhcmQtYmVoYXZpb3JzJyk7XG5jb25zdCB7IFF1ZXVlUGVybWlzc2lvbnMgfSA9IHJlcXVpcmUoJy4vcXVldWUtcGVybWlzc2lvbnMnKTtcblxuY29uc3QgREVGQVVMVFMgPSB7XG4gIHBlcm1pc3Npb25zOiAgICAgICAgICB1bmRlZmluZWQsXG4gIGFjY2Vzc1R5cGU6ICAgICAgICAgICB1bmRlZmluZWQsXG4gIHF1b3RhTUI6ICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gIG1heE1lc3NhZ2VTaXplOiAgICAgICB1bmRlZmluZWQsXG4gIHJlc3BlY3RzVFRMOiAgICAgICAgICBmYWxzZSxcbiAgZGlzY2FyZEJlaGF2aW9yOiAgICAgIHVuZGVmaW5lZCxcbiAgbWF4TWVzc2FnZVJlZGVsaXZlcnk6IHVuZGVmaW5lZCxcbn07XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIHF1ZXVlIHByb3BlcnRpZXMgb2JqZWN0LiBNYXkgYmUgcGFzc2VkIGluIHRvXG4gKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlTWVzc2FnZUNvbnN1bWVyfSB3aGVuIGNyZWF0aW5nIGFcbiAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSBvYmplY3QuICBVcG9uIGNyZWF0aW9uIG9mIGEgcXVldWUsIHVuZGVmaW5lZCBxdWV1ZVxuICogcHJvcGVydGllcyBhcmUgc2V0IHRvIGRlZmF1bHQgdmFsdWVzIGNob3NlbiBieSB0aGUgcm91dGVyLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgUXVldWVQcm9wZXJ0aWVzIGV4dGVuZHMgQVBJUHJvcGVydGllcyB7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKERFRkFVTFRTLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzL3NldHMgcGVybWlzc2lvbnMgZm9yIHRoaXMgcXVldWUuXG4gICAqXG4gICAqIFdoZW4gY3JlYXRpbmcgYSB0ZW1wb3JhcnkgcXVldWUsIHRoZXNlIGFyZSB0aGUgcGVybWlzc2lvbnMgdGhhdCBhcHBseVxuICAgKiB0byBhbGwgb3RoZXIgdXNlcnM7IHRoZSB1c2VyIGNyZWF0aW5nIHRoZSB0ZW1wb3JhcnkgcXVldWUgaXMgYWx3YXlzXG4gICAqIGdyYW50ZWQgREVMRVRFIHBlcm1pc3Npb25zLlxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLlF1ZXVlUGVybWlzc2lvbnN9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IHBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9wZXJtaXNzaW9ucztcbiAgfVxuICBzZXQgcGVybWlzc2lvbnMobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9wZXJtaXNzaW9ucyA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMvc2V0cyB0aGUgYWNjZXNzIHR5cGUgZm9yIHRoaXMgcXVldWUuXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIG11c3QgTk9UIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHF1ZXVlIHZpYVxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlTWVzc2FnZUNvbnN1bWVyfS4gU3VjaCBhIHF1ZXVlIGhhcyBpdHNcbiAgICogYWNjZXNzIHR5cGUgZGV0ZXJtaW5lZCBieSB0aGUgcmVtb3RlIG1lc3NhZ2Ugcm91dGVyLlxuICAgKlxuICAgKiBAdHlwZSB7c29sYWNlLlF1ZXVlQWNjZXNzVHlwZX1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgYWNjZXNzVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWNjZXNzVHlwZSB8fCBERUZBVUxUUy5hY2Nlc3NUeXBlO1xuICB9XG4gIHNldCBhY2Nlc3NUeXBlKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fYWNjZXNzVHlwZSA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMvc2V0cyB0aGUgcXVvdGEsIGluIG1lZ2FieXRlcywgZm9yIHRoaXMgcXVldWUuXG4gICAqICAqIFRoZSBhbGxvd2VkIHZhbHVlcyBhcmUgKDAgPD0gcXVvdGFNQikgfHwgdW5kZWZpbmVkLlxuICAgKiAgKiBBIHZhbHVlIG9mIDAgY29uZmlndXJlcyB0aGUgcXVldWUgdG8gYWN0IGFzIGEgTGFzdC1WYWx1ZS1RdWV1ZSAoTFZRKSwgd2hlcmUgdGhlIHJvdXRlclxuICAgKiAgICBlbmZvcmNlcyBhIFF1ZXVlIGRlcHRoIG9mIG9uZSwgYW5kIG9ubHkgdGhlIG1vc3QgY3VycmVudCBtZXNzYWdlIGlzIHNwb29sZWQgYnkgdGhlXG4gICAqICAgIHF1ZXVlLiBXaGVuIGEgbmV3IG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIHRoZSBjdXJyZW50IHF1ZXVlZCBtZXNzYWdlIGlzIGZpcnN0XG4gICAqICAgIGF1dG9tYXRpY2FsbHkgZGVsZXRlZCBmcm9tIHRoZSBxdWV1ZSwgdGhlbiB0aGUgbmV3IG1lc3NhZ2UgaXMgc3Bvb2xlZC5cbiAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IHF1b3RhTUIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1b3RhTUI7XG4gIH1cbiAgc2V0IHF1b3RhTUIobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9xdW90YU1CID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cy9zZXRzIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSwgaW4gYnl0ZXMsIGZvciBhbnkgc2luZ2xlIG1lc3NhZ2Ugc3Bvb2xlZCBvbiB0aGlzIHF1ZXVlLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGdldCBtYXhNZXNzYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TWVzc2FnZVNpemU7XG4gIH1cbiAgc2V0IG1heE1lc3NhZ2VTaXplKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fbWF4TWVzc2FnZVNpemUgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzL3NldHMgd2hldGhlciB0aGlzIHF1ZXVlIHJlc3BlY3RzIFRpbWUgVG8gTGl2ZSBvbiBtZXNzYWdlcy5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBnZXQgcmVzcGVjdHNUVEwoKSB7XG4gICAgcmV0dXJuIENoZWNrLmJvb2xlYW4odGhpcy5fcmVzcGVjdHNUVEwpID8gdGhpcy5fcmVzcGVjdHNUVEwgOiBERUZBVUxUUy5yZXNwZWN0c1RUTDtcbiAgfVxuICBzZXQgcmVzcGVjdHNUVEwobmV3VmFsdWUpIHtcbiAgICB0aGlzLl9yZXNwZWN0c1RUTCA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMvc2V0cyB0aGUgZGlzY2FyZCBiZWhhdmlvciBmb3IgdGhpcyBxdWV1ZS5cbiAgICogQHR5cGUge3NvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvcn1cbiAgICogQGRlZmF1bHQge3NvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvci5OT1RJRllfU0VOREVSX09GRn1cbiAgICovXG4gIGdldCBkaXNjYXJkQmVoYXZpb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2NhcmRCZWhhdmlvciB8fCBRdWV1ZURpc2NhcmRCZWhhdmlvci5OT1RJRllfU0VOREVSX09GRjtcbiAgfVxuICBzZXQgZGlzY2FyZEJlaGF2aW9yKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fZGlzY2FyZEJlaGF2aW9yID0gbmV3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cy9zZXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0byBhdHRlbXB0IG1lc3NhZ2UgcmVkZWxpdmVyeSBmb3IgdGhpcyBxdWV1ZS5cbiAgICogICogVGhlIHZhbGlkIHJhbmdlIGlzIDAgPD0gbWF4TWVzc2FnZVJlZGVsaXZlcnkgPD0gMjU1XG4gICAqICAqIEEgdmFsdWUgb2YgMCBtZWFucyByZXRyeSBmb3JldmVyLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGdldCBtYXhNZXNzYWdlUmVkZWxpdmVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TWVzc2FnZVJlZGVsaXZlcnk7XG4gIH1cbiAgc2V0IG1heE1lc3NhZ2VSZWRlbGl2ZXJ5KG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fbWF4TWVzc2FnZVJlZGVsaXZlcnkgPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3Blcm1pc3Npb25zJzogICAgIFF1ZXVlUGVybWlzc2lvbnMuZGVzY3JpYmUodGhpcy5wZXJtaXNzaW9ucyksXG4gICAgICAnYWNjZXNzVHlwZSc6ICAgICAgUXVldWVBY2Nlc3NUeXBlLmRlc2NyaWJlKHRoaXMuYWNjZXNzVHlwZSksXG4gICAgICAncXVvdGFNQic6ICAgICAgICAgdGhpcy5xdW90YU1CLFxuICAgICAgJ21heE1lc3NhZ2VTaXplJzogIHRoaXMubWF4TWVzc2FnZVNpemUsXG4gICAgICAncmVzcGVjdHNUVEwnOiAgICAgdGhpcy5yZXNwZWN0c1RUTCxcbiAgICAgICdkaXNjYXJkQmVoYXZpb3InOiB0aGlzLmRpc2NhcmRCZWhhdmlvdXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFF1ZXVlRGlzY2FyZEJlaGF2aW9yLmRlc2NyaWJlKHRoaXMuZGlzY2FyZEJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3VuZGVmaW5lZCcsXG4gICAgICAnbWF4TWVzc2FnZVJlZGVsaXZlcnknOiB0aGlzLm1heE1lc3NhZ2VSZWRlbGl2ZXJ5LFxuICAgIH07XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlUHJvcGVydGllcyA9IFF1ZXVlUHJvcGVydGllcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXF1ZXVlL2xpYi9xdWV1ZS1wcm9wZXJ0aWVzLmpzIiwiY29uc3QgeyBFbmNvZGVTaW5nbGVFbGVtZW50IH0gPSByZXF1aXJlKCcuL2VuY29kZS1zaW5nbGUtZWxlbWVudCcpO1xuY29uc3QgeyBJRUVFNzU0TElCIH0gPSByZXF1aXJlKCcuL2llZWU3NTRsaWInKTtcbmNvbnN0IHsgUGFyc2VTaW5nbGVFbGVtZW50IH0gPSByZXF1aXJlKCcuL3BhcnNlLXNpbmdsZS1lbGVtZW50Jyk7XG5cbmNvbnN0IHsgZW5jb2RlU2luZ2xlRWxlbWVudCB9ID0gRW5jb2RlU2luZ2xlRWxlbWVudDtcbmNvbnN0IHsgcGFyc2VTaW5nbGVFbGVtZW50IH0gPSBQYXJzZVNpbmdsZUVsZW1lbnQ7XG5cbmNvbnN0IENvZGVjID0ge1xuICBlbmNvZGVTaW5nbGVFbGVtZW50LFxuICBwYXJzZVNpbmdsZUVsZW1lbnQsXG4gIElFRUU3NTRMSUIsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db2RlYyA9IENvZGVjO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9hcGkuanMiLCJcbmNvbnN0IEVuY29kZUludGVnZXIgPSB7XG5cbiAgaW50NDhUb1N0cih2SW4pIHtcbiAgICBsZXQgdiA9IHZJbjtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb25zdCBieXRlSSA9ICh2ICUgMjU2KTtcbiAgICAgIHYgPSBNYXRoLmZsb29yKHYgLyAyNTYpO1xuICAgICAgYnl0ZXMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVJKSk7XG4gICAgfVxuICAgIGJ5dGVzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gYnl0ZXMuam9pbignJyk7XG4gIH0sXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLkVuY29kZUludGVnZXIgPSBFbmNvZGVJbnRlZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9lbmNvZGUtaW50ZWdlci5qcyIsImNvbnN0IEVuY29kZVNpbmdsZUVsZW1lbnRMaWIgPSByZXF1aXJlKCcuL2VuY29kZS1zaW5nbGUtZWxlbWVudCcpO1xuY29uc3QgVXRpbExpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IEVuY29kZUhlYWRlciB9ID0gcmVxdWlyZSgnLi9lbmNvZGUtaGVhZGVyJyk7XG5jb25zdCB7IFNEVERhdGFUeXBlcyB9ID0gcmVxdWlyZSgnLi4vc2R0LWRhdGEtdHlwZXMnKTtcbmNvbnN0IHsgU0RUTWFwQ29udGFpbmVyIH0gPSByZXF1aXJlKCcuLi9zZHQtbWFwLWNvbnRhaW5lcicpO1xuXG5jb25zdCB7IGVuY29kZUhlYWRlciB9ID0gRW5jb2RlSGVhZGVyO1xuXG5jb25zdCBFbmNvZGVNYXAgPSB7XG4gIC8qKlxuICAgKiBFbmNvZGVzIGFuIFNEVCBtYXAuXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2R0bWFwIFRoZSBtYXAgdG8gcGFyc2VcbiAgICogQHJldHVybnMge1N0cmluZ30gICAgICAgIFRoZSBtYXAgaW4gYmluYXJ5IHN0cmluZyBmb3JtYXRcbiAgICovXG4gIGVuY29kZU1hcChzZHRtYXApIHtcbiAgICBjb25zdCBidWYgPSBbXTtcbiAgICBpZiAoIShzZHRtYXAgaW5zdGFuY2VvZiBTRFRNYXBDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gc2tpcCFcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IHNkdG1hcC5nZXRLZXlzKCk7XG4gICAgbGV0IHNkdGZpZWxkID0gbnVsbDtcbiAgICBsZXQgc3RyS2V5RmllbGQgPSBudWxsO1xuICAgIGxldCBzdHJLZXlOYW1lID0gbnVsbDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgc2R0ZmllbGQgPSBzZHRtYXAuZ2V0RmllbGQoa2V5c1tpXSk7XG4gICAgICBpZiAoc2R0ZmllbGQpIHtcbiAgICAgICAgLy8gPT09IEtFWSA9PT1cbiAgICAgICAgc3RyS2V5TmFtZSA9IFV0aWxMaWIuU3RyaW5nVXRpbHMubnVsbFRlcm1pbmF0ZShrZXlzW2ldKTtcbiAgICAgICAgc3RyS2V5RmllbGQgPSBlbmNvZGVIZWFkZXIoU0RURGF0YVR5cGVzLlN0cmluZywgc3RyS2V5TmFtZS5sZW5ndGgpO1xuICAgICAgICBzdHJLZXlGaWVsZCArPSBzdHJLZXlOYW1lO1xuICAgICAgICBidWYucHVzaChzdHJLZXlGaWVsZCk7XG5cbiAgICAgICAgLy8gPT09IFZBTFVFID09PVxuICAgICAgICBFbmNvZGVTaW5nbGVFbGVtZW50TGliLkVuY29kZVNpbmdsZUVsZW1lbnQuZW5jb2RlU2luZ2xlRWxlbWVudFRvQnVmKHNkdGZpZWxkLCBidWYpO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIGl0ZXIgb3ZlciBrZXlzXG4gICAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkVuY29kZU1hcCA9IEVuY29kZU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvZW5jb2RlLW1hcC5qcyIsImNvbnN0IEVuY29kZVNpbmdsZUVsZW1lbnRMaWIgPSByZXF1aXJlKCcuL2VuY29kZS1zaW5nbGUtZWxlbWVudCcpO1xuY29uc3QgeyBTRFRTdHJlYW1Db250YWluZXIgfSA9IHJlcXVpcmUoJy4uL3NkdC1zdHJlYW0tY29udGFpbmVyJyk7XG5cbmNvbnN0IEVuY29kZVN0cmVhbSA9IHtcbiAgZW5jb2RlU3RyZWFtKHNkdHN0cmVhbSkge1xuICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgIGlmICghKHNkdHN0cmVhbSBpbnN0YW5jZW9mIFNEVFN0cmVhbUNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBza2lwIVxuICAgIH1cbiAgICBsZXQgc2R0ZmllbGQgPSBudWxsO1xuICAgIHdoaWxlIChzZHRzdHJlYW0uaGFzTmV4dCgpKSB7XG4gICAgICBzZHRmaWVsZCA9IHNkdHN0cmVhbS5nZXROZXh0KCk7XG4gICAgICBpZiAoc2R0ZmllbGQpIHtcbiAgICAgICAgRW5jb2RlU2luZ2xlRWxlbWVudExpYi5FbmNvZGVTaW5nbGVFbGVtZW50LmVuY29kZVNpbmdsZUVsZW1lbnRUb0J1ZihzZHRmaWVsZCwgYnVmKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuZCBpdGVyIG92ZXIgc3RyZWFtIGVudHJpZXNcbiAgICByZXR1cm4gYnVmLmpvaW4oJycpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuRW5jb2RlU3RyZWFtID0gRW5jb2RlU3RyZWFtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9lbmNvZGUtc3RyZWFtLmpzIiwiY29uc3QgeyBEZXN0aW5hdGlvbkZyb21OZXR3b3JrLCBEZXN0aW5hdGlvblR5cGUsIFF1ZXVlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgTE9HX0RFQlVHLCBMT0dfSU5GTyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBTRFREZXN0VHlwZSB9ID0gcmVxdWlyZSgnLi4vc2R0LWRlc3RpbmF0aW9uLXR5cGVzJyk7XG5jb25zdCB7IFNEVEZpZWxkIH0gPSByZXF1aXJlKCcuLi9zZHQtZmllbGQnKTtcbmNvbnN0IHsgU0RURmllbGRUeXBlIH0gPSByZXF1aXJlKCcuLi9zZHQtZmllbGQtdHlwZXMnKTtcbmNvbnN0IHsgVG9waWMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuXG5jb25zdCBQYXJzZURlc3RpbmF0aW9uID0ge1xuICBwYXJzZURlc3RpbmF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCBkZXN0VHlwZSA9IGRhdGEuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBkZXN0Qnl0ZXMgPSBkYXRhLnN1YnN0cigxKTtcbiAgICAvLyBmaXJzdCB0cnkgdG8gY3JlYXRlIGEgZGVzdGluYXRpb24gZnJvbSB0aGUgc3RyaW5nLCB0aGlzIGhhbmRsZXMgc3RyaW5ncyB3aXRoXG4gICAgLy8gdGhlIHByZWFtYmxlICgnI1AyUC9RVUUnIG9yICcjUDJQL1RRVUUnKS5cbiAgICBsZXQgZGVzdGluYXRpb24gPSBEZXN0aW5hdGlvbkZyb21OZXR3b3JrLmNyZWF0ZURlc3RpbmF0aW9uRnJvbUJ5dGVzKGRlc3RCeXRlcyk7XG4gICAgaWYgKFNEVERlc3RUeXBlW2Rlc3RpbmF0aW9uLnR5cGVdICE9PSBkZXN0VHlwZSkge1xuICAgICAgLy8gU0RUIGRlc3RpbmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIHN0cmluZyBmb3JtYXQuIFRoaXMgbWVhbnMgZWl0aGVyOlxuICAgICAgLy8gICAgKiB0aGF0IHRoZSBzdHJpbmcgY29udGFpbnMgYSBxdWV1ZSBwcmVhbWJsZSBhbmQgdGhlIHR5cGUgaXMgdG9waWMsXG4gICAgICAvLyAgICAgIHNvIGp1c3QgbWFrZSBpdCBhIHRvcGljXG4gICAgICAvLyAgICAqIHRoYXQgdGhlIHR5cGUgaXMgcXVldWUgYW5kIHRoZSBzdHJpbmcgZG9lcyBub3QgaGF2ZSB0aGUgcHJlYW1ibGUsIHdoaWNoIG1lYW5zIHdlXG4gICAgICAvLyAgICAgIHNob3VsZCBjb25zdHJ1Y3QgYSBxdWV1ZS5cbiAgICAgIGlmIChTRFREZXN0VHlwZVtEZXN0aW5hdGlvblR5cGUuUVVFVUVdID09PSBkZXN0VHlwZSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IFF1ZXVlLmNyZWF0ZUZyb21Mb2NhbE5hbWUoZGVzdEJ5dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoU0RURGVzdFR5cGVbRGVzdGluYXRpb25UeXBlLlRPUElDXSA9PT0gZGVzdFR5cGUpIHtcbiAgICAgICAgTE9HX0RFQlVHKGBGb3VuZCBhbmQgYWxsb3dlZCBTRFQgZmllbGQgd2l0aCAgZGVzdGluYXRpb24gdHlwZSAke2Rlc3RUeXBlfSB3aGVuIGRlY29kaW5nICR7ZGVzdEJ5dGVzfSB0byAke2Rlc3RpbmF0aW9uLnR5cGV9YCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIG92ZXJyaWRlIHRoZSBmb3JtYXQgYW5kIHNldCBkZXN0VHlwZSBhcyBzcGVjaWZpZWQgaW4gdGhlIFNNRiAoaS5lLiBUT1BJQylcbiAgICAgICAgZGVzdGluYXRpb24gPSBuZXcgVG9waWMoZGVzdEJ5dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExPR19JTkZPKGBEcm9wIFNEVCBmaWVsZCB3aXRoIGludmFsaWQgZGVzdGluYXRpb24gdHlwZSAke2Rlc3RUeXBlfSB3aGVuIGRlY29kaW5nICR7ZGVzdEJ5dGVzfSB0byAke2Rlc3RpbmF0aW9uLnR5cGV9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5ERVNUSU5BVElPTiwgZGVzdGluYXRpb24pO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuUGFyc2VEZXN0aW5hdGlvbiA9IFBhcnNlRGVzdGluYXRpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLWRlc3RpbmF0aW9uLmpzIiwiY29uc3QgeyBJRUVFNzU0TElCIH0gPSByZXF1aXJlKCcuL2llZWU3NTRsaWInKTtcbmNvbnN0IHsgU0RURmllbGQgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZCcpO1xuY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZC10eXBlcycpO1xuXG5jb25zdCBQYXJzZUZsb2F0ID0ge1xuICBwYXJzZUZsb2F0RmllbGQoYnl0ZXMpIHtcbiAgICBzd2l0Y2ggKGJ5dGVzLmxlbmd0aCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5GTE9BVFRZUEUsIElFRUU3NTRMSUIuZnJvbUlFRUU3NTRTaW5nbGUoYnl0ZXMpKTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuRE9VQkxFVFlQRSwgSUVFRTc1NExJQi5mcm9tSUVFRTc1NERvdWJsZShieXRlcykpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuVU5LTk9XTiwgYnl0ZXMpO1xuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlBhcnNlRmxvYXQgPSBQYXJzZUZsb2F0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi9jb2RlYy9wYXJzZS1mbG9hdC5qcyIsImNvbnN0IFBhcnNlU2luZ2xlRWxlbWVudExpYiA9IHJlcXVpcmUoJy4vcGFyc2Utc2luZ2xlLWVsZW1lbnQnKTtcbmNvbnN0IHsgTE9HX0VSUk9SIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IFBhcnNlRmllbGRIZWFkZXIgfSA9IHJlcXVpcmUoJy4vcGFyc2UtZmllbGQtaGVhZGVyJyk7XG5jb25zdCB7IFNEVERhdGFUeXBlcyB9ID0gcmVxdWlyZSgnLi4vc2R0LWRhdGEtdHlwZXMnKTtcbmNvbnN0IHsgU0RURmllbGQgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZCcpO1xuY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZC10eXBlcycpO1xuY29uc3QgeyBTRFRNYXBDb250YWluZXIgfSA9IHJlcXVpcmUoJy4uL3NkdC1tYXAtY29udGFpbmVyJyk7XG5cbmNvbnN0IFBhcnNlTWFwID0ge1xuICBwYXJzZU1hcEF0KGRhdGEsIG9mZnNldCwgZGF0YWxlbikge1xuICAgIGNvbnN0IG1hcE9iaiA9IG5ldyBTRFRNYXBDb250YWluZXIoKTtcbiAgICBsZXQgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBvZmZzZXQgKyBkYXRhbGVuKSB7XG4gICAgICAvLyA9PT0ga2V5IGZpZWxkID09PVxuICAgICAgY29uc3Qga2V5RmllbGRIZWFkZXIgPSBQYXJzZUZpZWxkSGVhZGVyLnBhcnNlRmllbGRIZWFkZXIoZGF0YSwgcG9zKTtcbiAgICAgIHBvcyArPSBrZXlGaWVsZEhlYWRlclszXTsgLy8gY29uc3VtZWQgYnl0ZXNcbiAgICAgIC8vIHBvcyBub3cgcG9pbnRzIHRvIHN0YXJ0IG9mIHN0cmluZ1xuICAgICAgaWYgKGtleUZpZWxkSGVhZGVyWzBdICE9PSBTRFREYXRhVHlwZXMuU3RyaW5nKSB7XG4gICAgICAgIC8vIEZhaWwhXG4gICAgICAgIExPR19FUlJPUihcIkVycm9yIHBhcnNpbmcgU0RUTUFQLCBleHBlY3RlZCB0byBmaW5kIGEgc3RyaW5nIGZpZWxkIGFzIG1hcCBrZXksIGFuZCBkaWRuJ3RcIik7XG4gICAgICAgIHJldHVybiBTRFRGaWVsZC5jcmVhdGUoU0RURmllbGRUeXBlLk1BUCwgbnVsbCk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlTdHJpbmcgPSBkYXRhLnN1YnN0cihwb3MsIGtleUZpZWxkSGVhZGVyWzJdIC0gMSk7XG4gICAgICBwb3MgKz0ga2V5RmllbGRIZWFkZXJbMl07XG5cbiAgICAgIC8vID09PSB2YWx1ZSBmaWVsZCA9PT1cbiAgICAgIC8vIHBvcyBub3cgcG9pbnRzIHRvIHN0YXJ0IG9mIG5leHQgdmFsdWVcbiAgICAgIGNvbnN0IHZhbHVlRmllbGRIZWFkZXIgPSBQYXJzZUZpZWxkSGVhZGVyLnBhcnNlRmllbGRIZWFkZXIoZGF0YSwgcG9zKTtcbiAgICAgIGNvbnN0IHZhbHVlRmllbGQgPSBQYXJzZVNpbmdsZUVsZW1lbnRMaWIuUGFyc2VTaW5nbGVFbGVtZW50LnBhcnNlU2luZ2xlRWxlbWVudChkYXRhLCBwb3MpO1xuICAgICAgcG9zICs9IHZhbHVlRmllbGRIZWFkZXJbMV07IC8vIGRlY2xhcmVkIGZpZWxkIGxlbmd0aFxuICAgICAgaWYgKHZhbHVlRmllbGQpIHtcbiAgICAgICAgbWFwT2JqLmFkZEZpZWxkKGtleVN0cmluZywgdmFsdWVGaWVsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTRFRGaWVsZC5jcmVhdGUoU0RURmllbGRUeXBlLk1BUCwgbWFwT2JqKTtcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLlBhcnNlTWFwID0gUGFyc2VNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZHQvbGliL2NvZGVjL3BhcnNlLW1hcC5qcyIsImNvbnN0IFBhcnNlU2luZ2xlRWxlbWVudExpYiA9IHJlcXVpcmUoJy4vcGFyc2Utc2luZ2xlLWVsZW1lbnQnKTtcbmNvbnN0IHsgUGFyc2VGaWVsZEhlYWRlciB9ID0gcmVxdWlyZSgnLi9wYXJzZS1maWVsZC1oZWFkZXInKTtcbmNvbnN0IHsgU0RURmllbGQgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZCcpO1xuY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4uL3NkdC1maWVsZC10eXBlcycpO1xuY29uc3QgeyBTRFRTdHJlYW1Db250YWluZXIgfSA9IHJlcXVpcmUoJy4uL3NkdC1zdHJlYW0tY29udGFpbmVyJyk7XG5cbmNvbnN0IFBhcnNlU3RyZWFtID0ge1xuICBwYXJzZVN0cmVhbUF0KGRhdGEsIG9mZnNldCwgZGF0YWxlbikge1xuICAgIGNvbnN0IHN0cmVhbU9iaiA9IG5ldyBTRFRTdHJlYW1Db250YWluZXIoKTtcbiAgICBsZXQgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBvZmZzZXQgKyBkYXRhbGVuKSB7XG4gICAgICBjb25zdCB2YWx1ZUZpZWxkSGVhZGVyID0gUGFyc2VGaWVsZEhlYWRlci5wYXJzZUZpZWxkSGVhZGVyKGRhdGEsIHBvcyk7XG4gICAgICBjb25zdCB2YWx1ZUZpZWxkID0gUGFyc2VTaW5nbGVFbGVtZW50TGliLlBhcnNlU2luZ2xlRWxlbWVudC5wYXJzZVNpbmdsZUVsZW1lbnQoZGF0YSwgcG9zKTtcbiAgICAgIHBvcyArPSB2YWx1ZUZpZWxkSGVhZGVyWzFdOyAvLyBkZWNsYXJlZCBmaWVsZCBsZW5ndGhcbiAgICAgIGlmICh2YWx1ZUZpZWxkKSB7XG4gICAgICAgIHN0cmVhbU9iai5hZGRGaWVsZCh2YWx1ZUZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuU1RSRUFNLCBzdHJlYW1PYmopO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuUGFyc2VTdHJlYW0gPSBQYXJzZVN0cmVhbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNkdC9saWIvY29kZWMvcGFyc2Utc3RyZWFtLmpzIiwiY29uc3QgRGVzdGluYXRpb25MaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IFNEVE1hcENvbnRhaW5lckxpYiA9IHJlcXVpcmUoJy4vc2R0LW1hcC1jb250YWluZXInKTtcbmNvbnN0IFNEVFN0cmVhbUNvbnRhaW5lckxpYiA9IHJlcXVpcmUoJy4vc2R0LXN0cmVhbS1jb250YWluZXInKTtcbmNvbnN0IFZhbGlkYXRlTGliID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJy4vc2R0LWZpZWxkLXR5cGVzJyk7XG5cbmNvbnN0IGJhc2VUeXBlcyA9ICgoKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICByZXN1bHRbU0RURmllbGRUeXBlLkJPT0xdID0gJ2Jvb2xlYW4nO1xuICByZXN1bHRbU0RURmllbGRUeXBlLlVJTlQ4XSA9ICdudW1iZXInO1xuICByZXN1bHRbU0RURmllbGRUeXBlLklOVDhdID0gJ251bWJlcic7XG4gIHJlc3VsdFtTRFRGaWVsZFR5cGUuVUlOVDE2XSA9ICdudW1iZXInO1xuICByZXN1bHRbU0RURmllbGRUeXBlLklOVDE2XSA9ICdudW1iZXInO1xuICByZXN1bHRbU0RURmllbGRUeXBlLlVJTlQzMl0gPSAnbnVtYmVyJztcbiAgcmVzdWx0W1NEVEZpZWxkVHlwZS5JTlQzMl0gPSAnbnVtYmVyJztcbiAgcmVzdWx0W1NEVEZpZWxkVHlwZS5VSU5UNjRdID0gJ251bWJlcic7XG4gIHJlc3VsdFtTRFRGaWVsZFR5cGUuSU5UNjRdID0gJ251bWJlcic7XG4gIHJlc3VsdFtTRFRGaWVsZFR5cGUuV0NIQVJdID0gJ3N0cmluZyc7XG4gIHJlc3VsdFtTRFRGaWVsZFR5cGUuU1RSSU5HXSA9ICdzdHJpbmcnO1xuICByZXN1bHRbU0RURmllbGRUeXBlLkJZVEVBUlJBWV0gPSAnc3RyaW5nJztcbiAgcmVzdWx0W1NEVEZpZWxkVHlwZS5GTE9BVFRZUEVdID0gJ251bWJlcic7XG4gIHJlc3VsdFtTRFRGaWVsZFR5cGUuRE9VQkxFVFlQRV0gPSAnbnVtYmVyJztcbiAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5cbmZ1bmN0aW9uIGZhaWxJbnZhbGlkUGFyYW1ldGVyKHZhbHVlVHlwZSkge1xuICByZXR1cm4gbmV3IE9wZXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgU0RUIHR5cGU6dmFsdWUgY29tYmluYXRpb24sIGV4cGVjdGVkIHZhbHVlIHR5cGUgJHt2YWx1ZVR5cGV9YCxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTZHRGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICBpZiAoYmFzZVR5cGVzW3R5cGVdKSB7XG4gICAgaWYgKChiYXNlVHlwZXNbdHlwZV0gPT09ICdib29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykgfHxcbiAgICAgICAgICAgIChiYXNlVHlwZXNbdHlwZV0gPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICAgICAoYmFzZVR5cGVzW3R5cGVdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIGZhaWxJbnZhbGlkUGFyYW1ldGVyKGJhc2VUeXBlc1t0eXBlXSk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlID09PSBTRFRGaWVsZFR5cGUuTUFQICYmXG4gICAgICAhVmFsaWRhdGVMaWIuQ2hlY2suaW5zdGFuY2VPZih2YWx1ZSwgU0RUTWFwQ29udGFpbmVyTGliLlNEVE1hcENvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gZmFpbEludmFsaWRQYXJhbWV0ZXIoJ1NEVE1hcENvbnRhaW5lcicpO1xuICB9XG4gIGlmICh0eXBlID09PSBTRFRGaWVsZFR5cGUuU1RSRUFNICYmXG4gICAgICAhVmFsaWRhdGVMaWIuQ2hlY2suaW5zdGFuY2VPZih2YWx1ZSwgU0RUU3RyZWFtQ29udGFpbmVyTGliLlNEVFN0cmVhbUNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gZmFpbEludmFsaWRQYXJhbWV0ZXIoJ1NEVFN0cmVhbUNvbnRhaW5lcicpO1xuICB9XG4gIGlmICh0eXBlID09PSBTRFRGaWVsZFR5cGUuREVTVElOQVRJT04gJiZcbiAgICAgICFWYWxpZGF0ZUxpYi5DaGVjay5pbnN0YW5jZU9mKHZhbHVlLCBEZXN0aW5hdGlvbkxpYi5EZXN0aW5hdGlvbikpIHtcbiAgICByZXR1cm4gZmFpbEludmFsaWRQYXJhbWV0ZXIoJ0Rlc3RpbmF0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhbGlkYXRlU2R0RmllbGQgPSB2YWxpZGF0ZVNkdEZpZWxkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2R0L2xpYi92YWxpZGF0ZS1zZHQtZmllbGQuanMiLCJjbGFzcyBDb3JyZWxhdGVkUmVxdWVzdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvcnJlbGF0ZWRSZXF1ZXN0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25UYWcgVGhlIGFzc29jaWF0ZWQgdGFnXG4gICAqIEBwYXJhbSB7P30gdGltZXIgVGhlIG9wYXF1ZSB0aW1lciBoYW5kbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvcnJlbGF0aW9uS2V5IFRoZSBhc3NvY2lhdGVkIGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNwUmVjdmRDYWxsYmFjayBUaGUgYXNzb2NpYXRlZCBjYWxsYmFja1xuICAgKiBAbWVtYmVyb2YgQ29ycmVsYXRlZFJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvcnJlbGF0aW9uVGFnLCB0aW1lciwgY29ycmVsYXRpb25LZXksIHJlc3BSZWN2ZENhbGxiYWNrKSB7XG4gICAgdGhpcy5jb3JyZWxhdGlvblRhZyA9IGNvcnJlbGF0aW9uVGFnO1xuICAgIHRoaXMudGltZXIgPSB0aW1lcjtcbiAgICB0aGlzLmNvcnJlbGF0aW9uS2V5ID0gY29ycmVsYXRpb25LZXk7XG4gICAgdGhpcy5yZXNwUmVjdmRDYWxsYmFjayA9IHJlc3BSZWN2ZENhbGxiYWNrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNvcnJlbGF0ZWRSZXF1ZXN0ID0gQ29ycmVsYXRlZFJlcXVlc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9jb3JyZWxhdGVkLXJlcXVlc3QuanMiLCJjb25zdCB7IENhcGFiaWxpdHlUeXBlIH0gPSByZXF1aXJlKCcuL2NhcGFiaWxpdHktdHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMuRGVmYXVsdENhcGFiaWxpdGllcyA9IHtcbiAgY3JlYXRlRGVmYXVsdENhcGFiaWxpdGllcygpIHtcbiAgICBjb25zdCBkZWZhdWx0Q2FwYWJpbGl0aWVzID0ge1xuICAgICAgW0NhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FXTogdHJ1ZSxcbiAgICAgIFtDYXBhYmlsaXR5VHlwZS5HVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSF06IHRydWUsXG4gICAgICAvLyBUaGUgb3RoZXJzIGFyZSBzZXQgVFJVRSBieSBDQ1NNUCwgYnV0IG5vdCByZWxldmFudCBmb3IgdXMgeWV0XG4gICAgICAvLyBbQ2FwYWJpbGl0eVR5cGUuVEVNUE9SQVJZX0VORFBPSU5UXTogICB0cnVlLFxuICAgICAgLy8gW0NhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9CUk9XU0VdOiAgICAgICAgIHRydWUsXG4gICAgICAvLyBbQ2FwYWJpbGl0eVR5cGUuRU5EUE9JTlRfTUdNVF06ICAgICAgICB0cnVlLFxuICAgICAgLy8gW0NhcGFiaWxpdHlUeXBlLlNFTEVDVE9SXTogICAgICAgICAgICAgdHJ1ZSxcbiAgICAgIC8vIFtDYXBhYmlsaXR5VHlwZS5DT01QUkVTU0lPTl06ICAgICAgICAgIHRydWUsXG4gICAgICAvLyBbQ2FwYWJpbGl0eVR5cGUuQ1VUX1RIUk9VR0hdOiAgICAgICAgICB0cnVlLFxuICAgICAgLy8gW0NhcGFiaWxpdHlUeXBlLlFVRVVFX1NVQlNDUklQVElPTlNdOiAgdHJ1ZSxcbiAgICAgIC8vIFtDYXBhYmlsaXR5VHlwZS5TVUJTQ1JJUFRJT05fTUFOQUdFUl06IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdENhcGFiaWxpdGllcztcbiAgfSxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9kZWZhdWx0LWNhcGFiaWxpdGllcy5qcyIsImNvbnN0IHsgUHJvY2VzcyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcblxuY29uc3QgQ18yXzMyID0gTWF0aC5wb3coMiwgMzIpO1xuXG5mdW5jdGlvbiBsZWZ0UGFkKHN0ciwgbGVuKSB7XG4gIHJldHVybiAnMCcucmVwZWF0KGxlbiAtIHN0ci5sZW5ndGgpICsgc3RyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKCkge1xuICBjb25zdCByYW5kID0gKE1hdGgucmFuZG9tKCkgKiBDXzJfMzIpLnRvRml4ZWQoMCk7XG4gIHJldHVybiBsZWZ0UGFkKHJhbmQudG9TdHJpbmcoKSwgMTApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEdsb2JhbENvbnRleHQgPSB7XG5cbiAgc2Vzc2lvbkNvdW50ZXI6IDAsXG4gIGlkQ291bnRlcjogICAgICAwLFxuXG4gIFJhbmRJZDogZ2VuZXJhdGVSYW5kb21JZCgpLFxuXG4gIE5leHRTZXNzaW9uQ291bnRlcigpIHtcbiAgICBjb25zdCBjb3VudCA9ICsrdGhpcy5zZXNzaW9uQ291bnRlcjtcbiAgICByZXR1cm4gbGVmdFBhZChjb3VudC50b1N0cmluZygpLCA0KTtcbiAgfSxcblxuICBOZXh0SWQoKSB7XG4gICAgcmV0dXJuICsrdGhpcy5pZENvdW50ZXI7XG4gIH0sXG5cbiAgR2VuZXJhdGVDbGllbnROYW1lKCkge1xuICAgIGNvbnN0IHsgcHJvZHVjdCwgcGxhdGZvcm0gfSA9IFByb2Nlc3M7XG4gICAgY29uc3QgcmVzdWx0ID0gYCR7cHJvZHVjdH0vJHtwbGF0Zm9ybX0vJHt0aGlzLlJhbmRJZH0vJHt0aGlzLk5leHRTZXNzaW9uQ291bnRlcigpfWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBHZW5lcmF0ZVVzZXJJZGVudGlmaWNhdGlvbigpIHtcbiAgICBjb25zdCB7IHByb2R1Y3QsIHBsYXRmb3JtIH0gPSBQcm9jZXNzO1xuICAgIHJldHVybiBgJHtwcm9kdWN0fS8ke3BsYXRmb3JtfS8ke3RoaXMuUmFuZElkfWA7XG4gIH0sXG5cbiAgR2VuZXJhdGVDbGllbnREZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gYHNvbGNsaWVudGpzLyR7UHJvY2Vzcy5kZXNjcmlwdGlvbn1gLnN1YnN0cmluZygwLCAyNTQpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuR2xvYmFsQ29udGV4dCA9IEdsb2JhbENvbnRleHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9nbG9iYWwtY29udGV4dC5qcyIsImNvbnN0IHsgTE9HX1RSQUNFIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IHBhcnNlVVJMIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG5sZXQgaG9zdExpc3RETlNGaWx0ZXI7XG5pZiAoQlVJTERfRU5WLlRBUkdFVF9OT0RFKSB7XG4gIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBnbG9iYWwtcmVxdWlyZSAqL1xuICBjb25zdCBkbnMgPSByZXF1aXJlKCdkbnMnKTtcbiAgLyogZXNsaW50LWVuYWJsZSBnbG9iYWwtcmVxdWlyZSAqL1xuXG4gIC8vIHV0aWwucHJvbWlzaWZ5IGlzIE5vZGUgOC4gVGhpcyBjb252ZXJ0cyBhbiAoZXJyLCByZXN1bHQpIGNhbGxiYWNrIHRvIGEgcHJvbWlzZS5cbiAgLy8gVGhlIHB1cnBvc2UgaXMgdG8gYWxsb3cgdXMgdG8gdXNlIFByb21pc2UuYWxsLCB3aGljaCBkZWFscyB3aXRoIHdhaXRpbmcgdW50aWxcbiAgLy8gYWxsIHByb21pc2VzIGFyZSByZXNvbHZlZCwgYW5kIHJldHVybmluZyB0aGUgcmVzdWx0cyBpbiBjb3JyZWN0bHkgb3JkZXJlZCBhcnJheS5cbiAgY29uc3QgZG5zTG9va3VwUHJvbWlzZSA9ICh1cmwsIG9wdGlvbnMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgaG9zdCA9IHBhcnNlVVJMKHVybCkuaG9zdG5hbWU7XG4gICAgTE9HX1RSQUNFKCdsb29raW5nIHVwJywgdXJsLCAnPT4nLCBob3N0KTtcbiAgICBkbnMubG9va3VwKGhvc3QsIG9wdGlvbnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICBMT0dfVFJBQ0UoJ0ROUyByZXN1bHQnLCBlcnJvciwgcmVzdWx0KTtcbiAgICAgIHJldHVybiBlcnJvciA9PT0gbnVsbFxuICAgICAgICA/IHJlc29sdmUoeyB1cmwsIGhvc3QsIGFkZHJlc3M6IHJlc3VsdCwgcmVzb2x2ZWQ6IHRydWUgfSlcbiAgICAgICAgOiByZXNvbHZlKFxuICAgICAgICAgIHsgdXJsLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHJlc29sdmVkOiB0cnVlLFxuICAgICAgICAgICAgZXJyb3I6ICAgIHtcbiAgICAgICAgICAgICAgY29kZTogICAgIGVycm9yWydjb2RlJ10sIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICAgICAgICAgIGVycm5vOiAgICBlcnJvclsnZXJybm8nXSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgICAgICAgaG9zdG5hbWU6IGVycm9yWydob3N0bmFtZSddLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICAgICAgICBzeXNjYWxsOiAgZXJyb3JbJ3N5c2NhbGwnXSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXNvbHV0aW9uIGNhbGxzIGJhY2sgd2l0aCBhbiBhcnJheSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiBgeyB1cmw6ICdodHRwOi8vZXhhbXBsZS5jb20vZm9vJywgaG9zdDogJ2V4YW1wbGUuY29tJywgYWRkcmVzczogJzEwLjAuMC4xJywgcmVzb2x2ZWQ6IHRydWUgfWBcbiAgICogb3IsIG9uIGVycm9yXG4gICAqIGB7IHVybDogJ2h0dHA6Ly9leGFtcGxlLmNvbS9mb28nLCBob3N0OiAnZXhhbXBsZS5jb20nLCByZXNvbHZlZDogdHJ1ZSwgZXJyb3I6IHtcbiAgICogICAgY29kZTogJ0VOT1RGT1VORCcsIGVycm5vOiAnRU5PVEZPVU5EJywgc3lzY2FsbDogJ2dldGFkZHJpbmZvJ1xuICAgKiAgfSB9YFxuICAgKlxuICAgKiBJZiByZXNvbHV0aW9uIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQsIGJlY2F1c2Ugb2YgcGxhdGZvcm0gbGltaXRhdGlvbnMsIHRoZSBjYWxsYmFjayByZWNlaXZlc1xuICAgKiB0aGUgZm9sbG93aW5nOlxuICAgKiBgeyB1cmw6ICdodHRwOi8vZXhhbXBsZS5jb20vZm9vJywgaG9zdDogJ2V4YW1wbGUuY29tJywgYWRkcmVzczogJ2V4YW1wbGUuY29tJywgcmVzb2x2ZWQ6IGZhbHNlIH1gXG4gICAqXG4gICAqIEV2ZW4gaWYgbm8gRE5TIGxvb2t1cCBpcyBwZXJmb3JtZWQsIHRoZSBmdW5jdGlvbiBjYW4gc3RpbGwgZmFpbCBpZiBhbiBpbnZhbGlkIFVSTCBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGFsd2F5cyBjYWxscyBiYWNrIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSB1cmxzIEFycmF5IG9mIFVSTHMgdG8gcmVzb2x2ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBBIGZ1bmN0aW9uIGNhbGxlZCBiYWNrIHdpdGggcmVzdWx0cyBhcyBkZXNjcmliZWQgYWJvdmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhvc3RMaXN0RE5TRmlsdGVyID0gZnVuY3Rpb24gaG9zdExpc3RETlNGaWx0ZXJOb2RlKHVybHMsIGNiKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB1cmxzLm1hcCh1cmwgPT4gZG5zTG9va3VwUHJvbWlzZShcbiAgICAgIHVybCxcbiAgICAgIHsgJ3ZlcmJhdGltJzogdHJ1ZSB9XG4gICAgKSk7XG4gICAgLy8gQ2FsbCBiYWNrIChudWxsLCBbe2hvc3Q6LCBhZGRyZXNzOn0sIC4uLl0pIGlmIGFsbCBzdWNjZXNzZnVsXG4gICAgLy8gQ2FsbCBiYWNrIChlcnIsIHVuZGVmaW5lZCkgZmFzdCBpZiBhbnkgZXJyb3JcbiAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihyZXNvbHZlZCA9PiBjYihudWxsLCByZXNvbHZlZCkpLmNhdGNoKGVyciA9PiBjYihlcnIpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuICAvLyBDcmVhdGUgYW4gYWx3YXlzLWFzeW5jIGNhbGxiYWNrIHRoYXQgYWxsb3dzIGFsbCBob3N0cy5cbiAgaG9zdExpc3RETlNGaWx0ZXIgPSAodXJscywgY2IpID0+IHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVybHMubWFwKCh1cmwpID0+IHtcbiAgICAgICAgY29uc3QgaG9zdCA9IHBhcnNlVVJMKHVybCkuaG9zdDtcbiAgICAgICAgcmV0dXJuIHsgdXJsLCBob3N0LCBhZGRyZXNzOiBob3N0LCByZXNvbHZlZDogZmFsc2UgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNiKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmhvc3RMaXN0RE5TRmlsdGVyID0gaG9zdExpc3RETlNGaWx0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9ob3N0LWxpc3QtZG5zLWZpbHRlci5qcyIsImNvbnN0IHsgYXNzZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgaG9zdExpc3RETlNGaWx0ZXIgfSA9IHJlcXVpcmUoJy4vaG9zdC1saXN0LWRucy1maWx0ZXInKTtcbmNvbnN0IHsgTG9nRm9ybWF0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IHBhcnNlVVJMIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG5mdW5jdGlvbiBwYXJzZVVSTHMocmF3VVJMcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShyYXdVUkxzKSkge1xuICAgIHJldHVybiByYXdVUkxzLm1hcChyYXdVUkwgPT4gcGFyc2VVUkwocmF3VVJMKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlVVJMcyhyYXdVUkxzLnNwbGl0KC9bLDtdLykpO1xufVxuXG4vKlxuICogICBcIldoZW4gdXNpbmcgYSBob3N0IGxpc3QsIGVhY2ggdGltZSB0aGUgQVBJIHdvcmtzIHRocm91Z2ggdGhlIGhvc3QgbGlzdCB3aXRob3V0IGVzdGFibGlzaGluZ1xuICogICAgYSBjb25uZWN0aW9uIGlzIGNvbnNpZGVyZWQgYW4gY29ubmVjdCByZXRyeS5cIlxuICogICBTRVNTSU9OX0NPTk5FQ1RfUkVUUklFUzogXCJXaGVuIHVzaW5nIGEgaG9zdCBsaXN0LCB0aGlzIHByb3BlcnR5IGRlZmluZXMgaG93IG1hbnkgdGltZXMgdG9cbiAqICAgIHRyeSB0byBjb25uZWN0IG9yIHJlY29ubmVjdCB0byBhIHNpbmdsZSBob3N0IGJlZm9yZSBtb3ZpbmcgdG8gdGhlIG5leHQgaG9zdCBpbiB0aGUgbGlzdC5cIlxuICogICBEZXRhaWxzOiBodHRwOi8vZG9jcy5zb2xhY2UuY29tL1NvbGFjZS1NZXNzYWdpbmctQVBJcy9Db25maWd1cmluZy1Db25uZWN0aW9uLVQuaHRtXG4qL1xuXG4vLyBJbiBnZW5lcmFsOlxuLy8gKiBzZXQgaW5pdGlhbCBzdGF0ZSB0byBpbnZhbGlkIHNvIHRoYXQgd2UgYmVnaW4gbmVlZGluZyBhIHRyYW5zaXRpb24uXG4vLyAqIHByZWluY3JlbWVudCBhbGwgdHJ5IGNvdW50cyBvbiB0cmFuc2l0aW9uLlxuLy8gU3BlY2lmaWNzOlxuLy8gKiBTZWxlY3QgdHJ5IGNvdW50IGZvciBlbnRpcmUgbGlzdCBiYXNlZCBvbiB3aGV0aGVyIHdlIHdlcmUgY29ubmVjdGVkLlxuLy8gKiBUcnkgY291bnQgcGVyIGhvc3QgaXMgdGhlIHNhbWUgZm9yIGJvdGggY29ubmVjdCBhbmQgcmVjb25uZWN0LlxuLy8gKiBXaGVuIHRoZSBob3N0IGNoYW5nZXMsIHRoZSB3YWl0VGltZSBpcyAwLlxuLy8gKiBPdmVycmlkaW5nIHRoZSBhYm92ZSwgd2hlbiB0aGUgaG9zdCBwb2ludGVyIHdyYXBzIHRvIDAsIHRoZSB3YWl0VGltZSBpcyBub256ZXJvLlxuXG5jbGFzcyBIb3N0SW5mbyB7XG4gIGNvbnN0cnVjdG9yKHByb3BzID0geyB1cmw6IG51bGwsIHdhaXRUaW1lOiAwIH0pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEhvc3RMaXN0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBjb25uZWN0UmV0cmllcyxcbiAgICByZWNvbm5lY3RSZXRyaWVzLFxuICAgIGNvbm5lY3RSZXRyaWVzUGVySG9zdCxcbiAgICByZWNvbm5lY3RSZXRyeVdhaXRJbk1zZWNzLFxuICB9ID0ge30pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIGhvc3RzOiBwYXJzZVVSTHModXJsKS5tYXAoZSA9PiBlLmhyZWYpLFxuXG4gICAgICAvLyBIb3cgbWFueSB0aW1lcyB3aWxsIHdlIHRyYXZlcnNlIHRoZSBob3N0IGxpc3Qgd2l0aG91dCBzdWNjZXNzP1xuICAgICAgLy8gVHJ5IHRvIGNvbm5lY3Qgb25lIG1vcmUgdGhhbiB0aGUgJ3JldHJ5Q291bnQnIGJlY2F1c2Ugd2UgYWx3YXlzIHRyeSBvbmNlLlxuICAgICAgY29ubmVjdFRyeUNvdW50OiAoY29ubmVjdFJldHJpZXMgPT09IC0xXG4gICAgICAgID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIDogY29ubmVjdFJldHJpZXMgKyAxXG4gICAgICApLFxuXG4gICAgICAvLyBIb3cgbWFueSB0aW1lcyB3aWxsIHdlIHRyYXZlcnNlIHRoZSBob3N0IGxpc3QgYWZ0ZXIgc3VjY2Vzcz9cbiAgICAgIHJlY29ubmVjdFRyeUNvdW50OiAocmVjb25uZWN0UmV0cmllcyA9PT0gLTFcbiAgICAgICAgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgOiByZWNvbm5lY3RSZXRyaWVzXG4gICAgICApLFxuXG4gICAgICAvLyBBIHZhbHVlIG9mIOKAkzEgaW4gdGhlIG5leHQgYXNzaWduZW1lbnRzIG1lYW5zIHJldHJ5IGZvcmV2ZXIgLSBcIm51bGxcIiB3aWxsIG1lYW4gdGhhdFxuICAgICAgLy8gdHJ5IHRvIGNvbm5lY3Qgb25lIG1vcmUgdGhhbiB0aGUgJ3JldHJ5Q291bnQnIGJlY2F1c2Ugd2UgYWx3YXlzIHRyeSBvbmNlLlxuICAgICAgY29ubmVjdFRyeUNvdW50UGVySG9zdDogKGNvbm5lY3RSZXRyaWVzUGVySG9zdCA9PT0gLTFcbiAgICAgICAgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgOiBjb25uZWN0UmV0cmllc1Blckhvc3QgKyAxXG4gICAgICApLFxuXG4gICAgICAvLyBIb3cgbG9uZyBkbyB3ZSB3YWl0IGJlZm9yZSByZWF0dGVtcHRpbmcgdGhlIHNhbWUgaG9zdCBvciB3cmFwcGluZyBhcm91bmQgdGhlIGxpc3Q/XG4gICAgICByZWNvbm5lY3RSZXRyeVdhaXRJbk1zZWNzLFxuXG4gICAgICAvLyBNdXRhdGluZyBvcGVyYXRpb25zIGFmZmVjdCBvbmx5IHRoaXMuXG4gICAgICBfbXV0YWJsZVN0YXRlOiB7fSxcblxuICAgICAgbG9nZ2VyOiBuZXcgTG9nRm9ybWF0dGVyKCdbaG9zdC1saXN0XScpLFxuICAgIH0pO1xuXG4gICAgYXNzZXJ0KHRoaXMuaG9zdHMubGVuZ3RoID49IDEpO1xuICAgIGFzc2VydCh0aGlzLmNvbm5lY3RUcnlDb3VudCA+PSAxKTtcbiAgICBhc3NlcnQodGhpcy5yZWNvbm5lY3RUcnlDb3VudCA+PSAwKTtcbiAgICBhc3NlcnQodGhpcy5jb25uZWN0VHJ5Q291bnRQZXJIb3N0ID49IDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYmVmb3JlIGZpcnN0IGdldE5leHRIb3N0KCkgdG8gdmFsaWRhdGUgdGhhdCBhdCBsZWFzdCBvbmUgVVJMIGNvbnRhaW5zIGEgcmVhY2hhYmxlXG4gICAqIGhvc3RuYW1lLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIEROUyByZXNvbHV0aW9uIGNvbXBsZXRlc1xuICAgKi9cbiAgcmVzb2x2ZUhvc3RzKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBMT0dfVFJBQ0UsIExPR19XQVJOIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBob3N0TGlzdEROU0ZpbHRlcih0aGlzLmhvc3RzLCAoZXJyLCByZXNvbHZlZCkgPT4ge1xuICAgICAgLy8gRXhpdCBpbW1lZGlhdGVseSBpZiB0aGUgZmlsdGVyIHRocmV3LlxuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICBhc3NlcnQocmVzb2x2ZWQubGVuZ3RoID09PSB0aGlzLmhvc3RzLmxlbmd0aCwgJ1Jlc29sdmUgZGlkIG5vdCByZXR1cm4gYSByZXN1bHQgZm9yIGFsbCBob3N0cycpO1xuXG4gICAgICBMT0dfVFJBQ0UoJ1Jlc29sdmUgcmVzdWx0JywgcmVzb2x2ZWQpO1xuICAgICAgbGV0IHN1Y2NlZWRlZCA9IDA7XG4gICAgICByZXNvbHZlZC5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdC5hZGRyZXNzKSB7XG4gICAgICAgICAgKytzdWNjZWVkZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQucmVzb2x2ZWQpIHtcbiAgICAgICAgICAvLyBPbmx5IGxvZyBpZiB0aGUgbG9va3VwIHdhcyBhY3R1YWxseSBwZXJmb3JtZWRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5hZGRyZXNzKSB7XG4gICAgICAgICAgTE9HX1RSQUNFKCdETlMgcmVzb2x2ZSBPSzogICAgJywgcmVzdWx0LmFkZHJlc3MsICdmb3InLCByZXN1bHQudXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMT0dfV0FSTignRE5TIHJlc29sdmUgRkFJTEVEOicsIHJlc3VsdC5lcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgIGAke3Jlc3VsdC5lcnJvci5zeXNjYWxsfSgnJHtyZXN1bHQuZXJyb3IuaG9zdG5hbWV9JylgLCAnZm9yJywgcmVzdWx0LnVybCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHN1Y2NlZWRlZCA9PT0gMCA/ICdBbGwgaG9zdHMgZmFpbGVkIEROUyByZXNvbHV0aW9uJyA6IG51bGwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBQcm9wZXJ0aWVzIGZvciBob3N0IHNlbGVjdGlvbiBsb2dpY1xuICAgKiBAbWVtYmVyb2YgSG9zdExpc3RcbiAgICovXG4gIHJlc2V0KHN0YXRlID0geyB3YXNDb25uZWN0ZWQ6IGZhbHNlLCBkaXNjb25uZWN0ZWQ6IGZhbHNlIH0pIHtcbiAgICAvLyBPbiByZXNldCwgd2UgYWx3YXlzIHJldHVybiB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBob3N0IGxpc3QuXG4gICAgLy8gVGhpcyBmYWNpbGl0YXRlcyBEUiByZWNvdmVyeSBieSByZXR1cm5pbmcgdG8gdGhlIHByaW1hcnkgcm91dGVyLlxuICAgIC8vIFNldCBhbiBpbnZhbGlkIGluaXRpYWwgc3RhdGUgdGhhdCB3aWxsIHRyaWdnZXIgb3VyIGZpcnN0IHRyeS5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX211dGFibGVTdGF0ZSwge1xuICAgICAgd2FzQ29ubmVjdGVkOiBzdGF0ZS53YXNDb25uZWN0ZWQsXG4gICAgICBkaXNjb25uZWN0ZWQ6IHN0YXRlLmRpc2Nvbm5lY3RlZCxcbiAgICAgIGhvc3RQb2ludGVyOiAgMCxcbiAgICAgIGhvc3RUcmllczogICAgMCxcbiAgICAgIGxpc3RUcmllczogICAgMSxcbiAgICAgIGV4aGF1c3RlZDogICAgZmFsc2UsXG4gICAgICBsYXN0SG9zdEluZm86IG5ldyBIb3N0SW5mbygpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICFyZXR1cm5zIHtIb3N0SW5mb30gQ29ubmVjdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG5leHQgaG9zdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFVSTCBmb3IgdGhlIG5leHQgaG9zdFxuICAgKiBAbWVtYmVyb2YgSG9zdExpc3RcbiAgICovXG4gIGdldE5leHRIb3N0KCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fbXV0YWJsZVN0YXRlO1xuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IHN0YXRlLndhc0Nvbm5lY3RlZDtcbiAgICBjb25zdCBsYXN0SG9zdEluZm8gPSBzdGF0ZS5sYXN0SG9zdEluZm87XG5cbiAgICBhc3NlcnQobGFzdEhvc3RJbmZvLCAnTmV4dCBob3N0IHJlcXVlc3Qgd2l0aCBubyBwcmlvciBob3N0IGluZm8gLS0gZGlkIHlvdSBjYWxsIHJlc2V0KCk/Jyk7XG4gICAgLy8gVXNpbmcgYSB0cnkvZmluYWxseSBhcyBhIFwiZ290byBlbmRcIiB0byBhbHdheXMgbG9nIGZpbmFsIHN0YXRlLiBFeGNlcHRpb25zIG5vdCBleHBlY3RlZFxuICAgIC8vIGhlcmUsIGFsdGhvdWdoIGlmIGFuIGFzc2VydGlvbiBmYWlscywgdGhlIGZpbmFsbHkgbG9nIHNob3VsZCBiZSBoZWxwZnVsLlxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBwYXNzZWQgaW50byByZXNldCwgdGhlIHNlc3Npb24gaXMgdGVsbGluZyB1cyB0byBlbmZvcmNlIG5vIG1vcmUgaG9zdHMuXG4gICAgICBpZiAoc3RhdGUuZGlzY29ubmVjdGVkKSB7XG4gICAgICAgIExPR19UUkFDRSgnSG9zdCBsaXN0IHNldCB0byBkaXNjb25uZWN0ZWQsIHByb3ZpZGluZyBudWxsIG5leHQgaG9zdCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZXhoYXVzdGVkLCB0aGlzIGZ1bmN0aW9uIGhhcyByZXR1cm5lZCBhIG51bGwgdXJsIGFscmVhZHkuXG4gICAgICBhc3NlcnQoIXN0YXRlLmV4aGF1c3RlZCwgJ05leHQgaG9zdCByZXF1ZXN0IGFmdGVyIGhvc3QgbGlzdCBleGhhdXN0ZWQnKTtcblxuICAgICAgLy8gUHVsbCBpbW11dGFibGUgcHJvcGVydGllcyBmcm9tIHRoZSBpbnN0YW5jZVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBob3N0czogICAgICAgIHRoaXMuaG9zdHMsXG4gICAgICAgIGhvc3RUcmllc01heDogdGhpcy5jb25uZWN0VHJ5Q291bnRQZXJIb3N0LFxuICAgICAgICBsaXN0VHJpZXNNYXg6IHdhc0Nvbm5lY3RlZCA/IHRoaXMucmVjb25uZWN0VHJ5Q291bnQgOiB0aGlzLmNvbm5lY3RUcnlDb3VudCxcbiAgICAgIH0pO1xuXG4gICAgICBMT0dfVFJBQ0UoJ0dldHRpbmcgbmV4dCBob3N0XFxuJywgJ3Byb3BlcnRpZXMnLCBwcm9wZXJ0aWVzLCAnXFxuc3RhdGUnLCBzdGF0ZSk7XG4gICAgICBMT0dfVFJBQ0UoJ0xhc3QgaG9zdCcsIGxhc3RIb3N0SW5mbyk7XG5cbiAgICAgIC8vIEluaXRpYWwgc3RhdGUgd2FzIHZhbGlkLiBUaGlzIGlzIGEgaG9zdCB0cnkuIEluY3JlbWVudC5cbiAgICAgICsrc3RhdGUuaG9zdFRyaWVzO1xuICAgICAgaWYgKHN0YXRlLmhvc3RUcmllcyA+IHByb3BlcnRpZXMuaG9zdFRyaWVzTWF4KSB7XG4gICAgICAgIC8vIEluY3JlbWVudCBob3N0IHBvaW50ZXIsIHBvc3NpYmx5IHB1dHRpbmcgaXQgb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgTE9HX1RSQUNFKGBFeGhhdXN0ZWQgJHtzdGF0ZS5ob3N0VHJpZXN9IGhvc3QgdHJpZXMgZm9yIGhvc3QgJHtsYXN0SG9zdEluZm8udXJsfS5gKTtcbiAgICAgICAgKytzdGF0ZS5ob3N0UG9pbnRlcjtcbiAgICAgICAgLy8gSWYgdGhlIGhvc3QgcG9pbnRlciBpcyBvdXQgb2YgYm91bmRzLCB3ZSBhcmUgYmVnaW5uaW5nIGEgbmV3IGxpc3QgdHJ5LlxuICAgICAgICAvLyBJdCB3YXMgZWl0aGVyIHNldCBvdXQgb2YgYm91bmRzIGRlbGliZXJhdGVseSBieSByZXNldCgpIG9yIGl0IHdhc1xuICAgICAgICAvLyBpbmNyZW1lbnRlZCBvdXQgb2YgYm91bmRzIGFib3ZlLlxuICAgICAgICBpZiAoc3RhdGUuaG9zdFBvaW50ZXIgPj0gcHJvcGVydGllcy5ob3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGxpc3QgdHJ5LlxuICAgICAgICAgICsrc3RhdGUubGlzdFRyaWVzO1xuICAgICAgICAgIGlmIChzdGF0ZS5saXN0VHJpZXMgPiBwcm9wZXJ0aWVzLmxpc3RUcmllc01heCkge1xuICAgICAgICAgICAgLy8gQmVnaW5uaW5nIHRoaXMgbGlzdCB0cnkgaGFzIGV4Y2VlZGVkIG91ciBpbmNsdXNpdmUgbWF4LiBUaGUgaG9zdCBsaXN0IGlzXG4gICAgICAgICAgICAvLyBleGhhdXN0ZWQuXG4gICAgICAgICAgICBMT0dfVFJBQ0UoYEV4aGF1c3RlZCBob3N0IGxpc3QgYXQgJHtwcm9wZXJ0aWVzLmxpc3RUcmllc01heH0gdHJhdmVyc2Fscy5gKTtcbiAgICAgICAgICAgIHN0YXRlLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlc2V0dGluZyB0aGUgaG9zdCBwb2ludGVyIHRvIGJlZ2luIHRoaXMgbGlzdCB0cnkuXG4gICAgICAgICAgICBMT0dfVFJBQ0UoYEhvc3QgbGlzdCB0cnkgKCR7c3RhdGUubGlzdFRyaWVzfS8ke3Byb3BlcnRpZXMubGlzdFRyaWVzTWF4fSlgKTtcbiAgICAgICAgICAgIHN0YXRlLmhvc3RQb2ludGVyID0gMDtcbiAgICAgICAgICAgIHN0YXRlLmhvc3RUcmllcyA9IDE7IC8vIHRoaXMgaXMgdGhlIGZpcnN0IHRyeSBmb3IgdGhpcyBob3N0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmhvc3RUcmllcyA9IDE7IC8vIHRoaXMgaXMgdGhlIGZpcnN0IHRyeSBmb3IgdGhpcyBob3N0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhpcyBob3N0LlxuICAgICAgICBMT0dfVFJBQ0UoYEhvc3QgdHJ5ICgke3N0YXRlLmhvc3RUcmllc30vJHtwcm9wZXJ0aWVzLmhvc3RUcmllc01heH0pYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5leGhhdXN0ZWQpIHtcbiAgICAgICAgTE9HX1RSQUNFKCdBbGwgaG9zdHMgZXhoYXVzdGVkJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBCZXlvbmQgdGhpcyBwb2ludCwgZXhwZWN0IGEgdmFsaWQgaG9zdCB0byBiZSByZXR1cm5lZC5cblxuICAgICAgY29uc3QgdXJsID0gcHJvcGVydGllcy5ob3N0c1tzdGF0ZS5ob3N0UG9pbnRlcl07XG4gICAgICBhc3NlcnQodXJsLCBgTm8gaG9zdCBhdCB0aGUgaG9zdCBwb2ludGVyISAke3Byb3BlcnRpZXMuaG9zdHN9WyR7c3RhdGUuaG9zdFBvaW50ZXJ9XWApO1xuXG4gICAgICAvLyBXYWl0IHRpbWUgY29uZGl0aW9uczpcbiAgICAgIC8vIDEuIE9uIGEgbmV3IGxpc3QgKGludmFsaWQgbGFzdEhvc3RJbmZvKSwgemVybyB3YWl0VGltZS5cbiAgICAgIGNvbnN0IGlzTmV3TGlzdCA9IGxhc3RIb3N0SW5mby51cmwgPT09IG51bGw7XG4gICAgICAvLyAyYS4gT24gYSBuZXcgaG9zdCwgemVybyB3YWl0VGltZS4uLlxuICAgICAgY29uc3QgaXNOZXdIb3N0ID0gbGFzdEhvc3RJbmZvLnVybCAhPT0gdXJsO1xuICAgICAgLy8gMmIuIC4uLnVubGVzcyB3ZSBhcmUganVzdCByZXN0YXJ0aW5nIHRoZSBsaXN0LlxuICAgICAgY29uc3QgZGlkSnVzdEZpbmlzaExpc3QgPSBsYXN0SG9zdEluZm8udXJsICE9PSB1cmwgJiYgc3RhdGUuaG9zdFBvaW50ZXIgPT09IDA7XG4gICAgICAvLyAoMmIgbmVnYXRlcyAyYSBmb3IgYSBuZXcgbGlzdClcblxuICAgICAgY29uc3Qgd2FpdFRpbWUgPSAoaXNOZXdMaXN0IHx8IChpc05ld0hvc3QgJiYgIWRpZEp1c3RGaW5pc2hMaXN0KSlcbiAgICAgICAgPyAwXG4gICAgICAgIDogdGhpcy5yZWNvbm5lY3RSZXRyeVdhaXRJbk1zZWNzO1xuXG4gICAgICAvLyBTZXNzaW9uIEZTTSB3YXMgaW50ZW5kZWQgdG8gdXNlIGFsbCBvZiB0aGVzZSwgYnV0IGhhbmRsZXMgaXRzIG93biBldmVudHMgcHJlc2VudGx5XG4gICAgICAvLyBhbmQgZXhwZWN0cyB3YWl0VGltZSB0byBiZSBhIHByb3BlcnR5IG9mIHRoZSBsaXN0IHRoYXQgbXV0YXRlcyBwZXIgaG9zdCwgc28gdGhhdCBpc1xuICAgICAgLy8gd2hhdCBpcyBkb25lLlxuICAgICAgY29uc3QgaG9zdEluZm8gPSBuZXcgSG9zdEluZm8oe1xuICAgICAgICB1cmwsXG4gICAgICAgIHdhaXRUaW1lLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCBsYXN0IGhvc3QgZm9yIG5leHQgdGltZSwgYW5kIHJldHVyblxuICAgICAgTE9HX1RSQUNFKCdSZXR1cm5pbmcgaG9zdCBmcm9tJywgaG9zdEluZm8pO1xuICAgICAgc3RhdGUubGFzdEhvc3RJbmZvID0gaG9zdEluZm87XG4gICAgICByZXR1cm4gaG9zdEluZm8udXJsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBMT0dfVFJBQ0UoJ0ZpbmFsIGxpc3Qgc3RhdGVcXG4nLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3RXYWl0VGltZUluTXNlY3MoKSB7XG4gICAgYXNzZXJ0KHRoaXMuX211dGFibGVTdGF0ZS5sYXN0SG9zdEluZm8udXJsLCAnR2V0dGluZyBjb25uZWN0V2FpdFRpbWVJbk1zZWNzIGhhdmluZyBuZXZlciBjYWxsZWQgZ2V0TmV4dEhvc3RJbmZvJyk7XG4gICAgcmV0dXJuIHRoaXMuX211dGFibGVTdGF0ZS5sYXN0SG9zdEluZm8ud2FpdFRpbWU7XG4gIH1cblxuICBjdXJyZW50SG9zdFRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fbXV0YWJsZVN0YXRlO1xuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IHN0YXRlLndhc0Nvbm5lY3RlZDtcbiAgICAvLyBQdWxsIGltbXV0YWJsZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGluc3RhbmNlXG4gICAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgaG9zdHM6ICAgICAgICB0aGlzLmhvc3RzLFxuICAgICAgaG9zdFRyaWVzTWF4OiB0aGlzLmNvbm5lY3RUcnlDb3VudFBlckhvc3QsXG4gICAgICBsaXN0VHJpZXNNYXg6IHdhc0Nvbm5lY3RlZCA/IHRoaXMucmVjb25uZWN0VHJ5Q291bnQgOiB0aGlzLmNvbm5lY3RUcnlDb3VudCxcbiAgICB9KTtcbiAgICAvLyBob3N0IHBvaW50ZXIgaXMgemVybyBiYXNlZCBpbmRleCBpbnRvIHRoZSBob3N0IGxpc3RcbiAgICAvLyBzbyB0cmFuc2xhdGUgaXQgdG8gYSBodW1hbiByZWFkYWJsZSBpbmRleFxuICAgIGNvbnN0IGhvc3ROdW1iZXIgPSBzdGF0ZS5ob3N0UG9pbnRlciArIDE7XG4gICAgcmV0dXJuIGBob3N0ICcke3N0YXRlLmxhc3RIb3N0SW5mby51cmx9JyAoaG9zdCAke2hvc3ROdW1iZXJ9IG9mICR7cHJvcGVydGllcy5ob3N0cy5sZW5ndGh9KShob3N0IGNvbm5lY3Rpb24gYXR0ZW1wdCAke3N0YXRlLmhvc3RUcmllc30gb2YgJHtwcm9wZXJ0aWVzLmhvc3RUcmllc01heH0pKHRvdGFsICR7d2FzQ29ubmVjdGVkID8gJ3JlY29ubmVjdGlvbicgOiAnY29ubmVjdGlvbid9IGF0dGVtcHQgJHtzdGF0ZS5saXN0VHJpZXN9IG9mICR7cHJvcGVydGllcy5saXN0VHJpZXNNYXh9KWA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuSG9zdExpc3QgPSBIb3N0TGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL2hvc3QtbGlzdC5qcyIsIi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgT3V0c3RhbmRpbmdEYXRhUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKGNvcnJlbGF0aW9uSWQsIHRpbWVyLCByZXBseVJlY2VpdmVkQ0JGdW5jdGlvbiwgcmVxRmFpbGVkQ0JGdW5jdGlvbiwgdXNlck9iamVjdCkge1xuICAgIHRoaXMuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWQ7XG4gICAgdGhpcy50aW1lciA9IHRpbWVyO1xuICAgIHRoaXMucmVwbHlSZWNlaXZlZENCRnVuY3Rpb24gPSByZXBseVJlY2VpdmVkQ0JGdW5jdGlvbjtcbiAgICB0aGlzLnJlcUZhaWxlZENCRnVuY3Rpb24gPSByZXFGYWlsZWRDQkZ1bmN0aW9uO1xuICAgIHRoaXMudXNlck9iamVjdCA9IHVzZXJPYmplY3Q7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuT3V0c3RhbmRpbmdEYXRhUmVxdWVzdCA9IE91dHN0YW5kaW5nRGF0YVJlcXVlc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9vdXRzdGFuZGluZy1kYXRhLXJlcXVlc3QuanMiLCJjb25zdCBDb25zdW1lckxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlLWNvbnN1bWVyJyk7XG5jb25zdCBQdWJsaXNoZXJMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXInKTtcbmNvbnN0IFNNRkxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zbWYnKTtcbmNvbnN0IFNvbGNsaWVudEZhY3RvcnlMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZmFjdG9yeScpO1xuY29uc3QgVHJhbnNwb3J0TGliID0gcmVxdWlyZSgnc29sY2xpZW50LXRyYW5zcG9ydCcpO1xuXG5jb25zdCB7IGFzc2VydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7IENhcGFiaWxpdHlUeXBlIH0gPSByZXF1aXJlKCcuL2NhcGFiaWxpdHktdHlwZXMnKTtcbmNvbnN0IHsgQ2hlY2sgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBDb3JyZWxhdGVkUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9jb3JyZWxhdGVkLXJlcXVlc3QnKTtcbmNvbnN0IHsgRGVzdGluYXRpb24gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlcixcbiAgICAgICAgRXJyb3JTdWJjb2RlLFxuICAgICAgICBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IEZzbUV2ZW50LFxuICAgICAgICBTdGF0ZSxcbiAgICAgICAgU3RhdGVNYWNoaW5lIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZnNtJyk7XG5jb25zdCB7IEhleCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTG9nRm9ybWF0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IE1lc3NhZ2UsXG4gICAgICAgIE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZScpO1xuY29uc3QgeyBQMlBVdGlsIH0gPSByZXF1aXJlKCcuL3AycC11dGlsJyk7XG5jb25zdCB7IFNlc3Npb25FdmVudCB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLWV2ZW50Jyk7XG5jb25zdCB7IFNlc3Npb25FdmVudENvZGUgfSA9IHJlcXVpcmUoJy4vc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBTZXNzaW9uRXZlbnROYW1lIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZXZlbnQtbmFtZXMnKTtcbmNvbnN0IHsgU2Vzc2lvbkZTTUV2ZW50IH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZnNtLWV2ZW50Jyk7XG5jb25zdCB7IFNlc3Npb25SZXF1ZXN0VHlwZSB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLXJlcXVlc3QtdHlwZXMnKTtcbmNvbnN0IHsgU2Vzc2lvblN0YXRlTmFtZSB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLXN0YXRlLW5hbWVzJyk7XG5jb25zdCB7IFN0YXRUeXBlLFxuICAgICAgICBTdGF0c0J5TW9kZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXN0YXRzJyk7XG5jb25zdCB7IFN0cmluZ1V0aWxzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuY29uc3QgeyBTdWJzY3JpcHRpb25VcGRhdGVUaW1lb3V0TWVzc2FnZXMgfSA9IHJlcXVpcmUoJy4vc3Vic2NyaXB0aW9uLXVwZGF0ZS10aW1lb3V0LW1lc3NhZ2VzJyk7XG5cbmNvbnN0IHsgZm9ybWF0SGV4U3RyaW5nIH0gPSBIZXg7XG5jb25zdCB7IHN0cmlwTnVsbFRlcm1pbmF0ZSB9ID0gU3RyaW5nVXRpbHM7XG5jb25zdCB7IFNUQVRfVFhfQllNT0RFX0JZVEVTLFxuICAgICAgICBTVEFUX1RYX0JZTU9ERV9NU0dTLFxuICAgICAgICBTVEFUX1JYX0JZTU9ERV9CWVRFUyxcbiAgICAgICAgU1RBVF9SWF9CWU1PREVfTVNHUyxcbiAgICAgICAgU1RBVF9UWF9CWU1PREVfUkVERUxJVkVSRUQsXG4gICAgICAgIFNUQVRfVFhfQllNT0RFX0JZVEVTX1JFREVMSVZFUkVEIH0gPSBTdGF0c0J5TW9kZTtcblxuLyoqXG4gKiBAcGFyYW0ge1Nlc3Npb25Qcm9wZXJ0aWVzfSBzZXNzaW9uUHJvcGVydGllcyBUaGUgc2hhcmVkIHJlZmVyZW5jZSB0byB0aGUgcHJvcGVydGllcyBvZiB0aGVcbiAqICBvd25pbmcgc2Vzc2lvblxuICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIFRoZSBzZXNzaW9uIG93bmluZyB0aGlzIEZTTVxuICogQGV4dGVuZHMgU3RhdGVNYWNoaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTZXNzaW9uRlNNIGV4dGVuZHMgU3RhdGVNYWNoaW5lIHtcbiAgY29uc3RydWN0b3Ioc2Vzc2lvblByb3BlcnRpZXMsIHNlc3Npb24sIHN0YXRzLCBob3N0cykge1xuICAgIHN1cGVyKHsgbmFtZTogJ1Nlc3Npb25GU00nIH0pO1xuICAgIGNvbnN0IGZzbSA9IHRoaXM7XG4gICAgY29uc3QgbG9nRm9ybWF0dGVyID0gZnVuY3Rpb24gbG9nRm9ybWF0dGVyKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGBbc2Vzc2lvbi1mc209JHtmc20uc2Vzc2lvbklkSGV4IHx8ICcoTi9BKSd9XWAsXG4gICAgICAgIGBbJHtmc20uZ2V0Q3VycmVudFN0YXRlTmFtZSgpfV1gLFxuICAgICAgICAuLi5hcmdzLFxuICAgICAgXTtcbiAgICB9O1xuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyID0gbmV3IExvZ0Zvcm1hdHRlcihsb2dGb3JtYXR0ZXIpO1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFLCBMT0dfREVCVUcsIExPR19JTkZPIH0gPSBsb2dnZXI7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIud3JhcCh0aGlzLmxvZywgdGhpcyk7XG4gICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMgPSBzZXNzaW9uUHJvcGVydGllcztcbiAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcyA9IHN0YXRzO1xuICAgIHRoaXMuX2hvc3RzID0gaG9zdHM7XG4gICAgdGhpcy5fY29uc3VtZXJzID0gbmV3IENvbnN1bWVyTGliLkNvbnN1bWVyRmxvd3MoKTtcbiAgICAvLyBUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhpcyBpbnRlcmZhY2UuIEl0IHRha2VzIHRoZSBmbG93IGFzIGEgY29uc3RydWN0aW9uXG4gICAgLy8gcGFyYW1ldGVyLCBhbmQgZm9yIHNvbWUgbWV0aG9kcywgcHJvZHVjZXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIHVzaW5nIHRoYXQgZmxvdy5cbiAgICB0aGlzLl9mbG93SW50ZXJmYWNlRmFjdG9yeSA9IGZsb3cgPT4gKHtcbiAgICAgIGdldENvcnJlbGF0aW9uVGFnOiAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ycmVsYXRpb25UYWcuYmluZCh0aGlzKSxcbiAgICAgIGluY1N0YXQ6ICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jU3RhdC5iaW5kKHRoaXMpLFxuICAgICAgc2VuZERhdGE6ICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9PiB0aGlzLnNlbmQobWVzc2FnZSwgZmxvdywgZmFsc2UpLFxuICAgICAgc2VuZFRvVHJhbnNwb3J0OiAgICAgICAgICAgICAgICAgbWVzc2FnZSA9PiB0aGlzLnNlbmRUb1RyYW5zcG9ydChtZXNzYWdlLCBmbG93LCBmYWxzZSksXG4gICAgICBzZW5kQ29udHJvbDogICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0+IHRoaXMuc2VuZChtZXNzYWdlLCBmbG93LCB0cnVlKSxcbiAgICAgIGVucXVldWVSZXF1ZXN0OiAgICAgICAgICAgICAgICAgIHRoaXMuZW5xdWV1ZU91dHN0YW5kaW5nQ29ycmVsYXRlZFJlcS5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlRGVzdGluYXRpb25Gcm9tRGVzY3JpcHRvcjogc2Vzc2lvbi5jcmVhdGVEZXN0aW5hdGlvbkZyb21EZXNjcmlwdG9yLmJpbmQoc2Vzc2lvbiksXG4gICAgICBjcmVhdGVUZW1wb3JhcnlEZXN0aW5hdGlvbjogICAgICBzZXNzaW9uLmNyZWF0ZVRlbXBvcmFyeURlc3RpbmF0aW9uLmJpbmQoc2Vzc2lvbiksXG4gICAgICBpc0NhcGFibGU6ICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLmlzQ2FwYWJsZS5iaW5kKHNlc3Npb24pLFxuICAgICAgZ2V0Q2FwYWJpbGl0eTogICAgICAgICAgICAgICAgICAgc2Vzc2lvbi5nZXRDYXBhYmlsaXR5LmJpbmQoc2Vzc2lvbiksXG5cbiAgICAgIGdldCBzZXNzaW9uSWRIZXgoKSB7XG4gICAgICAgIHJldHVybiBmc20uc2Vzc2lvbklkSGV4O1xuICAgICAgfSxcbiAgICAgIGdldCBjYW5BY2soKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uLmNhbkFjaztcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLmNsZWFyQ3VycmVudEVycm9yKCk7XG5cbiAgICB0aGlzLmluaXRpYWwoZnVuY3Rpb24gb25Jbml0aWFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5TZXNzaW9uRGlzY29ubmVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPT4gY29udGV4dC5nZXRTdGF0ZU1hY2hpbmUoKS5yZXNldCgpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgZXZlbnRzIGluIHRoZSB1bmhhbmRsZWRFdmVudEhhbmRsZXIgY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge1Nlc3Npb25GU01FdmVudH0gc0V2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnVuaGFuZGxlZEV2ZW50UmVhY3Rpb24oZnVuY3Rpb24gb25VbmhhbmRsZWRFdmVudChzRXZlbnQpIHtcbiAgICAgIGNvbnN0IGN1clN0YXRlID0gZnNtLmdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgc3dpdGNoIChzRXZlbnQuZ2V0TmFtZSgpKSB7XG4gICAgICAgIGNhc2UgU2Vzc2lvbkV2ZW50TmFtZS5DUkVBVEVfU1VCU0NSSUJFUjpcbiAgICAgICAgICAvLyBDUkVBVEVfU1VCU0NSSUJFUiBpcyBvbmx5IGhhbmRsZWQgaW4gQ09OTkVDVEVEIHN0YXRlLlxuICAgICAgICAgIC8vIEluIGFsbCBvdGhlciBzdGF0ZXMgd2UganVzdCBhZGQgdGhlIGNvbnN1bWVyIHRvIG91clxuICAgICAgICAgIC8vIGxpc3Qgb2YgdW5ib3VuZCBjb25zdW1lcnMgdGhhdCBuZWVkIHRvIGJlIGJvdW5kIHdoZW5cbiAgICAgICAgICAvLyB0aGUgc2Vzc2lvbiB1cCBvY2N1cnMuXG4gICAgICAgICAgYXNzZXJ0KGZzbS5fY29uc3VtZXJzLCAnY29sbGVjdGlvbiBoYXMgbGlmZXRpbWUgb2YgRlNNIGluc3RhbmNlJyk7XG4gICAgICAgICAgZnNtLl9jb25zdW1lcnMuYWRkKHNFdmVudC5ndWFyYW50ZWVkRmxvd09iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNhc2UgU2Vzc2lvbkV2ZW50TmFtZS5ESVNQT1NFOlxuICAgICAgICAgIExPR19ERUJVRygnSGFuZGxpbmcgRElTUE9TRScpO1xuICAgICAgICAgIHJldHVybiBjdXJTdGF0ZS50ZXJtaW5hdGUoKCkgPT4gZnNtLmRpc3Bvc2VJbnRlcm5hbCgpKTtcbiAgICAgICAgY2FzZSBTZXNzaW9uRXZlbnROYW1lLkZMT1dfVVA6XG4gICAgICAgICAgTE9HX0RFQlVHKGBJZ25vcmluZyBGTE9XX1VQIGV2ZW50IGZyb20gJHtzRXZlbnQuZ3VhcmFudGVlZEZsb3dPYmplY3R9YCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgTE9HX1RSQUNFKGBJZ25vcmluZyBldmVudCAke3NFdmVudC5nZXROYW1lKCl9IGluIHN0YXRlICR7ZnNtLmdldEN1cnJlbnRTdGF0ZU5hbWUoKX1gKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuU2Vzc2lvbkNvbm5lY3RpbmcgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5DT05ORUNUSU5HLFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLFxuICAgIH0sIHtcbiAgICAgIC8vXG4gICAgICAvLyAgaGFuZGxlVHJhbnNwb3J0RGVzdHJveWVkIGlzIGNhbGxlZCBpbiByZXNwb25zZSB0byBUUkFOU1BPUlRfREVTVFJPWUVEXG4gICAgICAvLyAgZXZlbnQgYW5kIGlmIHRyYW5zcG9ydCBjcmVhdGUgdGhyb3dzIGFuIGV4Y2VwdGlvbi4gSW4gYm90aCBjYXNlIHRoZXJlIGlzXG4gICAgICAvLyAgbm8gdW5kZXJseWluZyB0cmFuc3BvcnQgYW5kIHRoZSBGU00gbXVzdCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGhvc3QuXG4gICAgICBoYW5kbGVUcmFuc3BvcnREZXN0cm95ZWQoKSB7XG4gICAgICAgIGZzbS5fY3VycmVudEhvc3QgPSBmc20uX2hvc3RzLmdldE5leHRIb3N0KCk7XG4gICAgICAgIGlmIChmc20uX2N1cnJlbnRIb3N0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvRXhpdFBvaW50KGZzbS5TZXNzaW9uQ29ubmVjdGluZywgJ0Vycm9yRXhpdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBjb25uZWN0V2FpdFRpbWVJbk1zZWNzIH0gPSBmc20uX2hvc3RzO1xuICAgICAgICBMT0dfVFJBQ0UoYFdhaXQgdGltZSBmb3IgdGhpcyBob3N0IGlzICR7Y29ubmVjdFdhaXRUaW1lSW5Nc2Vjc31gKTtcbiAgICAgICAgaWYgKGNvbm5lY3RXYWl0VGltZUluTXNlY3MgPiAwKSB7XG4gICAgICAgICAgZnNtLl9jb25uZWN0V2FpdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBmc20ucHJvY2Vzc0V2ZW50KG5ldyBTZXNzaW9uRlNNRXZlbnQoeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLkNPTk5FQ1RfV0FJVF9USU1FT1VUIH0pKTtcbiAgICAgICAgICB9LCBjb25uZWN0V2FpdFRpbWVJbk1zZWNzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JJbnRlckNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JUcmFuc3BvcnQpO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgZnNtLnNldENvbm5lY3RUaW1lcigpO1xuICAgICAgfSlcbiAgICAgIC5lbnRyeVBvaW50KCdEaXNjb25uZWN0VHJhbnNwb3J0JywgZnVuY3Rpb24gb25EaXNjb25uZWN0VHJhbnNwb3J0KCkge1xuICAgICAgICBmc20uX2hvc3RzLnJlc2V0KHsgd2FzQ29ubmVjdGVkOiB1bmRlZmluZWQsIGRpc2Nvbm5lY3RlZDogdHJ1ZSB9KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2V0IHRoZSBlcnJvciBldmVudCwgYXMgd2UgaGF2ZSByZXNldCB0aGVcbiAgICAgICAgLy8gaG9zdCBsaXN0IHdpdGggZGlzY29ubmVjdGVkOnRydWUsIHdlIGFsd2F5cyB0YWtlIHRoZVxuICAgICAgICAvLyBlcnJvckV4aXQgcGF0aCB0byBESVNDT05ORUNURUQgc3RhdGUgYWZ0ZXIgdGhpcyBlbnRyeVBvaW50LlxuICAgICAgICAvL1xuICAgICAgICBmc20uX2Nvbm5lY3RGYWlsRXZlbnQgPSBTZXNzaW9uRXZlbnRDb2RlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgZnNtLl9jb25uZWN0U3VjY2Vzc0V2ZW50ID0gU2Vzc2lvbkV2ZW50Q29kZS5ESVNDT05ORUNURUQ7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRGVzdHJveWluZ1RyYW5zcG9ydCk7XG4gICAgICB9KVxuICAgICAgLmVudHJ5UG9pbnQoJ1JlY29ubmVjdFRyYW5zcG9ydCcsIGZ1bmN0aW9uIG9uUmVjb25uZWN0VHJhbnNwb3J0KCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBTZXQgdGhlIGVycm9yIGV2ZW50LCB0aGlzIGlzIG9ubHkgdXNlZFxuICAgICAgICAvLyBpZiB3ZSB0YWtlIHRoZSBlcnJvckV4aXQgcGF0aFxuICAgICAgICAvL1xuICAgICAgICBmc20uX2Nvbm5lY3RGYWlsRXZlbnQgPSBTZXNzaW9uRXZlbnRDb2RlLkRPV05fRVJST1I7XG4gICAgICAgIGZzbS5fY29ubmVjdFN1Y2Nlc3NFdmVudCA9IFNlc3Npb25FdmVudENvZGUuUkVDT05ORUNURURfTk9USUNFO1xuICAgICAgICAvLyBTaG91bGQgd2UgdHJ5IHRvIHJlY29ubmVjdD9cbiAgICAgICAgY29uc3QgZGlzY29ubmVjdGVkID0gZnNtLl9zZXNzaW9uUHJvcGVydGllcy5fcmVjb25uZWN0UmV0cmllcyA9PT0gMDtcbiAgICAgICAgZnNtLl9ob3N0cy5yZXNldCh7IHdhc0Nvbm5lY3RlZDogdHJ1ZSwgZGlzY29ubmVjdGVkIH0pO1xuICAgICAgICBpZiAoIWRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIC8vIHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIHNlc3Npb24gc3RhdGUgaXMgY2hhbmdlZCB0byBjb25uZWN0aW5nIHdoZW5cbiAgICAgICAgICAvLyBhcHBsaWNhdGlvbiBnZXRzIHRoZSBzZXNzaW9uIGV2ZW50XG4gICAgICAgICAgLy8gcG9zaXRpb25hbCBwYXJhbWV0ZXJzIGZvciBTZXNzaW9uRXZlbnQgY29uc3RydWN0b3JcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZ2V0IHRoZSBhcmdzIGFuZCBlcnIgc2V0dXAgbm93IGFzIGJ5IHRoZSB0aW1lXG4gICAgICAgICAgLy8gdGhlIHBvc3RFdmVudEFjdGlvbiBydW5zIGN1cnJlbnRFcnJvciB3aWxsIGJlIHJlc2V0LlxuICAgICAgICAgIGNvbnN0IGVyciA9IGZzbS5fY3VycmVudEVycm9yIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbZXJyLmV2ZW50VGV4dCwgICAgLy8gaW5mb1N0cmluZ1xuICAgICAgICAgICAgZXJyLnJlc3BvbnNlQ29kZSwgICAgICAgICAgICAgLy8gcmVzcG9uc2VDb2RlXG4gICAgICAgICAgICBlcnIuZXJyb3JTdWJjb2RlLCAgICAgICAgICAgICAvLyBlcnJvclN1YmNvZGVcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlbGF0aW9uS2V5IC4uLiBOL0FcbiAgICAgICAgICAgIGVyci5ldmVudFJlYXNvbl07ICAgICAgICAgICAgIC8vIGV2ZW50UmVhc29uXG4gICAgICAgICAgZnNtLnNldFBvc3RFdmVudEFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBmc20uc2V0Q29ubmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBmc20uZW1pdFNlc3Npb25FdmVudChTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5SRUNPTk5FQ1RJTkdfTk9USUNFLCAuLi5hcmdzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5EZXN0cm95aW5nVHJhbnNwb3J0KTtcbiAgICAgIH0pXG4gICAgICAuaW5pdGlhbCgoKSA9PiB7XG4gICAgICAgIGZzbS5jbGVhckN1cnJlbnRFcnJvcigpO1xuICAgICAgICAvL1xuICAgICAgICAvLyBTZXQgdGhlIGVycm9yIGV2ZW50IHRoaXMgaXMgb25seSB1c2VkXG4gICAgICAgIC8vIGlmIHdlIHRha2UgdGhlIGVycm9yRXhpdCBwYXRoXG4gICAgICAgIC8vXG4gICAgICAgIGZzbS5fY29ubmVjdEZhaWxFdmVudCA9IFNlc3Npb25FdmVudENvZGUuQ09OTkVDVF9GQUlMRURfRVJST1I7XG4gICAgICAgIGZzbS5fY29ubmVjdFN1Y2Nlc3NFdmVudCA9IFNlc3Npb25FdmVudENvZGUuVVBfTk9USUNFO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gaG9zdCByZXNvbHV0aW9uIChndWFyYW50ZWVkIGFzeW5jOyByZXBsYWNlcyBhIHBvc3RFdmVudEFjdGlvbilcbiAgICAgICAgLy8gRG8gbm90IHBlcmZvcm0gaG9zdCBsaXN0IG9wZXJhdGlvbnMgdW50aWwgdGhpcyBjb21wbGV0ZXMgKG1vdmVkIHRvIGNhbGxiYWNrKVxuICAgICAgICBmc20uX2hvc3RzLnJlc29sdmVIb3N0cygoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFmc20uX2hvc3RzKSB7XG4gICAgICAgICAgICBMT0dfVFJBQ0UoJ0lnbm9yaW5nIGhvc3QgZmlsdGVyIGZhaWwgYmVjYXVzZSBzZXNzaW9uIHdhcyBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIExPR19UUkFDRSgnRE5TIGZpbHRlciBmYWlsZWQ6JywgZXJyKTtcbiAgICAgICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3Ioe1xuICAgICAgICAgICAgICBlcnJvclN1YmNvZGU6IEVycm9yU3ViY29kZS5VTlJFU09MVkVEX0hPU1RTLFxuICAgICAgICAgICAgICBldmVudFRleHQ6ICAgIGVycixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnNtLl9ob3N0cy5yZXNldCh7IGRpc2Nvbm5lY3RlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NFdmVudChuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5FWENFUFRJT04gfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5vdyB0aGF0IHRoZSBob3N0IGxpc3QgaGFzIGJlZW4gc2Nhbm5lZCwgd2UgY2FuIHJlc2V0IGFuZCBnZXQgbmV4dCBob3N0XG4gICAgICAgICAgZnNtLl9ob3N0cy5yZXNldCh7IHdhc0Nvbm5lY3RlZDogZmFsc2UgfSk7XG4gICAgICAgICAgZnNtLl9jdXJyZW50SG9zdCA9IGZzbS5faG9zdHMuZ2V0TmV4dEhvc3QoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRXZlbnQobmV3IFNlc3Npb25GU01FdmVudChcbiAgICAgICAgICAgIHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5ETlNfUkVTT0xVVElPTl9DT01QTEVURSB9XG4gICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JETlMpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkROU19SRVNPTFVUSU9OX0NPTVBMRVRFLCBmdW5jdGlvbiBvbkROU0NvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JUcmFuc3BvcnQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkRJU0NPTk5FQ1QsIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgvKiBldmVudCAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG9FbnRyeVBvaW50KGZzbS5TZXNzaW9uQ29ubmVjdGluZywgJ0Rpc2Nvbm5lY3RUcmFuc3BvcnQnKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5DT05ORUNUX1RJTUVPVVQsIGZ1bmN0aW9uIG9uQ29ubmVjdFRpbWVvdXQoLyogZXZlbnQgKi8pIHtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcih7XG4gICAgICAgICAgZXJyb3JTdWJjb2RlOiBFcnJvclN1YmNvZGUuVElNRU9VVCxcbiAgICAgICAgICBldmVudFRleHQ6ICAgICdDb25uZWN0IHRpbWVvdXQnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5EZXN0cm95aW5nVHJhbnNwb3J0KTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5TRU5EX0VSUk9SLCBmdW5jdGlvbiBvblNlbmRFcnJvcihzZXNzaW9uRXZlbnQpIHtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihzZXNzaW9uRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLkRlc3Ryb3lpbmdUcmFuc3BvcnQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkVYQ0VQVElPTiwgZnVuY3Rpb24gb25FeGNlcHRpb24oZXJyRXZlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogSSB0aGluayBFWENFUFRJT04gZXZlbnRzIG5ldmVyIGNhcnJ5IGV4dHJhIGVycm9yIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGFzIHNldEN1cnJlbnRFcnJvciBpcyBhbHJlYWR5IGNhbGxlZC5cbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihlcnJFdmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRGVzdHJveWluZ1RyYW5zcG9ydCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX0RFU1RST1lFRCwgZnVuY3Rpb24gb25UcmFuc3BvcnREZXN0cm95ZWQoc2Vzc2lvbkV2ZW50KSB7XG4gICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3Ioc2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgTE9HX0RFQlVHKCdUUkFOU1BPUlRfREVTVFJPWUVEIGV2ZW50Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRGVzdHJveWluZ1RyYW5zcG9ydCk7XG4gICAgICB9KVxuICAgICAgLmV4aXQoKCkgPT4ge1xuICAgICAgICBmc20uY2xlYXJDb25uZWN0VGltZXIoKTtcbiAgICAgICAgaWYgKGZzbS5fY29ubmVjdFdhaXRUaW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChmc20uX2Nvbm5lY3RXYWl0VGltZXIpO1xuICAgICAgICAgIGZzbS5fY29ubmVjdFdhaXRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZXhpdFBvaW50KCdDb25uZWN0ZWRFeGl0JywgKC8qIGV2ZW50ICovKSA9PiB7XG4gICAgICAgIC8vIE5vcm1hbCBleGl0IHRvIFRyYW5zcG9ydFVwLlxuICAgICAgICAvLyBXZSBuZWVkIHRvIG5vdGlmeSB0aGUgYXBwbGljYXRpb24gdGhleSBhcmUgY29ubmVjdGVkLiBVc2UgcG9zdEV2ZW50QWN0aW9uIHRvIG1ha2Ugc3VyZVxuICAgICAgICAvLyBzZXNzaW9uIHN0YXRlIGhhcyBhbHJlYWR5IGNoYW5nZWQgdG8gVHJhbnNwb3J0VXAgd2hlbiBhcHBsaWNhdGlvbiBnZXRzIHRoZSBjYWxsYmFjay5cbiAgICAgICAgLy8gVXNlIF9jb25uZWN0U3VjY2Vzc0V2ZW50IHRvIHNlbmQgUkVDT05ORUNURUQgdnMgVVAgZGVwZW5kaW5nIG9uIGVudHJ5IHBvaW50LlxuICAgICAgICAvLyBUT0RPOiB3aGF0IHRleHQgdG8gaW5jbHVkZSB3aXRoIGV2ZW50LCBjdXJyZW50bHkgdGV4dCBpcyBkaWZmZXJlbnQgZm9yXG4gICAgICAgIC8vIGNvbm5lY3QgdnMgcmVjb25uZWN0LiBXZSBzaG91bGQgc3RvcmUgd2l0aCBhcyBwYXJ0IG9mIF9jb25uZWN0U3VjY2Vzc0V2ZW50IGluXG4gICAgICAgIC8vIHRoZSBlbnRyeSBwb2ludC5cbiAgICAgICAgZnNtLnNldFBvc3RFdmVudEFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgZnNtLmVtaXRTZXNzaW9uRXZlbnQoU2Vzc2lvbkV2ZW50LmJ1aWxkKGZzbS5fY29ubmVjdFN1Y2Nlc3NFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCcke2ZzbS5faG9zdHMuY3VycmVudEhvc3RUb1N0cmluZygpfSdgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMDAsIDAsIG51bGwsIG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENsZWFyIGN1cnJlbnQgZXJyb3IgYXMgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIG9yXG4gICAgICAgIC8vIHJlY29ubmVjdGVkLlxuICAgICAgICBmc20uY2xlYXJDdXJyZW50RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5TZXNzaW9uVHJhbnNwb3J0VXApO1xuICAgICAgfSlcbiAgICAgIC5leGl0UG9pbnQoJ0Vycm9yRXhpdCcsIGZ1bmN0aW9uIG9uRXhpdCgvKiBldmVudCAqLykge1xuICAgICAgICAvLyBOb3RpZnkgdGhlIGFwcGxpY2F0aW9uIHRoZXkgYXJlIGRpc2Nvbm5lY3RlZC4gVXNlIHBvc3RFdmVudEFjdGlvbiB0byBtYWtlIHN1cmUgc2Vzc2lvblxuICAgICAgICAvLyBzdGF0ZSBoYXMgYWxyZWFkeSBjaGFuZ2VkIHRvIGRpc2Nvbm5lY3RlZCB3aGVuIGFwcGxpY2F0aW9uIGdldHMgdGhlIGNhbGxiYWNrLlxuICAgICAgICBmc20uc2V0UG9zdEV2ZW50QWN0aW9uKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBmc20uX2N1cnJlbnRFcnJvciB8fCB7fTtcbiAgICAgICAgICAvLyBwb3NpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIFNlc3Npb25FdmVudCBjb25zdHJ1Y3RvclxuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbZXJyLmV2ZW50VGV4dCwgICAgLy8gaW5mb1N0cmluZ1xuICAgICAgICAgICAgZXJyLnJlc3BvbnNlQ29kZSwgICAgICAgICAgICAgLy8gcmVzcG9uc2VDb2RlXG4gICAgICAgICAgICBlcnIuZXJyb3JTdWJjb2RlLCAgICAgICAgICAgICAvLyBlcnJvclN1YmNvZGVcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlbGF0aW9uS2V5IC4uLiBOL0FcbiAgICAgICAgICAgIGVyci5ldmVudFJlYXNvbl07ICAgICAgICAgICAgIC8vIGV2ZW50UmVhc29uXG4gICAgICAgICAgZnNtLmVtaXRTZXNzaW9uRXZlbnQoU2Vzc2lvbkV2ZW50LmJ1aWxkKGZzbS5fY29ubmVjdEZhaWxFdmVudCwgLi4uYXJncykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5TZXNzaW9uRGlzY29ubmVjdGVkKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5XYWl0aW5nRm9yRE5TID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfRE5TLFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLlNlc3Npb25Db25uZWN0aW5nLFxuICAgIH0pO1xuXG4gICAgdGhpcy5EZXN0cm95aW5nVHJhbnNwb3J0ID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuREVTVFJPWUlOR19UUkFOU1BPUlQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uU2Vzc2lvbkNvbm5lY3RpbmcsXG4gICAgfSlcbiAgICAgIC5lbnRyeSgoKSA9PiB7XG4gICAgICAgIExPR19ERUJVRygnQ29ubmVjdGluZywgZGlzcG9zaW5nIHRyYW5zcG9ydCcpO1xuICAgICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIHN0cmluZyBvciBzdWJDb2RlIHRoYXQgY2FuIGJlIGNhcHR1cmVkIGhlcmVcbiAgICAgICAgZnNtLmRlc3Ryb3lUcmFuc3BvcnRTZXNzaW9uKCdEaXNjb25uZWN0aW5nIHNlc3Npb24nLCAwKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfREVTVFJPWUVELCBmdW5jdGlvbiBvblRyYW5zcG9ydERlc3Ryb3llZChzZXNzaW9uRXZlbnQpIHtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihzZXNzaW9uRXZlbnQpO1xuICAgICAgICByZXR1cm4gZnNtLlNlc3Npb25Db25uZWN0aW5nLmhhbmRsZVRyYW5zcG9ydERlc3Ryb3llZC5jYWxsKHRoaXMpO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLldhaXRpbmdGb3JJbnRlckNvbm5lY3RUaW1lb3V0ID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfSU5URVJDT05ORUNUX1RJTUVPVVQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uU2Vzc2lvbkNvbm5lY3RpbmcsXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkNPTk5FQ1RfV0FJVF9USU1FT1VULCBmdW5jdGlvbiBvbkNvbm5lY3RXYWl0VGltZW91dCgvKmV2ZW50Ki8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XYWl0aW5nRm9yVHJhbnNwb3J0KTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5XYWl0aW5nRm9yVHJhbnNwb3J0ID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfVFJBTlNQT1JULFxuICAgICAgcGFyZW50Q29udGV4dDogZnNtLlNlc3Npb25Db25uZWN0aW5nLFxuICAgIH0pXG4gICAgICAuaW5pdGlhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdDYW5ub3QgZXN0YWJsaXNoIHRyYW5zcG9ydCBzZXNzaW9uOiBjcmVhdGlvbiBmYWlsZWQnO1xuICAgICAgICBmc20uc2V0Q29ubmVjdFRpbWVyKCk7XG4gICAgICAgIGZzbS5jbGVhckN1cnJlbnRFcnJvcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzbS5pbml0VHJhbnNwb3J0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnNldEN1cnJlbnRFcnJvcih7XG4gICAgICAgICAgICBldmVudFRleHQ6ICAgIGUubWVzc2FnZSA9PT0gZXJyb3JNZXNzYWdlID8gZXJyb3JNZXNzYWdlIDogYCR7ZXJyb3JNZXNzYWdlfTogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIGVycm9yU3ViY29kZTogZS5zdWJjb2RlIHx8IEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgIGV2ZW50UmVhc29uOiAgZSB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86ICBob3cgZG8gd2UgaGFuZGxlIGEgdHJhbnNpdGlvbiBpbiBhbiBlbnRyeSBwb2ludFxuICAgICAgICAgICAgLy8gYW5kIHNob3VsZCB3ZSByZWZlcmVuY2UgZnNtLlNlc3Npb25Db25uZWN0aW5nIGRpcmVjdGx5IG9yIHZpYVxuICAgICAgICAgICAgLy8gcGFyZW50Q29udGV4dD8gb3IgYnkgdmFyIHNldCBpbiBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgcmV0dXJuIGZzbS5TZXNzaW9uQ29ubmVjdGluZy5oYW5kbGVUcmFuc3BvcnREZXN0cm95ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JUcmFuc3BvcnRVcCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuV2FpdGluZ0ZvclRyYW5zcG9ydFVwID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfVFJBTlNQT1JUX1VQLFxuICAgICAgcGFyZW50Q29udGV4dDogdGhpcy5XYWl0aW5nRm9yVHJhbnNwb3J0LFxuICAgIH0pXG4gICAgICAuaW5pdGlhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdDYW5ub3QgZXN0YWJsaXNoIHRyYW5zcG9ydCBzZXNzaW9uOiBjb25uZWN0aW9uIGZhaWxlZCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmV0dXJuQ29kZSA9IGZzbS5fdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgICBpZiAocmV0dXJuQ29kZSAhPT0gVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUixcbiAgICAgICAgICAgICAgVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuZGVzY3JpYmUocmV0dXJuQ29kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIExPR19ERUJVRyhgQXR0ZW1wdGluZyB0byBjb25uZWN0IHNlc3Npb24gJyR7ZnNtLnNlc3Npb25JZH0nIHRvICR7ZnNtLl9ob3N0cy5jdXJyZW50SG9zdFRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnNldEN1cnJlbnRFcnJvcih7XG4gICAgICAgICAgICBldmVudFRleHQ6ICAgIGUubWVzc2FnZSA9PT0gZXJyb3JNZXNzYWdlID8gZXJyb3JNZXNzYWdlIDogYCR7ZXJyb3JNZXNzYWdlfTogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIGVycm9yU3ViY29kZTogZS5zdWJjb2RlIHx8IEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUixcbiAgICAgICAgICAgIGV2ZW50UmVhc29uOiAgZSB9KTtcbiAgICAgICAgICAvLyBUT0RPOiAgaG93IGRvIHdlIGhhbmRsZSBhIHRyYW5zaXRpb24gaW4gYW4gZW50cnkgcG9pbnRcbiAgICAgICAgICAvLyBhbmQgc2hvdWxkIHdlIHJlZmVyZW5jZSBmc20uU2Vzc2lvbkNvbm5lY3RpbmcgZGlyZWN0bHkgb3IgdmlhXG4gICAgICAgICAgLy8gcGFyZW50Q29udGV4dD8gb3IgYnkgdmFyIHNldCBpbiBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgcmV0dXJuIGZzbS5TZXNzaW9uQ29ubmVjdGluZy5oYW5kbGVUcmFuc3BvcnREZXN0cm95ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfVVAsIGZ1bmN0aW9uIG9uVHJhbnNwb3J0VXAoc0V2ZW50KSB7XG4gICAgICAgIGZzbS5zZXNzaW9uSWQgPSBzRXZlbnQuc2Vzc2lvbklkIHx8ICcnO1xuICAgICAgICBjb25zdCByZXR1cm5Db2RlID0gZnNtLnNlbmRDbGllbnRDdHJsTG9naW4oKTtcbiAgICAgICAgaWYgKHJldHVybkNvZGUgPT09IFRyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLk9LKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XYWl0aW5nRm9yTG9naW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IGNhcHR1cmUgYSBzdWJDb2RlIGZyb20gdGhlIHRyYW5zcG9ydFxuICAgICAgICBjb25zdCBlcnIgPSB7XG4gICAgICAgICAgZXZlbnRUZXh0OiAgICAnRmFpbGVkIHRvIHNlbmQgQ2xpZW50IENvbnRyb2wgTG9naW4nLFxuICAgICAgICAgIGVycm9yU3ViY29kZTogRXJyb3JTdWJjb2RlLkxPR0lOX0ZBSUxVUkUsXG4gICAgICAgICAgcmVzcG9uc2VDb2RlOiA0MDAsXG4gICAgICAgIH07XG4gICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5EZXN0cm95aW5nVHJhbnNwb3J0KTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5XYWl0aW5nRm9yTG9naW4gPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5XQUlUSU5HX0ZPUl9MT0dJTixcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5TZXNzaW9uQ29ubmVjdGluZyxcbiAgICB9KVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgZnNtLnNldENsaWVudEN0cmxUaW1lcigpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLlRSQU5TUE9SVF9QUk9UT0NPTF9DTElFTlRDVFJMLCBmdW5jdGlvbiBvbkNsaWVudEN0cmwoc0V2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNsaWVudEN0cmxNc2cgPSBzRXZlbnQuc21mTXNnO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNsaWVudEN0cmxNc2cuZ2V0UmVzcG9uc2UoKTtcbiAgICAgICAgY29uc3QgcmVzcENvZGUgPSByZXNwb25zZS5yZXNwb25zZUNvZGU7XG4gICAgICAgIGNvbnN0IGVyciA9IHtcbiAgICAgICAgICByZXNwb25zZUNvZGU6IHJlc3BDb2RlLFxuICAgICAgICB9O1xuICAgICAgICBmc20uX3Jlc3BvbnNlQ29kZSA9IHJlc3BDb2RlO1xuICAgICAgICBpZiAocmVzcENvZGUgPT09IDIwMCkge1xuICAgICAgICAgIGlmIChmc20uY2hlY2tOb0xvY2FsKGNsaWVudEN0cmxNc2cpKSB7XG4gICAgICAgICAgICBmc20udXBkYXRlUmVhZG9ubHlTZXNzaW9uUHJvcHMoY2xpZW50Q3RybE1zZyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLlJlYXBwbHlpbmdTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlcnIsIHtcbiAgICAgICAgICAgIGV2ZW50VGV4dDogICAgJ05vIExvY2FsIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFNvbGFjZSBNZXNzYWdlIFJvdXRlcicsXG4gICAgICAgICAgICBlcnJvclN1YmNvZGU6IEVycm9yU3ViY29kZS5OT19MT0NBTF9OT1RfU1VQUE9SVEVELFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCB7XG4gICAgICAgICAgICBldmVudFRleHQ6ICAgIHJlc3BvbnNlLnJlc3BvbnNlU3RyaW5nLFxuICAgICAgICAgICAgZXJyb3JTdWJjb2RlOiBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRFcnJvclN1YmNvZGUocmVzcENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZVN0cmluZyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgTE9HX1RSQUNFKCdDbGllbnRDdHJsIGVycm9yJywgZXJyKTtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLkRlc3Ryb3lpbmdUcmFuc3BvcnQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkRPV05HUkFERV9USU1FT1VULCBmdW5jdGlvbiBvbkRvd25ncmFkZVRpbWVvdXQoLyogZXZlbnQgKi8pIHtcbiAgICAgICAgaWYgKGZzbS5fdHJhbnNwb3J0LnJlcXVlc3REb3duZ3JhZGUoJ0NsaWVudEN0cmwgdGltZW91dCcsIEVycm9yU3ViY29kZS5USU1FT1VUKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBmc20uc2V0Q3VycmVudEVycm9yKHtcbiAgICAgICAgICAgIGV2ZW50VGV4dDogICAgJ0NsaWVudEN0cmwgdGltZW91dCcsXG4gICAgICAgICAgICBlcnJvclN1YmNvZGU6IEVycm9yU3ViY29kZS5USU1FT1VULFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRGVzdHJveWluZ1RyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgcmVjcmVhdGUgdGhlIHRyYW5zcG9ydCwganVzdCB0cnkgdG8gY29ubmVjdCBpdFxuICAgICAgICBMT0dfVFJBQ0UoJ0Rvd25ncmFkZSBhY2NlcHRlZCwgcmV0dXJuaW5nIHRvIFdhaXRpbmdGb3JUcmFuc3BvcnRVcCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRpbmdGb3JUcmFuc3BvcnRVcCk7XG4gICAgICB9KVxuICAgICAgLmV4aXQoKCkgPT4ge1xuICAgICAgICBmc20uY2xlYXJDbGllbnRDdHJsVGltZXIoKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5SZWFwcGx5aW5nU3Vic2NyaXB0aW9ucyA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBTZXNzaW9uU3RhdGVOYW1lLlJFQVBQTFlJTkdfU1VCU0NSSVBUSU9OUyxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5TZXNzaW9uQ29ubmVjdGluZyxcbiAgICB9KVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKCdSZWFwcGx5aW5nU3Vic2NyaXB0aW9uczogZW50cnknKTtcbiAgICAgICAgZnNtLmNvcHlTdWJzY3JpcHRpb25DYWNoZUtleXMoKTtcbiAgICAgIH0pXG4gICAgICAuaW5pdGlhbChmdW5jdGlvbiBvbkluaXRpYWwoKSB7XG4gICAgICAgIGlmIChmc20ucmVhcHBseVN1YnNjcmlwdGlvbnMoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIGFsbCBzdWJzY3JpcHRpb25zIGFwcGxpZWQgYW5kIHdhaXRpbmcgZm9yIGEgc3Vic2NyaXB0aW9uIGNvbmZpcm1cbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRGb3JTdWJDb25maXJtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmbG93IGNvbnRyb2xsZWQgd2hpbGUgcmVhcHBseWluZ1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldhaXRGb3JDYW5BY2NlcHREYXRhKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5TVUJTQ1JJQkVfVElNRU9VVCwgZnVuY3Rpb24gb25TdWJzY3JpYmVUaW1lb3V0KCkge1xuICAgICAgICBjb25zdCByZXNwVGV4dCA9ICdTdWJzY3JpcHRpb24gdGltZW91dCB3aGlsZSByZWFwcGx5aW5nJztcbiAgICAgICAgY29uc3Qgc3ViY29kZSA9IEVycm9yU3ViY29kZS5USU1FT1VUO1xuICAgICAgICBmc20uc2V0Q3VycmVudEVycm9yKHtcbiAgICAgICAgICBldmVudFRleHQ6ICAgIHJlc3BUZXh0LFxuICAgICAgICAgIGVycm9yU3ViY29kZTogc3ViY29kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24oZnNtLkRlc3Ryb3lpbmdUcmFuc3BvcnQpO1xuICAgICAgfSlcbiAgICAgIC5leGl0KGZ1bmN0aW9uIG9uRXhpdCgpIHtcbiAgICAgICAgZnNtLmNsZWFyU3Vic2NyaXB0aW9uQ2FjaGVLZXlzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLldhaXRGb3JTdWJDb25maXJtID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfU1VCQ09ORklSTSxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5SZWFwcGx5aW5nU3Vic2NyaXB0aW9ucyxcbiAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX1BST1RPQ09MX1NNUCwgZnVuY3Rpb24gb25UcmFuc3BvcnRQcm90b2NvbFNNUChzRXZlbnQpIHtcbiAgICAgICAgLy8gcHJvY2VzcyByeE1zZ09ialxuICAgICAgICBjb25zdCBzbWZSZXNwSGVhZGVyID0gc0V2ZW50LnNtZk1zZy5zbWZIZWFkZXI7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN0ciA9IHN0cmlwTnVsbFRlcm1pbmF0ZShzRXZlbnQuc21mTXNnLmVuY29kZWRVdGY4U3Vic2NyaXB0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzcENvZGUgPSBzbWZSZXNwSGVhZGVyLnBtX3Jlc3Bjb2RlO1xuICAgICAgICBjb25zdCByZXNwVGV4dCA9IHNtZlJlc3BIZWFkZXIucG1fcmVzcHN0cjtcbiAgICAgICAgaWYgKHJlc3BDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRFcnJvclN1YmNvZGUocmVzcENvZGUsIHJlc3BUZXh0KTtcbiAgICAgICAgICBMT0dfREVCVUcoYFdhaXRpbmcgZm9yIHN1YnNjcmlwdGlvbiBjb25maXJtYXRpb24sIGdvdCAke3Jlc3BDb2RlfSAoJHtlcnJvclN1YmNvZGV9KSBgICtcbiAgICAgICAgICAgICAgICAgICAgYCcke3Jlc3BUZXh0fScgb24gc3Vic2NyaXB0aW9uICR7c3Vic2NyaXB0aW9uU3RyfWApO1xuICAgICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3Ioe1xuICAgICAgICAgICAgZXZlbnRUZXh0OiAgICByZXNwVGV4dCxcbiAgICAgICAgICAgIHJlc3BvbnNlQ29kZTogcmVzcENvZGUsXG4gICAgICAgICAgICBlcnJvclN1YmNvZGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5EZXN0cm95VHJhbnNwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmc20uX3Nlc3Npb24uY2FuQ29ubmVjdFB1Ymxpc2hlciAmJlxuICAgICAgICAgICAgZnNtLl9kZWZhdWx0UHVibGlzaGVyICYmXG4gICAgICAgICAgICBmc20uX2RlZmF1bHRQdWJsaXNoZXIuaXNCaW5kV2FpdGluZygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XYWl0aW5nRm9yTWVzc2FnZVB1Ymxpc2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvRXhpdFBvaW50KGZzbS5TZXNzaW9uQ29ubmVjdGluZywgJ0Nvbm5lY3RlZEV4aXQnKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5XYWl0Rm9yQ2FuQWNjZXB0RGF0YSA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBTZXNzaW9uU3RhdGVOYW1lLldBSVRJTkdfRk9SX0NBTl9BQ0NFUFRfREFUQSxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5SZWFwcGx5aW5nU3Vic2NyaXB0aW9ucyxcbiAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX1BST1RPQ09MX1NNUCwgZnVuY3Rpb24gb25UcmFuc3BvcnRQcm90b2NvbFNNUChzRXZlbnQpIHtcbiAgICAgICAgLy8gcHJvY2VzcyByeE1zZ09ialxuICAgICAgICBjb25zdCBzbWZSZXNwSGVhZGVyID0gc0V2ZW50LnNtZk1zZy5zbWZIZWFkZXI7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN0ciA9IHN0cmlwTnVsbFRlcm1pbmF0ZShzRXZlbnQuc21mTXNnLmVuY29kZWRVdGY4U3Vic2NyaXB0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzcENvZGUgPSBzbWZSZXNwSGVhZGVyLnBtX3Jlc3Bjb2RlO1xuICAgICAgICBjb25zdCByZXNwVGV4dCA9IHNtZlJlc3BIZWFkZXIucG1fcmVzcHN0cjtcbiAgICAgICAgLy8gV2UgYXJlIG5vdCBleHBlY3RpbmcgYSBTTVAgcmVzcG9uc2UgYXMgd2UgaGF2ZSBub3Qgc2VudCBhIHJlcXVlc3QtY29uZmlybVxuICAgICAgICAvLyBzbyB0aGlzIGlzIGFsbW9zdCBhc3N1cmVkbHkgYW4gZXJyb3IgcmVzcG9uc2UgdG8gYSBzdWJzY3JpcHRpb24gYWRkXG4gICAgICAgIC8vIGNoZWNrIHJlc3BDb2RlIGFueXdheS4gIGlmIGl0cyAnMjAwIE9LJyBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKHJlc3BDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRFcnJvclN1YmNvZGUocmVzcENvZGUsIHJlc3BUZXh0KTtcbiAgICAgICAgICBMT0dfREVCVUcoYFdhaXRpbmcgZm9yIGNhbiBhY2NlcHQgZGF0YSwgZ290ICR7cmVzcENvZGV9IChzdWJjb2RlICR7ZXJyb3JTdWJjb2RlfSkgYCArXG4gICAgICAgICAgICBgJyR7cmVzcFRleHR9JyBvbiBzdWJzY3JpcHRpb24gJHtzdWJzY3JpcHRpb25TdHJ9YCk7XG4gICAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcih7XG4gICAgICAgICAgICBldmVudFRleHQ6ICAgIHJlc3BUZXh0LFxuICAgICAgICAgICAgcmVzcG9uc2VDb2RlOiByZXNwQ29kZSxcbiAgICAgICAgICAgIGVycm9yU3ViY29kZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLkRlc3Ryb3lpbmdUcmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuZXhwZWN0ZWQgMjAwIE9LIHJlcHNvbnNlLCBsb2cgaXQgYW5kIGNvbnRpbnVlXG4gICAgICAgIExPR19JTkZPKGBVbmV4cGVjdGVkIDIwMCBPSyByZXNwb25zZSB0byBzdWJzY3JpcHRpb24gYWRkIGZvciAke3N1YnNjcmlwdGlvblN0cn1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUcmFuc2l0aW9uKG51bGwpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLlRSQU5TUE9SVF9DQU5fQUNDRVBUX0RBVEEsIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2FuQWNjZXB0RGF0YSgpIHtcbiAgICAgICAgaWYgKGZzbS5yZWFwcGx5U3Vic2NyaXB0aW9ucygpID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gYWxsIHN1YnNjcmlwdGlvbnMgYXBwbGllZCBhbmQgd2FpdGluZyBmb3IgYSBzdWJzY3JpcHRpb24gY29uZmlybVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2FpdEZvclN1YkNvbmZpcm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZsb3cgY29udHJvbGxlZCB3aGlsZSByZWFwcGx5aW5nXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbihudWxsKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5XYWl0aW5nRm9yTWVzc2FnZVB1Ymxpc2hlciA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBTZXNzaW9uU3RhdGVOYW1lLldBSVRJTkdfRk9SX1BVQkZMT1csXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uU2Vzc2lvbkNvbm5lY3RpbmcsXG4gICAgfSlcbiAgICAgIC5lbnRyeSgoKSA9PiB7XG4gICAgICAgIC8vIEluZm9ybSB0aGUgcHVibGlzaGVyIHRoYXQgdGhlIHNlc3Npb24gaXMgdXAgYW5kIHRoZSBmbG93IGVzdGFibGlzaG1lbnQgY2FuIGJlZ2luLlxuICAgICAgICBmc20uX2RlZmF1bHRQdWJsaXNoZXIuY29ubmVjdCgpO1xuICAgICAgICBmc20uc2VuZFB1Ymxpc2hlclNlc3Npb25VcEV2ZW50KGZzbS5fZGVmYXVsdFB1Ymxpc2hlcik7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuRkxPV19VUCwgZnVuY3Rpb24gb25FdmVudCgpIHtcbiAgICAgICAgTE9HX1RSQUNFKGBGbG93IHVwICR7dGhpc31gKTtcbiAgICAgICAgaWYgKCFmc20uX2RlZmF1bHRQdWJsaXNoZXIuaXNCaW5kV2FpdGluZygpKSB7XG4gICAgICAgICAgTE9HX1RSQUNFKCdQdWJsaXNoZXIgdXAnKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG9FeGl0UG9pbnQoZnNtLlNlc3Npb25Db25uZWN0aW5nLCAnQ29ubmVjdGVkRXhpdCcpO1xuICAgICAgICB9XG4gICAgICAgIExPR19UUkFDRSgnV2FpdGluZyBmb3IgbW9yZSBwdWJsaXNoZXJzJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbihudWxsKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5GTE9XX0ZBSUxFRCwgZnVuY3Rpb24gb25FdmVudChzRXZlbnQpIHtcbiAgICAgICAgLy8gVE9ETzogTE9HSU5fRkFJTFVSRSBmb3IgZmxvdyBmYWlsZWQ/IENyZWRlbnRpYWxzIGRpc2FsbG93IEdNIHB1Ymxpc2hpbmc/XG4gICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3Ioe1xuICAgICAgICAgIGV2ZW50VGV4dDogICAgYEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoZXIgRmFpbGVkOiAke3NFdmVudC5ldmVudFRleHR9YCxcbiAgICAgICAgICBlcnJvclN1YmNvZGU6IEVycm9yU3ViY29kZS5MT0dJTl9GQUlMVVJFLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5EZXN0cm95aW5nVHJhbnNwb3J0KTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5TZXNzaW9uVHJhbnNwb3J0VXAgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5UUkFOU1BPUlRfVVAsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20sXG4gICAgfSlcbiAgICAgIC5lbnRyeShmdW5jdGlvbiBvbkVudHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pXG4gICAgICAuaW5pdGlhbChmdW5jdGlvbiBvbkluaXRpYWwoKSB7XG4gICAgICAgIGlmIChmc20uX3Nlc3Npb24uY2FuQ29ubmVjdENvbnN1bWVyKSB7XG4gICAgICAgICAgLy8gSW5mb3JtIHRoZSBzdWJzY3JpYmVycyB0aGF0IHRoZSBzZXNzaW9uIGlzIHVwIGFuZCB0aGUgZmxvdyBlc3RhYmxpc2htZW50IGNhbiBiZWdpbi5cbiAgICAgICAgICBmc20uX2NvbnN1bWVycy5mbG93cy5mb3JFYWNoKGNvbnN1bWVyID0+IGZzbS5zZW5kQ29uc3VtZXJTZXNzaW9uVXBFdmVudChjb25zdW1lcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRnVsbHlDb25uZWN0ZWQpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkRJU0NPTk5FQ1QsIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgvKiBzRXZlbnQgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5TZXNzaW9uRGlzY29ubmVjdGluZyk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuRVhDRVBUSU9OLCBmdW5jdGlvbiBvbkV4Y2VwdGlvbihzRXZlbnQpIHtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihzRXZlbnQpO1xuICAgICAgICBmc20uY2xlYW51cFNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvRW50cnlQb2ludChmc20uU2Vzc2lvbkNvbm5lY3RpbmcsICdSZWNvbm5lY3RUcmFuc3BvcnQnKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5TRU5EX0VSUk9SLCBmdW5jdGlvbiBvblNlbmRFcnJvcihzRXZlbnQpIHtcbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcihzRXZlbnQpO1xuICAgICAgICBmc20uY2xlYW51cFNlc3Npb24oKTtcbiAgICAgICAgTE9HX1RSQUNFKCdSZWNvbm5lY3RpbmcgdHJhbnNwb3J0IGFmdGVyIFNFTkRfRVJST1IgKG5vdCBmdWxseSBjb25uZWN0ZWQpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ub0VudHJ5UG9pbnQoZnNtLlNlc3Npb25Db25uZWN0aW5nLCAnUmVjb25uZWN0VHJhbnNwb3J0Jyk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX0RFU1RST1lFRCwgZnVuY3Rpb24gb25UcmFuc3BvcnREZXN0cm95ZWQoc0V2ZW50KSB7XG4gICAgICAgIGZzbS5zZXRDdXJyZW50RXJyb3Ioc0V2ZW50KTtcbiAgICAgICAgTE9HX0RFQlVHKCdSZWNlaXZlZCB1bnNvbGljaXRlZCBUUkFOU1BPUlRfREVTVFJPWUVEIGV2ZW50IHdoaWxlIHRyYW5zcG9ydCBpcyB1cCcpO1xuICAgICAgICBMT0dfVFJBQ0UoYFRSQU5TUE9SVF9ERVNUUk9ZRUQgZGV0YWlsczogJHtzRXZlbnR9YCk7XG4gICAgICAgIGZzbS5jbGVhbnVwU2Vzc2lvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG9FbnRyeVBvaW50KGZzbS5TZXNzaW9uQ29ubmVjdGluZywgJ1JlY29ubmVjdFRyYW5zcG9ydCcpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLlRSQU5TUE9SVF9QUk9UT0NPTF9TTVAsIGZ1bmN0aW9uIG9uVHJhbnNwb3J0UHJvdG9jb2xTTVAoc0V2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNtZlJlc3BIZWFkZXIgPSBzRXZlbnQuc21mTXNnLnNtZkhlYWRlcjtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3RyID0gc3RyaXBOdWxsVGVybWluYXRlKHNFdmVudC5zbWZNc2cuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24pO1xuICAgICAgICBjb25zdCByZXNwQ29kZSA9IHNtZlJlc3BIZWFkZXIucG1fcmVzcGNvZGU7XG4gICAgICAgIGNvbnN0IHJlc3BUZXh0ID0gc21mUmVzcEhlYWRlci5wbV9yZXNwc3RyO1xuXG4gICAgICAgIGZzbS5oYW5kbGVTdWJzY3JpcHRpb25VcGRhdGVFcnJvcihyZXNwQ29kZSwgcmVzcFRleHQsIHN1YnNjcmlwdGlvblN0ciwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbihudWxsKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfQ0FOX0FDQ0VQVF9EQVRBLCBmdW5jdGlvbiBvbkNhbkFjY2VwdERhdGEoc0V2ZW50KSB7XG4gICAgICAgIC8vIE5vdGlmeSBjbGllbnQgZm9yIHJlcHVibGlzaGluZ1xuICAgICAgICBjb25zdCBzZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5DQU5fQUNDRVBUX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJywgbnVsbCwgMCwgbnVsbCwgc0V2ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBmc20uZW1pdFNlc3Npb25FdmVudChzZXNzaW9uRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRyYW5zaXRpb24obnVsbCk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuQ1JFQVRFX1NVQlNDUklCRVIsIGZ1bmN0aW9uIG9uQ3JlYXRlU3Vic2NyaWJlcihzRXZlbnQpIHtcbiAgICAgICAgLy8gSW5mb3JtIHRoZSBjb25zdW1lciB0aGF0IHRoZSBzZXNzaW9uIGlzIHVwIGFuZCB0aGUgZmxvdyBlc3RhYmxpc2htZW50IGNhbiBiZWdpbi5cbiAgICAgICAgY29uc3QgY29uc3VtZXIgPSBmc20uX2NvbnN1bWVycy5hZGQoc0V2ZW50Lmd1YXJhbnRlZWRGbG93T2JqZWN0KTtcbiAgICAgICAgZnNtLnNlbmRDb25zdW1lclNlc3Npb25VcEV2ZW50KGNvbnN1bWVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KVxuICAgICAgLmV4aXQoZnVuY3Rpb24gb25FeGl0KCkge1xuICAgICAgICBmc20uY2xlYXJLZWVwQWxpdmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcblxuICAgIHRoaXMuRnVsbHlDb25uZWN0ZWQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5GVUxMWV9DT05ORUNURUQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uU2Vzc2lvblRyYW5zcG9ydFVwLFxuICAgIH0pXG4gICAgICAuZW50cnkoKCkgPT4ge1xuICAgICAgICBmc20uX2Nvbm5lY3RGYWlsRXZlbnQgPSBTZXNzaW9uRXZlbnRDb2RlLkRPV05fRVJST1I7XG4gICAgICAgIGZzbS5zY2hlZHVsZUtlZXBBbGl2ZSgpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLlNFTkRfRVJST1IsIGZ1bmN0aW9uIG9uU2VuZEVycm9yKHNFdmVudCkge1xuICAgICAgICBmc20uc2V0Q3VycmVudEVycm9yKHNFdmVudCk7XG4gICAgICAgIExPR19UUkFDRSgnRGlzY29ubmVjdGluZyB0cmFuc3BvcnQgYWZ0ZXIgU0VORF9FUlJPUiB3aGVuIGZ1bGx5IGNvbm5lY3RlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLkRlc3Ryb3lpbmdUcmFuc3BvcnQpO1xuICAgICAgfSk7XG5cbiAgICB0aGlzLlNlc3Npb25EaXNjb25uZWN0ZWQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5ESVNDT05ORUNURUQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20sXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkRJU0NPTk5FQ1QsIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgvKiBzRXZlbnQgKi8pIHtcbiAgICAgICAgZnNtLnNldFBvc3RFdmVudEFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgZnNtLmVtaXRTZXNzaW9uRXZlbnQoU2Vzc2lvbkV2ZW50LmJ1aWxkKFNlc3Npb25FdmVudENvZGUuRElTQ09OTkVDVEVEKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbihudWxsKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5DT05ORUNULCBmdW5jdGlvbiBvbkNvbm5lY3QoLyogc0V2ZW50ICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uU2Vzc2lvbkNvbm5lY3RpbmcpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkVYQ0VQVElPTiwgZnVuY3Rpb24gb25FeGNlcHRpb24oLyogc0V2ZW50ICovKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUcmFuc2l0aW9uKG51bGwpO1xuICAgICAgfSk7XG4gICAgdGhpcy5TZXNzaW9uRGlzY29ubmVjdGluZyA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBTZXNzaW9uU3RhdGVOYW1lLkRJU0NPTk5FQ1RJTkcsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20sXG4gICAgfSlcbiAgICAgIC5pbml0aWFsKCgpID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKGBEaXNjb25uZWN0aW5nIHNlc3Npb24gJHtmc219YCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uRGlzY29ubmVjdGluZ0Zsb3dzKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5ESVNDT05ORUNULCBmdW5jdGlvbiBvbkRpc2Nvbm5lY3QoLyogc0V2ZW50ICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVHJhbnNpdGlvbihudWxsKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5FWENFUFRJT04sIGZ1bmN0aW9uIG9uRXhjZXB0aW9uKGVyckV2ZW50KSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFzIHdlIGFyZSBpbiBkaXNjb25uZWN0aW5nIHN0YXRlIHdlIGhhdmUgaW5pdGlhdGVkIHRoZVxuICAgICAgICAvLyBkaXNjb25uZWN0IGFuZCBuZWVkIHRvIHByZXNlcnZlIHRoZSBlcnJvciBzdWJjb2RlIHRoYXRcbiAgICAgICAgLy8gd2Ugc2V0IGJlZm9yZSBkZXN0cm95aW5nIHRoZSB0cmFuc3BvcnQuIFRoZSB0cmFuc3BvcnQsIGhhdmluZ1xuICAgICAgICAvLyBubyBlcnJvciwgd2lsbCB1c3VhbGx5IHJldHVybiBhIHN1YmNvZGUgb2YgemVybyBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIG9ubHkgY2hhbmdlcyB0aGUgZXZlbnRDb2RlLCBub3QgdGhlIHN1YmNvZGUuIE90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgLy8gYXJlIHByZXNlcnZlZC5cbiAgICAgICAgLy9cbiAgICAgICAgZnNtLnNldEN1cnJlbnRFcnJvcih7IGVyckV2ZW50IH0pO1xuICAgICAgICBmc20uY2xlYW51cFNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvRW50cnlQb2ludChmc20uU2Vzc2lvbkNvbm5lY3RpbmcsICdEaXNjb25uZWN0VHJhbnNwb3J0Jyk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX0RFU1RST1lFRCwgZnVuY3Rpb24gb25UcmFuc3BvcnREZXN0cm95ZWQoLyogc0V2ZW50ICovKSB7XG4gICAgICAgIExPR19ERUJVRygnUmVjZWl2ZWQgdW5zb2xpY2l0ZWQgVFJBTlNQT1JUX0RFU1RST1lFRCB3aGlsZSBkaXNjb25uZWN0aW5nIHRyYW5zcG9ydCcpO1xuICAgICAgICBmc20uY2xlYW51cFNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvRW50cnlQb2ludChmc20uU2Vzc2lvbkNvbm5lY3RpbmcsICdEaXNjb25uZWN0VHJhbnNwb3J0Jyk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuRGlzY29ubmVjdGluZ0Zsb3dzID0gbmV3IFN0YXRlKHtcbiAgICAgIG5hbWU6ICAgICAgICAgIFNlc3Npb25TdGF0ZU5hbWUuRElTQ09OTkVDVElOR19GTE9XUyxcbiAgICAgIHBhcmVudENvbnRleHQ6IGZzbS5TZXNzaW9uRGlzY29ubmVjdGluZyxcbiAgICB9LCB7XG4gICAgICAvLyBHZXQgYWxsIGZsb3dzIHRvIGRpc2Nvbm5lY3QuIFRoaXMgd2lsbCBuZWVkIHRvIGJlIGNhbGxlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgZ2F0aGVyUGVuZGluZ0Zsb3dzKCkge1xuICAgICAgICBjb25zdCB7IE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZSB9ID0gQ29uc3VtZXJMaWI7XG4gICAgICAgIGNvbnN0IHsgTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZSB9ID0gUHVibGlzaGVyTGliO1xuXG4gICAgICAgIC8vIERvbid0IHJlLWVudGVyIHN5bmNocm9ub3VzbHkgdG8gbG9vayBmb3IgbmV3IGZsb3dzLlxuICAgICAgICAvLyBGbG93cyBkaXNjb25uZWN0IHN5bmNocm9ub3VzbHkgd2hlbiB0aGV5IGFyZSBhbHJlYWR5IGRpc2Nvbm5lY3RlZC5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhleSB0aHJvdzsgdGhleSBkbyBub3QgZW1pdCBhbiBldmVudC5cbiAgICAgICAgLy8gSWYgYSBjb25zdW1lciBmbG93IGlzIHVwLCBpdCB3aWxsIGltbWVkaWF0ZWx5IGVtaXQgYSBCSU5EX1dBSVRJTkcgZXZlbnQgYW5kIHdlXG4gICAgICAgIC8vIGhhbmRsZSB0aGF0LlxuICAgICAgICAvLyBTaW5jZSB3ZSBrbm93IHRoYXQgZmxvdyNfZGlzY29ubmVjdFNlc3Npb24gbmVpdGhlciBjcmVhdGVzIGEgbmV3IGZsb3dcbiAgICAgICAgLy8gbm9yIGNhbGxzIGEgdXNlciBjYWxsYmFjayB0aGF0IGNvdWxkIGRvIHNvLCB3ZSBuZWVkIG5vdCBsb29rIGZvciBuZXdcbiAgICAgICAgLy8gZmxvd3MgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICAgIGFzc2VydCghdGhpcy5pc0dhdGhlcmluZyk7XG4gICAgICAgIHRoaXMuaXNHYXRoZXJpbmcgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IGFkYXB0ZWRMaXN0ZW5Gb3JEZXN0cm95ID0gKGZsb3csIGluc3RhbGxmbiwgZG93bkV2ZW50cykgPT4ge1xuICAgICAgICAgIGFzc2VydChmbG93LCAnVHJ5aW5nIHRvIGxpc3RlbiB0byB1bmRlZmluZWQgZmxvdycpO1xuICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkga25vdyBhYm91dCB0aGlzIGZsb3csIHNraXAgaXQuXG4gICAgICAgICAgaWYgKHRoaXMua25vd24uaGFzKGZsb3cpKSByZXR1cm47XG4gICAgICAgICAgTE9HX1RSQUNFKGBBZGRpbmcgcGVuZGluZyBmbG93ICR7Zmxvd31gKTtcbiAgICAgICAgICB0aGlzLmtub3duLmFkZChmbG93KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmcuYWRkKGZsb3cpO1xuICAgICAgICAgIGNvbnN0IG9uRmxvd0Rvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICBMT0dfVFJBQ0UoYFJlbW92aW5nIGZsb3cgZnJvbSBwZW5kaW5nICR7Zmxvd31gKTtcbiAgICAgICAgICAgIGRvd25FdmVudHMuZm9yRWFjaChldmVudCA9PiBmbG93Ll9yZW1vdmVMaXN0ZW5lcihldmVudCwgb25GbG93RG93bikpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmRlbGV0ZShmbG93KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0dhdGhlcmluZykgdGhpcy5jaGVja1BlbmRpbmdGbG93cygpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZG93bkV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGluc3RhbGxmbi5jYWxsKGZsb3csIGV2ZW50LCBvbkZsb3dEb3duKSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZsb3cuX2Rpc2Nvbm5lY3RTZXNzaW9uKCk7IC8vIFNlc3Npb24gaGFzIGJlZW4gZGlzY29ubmVjdGVkIGJ5IHVzZXJcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgIC8vIFN5bmNocm9ub3VzbHkgZG93blxuICAgICAgICAgICAgTE9HX1RSQUNFKCdGbG93IGRpc2Nvbm5lY3QgdGhyZXcnKTtcbiAgICAgICAgICAgIG9uRmxvd0Rvd24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZzbS5fZGVmYXVsdFB1Ymxpc2hlcikge1xuICAgICAgICAgIGFkYXB0ZWRMaXN0ZW5Gb3JEZXN0cm95KGZzbS5fZGVmYXVsdFB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmc20uX2RlZmF1bHRQdWJsaXNoZXIub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5ET1dOXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZzbS5fY29uc3VtZXJzKSB7XG4gICAgICAgICAgZnNtLl9jb25zdW1lcnMuZmxvd3MuZm9yRWFjaCgoZmxvdykgPT4ge1xuICAgICAgICAgICAgYWRhcHRlZExpc3RlbkZvckRlc3Ryb3koZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3cuX29uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5ET1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUuRE9XTl9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0dhdGhlcmluZyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGEgZmxvdyBjb21lcyBkb3duLCB3aGV0aGVyIHN5bmMgb3IgYXN5bmMuXG4gICAgICAvLyBUaGUgYm9keSBpcyB3cmFwcGVkIGluIGEgYmFzaWMgZGVib3VuY2U6IGlmIHdlIGFyZSByZS1lbnRlcmluZyAoc3luY2hyb25vdXNseSksXG4gICAgICAvLyBubyBuZXcgZmxvd3Mgd2lsbCBiZSBhZGRlZC5cbiAgICAgIGNoZWNrUGVuZGluZ0Zsb3dzKCkge1xuICAgICAgICBMT0dfVFJBQ0UoJ1dhaXRpbmcgZm9yIGRpc2Nvbm5lY3RzIG9uJywgdGhpcy5wZW5kaW5nKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZy5zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIG91dCBvZiBwZW5kaW5nIGZsb3dzLCBidXQgbG9vayBmb3IgbmV3IGZsb3dzIHRoYXQgd2VyZSBqdXN0IGFkZGVkXG4gICAgICAgICAgdGhpcy5nYXRoZXJQZW5kaW5nRmxvd3MoKTtcbiAgICAgICAgICAvLyBXZXJlIGFueSBmbG93cyBqdXN0IGFkZGVkP1xuICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZWVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgLy8gQWxsIGRvbmUhXG4gICAgICAgIC8vIENsZWFyIGZsb3cgc2V0cyBzbyB0aGV5IGNhbiBiZSBkaXNwb3NlZFxuICAgICAgICB0aGlzLmtub3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgTE9HX0RFQlVHKCdBbGwgZmxvd3MgZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIGZzbS5wcm9jZXNzRXZlbnQobmV3IEZzbUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5GTE9XU19ESVNDT05ORUNURUQgfSkpO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmVudHJ5KGZ1bmN0aW9uIG9uRW50cnkoKSB7XG4gICAgICAgIHRoaXMua25vd24gPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdGbG93cygpO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihTZXNzaW9uRXZlbnROYW1lLkZMT1dTX0RJU0NPTk5FQ1RFRCwgZnVuY3Rpb24gb25GbG93c0Rpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5GbHVzaGluZ1RyYW5zcG9ydCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuRmx1c2hpbmdUcmFuc3BvcnQgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgU2Vzc2lvblN0YXRlTmFtZS5GTFVTSElOR19UUkFOU1BPUlQsXG4gICAgICBwYXJlbnRDb250ZXh0OiBmc20uU2Vzc2lvbkRpc2Nvbm5lY3RpbmcsXG4gICAgfSwge1xuICAgICAgZmx1c2hUcmFuc3BvcnQoKSB7XG4gICAgICAgIGZzbS5jbGVhbnVwU2Vzc2lvbigpO1xuICAgICAgICBmc20uZmx1c2hUcmFuc3BvcnRTZXNzaW9uKCgpID0+IHRoaXMub25UcmFuc3BvcnRGbHVzaGVkKCkpO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgb25UcmFuc3BvcnRGbHVzaGVkKCkge1xuICAgICAgICBmc20ucHJvY2Vzc0V2ZW50KG5ldyBGc21FdmVudCh7IG5hbWU6IFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX0ZMVVNIRUQgfSkpO1xuICAgICAgfSxcbiAgICB9KVxuICAgICAgLmVudHJ5KGZ1bmN0aW9uIG9uRW50cnkoKSB7XG4gICAgICAgIExPR19ERUJVRygnRmx1c2hpbmcgdHJhbnNwb3J0Jyk7XG4gICAgICAgIHRoaXMuZmx1c2hUcmFuc3BvcnQoKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfRkxVU0hFRCwgZnVuY3Rpb24gb25UcmFuc3BvcnRGbHVzaGVkKCkge1xuICAgICAgICBMT0dfREVCVUcoJ0hhbmRsZSBUcmFuc3BvcnQgRmx1c2hlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG9FbnRyeVBvaW50KGZzbS5TZXNzaW9uQ29ubmVjdGluZywgJ0Rpc2Nvbm5lY3RUcmFuc3BvcnQnKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVzdGluYXRpb259IGRlc3RpbmF0aW9uIFRoZSB0b3BpYyB0byBhZGRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFRvU3Vic2NyaXB0aW9uQ2FjaGUoZGVzdGluYXRpb24pIHtcbiAgICBpZiAoQ2hlY2subm90aGluZyhkZXN0aW5hdGlvbikgfHwgIXRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IGtleSA9IGRlc3RpbmF0aW9uLm5hbWU7XG4gICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlW2tleV0gPT09IG51bGwgfHxcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBMT0dfREVCVUcoYENhY2hlIHN1YnNjcmlwdGlvbiAke2tleX1gKTtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlW2tleV0gPSBkZXN0aW5hdGlvbjtcbiAgICAgIExPR19ERUJVRygnSW5jcmVtZW50IGNhY2hlIGNvdW50Jyk7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWNoZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIExPR19ERUJVRyhgQ2FjaGUgc3Vic2NyaXB0aW9uICR7a2V5fWApO1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVba2V5XSA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25UYWcgVGhlIHRhZyBvZiB0aGUgcmVxdWVzdCB0byBjYW5jZWxcbiAgICogQHJldHVybnMge0NvcnJlbGF0ZWRSZXF1ZXN0fSBUaGUgY2FuY2VsbGVkIHJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbE91dHN0YW5kaW5nQ29ycmVsYXRlZFJlcShjb3JyZWxhdGlvblRhZykge1xuICAgIGlmIChDaGVjay5ub3RoaW5nKGNvcnJlbGF0aW9uVGFnKSB8fCAhdGhpcy5fY29ycmVsYXRlZFJlcXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSB0aGlzLl9jb3JyZWxhdGVkUmVxc1tjb3JyZWxhdGlvblRhZ107XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgeyBMT0dfREVCVUcsIExPR19FUlJPUiB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKGBDYW5jZWwgb3V0c3RhbmRpbmcgY3RybCByZXF1ZXN0IGNvcnJlbGF0aW9uVGFnPSR7Y29ycmVsYXRpb25UYWdcbiAgICAgIH1gKTtcbiAgICBpZiAocmVxLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVxLnRpbWVyKTtcbiAgICAgIHJlcS50aW1lciA9IG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWxldGUgdGhpcy5fY29ycmVsYXRlZFJlcXNbY29ycmVsYXRpb25UYWddO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgTE9HX0VSUk9SKGBDYW5ub3QgZGVsZXRlIGN0cmwgcmVxdWVzdCAke2NvcnJlbGF0aW9uVGFnfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBjdHJsIHJlcXVlc3QgJHtjb3JyZWxhdGlvblRhZ31gLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhbnVwU2Vzc2lvbigpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKCdDbGVhbiB1cCBzZXNzaW9uJyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBDb25zdW1lckZTTUV2ZW50LFxuICAgICAgQ29uc3VtZXJGU01FdmVudE5hbWVzLFxuICAgIH0gPSBDb25zdW1lckxpYjtcblxuICAgIGlmICh0aGlzLl9jb3JyZWxhdGVkUmVxcykge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fY29ycmVsYXRlZFJlcXMpLmZvckVhY2goa2V5ID0+XG4gICAgICAgIHRoaXMuY2FuY2VsT3V0c3RhbmRpbmdDb3JyZWxhdGVkUmVxKGtleSkpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZXIoKTtcbiAgICB0aGlzLmNsZWFyQ2xpZW50Q3RybFRpbWVyKCk7XG4gICAgdGhpcy5jbGVhcktlZXBBbGl2ZSgpO1xuICAgIHRoaXMuX2NvbnN1bWVycy5mbG93cy5mb3JFYWNoKChjb25zdW1lcikgPT4ge1xuICAgICAgY29uc3VtZXIucHJvY2Vzc0ZTTUV2ZW50KFxuICAgICAgICBuZXcgQ29uc3VtZXJGU01FdmVudCh7IG5hbWU6IENvbnN1bWVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RPV04gfSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX2RlZmF1bHRQdWJsaXNoZXIpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRQdWJsaXNoZXIucHJvY2Vzc0ZTTUV2ZW50KFxuICAgICAgICBuZXcgUHVibGlzaGVyTGliLlB1Ymxpc2hlckZTTUV2ZW50KHtcbiAgICAgICAgICBuYW1lOiBQdWJsaXNoZXJMaWIuUHVibGlzaGVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX0RPV04sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uLmNsZWFudXBTZXNzaW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyQ2xpZW50Q3RybFRpbWVyKCkge1xuICAgIGlmICghdGhpcy5fY2xpZW50Q3RybFRpbWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NsaWVudEN0cmxUaW1lcik7XG4gICAgdGhpcy5fY2xpZW50Q3RybFRpbWVyID0gbnVsbDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhckNvbm5lY3RUaW1lcigpIHtcbiAgICBpZiAoIXRoaXMuX2Nvbm5lY3RUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uZWN0VGltZXIpO1xuICAgIHRoaXMuX2Nvbm5lY3RUaW1lciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwga2VlcCBhbGl2ZSB0YXNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhcktlZXBBbGl2ZSgpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG5cbiAgICBpZiAodGhpcy5fa2VlcEFsaXZlVGltZXIpIHtcbiAgICAgIExPR19ERUJVRygnQ2FuY2VsIGtlZXBhbGl2ZSB0aW1lcicpO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9rZWVwQWxpdmVUaW1lcik7XG4gICAgICB0aGlzLl9rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEtlZXBBbGl2ZUNvdW50ZXIoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50Q3RybE1lc3NhZ2V9IGNsaWVudEN0cmxNc2cgVGhlIG1lc3NhZ2UgdG8gcGFyc2VcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgTm8gTG9jYWwgaXMgc3VwcG9ydGVkIGJ5IHRoZSByb3V0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrTm9Mb2NhbChjbGllbnRDdHJsTXNnKSB7XG4gICAgbGV0IG5vTG9jYWxTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5ub0xvY2FsID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBjYXBzID0gY2xpZW50Q3RybE1zZy5nZXRSb3V0ZXJDYXBhYmlsaXRpZXMoKTtcbiAgICAgIGlmICghY2Fwcykge1xuICAgICAgICBub0xvY2FsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHdWFyZCBmb3IgdW5kZWZpbmVkIE9SIG5vbi1ib29sZWFuIGNhcGFiaWxpdHlcbiAgICAgICAgbm9Mb2NhbFN1cHBvcnRlZCA9ICh0eXBlb2YgY2Fwc1tDYXBhYmlsaXR5VHlwZS5OT19MT0NBTF0gPT09ICdib29sZWFuJykgPyBjYXBzW0NhcGFiaWxpdHlUeXBlLk5PX0xPQ0FMXSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9Mb2NhbFN1cHBvcnRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgZXJyb3IgZXhpdCBpbmZvcm1hdGlvbiBmb3IgdGhlIEZTTS5cbiAgICovXG4gIGNsZWFyQ3VycmVudEVycm9yKCkge1xuICAgIHRoaXMuX2N1cnJlbnRFcnJvciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFyU3Vic2NyaXB0aW9uQ2FjaGVLZXlzKCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlS2V5cyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvcHlTdWJzY3JpcHRpb25DYWNoZUtleXMoKSB7XG4gICAgLy8gcmVhcHBseSBzdWJzY3JpcHRpb25zIGlmIGFwcGxpY2FibGVcbiAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uQ2FjaGVLZXlzKCk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVLZXlzID0gT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGUgfHwge30pO1xuXG4gICAgLy8gQWRkIHRoZSBQMlAgSW5ib3ggc3Vic2NyaXB0aW9uLCBzbyB0aGUgc3Vic2NyaXB0aW9uQ2FjaGUgYWx3YXlzIGhhc1xuICAgIC8vIGF0IGxlYXN0IG9uZSBzdWJzY3JpcHRpb24uXG4gICAgY29uc3QgcDJwVG9waWMgPSBQMlBVdGlsLmdldFAyUFRvcGljU3Vic2NyaXB0aW9uKHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLnAycEluYm94QmFzZSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVLZXlzLnB1c2gocDJwVG9waWMpO1xuICB9XG5cbiAgY3JlYXRlTWVzc2FnZVB1Ymxpc2hlcigpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgaWYgKCF0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5wdWJsaXNoZXJQcm9wZXJ0aWVzLmVuYWJsZWQpIHtcbiAgICAgIExPR19ERUJVRygnUHVibGlzaGVyIGlzIGRpc2FibGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgTWVzc2FnZVB1Ymxpc2hlcixcbiAgICAgIE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUsXG4gICAgfSA9IFB1Ymxpc2hlckxpYjtcbiAgICBjb25zdCBwdWJsaXNoZXIgPSBuZXcgTWVzc2FnZVB1Ymxpc2hlcih7XG4gICAgICBwcm9wZXJ0aWVzOiAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucHVibGlzaGVyUHJvcGVydGllcyxcbiAgICAgIHNlc3Npb25JbnRlcmZhY2VGYWN0b3J5OiB0aGlzLl9mbG93SW50ZXJmYWNlRmFjdG9yeSxcbiAgICB9KTtcbiAgICBwdWJsaXNoZXIub24oXG4gICAgICBNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLlVQLFxuICAgICAgKCkgPT4gdGhpcy5wcm9jZXNzRXZlbnQobmV3IFNlc3Npb25GU01FdmVudChcbiAgICAgICAgeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLkZMT1dfVVAgfSxcbiAgICAgICAgeyBndWFyYW50ZWVkRmxvd09iamVjdDogcHVibGlzaGVyIH0pKSk7XG4gICAgcHVibGlzaGVyLm9uKFxuICAgICAgTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5DT05ORUNUX0ZBSUxFRF9FUlJPUixcbiAgICAgIGV2ZW50ID0+IHRoaXMucHJvY2Vzc0V2ZW50KFxuICAgICAgICBuZXcgU2Vzc2lvbkZTTUV2ZW50KFxuICAgICAgICAgIHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5GTE9XX0ZBSUxFRCB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGd1YXJhbnRlZWRGbG93T2JqZWN0OiBwdWJsaXNoZXIsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGV2ZW50VGV4dDogICAgICAgICAgICBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICB9KSkpO1xuXG4gICAgcHVibGlzaGVyLm9uKE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUuUkVKRUNURURfTUVTU0FHRSwgKG1lc3NhZ2UsIGN0cmxNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBoZWFkZXIgPSBjdHJsTWVzc2FnZS5zbWZIZWFkZXI7XG4gICAgICBjb25zdCByZXNwQ29kZSA9IGhlYWRlci5wbV9yZXNwY29kZTtcbiAgICAgIGNvbnN0IHJlc3BUZXh0ID0gaGVhZGVyLnBtX3Jlc3BzdHI7XG4gICAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRBREVycm9yU3ViY29kZShyZXNwQ29kZSwgcmVzcFRleHQpO1xuICAgICAgY29uc3QgZXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5SRUpFQ1RFRF9NRVNTQUdFX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2V0Q29ycmVsYXRpb25LZXkoKSk7XG4gICAgICBldmVudFsnbWVzc2FnZSddID0gbWVzc2FnZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIHRoaXMuZW1pdFNlc3Npb25FdmVudChldmVudCk7XG4gICAgfSk7XG4gICAgcHVibGlzaGVyLm9uKE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUuQUNLTk9XTEVER0VEX01FU1NBR0UsIChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLkFDS05PV0xFREdFRF9NRVNTQUdFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01lc3NhZ2UocykgYWNrbm93bGVkZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdldENvcnJlbGF0aW9uS2V5KCkpO1xuICAgICAgZXZlbnRbJ21lc3NhZ2UnXSA9IG1lc3NhZ2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICB0aGlzLmVtaXRTZXNzaW9uRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuICAgIHB1Ymxpc2hlci5vbihNZXNzYWdlUHVibGlzaGVyRXZlbnROYW1lLkZMT1dfTkFNRV9DSEFOR0VELCAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgeyBtZXNzYWdlcywgY291bnQgfSA9IGRhdGE7XG4gICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFNlc3Npb25FdmVudENvZGUuUkVQVUJMSVNISU5HX1VOQUNLRURfTUVTU0FHRVMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBSZXB1Ymxpc2hpbmcgJHtjb3VudH0gbWVzc2FnZXMgZHVlIHRvIGAgK1xuICAgICAgICAgICdHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaGVyIGZhaWxlZCB0byByZWNvbm5lY3QnKTtcbiAgICAgICAgZXZlbnRbJ21lc3NhZ2VzJ10gPSBtZXNzYWdlczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgZXZlbnRbJ2NvdW50J10gPSBjb3VudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgICAgdGhpcy5lbWl0U2Vzc2lvbkV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwdWJsaXNoZXIub24oTWVzc2FnZVB1Ymxpc2hlckV2ZW50TmFtZS5DQU5fU0VORCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0U2Vzc2lvbkV2ZW50KFxuICAgICAgICBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5DQU5fQUNDRVBUX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtwdWJsaXNoZXJ9IHdpbmRvdyBpcyBub3cgb3BlbiBhbmQgY2FuIHNlbmRgKSk7XG4gICAgfSk7XG4gICAgcHVibGlzaGVyLm9uKE1lc3NhZ2VQdWJsaXNoZXJFdmVudE5hbWUuR1VBUkFOVEVFRF9NRVNTQUdJTkdfRE9XTiwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0U2Vzc2lvbkV2ZW50KFxuICAgICAgICBTZXNzaW9uRXZlbnQuYnVpbGQoXG4gICAgICAgICAgU2Vzc2lvbkV2ZW50Q29kZS5HVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSEVSX0RPV04sXG4gICAgICAgICAgJ0d1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoaW5nIHNodXQgZG93bicpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9kZWZhdWx0UHVibGlzaGVyID0gcHVibGlzaGVyO1xuICB9XG5cbiAgc2VuZENvbnN1bWVyU2Vzc2lvblVwRXZlbnQoY29uc3VtZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBDb25zdW1lckZTTUV2ZW50LFxuICAgICAgQ29uc3VtZXJGU01FdmVudE5hbWVzLFxuICAgIH0gPSBDb25zdW1lckxpYjtcbiAgICBjb25zdCBpc0FEID0gdGhpcy5fc2Vzc2lvbi5jYW5Db25uZWN0Q29uc3VtZXI7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ29uc3VtZXJGU01FdmVudCh7XG4gICAgICBuYW1lOiBpc0FEXG4gICAgICAgID8gQ29uc3VtZXJGU01FdmVudE5hbWVzLlNFU1NJT05fVVBcbiAgICAgICAgOiBDb25zdW1lckZTTUV2ZW50TmFtZXMuU0VTU0lPTl9VUF9OT19BRCxcbiAgICB9KTtcbiAgICBldmVudC5ndWFyYW50ZWVkRmxvd09iamVjdCA9IGNvbnN1bWVyO1xuICAgIGNvbnN1bWVyLnByb2Nlc3NGU01FdmVudChldmVudCk7XG4gIH1cblxuICBzZW5kUHVibGlzaGVyU2Vzc2lvblVwRXZlbnQocHVibGlzaGVyKSB7XG4gICAgY29uc3QgaXNBRCA9IHRoaXMuX3Nlc3Npb24uY2FuQ29ubmVjdFB1Ymxpc2hlcjtcbiAgICBjb25zdCBldmVudCA9IG5ldyBQdWJsaXNoZXJMaWIuUHVibGlzaGVyRlNNRXZlbnQoe1xuICAgICAgbmFtZTogaXNBRFxuICAgICAgICA/IFB1Ymxpc2hlckxpYi5QdWJsaXNoZXJGU01FdmVudE5hbWVzLlNFU1NJT05fVVBcbiAgICAgICAgOiBQdWJsaXNoZXJMaWIuUHVibGlzaGVyRlNNRXZlbnROYW1lcy5TRVNTSU9OX1VQX05PX0FELFxuICAgIH0pO1xuICAgIGV2ZW50Lmd1YXJhbnRlZWRGbG93T2JqZWN0ID0gcHVibGlzaGVyO1xuICAgIHB1Ymxpc2hlci5wcm9jZXNzRlNNRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBHdWFyYW50ZWVkIE1lc3NhZ2luZyBTdWJzY3JpYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxNZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgZm9yIHRoZSBmbG93LlxuICAgKiAgRXhwZWN0ZWQgZmllbGRzOiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXN9XG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSBUaGUgbmV3bHkgY29uc3RydWN0ZWQgY29uc3VtZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZU1lc3NhZ2VDb25zdW1lcihwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgeyBNZXNzYWdlQ29uc3VtZXIgfSA9IENvbnN1bWVyTGliO1xuICAgIGNvbnN0IGNvbnN1bWVyID0gbmV3IE1lc3NhZ2VDb25zdW1lcih7XG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgc2Vzc2lvbkludGVyZmFjZUZhY3Rvcnk6IHRoaXMuX2Zsb3dJbnRlcmZhY2VGYWN0b3J5LFxuICAgIH0pO1xuICAgIGNvbnN0IGluZm8gPSB7IGd1YXJhbnRlZWRGbG93T2JqZWN0OiBjb25zdW1lciB9O1xuICAgIC8vIFdpbGwgYmUgYWRkZWQgdG8gdGhlIGd1YXJhbnRlZWQgZmxvdyBjb2xsZWN0aW9uIGJ5IGRpc3BhdGNoaW5nXG4gICAgdGhpcy5wcm9jZXNzRXZlbnQoXG4gICAgICBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5DUkVBVEVfU1VCU0NSSUJFUiB9LCBpbmZvKVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnN1bWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgVGhlIHN0YXR1cyBtZXNzYWdlIGZvciB0aGUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7U3ViY29kZX0gc3ViY29kZSBUaGUgc3ViY29kZSByZWFzb24gZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlc3Ryb3lUcmFuc3BvcnRTZXNzaW9uKG1zZywgc3ViY29kZSkge1xuICAgIGlmIChDaGVjay5ub3RoaW5nKHRoaXMuX3RyYW5zcG9ydCkpIHtcbiAgICAgIC8vIEp1c3Qgc2VuZCB0aGUgZXZlbnRcbiAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KFxuICAgICAgICBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfREVTVFJPWUVEIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IExPR19ERUJVRywgTE9HX0VSUk9SIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoJ0Rlc3Ryb3kgdHJhbnNwb3J0IHNlc3Npb24nKTtcblxuICAgIGNvbnN0IHJldHVybkNvZGUgPSB0aGlzLl90cmFuc3BvcnQuZGVzdHJveShtc2csIHN1YmNvZGUpO1xuICAgIHRoaXMuX3NtZkNsaWVudCA9IG51bGw7XG5cbiAgICBpZiAocmV0dXJuQ29kZSAhPT0gVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgIExPR19FUlJPUihgRmFpbGVkIHRvIGRlc3Ryb3kgdHJhbnNwb3J0IHNlc3Npb24sIHJldHVybiBjb2RlOiAke1xuICAgICAgICBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5kZXNjcmliZShyZXR1cm5Db2RlKX1gKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZXNzaW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSB7XG4gICAgICAndHJhbnNwb3J0JzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3lUcmFuc3BvcnRTZXNzaW9uKCdEaXNwb3NpbmcnLCAwKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc21mQ2xpZW50ID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAnc2Vzc2lvbic6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhbnVwU2Vzc2lvbigpO1xuICAgICAgICB0aGlzLl9zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb3JyZWxhdGVkUmVxcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Zsb3dJbnRlcmZhY2VGYWN0b3J5ID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAnc3RhdGlzdGljcyc6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MucmVzZXRTdGF0cygpO1xuICAgICAgICAgIHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9rYVN0YXRzID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAnc3Vic2NyaXB0aW9uIGNhY2hlJzogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGUpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25DYWNoZSkuZm9yRWFjaChcbiAgICAgICAgICAgIGtleSA9PiB0aGlzLnJlbW92ZUZyb21TdWJzY3JpcHRpb25DYWNoZShrZXkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWNoZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbkNhY2hlS2V5cygpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWNoZUNvdW50ID0gMDtcbiAgICAgIH0sXG4gICAgICAnTWVzc2FnZVB1Ymxpc2hlcnMnOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kZWZhdWx0UHVibGlzaGVyKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFB1Ymxpc2hlci5kaXNwb3NlKCk7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdFB1Ymxpc2hlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnTWVzc2FnZUNvbnN1bWVycyc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJzLmRpc3Bvc2VBbGwoKTtcbiAgICAgICAgdGhpcy5fY29uc3VtZXJzID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAnaG9zdCBsaXN0JzogKCkgPT4ge1xuICAgICAgICB0aGlzLl9jdXJyZW50SG9zdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hvc3RzID0gbnVsbDtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIE9iamVjdC5rZXlzKG9wZXJhdGlvbnMpLmZvckVhY2goKG9wZXJhdGlvbktleSkgPT4ge1xuICAgICAgY29uc3QgeyBMT0dfVFJBQ0UsIExPR19JTkZPIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbb3BlcmF0aW9uS2V5XTtcbiAgICAgIHRyeSB7XG4gICAgICAgIExPR19UUkFDRShgRGlzcG9zZTogJHtvcGVyYXRpb25LZXl9YCk7XG4gICAgICAgIG9wZXJhdGlvbigpO1xuICAgICAgICBMT0dfVFJBQ0UoYERpc3Bvc2U6ICR7b3BlcmF0aW9uS2V5fSBzdWNjZWVkZWRgKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIExPR19JTkZPKGBEaXNwb3NlOiAke29wZXJhdGlvbktleX0gZmFpbGVkOmAsIGV4LCAnLi4uY29udGludWluZycpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGVtaXRTZXNzaW9uRXZlbnQoZXZlbnQpIHtcbiAgICAvLyBEb24ndCBsb2cgaGVyZTsgY2FsbGVlIGRvZXMgaXRcbiAgICB0aGlzLl9zZXNzaW9uLnNlbmRFdmVudChldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvcnJlbGF0aW9uVGFnIFRoZSBjb3JyZWxhdGlvbiB0YWdcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVxVGltZW91dENiIFRoZSB0aW1lb3V0IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXFUaW1lb3V0IFRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29ycmVsYXRpb25LZXkgVGhlIGNvcnJlbGF0aW9uIGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNwUmVjdkNhbGxiYWNrIFRoZSBzdWNjZXNzIGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbnF1ZXVlT3V0c3RhbmRpbmdDb3JyZWxhdGVkUmVxKGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcVRpbWVvdXRDYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BSZWN2Q2FsbGJhY2spIHtcbiAgICBpZiAoQ2hlY2subm90aGluZyhjb3JyZWxhdGlvblRhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKGBFbnF1ZXVlIG91dHN0YW5kaW5nIGN0cmwgcmVxdWVzdCBjb3JyZWxhdGlvblRhZz0ke2NvcnJlbGF0aW9uVGFnfWApO1xuICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgaWYgKHJlcVRpbWVvdXRDYikge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHJlcVRpbWVvdXRDYiwgcmVxVGltZW91dCB8fCB0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5yZWFkVGltZW91dEluTXNlY3MpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHN0YW5kaW5nUmVxID0gbmV3IENvcnJlbGF0ZWRSZXF1ZXN0KGNvcnJlbGF0aW9uVGFnLFxuICAgICAgdGltZXIsXG4gICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgIHJlc3BSZWN2Q2FsbGJhY2spO1xuICAgIHRoaXMuX2NvcnJlbGF0ZWRSZXFzW2NvcnJlbGF0aW9uVGFnXSA9IG91dHN0YW5kaW5nUmVxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckV2ZW50VGV4dCBEZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAgICogQHBhcmFtIHtFcnJvclN1YmNvZGV9IGVycm9yU3ViY29kZSBTdWJjb2RlIGZvciB0aGUgZXJyb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtldmVudFJlYXNvbl0gVGhlIHJlYXNvbiBmb3IgdGhlIGVycm9yXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBtZW1iZXJvZiBTZXNzaW9uRlNNXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlcnJvckluRnNtKGVycm9yRXZlbnRUZXh0LCBlcnJvclN1YmNvZGUsIGV2ZW50UmVhc29uID0gbnVsbCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBjb25zdCBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5FWENFUFRJT04gfSk7XG4gICAgTE9HX0RFQlVHKGBIYW5kbGluZyBlcnJvciBpbiBGU006ICR7ZXJyb3JFdmVudFRleHR9ICR7ZXZlbnRSZWFzb24gJiYgZXZlbnRSZWFzb24uc3RhY2t9YCk7XG4gICAgdGhpcy5zZXRDdXJyZW50RXJyb3Ioe1xuICAgICAgZXZlbnRUZXh0OiBlcnJvckV2ZW50VGV4dCxcbiAgICAgIGVycm9yU3ViY29kZSxcbiAgICAgIGV2ZW50UmVhc29uLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICB9XG5cbiAgZmx1c2hUcmFuc3BvcnRTZXNzaW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGEgc3RhdGljIG1ldGhvZCBvbiBzbWYgbm90IG5lY2Vzc2FyaWx5IGluc3RhbnRpYXRlZCBpbiBldmVyeVxuICAgKiBzbWZDbGllbnQuICBMb29rIGludG8gYWRkaW5nIGNvcnJlbGF0aW9uIHRhZyB3aGVuIG9iamVjdHMgYXJlIGNyZWF0ZVxuICAgKiAoQWRQcm90b2NvbE1zZywgY2xpZW50Q3RybE1zZykgdGhlbiByZXRyaWV2aW5nIGl0IGZyb20gdGhvc2Ugb2JqZWN0cy5cbiAgICogUmU6IHRhZ3MgY3JlYXRlZCBpbiBtZXNzYWdlczsgZG8gd2UgcmVhbGx5IHdhbnQgdG8gZGVjcmVhc2UgcGVyZm9ybWFuY2Ugb2YgbWVzc2FnZSBnZW5lcmF0aW9uP1xuICAgKiBUaG9zZSBtZXNzYWdlIHR5cGVzIGRvIG5vdCBuZWNlc3NhcmlseSByZXF1aXJlIGNvcnJlbGF0aW9uIHRhZ3MuIENvdWxkIGdlbmVyYXRlIHdoZW4gcmVxdWlyZWRcbiAgICogYmFzZWQgb24gbWVzc2FnZSBvYmplY3Qgc3VidHlwZSAoZS5nLiBPUEVORkxPVykuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBuZXh0IGNvcnJlbGF0aW9uIHRhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ycmVsYXRpb25UYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NtZkNsaWVudC5uZXh0Q29ycmVsYXRpb25UYWcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBzdGF0ZSBuYW1lXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlLCBvciBTZXNzaW9uU3RhdGVOYW1lLkRJU1BPU0VEIGlmIHRoZVxuICAgKiAgRlNNIGlzIHRlcm1pbmF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEN1cnJlbnRTdGF0ZU5hbWUoKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5nZXRDdXJyZW50U3RhdGUoKTtcblxuICAgIGlmICghY3VycmVudFN0YXRlKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoY3VycmVudFN0YXRlID09PSB0aGlzLmdldEZpbmFsU3RhdGUoKSkgcmV0dXJuIFNlc3Npb25TdGF0ZU5hbWUuRElTUE9TRUQ7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0YXRlKCkuZ2V0TmFtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ge0BsaW5rIFN0YXRUeXBlfS5cbiAgICpcbiAgICogQHBhcmFtIHtTdGF0VHlwZX0gc3RhdFR5cGUgVGhlIHN0YXRpc3RpYyB0byBxdWVyeS5cbiAgICogQHJldHVybnMgez9OdW1iZXJ9IFRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHN0YXQsIGlmIGF2YWlsYWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U3RhdChzdGF0VHlwZSkge1xuICAgIGlmICh0aGlzLl9zZXNzaW9uU3RhdGlzdGljcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIFRYX1RPVEFMX0RBVEFfTVNHUyBhbmQgVFhfVE9UQUxfREFUQV9CWVRFUyBhcmUgc3VtbWFyeSBjb3VudGVyc1xuICAgIC8vIFRoZXNlIHN0YXRzIGFyZSBjYWxjdWxhdGVkIGFzIHRoZSBzdW0gb2YgRElSRUNUL1BFUlNJU1RFTlQvTk9OUEVSU0lTVEVOVFxuICAgIC8vIGNvdW50ZXJzLiAgVGhpcyBpcyBieSBkZXNpZ24gc2luY2UgZGF5IG9uZS4gIEFzIHN1Y2ggdGhleSBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBjb3VudCBvZiByZWRlbGl2ZXJlZCBtZXNzYWdlcy9ieXRlcyBhcyBUWF9QRVJTSVNURU5UX01TR1MgYW5kIFRYX05PTlBFUlNJU1RFTlRfTVNHU1xuICAgIC8vIG9ubHkgaW5jbHVkZXMgdGhlIGNvdW50cyBvZiBtZXNzYWdlcyBzdWNjZXNzZnVsbHkgZGVsaXZlcmVkLiBUaGlzIGlzIG5vdCBjb25zaXN0ZW50XG4gICAgLy8gd2l0aCByZWNlaXZlIHN0YXRzIGJ1dCBpdCBpcyB3aGF0IGl0IGlzLiBUaGlzIGRlZmluaXRpb24gaXMgY29uc2lzdGVudCB3aXRoIHRoZSBvdGhlclxuICAgIC8vIGV4aXN0aW5nIEFQSXMgKENDU01QIGFuZCBKQ1NNUCkuXG4gICAgLy9cbiAgICBpZiAoc3RhdFR5cGUgPT09IFN0YXRUeXBlLlRYX1RPVEFMX0RBVEFfTVNHUykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzLmdldFN0YXQoU3RhdFR5cGUuVFhfRElSRUNUX01TR1MpICtcbiAgICAgICAgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MuZ2V0U3RhdChTdGF0VHlwZS5UWF9QRVJTSVNURU5UX01TR1MpICtcbiAgICAgICAgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MuZ2V0U3RhdChTdGF0VHlwZS5UWF9OT05QRVJTSVNURU5UX01TR1MpO1xuICAgIH0gZWxzZSBpZiAoc3RhdFR5cGUgPT09IFN0YXRUeXBlLlRYX1RPVEFMX0RBVEFfQllURVMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcy5nZXRTdGF0KFN0YXRUeXBlLlRYX0RJUkVDVF9CWVRFUykgK1xuICAgICAgICB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcy5nZXRTdGF0KFN0YXRUeXBlLlRYX1BFUlNJU1RFTlRfQllURVMpICtcbiAgICAgICAgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MuZ2V0U3RhdChTdGF0VHlwZS5UWF9OT05QRVJTSVNURU5UX0JZVEVTKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzLmdldFN0YXQoc3RhdFR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB0cmFuc3BvcnQgc2Vzc2lvbiBpbmZvcm1hdGlvbiBzdHJpbmcuXG4gICAqIFRoaXMgc3RyaW5nIGlzIGluZm9ybWF0aXZlIG9ubHksIGFuZCBhcHBsaWNhdGlvbnMgc2hvdWxkIG5vdCBhdHRlbXB0IHRvIHBhcnNlIGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHRyYW5zcG9ydFxuICAgKi9cbiAgZ2V0VHJhbnNwb3J0SW5mbygpIHtcbiAgICBpZiAoQ2hlY2subm90aGluZyh0aGlzLl90cmFuc3BvcnQpKSB7XG4gICAgICByZXR1cm4gJ05vdCBjb25uZWN0ZWQuJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRJbmZvU3RyKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGFuIEFEIENUUkwgbWVzc2FnZSBnaXZlbiB0aGUgbWVzc2FnZSwgaXRzIGhlYWRlciwgYW5kIHRoZSBwcmV2aW91c2x5LWlkZW50aWZpZWRcbiAgICogY2FuZGlkYXRlIGZsb3csIHdoaWNoIGlzIHVzZWQgaWYgdGhlIG1lc3NhZ2UgaGFzIG5vIGNvcnJlbGF0aW9uIHRhZy5cbiAgICpcbiAgICogQHBhcmFtIHtBZFByb3RvY29sTWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYW5kbGVcbiAgICogQHBhcmFtIHtTTUZIZWFkZXJ9IGhlYWRlciBUaGUgaGVhZGVyIG9mIHRoZSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtTZXNzaW9uRlNNfSBUaGlzIEZTTS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUFEQ3RybE1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKSB7XG4gICAgY29uc3QgZmxvd0lkID0gbWVzc2FnZS5nZXRGbG93SWQoKTtcbiAgICBjb25zdCByZXNwVGV4dCA9IGhlYWRlci5wbV9yZXNwc3RyO1xuICAgIGNvbnN0IGNvcnJlbGF0aW9uVGFnID0gaGVhZGVyLnBtX2NvcnJ0YWc7XG4gICAgY29uc3QgeyBMT0dfREVCVUcsIExPR19XQVJOIH0gPSB0aGlzLmxvZ2dlcjtcblxuICAgIGlmIChjb3JyZWxhdGlvblRhZykge1xuICAgICAgLy8gQ29ycmVsYXRpb24gdGFnIGlzIG5vbi1udWxsXG4gICAgICAvLyBTZXNzaW9uIGhhbmRsZXMgY29ycmVsYXRlZCByZXF1ZXN0LXJlcGx5XG4gICAgICB0aGlzLnVwZGF0ZVJ4U3RhdHMobWVzc2FnZSk7XG5cbiAgICAgIExPR19ERUJVRyhgSGFuZGxlIFNNRiByZXNwb25zZSBmb3IgY29ycmVsYXRpb25UYWcgJHtjb3JyZWxhdGlvblRhZ31gKTtcbiAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgY29ycmVsYXRpb25UYWcgdG8gY2FuY2VsIHRpbWVyXG4gICAgICBjb25zdCBjYW5jZWxsZWRSZXF1ZXN0ID0gdGhpcy5jYW5jZWxPdXRzdGFuZGluZ0NvcnJlbGF0ZWRSZXEoY29ycmVsYXRpb25UYWcpO1xuICAgICAgaWYgKENoZWNrLm5vdGhpbmcoY2FuY2VsbGVkUmVxdWVzdCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JJbkZzbShgQ2Fubm90IGZpbmQgbWF0Y2hpbmcgcmVxdWVzdCBmb3IgcmVzcG9uc2U6ICR7cmVzcFRleHR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5URVJOQUxfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkUmVxdWVzdC5yZXNwUmVjdmRDYWxsYmFjaykge1xuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIHJlZmVyZW5jZWQgYnkgY2FuY2VsbGVkUmVxdWVzdFxuICAgICAgICAvLyBsb2dpbiBvciB1cGRhdGUgcHJvcGVydHlcbiAgICAgICAgY2FuY2VsbGVkUmVxdWVzdC5yZXNwUmVjdmRDYWxsYmFjayhtZXNzYWdlLCBjYW5jZWxsZWRSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIExPR19ERUJVRyhgRHJvcHBpbmcgQURDVFJMIG1lc3NhZ2UgZHVlIHRvIG1pc21hdGNoZWQgY29ycmVsYXRpb24gdGFnICR7Y29ycmVsYXRpb25UYWd9YCk7XG4gICAgICB0aGlzLmluY1N0YXQoU3RhdFR5cGUuUlhfUkVQTFlfTVNHX0RJU0NBUkQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gVW5zb2xpY2l0ZWQgY29udHJvbCBtZXNzYWdlXG4gICAgbGV0IGZsb3c7XG4gICAgY29uc3QgbXNnVHlwZSA9IG1lc3NhZ2UubXNnVHlwZTtcbiAgICBjb25zdCB7IFNNRkFkUHJvdG9jb2xNZXNzYWdlVHlwZSB9ID0gU01GTGliO1xuICAgIHN3aXRjaCAobXNnVHlwZSkge1xuICAgICAgY2FzZSBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xJRU5UQUNLOlxuICAgICAgY2FzZSBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xJRU5UTkFDSzpcbiAgICAgIGNhc2UgU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLkNMT1NFUFVCRkxPVzpcbiAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRQdWJsaXNoZXIuZmxvd0lkID09PSBmbG93SWQpIHtcbiAgICAgICAgICBmbG93ID0gdGhpcy5fZGVmYXVsdFB1Ymxpc2hlcjtcbiAgICAgICAgfSAvLyBlbHNlIGRyb3AuXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZmxvdyA9IHRoaXMuX2NvbnN1bWVycy5nZXRGbG93QnlJZChmbG93SWQpO1xuICAgIH1cblxuICAgIGlmIChmbG93ICYmICFmbG93LmRpc3Bvc2VkKSB7XG4gICAgICAvLyBGb3VuZCBhIG1hdGNoaW5nIGZsb3dcbiAgICAgIHRoaXMudXBkYXRlUnhTdGF0cyhtZXNzYWdlLCBmbG93KTtcbiAgICAgIGZsb3cuaGFuZGxlVW5jb3JyZWxhdGVkQ29udHJvbE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBObyBtYXRjaGluZyBmbG93XG4gICAgY29uc3QgcmVzcG9uc2UgPSBtZXNzYWdlLmdldFJlc3BvbnNlKCk7XG4gICAgY29uc3QgcmMgPSByZXNwb25zZSA/IGBcIiR7cmVzcG9uc2UucmVzcG9uc2VDb2RlfSAke3Jlc3BvbnNlLnJlc3BvbnNlU3RyaW5nfVwiIGAgOiAnJztcbiAgICBMT0dfV0FSTihcbiAgICAgIGBEcm9wcGluZyBBRENUUkwuJHtTTUZMaWIuU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLmRlc2NyaWJlKG1lc3NhZ2UubXNnVHlwZSlcbiAgICAgIH0gJHtyY31mb3IgdW5rbm93biBmbG93ICR7Zmxvd0lkfWBcbiAgICApO1xuICAgIHRoaXMuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX05PX01BVENISU5HX0NPTlNVTUVSKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2UgVGhlIEFEIGRhdGEgbWVzc2FnZSB0byBoYW5kbGVcbiAgICogQHBhcmFtIHtTTUZIZWFkZXJ9IGhlYWRlciBUaGUgaGVhZGVyIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7TWVzc2FnZUNvbnN1bWVyfSBUaGUgZmxvdyB0aGF0IGhhbmRsZWQgdGhlIG1lc3NhZ2UsIG9yIGBudWxsYFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQURUck1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKSB7XG4gICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IGZsb3dJZCA9IGhlYWRlci5wbV9hZF9mbG93aWQ7XG4gICAgLy8gR2V0IGEgZmxvdyBmcm9tIHRoYXQgSUQgaWYgcG9zc2libGUuXG4gICAgY29uc3QgZmxvdyA9IHRoaXMuX2NvbnN1bWVycy5nZXRGbG93QnlJZChmbG93SWQpO1xuICAgIGlmICghZmxvdyB8fCBmbG93LmRpc3Bvc2VkKSB7XG4gICAgICBMT0dfREVCVUcoJ0Ryb3BwZWQgaW5jb21pbmcgQUQgbWVzc2FnZSBmb3IgJyArXG4gICAgICAgICAgICAgICAgYCR7ZmxvdyA/ICdkaXNwb3NlZCcgOiAndW5rbm93bid9IGZsb3cgSUQgJHtmbG93SWR9YCk7XG4gICAgICB0aGlzLnVwZGF0ZVJ4U3RhdHMobWVzc2FnZSwgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MpO1xuICAgICAgdGhpcy5pbmNTdGF0KFN0YXRUeXBlLlJYX0RJU0NBUkRfTk9fTUFUQ0hJTkdfQ09OU1VNRVIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUnhTdGF0cyhtZXNzYWdlLCBmbG93KTtcbiAgICBmbG93LmhhbmRsZURhdGFNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiBmbG93O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JyZWxhdGlvblRhZyBUaGUgY29ycmVsYXRpb24gdGFnIGZvciB0aGUgdGltZWQgb3V0IHN1YnNjcmlwdGlvbiByZXF1ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdGltZW91dE1zZ10gVGhlIHJlYXNvbiBmb3IgdGhlIHRpbWVvdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUFwaVN1YnNjcmlwdGlvblRpbWVvdXQoY29ycmVsYXRpb25UYWcsIHRpbWVvdXRNc2cpIHtcbiAgICAvLyByZW1vdmUgcmVxdWVzdCBmcm9tIHF1ZXVlXG4gICAgaWYgKHRoaXMuX2NvcnJlbGF0ZWRSZXFzW2NvcnJlbGF0aW9uVGFnXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHRoaXMuX2NvcnJlbGF0ZWRSZXFzW2NvcnJlbGF0aW9uVGFnXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHsgTE9HX0RFQlVHLCBMT0dfRVJST1IgfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19ERUJVRyhgJHt0aW1lb3V0TXNnIHx8ICdTdWJzY3JpcHRpb24gdGltZW91dCd9IGZvciBjb3JyZWxhdGlvblRhZz0ke2NvcnJlbGF0aW9uVGFnfWApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWxldGUgdGhpcy5fY29ycmVsYXRlZFJlcXNbY29ycmVsYXRpb25UYWddO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgTE9HX0VSUk9SKGBDYW5ub3QgZGVsZXRlIGN0cmwgcmVxdWVzdCAke2NvcnJlbGF0aW9uVGFnfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBjdHJsIHJlcXVlc3QgJHtjb3JyZWxhdGlvblRhZ30sIGV4Y2VwdGlvbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2xpZW50Q3RybE1lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFuZGxlXG4gICAqIEBwYXJhbSB7U01GSGVhZGVyfSBoZWFkZXIgVGhlIGhlYWRlciBmcm9tIHRoZSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGllbnRDdHJsTWVzc2FnZShtZXNzYWdlLCBoZWFkZXIpIHtcbiAgICBsZXQgY29ycmVsYXRpb25UYWc7XG4gICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgIHRoaXMudXBkYXRlUnhTdGF0cyhtZXNzYWdlKTtcbiAgICBpZiAobWVzc2FnZS5tc2dUeXBlID09PSBTTUZMaWIuU01GQ2xpZW50Q3RybE1lc3NhZ2VUeXBlLkxPR0lOKSB7XG4gICAgICAvLyBDdXJyZW50bHksIGxvZ2luIHJlcXVlc3RzIGRvbid0IHVzZSBhIGNvcnJlbGF0aW9uIHRhZy5cbiAgICAgIC8vIFVzaW5nIGhlcmUgYSBmYWtlIGludGVybmFsIG9uZSB0byBtYXRjaCB0aGUgcmVxdWVzdC5cbiAgICAgIGNvcnJlbGF0aW9uVGFnID0gVHJhbnNwb3J0TGliLlNNRkNsaWVudC5TTUZfQ0xJRU5UQ1RSTF9MT0dJTl9GQUtFX0NPUlJFTEFUSU9OVEFHO1xuICAgICAgTE9HX0RFQlVHKCdIYW5kbGUgU01GIHJlc3BvbnNlIGZvciBDbGllbnRDVFJMIExvZ2luJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcnJlbGF0aW9uVGFnID0gaGVhZGVyLnBtX2NvcnJ0YWc7XG4gICAgICBMT0dfREVCVUcoYEhhbmRsZSBTTUYgcmVzcG9uc2UgZm9yIGNvcnJlbGF0aW9uVGFnICR7Y29ycmVsYXRpb25UYWd9YCk7XG4gICAgfVxuICAgIC8vIGZpbmQgbWF0Y2hpbmcgY29ycmVsYXRpb25UYWcgdG8gY2FuY2VsIHRpbWVyXG4gICAgY29uc3QgY2FuY2VsbGVkUmVxdWVzdCA9IHRoaXMuY2FuY2VsT3V0c3RhbmRpbmdDb3JyZWxhdGVkUmVxKGNvcnJlbGF0aW9uVGFnKTtcbiAgICBpZiAoQ2hlY2subm90aGluZyhjYW5jZWxsZWRSZXF1ZXN0KSkge1xuICAgICAgY29uc3QgcmVzcFRleHQgPSBoZWFkZXIucG1fcmVzcHN0cjtcbiAgICAgIHJldHVybiB0aGlzLmVycm9ySW5Gc20oYENhbm5vdCBmaW5kIG1hdGNoaW5nIHJlcXVlc3QgZm9yIHJlc3BvbnNlOiAke3Jlc3BUZXh0fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfSBlbHNlIGlmIChjYW5jZWxsZWRSZXF1ZXN0LnJlc3BSZWN2ZENhbGxiYWNrKSB7XG4gICAgICAvLyBjYWxsIGNhbGxiYWNrIHJlZmVyZW5jZWQgYnkgY2FuY2VsbGVkUmVxdWVzdFxuICAgICAgLy8gbG9naW4gb3IgdXBkYXRlIHByb3BlcnR5XG4gICAgICByZXR1cm4gY2FuY2VsbGVkUmVxdWVzdC5yZXNwUmVjdmRDYWxsYmFjayhtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoYERyb3BwaW5nIENsaWVudEN0cmwgbWVzc2FnZSBkdWUgdG8gbWlzbWF0Y2hlZCBjb3JyZWxhdGlvbiB0YWcgJHtjb3JyZWxhdGlvblRhZ31gKTtcbiAgICByZXR1cm4gdGhpcy5pbmNTdGF0KFN0YXRUeXBlLlJYX1JFUExZX01TR19ESVNDQVJEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NsaWVudEN0cmxNZXNzYWdlfSBjbGllbnRDdHJsTXNnIFRoZSBtZXNzYWdlIHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpZW50Q3RybFJlc3BvbnNlKGNsaWVudEN0cmxNc2cpIHtcbiAgICBjb25zdCBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfUFJPVE9DT0xfQ0xJRU5UQ1RSTCB9KTtcbiAgICBzRXZlbnQuc21mTXNnID0gY2xpZW50Q3RybE1zZztcbiAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDbGllbnRDdHJsVGltZW91dCgpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgTE9HX0RFQlVHKCdDbGllbnRDdHJsIHRpbWVvdXQgZm9yIHNlc3Npb24nKTtcbiAgICBjb25zdCBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5ET1dOR1JBREVfVElNRU9VVCB9KTtcbiAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICB9XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBMT0dfREVCVUcoJ0Nvbm5lY3Rpb24gdGltZW91dC4gRGlzY29ubmVjdGluZycpO1xuICAgIGNvbnN0IHNFdmVudCA9IG5ldyBTZXNzaW9uRlNNRXZlbnQoeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLkNPTk5FQ1RfVElNRU9VVCB9KTtcbiAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjb250cm9sIHJlcXVlc3QgdGltZW91dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25UYWcgVGhlIGNvcnJlbGF0aW9uIHRhZyBmb3IgdGhlIHRpbWVkIG91dCBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRpbWVvdXRNc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSB0aW1lb3V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVVcGRhdGVQcm9wZXJ0eVRpbWVvdXQoY29ycmVsYXRpb25UYWcsIHRpbWVvdXRNc2cpIHtcbiAgICBjb25zdCB7IExPR19FUlJPUiB9ID0gdGhpcy5sb2dnZXI7XG4gICAgLy8gcmVtb3ZlIHJlcXVlc3QgZnJvbSBxdWV1ZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZWxldGUgdGhpcy5fY29ycmVsYXRlZFJlcXNbY29ycmVsYXRpb25UYWddO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgTE9HX0VSUk9SKGBDYW5ub3QgZGVsZXRlIGN0cmwgcmVxdWVzdCAke2NvcnJlbGF0aW9uVGFnfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBjdHJsIHJlcXVlc3QgJHtjb3JyZWxhdGlvblRhZ30sIGV4Y2VwdGlvbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgLy8gbm90aWZ5IGNsaWVudFxuICAgIGNvbnN0IHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLlBST1BFUlRZX1VQREFURV9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dE1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlRJTUVPVVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgIHRoaXMuc2VuZEV2ZW50KHNlc3Npb25FdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTTUZIZWFkZXJ9IGhlYWRlciBUaGUgaGVhZGVyIGZyb20gdGhlIHJlamVjdGVkIG1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVJlamVjdGVkVHJNZXNzYWdlKGhlYWRlcikge1xuICAgIC8vIEl0IGlzIHRybXNnIHJlc3BvbnNlLiBGb3IgZGlyZWN0IG1lc3NhZ2UsIGl0IG11c3QgYmUgYSBmYWlsdXJlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzcENvZGUgPSBoZWFkZXIucG1fcmVzcGNvZGU7XG4gICAgY29uc3QgcmVzcFRleHQgPSBoZWFkZXIucG1fcmVzcHN0cjtcbiAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRFcnJvclN1YmNvZGUocmVzcENvZGUsIHJlc3BUZXh0KTtcbiAgICB0aGlzLmVtaXRTZXNzaW9uRXZlbnQoU2Vzc2lvbkV2ZW50LmJ1aWxkKFxuICAgICAgU2Vzc2lvbkV2ZW50Q29kZS5SRUpFQ1RFRF9NRVNTQUdFX0VSUk9SLFxuICAgICAgcmVzcFRleHQsXG4gICAgICByZXNwQ29kZSxcbiAgICAgIGVycm9yU3ViY29kZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2UgVGhlIFNNRiBtZXNzYWdlIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU01GTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0YXRzIGZvciB0aGlzIG1lc3NhZ2UgbWlnaHQgYWZmZWN0IGJvdGggdGhlIHNlc3Npb24gYW5kIHRoZSBmbG93LiBOZWVkIHRvXG4gICAgICAvLyBkZXRlcm1pbmUgd2hlcmUgdGhlIG1lc3NhZ2UgaXMgaGFuZGxlZCBiZWZvcmUgaGFuZGxpbmcgc3RhdHMuXG4gICAgICAvLyBTb21lIEFEQ1RSTCBtZXNzYWdlcyBoYXZlIG5vIGZsb3cgSUQgYnV0IG9ubHkgYSBjb3JyZWxhdGlvbiB0YWcuXG4gICAgICAvLyBUaGVzZSBhcmUgT1BFTkZMT1cgYW5kIHdlIGNvdW50IHRoZW0gYXMgaGFuZGxlZCBieSB0aGUgc2Vzc2lvbi5cblxuICAgICAgY29uc3QgaGVhZGVyID0gbWVzc2FnZS5zbWZIZWFkZXI7XG5cbiAgICAgIGlmIChoZWFkZXIuZGlzY2FyZE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVUg9PTIgb24gYW4gdW5rbm93biBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX1NNRl9VTktOT1dOX0VMRU1FTlQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBFYWNoIG1lc3NhZ2UgdHlwZSBoYW5kbGVyIG11c3QgY2FsbCB0aGlzLnVwZGF0ZVJ4U3RhdHMobWVzc2FnZSwgdGFyZ2V0KS5cbiAgICAgIC8vIFRoZSBkaXJlY3QvVFJtc2cgcGF0aCBpbmNsdWRlcyB0aGUgY2FsbCBoZXJlIGluIHRoZSBzd2l0Y2guXG4gICAgICBzd2l0Y2ggKGhlYWRlci5zbWZfcHJvdG9jb2wpIHtcbiAgICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuVFJNU0c6XG4gICAgICAgICAgaWYgKGhlYWRlci5zbWZfYWRmKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVBRFRyTWVzc2FnZShtZXNzYWdlLCBoZWFkZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZVJ4U3RhdHMobWVzc2FnZSwgdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MpO1xuICAgICAgICAgIHJldHVybiBoZWFkZXIucG1fcmVzcGNvZGUgPT09IDBcbiAgICAgICAgICAgID8gdGhpcy5fc2Vzc2lvbi5oYW5kbGVEYXRhTWVzc2FnZShtZXNzYWdlKVxuICAgICAgICAgICAgOiB0aGlzLmhhbmRsZVJlamVjdGVkVHJNZXNzYWdlKGhlYWRlcik7XG5cbiAgICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuQURDVFJMOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUFEQ3RybE1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKTtcblxuICAgICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5DTElFTlRDVFJMOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudEN0cmxNZXNzYWdlKG1lc3NhZ2UsIGhlYWRlcik7XG5cbiAgICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuU01QOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNNUE1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKTtcblxuICAgICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5LRUVQQUxJVkU6XG4gICAgICAgIGNhc2UgU01GTGliLlNNRlByb3RvY29sLktFRVBBTElWRVYyOlxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVVua25vd25Qcm90b2NvbE1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCB7IExPR19FUlJPUiB9ID0gdGhpcy5sb2dnZXI7XG4gICAgICBMT0dfRVJST1IoYEV4Y2VwdGlvbiBpbiBoYW5kbGVTTUZNZXNzYWdlLCBleGNlcHRpb246ICR7ZS5zdGFja31gKTtcbiAgICAgIHJldHVybiB0aGlzLmVycm9ySW5Gc20oYEV4Y2VwdGlvbiBpbiBoYW5kbGVTTUZNZXNzYWdlOiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN1YmNvZGUgfHwgRXJyb3JTdWJjb2RlLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc3BvcnRFcnJvcn0gdHJhbnNwb3J0RXJyb3IgVGhlIFNNRiBwYXJzaW5nIGVycm9yIHBhc3NlZCBmcm9tIHRoZSB0cmFuc3BvcnRcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVNNRlBhcnNlRXJyb3IodHJhbnNwb3J0RXJyb3IpIHtcbiAgICAvLyBmYXRhbCBjb25uZWN0aW9uIGVycm9yXG5cbiAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JJbkZzbSh0cmFuc3BvcnRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QUk9UT0NPTF9FUlJPUik7IC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIFBBUlNFX0ZBSUxVUkVcbiAgfVxuXG4gIGhhbmRsZVNNUE1lc3NhZ2UobWVzc2FnZSwgaGVhZGVyKSB7XG4gICAgdGhpcy51cGRhdGVSeFN0YXRzKG1lc3NhZ2UpO1xuXG4gICAgLy8gZmluZCBtYXRjaGluZyBjb3JyZWxhdGlvblRhZyB0byBjYW5jZWwgdGltZXJcbiAgICBjb25zdCBjYW5jZWxsZWRSZXF1ZXN0ID0gdGhpcy5jYW5jZWxPdXRzdGFuZGluZ0NvcnJlbGF0ZWRSZXEoaGVhZGVyLnBtX2NvcnJ0YWcgfHwgJycpO1xuICAgIC8qXG4gICAgICogSWYgd2UgZmluZCB0aGUgY29ycmVsYXRpb25UYWcgYW5kIGl0IGhhcyBhIGNhbGxiYWNrIGFzc29jaWF0ZWQgd2l0aCBpdFxuICAgICAqIHRoZW4gY2FsbCB0aGF0IGNhbGxiYWNrLiAgSXQgaXMgbGlrZWx5IGNhbGxpbmcgYmFjayBzdHJhaWdodCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBkdWUgdG8gYSBjYWxsIHRvIHNlc3Npb24uc3Vic2NyaWJlKCkgb3Igc2Vzc2lvbi51bnN1YnNjcmliZSgpIG9yXG4gICAgICogc2Vzc2lvbi51cGRhdGVQcm9wZXJ0eSgpLlxuICAgICAqIE90aGVyd2lzZSBqdXN0IHNlbmQgYSBUUkFOU1BPUlRfUFJPVE9DT0xfU01QIGV2ZW50IHRvIHRoZSBGU00uXG4gICAgICovXG4gICAgaWYgKENoZWNrLm5vdGhpbmcoY2FuY2VsbGVkUmVxdWVzdCkgfHwgQ2hlY2subm90aGluZyhjYW5jZWxsZWRSZXF1ZXN0LnJlc3BSZWN2ZENhbGxiYWNrKSkge1xuICAgICAgLypcbiAgICAgICAqIGNvcnJlbGF0aW9uIHRhZyBub3QgZm91bmQsIHByb2JhYmx5IGFuIGVycm9yIHJlc3BvbnNlIHRvIGEgc3Vic2NyaXB0aW9uXG4gICAgICAgKiByZXF1ZXN0IHRoYXQgZGlkIG5vdCByZXF1ZXN0LWNvbmZpcm0sICBvciBpdCBjb3VsZCBiZSBvbmUgb2YgdGhlXG4gICAgICAgKiBGU00gZ2VuZXJhdGVkIHN1YnNjcmlwdGlvbnMgYW5kIHRoZSBjYWxsYmFjayBpcyB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uXG4gICAgICAgKiBpbiBzdGF0ZSBXYWl0aW5nRm9yU3ViQ29uZmlybW1cbiAgICAgICAqL1xuICAgICAgY29uc3Qgc0V2ZW50ID0gbmV3IFNlc3Npb25GU01FdmVudCh7IG5hbWU6IFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX1BST1RPQ09MX1NNUCB9KTtcbiAgICAgIHNFdmVudC5zbWZNc2cgPSBtZXNzYWdlO1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0V2ZW50KHNFdmVudCk7XG4gICAgfVxuXG4gICAgLy8gY2FsbGluZyB0aHJvdWdoIHRoZSBjYWxsYmFjaywgdGhpcyBzaG91bGQgIGJlIGEgY2FsbGJhY2sgaW4gdGhlIF9zZXNzaW9uIGZvclxuICAgIC8vIGFwcGxpY2F0ZWQgZ2VuZXJhdGVkIHN1YnNjcmliZS91bnN1YnNjcmliZS91cGRhdGVQcm9wZXJ0eShjbGllbnROYW1lKVxuICAgIHJldHVybiBjYW5jZWxsZWRSZXF1ZXN0LnJlc3BSZWN2ZENhbGxiYWNrKG1lc3NhZ2UsIGNhbmNlbGxlZFJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXNwQ29kZSBUaGUgcm91dGVyIHJlc3BvbnNlIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlc3BUZXh0IFRoZSByb3V0ZXIgcmVzcG9uc2UgdGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3Vic2NyaXB0aW9uU3RyIFRoZSBzdWJzY3JpcHRpb24gY2FjaGUga2V5XG4gICAqIEBwYXJhbSB7Q29ycmVsYXRlZFJlcXVlc3R9IHJlcXVlc3QgVGhlIGFzc29jaWF0ZWQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpcm0gV2hldGhlciB0aGUgdXNlciB3YW50ZWQgY29uZmlybWF0aW9uIGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlRXJyb3IocmVzcENvZGUsIHJlc3BUZXh0LCBzdWJzY3JpcHRpb25TdHIsIHJlcXVlc3QsIGNvbmZpcm0pIHtcbiAgICBjb25zdCBlcnJvclN1YmNvZGUgPSBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRFcnJvclN1YmNvZGUocmVzcENvZGUsIHJlc3BUZXh0KTtcblxuICAgIC8vXG4gICAgLy8gaWYgaXQgaXMgYSBub3QtZm91bmQgb3IgYWxyZWFkeS1wcmVzZW50IGVycm9yLCBpdCBkb2VzIG5vdCBhZmZlY3Qgb3VyIHN1YnNjcmlwdGlvblxuICAgIC8vIGNhY2hlLCBvdGhlcndpc2UgcmVtb3ZlIGl0IGZyb20gdGhlIGNhY2hlLlxuICAgIC8vXG4gICAgaWYgKCEoZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0FMUkVBRFlfUFJFU0VOVCB8fFxuICAgICAgZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX05PVF9GT1VORCkpIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICB0aGlzLnJlbW92ZUZyb21TdWJzY3JpcHRpb25DYWNoZShzdWJzY3JpcHRpb25TdHIpO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gbm90aWZ5IHRoZSBjbGllbnRcbiAgICAvL1xuICAgIHRoaXMuX3Nlc3Npb24uaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlRXJyb3IocmVzcENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25UYWcgVGhlIGNvcnJlbGF0aW9uIHRhZyBmb3IgdGhlIHRpbWVkIG91dCByZXF1ZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTdWJzY3JpcHRpb25UaW1lb3V0KGNvcnJlbGF0aW9uVGFnKSB7XG4gICAgLy8gcmVtb3ZlIHJlcXVlc3QgZnJvbSBxdWV1ZVxuICAgIGNvbnN0IHsgTE9HX0VSUk9SIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVsZXRlIHRoaXMuX2NvcnJlbGF0ZWRSZXFzW2NvcnJlbGF0aW9uVGFnXTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBjdHJsIHJlcXVlc3QgJHtjb3JyZWxhdGlvblRhZ31gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMT0dfRVJST1IoYENhbm5vdCBkZWxldGUgY3RybCByZXF1ZXN0ICR7Y29ycmVsYXRpb25UYWd9YCwgZSk7XG4gICAgfVxuICAgIGNvbnN0IHNFdmVudCA9IG5ldyBTZXNzaW9uRlNNRXZlbnQoeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLlNVQlNDUklCRV9USU1FT1VUIH0pO1xuICAgIHRoaXMucHJvY2Vzc0V2ZW50KHNFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc3BvcnRTZXNzaW9uRXZlbnR9IHRyYW5zcG9ydEV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVRyYW5zcG9ydEV2ZW50KHRyYW5zcG9ydEV2ZW50KSB7XG4gICAgY29uc3QgeyBMT0dfREVCVUcsIExPR19XQVJOIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBjb25zdCBpbmZvU3RyID0gdHJhbnNwb3J0RXZlbnQuZ2V0SW5mb1N0cigpIHx8ICcnO1xuICAgIExPR19ERUJVRyhgUmVjZWl2ZSB0cmFuc3BvcnQgZXZlbnQ6ICR7dHJhbnNwb3J0RXZlbnR9YCk7XG5cbiAgICBsZXQgc0V2ZW50O1xuXG4gICAgc3dpdGNoICh0cmFuc3BvcnRFdmVudC5nZXRUcmFuc3BvcnRFdmVudENvZGUoKSkge1xuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5VUF9OT1RJQ0U6XG4gICAgICAgIHNFdmVudCA9IG5ldyBTZXNzaW9uRlNNRXZlbnQoeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLlRSQU5TUE9SVF9VUCB9KTtcbiAgICAgICAgc0V2ZW50LnNlc3Npb25JZCA9IHRyYW5zcG9ydEV2ZW50LmdldFNlc3Npb25JZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5ERVNUUk9ZRURfTk9USUNFOlxuICAgICAgICBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5UUkFOU1BPUlRfREVTVFJPWUVEIH0pO1xuICAgICAgICBzRXZlbnQuc2Vzc2lvbklkID0gdHJhbnNwb3J0RXZlbnQuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgIHNFdmVudC5ldmVudFRleHQgPSBpbmZvU3RyO1xuICAgICAgICBzRXZlbnQuZXJyb3JTdWJjb2RlID0gdHJhbnNwb3J0RXZlbnQuZ2V0U3ViY29kZSgpO1xuICAgICAgICBzRXZlbnQuZXZlbnRSZWFzb24gPSB0cmFuc3BvcnRFdmVudDtcbiAgICAgICAgdGhpcy5fc21mQ2xpZW50ID0gbnVsbDsgLy8gY2FsbGluZyByZXNldCBkb2VzIG5vdGhpbmcgdXNlZnVsIGhlcmVcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDsgLy8gdHJhbnNwb3J0IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5DQU5fQUNDRVBUX0RBVEE6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHVuYmxvY2sgdGhlIHB1Ymxpc2hlciB0b29cbiAgICAgICAgdGhpcy5HdWFyYW50ZWVkRmxvd0NvbnRyb2xsZWRSZWxpZWYoKTtcbiAgICAgICAgc0V2ZW50ID0gbmV3IFNlc3Npb25GU01FdmVudCh7IG5hbWU6IFNlc3Npb25FdmVudE5hbWUuVFJBTlNQT1JUX0NBTl9BQ0NFUFRfREFUQSB9KTtcbiAgICAgICAgc0V2ZW50LnNlc3Npb25JZCA9IHRyYW5zcG9ydEV2ZW50LmdldFNlc3Npb25JZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5TRU5EX0VSUk9SOlxuICAgICAgICBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5TRU5EX0VSUk9SIH0pO1xuICAgICAgICBzRXZlbnQuc2Vzc2lvbklkID0gdHJhbnNwb3J0RXZlbnQuZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgIHNFdmVudC5ldmVudFRleHQgPSB0cmFuc3BvcnRFdmVudC5nZXRJbmZvU3RyKCk7XG4gICAgICAgIHNFdmVudC5lcnJvclN1YmNvZGUgPSB0cmFuc3BvcnRFdmVudC5nZXRTdWJjb2RlKCk7XG4gICAgICAgIHNFdmVudC5ldmVudFJlYXNvbiA9IHRyYW5zcG9ydEV2ZW50O1xuICAgICAgICB0aGlzLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5EQVRBX0RFQ09ERV9FUlJPUjpcbiAgICAgIGNhc2UgVHJhbnNwb3J0TGliLlRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuUEFSU0VfRkFJTFVSRTpcbiAgICAgICAgLy8gZmF0YWwgY29ubmVjdGlvbiBlcnJvclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckluRnNtKHRyYW5zcG9ydEV2ZW50LmdldEluZm9TdHIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRFdmVudC5nZXRTdWJjb2RlKCkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgTE9HX1dBUk4oJ1JlY2VpdmVkIHVua25vd24gdHJhbnNwb3J0IHNlc3Npb24gZXZlbnQnLCB0cmFuc3BvcnRFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCYXNlTWVzc2FnZXxNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhbmRsZVxuICAgKiBAcGFyYW0ge1NNRkhlYWRlcn0gW2hlYWRlcl0gVGhlIFNNRiBoZWFkZXIgZnJvbSB0aGUgbWVzc2FnZSwgaWYgYXZhaWxhYmxlXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVVbmtub3duUHJvdG9jb2xNZXNzYWdlKG1lc3NhZ2UsIGhlYWRlcikge1xuICAgIGNvbnN0IHsgTE9HX0lORk8sIExPR19FUlJPUiB9ID0gdGhpcy5sb2dnZXI7XG4gICAgLy8gdW5rbm93biBwcm90b2NvbFxuICAgIHRoaXMudXBkYXRlUnhTdGF0cyhtZXNzYWdlKTtcbiAgICBpZiAoaGVhZGVyICYmIGhlYWRlci5zbWZfcHJvdG9jb2wgPT09IFNNRkxpYi5TTUZQcm90b2NvbC5UU0VTU0lPTikge1xuICAgICAgLy8gY2hhbmdlIHN0YXRlXG4gICAgICBMT0dfRVJST1IoYFJlY2VpdmVkIHRyYW5zcG9ydCBzZXNzaW9uIG1lc3NhZ2UgaW5zdGVhZCBvZiBTTUYgbWVzc2FnZSwgcHJvdG9jb2wgMHgke1xuICAgICAgICBmb3JtYXRIZXhTdHJpbmcoaGVhZGVyLnNtZl9wcm90b2NvbCl9YCk7XG4gICAgICBMT0dfRVJST1IoYFRyYW5zcG9ydCBNZXNzYWdlVHlwZT0ke21lc3NhZ2UubWVzc2FnZVR5cGV9LCB0YXJnZXQgc2Vzc2lvbklkPSR7XG4gICAgICAgIGZvcm1hdEhleFN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCl9YCk7XG4gICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICByZXR1cm4gdGhpcy5lcnJvckluRnNtKCdSZWNlaXZlZCBtZXNzYWdlIHdpdGggdW5rbm93biBwcm90b2NvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJTRV9GQUlMVVJFKTtcbiAgICB9XG5cbiAgICAvLyBEcm9wIG1lc3NhZ2Ugb2YgdW5rbm93biBwcm90b2NvbCBhbmQgaW5jcmVtZW50IHN0YXRzXG4gICAgaWYgKHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzKSB7XG4gICAgICB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcy5pbmNTdGF0KFN0YXRUeXBlLlJYX0RJU0NBUkRfU01GX1VOS05PV05fRUxFTUVOVCk7XG4gICAgfVxuICAgIExPR19JTkZPKGBEcm9wIG1lc3NhZ2Ugd2l0aCB1bmtub3duIHByb3RvY29sIDB4JHtmb3JtYXRIZXhTdHJpbmcoaGVhZGVyLnNtZl9wcm90b2NvbCl9YCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIGEgc2Vzc2lvbiBzdGF0aXN0aWNcbiAgICpcbiAgICogQHBhcmFtIHtTdGF0VHlwZX0gc3RhdFR5cGUgVGhlIGtleSB0byBpbmNyZW1lbnRcbiAgICogQHBhcmFtIHs/TnVtYmVyfSB2YWx1ZSBUaGUgYW1vdW50IHRvIGluY3JlbWVudCB0aGUgdmFsdWUgYnlcbiAgICogQHJldHVybnMgez9OdW1iZXJ9IFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzdGF0aXN0aWNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluY1N0YXQoc3RhdFR5cGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzID8gdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MuaW5jU3RhdChzdGF0VHlwZSwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0VHJhbnNwb3J0KCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBjb25zdCBob3N0ID0gdGhpcy5fY3VycmVudEhvc3Q7XG4gICAgTE9HX0RFQlVHKGBDcmVhdGluZyB0cmFuc3BvcnQgc2Vzc2lvbiAke2hvc3R9YCk7XG4gICAgdGhpcy5fa2FTdGF0cyA9IHsgbGFzdE1zZ1dyaXR0ZW46IDAsIGxhc3RCeXRlc1dyaXR0ZW46IDAgfTtcblxuICAgIHRoaXMuX3NtZkNsaWVudCA9IG5ldyBUcmFuc3BvcnRMaWIuU01GQ2xpZW50KFxuICAgICAgcnhEYXRhID0+IHRoaXMuaGFuZGxlU01GTWVzc2FnZShyeERhdGEpLFxuICAgICAgcnhFcnJvciA9PiB0aGlzLmhhbmRsZVNNRlBhcnNlRXJyb3IocnhFcnJvciksXG4gICAgICB0aGlzXG4gICAgKTtcblxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IFRyYW5zcG9ydExpYi5UcmFuc3BvcnRGYWN0b3J5LmNyZWF0ZVRyYW5zcG9ydChcbiAgICAgIGhvc3QsXG4gICAgICB0cmFuc3BvcnRFdmVudCA9PiB0aGlzLmhhbmRsZVRyYW5zcG9ydEV2ZW50KHRyYW5zcG9ydEV2ZW50KSxcbiAgICAgIHRoaXMuX3NtZkNsaWVudCxcbiAgICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLmNsb25lKCksXG4gICAgICAoKSA9PiB0aGlzLnNlc3Npb25JZEhleFxuICAgICk7XG4gICAgdGhpcy5pbmplY3RUcmFuc3BvcnRJbnRlcmNlcHRvcih0aGlzLl90cmFuc3BvcnRJbnRlcmNlcHRvcik7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFsbHMgYSB0cmFuc3BvcnQgaW50ZXJjZXB0b3IgZm9yIHRoZSBjdXJyZW50IGFuZCBhbnkgZnV0dXJlIHRyYW5zcG9ydHMuXG4gICAqXG4gICAqIFRoZSBvYmplY3QgbWV0aG9kcyAuaW5zdGFsbGVkKGluc3RhbmNlKSBhbmQgLnJlbW92ZWQoaW5zdGFuY2UpIHdpbGwgYmUgY2FsbGVkIGlmIHByZXNlbnQsIHdpdGhcbiAgICogdGhlIHRyYW5zcG9ydCBpbnN0YW5jZSBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogVG8gc3RvcCB1c2luZyB0cmFuc3BvcnQgaW50ZXJjZXB0b3JzLCBzdXBwbHkgYSBudWxsIGludGVyY2VwdG9yIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW50ZXJjZXB0b3IgQW4gb2JqZWN0IGdpdmVuIGFjY2VzcyB0byB0aGUgaW50ZXJuYWxzIG9mIHRoZSB0cmFuc3BvcnQgaW5zdGFuY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmplY3RUcmFuc3BvcnRJbnRlcmNlcHRvcihpbnRlcmNlcHRvcikge1xuICAgIHRoaXMuX3RyYW5zcG9ydEludGVyY2VwdG9yID0gaW50ZXJjZXB0b3I7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LnNldEludGVyY2VwdG9yKGludGVyY2VwdG9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBmcm9tIGtlZXAgYWxpdmUgc2NoZWR1bGVkIHRhc2tcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGtlZXBBbGl2ZVRpbWVvdXQoKSB7XG4gICAgY29uc3QgeyBMT0dfVFJBQ0UsIExPR19ERUJVRywgTE9HX0lORk8gfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19UUkFDRSgnS2VlcEFsaXZlIHRpbWVvdXQnKTtcblxuICAgIC8vIHNlc3Npb24gaXMgaW4gY29ubmVjdGVkIHN0YXRlIGJ1dCBoYXNuJ3QgcmVjZWl2ZWQga2VlcCBhbGl2ZSByZXNwb25zZVxuICAgIC8vIExlc3MgdGhhbiBvciBlcXVhbCB0byBiZWNhdXNlIHRoaXMgaXMgdGhlIG51bWJlciBvZiAqYWxyZWFkeSBzZW50KiBLQXNcbiAgICBpZiAodGhpcy5fa2VlcEFsaXZlQ291bnRlciA+PSB0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5rZWVwQWxpdmVJbnRlcnZhbHNMaW1pdCkge1xuICAgICAgTE9HX0lORk8oYEV4Y2VlZCBtYXhpbXVtIGtlZXAgYWxpdmUgaW50ZXJ2YWxzIGxpbWl0ICR7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMua2VlcEFsaXZlSW50ZXJ2YWxzTGltaXR9YCk7XG4gICAgICAvLyBzdG9wIHRpbWVyc1xuICAgICAgTE9HX0RFQlVHKCdTdG9wIGtlZXAgYWxpdmUgdGltZXInKTtcbiAgICAgIGlmICh0aGlzLl9rZWVwQWxpdmVUaW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2tlZXBBbGl2ZVRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hhbmdlIHNlc3Npb24gc3RhdGVcbiAgICAgIHJldHVybiB0aGlzLmVycm9ySW5Gc20oJ0V4Y2VlZCBtYXhpbXVtIGtlZXAgYWxpdmUgaW50ZXJ2YWxzIGxpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLktFRVBfQUxJVkVfRkFJTFVSRSk7XG4gICAgfVxuXG4gICAgTE9HX1RSQUNFKCdBYm91dCB0byBzZW5kIGtlZXAgYWxpdmUnKTtcblxuICAgIGNvbnN0IGNsaWVudFN0YXRzID0gdGhpcy5fdHJhbnNwb3J0LmdldENsaWVudFN0YXRzKCk7XG4gICAgY29uc3QgcHJlc3RhdE1zZ1dyaXR0ZW4gPSBjbGllbnRTdGF0cy5tc2dXcml0dGVuO1xuICAgIGNvbnN0IHByZXN0YXRCeXRlc1dyaXR0ZW4gPSBjbGllbnRTdGF0cy5ieXRlc1dyaXR0ZW47XG5cbiAgICBjb25zdCBrYU1zZyA9IG5ldyBTTUZMaWIuS2VlcEFsaXZlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHJldHVybkNvZGUgPSB0aGlzLnNlbmQoa2FNc2csIG51bGwsIHRydWUpO1xuICAgIGlmIChyZXR1cm5Db2RlICE9PSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgLypcbiAgICAgICAqIFRyYW5zcG9ydFJldHVybkNvZGUuTk9fU1BBQ0UgaXMgbm90IHBvc3NpYmxlLlxuICAgICAgICogU2VuZCBpcyBjYWxsZWQgd2l0aCB0aGUgZm9yY2VBbGxvd0VucXVldWUgcGFyYW1ldGVyLlxuICAgICAgICogU28gd2hhdGV2ZXIgZXJyb3IgaXMgcmV0dXJuZWQgaXMgZmF0YWxcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHRoaXMuZXJyb3JJbkZzbSgnQ2Fubm90IHNlbmQga2VlcCBhbGl2ZSBtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLktFRVBfQUxJVkVfRkFJTFVSRSk7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byBhdm9pZCBpbmNyZW1lbnRpbmcgdGhlIEtBIGNvdW50ZXIgaWYgd2UncmUgaW4gdGhlIHByb2Nlc3Mgb2ZcbiAgICAvLyBzZW5kaW5nIGEgaHVnZSBtZXNzYWdlIGFuZCB3ZSd2ZSBoYWQgbm8gb3Bwb3J0dW5pdHkgdG8gd3JpdGUgYSBLQSBtZXNzYWdlLlxuICAgIC8vIERldGVjdGlvbjogbGFzdCBLQSdzIHNuYXBzaG90IG9mIG1lc3NhZ2VzIHdyaXR0ZW4gaXMgdW5jaGFuZ2VkLCBidXQgbnVtYmVyIG9mIGJ5dGVzXG4gICAgLy8gd3JpdHRlbiBoYXMgZ29uZSB1cC5cbiAgICBpZiAodGhpcy5fa2FTdGF0cy5sYXN0TXNnV3JpdHRlbiA9PT0gcHJlc3RhdE1zZ1dyaXR0ZW4gJiZcbiAgICAgIHRoaXMuX2thU3RhdHMubGFzdEJ5dGVzV3JpdHRlbiA8IHByZXN0YXRCeXRlc1dyaXR0ZW4pIHtcbiAgICAgIExPR19ERUJVRygnS2VlcCBhbGl2ZSBzZW50JyxcbiAgICAgICAgICAgICAgICAnTm90IGluY3JlbWVudGluZyBrZWVwIGFsaXZlIGNvdW50ZXIgZHVlIHRvIGxhcmdlIG1lc3NhZ2Ugc2VuZCcsXG4gICAgICAgICAgICAgICAgYEtBIGNvdW50ID0gJHt0aGlzLl9rZWVwQWxpdmVDb3VudGVyfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2tlZXBBbGl2ZUNvdW50ZXIrKztcbiAgICAgIExPR19UUkFDRShgTGFzdCBtZXNzYWdlIHdyaXR0ZW46ICR7dGhpcy5fa2FTdGF0cy5sYXN0TXNnV3JpdHRlbn1gKTtcbiAgICAgIExPR19UUkFDRShgTGFzdCBieXRlcyB3cml0dGVuOiAke3RoaXMuX2thU3RhdHMubGFzdEJ5dGVzV3JpdHRlbn1gKTtcbiAgICAgIExPR19UUkFDRShgS2VlcCBhbGl2ZSBzZW50LCBpbmNyZW1lbnQga2VlcCBhbGl2ZSBjb3VudGVyLCBrZWVwIGFsaXZlIGNvdW50ID0gJHtcbiAgICAgICAgdGhpcy5fa2VlcEFsaXZlQ291bnRlcn1gKTtcbiAgICB9XG4gICAgdGhpcy5fa2FTdGF0cy5sYXN0Qnl0ZXNXcml0dGVuID0gY2xpZW50U3RhdHMuYnl0ZXNXcml0dGVuO1xuICAgIHRoaXMuX2thU3RhdHMubGFzdE1zZ1dyaXR0ZW4gPSBjbGllbnRTdGF0cy5tc2dXcml0dGVuO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZXMgYSBtZXNzYWdlIGZvciBzZW5kaW5nIGFuZCB0aGVuIGludm9rZSB0aGUgdHJhbnNwb3J0XG4gICAqIHNlbmQgbWV0aG9kLiBGb3IgZ3VhcmFudGVlZCBtZXNzYWdlcywgcGFzcyB0aGUgdHJhbnNwb3J0IHNlbmRcbiAgICogbWV0aG9kIHRvIHRoZSBwdWJsaXNoZXIgc28gaXQgY2FuIGJlIGludm9rZWQgZnJvbSB0aGVyZSBhbmQgZXJyb3JzXG4gICAqIGhhbmRsZWQgd2l0aGluIHRoZSBwdWJsaXNoZXIgRlNNLlxuICAgKiBAcGFyYW0ge0Jhc2VNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHByZXBhcmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlQW5kU2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgbGV0IHJldHVybkNvZGU7XG4gICAgICAvLyBEZWxlZ2F0ZSBtZXNzYWdlIHByZXBhcmF0aW9uIHdoZXJlIGFwcHJvcHJpYXRlXG4gICAgICBjb25zdCBkZWxpdmVyeU1vZGUgPSBtZXNzYWdlLmdldERlbGl2ZXJ5TW9kZSgpO1xuICAgICAgc3dpdGNoIChkZWxpdmVyeU1vZGUpIHtcblxuICAgICAgICBjYXNlIE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLkRJUkVDVDpcbiAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICAgIHJldHVybkNvZGUgPSB0aGlzLnNlbmRUb1RyYW5zcG9ydChtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlQ6XG4gICAgICAgIGNhc2UgTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuTk9OX1BFUlNJU1RFTlQ6XG4gICAgICAgICAgaWYgKCF0aGlzLl9kZWZhdWx0UHVibGlzaGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZWFzb24gPSB0aGlzLl9zZXNzaW9uLmFkTG9jYWxseURpc2FibGVkXG4gICAgICAgICAgICAgICAgPyAnbG9jYWxseSBkaXNhYmxlZCdcbiAgICAgICAgICAgICAgICA6ICdyZW1vdGVseSB1bnN1cHBvcnRlZCc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ1Nlc3Npb24gZG9lcyBub3QgcHJvdmlkZSBHdWFyYW50ZWVkIE1lc3NhZ2UgUHVibGlzaCBjYXBhYmlsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5HTV9VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nbVNlbmREaXNhbGxvd2VkKSB0aGlzLl9nbVNlbmREaXNhbGxvd2VkKCk7IC8vIHRocm93cyBpZiBwcmVzZW50XG4gICAgICAgICAgICByZXR1cm5Db2RlID0gdGhpcy5fZGVmYXVsdFB1Ymxpc2hlci5wcmVwYXJlQWRNZXNzYWdlQW5kU2VuZChtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IHsgTE9HX0VSUk9SIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgICBMT0dfRVJST1IoJ1VuaGFuZGxlZCBtZXNzYWdlIGRlbGl2ZXJ5IG1vZGUnLCBNZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5kZXNjcmliZShkZWxpdmVyeU1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuQ29kZSAhPT0gVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgICAgaWYgKHJldHVybkNvZGUgPT09IFRyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLk5PX1NQQUNFKSB7XG4gICAgICAgICAgLy8gTXVzdCBiZSBESVJFQ1QgbWVzc2FnZSBiZWNhdXNlIHRoZSBQdWJsaXNoZXIgaGFuZGxlcyBOT19TUEFDRSByZXR1cm5Db2RlXG4gICAgICAgICAgLy8gaW50ZXJuYWxseVxuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignQ2Fubm90IHNlbmQgbWVzc2FnZSAtIG5vIHNwYWNlIGluIHRyYW5zcG9ydCcsXG4gICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5TVUZGSUNJRU5UX1NQQUNFLFxuICAgICAgICAgICAgVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuZGVzY3JpYmUocmV0dXJuQ29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGZhdGFsIHNlc3Npb24gZXJyb3JcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50RXJyb3IobmV3IE9wZXJhdGlvbkVycm9yKCdDYW5ub3Qgc2VuZCBtZXNzYWdlJyxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTixcbiAgICAgICAgICAgIFRyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLmRlc2NyaWJlKHJldHVybkNvZGUpKSk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KG5ldyBTZXNzaW9uRlNNRXZlbnQoeyBuYW1lOiBTZXNzaW9uRXZlbnROYW1lLkVYQ0VQVElPTiB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgR3VhcmFudGVlZEZsb3dDb250cm9sbGVkUmVsaWVmKCkge1xuICAgIGlmICh0aGlzLl9kZWZhdWx0UHVibGlzaGVyKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0UHVibGlzaGVyLnByb2Nlc3NGU01FdmVudChcbiAgICAgICAgbmV3IFB1Ymxpc2hlckxpYi5QdWJsaXNoZXJGU01FdmVudCh7XG4gICAgICAgICAgbmFtZTogUHVibGlzaGVyTGliLlB1Ymxpc2hlckZTTUV2ZW50TmFtZXMuQ0FOX1NFTkQgfSkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhcHBseSBzdWJzY3JpcHRpb25zLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBhbGwgc3Vic2NyaXB0aW9ucyB3ZXJlIHJlYXBwbGllZC4gRmFsc2UgaWYgV09VTERfQkxPQ0suXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWFwcGx5U3Vic2NyaXB0aW9ucygpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG4gICAgY29uc3QgeyBTb2xjbGllbnRGYWN0b3J5OiB7IGNyZWF0ZVRvcGljRGVzdGluYXRpb24gfSB9ID0gU29sY2xpZW50RmFjdG9yeUxpYjtcbiAgICBMT0dfREVCVUcoYFJlYXBwbHlpbmcgc3Vic2NyaXB0aW9ucywgY291bnQ9JHt0aGlzLl9zdWJzY3JpcHRpb25DYWNoZUtleXMubGVuZ3RofWApO1xuICAgIC8vIGFkZCBzdWJzY3JpcHRpb25zIGFuZCBhc2sgZm9yIGNvbmZpcm0gb24gbGFzdCBvbmVcblxuICAgIGlmICghdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVLZXlzKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGtleSBpcyB0aGUgdGhlIHRvcGljIHN0cmluZyAodG9waWMuZ2V0TmFtZSgpKS5cbiAgICAgICAgLy8gc2VuZFN1YnNjcmliZSgpIHJlcXVpcmVzIGEgZGVzdGluYXRpb24sIHNvIHdlIGVuY29kZSBpdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvbiBlbnRyeSB0byByZWFwcGx5U3Vic2NyaXB0aW9ucyB3ZSBhZGRlZCB0aGUgUDJQIHRvcGljIHRvXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbkNhY2hlS2V5cyBidXQgdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBlbnRyeSBpblxuICAgICAgICAvLyBfc3Vic2NyaXB0aW9uQ2FjaGUgc28gd2Ugbm8gbG9uZ2VyIHVzZSB0aGUga2V5IHRvIGluZGV4IHRoYXQgYWN0dWFsXG4gICAgICAgIC8vIGNhY2hlLlxuICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIG5lY2VzYXJ5IHRvIHBhc3MgdGhlIFRvcGljIG9iamVjdCB0byBzZW5kU3Vic2NyaWJlIGluIGFcbiAgICAgICAgLy8gYSBmdXR1cmUgZW5oYW5jZW1lbnQgKHBlcmhhcHMgdG8gcmVtZW1iZXIgZmxhZ3MgbGlrZSByZXF1ZXN0LWNvbmZpcm0pIHRoZW5cbiAgICAgICAgLy8gdGhpcyBsb2dpYyBoZXJlIG5lZWRzIHRvIGJlIHJldmlzaXN0ZWQuXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlS2V5cy5zaGlmdCgpO1xuICAgICAgICBjb25zdCByZXF1ZXN0Q29uZmlybWF0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVLZXlzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgY29uc3QgdG9waWNEZXN0aW5hdGlvbiA9IGNyZWF0ZVRvcGljRGVzdGluYXRpb24oa2V5KTtcbiAgICAgICAgY29uc3QgcmMgPSB0aGlzLnNlbmRTdWJzY3JpYmUodG9waWNEZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENvbmZpcm1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhZFRpbWVvdXRJbk1zZWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgaWYgKHJjICE9PSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgICAgIHRoaXMuZXJyb3JJbkZzbShcbiAgICAgICAgICAgIGBFcnJvciBvY2N1cnJlZCBzZW5kaW5nIHN1YnNjcmlwdGlvbjogJHtUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5kZXNjcmliZShyYyl9YCxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUiAgLy8gVE9ETzogYmV0dGVyIHN1YmNvZGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBPcGVyYXRpb25FcnJvciAmJiBlLnN1YmNvZGUgPT09IEVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0UpIHtcbiAgICAgICAgTE9HX0RFQlVHKCdBcHBseSBzdWJzY3JpcHRpb25zIGJsb2NrZWQgZHVlIHRvIGluc3VmZmljaWVudCBzcGFjZSwgd2FpdCBmb3IgY2FuIGFjY2VwdCBkYXRhIGV2ZW50Jyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3JJbkZzbShgVW5leHBlY3RlZCBleHBlY3Rpb24gb2NjdXJyZWQgd2hpbGUgcmVhcHBseWluZyBzdWJzY3JpcHRpb25zOiAke2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICBlLnN1YmNvZGUgfHwgRXJyb3JTdWJjb2RlLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgIGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTsgICAgLy8gc2VudCBhbGwgc3Vic2NyaXB0aW9uc1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtEZXN0aW5hdGlvbn0gdG9waWMgVGhlIHRvcGljIHRvIHJlbW92ZSBmcm9tIHRoZSBzdWJzY3JpcHRpb24gY2FjaGVcbiAgICogQHJldHVybnMgez9EZXN0aW5hdGlvbn0gVGhlIHZhbHVlIGluIHRoZSBzdWJzY3JpcHRpb24gY2FjaGUgYXQgdGhhdCBrZXlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZUZyb21TdWJzY3JpcHRpb25DYWNoZSh0b3BpYykge1xuICAgIGlmIChDaGVjay5ub3RoaW5nKHRvcGljKSB8fCAhdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHsgTE9HX0RFQlVHLCBMT0dfRVJST1IgfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IGtleSA9ICh0b3BpYyBpbnN0YW5jZW9mIERlc3RpbmF0aW9uKSA/IHRvcGljLm5hbWUgOiB0b3BpYztcbiAgICBMT0dfREVCVUcoYFJlbW92ZSBzdWJzY3JpcHRpb24gJHtrZXl9YCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVba2V5XTtcbiAgICBpZiAoc3ViID09PSB1bmRlZmluZWQgfHwgc3ViID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlW2tleV07XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBMT0dfRVJST1IoYENhbm5vdCByZW1vdmUgc3Vic2NyaXB0aW9uICR7a2V5fWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVDb3VudC0tO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExPR19FUlJPUihgQ2Fubm90IHJlbW92ZSBzdWJzY3JpcHRpb24gJHtrZXl9YCwgZSk7XG4gICAgfVxuICAgIHJldHVybiBzdWI7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgRlNNIHN0YXRlIGFuZCByZWxlYXNlIGFsbCBvYmplY3RzLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgb25jZSBmcm9tXG4gICAqIFNlc3Npb25GU00ub25Jbml0aWFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnJlc2V0U3RhdHMoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZmllbGRzIGFyZSBkaXNwb3NlZCB3aGVuIGRpc2Nvbm5lY3QgaXMgY2FsbGVkXG4gICAgICogYW5kIHJlY3JlYXRlZCB3aGVuIGNvbm5lY3QgaXMgY2FsbGVkIGFnYWluLlxuICAgICAqL1xuICAgIHRoaXMuc2Vzc2lvbklkID0gbnVsbDtcblxuICAgIC8vIE5lZWQgdG8gcmVzY2hlZHVsZSBrZWVwQWxpdmVUaW1lciB3aGVuIHNvbWUgb3RoZXIgd3JpdGUgb3BlcmF0aW9uIGhhcHBlbnNcbiAgICB0aGlzLl9rZWVwQWxpdmVUaW1lciA9IG51bGw7XG4gICAgdGhpcy5yZXNldEtlZXBBbGl2ZUNvdW50ZXIoKTtcbiAgICB0aGlzLl9jb3JyZWxhdGVkUmVxcyA9IHt9O1xuXG4gICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3NtZkNsaWVudCA9IG51bGw7XG4gICAgdGhpcy5fa2FTdGF0cyA9IHsgbGFzdE1zZ1dyaXR0ZW46IDAsIGxhc3RCeXRlc1dyaXR0ZW46IDAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZmllbGRzIGFyZSBkZXN0cm95ZWQgd2hlbiBkaXNwb3NlIGlzIGNhbGxlZFxuICAgICAqIGFuZCBjYW5ub3QgYmUgcmVpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWNoZSA9IG51bGw7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FjaGVLZXlzID0gbnVsbDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWNoZUNvdW50ID0gMDtcbiAgICBpZiAodGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhcHBseVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhY2hlID0ge307XG4gICAgfVxuXG4gICAgLy8gV2hlbiBuZWdvdGlhdGluZyB0aGUgaW5pdGlhbCB0cmFuc3BvcnQsIHdlIGNhbiBmYWlsIGFuZCB0cmFuc3BhcmVudGx5IHJlY29ubmVjdC5cbiAgICAvLyB0aGlzLnJlc2V0VHJhbnNwb3J0UHJvdG9jb2xIYW5kbGVyKCk7XG4gICAgLy8gdGhpcy5fbGFzdEtub3duR29vZFRyYW5zcG9ydCA9IG51bGw7XG5cbiAgICAvLyBldmVudCBhbmQgZXJyb3IgaW5mb3JtYXRpb25cbiAgICB0aGlzLl9ldmVudENvZGUgPSBudWxsO1xuICAgIHRoaXMuX3Jlc3BvbnNlQ29kZSA9IG51bGw7XG4gICAgdGhpcy5ldmVudFRleHQgPSBudWxsO1xuICAgIHRoaXMuZXJyb3JTdWJjb2RlID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50UmVhc29uID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXRLZWVwQWxpdmVDb3VudGVyKCkge1xuICAgIC8vIFJlc2V0IHRoZSBLQSBjb3VudGVyLiBDYWxsZWQgYnkgdGhlIFNNRkNsaWVudCBvbiBlYWNoIFNNRiBjaHVuayByZWNlaXZlZCAod2hldGhlciBmdWxsXG4gICAgLy8gbWVzc2FnZSBvciBub3QpLlxuICAgIHRoaXMuX2tlZXBBbGl2ZUNvdW50ZXIgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/fSBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgcmVzZXRTdGF0cygpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MgPyB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcy5yZXNldFN0YXRzKCkgOiB1bmRlZmluZWQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZSBrZWVwIGFsaXZlIHRhc2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNjaGVkdWxlS2VlcEFsaXZlKCkge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHLCBMT0dfRVJST1IgfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IHsga2VlcEFsaXZlSW50ZXJ2YWxJbk1zZWNzIH0gPSB0aGlzLl9zZXNzaW9uUHJvcGVydGllcztcbiAgICBpZiAoa2VlcEFsaXZlSW50ZXJ2YWxJbk1zZWNzID09PSAwKSB7XG4gICAgICAvLyBLZWVwYWxpdmVzIGRpc2FibGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2tlZXBBbGl2ZVRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2tlZXBBbGl2ZVRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9rZWVwQWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlVGltZW91dCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBMT0dfRVJST1IoJ0Vycm9yIG9jY3VycmVkIGluIGtlZXBBbGl2ZVRpbWVvdXQnLCBlKTtcbiAgICAgIH1cbiAgICB9LCBrZWVwQWxpdmVJbnRlcnZhbEluTXNlY3MpO1xuXG4gICAgTE9HX0RFQlVHKGBDcmVhdGUgS2VlcGFsaXZlIHRpbWVyICR7dGhpcy5fa2VlcEFsaXZlVGltZXJ9YCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIG1ldGhvZCBmb3IgdGhlIHNlc3Npb24gb2JqZWN0IHRvIHVzZSB0byBzZW5kXG4gICAqIG1lc3NhZ2VzIHRvIHRoZSB0cmFuc3BvcnQuICBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseSBieVxuICAgKiB0aGUgRlNNLiAgVGhlIHNlc3Npb24gc2VuZCgpIEFQSSBzaG91bGQgaW52b2tlIHNlbmRUb1RyYW5zcG9ydCgpIGRpcmVjdGx5XG4gICAqIHNvIGVycm9ycyBhcmUgdGhyb3duIGJhY2sgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0VGFyZ2V0PXRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzXSBUaGUgc2VuZGVyIG9mIHRoaXMgbWVzc2FnZSwgZm9yIHN0YXRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFsbG93RW5xdWV1ZT1mYWxzZV0gU2V0IHRvIHRydWUgdG8gZm9yY2UgZW5xdWV1ZWluZyBvZiBjb250cm9sIG1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgUkMgZnJvbSB0aGUgdHJhbnNwb3J0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kKG1lc3NhZ2UsIHN0YXRUYXJnZXQgPSB0aGlzLl9zZXNzaW9uU3RhdGlzdGljcywgZm9yY2VBbGxvd0VucXVldWUgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5zZW5kVG9UcmFuc3BvcnQobWVzc2FnZSwgc3RhdFRhcmdldCwgZm9yY2VBbGxvd0VucXVldWUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgICAvLyBUaGUgc2VuZCBvcGVyYXRpb24gdGhyZXcgKG9yIHdlIHRocmV3IGxvY2FsbHkpLCB3aGljaCBpcyBhbHdheXMgYSBTZXNzaW9uRXhjZXB0aW9uLlxuICAgICAgTE9HX1RSQUNFKGBFcnJvciBzZW5kaW5nIG1lc3NhZ2U6ICR7ZXgubWVzc2FnZX06ICR7ZXguc3RhY2t9YCk7XG4gICAgICB0aGlzLmVycm9ySW5Gc20oYFNlbmQgb3BlcmF0aW9uIGZhaWxlZDogJHtleC5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgZXguc3ViY29kZSB8fCBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5DT05ORUNUSU9OX0VSUk9SO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBtZXRob2QgZm9yIHRoZSBzZXNzaW9uIG9iamVjdCB0byB1c2UgdG8gc2VuZFxuICAgKiBtZXNzYWdlcyB0byB0aGUgdHJhbnNwb3J0LlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0VGFyZ2V0PXRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzXSBUaGUgc2VuZGVyIG9mIHRoaXMgbWVzc2FnZSwgZm9yIHN0YXRzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZUFsbG93RW5xdWV1ZT1mYWxzZV0gU2V0IHRvIHRydWUgdG8gZm9yY2UgZW5xdWV1ZWluZyBvZiBjb250cm9sIG1lc3NhZ2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgUkMgZnJvbSB0aGUgdHJhbnNwb3J0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kVG9UcmFuc3BvcnQobWVzc2FnZSwgc3RhdFRhcmdldCA9IHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzLCBmb3JjZUFsbG93RW5xdWV1ZSA9IGZhbHNlKSB7XG4gICAgbGV0IHJldHVybkNvZGUgPSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5DT05ORUNUSU9OX0VSUk9SO1xuXG4gICAgaWYgKCF0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignVHJhbnNwb3J0IGhhcyBiZWVuIGRlc3Ryb3llZCcsIEVycm9yU3ViY29kZS5JTlRFUk5BTF9FUlJPUik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBTTUZMaWIuQ29kZWMuRW5jb2RlLmVuY29kZUNvbXBvdW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm5Db2RlID0gdGhpcy5fdHJhbnNwb3J0LnNlbmQoY29udGVudCwgZm9yY2VBbGxvd0VucXVldWUpO1xuICAgIHN3aXRjaCAocmV0dXJuQ29kZSkge1xuICAgICAgY2FzZSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5PSzpcbiAgICAgICAgdGhpcy51cGRhdGVUeFN0YXRzKG1lc3NhZ2UsIHN0YXRUYXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuTk9fU1BBQ0U6XG4gICAgICAgIGlmICghZm9yY2VBbGxvd0VucXVldWUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFsbG93ZWQuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIEVsc2UgZmFsbCB0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYFRyYW5zcG9ydCByZXR1cm5lZCAke1RyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLmRlc2NyaWJlKHJldHVybkNvZGUpfWAsXG4gICAgICAgICAgRXJyb3JTdWJjb2RlLklOVEVSTkFMX0VSUk9SKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuQ29kZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgQ2xpZW50Q3RybCBoYW5kc2hha2UsIGNhbGxlZCBmcm9tIHRyYW5zcG9ydFNlc3Npb25FdmVudCBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIFJDIGZyb20gdGhlIHRyYW5zcG9ydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZENsaWVudEN0cmxMb2dpbigpIHtcbiAgICBjb25zdCB7IExPR19ERUJVRyB9ID0gdGhpcy5sb2dnZXI7XG5cbiAgICAvLyBEb24ndCB1c2UgdGhlIGNvcnJlbGF0aW9uIHRhZy4gRm9yIExvZ2luIG9ubHksIHRoZSByb3V0ZXIgd29uJ3QgcmV0dXJuIGl0LlxuICAgIGNvbnN0IGNsaWVudEN0cmxNc2cgPSBTTUZMaWIuQ2xpZW50Q3RybE1lc3NhZ2UuZ2V0TG9naW4odGhpcy5fc2Vzc2lvblByb3BlcnRpZXMpO1xuICAgIGNvbnN0IHJldHVybkNvZGUgPSB0aGlzLnNlbmQoY2xpZW50Q3RybE1zZyk7XG4gICAgaWYgKHJldHVybkNvZGUgIT09IFRyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLk9LKSB7XG4gICAgICB0aGlzLl9yZXNwb25zZUNvZGUgPSBudWxsO1xuICAgICAgdGhpcy5ldmVudFJlYXNvbiA9IG51bGw7XG4gICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICBpZiAocmV0dXJuQ29kZSA9PT0gVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuTk9fU1BBQ0UpIHtcbiAgICAgICAgdGhpcy5ldmVudFRleHQgPSAnQ2Fubm90IHNlbmQgY2xpZW50IGNvbnRyb2wgLSBubyBzcGFjZSBpbiB0cmFuc3BvcnQnO1xuICAgICAgICB0aGlzLmVycm9yU3ViY29kZSA9IEVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMT0dfREVCVUcoYENhbm5vdCBzZW5kIGNsaWVudCBjdHJsLCByZXR1cm4gY29kZSAke1RyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLmRlc2NyaWJlKHJldHVybkNvZGUpfWApO1xuICAgICAgICB0aGlzLmV2ZW50VGV4dCA9ICdDYW5ub3Qgc2VuZCBjbGllbnQgY3RybCc7XG4gICAgICAgIHRoaXMuZXJyb3JTdWJjb2RlID0gRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnF1ZXVlIG91dHN0YW5kaW5nIHJlcXVlc3QsIHVzZSBhIGZha2UgY29ycmVsYXRpb24gdGFnIGZvciBMb2dpbiBvbmx5XG4gICAgICBjb25zdCBjb3JyZWxhdGlvblRhZyA9IFRyYW5zcG9ydExpYi5TTUZDbGllbnQuU01GX0NMSUVOVENUUkxfTE9HSU5fRkFLRV9DT1JSRUxBVElPTlRBRztcbiAgICAgIExPR19ERUJVRyhgVXNpbmcgaW50ZXJuYWxseSBjb3JyZWxhdGlvblRhZz0ke2NvcnJlbGF0aW9uVGFnfSBmb3IgdHJhY2tpbmcgQ2xpZW50Q1RSTCBMb2dpbmApO1xuICAgICAgdGhpcy5lbnF1ZXVlT3V0c3RhbmRpbmdDb3JyZWxhdGVkUmVxKGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ4TXNnT2JqID0+IHRoaXMuaGFuZGxlQ2xpZW50Q3RybFJlc3BvbnNlKHJ4TXNnT2JqKSk7XG5cbiAgICAgIExPR19ERUJVRygnU2VudCBjbGllbnQgY3RybCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuQ29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIHNlbmRpbmcgc3Vic2NyaXB0aW9ucyBmcm9tIFNlc3Npb25Db25uZWN0aW5nIHN0YXRlIChyZWFwcGx5IG9yIFAyUC1pbmJveClcbiAgICpcbiAgICogQHBhcmFtIHtEZXN0aW5hdGlvbn0gdG9waWMgVGhlIHRvcGljIHRvIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVlc3RDb25maXJtYXRpb24gSWYgdHJ1ZSwgZXhwZWN0IGEgcmVwbHkgb24gc3VjY2VzcyBhbHNvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JyZWxhdGlvbktleSBUaGUgY29ycmVsYXRpb24ga2V5IGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVxdWVzdFRpbWVvdXQgVGhlIHRpbWVvdXQgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc3BSZWN2ZENhbGxiYWNrIFRoZSBjYWxsYmFjayBvbiByZXBseSByZWNlaXZlZFxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIFJDIGZyb20gdGhlIHRyYW5zcG9ydFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZFN1YnNjcmliZSh0b3BpYywgcmVxdWVzdENvbmZpcm1hdGlvbiwgY29ycmVsYXRpb25LZXksIHJlcXVlc3RUaW1lb3V0LCByZXNwUmVjdmRDYWxsYmFjaykge1xuICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBhc3NlcnQodG9waWMgaW5zdGFuY2VvZiBEZXN0aW5hdGlvbiwgJ3NlbmRTdWJzY3JpYmUgcmVxdWlyZXMgYSBEZXN0aW5hdGlvbiwgbm90IGEgc3RyaW5nJyk7XG4gICAgTE9HX0RFQlVHKCdTZW5kaW5nIHN1YnNjcmliZTogJywgdG9waWMsIHJlcXVlc3RDb25maXJtYXRpb24sIGNvcnJlbGF0aW9uS2V5KTtcbiAgICBjb25zdCBjb3JyZWxhdGlvblRhZyA9IHRoaXMuZ2V0Q29ycmVsYXRpb25UYWcoKTtcbiAgICBjb25zdCBzbXBNc2cgPSBTTUZMaWIuU01QTWVzc2FnZS5nZXRTdWJzY3JpcHRpb25NZXNzYWdlKGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAvLyBzZXQgYWRkID09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RDb25maXJtYXRpb24pO1xuICAgIGFzc2VydChzbXBNc2cuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24sICdFbmNvZGVkIFNNUCBtZXNzYWdlIHdhcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgcmV0dXJuQ29kZSA9IHRoaXMuc2VuZChzbXBNc2cpO1xuICAgIGlmIChyZXR1cm5Db2RlICE9PSBUcmFuc3BvcnRMaWIuVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgTE9HX0RFQlVHKCdTdWJzY3JpYmUgZmFpbGVkJywgVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuZGVzY3JpYmUocmV0dXJuQ29kZSkpO1xuICAgICAgcmV0dXJuIHJldHVybkNvZGU7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0Q29uZmlybWF0aW9uKSB7XG4gICAgICB0aGlzLmVucXVldWVPdXRzdGFuZGluZ0NvcnJlbGF0ZWRSZXEoXG4gICAgICAgIGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblRpbWVvdXQoY29ycmVsYXRpb25UYWcpLFxuICAgICAgICByZXF1ZXN0VGltZW91dCB8fCB0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5yZWFkVGltZW91dEluTXNlY3MsXG4gICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICByZXNwUmVjdmRDYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5Db2RlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7TXV0YWJsZVNlc3Npb25Qcm9wZXJ0eX0gbXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSBUaGUgcHJvcGVydHkga2V5IHRvIGNoYW5nZVxuICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25LZXkgVGhlIGNvcnJlbGF0aW9uIGtleSBmb3IgdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcXVlc3RUaW1lb3V0IFRoZSB0aW1lb3V0IGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNwUmVjdmRDYWxsYmFjayBUaGUgY2FsbGJhY2sgb24gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1RyYW5zcG9ydFJldHVybkNvZGV9IFRoZSBSQyBmcm9tIHRoZSB0cmFuc3BvcnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRVcGRhdGVQcm9wZXJ0eShtdXRhYmxlU2Vzc2lvblByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgcmVzcFJlY3ZkQ2FsbGJhY2spIHtcbiAgICBjb25zdCBjb3JyZWxhdGlvblRhZyA9IHRoaXMuX3NtZkNsaWVudC5uZXh0Q29ycmVsYXRpb25UYWcoKTtcbiAgICBjb25zdCBzbXBNc2cgPSBTTUZMaWIuQ2xpZW50Q3RybE1lc3NhZ2UuZ2V0VXBkYXRlKG11dGFibGVTZXNzaW9uUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFnKTtcblxuICAgIGNvbnN0IHJldHVybkNvZGUgPSB0aGlzLnNlbmQoc21wTXNnKTtcbiAgICBpZiAocmV0dXJuQ29kZSAhPT0gVHJhbnNwb3J0TGliLlRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgIHJldHVybiByZXR1cm5Db2RlO1xuICAgIH1cblxuICAgIHRoaXMuZW5xdWV1ZU91dHN0YW5kaW5nQ29ycmVsYXRlZFJlcShcbiAgICAgIGNvcnJlbGF0aW9uVGFnLFxuICAgICAgKCkgPT4gdGhpcy5oYW5kbGVVcGRhdGVQcm9wZXJ0eVRpbWVvdXQoY29ycmVsYXRpb25UYWcpLFxuICAgICAgcmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhZFRpbWVvdXRJbk1zZWNzLFxuICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICByZXNwUmVjdmRDYWxsYmFjayk7XG4gICAgcmV0dXJuIHJldHVybkNvZGU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENsaWVudEN0cmxUaW1lcigpIHtcbiAgICB0aGlzLmNsZWFyQ2xpZW50Q3RybFRpbWVyKCk7XG5cbiAgICB0aGlzLl9jbGllbnRDdHJsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlQ2xpZW50Q3RybFRpbWVvdXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLnRyYW5zcG9ydERvd25ncmFkZVRpbWVvdXRJbk1zZWNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Q29ubmVjdFRpbWVyKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZXIoKTtcbiAgICAvLyBUaGUgaG9zdHMgbGlzdHMgcHJvdmlkZXMgdGhlIHdhaXQgdGltZSBmb3IgaW50ZXItaG9zdCB0aW1lb3V0cy5cbiAgICAvLyBUaGlzIHRpbWVvdXQgaXMgZm9yIHRoZSBlbnRpcmUgbGlzdC5cbiAgICAvLyBUT0RPOiBjb25uZWN0VGltZW91dEluTXNlY3Mgd2FzIHNwZWNpZmljYWxseSBkZXNjcmliZWQgYXMgdGhlIHRpbWVvdXQgZm9yIFwiYSBnaXZlbiBob3N0XCIsXG4gICAgLy8gd2l0aCBhIHRpbWVvdXQgb2YgOCBzZWNvbmRzLCB3aGljaCBhcHBlYXJzIGluYXBwcm9wcmlhdGUgZ2l2ZW4gaXRzIHVzZSBoZXJlLlxuICAgIHRoaXMuX2Nvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oYW5kbGVDb25uZWN0VGltZW91dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuY29ubmVjdFRpbWVvdXRJbk1zZWNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlcnJvciBleGl0IGluZm9ybWF0aW9uIGZvciB0aGUgRlNNLlxuICAgKlxuICAgKiBUaGlzIGFwcGxpZXMga2V5LXZhbHVlIHBhaXJzIGZyb20gcHJvcGVydGllcyB0byB0aGUgY3VycmVudCBlcnJvciBvYmplY3QsXG4gICAqIGJ1dCBkb2VzIG5vdCBhbGxvdyBvdmVyd3JpdGluZyBhbmQgZG9lcyBub3QgYWxsb3cgYXNzaWdubWVudCBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG4gICAqXG4gICAqIE9ubHkgdGhlIGZvbGxvd2luZyBmaWVsZHMgYXJlIHJlbGV2YW50LCBhbnkgb3RoZXIgZmllbGRzIHRyYW5zZmVycmVkIHRvIGN1cnJlbnRFcnJvciBieSB0aGlzXG4gICAqIG1ldGhvZCBhcmUgZXZlbnR1YWxseSBpZ25vcmVkOlxuICAgKiAgICAqIGV2ZW50VGV4dFxuICAgKiAgICAqIHJlc3BvbnNlQ29kZVxuICAgKiAgICAqIGVycm9yU3ViY29kZVxuICAgKiAgICAqIGV2ZW50UmVhc29uXG4gICAqXG4gICAqIFNlZSBTZXNzaW9uQ29ubmVjdGluZyBleGl0UG9pbnQgJ2Vycm9yRXhpdCcuIFRoaXMgaXMgdGhlIG9ubHkgcGxhY2UgdGhlIGluZm9ybWF0aW9uIGluXG4gICAqIGN1cnJlbnRFcnJvciBpcyBleHRyYWN0ZWQuXG4gICAqXG4gICAqIENvdWxkIGJlIGltcGxlbWVudGVkIGFzIGBcbiAgICogdGhpcy5fY3VycmVudEVycm9yID0gT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyKHByb3BlcnRpZXMpLCB0aGlzLl9jdXJyZW50RXJyb3IpXG4gICAqIGBcbiAgICogd2hlcmUgYGZpbHRlcmAgaXMgYSBrZXktdmFsdWUgZmlsdGVyIHRoYXQgd29ya3MgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZFxuICAgKi9cbiAgc2V0Q3VycmVudEVycm9yKHNvdXJjZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2N1cnJlbnRFcnJvciB8fCB7fTtcbiAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSA9PT0gbnVsbCB8fCBzb3VyY2Vba2V5XSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGFyZ2V0W2tleV0gIT09IG51bGwgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBMT0dfVFJBQ0UoYEF0dGVtcHQgdG8gb3ZlcndyaXRlIHByb3BlcnR5IHtrZXk9JHtrZXl9LCBjdXJyZW50IHZhbHVlPSR7dGFyZ2V0W2tleV19LCBpbmNvbWluZyB2YWx1ZT0ke3NvdXJjZVtrZXldfX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRFcnJvciA9IHRhcmdldDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgcmVxdWVzdCBvbiBiZWhhbGYgb2YgdGhlIEFQSS5cbiAgICogQHBhcmFtIHtEZXN0aW5hdGlvbn0gc3ViamVjdCBUaGUgdGFyZ2V0IGZvciB0aGUgdXBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWVzdENvbmZpcm1hdGlvbiBSZXF1ZXN0IGEgc3VjY2VzcyBtZXNzYWdlIGlmIHRydWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvcnJlbGF0aW9uS2V5IFRoZSBjb3JyZWxhdGlvbiBrZXkgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXF1ZXN0VGltZW91dCBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtTZXNzaW9uUmVxdWVzdFR5cGV9IHJlcXVlc3RUeXBlIFRoZSByZXF1ZXN0IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzcFJlY3ZkQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIG9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgUkMgZnJvbSB0aGUgdHJhbnNwb3J0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdWJzY3JpcHRpb25VcGRhdGUoc3ViamVjdCxcbiAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RDb25maXJtYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICByZXNwUmVjdmRDYWxsYmFjaykge1xuICAgIGNvbnN0IHRpbWVvdXRNc2cgPVxuICAgICAgU3Vic2NyaXB0aW9uVXBkYXRlVGltZW91dE1lc3NhZ2VzW3JlcXVlc3RUeXBlXSB8fFxuICAgICAgU3Vic2NyaXB0aW9uVXBkYXRlVGltZW91dE1lc3NhZ2VzLmRlZmF1bHQ7XG4gICAgY29uc3QgaXNTTVAgPSAocmVxdWVzdFR5cGUgIT09IFNlc3Npb25SZXF1ZXN0VHlwZS5SRU1PVkVfRFRFX1NVQlNDUklQVElPTik7XG4gICAgY29uc3QgYWRkID0gKHJlcXVlc3RUeXBlID09PSBTZXNzaW9uUmVxdWVzdFR5cGUuQUREX1NVQlNDUklQVElPTiB8fFxuICAgICAgcmVxdWVzdFR5cGUgPT09IFNlc3Npb25SZXF1ZXN0VHlwZS5BRERfUDJQSU5CT1gpO1xuICAgIGNvbnN0IGNvcnJlbGF0aW9uVGFnID0gdGhpcy5nZXRDb3JyZWxhdGlvblRhZygpO1xuXG4gICAgY29uc3QgZ2VuZXJhdGVNZXNzYWdlID0gaXNTTVBcbiAgICAgID8gU01GTGliLlNNUE1lc3NhZ2UuZ2V0U3Vic2NyaXB0aW9uTWVzc2FnZVxuICAgICAgOiBTTUZMaWIuQWRQcm90b2NvbE1lc3NhZ2UuZ2V0RFRFVW5zdWJzY3JpYmVNZXNzYWdlO1xuICAgIGNvbnN0IG1zZyA9IGdlbmVyYXRlTWVzc2FnZShjb3JyZWxhdGlvblRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q29uZmlybWF0aW9uKTtcbiAgICBjb25zdCByZXR1cm5Db2RlID0gdGhpcy5zZW5kKG1zZyk7XG4gICAgaWYgKHJldHVybkNvZGUgIT09IFRyYW5zcG9ydExpYi5UcmFuc3BvcnRSZXR1cm5Db2RlLk9LKSB7XG4gICAgICByZXR1cm4gcmV0dXJuQ29kZTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdENvbmZpcm1hdGlvbikge1xuICAgICAgdGhpcy5lbnF1ZXVlT3V0c3RhbmRpbmdDb3JyZWxhdGVkUmVxKFxuICAgICAgICBjb3JyZWxhdGlvblRhZyxcbiAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVBcGlTdWJzY3JpcHRpb25UaW1lb3V0KGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dE1zZyksXG4gICAgICAgIHJlcXVlc3RUaW1lb3V0IHx8IHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLnJlYWRUaW1lb3V0SW5Nc2VjcyxcbiAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgIHJlc3BSZWN2ZENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RUeXBlID09PSBTZXNzaW9uUmVxdWVzdFR5cGUuQUREX1NVQlNDUklQVElPTiAmJlxuICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhcHBseVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuYWRkVG9TdWJzY3JpcHRpb25DYWNoZShzdWJqZWN0KTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBTZXNzaW9uUmVxdWVzdFR5cGUuUkVNT1ZFX1NVQlNDUklQVElPTiAmJlxuICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhcHBseVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbVN1YnNjcmlwdGlvbkNhY2hlKHN1YmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuQ29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2VNZXNzYWdlfE1lc3NhZ2V9IHNtZk1lc3NhZ2UgVGhlIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICogQHBhcmFtIHtTdGF0c30gW3RhcmdldF0gVGhlIHN0YXRpc3RpY3MgdGFyZ2V0IHRvIHVwZGF0ZSwgZGVmYXVsdCBpcyBzZXNzaW9uIHN0YXRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVSeFN0YXRzKHNtZk1lc3NhZ2UsIHRhcmdldCA9IHRoaXMuX3Nlc3Npb25TdGF0aXN0aWNzKSB7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc21mSGVhZGVyID0gc21mTWVzc2FnZS5zbWZIZWFkZXI7XG4gICAgaWYgKCFzbWZIZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsaXZlcnlNb2RlID0gc21mSGVhZGVyLnBtX2RlbGl2ZXJ5bW9kZSB8fCAwO1xuICAgIGNvbnN0IG1zZ1N0YXRLZXkgPSBTVEFUX1JYX0JZTU9ERV9NU0dTW2RlbGl2ZXJ5TW9kZV07XG4gICAgY29uc3QgYnl0ZXNTdGF0S2V5ID0gU1RBVF9SWF9CWU1PREVfQllURVNbZGVsaXZlcnlNb2RlXTtcbiAgICBjb25zdCBtc2dMZW5ndGggPSBzbWZIZWFkZXIubWVzc2FnZUxlbmd0aDtcblxuICAgIHN3aXRjaCAoc21mSGVhZGVyLnNtZl9wcm90b2NvbCkge1xuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuVFJNU0c6XG4gICAgICAgIGlmIChzbWZIZWFkZXIucG1fcmVzcGNvZGUgPT09IDApIHtcbiAgICAgICAgICB0YXJnZXQuaW5jU3RhdChTdGF0VHlwZS5SWF9UT1RBTF9EQVRBX01TR1MpO1xuICAgICAgICAgIHRhcmdldC5pbmNTdGF0KG1zZ1N0YXRLZXkpO1xuICAgICAgICAgIHRhcmdldC5pbmNTdGF0KFN0YXRUeXBlLlJYX1RPVEFMX0RBVEFfQllURVMsIG1zZ0xlbmd0aCk7XG4gICAgICAgICAgdGFyZ2V0LmluY1N0YXQoYnl0ZXNTdGF0S2V5LCBtc2dMZW5ndGgpO1xuICAgICAgICAgIGlmIChzbWZIZWFkZXIuc21mX2RpKSB7XG4gICAgICAgICAgICB0YXJnZXQuaW5jU3RhdChTdGF0VHlwZS5SWF9ESVNDQVJEX01TR19JTkRJQ0FUSU9OKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5DTElFTlRDVFJMOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuU01QOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuS0VFUEFMSVZFOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuS0VFUEFMSVZFVjI6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5BRENUUkw6XG4gICAgICAgIHRhcmdldC5pbmNTdGF0KFN0YXRUeXBlLlJYX0NPTlRST0xfTVNHUyk7XG4gICAgICAgIHRhcmdldC5pbmNTdGF0KFN0YXRUeXBlLlJYX0NPTlRST0xfQllURVMsIG1zZ0xlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBAcGFyYW0ge0Jhc2VNZXNzYWdlfE1lc3NhZ2V9IHNtZk1lc3NhZ2UgVGhlIG1lc3NhZ2Ugc2VudFxuICAqIEBwYXJhbSB7U3RhdHN9IFt0YXJnZXRdIFRoZSBzdGF0aXN0aWNzIHRhcmdldCB0byB1cGRhdGUsIGRlZmF1bHQgaXMgc2Vzc2lvbiBzdGF0c1xuICAqIEBwcml2YXRlXG4gICovXG4gIHVwZGF0ZVR4U3RhdHMoc21mTWVzc2FnZSwgdGFyZ2V0ID0gdGhpcy5fc2Vzc2lvblN0YXRpc3RpY3MpIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc21mTWVzc2FnZS5nZXRSZXBseVRvICE9PSB1bmRlZmluZWQgJiYgc21mTWVzc2FnZS5nZXRSZXBseVRvKCkpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgdGFyZ2V0LmluY1N0YXQoU3RhdFR5cGUuVFhfUkVRVUVTVF9TRU5UKTtcbiAgICB9XG4vLyBUT0RPRDogIFdoeSBkbyB3ZSBoYXZlIHRvIGdldCBTbWZIZWFkZXI/IENhbid0IHdlIGNhbiBzbWZNZXNzYWdlLmdldERlbGl2ZXJ5TW9kZSgpO1xuICAgIGNvbnN0IHNtZkhlYWRlciA9IHNtZk1lc3NhZ2Uuc21mSGVhZGVyO1xuICAgIGlmICghc21mSGVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVsaXZlcnlNb2RlID0gc21mSGVhZGVyLnBtX2RlbGl2ZXJ5bW9kZSB8fCAwO1xuICAgIGxldCBtc2dTdGF0S2V5ID0gU1RBVF9UWF9CWU1PREVfTVNHU1tkZWxpdmVyeU1vZGVdO1xuICAgIGxldCBieXRlc1N0YXRLZXkgPSBTVEFUX1RYX0JZTU9ERV9CWVRFU1tkZWxpdmVyeU1vZGVdO1xuICAgIC8vXG4gICAgLy8gSWYgdGhpcyBpcyBhIEd1YXJhbnRlZWQgTWVzc2FnZSB3ZSBtYXkgbmVlZCB0byBmdXJ0aGVyIHJlZmluZSB0aGUgc3RhdHMgYnkgdGhlIHJlZGVsaXZlcmVkXG4gICAgLy8gc3RhdHVzXG4gICAgaWYgKGRlbGl2ZXJ5TW9kZSAhPT0gTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUKSB7XG4gICAgICBpZiAoc21mTWVzc2FnZS5pc1JlZGVsaXZlcmVkKCkpIHtcbiAgICAgICAgbXNnU3RhdEtleSA9IFNUQVRfVFhfQllNT0RFX1JFREVMSVZFUkVEW2RlbGl2ZXJ5TW9kZV07XG4gICAgICAgIGJ5dGVzU3RhdEtleSA9IFNUQVRfVFhfQllNT0RFX0JZVEVTX1JFREVMSVZFUkVEW2RlbGl2ZXJ5TW9kZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1zZ0xlbmd0aCA9IHNtZkhlYWRlci5tZXNzYWdlTGVuZ3RoO1xuXG4gICAgc3dpdGNoIChzbWZIZWFkZXIuc21mX3Byb3RvY29sKSB7XG4gICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5UUk1TRzpcbiAgICAgICAgdGFyZ2V0LmluY1N0YXQobXNnU3RhdEtleSk7XG4gICAgICAgIHRhcmdldC5pbmNTdGF0KGJ5dGVzU3RhdEtleSwgbXNnTGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5DTElFTlRDVFJMOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuU01QOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuS0VFUEFMSVZFOlxuICAgICAgY2FzZSBTTUZMaWIuU01GUHJvdG9jb2wuS0VFUEFMSVZFVjI6XG4gICAgICBjYXNlIFNNRkxpYi5TTUZQcm90b2NvbC5BRENUUkw6XG4gICAgICAgIHRhcmdldC5pbmNTdGF0KFN0YXRUeXBlLlRYX0NPTlRST0xfTVNHUyk7XG4gICAgICAgIHRhcmdldC5pbmNTdGF0KFN0YXRUeXBlLlRYX0NPTlRST0xfQllURVMsIG1zZ0xlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDbGllbnRDdHJsTWVzc2FnZX0gY2xpZW50Q3RybFJlc3BNc2cgVGhlIGNsaWVudCBjb250cm9sIG1lc3NhZ2Ugd2l0aCBwcm9wc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmVhZG9ubHlTZXNzaW9uUHJvcHMoY2xpZW50Q3RybFJlc3BNc2cpIHtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzOyAvLyBNb2RpZnkgc2Vzc2lvbiBwcm9wZXJ0aWVzIGluIHBsYWNlXG5cbiAgICBwcm9wcy5fc2V0VnBuTmFtZUluVXNlKGNsaWVudEN0cmxSZXNwTXNnLmdldFZwbk5hbWVJblVzZVZhbHVlKCkgfHwgJycpO1xuICAgIGNvbnN0IG9sZFZpcnR1YWxSb3V0ZXJOYW1lID0gcHJvcHMudmlydHVhbFJvdXRlck5hbWU7XG4gICAgY29uc3QgbmV3VmlydHVhbFJvdXRlck5hbWUgPSBjbGllbnRDdHJsUmVzcE1zZy5nZXRWcmlkSW5Vc2VWYWx1ZSgpIHx8ICcnO1xuICAgIHByb3BzLl9zZXRWaXJ0dWFsUm91dGVyTmFtZShuZXdWaXJ0dWFsUm91dGVyTmFtZSk7XG4gICAgaWYgKG9sZFZpcnR1YWxSb3V0ZXJOYW1lICE9PSAnJyAmJiBvbGRWaXJ0dWFsUm91dGVyTmFtZSAhPT0gbmV3VmlydHVhbFJvdXRlck5hbWUpIHtcbiAgICAgIHRoaXMuaGFuZGxlVmlydHVhbFJvdXRlck5hbWVDaGFuZ2Uob2xkVmlydHVhbFJvdXRlck5hbWUsIG5ld1ZpcnR1YWxSb3V0ZXJOYW1lKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIGxvZ2luIHJlc3BvbnNlIHNob3VsZCBhbHdheXMgY29udGFpbiBhIFAyUCB0b3BpYyBmb3IgdGhpcyBjbGllbnRcbiAgICAvLyBuYW1lLiBJZiBpdCBkb2Vzbid0IHRoYXQncyBhbiBlcnJvciAoYW5kIHdlIHN0b3JlIFwiXCIpLlxuICAgIHByb3BzLl9zZXRQMnBJbmJveEJhc2UoY2xpZW50Q3RybFJlc3BNc2cuZ2V0UDJQVG9waWNWYWx1ZSgpIHx8ICcnKTtcbiAgICBwcm9wcy5fc2V0UDJwSW5ib3hJblVzZShQMlBVdGlsLmdldFAyUEluYm94VG9waWMocHJvcHMucDJwSW5ib3hCYXNlKSk7XG4gICAgdGhpcy5fc2Vzc2lvbi51cGRhdGVDYXBhYmlsaXRpZXMoY2xpZW50Q3RybFJlc3BNc2cuZ2V0Um91dGVyQ2FwYWJpbGl0aWVzKCkpO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCBjYWNoZSBhIGd1YXJkIGZvciBHTSBzZW5kaW5nLlxuICAgIGNvbnN0IGdtQ2FwID0gdGhpcy5fc2Vzc2lvbi5fZ2V0Q2FwYWJpbGl0eShDYXBhYmlsaXR5VHlwZS5HVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSCk7XG4gICAgdGhpcy5fZ21TZW5kRGlzYWxsb3dlZCA9ICh0eXBlb2YgZ21DYXAgPT09ICdib29sZWFuJyAmJiAhZ21DYXApXG4gICAgICA/ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFxuICAgICAgICAnU2VuZGluZyBndWFyYW50ZWVkIG1lc3NhZ2UgaXMgbm90IGFsbG93ZWQgYnkgcm91dGVyIGZvciB0aGlzIGNsaWVudCcsXG4gICAgICAgIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTixcbiAgICAgICAgbnVsbCk7XG4gICAgICB9XG4gICAgICA6IG51bGw7XG4gIH1cblxuICBoYW5kbGVWaXJ0dWFsUm91dGVyTmFtZUNoYW5nZShvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgaWYgKHRoaXMuX2NvbnN1bWVycykge1xuICAgICAgdGhpcy5fY29uc3VtZXJzLmZsb3dzLmZvckVhY2goY29uc3VtZXIgPT4gY29uc3VtZXIub25WUk5DaGFuZ2VkKCkpO1xuICAgIH1cbiAgICB0aGlzLmVtaXRTZXNzaW9uRXZlbnQoXG4gICAgICBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5WSVJUVUFMUk9VVEVSX05BTUVfQ0hBTkdFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBgVmlydHVhbCByb3V0ZXIgbmFtZSBpcyBjaGFuZ2VkIGZyb20gJHtvbGROYW1lfSB0byAke25ld05hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHNlc3Npb24ncyBJRCBpbiBoZXhhZGVjaW1hbCBmb3JtYXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBzZXNzaW9uSWRIZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbklkICYmIGZvcm1hdEhleFN0cmluZyh0aGlzLnNlc3Npb25JZCkgfHwgJ04vQSc7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uRlNNID0gU2Vzc2lvbkZTTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL3Nlc3Npb24tZnNtLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgU2Vzc2lvbk9wZXJhdGlvbiA9IHtcbiAgQ09OTkVDVDogICAgICAgICAnQ09OTkVDVCcsXG4gIERJU0NPTk5FQ1Q6ICAgICAgJ0RJU0NPTk5FQ1QnLFxuICBDVFJMOiAgICAgICAgICAgICdDVFJMJyxcbiAgU0VORDogICAgICAgICAgICAnU0VORCcsXG4gIFFVRVJZX09QRVJBVElPTjogJ1FVRVJZX09QRVJBVElPTicsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uT3BlcmF0aW9uID0gRW51bS5uZXcoU2Vzc2lvbk9wZXJhdGlvbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLW9wZXJhdGlvbnMuanMiLCJjb25zdCBQdWJsaXNoZXJMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZS1wdWJsaXNoZXInKTtcbmNvbnN0IFNlc3Npb25Qcm9wZXJ0aWVzTGliID0gcmVxdWlyZSgnLi9zZXNzaW9uLXByb3BlcnRpZXMnKTtcbmNvbnN0IFNNRkxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zbWYnKTtcbmNvbnN0IHsgQVBJUHJvcGVydGllc1ZhbGlkYXRvcnMsIHBhcnNlVVJMIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuY29uc3QgeyBBdXRoZW50aWNhdGlvblNjaGVtZSB9ID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGlvbi1zY2hlbWVzJyk7XG5jb25zdCB7IENoZWNrIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdmFsaWRhdGUnKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlLCBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IExPR19XQVJOIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IFRyYW5zcG9ydFByb3RvY29sIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdHJhbnNwb3J0Jyk7XG5cbmNvbnN0IHtcbiAgdmFsaWRhdGVJbnN0YW5jZSxcbiAgdmFsQXJyYXlJc01lbWJlcixcbiAgdmFsQXJyYXlPZlN0cmluZyxcbiAgdmFsQm9vbGVhbixcbiAgdmFsTGVuZ3RoLFxuICB2YWxOb3RFbXB0eSxcbiAgdmFsTnVtYmVyLFxuICB2YWxSYW5nZSxcbiAgdmFsU3RyaW5nLFxuICB2YWxTdHJpbmdPckFycmF5LFxufSA9IEFQSVByb3BlcnRpZXNWYWxpZGF0b3JzO1xuXG5jb25zdCBBTExPV0VEX1BST1RPQ09MUyA9IFsnaHR0cDonLCAnaHR0cHM6JywgJ3dzOicsICd3c3M6JywgJ3RjcDonLCAndGNwczonXTtcblxuZnVuY3Rpb24gdmFsQ2xpZW50TmFtZSh0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgLy8gdmFsU3RyaW5nIGFuZCB2YWxMZW5ndGgoMTYwKSBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQuXG4gIGNvbnN0IGVycm9yID1cbiAgICBTTUZMaWIuQ2xpZW50Q3RybE1lc3NhZ2UudmFsaWRhdGVDbGllbnROYW1lKFxuICAgICAgaW5zdGFuY2VbbmFtZV0sXG4gICAgICBlcnJvck1lc3NhZ2UgPT5cbiAgICAgICAgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lfSc6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSkpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxJc01lbWJlcih0eXBlRGVzYywgaW5zdGFuY2UsIGtleSwgZW51bUluc3RhbmNlLCBlbnVtTmFtZSwgYWxsb3dOdWxsKSB7XG4gIGNvbnN0IHZhbCA9IGluc3RhbmNlW2tleV07XG4gIGlmIChhbGxvd051bGwgJiYgdmFsID09PSBudWxsKSByZXR1cm47XG4gIGlmICh0eXBlb2YgKHZhbCkgIT09ICd1bmRlZmluZWQnICYmICFlbnVtSW5zdGFuY2UudmFsdWVzLnNvbWUodiA9PiB2ID09PSB2YWwpKSB7XG4gICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgbXVzdCBiZSBhIG1lbWJlciBvZiAke2VudW1OYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxTc2xFeGNsdWRlZFByb3RvY29scyh0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgY29uc3QgdmFsID0gaW5zdGFuY2VbbmFtZV07XG4gIGlmIChDaGVjay5hcnJheSh2YWwpKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWQgPSBTZXNzaW9uUHJvcGVydGllc0xpYi5TZXNzaW9uUHJvcGVydGllcy5TVVBQT1JURURfU1NMX1BST1RPQ09MUztcbiAgICAgIHZhbC5mb3JFYWNoKChwcm90b2NvbCkgPT4ge1xuICAgICAgICBjb25zdCBwcnRjbCA9IHByb3RvY29sLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdXBwb3J0ZWQuaW5kZXhPZihwcnRjbCkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIGNvbnRhaW5zIHVuc3VwcG9ydGVkIHByb3RvY29sOiAke3Byb3RvY29sfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxTc2xDaXBoZXJTdWl0ZXModHlwZURlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IHZhbCA9IGluc3RhbmNlW25hbWVdO1xuICBpZiAodmFsICYmIENoZWNrLnN0cmluZyh2YWwpICYmICFDaGVjay5lbXB0eSh2YWwpKSB7XG4gICAgY29uc3QgY2lwaGVycyA9IHZhbC5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IHN1cHBvcnRlZCA9IFNlc3Npb25Qcm9wZXJ0aWVzTGliLlNlc3Npb25Qcm9wZXJ0aWVzLlNVUFBPUlRFRF9DSVBIRVJfU1VJVEVTO1xuICAgIGNpcGhlcnMuZm9yRWFjaCgoY2lwaGVyKSA9PiB7XG4gICAgICBpZiAoc3VwcG9ydGVkLmluZGV4T2YoY2lwaGVyLnRyaW0oKSkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfScgY29udGFpbnMgdW5zdXBwb3J0ZWQgY2lwaGVyIHN1aXRlOiAnJHtjaXBoZXJ9J2AsXG4gICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gbWF4aW11bSBudW1iZXIgb2YgY29tbW9uIG5hbWVzIGlzIDE2XG5mdW5jdGlvbiB2YWxTc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3QodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IHZhbCA9IGluc3RhbmNlW25hbWVdO1xuICBpZiAoQ2hlY2suc29tZXRoaW5nKHZhbCkgJiYgQ2hlY2suYXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID4gMTYpIHtcbiAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICB9JyBsZW5ndGggZXhjZWVkcyBsaW1pdCBvZiAxNmAsXG4gICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbFVybExpc3QodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IHZhbCA9IGluc3RhbmNlW25hbWVdO1xuICBjb25zdCB2YWxBcnJheSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnNwbGl0KCcsJykgOiB2YWw7XG4gIGlmICghQ2hlY2suYXJyYXkodmFsQXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBub3QgYW4gYXJyYXkgb3IgY29tbWEtZGVsaW1pdGVkIHN0cmluZ2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gIH1cbiAgdmFsQXJyYXkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBsZXQgdXJsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdXJsID0gcGFyc2VVUkwoZWwpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgY29udGFpbmVkIGFuIGludmFsaWQgVVJMOiAke2VsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gICAgaWYgKCFDaGVjay5pbmNsdWRlZCh1cmwucHJvdG9jb2wsIEFMTE9XRURfUFJPVE9DT0xTKSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIGNvbnRhaW5lZCBhIFVSTCcke3VybC5ocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIHdpdGggYW4gaW52YWxpZCBwcm90b2NvbDogJyR7dXJsLnByb3RvY29sfSdgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNIdHRwVHJhbnNwb3J0KHRyYW5zcG9ydFByb3RvY29sKSB7XG4gIHJldHVybiAodHJhbnNwb3J0UHJvdG9jb2wgJiYgKFxuICAgICAgICAgIHRyYW5zcG9ydFByb3RvY29sID09PSBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV9TVFJFQU1JTkcgfHxcbiAgICAgICAgICB0cmFuc3BvcnRQcm90b2NvbCA9PT0gVHJhbnNwb3J0UHJvdG9jb2wuSFRUUF9CSU5BUlkgfHxcbiAgICAgICAgICB0cmFuc3BvcnRQcm90b2NvbCA9PT0gVHJhbnNwb3J0UHJvdG9jb2wuSFRUUF9CQVNFNjQpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wc1N1cHBvcnRlZEJ5VHJhbnNwb3J0KHRyYW5zcG9ydFByb3RvY29sLCBub25IdHRwUHJvcHNTZXQpIHtcbiAgaWYgKG5vbkh0dHBQcm9wc1NldC5sZW5ndGggPiAwICYmIGlzSHR0cFRyYW5zcG9ydCh0cmFuc3BvcnRQcm90b2NvbCkpIHtcbiAgICBjb25zdCBwcm9wTmFtZXMgPSBub25IdHRwUHJvcHNTZXQubGVuZ3RoIDw9IDUgPyBub25IdHRwUHJvcHNTZXQgOiBub25IdHRwUHJvcHNTZXQuc2xpY2UoMCwgNSk7XG4gICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBTZXNzaW9uUHJvcGVydGllcyB2YWxpZGF0aW9uOiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdHJhbnNwb3J0IHByb3RvY29sICR7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydFByb3RvY29sfSBoYXZlIGJlZW4gc2V0OiAke3Byb3BOYW1lc31gLCBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlU3NsKGluc3RhbmNlLCBuYW1lKSB7XG4gIGNvbnN0IHZhbCA9IGluc3RhbmNlW25hbWVdO1xuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAvLyBob3N0IGxpc3QgaXMgdXNlZCwgaXRlcmF0ZSB0byBmaW5kIGF0IGxlYXN0IG9uZSBlbnRyeVxuICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRlbnRyeSA9IHZhbFtpXTtcbiAgICAgIGlmIChDaGVjay5zdHJpbmcoY3VycmVudGVudHJ5KSAmJiBjdXJyZW50ZW50cnkubWF0Y2goL14oaHR0cHN8d3NzfHRjcHMpOi9pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoQ2hlY2suc3RyaW5nKHZhbCkgJiYgdmFsLm1hdGNoKC9eKGh0dHBzfHdzc3x0Y3BzKTovaSkpO1xufVxuXG5jb25zdCBTZXNzaW9uUHJvcGVydGllc1ZhbGlkYXRvciA9IHtcbiAgdmFsaWRhdGUocHJvcHMpIHtcbiAgICAvLyBWYWxpZGF0aW9uIHJ1bGVzOiBzYW1lIGFzIEpDU01QXG4gICAgY29uc3QgdiA9IHZhbGlkYXRlSW5zdGFuY2UuYmluZChudWxsLCAnU2Vzc2lvblByb3BlcnRpZXMnLCBwcm9wcyk7XG4gICAgdigndXJsJywgW3ZhbE5vdEVtcHR5XSwgW3ZhbFN0cmluZ09yQXJyYXldLCBbdmFsVXJsTGlzdF0pO1xuICAgIHYoJ3VzZXJOYW1lJywgW3ZhbFN0cmluZ10sIFt2YWxMZW5ndGgsIDE4OV0pO1xuICAgIHYoJ3Bhc3N3b3JkJywgW3ZhbFN0cmluZ10sIFt2YWxMZW5ndGgsIDEyOF0pO1xuICAgIHYoJ2NsaWVudE5hbWUnLCBbdmFsU3RyaW5nXSwgW3ZhbExlbmd0aCwgMTYwXSwgW3ZhbENsaWVudE5hbWVdKTtcbiAgICB2KCdhcHBsaWNhdGlvbkRlc2NyaXB0aW9uJywgW3ZhbFN0cmluZ10sIFt2YWxMZW5ndGgsIDI1NF0pO1xuICAgIHYoJ3Zwbk5hbWUnLCBbdmFsU3RyaW5nXSwgW3ZhbExlbmd0aCwgMzJdKTtcbiAgICB2KCdjb25uZWN0VGltZW91dEluTXNlY3MnLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAxLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG4gICAgdignY29ubmVjdFJldHJpZXNQZXJIb3N0JywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgLTEsIE51bWJlci5NQVhfVkFMVUVdKTtcbiAgICB2KCdjb25uZWN0UmV0cmllcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIC0xLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG4gICAgdigncmVjb25uZWN0UmV0cmllcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIC0xLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG4gICAgdigncmVjb25uZWN0UmV0cnlXYWl0SW5Nc2VjcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDAsIDYwMDAwXSk7XG4gICAgdigncmVhZFRpbWVvdXRJbk1zZWNzJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgTnVtYmVyLk1BWF9WQUxVRV0pO1xuICAgIHYoJ3NlbmRCdWZmZXJNYXhTaXplJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgTnVtYmVyLk1BWF9WQUxVRV0pO1xuICAgIHYoJ21heFdlYlBheWxvYWQnLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAxMDAsIE51bWJlci5NQVhfVkFMVUVdKTtcbiAgICBpZiAoQlVJTERfRU5WLlRBUkdFVF9CUk9XU0VSKSB7XG4gICAgICB2KCdidWZmZXJlZEFtb3VudFF1ZXJ5SW50ZXJ2YWxJbk1zZWNzJywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgNCwgTnVtYmVyLk1BWF9WQUxVRV0pO1xuICAgIH1cbiAgICB2KCdnZW5lcmF0ZVNlbmRUaW1lc3RhbXBzJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCdnZW5lcmF0ZVJlY2VpdmVUaW1lc3RhbXBzJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCdpbmNsdWRlU2VuZGVySWQnLCBbdmFsQm9vbGVhbl0pO1xuICAgIHYoJ2tlZXBBbGl2ZUludGVydmFsSW5Nc2VjcycsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDAsIE51bWJlci5NQVhfVkFMVUVdKTtcbiAgICB2KCdrZWVwQWxpdmVJbnRlcnZhbHNMaW1pdCcsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDMsIE51bWJlci5NQVhfVkFMVUVdKTtcbiAgICB2KCdnZW5lcmF0ZVNlcXVlbmNlTnVtYmVyJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCdzdWJzY3JpYmVyTG9jYWxQcmlvcml0eScsIFt2YWxOdW1iZXJdLCBbdmFsUmFuZ2UsIDEsIDRdKTtcbiAgICB2KCdzdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5JywgW3ZhbE51bWJlcl0sIFt2YWxSYW5nZSwgMSwgNF0pO1xuICAgIHYoJ2lnbm9yZUR1cGxpY2F0ZVN1YnNjcmlwdGlvbkVycm9yJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCdpZ25vcmVTdWJzY3JpcHRpb25Ob3RGb3VuZEVycm9yJywgW3ZhbEJvb2xlYW5dKTtcbiAgICB2KCdyZWFwcGx5U3Vic2NyaXB0aW9ucycsIFt2YWxCb29sZWFuXSk7XG4gICAgdignbm9Mb2NhbCcsIFt2YWxCb29sZWFuXSk7XG4gICAgdigndHJhbnNwb3J0RG93bmdyYWRlVGltZW91dEluTXNlY3MnLCBbdmFsTnVtYmVyXSwgW3ZhbFJhbmdlLCAxLCBOdW1iZXIuTUFYX1ZBTFVFXSk7XG5cbiAgICBpZiAocHJvcHMudHJhbnNwb3J0UHJvdG9jb2wgJiYgcHJvcHMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJTZXNzaW9uUHJvcGVydGllcyB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAndHJhbnNwb3J0UHJvdG9jb2wnIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0JyBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QgIT09IG51bGwgJiYgcHJvcHMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcIlByb3BlcnR5ICd3ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QnIG11c3QgYmUgYW4gYXJyYXkgaWYgc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJQcm9wZXJ0eSAnd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0JyBtdXN0IGJlIG5vbi1lbXB0eSBpZiBzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2KCdhdXRoZW50aWNhdGlvblNjaGVtZScsIFt2YWxJc01lbWJlciwgQXV0aGVudGljYXRpb25TY2hlbWUsICdBdXRoZW50aWNhdGlvblNjaGVtZScsIGZhbHNlXSk7XG4gICAgY29uc3QgdXNlQ2xpZW50Q2VydCA9IHByb3BzLmF1dGhlbnRpY2F0aW9uU2NoZW1lID09PSBBdXRoZW50aWNhdGlvblNjaGVtZS5DTElFTlRfQ0VSVElGSUNBVEU7XG4gICAgaWYgKCF1c2VTc2wocHJvcHMsICd1cmwnKSAmJiB1c2VDbGllbnRDZXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJTZXNzaW9uUHJvcGVydGllcyB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnYXV0aGVudGljYXRpb25TY2hlbWUnIGNhbm5vdCBiZSBzZXQgdG8gY2xpZW50IGNlcnRpZmljYXRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZm9yIHVuc2VjdXJlZCBzZXNzaW9ucycsIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG5cbiAgICBpZiAoQlVJTERfRU5WLlRBUkdFVF9OT0RFKSB7XG4gICAgICAvLyBzaG91bGQgbm90IGhhcHBlbiBzaW5jZSB0cmFuc3BvcnRQcm90b2NvbCBhbmQgd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0IGFyZSBub3QgcHVibGljXG4gICAgICBpZiAoQ2hlY2suc29tZXRoaW5nKHByb3BzLnRyYW5zcG9ydFByb3RvY29sKSAmJlxuICAgICAgICAgIHByb3BzLnRyYW5zcG9ydFByb3RvY29sICE9PSBUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUlkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwiU2Vzc2lvblByb3BlcnRpZXMgdmFsaWRhdGlvbjogcHJvcGVydGllcyAndHJhbnNwb3J0UHJvdG9jb2wnIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjYW4gb25seSBiZSBXU19CSU5BUlknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgICAgfVxuICAgICAgaWYgKENoZWNrLnNvbWV0aGluZyhwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QpKSB7XG4gICAgICAgIGlmICghQ2hlY2suYXJyYXkocHJvcHMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignU2Vzc2lvblByb3BlcnRpZXMgdmFsaWRhdGlvbjogUHJvcGVydHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3dlYlRyYW5zcG9ydFByb3RvY29sTGlzdCcgc2hvdWxkIGJlIHR5cGUgQXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICBwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3RbMF0gIT09IFRyYW5zcG9ydFByb3RvY29sLldTX0JJTkFSWSkge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignU2Vzc2lvblByb3BlcnRpZXMgdmFsaWRhdGlvbjogcHJvcGVydGllcyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0JyBjYW4gb25seSBjb250YWluIGVsZW1lbnQgV1NfQklOQVJZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2KCdzc2xFeGNsdWRlZFByb3RvY29scycsIFt2YWxBcnJheU9mU3RyaW5nXSwgW3ZhbFNzbEV4Y2x1ZGVkUHJvdG9jb2xzXSk7XG4gICAgICB2KCdzc2xDaXBoZXJTdWl0ZXMnLCBbdmFsU3RyaW5nXSwgW3ZhbFNzbENpcGhlclN1aXRlc10pO1xuICAgICAgdignc3NsVmFsaWRhdGVDZXJ0aWZpY2F0ZScsIFt2YWxCb29sZWFuXSk7XG5cbiAgICAgIGlmIChwcm9wcy5zc2xWYWxpZGF0ZUNlcnRpZmljYXRlIHx8IHVzZUNsaWVudENlcnQpIHtcbiAgICAgICAgdignc3NsVHJ1c3RTdG9yZXMnLCBbdmFsQXJyYXlPZlN0cmluZ10pO1xuICAgICAgICB2KCdzc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3QnLCBbdmFsQXJyYXlPZlN0cmluZ10sIFt2YWxTc2xUcnVzdGVkQ29tbW9uTmFtZUxpc3RdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZUNsaWVudENlcnQpIHtcbiAgICAgICAgdignc3NsUGZ4JywgW3ZhbFN0cmluZ10pO1xuICAgICAgICB2KCdzc2xQZnhQYXNzd29yZCcsIFt2YWxTdHJpbmddKTtcbiAgICAgICAgdignc3NsUHJpdmF0ZUtleScsIFt2YWxTdHJpbmddKTtcbiAgICAgICAgdignc3NsUHJpdmF0ZUtleVBhc3N3b3JkJywgW3ZhbFN0cmluZ10pO1xuICAgICAgICB2KCdzc2xDZXJ0aWZpY2F0ZScsIFt2YWxTdHJpbmddKTtcbiAgICAgICAgLy8gZWl0aGVyIHNzbFBmeCBvciBzc2xQcml2YXRlS2V5IGFuZCBzc2xDZXJ0aWZpY2F0ZSBtdXN0IGJlIHNwZWNpZmllZCxcbiAgICAgICAgLy8gYnV0IG5vdCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgICAgIGNvbnN0IHNzbFBmeFNldCA9IENoZWNrLnNvbWV0aGluZyhwcm9wcy5zc2xQZngpICYmIHByb3BzLnNzbFBmeC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNzbFByaXZhdGVLZXlTZXQgPSAoXG4gICAgICAgICAgQ2hlY2suc29tZXRoaW5nKHByb3BzLnNzbFByaXZhdGVLZXkpICYmXG4gICAgICAgICAgcHJvcHMuc3NsUHJpdmF0ZUtleS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3NsQ2VydFNldCA9IChcbiAgICAgICAgICBDaGVjay5zb21ldGhpbmcocHJvcHMuc3NsQ2VydGlmaWNhdGUpICYmXG4gICAgICAgICAgcHJvcHMuc3NsQ2VydGlmaWNhdGUubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGlmICghc3NsUGZ4U2V0ICYmICFzc2xQcml2YXRlS2V5U2V0ICYmICFzc2xDZXJ0U2V0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdTZXNzaW9uUHJvcGVydGllcyB2YWxpZGF0aW9uOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFaXRoZXIgcHJvcGVydHkgJ3NzbFBmeCcsIG9yICdzc2xQcml2YXRlS2V5JyBhbmQgJ3NzbENlcnRpZmljYXRlJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtdXN0IGJlIHNldCB3aGVuIGF1dGhlbnRpY2F0aW9uU2NoZW1lIGlzIGNsaWVudCBjZXJ0aWZpY2F0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3NsUGZ4U2V0ICYmIChzc2xQcml2YXRlS2V5U2V0IHx8IHNzbENlcnRTZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdTZXNzaW9uUHJvcGVydGllcyB2YWxpZGF0aW9uOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQcm9wZXJ0eSAnc3NsUGZ4JyBjYW4gb25seSBiZSBzZXQgd2hlbiAnc3NsUHJpdmF0ZUtleScgYW5kICdzc2xDZXJ0aWZpY2F0ZScgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJlIG5vdCBzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzc2xQcml2YXRlS2V5U2V0ICYmICFzc2xDZXJ0U2V0KSB8fCAoIXNzbFByaXZhdGVLZXlTZXQgJiYgc3NsQ2VydFNldCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ1Nlc3Npb25Qcm9wZXJ0aWVzIHZhbGlkYXRpb246ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlByb3BlcnR5ICdzc2xQcml2YXRlS2V5JyBhbmQgJ3NzbENlcnRpZmljYXRlJyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtdXN0IGJlIHNldCBhdCB0aGUgc2FtZSB0aW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdigndHJhbnNwb3J0UHJvdG9jb2wnLCBbdmFsSXNNZW1iZXIsIFRyYW5zcG9ydFByb3RvY29sLCAnVHJhbnNwb3J0UHJvdG9jb2wnLCB0cnVlXSk7XG4gICAgdignd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0JyxcbiAgICAgIFt2YWxBcnJheUlzTWVtYmVyLCBUcmFuc3BvcnRQcm90b2NvbCwgJ1RyYW5zcG9ydFByb3RvY29sJyxcbiAgICAgICAgdHJ1ZSwgZmFsc2UsIGZhbHNlXSk7XG5cbiAgICB2YWxpZGF0ZVByb3BzU3VwcG9ydGVkQnlUcmFuc3BvcnQocHJvcHMudHJhbnNwb3J0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm5vbkhUVFBUcmFuc3BvcnRQcm9wc1NldCk7XG5cbiAgICBpZiAocHJvcHMucHVibGlzaGVyUHJvcGVydGllcykge1xuICAgICAgUHVibGlzaGVyTGliLk1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzVmFsaWRhdG9yLnZhbGlkYXRlKHByb3BzLnB1Ymxpc2hlclByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8vIE5vbi1lcnJvcnNcblxuICAgIGNvbnN0IHJlY29tbWVuZGVkTWluID0gcHJvcHMuZGVmYXVsdENvbm5lY3RUaW1lb3V0SW5Nc2VjcztcbiAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IHByb3BzLmNvbm5lY3RUaW1lb3V0SW5Nc2VjcztcbiAgICBjb25zdCB0cmFuc3BvcnRDb3VudCA9IHByb3BzLndlYlRyYW5zcG9ydFByb3RvY29sTGlzdFxuICAgICAgPyBwcm9wcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QubGVuZ3RoXG4gICAgICA6IDE7XG4gICAgaWYgKHRyYW5zcG9ydENvdW50ID4gMSAmJiBjb25uZWN0VGltZW91dCA8IHJlY29tbWVuZGVkTWluKSB7XG4gICAgICBMT0dfV0FSTihcbiAgICAgICAgYENvbm5lY3QgdGltZW91dCBvZiAke2Nvbm5lY3RUaW1lb3V0fSBtc2VjcyBpcyBsZXNzIHRoYW4gZGVmYXVsdCBhbmQgcmVjb21tZW5kZWQgYCArXG4gICAgICAgIGBtaW5pbXVtIG9mICR7cmVjb21tZW5kZWRNaW59IG1zZWNzIGZvciBjdXJyZW50IHRyYW5zcG9ydCBzZWxlY3Rpb24uIFRyYW5zcG9ydCBgICtcbiAgICAgICAgJ2Rvd25ncmFkZXMgbWF5IG5vdCBjb21wbGV0ZS4nKTtcbiAgICB9XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5TZXNzaW9uUHJvcGVydGllc1ZhbGlkYXRvciA9IFNlc3Npb25Qcm9wZXJ0aWVzVmFsaWRhdG9yO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zZXNzaW9uL2xpYi9zZXNzaW9uLXByb3BlcnRpZXMtdmFsaWRhdG9yLmpzIiwiY29uc3QgRGVzdGluYXRpb25MaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IE1lc3NhZ2VMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtbWVzc2FnZScpO1xuY29uc3QgU29sY2xpZW50RmFjdG9yeUxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mYWN0b3J5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBhc3NlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBDYWNoZVNlc3Npb24sXG4gICAgICAgIENBQ0hFX1JFUVVFU1RfUFJFRklYIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbicpO1xuY29uc3QgeyBDYXBhYmlsaXR5VHlwZSB9ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5LXR5cGVzJyk7XG5jb25zdCB7IENoZWNrLFxuICAgICAgICBQYXJhbWV0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBEZWZhdWx0Q2FwYWJpbGl0aWVzIH0gPSByZXF1aXJlKCcuL2RlZmF1bHQtY2FwYWJpbGl0aWVzJyk7XG5jb25zdCB7IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyLFxuICAgICAgICBFcnJvclN1YmNvZGUsXG4gICAgICAgIE9wZXJhdGlvbkVycm9yLFxuICAgICAgICBSZXF1ZXN0RXZlbnRDb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXZlbnRzJyk7XG5jb25zdCB7IEdsb2JhbENvbnRleHQgfSA9IHJlcXVpcmUoJy4vZ2xvYmFsLWNvbnRleHQnKTtcbmNvbnN0IHsgSG9zdExpc3QgfSA9IHJlcXVpcmUoJy4vaG9zdC1saXN0Jyk7XG5jb25zdCB7IExvZ0Zvcm1hdHRlciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBNZXNzYWdlUnhDQkluZm8gfSA9IHJlcXVpcmUoJy4vbWVzc2FnZS1yeC1jYi1pbmZvJyk7XG5jb25zdCB7IE11dGFibGVTZXNzaW9uUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4vbXV0YWJsZS1zZXNzaW9uLXByb3BlcnRpZXMnKTtcbmNvbnN0IHsgT3V0c3RhbmRpbmdEYXRhUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9vdXRzdGFuZGluZy1kYXRhLXJlcXVlc3QnKTtcbmNvbnN0IHsgUDJQVXRpbCB9ID0gcmVxdWlyZSgnLi9wMnAtdXRpbCcpO1xuY29uc3QgeyBRdWV1ZURlc2NyaXB0b3IsXG4gICAgICAgIFF1ZXVlVHlwZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXF1ZXVlJyk7XG5jb25zdCB7IFNEVEZpZWxkLFxuICAgICAgICBTRFRGaWVsZFR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zZHQnKTtcbmNvbnN0IHsgU2Vzc2lvbkV2ZW50IH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZXZlbnQnKTtcbmNvbnN0IHsgU2Vzc2lvbkV2ZW50Q0JJbmZvIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZXZlbnQtY2ItaW5mbycpO1xuY29uc3QgeyBTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZXZlbnQtY29kZXMnKTtcbmNvbnN0IHsgU2Vzc2lvbkV2ZW50TmFtZSB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLWV2ZW50LW5hbWVzJyk7XG5jb25zdCB7IFNlc3Npb25GU00gfSA9IHJlcXVpcmUoJy4vc2Vzc2lvbi1mc20nKTtcbmNvbnN0IHsgU2Vzc2lvbkZTTUV2ZW50IH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tZnNtLWV2ZW50Jyk7XG5jb25zdCB7IFNlc3Npb25PcGVyYXRpb24gfSA9IHJlcXVpcmUoJy4vc2Vzc2lvbi1vcGVyYXRpb25zJyk7XG5jb25zdCB7IFNlc3Npb25Qcm9wZXJ0aWVzIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tcHJvcGVydGllcycpO1xuY29uc3QgeyBTZXNzaW9uUHJvcGVydGllc1ZhbGlkYXRvciB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLXByb3BlcnRpZXMtdmFsaWRhdG9yJyk7XG5jb25zdCB7IFNlc3Npb25SZXF1ZXN0VHlwZSB9ID0gcmVxdWlyZSgnLi9zZXNzaW9uLXJlcXVlc3QtdHlwZXMnKTtcbmNvbnN0IHsgU2Vzc2lvblN0YXRlIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tc3RhdGVzJyk7XG5jb25zdCB7IFNlc3Npb25TdGF0ZU5hbWUgfSA9IHJlcXVpcmUoJy4vc2Vzc2lvbi1zdGF0ZS1uYW1lcycpO1xuY29uc3QgeyBTdGF0cyxcbiAgICAgICAgU3RhdFR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zdGF0cycpO1xuY29uc3QgeyBTdHJpbmdVdGlscyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgVHJhbnNwb3J0Q2FwYWJpbGl0aWVzLFxuICAgICAgICBUcmFuc3BvcnRQcm90b2NvbCxcbiAgICAgICAgVHJhbnNwb3J0UmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXRyYW5zcG9ydCcpO1xuXG5mdW5jdGlvbiB0cmFuc3BvcnRQcm90b2NvbERlZmF1bHRMaXN0KCkge1xuICBjb25zdCB7IFByb2ZpbGVCaW5kaW5nIH0gPSBTb2xjbGllbnRGYWN0b3J5TGliO1xuXG4gIGlmIChCVUlMRF9FTlYuVEFSR0VUX05PREUpIHtcbiAgICByZXR1cm4gW1RyYW5zcG9ydFByb3RvY29sLldTX0JJTkFSWV07XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKFRyYW5zcG9ydENhcGFiaWxpdGllcy53ZWIud2ViU29ja2V0KCkpIHtcbiAgICByZXN1bHQucHVzaChUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUlkpO1xuICB9XG4gIGNvbnN0IHByb2ZpbGUgPSBQcm9maWxlQmluZGluZy52YWx1ZTtcbiAgaWYgKHByb2ZpbGUuY29tZXRFbmFibGVkKSB7XG4gICAgaWYgKFRyYW5zcG9ydENhcGFiaWxpdGllcy53ZWIueGhyQmluYXJ5KCkpIHtcbiAgICAgIGlmIChUcmFuc3BvcnRDYXBhYmlsaXRpZXMud2ViLnN0cmVhbWluZygpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQklOQVJZX1NUUkVBTUlORyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQkFTRTY0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkQURUcmFuc3BvcnQodHJhbnNwb3J0UHJvdG9jb2wpIHtcbiAgcmV0dXJuICh0cmFuc3BvcnRQcm90b2NvbCAmJiAoXG4gICAgICAgICAgdHJhbnNwb3J0UHJvdG9jb2wgIT09IFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQklOQVJZX1NUUkVBTUlORyAmJlxuICAgICAgICAgIHRyYW5zcG9ydFByb3RvY29sICE9PSBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWSAmJlxuICAgICAgICAgIHRyYW5zcG9ydFByb3RvY29sICE9PSBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JBU0U2NCkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIHJldHVybiBgU2Vzc2lvbkV2ZW50Q29kZS4ke1Nlc3Npb25FdmVudENvZGUuZGVzY3JpYmUoZXZlbnROYW1lKX1gO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFNPTENMSUVOVF9SRVFVRVNUX1BSRUZJWCA9ICcjUkVRJztcblxuLyoqXG4gKiBBIGNhbGxiYWNrIHRoYXQgcmV0dXJucyByZXBsaWVzIHRvIHJlcXVlc3RzIHNlbnQgdmlhIHtAbGluayBzb2xhY2UuU2Vzc2lvbiNzZW5kUmVxdWVzdH0uXG4gKiBUaGUgcmVwbHlSZWNlaXZlZENhbGxiYWNrIDxiPm11c3Q8L2I+IGJlIHByb3ZpZGVkIHRvIHRoZSBBUEkgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IG9mXG4gKiB7QGxpbmsgc29sYWNlLlNlc3NzaW9uI3NlbmRSZXF1ZXN0fS5cbiAqIEBjYWxsYmFja1xuICogQGZ1bmN0aW9uXG4gKiBAbmFtZSBzb2xhY2UuU2Vzc2lvbi5yZXBseVJlY2VpdmVkQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb259IHNlc3Npb24gVGhlIHNlc3Npb24gb2JqZWN0IHRoYXQgcmVjZWl2ZWQgdGhlIHJlcGx5LlxuICogQHBhcmFtIHtzb2xhY2UuTWVzc2FnZX0gbWVzc2FnZSBUaGUgcmVwbHkgbWVzc2FnZSByZWNlaXZlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT2JqZWN0IFRoZSB1c2VyIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGxiYWNrLiAndW5kZWZpbmVkJyB3aGVuXG4gKiBub3QgcHJvdmlkZWQgdG8gPGk+c2VuZFJlcXVlc3Q8L2k+XG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHRoYXQgcmV0dXJucyBlcnJvcnMgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3RzIHNlbnQgdmlhXG4gKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jc2VuZFJlcXVlc3R9LiBUaGUgcmVwbHlSZWNlaXZlZENhbGxiYWNrIDxiPm11c3Q8L2I+IGJlXG4gKiBwcm92aWRlZCB0byB0aGUgQVBJIGFzIHRoZSBmb3VydGggYXJndW1lbnQgb2ZcbiAqIHtAbGluayBzb2xhY2UuU2Vzc3Npb24jc2VuZFJlcXVlc3R9XG4gKiBAY2FsbGJhY2tcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgc29sYWNlLlNlc3Npb24ucmVxdWVzdEZhaWxlZENhbGxiYWNrXG4gKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9ufSBzZXNzaW9uIFRoZSBzZXNzaW9uIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuICogQHBhcmFtIHtzb2xhY2UuUmVxdWVzdEVycm9yfSBlcnJvciBUaGUgZXZlbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBmYWlsdXJlLlxuICogQHBhcmFtIHtPYmplY3R9IHVzZXJPYmplY3QgVGhlIHVzZXIgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsbGJhY2suICd1bmRlZmluZWQnIHdoZW5cbiAqIG5vdCBwcm92aWRlZCB0byA8aT5zZW5kUmVxdWVzdDwvaT5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIDxiPlRoaXMgY2xhc3MgaXMgbm90IGV4cG9zZWQgZm9yIGNvbnN0cnVjdGlvbiBieSBBUEkgdXNlcnMuPC9iPlxuICogQXBwbGljYXRpb25zIG11c3QgdXNlIHtAbGluayBzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5jcmVhdGVTZXNzaW9ufSB0byBjcmVhdGUgYSBzZXNzaW9uLlxuICpcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgU2Vzc2lvbi5cbiAqXG4gKiBTZXNzaW9uIHByb3ZpZGVzIHRoZXNlIG1ham9yIGZ1bmN0aW9uczpcbiAqICAqIFN1YnNjcmliZXIgY29udHJvbCwgc3VjaCBhcyB1cGRhdGluZyBzdWJzY3JpcHRpb25zO1xuICogICogUHVibGlzaGVzIGJvdGggRGlyZWN0IGFuZCBHdWFyYW50ZWVkIE1lc3NhZ2VzIHRvIHRoZSByb3V0ZXI7XG4gKiAgKiBSZWNlaXZlcyBkaXJlY3QgbWVzc2FnZXMgZnJvbSB0aGUgcm91dGVyLlxuICpcbiAqIFRoZSBTZXNzaW9uIG9iamVjdCBpcyBhblxuICoge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcnxFdmVudEVtaXR0ZXJ9LCBhbmQgd2lsbCBlbWl0XG4gKiBldmVudHMgd2l0aCBldmVudCBuYW1lcyBmcm9tIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZX0gd2hlbiBTZXNzaW9uIGV2ZW50cyBvY2N1ci5cbiAqIEVhY2ggc2Vzc2lvbiBldmVudCBjYW4gYmUgc3Vic2NyaWJlZCB1c2luZyB7QGxpbmsgc29sYWNlLlNlc3Npb24jb259IHdpdGggdGhlIGNvcnJlc3BvbmRpbmdcbiAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZX0uIElmIGFueSBvZiB0aGUgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhyb3cgYW4gZXhjZXB0aW9uLFxuICogdGhlIGV4Y2VwdGlvbiB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlICdlcnJvcicgZXZlbnQuXG4gKlxuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI0FDS05PV0xFREdFRF9NRVNTQUdFXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjQ0FOX0FDQ0VQVF9EQVRBXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjQ09OTkVDVF9GQUlMRURfRVJST1JcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNESVNDT05ORUNURURcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNET1dOX0VSUk9SXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjR1VBUkFOVEVFRF9NRVNTQUdFX1BVQkxJU0hFUl9ET1dOXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjTUVTU0FHRVxuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1BST1BFUlRZX1VQREFURV9FUlJPUlxuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1BST1BFUlRZX1VQREFURV9PS1xuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1JFQ09OTkVDVEVEX05PVElDRVxuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1JFQ09OTkVDVElOR19OT1RJQ0VcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNSRUpFQ1RFRF9NRVNTQUdFX0VSUk9SXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjUkVQVUJMSVNISU5HX1VOQUNLRURfTUVTU0FHRVNcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNTVUJTQ1JJUFRJT05fRVJST1JcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNTVUJTQ1JJUFRJT05fT0tcbiAqIEBmaXJlcyBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNVTlNVQlNDUklCRV9URV9UT1BJQ19FUlJPUlxuICogQGZpcmVzIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI1VOU1VCU0NSSUJFX1RFX1RPUElDX09LXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjVVBfTk9USUNFXG4gKiBAZmlyZXMgc29sYWNlLlNlc3Npb25FdmVudENvZGUjVklSVFVBTFJPVVRFUl9OQU1FX0NIQU5HRURcbiAqXG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKi9cbmNsYXNzIFNlc3Npb24gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIC8qXG4gICAqIEFwcGxpY2F0aW9ucyBtdXN0IHVzZSB7QGxpbmsgc29sYWNlLlNvbGNsaWVudEZhY3RvcnkuY3JlYXRlU2Vzc2lvbn0gdG8gY3JlYXRlIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXN9IHByb3BlcnRpZXMgUHJvcGVydGllcyB0byB1c2UgZm9yIGNvbnN0cnVjdGluZ1xuICAgKiAgICAgICAgdGhlIHNlc3Npb24uXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2VSeENCSW5mb30gW21lc3NhZ2VDYWxsYmFja10gTWVzc2FnZSBjYWxsYmFjayBpbmZvLiBUaGUgYXBwbGljYXRpb24gY2FuXG4gICAqICAgIGFsc28gcmVjZWl2ZSBtZXNzYWdlIGV2ZW50cyB2aWFcbiAgICogICAgYHNlc3Npb24ub24oc29sYWNlLlNlc3Npb25FdmVudENvZGUuTUVTU0FHRSwgKG1lc3NhZ2UpID0+IHsgLi4uIH0pO2BcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbkV2ZW50Q0JJbmZvfSBbZXZlbnRDYWxsYmFja10gRXZlbnQgY2FsbGJhY2sgaW5mby4gVGhlIGFwcGxpY2F0aW9uIGNhblxuICAgKiAgICBhbHNvIHJlY2VpdmUgc2Vzc2lvbiBldmVudHMgdmlhXG4gICAqICAgIGBzZXNzaW9uLm9uKHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLjxjb2RlPiwgKGV2ZW50KSA9PiB7IC4uLiB9KTtgXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUgb3IgdmFsdWUuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgbWVzc2FnZUNhbGxiYWNrLCBldmVudENhbGxiYWNrKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW1pdHM6ICBTZXNzaW9uRXZlbnRDb2RlLnZhbHVlcyxcbiAgICAgIGRpcmVjdDogU2Vzc2lvbkV2ZW50Q29kZS5NRVNTQUdFLFxuICAgICAgZm9ybWF0RXZlbnROYW1lLFxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ0Zvcm1hdHRlcigpO1xuICAgIHRoaXMubG9nZ2VyLmZvcm1hdHRlciA9IGZ1bmN0aW9uIGZvcm1hdHRlciguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gW2Bbc2Vzc2lvbj0ke3NlbGYuX3Nlc3Npb25GU00gPyBzZWxmLl9zZXNzaW9uRlNNLnNlc3Npb25JZEhleCA6ICcoTi9BKSd9XWAsIC4uLmFyZ3NdO1xuICAgIH07XG4gICAgaWYgKChwcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpICYmIChwcm9wZXJ0aWVzICE9PSBudWxsKSkge1xuICAgICAgY29uc3QgeyBMT0dfREVCVUcgfSA9IHRoaXMubG9nZ2VyO1xuICAgICAgTE9HX0RFQlVHKCdTZXNzaW9uIHByb3BlcnRpZXM6XFxuJywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vzc2lvblByb3BlcnRpZXMgPSBuZXcgU2Vzc2lvblByb3BlcnRpZXMocHJvcGVydGllcyk7XG5cbiAgICAvLyBDYWxsYmFja3MgdG8gY2xpZW50IGFwcGxpY2F0aW9uLlxuICAgIC8vIEdldC9zZXQgZm9yIHRoZXNlIGlzIHByaXZhdGUsIHNvIHRoZXkgY2FuIG9ubHkgYmUgY2hhbmdlZCBpbi1BUEkgKGUuZy4gYnkgQ2FjaGVTZXNzaW9uKVxuICAgIC8vIFRoZSB1c2VyLXN1cHBsaWVkIG9uZSBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICAvLyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgZXhjZXB0aW9ucyBnZW5lcmF0ZWQgYnkgdGhlc2UgbmVlZHMgdG8gbWF0Y2ggRXZlbnRFbWl0dGVyLCBzbyB0aGF0XG4gICAgLy8gdGhlIGhhbmRsZUdlbmVyaWNFcnJvckV2ZW50IGFib3ZlIGNhbiBiZWhhdmUgY29uc2lzdGVudGx5XG4gICAgdGhpcy5fbWVzc2FnZUNhbGxiYWNrSW5mbyA9IHRoaXMud3JhcE1lc3NhZ2VDYWxsYmFjayhtZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tJbmZvID0gdGhpcy53cmFwRXZlbnRDYWxsYmFjayhldmVudENhbGxiYWNrKTtcblxuICAgIC8vIGNsaWVudCBuYW1lIGdlbmVyYXRpb24gaXMgYXBwbGljYWJsZVxuICAgIGlmIChDaGVjay5lbXB0eShzZXNzaW9uUHJvcGVydGllcy5jbGllbnROYW1lKSkge1xuICAgICAgLy8gQXV0by1nZW4gY2xpZW50TmFtZVxuICAgICAgc2Vzc2lvblByb3BlcnRpZXMuY2xpZW50TmFtZSA9IEdsb2JhbENvbnRleHQuR2VuZXJhdGVDbGllbnROYW1lKCk7XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgdXNlcklkZW50aWZpY2F0aW9uXG4gICAgc2Vzc2lvblByb3BlcnRpZXMuX3NldFVzZXJJZGVudGlmaWNhdGlvbihHbG9iYWxDb250ZXh0LkdlbmVyYXRlVXNlcklkZW50aWZpY2F0aW9uKCkpO1xuXG4gICAgLy8gY2xpZW50IGRlc2NyaXB0aW9uIGdlbmVyYXRpb24gaXMgYXBwbGljYWJsZVxuICAgIGlmIChDaGVjay5lbXB0eShzZXNzaW9uUHJvcGVydGllcy5hcHBsaWNhdGlvbkRlc2NyaXB0aW9uKSkge1xuICAgICAgLy8gQXV0by1nZW4gYXBwbGljYXRpb25EZXNjcmlwdGlvblxuICAgICAgc2Vzc2lvblByb3BlcnRpZXMuYXBwbGljYXRpb25EZXNjcmlwdGlvbiA9IEdsb2JhbENvbnRleHQuR2VuZXJhdGVDbGllbnREZXNjcmlwdGlvbigpO1xuICAgIH1cblxuICAgIC8vIFNldCB3ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QgYWZ0ZXIgdmFsaWRhdGlvbiBzbyB3ZSdyZSBub3QgYmFzaW5nIGl0IG9uIGFuXG4gICAgLy8gaW52YWxpZCB0cmFuc3BvcnQgc2VsZWN0aW9uLi4uc28gd2UncmUgbm90IGNoZWNraW5nIHRyYW5zcG9ydFByb3RvY29sL1xuICAgIC8vIHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdCBleGNlcHQgZm9yIHBhcmFtZXRlciBjb25mbGljdC5cblxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdG91Y2hlZCB1cCB0aGUgcHJvcGVydGllcyBhcyBtdWNoIGFzIHBvc3NpYmxlLCB2YWxpZGF0ZVxuICAgIC8vIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHN1Ym9yZGluYXRlIE1lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzXG4gICAgU2Vzc2lvblByb3BlcnRpZXNWYWxpZGF0b3IudmFsaWRhdGUoc2Vzc2lvblByb3BlcnRpZXMpO1xuXG4gICAgLy8gV2Ugd2FudCBhIHByb3RvY29sIGxpc3QsIGJ1dCBoaXN0b3JpY2FsbHkgd2UgYWxzbyBhY2NlcHQgYSBzaW5nbGUgcHJvdG9jb2wuXG4gICAgLy8gQ3JlYXRlIGEgd2ViIHRyYW5zcG9ydCBwcm90b2NvbCBsaXN0IGZyb20gdGhlIHRyYW5zcG9ydCBwcm90b2NvbFxuICAgIC8vIG9wdGlvbiBpZiB0aGF0IGlzIGFsbCB0aGF0IHdhcyBzZXQuIChJZiBib3RoIHdlcmUgc2V0LCB3ZSBmYWlsZWQgdmFsaWRhdGlvbilcbiAgICBpZiAoQ2hlY2subm90aGluZyhzZXNzaW9uUHJvcGVydGllcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QpKSB7XG4gICAgICAvLyBDcmVhdGUgYSBmYWxsYmFjayBsaXN0IHRoYXQgc3RhcnRzIHdpdGggdGhlIHNlbGVjdGVkIHByb3RvY29sLlxuICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkIHByb3RvY29sIGlzIG5vdCBpbiB0aGUgZmFsbGJhY2sgbGlzdCwgaXQgaXMgbm90XG4gICAgICAvLyBhIHZhbGlkIHByb3RvY29sIGZvciB0aGUgcGxhdGZvcm0gc28gcmV0dXJuIGFuIGVtcHR5IGxpc3QuXG4gICAgICBjb25zdCBzZWxlY3RlZFByb3RvY29sID0gc2Vzc2lvblByb3BlcnRpZXMudHJhbnNwb3J0UHJvdG9jb2w7XG4gICAgICBjb25zdCBkZWZhdWx0TGlzdCA9IHRyYW5zcG9ydFByb3RvY29sRGVmYXVsdExpc3QoKTtcbiAgICAgIGNvbnN0IHNsaWNlSW5kZXggPSBzZWxlY3RlZFByb3RvY29sID8gZGVmYXVsdExpc3QuaW5kZXhPZihzZWxlY3RlZFByb3RvY29sKSA6IDA7XG4gICAgICBpZiAoc2xpY2VJbmRleCA8IDApIHtcbiAgICAgICAgLy8gVGhlIHVzZXIgZXhwbGljaXRseSBzZWxlY3RlZCBhIHByb3RvY29sIHRoYXQgd2Fzbid0IHZhbGlkXG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgU2VsZWN0ZWQgdHJhbnNwb3J0IHByb3RvY29sICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnRQcm90b2NvbC5kZXNjcmliZShzZWxlY3RlZFByb3RvY29sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBpcyBkaXNhYmxlZCBvciBpbnZhbGlkIGZvciB0aGlzIHBsYXRmb3JtYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICAgICAgfVxuICAgICAgLy8gU2xpY2UgaW5kZXggaXMgdmFsaWRcbiAgICAgIHNlc3Npb25Qcm9wZXJ0aWVzLndlYlRyYW5zcG9ydFByb3RvY29sTGlzdCA9IGRlZmF1bHRMaXN0LnNsaWNlKHNsaWNlSW5kZXgpO1xuXG4gICAgICBpZiAoc2Vzc2lvblByb3BlcnRpZXMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBFdmVuIGJlZm9yZSBBRCByZXN0cmljdGlvbnMsIG5vIHZhbGlkIHByb3RvY29scy5cbiAgICAgICAgLy8gVXNlciBlcnJvci5cbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBObyB1c2FibGUgdHJhbnNwb3J0IHByb3RvY29sIG9yIGZhbGxiYWNrIGZyb20gJHtcbiAgICAgICAgICBUcmFuc3BvcnRQcm90b2NvbC5kZXNjcmliZShzZWxlY3RlZFByb3RvY29sKX1gLFxuICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfQ09ORkxJQ1QpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0aGF0IHRoZSBnZW5lcmF0ZWQgbGlzdCBpcyBjb21wYXRpYmxlIHdpdGggQUQuXG4gICAgICBjb25zdCB2YWxpZEZvckFEID0gc2Vzc2lvblByb3BlcnRpZXMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0LmZpbHRlcih4ID0+XG4gICAgICAgIGlzVmFsaWRBRFRyYW5zcG9ydCh4KSk7XG4gICAgICBpZiAodmFsaWRGb3JBRC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fYWREaXNhYmxlZFJlYXNvbiA9ICdHdWFyYW50ZWVkIG1lc3NhZ2luZyBub3QgY29tcGF0aWJsZSB3aXRoIGFueSBhdmFpbGFibGUgJyArXG4gICAgICAgICAgYHRyYW5zcG9ydCBwcm90b2NvbDogJHtcbiAgICAgICAgICAgIHNlc3Npb25Qcm9wZXJ0aWVzLndlYlRyYW5zcG9ydFByb3RvY29sTGlzdC5tYXAoayA9PlxuICAgICAgICAgICAgICBUcmFuc3BvcnRQcm90b2NvbC5kZXNjcmliZShrKSkuam9pbignLCAnKX1gO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBmb2xkIHRoaXMgaW50byB0aGUgY2hlY2sgYmVsb3cgLS0gZm9yIHRoYXQgb25lLCBldmVyeVxuICAgICAgLy8gcHJvdG9jb2wgbXVzdCBiZSB2YWxpZCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGFsbCBvZiB0aGVtLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBlbnN1cmUgdGhhdCBhdCBsZWFzdCBvbmUgb2Ygb3VyIGdlbmVyYXRlZCBsaXN0IGlzIHZhbGlkLlxuICAgICAgaWYgKHNlc3Npb25Qcm9wZXJ0aWVzLnB1Ymxpc2hlclByb3BlcnRpZXMuZW5hYmxlZCkge1xuICAgICAgICBpZiAodGhpcy5fYWREaXNhYmxlZFJlYXNvbikge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIHRyYW5zcG9ydCBwcm90b2NvbChzKSBmb3Igc2Vzc2lvbiB3aXRoIEd1YXJhbnRlZWQgTWVzc2FnaW5nIFB1Ymxpc2hlcicsXG4gICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0NPTkZMSUNULFxuICAgICAgICAgICAgdGhpcy5fYWREaXNhYmxlZFJlYXNvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQUQgd2FzIG5vdCBkaXNhYmxlZCBieSBoYXZpbmcgbm8gcHJvdG9jb2xzIGF2YWlsYWJsZVxuICAgICAgICBzZXNzaW9uUHJvcGVydGllcy53ZWJUcmFuc3BvcnRQcm90b2NvbExpc3QgPSB2YWxpZEZvckFEO1xuICAgICAgfVxuICAgICAgLy8gQSB2YWxpZCBwcm90b2NvbCBsaXN0IGlzIHJlYWR5IHRvIHVzZS5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlciBwcm92aWRlZCB0cmFuc3BvcnQgcHJvdG9jb2wgbGlzdFxuICAgICAgLy8gQ2hlY2sgZm9yIHBhcmFtZXRlciBjb25mbGljdCBiZXR3ZWVuIHNlc3Npb24gYW5kIHB1Ymxpc2hlclxuICAgICAgLy8gQWxyZWFkeSBjaGVja2VkIHRoZXNlIGZvciBwYXJhbWV0ZXIgY29uZmxpY3Q7IG9ubHkgb25lIHdpbGwgYmUgc2V0XG4gICAgICAvLyBBbHJlYWR5IGNoZWNrZWQgdGhhdCB1c2VyIGxpc3Qgd2FzIG5vdCBlbXB0eVxuICAgICAgY29uc3QgdHJhbnNwb3J0UHJvdG9jb2xzID0gc2Vzc2lvblByb3BlcnRpZXMud2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0O1xuICAgICAgY29uc3QgdmFsaWRGb3JBRCA9IHRyYW5zcG9ydFByb3RvY29scy5ldmVyeShpc1ZhbGlkQURUcmFuc3BvcnQpO1xuICAgICAgaWYgKCF2YWxpZEZvckFEKSB7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSB0cmFuc3BvcnRQcm90b2NvbHMuZmlsdGVyKHggPT4gIWlzVmFsaWRBRFRyYW5zcG9ydCh4KSk7XG4gICAgICAgIHRoaXMuX2FkRGlzYWJsZWRSZWFzb24gPSBgR3VhcmFudGVlZCBtZXNzYWdpbmcgaW5jb21wYXRpYmxlIHdpdGggc2VsZWN0ZWQgdHJhbnNwb3J0IHByb3RvY29sczogJHtcbiAgICAgICAgICBpbnZhbGlkLm1hcChrID0+IFRyYW5zcG9ydFByb3RvY29sLmRlc2NyaWJlKGspKS5qb2luKCcsICcpfWA7XG4gICAgICAgIGlmIChzZXNzaW9uUHJvcGVydGllcy5wdWJsaXNoZXJQcm9wZXJ0aWVzLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCB0cmFuc3BvcnQgcHJvdG9jb2wocykgZm9yIHNlc3Npb24gd2l0aCBHdWFyYW50ZWVkIE1lc3NhZ2luZyBQdWJsaXNoZXInLFxuICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVCxcbiAgICAgICAgICAgIHRoaXMuX2FkRGlzYWJsZWRSZWFzb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBBc3NpZ24gdGhlIGZpbmFsIHByb3BlcnRpZXMgYW5kIHN0YXJ0IHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzID0gc2Vzc2lvblByb3BlcnRpZXM7XG4gICAgdGhpcy5fc2Vzc2lvblN0YXRzID0gbmV3IFN0YXRzKCk7XG4gICAgdGhpcy5faG9zdHMgPSBuZXcgSG9zdExpc3Qoc2Vzc2lvblByb3BlcnRpZXMpO1xuICAgIHRoaXMuX3Nlc3Npb25GU00gPSBuZXcgU2Vzc2lvbkZTTShcbiAgICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMuX3Nlc3Npb25TdGF0cyxcbiAgICAgIHRoaXMuX2hvc3RzXG4gICAgKTtcbiAgICB0aGlzLl9zZXNzaW9uRlNNLnN0YXJ0KCk7XG4gICAgdGhpcy5fc2Vzc2lvbkZTTS5jcmVhdGVNZXNzYWdlUHVibGlzaGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9sbG93aW5nIGZpZWxkcyBhcmUgZGVzdHJveWVkIHdoZW4gZGlzY29ubmVjdCBpcyBjYWxsZWRcbiAgICAgKiBhbmQgcmVjcmVhdGVkIHdoZW4gY29ubmVjdCBpcyBjYWxsZWQgYWdhaW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vdXRzdGFuZGluZ0RhdGFSZXFzID0ge307XG4gICAgdGhpcy5fY2FwYWJpbGl0aWVzID0gRGVmYXVsdENhcGFiaWxpdGllcy5jcmVhdGVEZWZhdWx0Q2FwYWJpbGl0aWVzKCk7XG4gICAgdGhpcy5fc2VxTnVtID0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgc2Vzc2lvbiB0byB0aGUgU29sYWNlIE1lc3NhZ2UgUm91dGVyIGFzIGNvbmZpZ3VyZWQgaW5cbiAgICogdGhlIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdXJsfS5cbiAgICpcbiAgICogV2hlbiB0aGUgc2Vzc2lvbiBpcyBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvIHRoZSBTb2xhY2UgTWVzc2FnZSBSb3V0ZXIsIHRoZVxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUjVVBfTk9USUNFfSBldmVudCBpcyBlbWl0dGVkIGlmIGEgbGlzdGVuZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSWYge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNyZWFwcGx5U3Vic2NyaXB0aW9uc30gaXMgc2V0IHRvIHRydWUsIHRoaXMgb3BlcmF0aW9uXG4gICAqIHJlLXJlZ2lzdGVycyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgc3Vic2NyaXB0aW9ucy4gVGhlIGNvbm5lY3RlZCBzZXNzaW9uIGV2ZW50XG4gICAqICh7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUjZXZlbnQ6VVBfTk9USUNFfSkgaXMgZW1pdHRlZCBvbmx5IHdoZW4gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFyZSBzdWNjZXNzZnVsbHkgYWRkZWQgdG8gdGhlIHJvdXRlci5cbiAgICpcbiAgICogSWYgdGhlIEFQSSBpcyB1bmFibGUgdG8gY29ubmVjdCB3aXRoaW4ge0BsaW5rIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcyNjb25uZWN0VGltZW91dEluTXNlY3N9XG4gICAqIG9yIGR1ZSB0byBsb2dpbiBmYWlsdXJlcywgdGhlIHNlc3Npb24ncyBzdGF0ZSB0cmFuc2l0aW9ucyBiYWNrIHRvICdkaXNjb25uZWN0ZWQnIGFuZCBhbiBldmVudFxuICAgKiBpcyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqICoqTm90ZToqKiBCZWZvcmUgdGhlIHNlc3Npb24ncyBzdGF0ZSB0cmFuc2l0aW9ucyB0byAnY29ubmVjdGVkJywgYSBjbGllbnRcbiAgICogYXBwbGljYXRpb24gY2Fubm90IHVzZSB0aGUgc2Vzc2lvbjsgYW55IGF0dGVtcHQgdG8gY2FsbCBmdW5jdGlvbnMgd2lsbCB0aHJvd1xuICAgKiB7QGxpbmsgc29sYWNlLk9wZXJhdGlvbkVycm9yfS5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkLCBhbHJlYWR5IGNvbm5lY3RlZCBvciBjb25uZWN0aW5nLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfS5cbiAgICogKiBpZiB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQgY2Fubm90IGJlIGVzdGFibGlzaGVkLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1J9LlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG93T3BlcmF0aW9uKFNlc3Npb25PcGVyYXRpb24uQ09OTkVDVCk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKHJlc3VsdCwgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgc0V2ZW50ID0gbmV3IFNlc3Npb25GU01FdmVudCh7IG5hbWU6IFNlc3Npb25FdmVudE5hbWUuQ09OTkVDVCB9KTtcbiAgICB0aGlzLl9zZXNzaW9uRlNNLnByb2Nlc3NFdmVudChzRXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzZXNzaW9uIGNhbiBiZSB1c2VkIHRvIGFja25vbHdlZGdlIGEgbWVzc2FnZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBjYW5BY2soKSB7XG4gICAgLypcbiAgICAgKiBJZiB0aGUgdXNlciB3YW50cyB0byBhY2sgYSBtZXNzYWdlLCBpdCB3YXMgcmVjZWl2ZWQgb24gYSBzZXNzaW9uIChlbHNlIGFjayB3aWxsIHRocm93KSxcbiAgICAgKiBhbmQgc28gd2Uga25vdyB0aGF0IHRoZSBzZXNzaW9uIHdhcyBjb25uZWN0ZWQgYXQgc29tZSBwb2ludC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzZXNzaW9uIGlzIGluIGFueSBvZiB0aGUgZm9sbG93aW5nIHN0YXRlcywgd2Uga25vdyBpdCBpcyBlaXRoZXIgY29ubmVjdGluZyBvclxuICAgICAqIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHdlIGtub3cgdGhlIHNlc3Npb24gd2FzIHByZXZpb3VzbHkgY29ubmVjdGVkLCB0aGlzIGltcGxpZXMgdGhlIHNlc3Npb24gaXMgZWl0aGVyXG4gICAgICogUkVDT05ORUNUSU5HIG9yIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIFdlIGFsbG93IGFja3Mgd2hlbiB0aGUgc2Vzc2lvbiBpcyByZWNvbm5lY3Rpbmcgb3IgY29ubmVjdGVkLlxuICAgICAqXG4gICAgICogVE9ETzogT3B0aW1pc3RpY2FsbHksIHdlIGFsbG93IGFja3Mgb24gYSBkaXNjb25uZWN0aW5nIHNlc3Npb24sIG9uIHRoZSB0aGVvcnkgdGhhdCBpdFxuICAgICAqIHdpbGwgYmUgcmVjb25uZWN0YWJsZS5cbiAgICAgKi9cbiAgICBjb25zdCBzdGF0ZXNDYW5BY2sgPSBbXG4gICAgICBTZXNzaW9uU3RhdGVOYW1lLkNPTk5FQ1RJTkcsXG4gICAgICBTZXNzaW9uU3RhdGVOYW1lLlRSQU5TUE9SVF9VUCxcbiAgICAgIFNlc3Npb25TdGF0ZU5hbWUuRElTQ09OTkVDVElORywgLy8gVE9ETzogTm90IHN1cmUgaWYgd2Ugc2hvdWxkIGFsbG93IHRoaXNcbiAgICBdO1xuICAgIC8vIEFsbG93IGFjayBpZiB0aGVyZSBpcyBzb21lIGFjY2VwdGFibGUgc3RhdGUgbmFtZSBzdWNoIHRoYXQgZ2V0QWN0aXZlU3RhdGUgcmV0dXJucyB0aGUgc3RhdGUuXG4gICAgcmV0dXJuIHN0YXRlc0NhbkFjay5zb21lKHN0YXRlTmFtZSA9PiAhIXRoaXMuX3Nlc3Npb25GU00uZ2V0QWN0aXZlU3RhdGUoc3RhdGVOYW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIHNlc3Npb24uIFRoZSBzZXNzaW9uIGF0dGVtcHRzIHRvIGRpc2Nvbm5lY3QgY2xlYW5seSwgY29uY2x1ZGluZyBhbGwgb3BlcmF0aW9uc1xuICAgKiBpbiBwcm9ncmVzcy4gVGhlIGRpc2Nvbm5lY3RlZCBzZXNzaW9uIGV2ZW50IHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpESVNDT05ORUNURUR9XG4gICAqIGlzIGVtaXR0ZWQgd2hlbiB0aGVzZSBvcGVyYXRpb25zIGNvbXBsZXRlIGFuZCB0aGUgc2Vzc2lvbiBoYXMgY29tcGxldGVseSBkaXNjb25uZWN0ZWQuXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdGhlIHNlc3Npb24gaXMgZGlzcG9zZWQsIG9yIGhhcyBuZXZlciBiZWVuIGNvbm5lY3RlZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb3dPcGVyYXRpb24oU2Vzc2lvbk9wZXJhdGlvbi5ESVNDT05ORUNUKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IocmVzdWx0LCBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04sIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBzRXZlbnQgPSBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5ESVNDT05ORUNUIH0pO1xuICAgIHRoaXMuX3Nlc3Npb25GU00ucHJvY2Vzc0V2ZW50KHNFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZSBhbGwgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2Vzc2lvbi5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gY2FsbCBkaXNjb25uZWN0KCkgZmlyc3QgZm9yIHByb3BlciBoYW5kc2hha2Ugd2l0aCB0aGUgbWVzc2FnZS1yb3V0ZXIuXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkgcmV0dXJuO1xuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIHRoaXMuX3Nlc3Npb25GU00ucHJvY2Vzc0V2ZW50KFxuICAgICAgICBuZXcgU2Vzc2lvbkZTTUV2ZW50KHsgbmFtZTogU2Vzc2lvbkV2ZW50TmFtZS5ESVNQT1NFIH0pXG4gICAgICApOyAvLyB5aWVsZCBmb3IgZGlzY29ubmVjdCBpZiBhbnlcbiAgICAgIHRoaXMuX3Nlc3Npb25GU00udGVybWluYXRlRnNtKCk7XG4gICAgICB0aGlzLmRpc2FibGVFbWl0dGVyKCk7XG4gICAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgdG9waWMsIG9wdGlvbmFsbHkgcmVxdWVzdGluZyBhIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSByb3V0ZXIuXG4gICAqXG4gICAqIElmIHJlcXVlc3RDb25maXJtYXRpb24gaXMgc2V0IHRvIHRydWU6XG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZS5TVUJTQ1JJUFRJT05fT0t9IGlzIGdlbmVyYXRlZCB3aGVuIHN1YnNjcmlwdGlvbiBpc1xuICAgKiBhZGRlZCBzdWNjZXNzZnVsbHk7IG90aGVyd2lzZSwgc2Vzc2lvbiBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SfSBpcyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIElmIHJlcXVlc3RDb25maXJtYXRpb24gaXMgc2V0IHRvIGZhbHNlLCBvbmx5IHNlc3Npb24gZXZlbnRcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLlNVQlNDUklQVElPTl9FUlJPUn0gaXMgZ2VuZXJhdGVkIHVwb24gZmFpbHVyZS5cbiAgICpcbiAgICogV2hlbiB0aGUgYXBwbGljYXRpb24gcmVjZWl2ZXMgc2Vzc2lvbiBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SfSwgaXRcbiAgICogY2FuIG9idGFpbiB0aGUgZmFpbGVkIHRvcGljIHN1YnNjcmlwdGlvbiBieSBjYWxsaW5nXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50I3JlYXNvbn0uXG4gICAqIFRoZSByZXR1cm5lZCBzdHJpbmcgaXMgaW4gdGhlIGZvcm1hdCBvZiBcIlRvcGljOiA8ZmFpbGVkIHRvcGljIHN1YnNjcmlwdGlvbj5cIi5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuRGVzdGluYXRpb259IHRvcGljIFRoZSB0b3BpYyBkZXN0aW5hdGlvbiBzdWJzY3JpcHRpb24gdG8gYWRkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVlc3RDb25maXJtYXRpb24gdHJ1ZSwgdG8gcmVxdWVzdCBhIGNvbmZpcm1hdGlvbjsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29ycmVsYXRpb25LZXkgSWYgc3BlY2lmaWVkLCBhbmQgaWYgcmVxdWVzdENvbmZpcm1hdGlvbiBpcyB0cnVlLCB0aGlzIHZhbHVlIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2hvZWQgaW4gdGhlIHNlc3Npb24gZXZlbnQgd2l0aGluIHtAbGluayBTZXNzaW9uRXZlbnR9LlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVxdWVzdFRpbWVvdXQgVGhlIHJlcXVlc3QgdGltZW91dCBwZXJpb2QgKGluIG1pbGxpc2Vjb25kcykuIElmIHNwZWNpZmllZCwgdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgb3ZlcndyaXRlcyByZWFkVGltZW91dEluTXNlY3MgcHJvcGVydHkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBTZXNzaW9uUHJvcGVydGllc30uXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn1cbiAgICogKiBpZiB0aGUgc2Vzc2lvbiBpcyBkaXNwb3NlZCBvciBkaXNjb25uZWN0ZWQuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB0eXBlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB2YWx1ZS5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFfS5cbiAgICogKiBpZiB0aGUgdG9waWMgaGFzIGludmFsaWQgc3ludGF4LlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfVE9QSUNfU1lOVEFYfS5cbiAgICogKiBpZiB0aGVyZSdzIG5vIHNwYWNlIGluIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0V9LiAgU2VlOlxuICAgKiAgIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9LlxuICAgKi9cbiAgc3Vic2NyaWJlKHRvcGljLCByZXF1ZXN0Q29uZmlybWF0aW9uLCBjb3JyZWxhdGlvbktleSwgcmVxdWVzdFRpbWVvdXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG93T3BlcmF0aW9uKFNlc3Npb25PcGVyYXRpb24uQ1RSTCk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKHJlc3VsdCwgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgUGFyYW1ldGVyLmlzSW5zdGFuY2VPZigndG9waWMnLCB0b3BpYywgRGVzdGluYXRpb25MaWIuRGVzdGluYXRpb24pO1xuICAgIHRvcGljLnZhbGlkYXRlKCk7XG4gICAgaWYgKHRvcGljLmdldFR5cGUoKSAhPT0gRGVzdGluYXRpb25MaWIuRGVzdGluYXRpb25UeXBlLlRPUElDKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYFRvcGljIGlzIHJlcXVpcmVkIGZvciBzdWJzY3JpYmU7ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVzdGluYXRpb25MaWIuRGVzdGluYXRpb25UeXBlLmRlc2NyaWJlKHRvcGljLmdldFR5cGUoKSl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5WQUxJRF9UT1BJQ19TWU5UQVgpO1xuICAgIH1cblxuICAgIFBhcmFtZXRlci5pc0Jvb2xlYW5Pck5vdGhpbmcoJ3JlcXVlc3RDb25maXJtYXRpb24nLCByZXF1ZXN0Q29uZmlybWF0aW9uKTtcbiAgICBQYXJhbWV0ZXIuaXNOdW1iZXJPck5vdGhpbmcoJ3JlcXVlc3RUaW1lb3V0JywgcmVxdWVzdFRpbWVvdXQpO1xuICAgIFBhcmFtZXRlci5pc1JhbmdlQ29tcGFyZU9yTm90aGluZygncmVxdWVzdFRpbWVvdXQnLCByZXF1ZXN0VGltZW91dCwgJz4nLCAwKTtcblxuICAgIHRoaXMuX3Nlc3Npb25GU00uc3Vic2NyaXB0aW9uVXBkYXRlKFxuICAgICAgdG9waWMsXG4gICAgICAhIXJlcXVlc3RDb25maXJtYXRpb24sXG4gICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgICAgU2Vzc2lvblJlcXVlc3RUeXBlLkFERF9TVUJTQ1JJUFRJT04sXG4gICAgICAocnhNc2dPYmosIGNhbmNlbGxlZFJlcXVlc3QpID0+XG4gICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlUmVzcG9uc2UocnhNc2dPYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q29uZmlybWF0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhIHRvcGljLCBhbmQgb3B0aW9uYWxseSByZXF1ZXN0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHJvdXRlci5cbiAgICpcbiAgICogSWYgcmVxdWVzdENvbmZpcm1hdGlvbiBpcyBzZXQgdG8gdHJ1ZSwgc2Vzc2lvbiBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX09LfSBpcyBnZW5lcmF0ZWQgd2hlbiBzdWJzY3JpcHRpb24gaXMgcmVtb3ZlZFxuICAgKiBzdWNjZXNzZnVsbHk7IG90aGVyd2lzZSwgc2Vzc2lvbiBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SfSBpcyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIElmIHJlcXVlc3RDb25maXJtYXRpb24gaXMgc2V0IHRvIGZhbHNlLCBvbmx5IHNlc3Npb24gZXZlbnRcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLlNVQlNDUklQVElPTl9FUlJPUn0gaXMgZ2VuZXJhdGVkIHVwb24gZmFpbHVyZS5cbiAgICpcbiAgICogV2hlbiB0aGUgYXBwbGljYXRpb24gcmVjZWl2ZXMgc2Vzc2lvbiBldmVudFxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SfSwgaXRcbiAgICogY2FuIG9idGFpbiB0aGUgZmFpbGVkIHRvcGljIHN1YnNjcmlwdGlvbiBieSBjYWxsaW5nXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50I3JlYXNvbn0uIFRoZSByZXR1cm5lZFxuICAgKiBzdHJpbmcgaXMgaW4gdGhlIGZvcm1hdCBcIlRvcGljOiA8ZmFpbGVkIHRvcGljIHN1YnNjcmlwdGlvbj5cIi5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuRGVzdGluYXRpb259IHRvcGljIFRoZSB0b3BpYyBkZXN0aW5hdGlvbiBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVlc3RDb25maXJtYXRpb24gdHJ1ZSwgdG8gcmVxdWVzdCBhIGNvbmZpcm1hdGlvbjsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29ycmVsYXRpb25LZXkgSWYgPGNvZGU+bnVsbDwvY29kZT4gb3IgdW5kZWZpbmVkLCBhIENvcnJlbGF0aW9uIEtleSBpcyBub3Qgc2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgY29uZmlybWF0aW9uIHNlc3Npb24gZXZlbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXF1ZXN0VGltZW91dCBUaGUgcmVxdWVzdCB0aW1lb3V0IHBlcmlvZCAoaW4gbWlsbGlzZWNvbmRzKS4gSWYgc3BlY2lmaWVkLCB0aGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvdmVyd3JpdGVzIHJlYWRUaW1lb3V0SW5Nc2VjcyBwcm9wZXJ0eSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIFNlc3Npb25Qcm9wZXJ0aWVzfS5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkIG9yIGRpc2Nvbm5lY3RlZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHZhbHVlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0V9LlxuICAgKiAqIGlmIHRoZSB0b3BpYyBoYXMgaW52YWxpZCBzeW50YXguXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9UT1BJQ19TWU5UQVh9LlxuICAgKiAqIGlmIHRoZXJlJ3Mgbm8gc3BhY2UgaW4gdGhlIHRyYW5zcG9ydCB0byBzZW5kIHRoZSByZXF1ZXN0LlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOU1VGRklDSUVOVF9TUEFDRX0uICBTZWU6XG4gICAqICAge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI2V2ZW50OkNBTl9BQ0NFUFRfREFUQX0uXG4gICAqL1xuICB1bnN1YnNjcmliZSh0b3BpYywgcmVxdWVzdENvbmZpcm1hdGlvbiwgY29ycmVsYXRpb25LZXksIHJlcXVlc3RUaW1lb3V0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvd09wZXJhdGlvbihTZXNzaW9uT3BlcmF0aW9uLkNUUkwpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuICAgIFBhcmFtZXRlci5pc0luc3RhbmNlT2YoJ3RvcGljJywgdG9waWMsIERlc3RpbmF0aW9uTGliLkRlc3RpbmF0aW9uKTtcbiAgICB0b3BpYy52YWxpZGF0ZSgpO1xuICAgIGlmICh0b3BpYy5nZXRUeXBlKCkgIT09IERlc3RpbmF0aW9uTGliLkRlc3RpbmF0aW9uVHlwZS5UT1BJQykge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBUb3BpYyBpcyByZXF1aXJlZCBmb3IgdW5zdWJzY3JpYmU7ICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVzdGluYXRpb25MaWIuRGVzdGluYXRpb25UeXBlLmRlc2NyaWJlKHRvcGljLmdldFR5cGUoKSl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5WQUxJRF9UT1BJQ19TWU5UQVgpO1xuICAgIH1cblxuICAgIFBhcmFtZXRlci5pc0Jvb2xlYW5Pck5vdGhpbmcoJ3JlcXVlc3RDb25maXJtYXRpb24nLCByZXF1ZXN0Q29uZmlybWF0aW9uKTtcbiAgICBQYXJhbWV0ZXIuaXNOdW1iZXJPck5vdGhpbmcoJ3JlcXVlc3RUaW1lb3V0JywgcmVxdWVzdFRpbWVvdXQpO1xuICAgIFBhcmFtZXRlci5pc1JhbmdlQ29tcGFyZU9yTm90aGluZygncmVxdWVzdFRpbWVvdXQnLCByZXF1ZXN0VGltZW91dCwgJz4nLCAwKTtcblxuICAgIHRoaXMuX3Nlc3Npb25GU00uc3Vic2NyaXB0aW9uVXBkYXRlKFxuICAgICAgdG9waWMsXG4gICAgICAhIXJlcXVlc3RDb25maXJtYXRpb24sXG4gICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgICAgU2Vzc2lvblJlcXVlc3RUeXBlLlJFTU9WRV9TVUJTQ1JJUFRJT04sXG4gICAgICAocnhNc2dPYmosIGNhbmNlbGxlZFJlcXVlc3QpID0+XG4gICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlUmVzcG9uc2UocnhNc2dPYmosXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q29uZmlybWF0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IGEgRHVyYWJsZSBUb3BpYyBFbmRwb2ludCBzdG9wIHJlY2VpdmluZyBkYXRhIG9uIGEgdG9waWMuIFVuc3Vic2NyaWJlXG4gICAqIHJlcXVlc3RzIGFyZSBvbmx5IGFsbG93ZWQgYnkgdGhlIHJvdXRlciB3aGVuIG5vIGNsaWVudHMgYXJlIGJvdW5kIHRvIHRoZSBEVEUuXG4gICAqIElmIHRoZSB1bnVic2NyaWJlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCwgdGhlIERURSB3aWxsIHN0b3AgYXR0cmFjdGluZyBtZXNzYWdlcyxcbiAgICogYW5kIGFsbCBtZXNzYWdlcyBzcG9vbGVkIHRvIHRoZSBEVEUgd2lsbCBiZSBkZWxldGVkLlxuICAgKlxuICAgKiB7QGxpbmsgc29sYWNlLlNlc3Npb25FdmVudENvZGUuVU5TVUJTQ1JJQkVfVEVfVE9QSUNfT0t9IGlzIGdlbmVyYXRlZCB3aGVuIHRoZVxuICAgKiBzdWJzY3JpcHRpb24gaXMgcmVtb3ZlZCBzdWNjZXNzZnVsbHk7IG90aGVyd2lzZSxcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLlVOU1VCU0NSSUJFX1RFX1RPUElDX0VSUk9SfSBpcyBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIFdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlY2VpdmVzIHNlc3Npb24gZXZlbnRcbiAgICoge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLlVOU1VCU0NSSUJFX1RFX1RPUElDX0VSUk9SfSwgaXRcbiAgICogY2FuIG9idGFpbiB0aGUgZmFpbGVkIHRvcGljIHN1YnNjcmlwdGlvbiBieSBjYWxsaW5nXG4gICAqIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50I3JlYXNvbn0uXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yfHNvbGFjZS5RdWV1ZURlc2NyaXB0b3J9IHF1ZXVlRGVzY3JpcHRvciBBIGRlc2NyaXB0aW9uXG4gICAqICBvZiB0aGUgcXVldWUgdG8gd2hpY2ggdGhlIHRvcGljIGlzIHN1YnNjcmliZWQuXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn1cbiAgICogKiBpZiB0aGUgc2Vzc2lvbiBpcyBkaXNwb3NlZCBvciBkaXNjb25uZWN0ZWQuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB0eXBlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB2YWx1ZS5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFfS5cbiAgICogKiBpZiB0aGVyZSdzIG5vIHNwYWNlIGluIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0V9LiAgU2VlOlxuICAgKiAgIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9LlxuICAgKi9cbiAgdW5zdWJzY3JpYmVEdXJhYmxlVG9waWNFbmRwb2ludChxdWV1ZURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG93T3BlcmF0aW9uKFNlc3Npb25PcGVyYXRpb24uQ1RSTCk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKHJlc3VsdCwgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgLy8gZW11bGF0ZSBzdWJzY3JpcHRpb25cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuY3JlYXRlRGVzdGluYXRpb25Gcm9tRGVzY3JpcHRvcihcbiAgICAgIFF1ZXVlRGVzY3JpcHRvci5jcmVhdGVGcm9tU3BlYyhxdWV1ZURlc2NyaXB0b3IpKTtcbiAgICBjb25zdCByZXF1ZXN0Q29uZmlybWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXNzaW9uRlNNLnN1YnNjcmlwdGlvblVwZGF0ZShcbiAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgcmVxdWVzdENvbmZpcm1hdGlvbixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIFNlc3Npb25SZXF1ZXN0VHlwZS5SRU1PVkVfRFRFX1NVQlNDUklQVElPTixcbiAgICAgIChyeE1zZ09iaiwgY2FuY2VsbGVkUmVxdWVzdCkgPT5cbiAgICAgICAgdGhpcy5oYW5kbGVEVEVVbnN1YnNjcmliZVJlc3BvbnNlKHJ4TXNnT2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkUmVxdWVzdCkpO1xuICB9XG5cblxuICAvKipcbiAgICogTW9kaWZ5IGEgc2Vzc2lvbiBwcm9wZXJ0eSBhZnRlciBjcmVhdGlvbiBvZiB0aGUgc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtNdXRhYmxlU2Vzc2lvblByb3BlcnR5fSBtdXRhYmxlU2Vzc2lvblByb3BlcnR5IFRoZSBwcm9wZXJ0eSBrZXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgVGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcXVlc3RUaW1lb3V0IFRoZSByZXF1ZXN0IHRpbWVvdXQgcGVyaW9kIChpbiBtaWxsaXNlY29uZHMpLiBJZiBzcGVjaWZpZWQsIGl0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdGVzIHJlYWRUaW1lb3V0SW5Nc2Vjc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29ycmVsYXRpb25LZXkgSWYgc3BlY2lmaWVkLCB0aGlzIHZhbHVlIGlzIGVjaG9lZCBpbiB0aGUgc2Vzc2lvbiBldmVudCB3aXRoaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBTZXNzaW9uRXZlbnR9IHByb3BlcnR5IGluIHtAbGluayBTZXNzaW9uUHJvcGVydGllc31cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkIG9yIGRpc2Nvbm5lY3RlZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHZhbHVlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0V9LlxuICAgKiAqIGlmIHRoZXJlJ3Mgbm8gc3BhY2UgaW4gdGhlIHRyYW5zcG9ydCB0byBzZW5kIHRoZSByZXF1ZXN0LlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOU1VGRklDSUVOVF9TUEFDRX0uICBTZWU6XG4gICAqICAge0BsaW5rIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlI2V2ZW50OkNBTl9BQ0NFUFRfREFUQX0uXG4gICAqL1xuICB1cGRhdGVQcm9wZXJ0eShtdXRhYmxlU2Vzc2lvblByb3BlcnR5LCBuZXdWYWx1ZSwgcmVxdWVzdFRpbWVvdXQsIGNvcnJlbGF0aW9uS2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvd09wZXJhdGlvbihTZXNzaW9uT3BlcmF0aW9uLkNUUkwpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IHsgVG9waWMgfSA9IERlc3RpbmF0aW9uTGliO1xuXG4gICAgTE9HX1RSQUNFKCdVcGRhdGluZyBwcm9wZXJ0eSAnLCBtdXRhYmxlU2Vzc2lvblByb3BlcnR5LCBuZXdWYWx1ZSk7XG5cbiAgICBQYXJhbWV0ZXIuaXNFbnVtTWVtYmVyKCdtdXRhYmxlU2Vzc2lvblByb3BlcnR5JywgbXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSwgTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSk7XG5cbiAgICBQYXJhbWV0ZXIuaXNOdW1iZXJPck5vdGhpbmcoJ3JlcXVlc3RUaW1lb3V0JywgcmVxdWVzdFRpbWVvdXQpO1xuICAgIFBhcmFtZXRlci5pc1JhbmdlQ29tcGFyZU9yTm90aGluZygncmVxdWVzdFRpbWVvdXQnLCByZXF1ZXN0VGltZW91dCwgJz4nLCAwKTtcblxuICAgIGxldCBzZXNzaW9uRXZlbnQ7XG4gICAgLypcbiAgICAgUmVzcG9uc2UgQ0IgdG8gdGhlIENMSUVOVENUUkwgVVBEQVRFIHJlc3BvbnNlXG5cbiAgICAgVGhpcyBpcyBwcmV0dHkgY29tcGxpY2F0ZWQ6IHdlIGRlZmluZSB0aGUgd2hvbGUgcHJvY2VzcyBpbiBoZXJlXG4gICAgIHVzaW5nIGNhbGxiYWNrcyB0byBwcmVzZXJ2ZSBzdGF0ZSBzdWNoIGFzIHRoZSBjb3JyZWxhdGlvbktleSBvZiB0aGUgdXNlclxuICAgICByZXF1ZXN0LlxuICAgICBUaGF0IGlzLCB0aGlzIGVudGlyZSBtdWx0aS1zdGVwIHByb2Nlc3MgZXhlY3V0ZXMgdW5kZXIgdGhlIGNvbnRleHQgb2YgdGhhdCBvbmUgY2FsbCB0b1xuICAgICB1cGRhdGVQcm9wZXJ0eSB3aXRoIGEgc2luZ2xlIGNvcnJlbGF0aW9uS2V5IHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0IHJlc3BvbnNlQ2FsbGJhY2sgPSAocmVzcE1zZykgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwTXNnLmdldFJlc3BvbnNlKCk7XG4gICAgICBpZiAocmVzcG9uc2UucmVzcG9uc2VDb2RlID09PSAyMDApIHtcbiAgICAgICAgaWYgKG11dGFibGVTZXNzaW9uUHJvcGVydHkgPT09IE11dGFibGVTZXNzaW9uUHJvcGVydHkuQ0xJRU5UX0RFU0NSSVBUSU9OKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHByb3BlcnR5IGFuZCBub3RpZnkgY2xpZW50XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuYXBwbGljYXRpb25EZXNjcmlwdGlvbiA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLlBST1BFUlRZX1VQREFURV9PSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzcG9uc2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgICAgIHRoaXMuc2VuZEV2ZW50KHNlc3Npb25FdmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobXV0YWJsZVNlc3Npb25Qcm9wZXJ0eSA9PT0gTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eS5DTElFTlRfTkFNRSkge1xuICAgICAgICAgIC8vIHJlcGxhY2UgUDJQIHN1YnNjcmlwdGlvbjogUkVNIGFuZCBBRERcbiAgICAgICAgICBjb25zdCBvbGRQMnBUb3BpY05hbWUgPSBQMlBVdGlsLmdldFAyUFRvcGljU3Vic2NyaXB0aW9uKFxuICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucDJwSW5ib3hCYXNlKTtcbiAgICAgICAgICBjb25zdCBvbGRQMnBUb3BpYyA9IFRvcGljLmNyZWF0ZUZyb21OYW1lKG9sZFAycFRvcGljTmFtZSk7XG5cbiAgICAgICAgICBjb25zdCBuZXdQMnBUb3BpY05hbWUgPSBQMlBVdGlsLmdldFAyUFRvcGljU3Vic2NyaXB0aW9uKFxuICAgICAgICAgICAgcmVzcE1zZy5nZXRQMlBUb3BpY1ZhbHVlKCkpO1xuICAgICAgICAgIGNvbnN0IG5ld1AycFRvcGljID0gVG9waWMuY3JlYXRlRnJvbU5hbWUobmV3UDJwVG9waWNOYW1lKTtcblxuICAgICAgICAgIGNvbnN0IGFmdGVyQWRkQ2FsbGJhY2sgPSAoc21wUmVzcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHNtcFJlc3AuZ2V0UmVzcG9uc2UoKTtcbiAgICAgICAgICAgIGlmIChyZXNwLnJlc3BvbnNlQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIC8vIG5vdGlmeSBjbGllbnRcbiAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuX3NldFAycEluYm94QmFzZShyZXNwTXNnLmdldFAyUFRvcGljVmFsdWUoKSB8fCAnJyk7XG4gICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLl9zZXRQMnBJbmJveEluVXNlKFxuICAgICAgICAgICAgICAgIFAyUFV0aWwuZ2V0UDJQSW5ib3hUb3BpYyh0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5wMnBJbmJveEJhc2UpKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuY2xpZW50TmFtZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICBzZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5QUk9QRVJUWV9VUERBVEVfT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3BvbnNlU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yU3ViY29kZSA9IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyLmdldEVycm9yU3ViY29kZShyZXNwLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VTdHJpbmcpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0FMUkVBRFlfUFJFU0VOVCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuaWdub3JlRHVwbGljYXRlU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICAgICAgICAgICAgc2Vzc2lvbkV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFNlc3Npb25FdmVudENvZGUuUFJPUEVSVFlfVVBEQVRFX09LLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3BvbnNlU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEV2ZW50KHNlc3Npb25FdmVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0FMUkVBRFlfUFJFU0VOVCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9PT0gRXJyb3JTdWJjb2RlLlNVQlNDUklQVElPTl9BVFRSSUJVVEVTX0NPTkZMSUNUIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0lOVkFMSUQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclN1YmNvZGUgPT09IEVycm9yU3ViY29kZS5TVUJTQ1JJUFRJT05fQUNMX0RFTklFRCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9PT0gRXJyb3JTdWJjb2RlLlNVQlNDUklQVElPTl9UT09fTUFOWSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBjbGllbnRcbiAgICAgICAgICAgICAgICBzZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5QUk9QRVJUWV9VUERBVEVfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclN1YmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFdmVudChzZXNzaW9uRXZlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBjbGllbnRcbiAgICAgICAgICAgICAgICBzZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5QUk9QRVJUWV9VUERBVEVfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0VSUk9SX09USEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBhZnRlclJlbW92ZUNhbGxiYWNrID0gKHNtcFJlc3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBzbXBSZXNwLmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICBpZiAocmVzcC5yZXNwb25zZUNvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAvLyBzZWNvbmQgYWRkIG5ldyBQMlBcbiAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbkZTTS5zdWJzY3JpcHRpb25VcGRhdGUobmV3UDJwVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAgICAgIC8vIHJlcXVlc3QgY29uZmlybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMucmVhZFRpbWVvdXRJbk1zZWNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXNzaW9uUmVxdWVzdFR5cGUuQUREX1AyUElOQk9YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckFkZENhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yU3ViY29kZSA9IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyLmdldEVycm9yU3ViY29kZShyZXNwLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AucmVzcG9uc2VTdHJpbmcpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX05PVF9GT1VORCAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuaWdub3JlU3Vic2NyaXB0aW9uTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBuZXcgUDJQIGFueXdheTogdGhlIGVycm9yIGlzIHNpbXBseSB0aGUgb2xkIFAyUFxuICAgICAgICAgICAgICAgIC8vIHdhcyBub3QgZm91bmQgb24gcmVtb3ZlLiAgSXQncyBub3RhYmxlIHRob3VnaC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uRlNNLnN1YnNjcmlwdGlvblVwZGF0ZShuZXdQMnBUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAgICAgICAvLyByZXF1ZXN0IGNvbmZpcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5yZWFkVGltZW91dEluTXNlY3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2Vzc2lvblJlcXVlc3RUeXBlLkFERF9QMlBJTkJPWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckFkZENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvclN1YmNvZGUgPT09IEVycm9yU3ViY29kZS5TVUJTQ1JJUFRJT05fQVRUUklCVVRFU19DT05GTElDVCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9PT0gRXJyb3JTdWJjb2RlLlNVQlNDUklQVElPTl9JTlZBTElEIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX05PVF9GT1VORCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSA9PT0gRXJyb3JTdWJjb2RlLlNVQlNDUklQVElPTl9BQ0xfREVOSUVEKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IGNsaWVudFxuICAgICAgICAgICAgICAgIHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLlBST1BFUlRZX1VQREFURV9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXNwb25zZVN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcC5yZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3ViY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICAgICAgICAgICAgc2Vzc2lvbkV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFNlc3Npb25FdmVudENvZGUuUFJPUEVSVFlfVVBEQVRFX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3BvbnNlU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlNVQlNDUklQVElPTl9FUlJPUl9PVEhFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBmaXJzdCByZW1vdmUgb2xkIFAyUFxuICAgICAgICAgIHRoaXMuX3Nlc3Npb25GU00uc3Vic2NyaXB0aW9uVXBkYXRlKG9sZFAycFRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsICAgICAgIC8vIHJlcXVlc3QgY29uZmlybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLnJlYWRUaW1lb3V0SW5Nc2VjcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXNzaW9uUmVxdWVzdFR5cGUuUkVNT1ZFX1AyUElOQk9YLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyUmVtb3ZlQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RpZnkgY2xpZW50IGVycm9yXG4gICAgICAgIGNvbnN0IGVycm9yU3ViY29kZSA9IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyLmdldEVycm9yU3ViY29kZShyZXNwb25zZS5yZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZVN0cmluZyk7XG4gICAgICAgIHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLlBST1BFUlRZX1VQREFURV9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3BvbnNlU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JTdWJjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgIH1cbiAgICB9OyAvLyBlbmQgQ0IgKHJlc3BvbnNlIHRvIFVQREFURSByZXF1ZXN0KVxuXG4gICAgY29uc3QgcmV0dXJuQ29kZSA9IHRoaXMuX3Nlc3Npb25GU00uc2VuZFVwZGF0ZVByb3BlcnR5KG11dGFibGVTZXNzaW9uUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ2FsbGJhY2spO1xuICAgIGlmIChyZXR1cm5Db2RlICE9PSBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LKSB7XG4gICAgICAgICAgLy8gZG8gbm90IGNoYW5nZSBzZXNzaW9uIHN0YXRlXG5cbiAgICAgIGlmIChyZXR1cm5Db2RlID09PSBUcmFuc3BvcnRSZXR1cm5Db2RlLk5PX1NQQUNFKSB7XG4gICAgICAgIHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChTZXNzaW9uRXZlbnRDb2RlLlBST1BFUlRZX1VQREFURV9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdQcm9wZXJ0eSB1cGRhdGUgZmFpbGVkIC0gbm8gc3BhY2UgaW4gdHJhbnNwb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuSU5TVUZGSUNJRU5UX1NQQUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vzc2lvbkV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFNlc3Npb25FdmVudENvZGUuUFJPUEVSVFlfVVBEQVRFX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Byb3BlcnR5IHVwZGF0ZSBmYWlsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VuZEV2ZW50KHNlc3Npb25FdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggKHNlbmQpIGEgbWVzc2FnZSBvdmVyIHRoZSBzZXNzaW9uLiBUaGUgbWVzc2FnZSBpcyBzZW50IHRvIGl0cyBzZXQgZGVzdGluYXRpb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIHNlbmRpbmcgYm90aCBkaXJlY3QgYW5kIEd1YXJhbnRlZWQgTWVzc2FnZXMuICBJZiB0aGUgbWVzc2FnZSdzXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGV9IGlzIHtAbGluayBzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUfSwgdGhlXG4gICAqIG1lc3NhZ2UgaXMgYSBkaXJlY3QgbWVzc2FnZTsgb3RoZXJ3aXNlLCBpdCBpcyBhIGd1YXJhbnRlZWQgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuTWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzZW5kLiBJdCBtdXN0IGhhdmUgYSBkZXN0aW5hdGlvbiBzZXQuXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn1cbiAgICogKiBpZiB0aGUgc2Vzc2lvbiBpcyBkaXNwb3NlZCBvciBkaXNjb25uZWN0ZWQuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB0eXBlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKiAqIGlmIHRoZSBtZXNzYWdlIGRvZXMgbm90IGhhdmUgYSB0b3BpYy5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5UT1BJQ19NSVNTSU5HfS5cbiAgICogKiBpZiB0aGVyZSdzIG5vIHNwYWNlIGluIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0V9LiAgU2VlOlxuICAgKiAgIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9LlxuICAgKiAqIGlmIG5vIEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoZXIgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbWVzc2FnZSBkZWxpdmVyeU1vZGUgaXNcbiAgICogICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlR9IG9yXG4gICAqICAge0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5OT05fUEVSU0lTVEVOVH0uXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuR01fVU5BVkFJTEFCTEV9LlxuICAgKi9cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvd09wZXJhdGlvbihTZXNzaW9uT3BlcmF0aW9uLlNFTkQsIG1lc3NhZ2UpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuICAgIFBhcmFtZXRlci5pc0luc3RhbmNlT2YoJ21lc3NhZ2UnLCBtZXNzYWdlLCBNZXNzYWdlTGliLk1lc3NhZ2UpO1xuICAgIHRoaXMudmFsaWRhdGVBbmRTZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHJlcXVlc3QgdXNpbmcgdXNlci1zcGVjaWZpZWQgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgKiA8YnI+XG4gICAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz5cbiAgICogVGhlIEFQSSBzZXRzIHRoZSBjb3JyZWxhdGlvbklkIGFuZCByZXBseVRvIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50O1xuICAgKiB0aGlzIG92ZXJ3cml0ZXMgYW55IGV4aXN0aW5nIGNvcnJlbGF0aW9uSWQgYW5kIHJlcGx5VG8gdmFsdWVzIG9uIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlfSBtZXNzYWdlIFRoZSByZXF1ZXN0IG1lc3NhZ2UgdG8gc2VuZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSBUaGUgdGltZW91dCB2YWx1ZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhlIG1pbmltdW0gdmFsdWUgaXMgMTAwIG1zZWNzLlxuICAgKiBAcGFyYW0ge3NvbGFjZS5TZXNzaW9uLnJlcGx5UmVjZWl2ZWRDYWxsYmFja30gW3JlcGx5UmVjZWl2ZWRDQkZ1bmN0aW9uXSBUaGUgY2FsbGJhY2sgdG8gbm90aWZ5XG4gICAqICAgIHdoZW4gYSByZXBseSBpcyByZWNlaXZlZC5cbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbi5yZXF1ZXN0RmFpbGVkQ2FsbGJhY2t9IFtyZXF1ZXN0RmFpbGVkQ0JGdW5jdGlvbl0gVGhlIGNhbGxiYWNrIHRvIG5vdGlmeVxuICAgKiAgICB3aGVuIHRoZSByZXF1ZXN0IGZhaWxlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFt1c2VyT2JqZWN0XSBBbiBvcHRpb25hbCBjb3JyZWxhdGlvbiBvYmplY3QgdG8gdXNlIGluIHRoZSByZXNwb25zZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkIG9yIGRpc2Nvbm5lY3RlZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHZhbHVlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0V9LlxuICAgKiAqIGlmIHRoZSBtZXNzYWdlIGRvZXMgbm90IGhhdmUgYSB0b3BpYy5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5UT1BJQ19NSVNTSU5HfS5cbiAgICogKiBpZiB0aGVyZSdzIG5vIHNwYWNlIGluIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0V9LiAgU2VlOlxuICAgKiAgIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9LlxuICAgKiAqIGlmIG5vIEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoZXIgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbWVzc2FnZSBkZWxpdmVyeU1vZGUgaXNcbiAgICogICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlR9IG9yXG4gICAqICAge0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5OT05fUEVSU0lTVEVOVH0uXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuR01fVU5BVkFJTEFCTEV9LlxuICAgKi9cbiAgc2VuZFJlcXVlc3QobWVzc2FnZSxcbiAgICAgICAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcmVwbHlSZWNlaXZlZENCRnVuY3Rpb24gPSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHJlcXVlc3RGYWlsZWRDQkZ1bmN0aW9uID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB1c2VyT2JqZWN0ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb3dPcGVyYXRpb24oU2Vzc2lvbk9wZXJhdGlvbi5TRU5ELCBtZXNzYWdlKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IocmVzdWx0LCBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04sIG51bGwpO1xuICAgIH1cbiAgICBQYXJhbWV0ZXIuaXNJbnN0YW5jZU9mKCdtZXNzYWdlJywgbWVzc2FnZSwgTWVzc2FnZUxpYi5NZXNzYWdlKTtcbiAgICBQYXJhbWV0ZXIuaXNOdW1iZXJPck5vdGhpbmcoJ3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICBQYXJhbWV0ZXIuaXNSYW5nZUNvbXBhcmVPck5vdGhpbmcoJ3RpbWVvdXQnLCB0aW1lb3V0LCAnPj0nLCAxMDApO1xuICAgIFBhcmFtZXRlci5pc0Z1bmN0aW9uT3JOb3RoaW5nKCdyZXBseVJlY2VpdmVkQ0JGdW5jdGlvbicsIHJlcGx5UmVjZWl2ZWRDQkZ1bmN0aW9uKTtcbiAgICBQYXJhbWV0ZXIuaXNGdW5jdGlvbk9yTm90aGluZygncmVxdWVzdEZhaWxlZENCRnVuY3Rpb24nLCByZXF1ZXN0RmFpbGVkQ0JGdW5jdGlvbik7XG5cbiAgICAvLyBzZXQgY29ycmVsYXRpb25JZCBhbmQgcmVwbHlUbyBmaWVsZHMgaWYgbm90IHNldCBieSB0aGUgYXBwbGljYXRpb25cbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gbWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCk7XG4gICAgaWYgKGNvcnJlbGF0aW9uSWQgPT09IG51bGwgfHwgY29ycmVsYXRpb25JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBtZXNzYWdlLnNldENvcnJlbGF0aW9uSWQoU09MQ0xJRU5UX1JFUVVFU1RfUFJFRklYICsgR2xvYmFsQ29udGV4dC5OZXh0SWQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcGx5VG8gPSBtZXNzYWdlLmdldFJlcGx5VG8oKTtcbiAgICBpZiAocmVwbHlUbyA9PT0gbnVsbCB8fCByZXBseVRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHJlcGx5VG9Ub3BpYyA9IERlc3RpbmF0aW9uTGliLlRvcGljLmNyZWF0ZUZyb21OYW1lKFxuICAgICAgICB0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5wMnBJbmJveEluVXNlKTtcbiAgICAgIG1lc3NhZ2Uuc2V0UmVwbHlUbyhyZXBseVRvVG9waWMpO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdGVBbmRTZW5kTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgLy8gZW5xdWV1ZSByZXF1ZXN0XG4gICAgdGhpcy5lbnF1ZXVlT3V0c3RhbmRpbmdEYXRhUmVxKG1lc3NhZ2UuZ2V0Q29ycmVsYXRpb25JZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RmFpbGVkQ0JGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlSZWNlaXZlZENCRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPYmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVwbHkgbWVzc2FnZSB0byB0aGUgZGVzdGluYXRpb24gc3BlY2lmaWVkIGluIG1lc3NhZ2VUb1JlcGx5VG8uXG4gICAqXG4gICAqIElmIGBtZXNzYWdlVG9SZXBseVRvYCBpcyBub24tbnVsbDpcbiAgICogICoge0BsaW5rIHNvbGFjZS5NZXNzYWdlI2dldFJlcGx5VG99IGlzIGNvcGllZCBmcm9tIGBtZXNzYWdlVG9SZXBseVRvYCB0b1xuICAgKiAgICB7QGxpbmsgc29sYWNlLk1lc3NhZ2Ujc2V0RGVzdGluYXRpb259IG9uIGByZXBseU1lc3NhZ2VgLCB1bmxlc3MgYHJlcGx5VG9gIGlzIG51bGwuXG4gICAqICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZSNzZXRDb3JyZWxhdGlvbklkfSBpcyBjb3BpZWQgZnJvbSBgbWVzc2FnZVRvUmVwbHlUb2AgdG9cbiAgICogICAge0BsaW5rIHNvbGFjZS5NZXNzYWdlI3NldENvcnJlbGF0aW9uSWR9IG9uIGByZXBseU1lc3NhZ2VgLCB1bmxlc3MgYGNvcnJlbGF0aW9uSWRgIGlzIG51bGwuXG4gICAqXG4gICAqIElmIGBtZXNzYWdlVG9SZXBseVRvYCBpcyBudWxsLCB0aGUgYXBwbGljYXRpb24gaXMgcmVzcG9uc2libGUgZm9yIHNldHRpbmdcbiAgICogdGhlIGBkZXN0aW5hdGlvbmAgYW5kIGBjb3JyZWxhdGlvbklkYCBvbiB0aGUgYHJlcGx5TWVzc2FnZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IG1lc3NhZ2VUb1JlcGx5VG8gVGhlIG1lc3NhZ2UgdG8gd2hpY2ggYSByZXBseSB3aWxsIGJlIHNlbnQuXG4gICAqIEBwYXJhbSB7c29sYWNlLk1lc3NhZ2V9IHJlcGx5TWVzc2FnZSBUaGUgcmVwbHkgdG8gc2VuZC5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkIG9yIGRpc2Nvbm5lY3RlZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRX0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHZhbHVlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0V9LlxuICAgKiAqIGlmIHRoZSBtZXNzYWdlIGRvZXMgbm90IGhhdmUgYSB0b3BpYy5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5UT1BJQ19NSVNTSU5HfS5cbiAgICogKiBpZiB0aGVyZSdzIG5vIHNwYWNlIGluIHRoZSB0cmFuc3BvcnQgdG8gc2VuZCB0aGUgcmVxdWVzdC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlNVRkZJQ0lFTlRfU1BBQ0V9LiAgU2VlOlxuICAgKiAgIHtAbGluayBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZSNldmVudDpDQU5fQUNDRVBUX0RBVEF9LlxuICAgKiAqIGlmIG5vIEd1YXJhbnRlZWQgTWVzc2FnZSBQdWJsaXNoZXIgaXMgYXZhaWxhYmxlIGFuZCB0aGUgbWVzc2FnZSBkZWxpdmVyeU1vZGUgaXNcbiAgICogICB7QGxpbmsgc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLlBFUlNJU1RFTlR9IG9yXG4gICAqICAge0BsaW5rIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5OT05fUEVSU0lTVEVOVH0uXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuR01fVU5BVkFJTEFCTEV9LlxuICAgKi9cbiAgc2VuZFJlcGx5KG1lc3NhZ2VUb1JlcGx5VG8sIHJlcGx5TWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb3dPcGVyYXRpb24oU2Vzc2lvbk9wZXJhdGlvbi5TRU5ELCByZXBseU1lc3NhZ2UpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuXG4gICAgUGFyYW1ldGVyLmlzSW5zdGFuY2VPZk9yTm90aGluZygnbWVzc2FnZVRvUmVwbHlUbycsIG1lc3NhZ2VUb1JlcGx5VG8sIE1lc3NhZ2VMaWIuTWVzc2FnZSk7XG4gICAgUGFyYW1ldGVyLmlzSW5zdGFuY2VPZigncmVwbHlNZXNzYWdlJywgcmVwbHlNZXNzYWdlLCBNZXNzYWdlTGliLk1lc3NhZ2UpO1xuXG4gICAgcmVwbHlNZXNzYWdlLnNldEFzUmVwbHlNZXNzYWdlKHRydWUpO1xuICAgIGlmIChtZXNzYWdlVG9SZXBseVRvKSB7XG4gICAgICByZXBseU1lc3NhZ2Uuc2V0Q29ycmVsYXRpb25JZChtZXNzYWdlVG9SZXBseVRvLmdldENvcnJlbGF0aW9uSWQoKSk7XG4gICAgICBjb25zdCByZXBseVRvID0gbWVzc2FnZVRvUmVwbHlUby5nZXRSZXBseVRvKCk7XG4gICAgICBpZiAocmVwbHlUbyA9PT0gbnVsbCB8fCByZXBseVRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdSZXBseVRvIGRlc3RpbmF0aW9uIG1heSBub3QgYmUgbnVsbC4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgICAgfVxuICAgICAgcmVwbHlNZXNzYWdlLnNldERlc3RpbmF0aW9uKG1lc3NhZ2VUb1JlcGx5VG8uZ2V0UmVwbHlUbygpKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFuZFNlbmRNZXNzYWdlKHJlcGx5TWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiB7QGxpbmsgc29sYWNlLlN0YXRUeXBlfS5cbiAgICpcbiAgICogQHBhcmFtIHtzb2xhY2UuU3RhdFR5cGV9IHN0YXRUeXBlIFRoZSBzdGF0aXN0aWMgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHN0YXRpc3RpYy5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAqIGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfS5cbiAgICogKiBpZiB0aGUgU3RhdFR5cGUgaXMgaW52YWxpZC5cbiAgICogICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFfS5cbiAgICovXG4gIGdldFN0YXQoc3RhdFR5cGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG93T3BlcmF0aW9uKFNlc3Npb25PcGVyYXRpb24uUVVFUllfT1BFUkFUSU9OKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IocmVzdWx0LCBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04sIG51bGwpO1xuICAgIH1cblxuICAgIFBhcmFtZXRlci5pc0VudW1NZW1iZXIoJ3N0YXRUeXBlJywgc3RhdFR5cGUsIFN0YXRUeXBlKTtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkZTTS5nZXRTdGF0KHN0YXRUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBzZXNzaW9uIHN0YXRpc3RpY3MgdG8gaW5pdGlhbCB2YWx1ZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgdGhlIHNlc3Npb24gaXMgZGlzcG9zZWQuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059LlxuICAgKi9cbiAgcmVzZXRTdGF0cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFsbG93T3BlcmF0aW9uKFNlc3Npb25PcGVyYXRpb24uUVVFUllfT1BFUkFUSU9OKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IocmVzdWx0LCBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04sIG51bGwpO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uRlNNLnJlc2V0U3RhdHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHByb3BlcnRpZXMgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMge3NvbGFjZS5TZXNzaW9uUHJvcGVydGllc30gQSBjbG9uZSBvZiB0aGlzIHNlc3Npb24ncyBwcm9wZXJ0aWVzLlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfS5cbiAgICovXG4gIGdldFNlc3Npb25Qcm9wZXJ0aWVzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb3dPcGVyYXRpb24oU2Vzc2lvbk9wZXJhdGlvbi5RVUVSWV9PUEVSQVRJT04pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLmNsb25lKCk7XG4gICAgY29uc3Qgc2Vzc2lvblN0YXRlID0gdGhpcy5nZXRTZXNzaW9uU3RhdGUoKTtcbiAgICBpZiAoKHNlc3Npb25TdGF0ZSAhPT0gU2Vzc2lvblN0YXRlTmFtZS5ESVNDT05ORUNURUQpICYmIHRoaXMuX3Nlc3Npb25GU00uX3RyYW5zcG9ydCkge1xuICAgICAgcHJvcGVydGllcy5fc2V0V2ViVHJhbnNwb3J0UHJvdG9jb2xJblVzZSh0aGlzLl9zZXNzaW9uRlNNLl90cmFuc3BvcnQuZ2V0VHJhbnNwb3J0UHJvdG9jb2woKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIHZhbHVlIG9mIGEgYm9vbGVhbiByb3V0ZXIgY2FwYWJpbGl0eS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBhIHNob3J0Y3V0IGZvciB7QGxpbmsgc29sYWNlLlNlc3Npb24jZ2V0Q2FwYWJpbGl0eX0uIEl0IHBlcmZvcm1zIHRoZSBzYW1lXG4gICAqIG9wZXJhdGlvbiwgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEge0BsaW5rIHNvbGFjZS5TRFRGaWVsZH0gd3JhcHBpbmcgYSBjYXBhYmlsaXR5IHZhbHVlLCBpdFxuICAgKiBqdXN0IHJldHVybnMgdGhlIGJvb2xlYW4gdmFsdWUuXG4gICAqXG4gICAqICBBdHRlbXB0aW5nIHRvIHF1ZXJ5IGEgbm9uLWJvb2xlYW4gY2FwYWJpbGl0eSB3aWxsIHJldHVybiBgbnVsbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLkNhcGFiaWxpdHlUeXBlfSBjYXBhYmlsaXR5VHlwZSBUaGUgY2FwYWJpbGl0eSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRoZSB2YWx1ZSBvZiB0aGUgY2FwYWJpbGl0eSBxdWVyaWVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9XG4gICAqICogaWYgdGhlIHNlc3Npb24gaXMgZGlzcG9zZWQuXG4gICAqICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT059LlxuICAgKiAqIGlmIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYW4gaW52YWxpZCB0eXBlIG9yIHZhbHVlLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKi9cbiAgaXNDYXBhYmxlKGNhcGFiaWxpdHlUeXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvd09wZXJhdGlvbihTZXNzaW9uT3BlcmF0aW9uLlFVRVJZX09QRVJBVElPTik7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKHJlc3VsdCwgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgUGFyYW1ldGVyLmlzTnVtYmVyKCdjYXBhYmlsaXR5VHlwZScsIGNhcGFiaWxpdHlUeXBlKTtcblxuICAgIGNvbnN0IGNhcHMgPSB0aGlzLl9jYXBhYmlsaXRpZXM7XG4gICAgaWYgKCFjYXBzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR3VhcmQgZm9yIHVuZGVmaW5lZCBPUiBub24tYm9vbGVhbiBjYXBhYmlsaXR5XG4gICAgcmV0dXJuICh0eXBlb2YgY2Fwc1tjYXBhYmlsaXR5VHlwZV0gPT09ICdib29sZWFuJykgPyBjYXBzW2NhcGFiaWxpdHlUeXBlXSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gcm91dGVyIGNhcGFiaWxpdHksIG9yIG51bGwgaWYgdW5rbm93bi4gVGhpcyBmdW5jdGlvbiBtdXN0XG4gICAqIGJlIGNhbGxlZCBhZnRlciBjb25uZWN0aW5nIHRoZSBzZXNzaW9uLlxuICAgKlxuICAgKiBTRFQgVHlwZSBjb252ZXJzaW9uczpcbiAgICpcbiAgICogICoge3N0cmluZ30gdmFsdWVzIGFyZSByZXR1cm5lZCBhcyB7QGxpbmsgc29sYWNlLlNEVEZpZWxkVHlwZS5TVFJJTkd9LlxuICAgKiAgKiB7Ym9vbGVhbn0gdmFsdWVzIGFyZSByZXR1cm5lZCBhcyB7QGxpbmsgc29sYWNlLlNEVEZpZWxkVHlwZS5CT09MfS5cbiAgICogICogQWxsIG51bWVyaWMgdmFsdWVzIGFyZSByZXR1cm5lZCBhcyB7QGxpbmsgc29sYWNlLlNEVEZpZWxkVHlwZS5JTlQ2NH0uXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLkNhcGFiaWxpdHlUeXBlfSBjYXBhYmlsaXR5VHlwZSBUaGUgcm91dGVyIGNhcGFiaWxpdHkgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuU0RURmllbGR9IFRoZSByZXN1bHQgb2YgdGhlIGNhcGFiaWxpdHkgcXVlcnkuXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn1cbiAgICogKiBpZiB0aGUgc2Vzc2lvbiBpcyBkaXNwb3NlZFxuICAgKiAgICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTn0uXG4gICAqICogaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSBhbiBpbnZhbGlkIHR5cGUgb3IgdmFsdWUuXG4gICAqICAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKi9cbiAgZ2V0Q2FwYWJpbGl0eShjYXBhYmlsaXR5VHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYWxsb3dPcGVyYXRpb24oU2Vzc2lvbk9wZXJhdGlvbi5RVUVSWV9PUEVSQVRJT04pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihyZXN1bHQsIEVycm9yU3ViY29kZS5JTlZBTElEX09QRVJBVElPTiwgbnVsbCk7XG4gICAgfVxuXG4gICAgUGFyYW1ldGVyLmlzTnVtYmVyKCdjYXBhYmlsaXR5VHlwZScsIGNhcGFiaWxpdHlUeXBlKTtcblxuICAgIGNvbnN0IHZhbCA9IHRoaXMuX2dldENhcGFiaWxpdHkoY2FwYWJpbGl0eVR5cGUpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBTRFRGaWVsZC5jcmVhdGUoU0RURmllbGRUeXBlLkJPT0wsIHZhbCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuSU5UNjQsIHZhbCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuU1RSSU5HLCB2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2dldENhcGFiaWxpdHkoY2FwYWJpbGl0eVR5cGUpIHtcbiAgICBjb25zdCBjYXBzID0gdGhpcy5fY2FwYWJpbGl0aWVzO1xuICAgIGlmICghY2FwcykgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCB2YWx1ZSA9IGNhcHNbY2FwYWJpbGl0eVR5cGVdO1xuICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Vzc2lvbidzIHN0YXRlLiBUaGlzIGlzIGEgdGhpcmQtY2hvaWNlIG1ldGhvZCB0byBkZXRlcm1pbmUgc2Vzc2lvblxuICAgKiBzdGF0ZTsgdGhlIGZpcnN0IGlzIG5vdGlmaWNhdGlvbnMgb24gRlNNIHRyYW5zaXRpb25zLCBhbmQgdGhlIHNlY29uZCBjaG9pY2UgaXNcbiAgICogdGhlIGZpbmVyLWdyYWluZWQgc3RhdGVzIG9mIHRoZSBGU00gdGhhdCBhcmUgdXNlZCBpbiB0aGlzIG1hcHBpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXNzaW9uU3RhdGV9IFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzZXNzaW9uLlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IGlmIHRoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRTZXNzaW9uU3RhdGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvd09wZXJhdGlvbihTZXNzaW9uT3BlcmF0aW9uLlFVRVJZX09QRVJBVElPTik7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKHJlc3VsdCwgRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgc2Vzc2lvblN0YXRlTmFtZSA9IHRoaXMuZ2V0RlNNU3RhdGUoKTtcbiAgICBzd2l0Y2ggKHNlc3Npb25TdGF0ZU5hbWUpIHtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5GVUxMWV9DT05ORUNURUQ6XG4gICAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGVOYW1lLkRJU0NPTk5FQ1RJTkc6XG4gICAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuRElTQ09OTkVDVElORztcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5ESVNDT05ORUNURUQ6XG4gICAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgY2FzZSBTZXNzaW9uU3RhdGVOYW1lLlNFU1NJT05fRVJST1I6XG4gICAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuU0VTU0lPTl9FUlJPUjtcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5DT05ORUNUSU5HOlxuICAgICAgY2FzZSBTZXNzaW9uU3RhdGVOYW1lLldBSVRJTkdfRk9SX0lOVEVSQ09OTkVDVF9USU1FT1VUOlxuICAgICAgY2FzZSBTZXNzaW9uU3RhdGVOYW1lLldBSVRJTkdfRk9SX0ROUzpcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5XQUlUSU5HX0ZPUl9UUkFOU1BPUlRfVVA6XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfU0VTU0lPTl9VUDpcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5XQUlUSU5HX0ZPUl9MT0dJTjpcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5XQUlUSU5HX0ZPUl9QMlBJTkJPWF9SRUc6XG4gICAgICBjYXNlIFNlc3Npb25TdGF0ZU5hbWUuV0FJVElOR19GT1JfUFVCRkxPVzpcbiAgICAgIGNhc2UgU2Vzc2lvblN0YXRlTmFtZS5SRUFQUExZSU5HX1NVQlNDUklQVElPTlM6XG4gICAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuQ09OTkVDVElORztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTdGF0ZSBuYW1lcyB1bmFjY291bnRlZCBmb3IgLS1cbiAgICAgICAgICAvLyBXQUlUSU5HX0ZPUl9TVUJDT05GSVJNXG4gICAgICAgICAgLy8gV0FJVElOR19GT1JfQ0FOX0FDQ0VQVF9EQVRBXG4gICAgICAgICAgLy8gRElTQ09OTkVDVElOR19GTE9XU1xuICAgICAgICAgIC8vIEZMVVNISU5HX1RSQU5TUE9SVFxuICAgICAgICAgIC8vIERFU1RST1lJTkdfVFJBTlNQT1JUXG4gICAgICAgICAgLy8gUkVDT05ORUNUSU5HXG4gICAgICAgICAgLy8gVFJBTlNQT1JUX0ZBSUxcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRPRE86IEFkanVzdCBzdHJhdGVneS4gVXNlIFN0YXRlTWFjaGluZSNpc1N0YXRlQWN0aXZlIG9uIGtleSBwYXJlbnQgc3RhdGVzLFxuICAgICAgICAgIC8vIGluc3RlYWQgb2YgaGF2aW5nIHRvIGVudW1lcmF0ZSBhbGwgY2hpbGQgc3RhdGVzLmFudFxuICAgICAgICAgIGNvbnN0IHsgTE9HX0lORk8gfSA9IHRoaXMubG9nZ2VyO1xuICAgICAgICAgIExPR19JTkZPKGBVbm1hcHBlZCBzZXNzaW9uIHN0YXRlICR7U2Vzc2lvblN0YXRlTmFtZS5kZXNjcmliZShzZXNzaW9uU3RhdGVOYW1lKX1gKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaW5lIGdyYWluZWQgc3RhdGUgbmFtZSBmcm9tIHRoZSBzZXNzaW9uIEZTTS5cbiAgICogQHJldHVybnMge3NvbGFjZS5TZXNzaW9uU3RhdGVOYW1lfSBUaGUgRlNNIHN0YXRlIG5hbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEZTTVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uRlNNLmdldEN1cnJlbnRTdGF0ZU5hbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEge0BsaW5rIHNvbGFjZS5DYWNoZVNlc3Npb259IG9iamVjdCB0aGF0IHVzZXMgdGhpcyBTZXNzaW9uIHRvIHNlcnZpY2UgaXRzXG4gICAqIGNhY2hlIHJlcXVlc3RzLlxuICAgKlxuICAgKiBJdCBzaG91bGQgYmUgZGlzcG9zZWQgd2hlbiB0aGUgYXBwbGljYXRpb24gbm8gbG9uZ2VyIHJlcXVpcmVzIGEgQ2FjaGVTZXNzaW9uLCBieSBjYWxsaW5nXG4gICAqIHtAbGluayBzb2xhY2UuQ2FjaGVTZXNzaW9uI2Rpc3Bvc2V9LlxuICAgKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FjaGUgc2Vzc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMge3NvbGFjZS5DYWNoZVNlc3Npb259IFRoZSBuZXdseSBjcmVhdGVkIGNhY2hlIHNlc3Npb24uXG4gICAqXG4gICAqIEB0aHJvd3Mge3NvbGFjZS5PcGVyYXRpb25FcnJvcn0gaWYgYSBDYWNoZVNlc3Npb24gaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggdGhpcyBTZXNzaW9uLlxuICAgKiAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfVxuICAgKi9cbiAgY3JlYXRlQ2FjaGVTZXNzaW9uKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IENhY2hlU2Vzc2lvbihwcm9wZXJ0aWVzLCB0aGlzLCB7XG4gICAgICAvLyBiaW5kIGluc3RlYWQgb2YgYXJyb3cgZnVuYyBmb3IgdmFyYXJnc1xuICAgICAgLy8gZHVlIHRvIGJ1YmzDqSB0cmFuc3BpbGVyIGJ1Z1xuICAgICAgaW5jU3RhdDogdGhpcy5fc2Vzc2lvbkZTTS5pbmNTdGF0LmJpbmQodGhpcy5fc2Vzc2lvbkZTTSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSB0byByZWNlaXZlIEd1YXJhbnRlZWQgTWVzc2FnZXMgaW4gdGhpcyBTZXNzaW9uLlxuICAgKlxuICAgKiBDb25zdW1lciBjaGFyYWN0ZXJpc3RpY3MgYW5kIGJlaGF2aW9yIGFyZSBkZWZpbmVkIGJ5IHByb3BlcnRpZXMuIFRoZSBjb25zdW1lciBwcm9wZXJ0aWVzIGFyZVxuICAgKiBzdXBwbGllZCBhcyBhbiBvYmplY3Q7IHRoZSBwZXJ0aW5lbnQgZmllbGRzIGFyZSBleHBvc2VkIGluXG4gICAqIHtAbGluayBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyUHJvcGVydGllc307XG4gICAqIG90aGVyIHByb3BlcnR5IG5hbWVzIGFyZSBpZ25vcmVkLiBJZiB0aGUgTWVzc2FnZSBDb25zdW1lciBjcmVhdGlvblxuICAgKiBzcGVjaWZpZXMgYSBub24tZHVyYWJsZSBlbmRwb2ludCxcbiAgICoge0BsaW5rIHNvbGFjZS5RdWV1ZVByb3BlcnRpZXN9IGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgZGVmYXVsdCBwcm9wZXJ0aWVzIG9uIHRoZVxuICAgKiBub24tZHVyYWJsZSBlbmRwb2ludC4gQW55IHZhbHVlcyBub3Qgc3VwcGxpZWQgYXJlIHNldCB0byBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogV2hlbiB0aGUgY29uc3VtZXIgaXMgY3JlYXRlZCwgYSBjb25zdW1lciBvYmplY3QgaXMgcmV0dXJuZWQgdG8gdGhlIGNhbGxlci4gVGhpcyBpcyB0aGUgb2JqZWN0XG4gICAqIGZyb20gd2hpY2ggZXZlbnRzIGFyZSBlbWl0dGVkLCBhbmQgdXBvbiB3aGljaCBvcGVyYXRpb25zIChmb3IgZXhhbXBsZSwgc3RhcnRpbmcgYW5kIHN0b3BwaW5nXG4gICAqIHRoZSBjb25zdW1lcikgYXJlIHBlcmZvcm1lZC5cbiAgICpcbiAgICogSWYgdGhpcyBzZXNzaW9uIGRvZXMgbm90IHN1cHBvcnQgR3VhcmFudGVlZCBNZXNzYWdpbmcsIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cuIFRoZSBmb2xsb3dpbmdcbiAgICogbXVzdCBiZSB0cnVlIGluIG9yZGVyIHRvIGNyZWF0ZSBhIE1lc3NhZ2VDb25zdW1lcjpcbiAgICogICogVGhlIHRyYW5zcG9ydCBwcm90b2NvbCBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYW55IEhUVFAgdHJhbnNwb3J0IHByb3RvY29scy4gU2VlXG4gICAqICAgIHtAbGluayBzb2xhY2UuU2Vzc2lvblByb3BlcnRpZXMjdHJhbnNwb3J0UHJvdG9jb2x9IGFuZFxuICAgKiAgICB7QGxpbmsgc29sYWNlLkZhY3RvcnlQcm9maWxlI2NvbWV0RW5hYmxlZH1cbiAgICogICogVGhlIFNvbGFjZSBNZXNzYWdpbmcgUm91dGVyIG11c3Qgc3VwcG9ydCBHdWFyYW50ZWVkIE1lc3NhZ2luZ1xuICAgKlxuICAgKiBAbWV0aG9kIHNvbGFjZS5TZXNzaW9uI2NyZWF0ZU1lc3NhZ2VDb25zdW1lclxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzfE9iamVjdH0gY29uc3VtZXJQcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGVcbiAgICogICAgY29uc3VtZXIuXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSBUaGUgbmV3bHkgY3JlYXRlZCBNZXNzYWdlIENvbnN1bWVyLlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IHdoZW4gR3VhcmFudGVlZCBNZXNzYWdlIENvbnN1bWUgaXMgbm90XG4gICAqICAgIHN1cHBvcnRlZCBvbiB0aGlzIHNlc3Npb24uXG4gICAqIEB0YXJnZXQgYnJvd3NlclxuICAgKi9cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lcn0gdG8gcmVjZWl2ZSBHdWFyYW50ZWVkIE1lc3NhZ2VzIGluIHRoaXMgU2Vzc2lvbi5cbiAgICpcbiAgICogQ29uc3VtZXIgY2hhcmFjdGVyaXN0aWNzIGFuZCBiZWhhdmlvciBhcmUgZGVmaW5lZCBieSBwcm9wZXJ0aWVzLiBUaGUgY29uc3VtZXIgcHJvcGVydGllcyBhcmVcbiAgICogc3VwcGxpZWQgYXMgYW4gb2JqZWN0OyB0aGUgcGVydGluZW50IGZpZWxkcyBhcmUgZXhwb3NlZCBpblxuICAgKiB7QGxpbmsgc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXN9O1xuICAgKiBvdGhlciBwcm9wZXJ0eSBuYW1lcyBhcmUgaWdub3JlZC4gSWYgdGhlIE1lc3NhZ2UgQ29uc3VtZXIgY3JlYXRpb25cbiAgICogc3BlY2lmaWVzIGEgbm9uLWR1cmFibGUgZW5kcG9pbnQsXG4gICAqIHtAbGluayBzb2xhY2UuUXVldWVQcm9wZXJ0aWVzfSBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgdGhlIGRlZmF1bHQgcHJvcGVydGllcyBvbiB0aGVcbiAgICogbm9uLWR1cmFibGUgZW5kcG9pbnQuIEFueSB2YWx1ZXMgbm90IHN1cHBsaWVkIGFyZSBzZXQgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAqXG4gICAqIFdoZW4gdGhlIGNvbnN1bWVyIGlzIGNyZWF0ZWQsIGEgY29uc3VtZXIgb2JqZWN0IGlzIHJldHVybmVkIHRvIHRoZSBjYWxsZXIuIFRoaXMgaXMgdGhlIG9iamVjdFxuICAgKiBmcm9tIHdoaWNoIGV2ZW50cyBhcmUgZW1pdHRlZCwgYW5kIHVwb24gd2hpY2ggb3BlcmF0aW9ucyAoZm9yIGV4YW1wbGUsIHN0YXJ0aW5nIGFuZCBzdG9wcGluZ1xuICAgKiB0aGUgY29uc3VtZXIpIGFyZSBwZXJmb3JtZWQuXG4gICAqXG4gICAqIElmIHRoaXMgc2Vzc2lvbiBkb2VzIG5vdCBzdXBwb3J0IEd1YXJhbnRlZWQgTWVzc2FnaW5nLCB0aGlzIG1ldGhvZCB3aWxsIHRocm93LiBUaGUgU29sYWNlXG4gICAqIE1lc3NhZ2luZyBSb3V0ZXIgbXVzdCBzdXBwb3J0IEd1YXJhbnRlZWQgTWVzc2FnaW5nLlxuICAgKlxuICAgKiBAbWV0aG9kIHNvbGFjZS5TZXNzaW9uI2NyZWF0ZU1lc3NhZ2VDb25zdW1lclxuICAgKiBAcGFyYW0ge3NvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzfE9iamVjdH0gY29uc3VtZXJQcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGVcbiAgICogICAgY29uc3VtZXIuXG4gICAqIEByZXR1cm5zIHtzb2xhY2UuTWVzc2FnZUNvbnN1bWVyfSBUaGUgbmV3bHkgY3JlYXRlZCBNZXNzYWdlIENvbnN1bWVyLlxuICAgKiBAdGhyb3dzIHtzb2xhY2UuT3BlcmF0aW9uRXJyb3J9IGlmIEd1YXJhbnRlZWQgTWVzc2FnZSBDb25zdW1lIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBzZXNzaW9uLlxuICAgKiBAdGFyZ2V0IG5vZGVcbiAgICovXG4gIGNyZWF0ZU1lc3NhZ2VDb25zdW1lcihjb25zdW1lclByb3BlcnRpZXMpIHtcbiAgICBpZiAodGhpcy5fYWREaXNhYmxlZFJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdTZXNzaW9uIGRvZXMgbm90IHByb3ZpZGUgTWVzc2FnZUNvbnN1bWVyIGNhcGFiaWxpdHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5HTV9VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZERpc2FibGVkUmVhc29uKTtcbiAgICB9XG4gICAgaWYgKChjb25zdW1lclByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkgJiYgKGNvbnN1bWVyUHJvcGVydGllcyAhPT0gbnVsbCkpIHtcbiAgICAgIGNvbnN0IHsgTE9HX0RFQlVHIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICAgIExPR19ERUJVRygnY3JlYXRlTWVzc2FnZUNvbnN1bWVyIC0gQ29uc3VtZXIgcHJvcGVydGllczpcXG4nLCBjb25zdW1lclByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkZTTS5jcmVhdGVNZXNzYWdlQ29uc3VtZXIoY29uc3VtZXJQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHVibGlzaGluZyBkZXN0aW5hdGlvbiBmcm9tIGEgcXVldWUgZGVzY3JpcHRvci5cbiAgICpcbiAgICogQSBNZXNzYWdlQ29uc3VtZXIgaXMgdGhlIG9ubHkgb2JqZWN0IHRoYXQgaGFzIGFueSBidXNpbmVzc1xuICAgKiBkb2luZyB0aGlzLCBidXQgaXQgc2hvdWxkIG5vdCBiZSBjb25jZXJuZWQgd2l0aCB0aGUgaW50ZXJuYWxzXG4gICAqIHdoaWNoIGRlcGVuZCBvbiB0aGUgc2Vzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFF1ZXVlRGVzY3JpcHRvcnxRdWV1ZURlc2NyaXB0b3J9IHF1ZXVlRGVzY3JpcHRvciBUaGUgY29uc3VtZXIncyBkZXNjcmlwdG9yXG4gICAqIEByZXR1cm5zIHtEZXN0aW5hdGlvbn0gQSBkZXN0aW5hdGlvbiB0aGF0IHB1Ymxpc2hlcyB0byB0aGUgZGVzY3JpcHRvci5cbiAgICogQG1lbWJlcm9mIFNlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZURlc3RpbmF0aW9uRnJvbURlc2NyaXB0b3IocXVldWVEZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgRGVzdGluYXRpb25UeXBlLFxuICAgICAgUXVldWUsXG4gICAgICBUb3BpYyxcbiAgICB9ID0gRGVzdGluYXRpb25MaWI7XG5cbiAgICBsZXQgZGVzdGluYXRpb25UeXBlID0gRGVzdGluYXRpb25UeXBlLlRPUElDO1xuICAgIGlmIChxdWV1ZURlc2NyaXB0b3IudHlwZSA9PT0gUXVldWVUeXBlLlFVRVVFKSB7XG4gICAgICBkZXN0aW5hdGlvblR5cGUgPSBxdWV1ZURlc2NyaXB0b3IuZHVyYWJsZVxuICAgICAgICA/IERlc3RpbmF0aW9uVHlwZS5RVUVVRVxuICAgICAgICA6IERlc3RpbmF0aW9uVHlwZS5URU1QT1JBUllfUVVFVUU7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHF1ZXVlRGVzY3JpcHRvci5uYW1lIHx8IG51bGw7XG5cbiAgICBpZiAocXVldWVEZXNjcmlwdG9yLmR1cmFibGUpIHtcbiAgICAgIGFzc2VydChuYW1lLCAnRHVyYWJsZSBlbmRwb2ludCB3aXRoIGdlbmVyYXRlZCBuYW1lIGlzIG5vdCBhIHZhbGlkIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgIGNvbnN0IGZhY3RvcnlNZXRob2QgPSBxdWV1ZURlc2NyaXB0b3IuZ2V0VHlwZSgpID09PSBRdWV1ZVR5cGUuUVVFVUVcbiAgICAgICAgPyBRdWV1ZS5jcmVhdGVGcm9tTG9jYWxOYW1lXG4gICAgICAgIDogVG9waWMuY3JlYXRlRnJvbU5hbWU7XG4gICAgICByZXR1cm4gZmFjdG9yeU1ldGhvZChuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wb3JhcnlEZXN0aW5hdGlvbihkZXN0aW5hdGlvblR5cGUsIG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZW1wb3JhcnkgZGVzdGluYXRpb24uXG4gICAqIEBwYXJhbSB7RGVzdGluYXRpb25UeXBlfSBkZXN0aW5hdGlvblR5cGUgVHlwZSBvZiBkZXN0aW5hdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIE5hbWUgaWYgYW55XG4gICAqIEByZXR1cm5zIHtEZXN0aW5hdGlvbn0gVGVtcG9yYXJ5IGRlc3RpbmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVUZW1wb3JhcnlEZXN0aW5hdGlvbihkZXN0aW5hdGlvblR5cGUsIG5hbWUpIHtcbiAgICBjb25zdCB7IExPR19UUkFDRSB9ID0gdGhpcy5sb2dnZXI7XG4gICAgY29uc3QgeyBEZXN0aW5hdGlvbkZyb21OZXR3b3JrLCBEZXN0aW5hdGlvblV0aWwgfSA9IERlc3RpbmF0aW9uTGliO1xuICAgIC8vIFRSQU5TUE9SVF9VUCBpcyBjaG9zZW4gYmVjYXVzZSB0aGlzIGlzIHdoZW4gdGhlIHNlc3Npb24gdGVsbHMgc3Vic2NyaWJlcnNcbiAgICAvLyB0aGF0IHRoZXkgbWF5IGJlZ2luIGNvbm5lY3RpbmdcbiAgICBjb25zdCB2cm4gPSB0aGlzLmdldFNlc3Npb25Qcm9wZXJ0aWVzKCkudmlydHVhbFJvdXRlck5hbWU7XG4gICAgaWYgKCF0aGlzLmlzQ2FwYWJsZShDYXBhYmlsaXR5VHlwZS5URU1QT1JBUllfRU5EUE9JTlQpIHx8XG4gICAgICAgIHZybiA9PT0gbnVsbCB8fCB2cm4gPT09IHVuZGVmaW5lZCB8fCB2cm4ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgICdBdHRlbXB0IHRvIGdlbmVyYXRlIHRlbXBvcmFyeSBkZXN0aW5hdGlvbiBvciBlbmRwb2ludCB3aXRob3V0IHN1aXRhYmxlIHNlc3Npb24nLFxuICAgICAgICBFcnJvclN1YmNvZGUuSU5WQUxJRF9PUEVSQVRJT04pO1xuICAgIH1cbiAgICAvLyBOb24tZHVyYWJsZSBjYXNlOyBhdm9pZCByZS1wcmVmaXhpbmdcbiAgICBjb25zdCBsb2NhbE5hbWUgPSBuYW1lICYmIG5hbWUuc3RhcnRzV2l0aCgnI1AyUCcpXG4gICAgICA/IG5hbWVcbiAgICAgIDogRGVzdGluYXRpb25VdGlsLmNyZWF0ZVRlbXBvcmFyeU5hbWUoZGVzdGluYXRpb25UeXBlLCB2cm4sIG5hbWUpO1xuICAgIExPR19UUkFDRSgnR2VuZXJhdGVkIG5hbWU6JywgbG9jYWxOYW1lKTtcbiAgICByZXR1cm4gRGVzdGluYXRpb25Gcm9tTmV0d29yay5jcmVhdGVEZXN0aW5hdGlvbkZyb21OYW1lKGxvY2FsTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbkV2ZW50fSBzZXNzaW9uRXZlbnQgVGhlIGV2ZW50IHRvIHNlbmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRFdmVudChzZXNzaW9uRXZlbnQpIHtcbiAgICBpZiAoIXNlc3Npb25FdmVudCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgeyBMT0dfVFJBQ0UgfSA9IHRoaXMubG9nZ2VyO1xuICAgIExPR19UUkFDRShgU2VuZGluZyBldmVudCAke3Nlc3Npb25FdmVudH1gKTtcbiAgICB0aGlzLl9ldmVudENhbGxiYWNrSW5mby5zZXNzaW9uRXZlbnRDQkZ1bmN0aW9uKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrSW5mby51c2VyT2JqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdHJhbnNwb3J0IHNlc3Npb24gaW5mb3JtYXRpb24gc3RyaW5nLlxuICAgKiBUaGlzIHN0cmluZyBpcyBpbmZvcm1hdGl2ZSBvbmx5LCBhbmQgYXBwbGljYXRpb25zIHNob3VsZCBub3QgYXR0ZW1wdCB0byBwYXJzZSBpdC5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gQSBkZXNjcmlwdGlvbiBvZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgdHJhbnNwb3J0LlxuICAgKi9cbiAgZ2V0VHJhbnNwb3J0SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbkZTTS5nZXRUcmFuc3BvcnRJbmZvKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGludGVyY2VwdG9yIFRoZSB0cmFuc3BvcnQgaW50ZXJjZXB0b3IgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbmplY3RUcmFuc3BvcnRJbnRlcmNlcHRvcihpbnRlcmNlcHRvcikge1xuICAgIHRoaXMuX3Nlc3Npb25GU00uaW5qZWN0VHJhbnNwb3J0SW50ZXJjZXB0b3IoaW50ZXJjZXB0b3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb25PcGVyYXRpb259IG9wZXJhdGlvbkVudW0gdGhlIGlkIG9mIHRoZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtzb2xhY2UuTWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBlcnJvciBtZXNzYWdlIGlmIG5vdCBhbGxvd2VkOyBvdGhlcndpc2UgbnVsbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWxsb3dPcGVyYXRpb24ob3BlcmF0aW9uRW51bSwgbWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5fc2Vzc2lvbkZTTSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbGxvdyA9IHRydWU7XG4gICAgY29uc3Qgc2Vzc2lvblN0YXRlTmFtZSA9IHRoaXMuX3Nlc3Npb25GU00uZ2V0Q3VycmVudFN0YXRlTmFtZSgpO1xuXG4gICAgaWYgKHNlc3Npb25TdGF0ZU5hbWUgPT09IFNlc3Npb25TdGF0ZU5hbWUuRElTUE9TRUQpIHtcbiAgICAgIGFsbG93ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChDaGVjay5hbnl0aGluZyhvcGVyYXRpb25FbnVtKSkge1xuICAgICAgc3dpdGNoIChvcGVyYXRpb25FbnVtKSB7XG4gICAgICAgIGNhc2UgU2Vzc2lvbk9wZXJhdGlvbi5DT05ORUNUOlxuICAgICAgICAgIGlmIChzZXNzaW9uU3RhdGVOYW1lICE9PSBTZXNzaW9uU3RhdGVOYW1lLk5FVyAmJlxuICAgICAgICAgICAgICBzZXNzaW9uU3RhdGVOYW1lICE9PSBTZXNzaW9uU3RhdGVOYW1lLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgYWxsb3cgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2Vzc2lvbk9wZXJhdGlvbi5ESVNDT05ORUNUOlxuICAgICAgICAgIGlmIChzZXNzaW9uU3RhdGVOYW1lID09PSBTZXNzaW9uU3RhdGVOYW1lLk5FVykge1xuICAgICAgICAgICAgYWxsb3cgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2Vzc2lvbk9wZXJhdGlvbi5TRU5EOlxuICAgICAgICBjYXNlIFNlc3Npb25PcGVyYXRpb24uQ1RSTDpcbiAgICAgICAgICBhbGxvdyA9XG4gICAgICAgICAgICAoKHNlc3Npb25TdGF0ZU5hbWUgPT09IFNlc3Npb25TdGF0ZU5hbWUuRlVMTFlfQ09OTkVDVEVEKSB8fFxuICAgICAgICAgICAgKG1lc3NhZ2UgJiYgKG1lc3NhZ2UuZ2V0RGVsaXZlcnlNb2RlKCkgIT09IE1lc3NhZ2VMaWIuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUKSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU2Vzc2lvbk9wZXJhdGlvbi5RVUVSWV9PUEVSQVRJT046XG4gICAgICAgICAgYWxsb3cgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbG93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYENhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiAke29wZXJhdGlvbkVudW19IHdoaWxlIGluIHN0YXRlICR7c2Vzc2lvblN0YXRlTmFtZX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c21mLkNsaWVudEN0cmxNZXNzYWdlfSByb3V0ZXJDYXBhYmlsaXRpZXMgVGhlIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgcm91dGVyIGNhcHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUNhcGFiaWxpdGllcyhyb3V0ZXJDYXBhYmlsaXRpZXMpIHtcbiAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSByb3V0ZXJDYXBhYmlsaXRpZXM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzb2xhY2UuTWVzc2FnZX0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUFuZFNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAvLyBTYW5pdHkgY2hlY2tzIG9uIHRoZSBtZXNzYWdlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHNlbmQgaXRcbiAgICAvLyAgKiBkbyB3ZSBoYXZlIGEgZGVzdGluYXRpb24/XG4gICAgY29uc3Qgc2VuZERlc3QgPSBtZXNzYWdlLmdldERlc3RpbmF0aW9uKCk7XG4gICAgaWYgKENoZWNrLm5vdGhpbmcoc2VuZERlc3QpIHx8IENoZWNrLmVtcHR5KHNlbmREZXN0LmdldE5hbWUoKSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignTWVzc2FnZSBtdXN0IGhhdmUgYSB2YWxpZCBEZXN0aW5hdGlvbicsIEVycm9yU3ViY29kZS5UT1BJQ19NSVNTSU5HKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kZXJUaW1lc3RhbXAgPSBtZXNzYWdlLmdldFNlbmRlclRpbWVzdGFtcCgpO1xuICAgIGNvbnN0IG5vU2VuZGVyVGltZXN0YW1wID0gc2VuZGVyVGltZXN0YW1wID09PSBudWxsIHx8IHNlbmRlclRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLl9zZXNzaW9uUHJvcGVydGllcy5nZW5lcmF0ZVNlbmRUaW1lc3RhbXBzICYmXG4gICAgICAgIChub1NlbmRlclRpbWVzdGFtcCB8fCBtZXNzYWdlLmhhc0F1dG9TZW5kZXJUaW1lc3RhbXApKSB7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgbWVzc2FnZS5zZXRTZW5kZXJUaW1lc3RhbXAobm93LmdldFRpbWUoKSk7XG4gICAgICBtZXNzYWdlLmhhc0F1dG9TZW5kZXJUaW1lc3RhbXAgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IG1lc3NhZ2UuZ2V0U2VxdWVuY2VOdW1iZXIoKTtcbiAgICBjb25zdCBub1NlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXIgPT09IG51bGwgfHwgc2VxdWVuY2VOdW1iZXIgPT09IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuZ2VuZXJhdGVTZXF1ZW5jZU51bWJlciAmJlxuICAgICAgICAobm9TZXF1ZW5jZU51bWJlciB8fCBtZXNzYWdlLmhhc0F1dG9TZXF1ZW5jZU51bWJlcikpIHtcbiAgICAgIG1lc3NhZ2Uuc2V0U2VxdWVuY2VOdW1iZXIodGhpcy5fc2VxTnVtKyspO1xuICAgICAgbWVzc2FnZS5oYXNBdXRvU2VxdWVuY2VOdW1iZXIgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJJZCA9IG1lc3NhZ2UuZ2V0U2VuZGVySWQoKTtcbiAgICBjb25zdCBub1NlbmRlcklkID0gc2VuZGVySWQgPT09IG51bGwgfHwgc2VuZGVySWQgPT09IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuaW5jbHVkZVNlbmRlcklkICYmIG5vU2VuZGVySWQpIHtcbiAgICAgIG1lc3NhZ2Uuc2V0U2VuZGVySWQodGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuY2xpZW50TmFtZSk7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgdGhlIEZTTSBhbmQgaXRzIGRlbGVnYXRlcyB0byBwcmVwYXJlIGFuZCBzZW5kIHRoZSBtZXNzYWdlXG4gICAgLy8gVGhpcyBtYXkgbXV0YXRlIHRoZSBkZWxlZ2F0ZXMsIHNvIHdlIG5lZWQgdG8gdmFsaWRhdGUgZmlyc3RcbiAgICAvLyB0aGlzIG1heSB0aHJvdyBpZiB0aGUgbWVzc2FnZSBpcyBndWFyYW50ZWVkIGFuZCB0aGUgd2luZG93IGlzIGNsb3NlZC5cbiAgICAvLyBJZiB0aGlzIHJldHVybnMgdHJ1ZSwgdGhlIG1lc3NhZ2UgY2FuIGJlIHNlbnQgdG8gdGhlIHRyYW5zcG9ydFxuICAgIC8vIChhbHdheXMgdHJ1ZSBmb3IgZGlyZWN0IG1lc3NhZ2VzIHdobmUgdGhlcmUgaXMgYSB0cmFuc3BvcnQpLiBJZlxuICAgIC8vIHRoaXMgcmV0dXJucyBmYWxzZSwgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gcHJlcGFyZWQgYW5kIHF1ZXVlZCBmb3JcbiAgICAvLyB0cmFuc3BvcnQgYnV0IG1heSBub3QgYmUgc2VudCBub3cuXG4gICAgdGhpcy5fc2Vzc2lvbkZTTS5wcmVwYXJlQW5kU2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvcnJlbGF0aW9uSWQgVGhlIGludGVybmFsIGNvcnJlbGF0aW9uIElEIGZvciB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLlsqXSl9IHJlcUZhaWxlZENiIFRoZSBjYWxsYmFjayBvbiByZXF1ZXN0IGZhaWx1cmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcVRpbWVvdXQgVGhlIHJlcXVlc3QgdGltZW91dCBpbiBtc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSByZXBseVJlY3ZkQ2IgVGhlIGNhbGxiYWNrIG9uIHJlcGx5IHJlY2VpdmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT2JqZWN0IEEgdXNlciBvYmplY3QgdG8gcGFzcyBiYWNrIHRvIHRoZSBjYWxsYmFjayAobGVnYWN5KVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZU91dHN0YW5kaW5nRGF0YVJlcShjb3JyZWxhdGlvbklkLCByZXFGYWlsZWRDYiwgcmVxVGltZW91dCwgcmVwbHlSZWN2ZENiLCB1c2VyT2JqZWN0KSB7XG4gICAgaWYgKENoZWNrLm5vbmUoY29ycmVsYXRpb25JZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBMT0dfVFJBQ0UsIExPR19FUlJPUiB9ID0gdGhpcy5sb2dnZXI7XG5cbiAgICAvLyBlbXB0eSBzdHJpbmcgaXMgdmFsaWRcbiAgICBMT0dfVFJBQ0UoYEVucXVldWUgb3V0c3RhbmRpbmcgZGF0YSByZXF1ZXN0IGNvcnJlbGF0aW9uSWQ9JHtjb3JyZWxhdGlvbklkfWApO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zZXNzaW9uRlNNLmluY1N0YXQoU3RhdFR5cGUuVFhfUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZXF1ZXN0IGZyb20gcXVldWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlbGV0ZSB0aGlzLl9vdXRzdGFuZGluZ0RhdGFSZXFzW2NvcnJlbGF0aW9uSWRdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBkYXRhIHJlcXVlc3QgJHtjb3JyZWxhdGlvbklkfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExPR19FUlJPUihgQ2Fubm90IGRlbGV0ZSBkYXRhIHJlcXVlc3QgJHtjb3JyZWxhdGlvbklkfWAsIGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQ2hlY2suYW55dGhpbmcocmVxRmFpbGVkQ2IpKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RFdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChSZXF1ZXN0RXZlbnRDb2RlLlJFUVVFU1RfVElNRU9VVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXF1ZXN0IHRpbWVvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25JZCk7XG5cbiAgICAgICAgcmVxRmFpbGVkQ2IodGhpcywgcmVxdWVzdEV2ZW50LCB1c2VyT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9LCByZXFUaW1lb3V0IHx8IHRoaXMuX3Nlc3Npb25Qcm9wZXJ0aWVzLnJlYWRUaW1lb3V0SW5Nc2Vjcyk7XG5cbiAgICBjb25zdCBvdXRzdGFuZGluZ1JlcSA9IG5ldyBPdXRzdGFuZGluZ0RhdGFSZXF1ZXN0KGNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5UmVjdmRDYixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUZhaWxlZENiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9iamVjdCk7XG4gICAgdGhpcy5fb3V0c3RhbmRpbmdEYXRhUmVxc1tjb3JyZWxhdGlvbklkXSA9IG91dHN0YW5kaW5nUmVxO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JyZWxhdGlvbklkIFRoZSBpbnRlcm5hbCBJRCBvZiB0aGUgcmVxdWVzdCB0byBjYW5jZWxcbiAgICogQHJldHVybnMge091dHN0YW5kaW5nRGF0YVJlcXVlc3R9IFRoZSByZXF1ZXN0IHRoYXQgd2FzIGNhbmNlbGxlZCwgaWYgYW55XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxPdXRzdGFuZGluZ0RhdGFSZXEoY29ycmVsYXRpb25JZCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFLCBMT0dfRVJST1IgfSA9IHRoaXMubG9nZ2VyO1xuXG4gICAgaWYgKENoZWNrLm5vbmUoY29ycmVsYXRpb25JZCkgfHwgIXRoaXMuX291dHN0YW5kaW5nRGF0YVJlcXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcSA9IHRoaXMuX291dHN0YW5kaW5nRGF0YVJlcXNbY29ycmVsYXRpb25JZF07XG4gICAgaWYgKHJlcSA9PT0gdW5kZWZpbmVkIHx8IHJlcSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIExPR19UUkFDRShgQ2FuY2VsIG91dHN0YW5kaW5nIGRhdGEgcmVxdWVzdCBjb3JyZWxhdGlvbklkPSR7Y29ycmVsYXRpb25JZH1gKTtcbiAgICBpZiAocmVxLnRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVxLnRpbWVyKTtcbiAgICAgIHJlcS50aW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlbGV0ZSB0aGlzLl9vdXRzdGFuZGluZ0RhdGFSZXFzW2NvcnJlbGF0aW9uSWRdO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgTE9HX0VSUk9SKGBDYW5ub3QgZGVsZXRlIGRhdGEgcmVxdWVzdCAke2NvcnJlbGF0aW9uSWR9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTE9HX0VSUk9SKGBDYW5ub3QgZGVsZXRlIGRhdGEgcmVxdWVzdCAke2NvcnJlbGF0aW9uSWR9YCwgZSk7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsZWFudXBTZXNzaW9uKCkge1xuICAgIGNvbnN0IHsgTE9HX1RSQUNFIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBpZiAodGhpcy5fb3V0c3RhbmRpbmdEYXRhUmVxcykge1xuICAgICAgTE9HX1RSQUNFKCdDYW5jZWwgYWxsIG91dHN0YW5kaW5nIGRhdGEgcmVxdWVzdHMnKTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX291dHN0YW5kaW5nRGF0YVJlcXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhUmVxID0gdGhpcy5jYW5jZWxPdXRzdGFuZGluZ0RhdGFSZXEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGFSZXEgJiYgZGF0YVJlcS5yZXFGYWlsZWRDQkZ1bmN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdEV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFJlcXVlc3RFdmVudENvZGUuUkVRVUVTVF9BQk9SVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUmVxdWVzdCBhYm9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KTtcbiAgICAgICAgICBkYXRhUmVxLnJlcUZhaWxlZENCRnVuY3Rpb24odGhpcywgcmVxdWVzdEV2ZW50LCBkYXRhUmVxLnVzZXJPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBkYXRhTWVzc2FnZUluIFRoZSByZWNlaXZlZCBkaXJlY3QgVFJtc2dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZURhdGFNZXNzYWdlKGRhdGFNZXNzYWdlSW4pIHtcbiAgICBjb25zdCB7IExPR19UUkFDRSwgTE9HX0lORk8gfSA9IHRoaXMubG9nZ2VyO1xuICAgIGNvbnN0IGRhdGFNZXNzYWdlID0gZGF0YU1lc3NhZ2VJbjtcbiAgICBpZiAodGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuZ2VuZXJhdGVSZWNlaXZlVGltZXN0YW1wcykge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGRhdGFNZXNzYWdlLl9yZWNlaXZlclRpbWVzdGFtcCA9IG5vdy5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFNZXNzYWdlLmlzUmVwbHlNZXNzYWdlKCkpIHtcbiAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBkYXRhTWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCk7XG4gICAgICBpZiAoQ2hlY2suYW55dGhpbmcoY29ycmVsYXRpb25JZCkpIHtcbiAgICAgICAgY29uc3QgZGF0YVJlcSA9IHRoaXMuY2FuY2VsT3V0c3RhbmRpbmdEYXRhUmVxKGNvcnJlbGF0aW9uSWQpO1xuICAgICAgICBpZiAoZGF0YVJlcSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3Nlc3Npb25GU00uaW5jU3RhdChTdGF0VHlwZS5SWF9SRVBMWV9NU0dfUkVDVkVEKTtcbiAgICAgICAgICBMT0dfVFJBQ0UoJ0NhbGxpbmcgYXBwbGljYXRpb24gcmVwbHlSZWNlaXZlZENhbGxiYWNrJyk7XG4gICAgICAgICAgZGF0YVJlcS5yZXBseVJlY2VpdmVkQ0JGdW5jdGlvbih0aGlzLCBkYXRhTWVzc2FnZSwgZGF0YVJlcS51c2VyT2JqZWN0KTtcbiAgICAgICAgICBMT0dfVFJBQ0UoJ2FwcGxpY2F0aW9uIHJlcGx5UmVjZWl2ZWRDYWxsYmFjayByZXR1cm5zJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvcnJlbGF0aW9uSWQuc3RhcnRzV2l0aChTT0xDTElFTlRfUkVRVUVTVF9QUkVGSVgpKSB7XG4gICAgICAgICAgICAvLyBpZiBhIHJlcGx5IG1lc3NhZ2UgZG9lc24ndCBoYXZlIG91dHN0YW5kaW5nIHJlcXVlc3QgYW5kIGNvcnJlbGF0aW9uSWRcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB3aXRoICNSRVEgaXQgaXMgYXNzdW1lZCB0byBiZSBhIGRlbGF5ZWQgcmVwbHkgYW5kIGhhcyB0byBiZSBkaXNjYXJkZWRcbiAgICAgICAgICBMT0dfSU5GTygnRFJPUDogRGlzY2FyZCByZXBseSBtZXNzYWdlIGR1ZSB0byBtaXNzaW5nIG91dHN0YW5kaW5nIHJlcXVlc3QnKTtcbiAgICAgICAgICB0aGlzLl9zZXNzaW9uRlNNLmluY1N0YXQoU3RhdFR5cGUuUlhfUkVQTFlfTVNHX0RJU0NBUkQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3JyZWxhdGlvbklkLnN0YXJ0c1dpdGgoQ0FDSEVfUkVRVUVTVF9QUkVGSVgpICYmXG4gICAgICAgICAgICAgICEoQ2FjaGVTZXNzaW9uICYmIHRoaXMuX21lc3NhZ2VDYWxsYmFja0luZm8udXNlck9iamVjdCBpbnN0YW5jZW9mIENhY2hlU2Vzc2lvbikpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIGEgY2FjaGUgbWVzc2FnZSwgb25seSBwYXNzIGl0IGFsb25nIGlmIHRoZSBsaXN0ZW5lciBpcyBhIGNhY2hlIG1lc3NhZ2VcbiAgICAgICAgICAvLyBsaXN0ZW5lci4gVGhlIGxpc3RlbmVyIG1heSBkcm9wIGl0IGFuZCBpbmNyZW1lbnQgdGhlIERJU0NBUkQgc3RhdCBpZiBub1xuICAgICAgICAgIC8vIGNhY2hlIHNlc3Npb24gcmVjb2duaXplcyB0aGUgcmVwbHkuXG4gICAgICAgICAgTE9HX0lORk8oJ0RST1A6IERpc2NhcmQgY2FjaGUgcmVwbHkgZHVlIHRvIG5vIGNhY2hlIHNlc3Npb24gYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkZTTS5pbmNTdGF0KFN0YXRUeXBlLlJYX1JFUExZX01TR19ESVNDQVJEKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3RpZnkgY2xpZW50IG1lc3NhZ2UgY2FsbGJhY2tcbiAgICBMT0dfVFJBQ0UoJ0NhbGxpbmcgYXBwbGljYXRpb24gbWVzc2FnZUNhbGxiYWNrJyk7XG4gICAgdGhpcy5fbWVzc2FnZUNhbGxiYWNrSW5mby5tZXNzYWdlUnhDQkZ1bmN0aW9uKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlQ2FsbGJhY2tJbmZvLnVzZXJPYmplY3QpO1xuICAgIExPR19UUkFDRSgnYXBwbGljYXRpb24gbWVzc2FnZUNhbGxiYWNrIHJldHVybnMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7c29sYWNlLlNNUE1lc3NhZ2V9IHNtcE1zZyBUaGUgU01QIHJlc3BvbnNlIHRvIHRoZSBzdWJzY3JpcHRpb24gcmVxdWVzdFxuICAgKiBAcGFyYW0ge0NvcnJlbGF0ZWRSZXF1ZXN0fSByZXF1ZXN0IFRoZSBvcmlnaW5hdGluZyByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVlc3RDb25maXJtIFdoZXRoZXIgdGhlIHVzZXIgYXNrZWQgZm9yIGNvbmZpcm1hdGlvbiBvbiB0aGUgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlUmVzcG9uc2Uoc21wTXNnLCByZXF1ZXN0LCByZXF1ZXN0Q29uZmlybSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gc21wTXNnLmdldFJlc3BvbnNlKCk7XG4gICAgY29uc3Qge1xuICAgICAgcmVzcG9uc2VDb2RlLFxuICAgICAgcmVzcG9uc2VTdHJpbmcsXG4gICAgIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCB7IGNvcnJlbGF0aW9uS2V5IH0gPSByZXF1ZXN0O1xuICAgIC8vIElmIHdlIGRvbid0IHJlcXVlc3QgY29uZmlybWF0aW9uLCB0aGUgcm91dGVyIGRvZXNuJ3Qgc2VuZCBvbmUgZm9yIHRoZSBPSyBjYXNlLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZ3VhcmQgZm9yIHRoYXQuXG4gICAgLy8gVGhlIHJvdXRlciBhbHdheXMgcmVwbGllcyBvbiBTVUJTQ1JJUFRJT05fRVJST1IsIHNvIHdlIHRyYWNrIHdoZXRoZXIgY29uZmlybWF0aW9uXG4gICAgLy8gd2FzIHJlcXVlc3RlZCBhbmQgc3VwcHJlc3MgdGhlIHJlcGx5IGluIGNlcnRhaW4gY2FzZXMuXG4gICAgaWYgKHJlc3BvbnNlQ29kZSA9PT0gMjAwKSB7XG4gICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICBjb25zdCBzZXNzaW9uRXZlbnQgPSBTZXNzaW9uRXZlbnQuYnVpbGQoU2Vzc2lvbkV2ZW50Q29kZS5TVUJTQ1JJUFRJT05fT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25LZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICB0aGlzLnNlbmRFdmVudChzZXNzaW9uRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25TdHIgPSBTdHJpbmdVdGlscy5zdHJpcE51bGxUZXJtaW5hdGUoc21wTXNnLmVuY29kZWRVdGY4U3Vic2NyaXB0aW9uKTtcbiAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlRXJyb3IocmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uU3RyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENvbmZpcm0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgRFRFIHVuc3Vic2NyaWJlIHJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLkFkTWVzc2FnZX0gYWRDdHJsTWVzc2FnZSBUaGUgR3VhcmFudGVlZCBNZXNzYWdlIFByb3RvY29sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbCByZXNwb25zZSB0byB0aGUgRFRFIHVuc3ViIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtDb3JyZWxhdGVkUmVxdWVzdH0gcmVxdWVzdCBUaGUgb3JpZ2luYXRpbmcgcmVxdWVzdCBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZURURVVuc3Vic2NyaWJlUmVzcG9uc2UoYWRDdHJsTWVzc2FnZSwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYWRDdHJsTWVzc2FnZS5nZXRSZXNwb25zZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3BvbnNlQ29kZSxcbiAgICAgIHJlc3BvbnNlU3RyaW5nLFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCB7IGNvcnJlbGF0aW9uS2V5IH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IGV2ZW50Q29kZSA9IHJlc3BvbnNlQ29kZSA9PT0gMjAwXG4gICAgICA/IFNlc3Npb25FdmVudENvZGUuVU5TVUJTQ1JJQkVfVEVfVE9QSUNfT0tcbiAgICAgIDogU2Vzc2lvbkV2ZW50Q29kZS5VTlNVQlNDUklCRV9URV9UT1BJQ19FUlJPUjtcbiAgICBjb25zdCBzdWJjb2RlID0gcmVzcG9uc2VDb2RlID09PSAyMDBcbiAgICAgID8gMFxuICAgICAgOiBFcnJvclJlc3BvbnNlU3ViY29kZU1hcHBlci5nZXRBREVycm9yU3ViY29kZShyZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlU3RyaW5nKTtcbiAgICB0aGlzLnNlbmRFdmVudChTZXNzaW9uRXZlbnQuYnVpbGQoZXZlbnRDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWxhdGlvbktleVxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZXNwQ29kZSBUaGUgcmV0dXJuZWQgcmVzcG9uc2UgY29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzcFRleHQgVGhlIHJldHVybmVkIHJlc3BvbnNlIHRleHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN1YnNjcmlwdGlvblN0ciBUaGUgcmVxdWVzdGVkIHRvcGljIG5hbWVcbiAgICogQHBhcmFtIHsqfSBjb3JyZWxhdGlvbktleSBUaGUgdXNlci1zdXBwbGllZCBjb3JyZWxhdGlvbiBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSByZXF1ZXN0Q29uZmlybSBXaGV0aGVyIGNvbmZpcm1hdGlvbiB3YXMgcmVxdWVzdGVkIG9uIHN1YnNjcmlwdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlRXJyb3IocmVzcENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25TdHIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q29uZmlybSkge1xuICAgIGNvbnN0IGVycm9yU3ViY29kZSA9IEVycm9yUmVzcG9uc2VTdWJjb2RlTWFwcGVyLmdldEVycm9yU3ViY29kZShyZXNwQ29kZSwgcmVzcFRleHQpO1xuICAgIGlmICgoZXJyb3JTdWJjb2RlID09PSBFcnJvclN1YmNvZGUuU1VCU0NSSVBUSU9OX0FMUkVBRFlfUFJFU0VOVCAmJlxuICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuaWdub3JlRHVwbGljYXRlU3Vic2NyaXB0aW9uRXJyb3IpIHx8XG4gICAgICAgIChlcnJvclN1YmNvZGUgPT09IEVycm9yU3ViY29kZS5TVUJTQ1JJUFRJT05fTk9UX0ZPVU5EICYmXG4gICAgICAgICAgdGhpcy5fc2Vzc2lvblByb3BlcnRpZXMuaWdub3JlU3Vic2NyaXB0aW9uTm90Rm91bmRFcnJvcikpIHtcbiAgICAgIGlmIChyZXF1ZXN0Q29uZmlybSkge1xuICAgICAgICAvLyBub3RpZnkgY2xpZW50XG4gICAgICAgIGNvbnN0IHNlc3Npb25FdmVudCA9IFNlc3Npb25FdmVudC5idWlsZChcbiAgICAgICAgICBTZXNzaW9uRXZlbnRDb2RlLlNVQlNDUklQVElPTl9PSyxcbiAgICAgICAgICByZXNwVGV4dCxcbiAgICAgICAgICByZXNwQ29kZSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZW5kRXZlbnQoc2Vzc2lvbkV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aWZ5IGNsaWVudFxuICAgICAgY29uc3Qgc2Vzc2lvbkV2ZW50ID0gU2Vzc2lvbkV2ZW50LmJ1aWxkKFxuICAgICAgICBTZXNzaW9uRXZlbnRDb2RlLlNVQlNDUklQVElPTl9FUlJPUixcbiAgICAgICAgcmVzcFRleHQsXG4gICAgICAgIHJlc3BDb2RlLFxuICAgICAgICBlcnJvclN1YmNvZGUsXG4gICAgICAgIGNvcnJlbGF0aW9uS2V5LFxuICAgICAgICBgVG9waWM6ICR7c3Vic2NyaXB0aW9uU3RyfWBcbiAgICAgICk7XG4gICAgICB0aGlzLnNlbmRFdmVudChzZXNzaW9uRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U2Vzc2lvbkV2ZW50Q0JJbmZvfSBUaGUgc2Vzc2lvbidzIGV2ZW50IGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRFdmVudENCSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRDYWxsYmFja0luZm87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTZXNzaW9uRXZlbnRDQkluZm99IGV2ZW50Q0JJbmZvIFRoZSBuZXcgZXZlbnQgY2FsbGJhY2sgdG8gc2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRFdmVudENCSW5mbyhldmVudENCSW5mbykge1xuICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tJbmZvID0gZXZlbnRDQkluZm87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge01lc3NhZ2VSeENCSW5mb30gVGhlIHNlc3Npb24ncyBtZXNzYWdlIGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNZXNzYWdlQ0JJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlQ2FsbGJhY2tJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVzc2FnZVJ4Q0JJbmZvfSBtZXNzYWdlQ0JJbmZvIFRoZSBuZXcgbWVzc2FnZSBjYWxsYmFjayB0byBzZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldE1lc3NhZ2VDQkluZm8obWVzc2FnZUNCSW5mbykge1xuICAgIHRoaXMuX21lc3NhZ2VDYWxsYmFja0luZm8gPSBtZXNzYWdlQ0JJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXh0IGNvcnJlbGF0aW9uIHRhZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q29ycmVsYXRpb25UYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25GU00uZ2V0Q29ycmVsYXRpb25UYWcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBhIFNlc3Npb25FdmVudENCSW5mbyBvciBhIGJhcmUgZnVuY3Rpb24gd2l0aCBhbiBldmVudCBlbWl0dGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtTZXNzaW9uRXZlbnRDQkluZm98ZnVuY3Rpb258dW5kZWZpbmVkfSBldmVudENhbGxiYWNrIFRoZSBjYWxsYmFjayB0byB3cmFwXG4gICAqIEByZXR1cm5zIHtTZXNzaW9uRXZlbnRDQkluZm99IEEgU2Vzc2lvbkV2ZW50Q0JJbmZvIG9iamVjdCB0aGF0IGhhbmRsZXMgYWxsIGNhbGxiYWNrcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdyYXBFdmVudENhbGxiYWNrKGV2ZW50Q2FsbGJhY2spIHtcbiAgICBjb25zdCB7IExPR19XQVJOIH0gPSB0aGlzLmxvZ2dlcjtcbiAgICBjb25zdCBldmVudENhbGxiYWNrSW5mbyA9ICgoKSA9PiB7XG4gICAgICBpZiAoIWV2ZW50Q2FsbGJhY2spIHJldHVybiBudWxsO1xuICAgICAgaWYgKGV2ZW50Q2FsbGJhY2suc2Vzc2lvbkV2ZW50Q0JGdW5jdGlvbikgcmV0dXJuIGV2ZW50Q2FsbGJhY2s7XG4gICAgICByZXR1cm4gbmV3IFNlc3Npb25FdmVudENCSW5mbyhldmVudENhbGxiYWNrKTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkV2ZW50Q0JJbmZvKChzZXNzaW9uLCBzZXNzaW9uRXZlbnQsIG9iaiwgcmZ1KSA9PiB7XG4gICAgICBjb25zdCB7IHNlc3Npb25FdmVudENvZGUgfSA9IHNlc3Npb25FdmVudDtcbiAgICAgIGlmIChldmVudENhbGxiYWNrSW5mbykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2ZW50Q2FsbGJhY2tJbmZvLnNlc3Npb25FdmVudENCRnVuY3Rpb24oc2Vzc2lvbiwgc2Vzc2lvbkV2ZW50LCBvYmosIHJmdSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBPYmplY3QuYXNzaWduKG5ldyBPcGVyYXRpb25FcnJvcihcbiAgICAgICAgICAgIGBVbmhhbmRsZWQgZXJyb3IgaW4gU2Vzc2lvbkV2ZW50UnhDQkluZm8gY2FsbGJhY2sgb24gc2Vzc2lvbkV2ZW50Q29kZSAke1xuICAgICAgICAgICAgICBTZXNzaW9uRXZlbnRDb2RlLmRlc2NyaWJlKHNlc3Npb25FdmVudENvZGUpfWAsXG4gICAgICAgICAgICAgIEVycm9yU3ViY29kZS5DQUxMQkFDS19FUlJPUixcbiAgICAgICAgICAgICAgYE9uIGV2ZW50OiAke1tzZXNzaW9uRXZlbnRDb2RlLCBzZXNzaW9uRXZlbnQsIG9iaiwgcmZ1XX0gJHtleH1gXG4gICAgICAgICAgICApLCB7XG4gICAgICAgICAgICAgIHN0YWNrOiBleC5zdGFjayxcbiAgICAgICAgICAgICAgaW5mbzogIHtcbiAgICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogICAgICAgICAgc2Vzc2lvbkV2ZW50Q29kZSxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZE5hbWU6IGBTZXNzaW9uRXZlbnRDb2RlLiR7U2Vzc2lvbkV2ZW50Q29kZS5kZXNjcmliZShzZXNzaW9uRXZlbnRDb2RlKX1gLFxuICAgICAgICAgICAgICAgICAgYXJnczogICAgICAgICAgW3Nlc3Npb25FdmVudCwgb2JqLCByZnVdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IGV4LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgTE9HX1dBUk4oZXJyb3IudG9TdHJpbmcoKSwgZXJyb3IuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChzZXNzaW9uRXZlbnRDb2RlLCBzZXNzaW9uRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGEgQ0JJbmZvIG9yIGEgYmFyZSBmdW5jdGlvbiB3aXRoIGFuIGV2ZW50IGVtaXR0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VDQkluZm98ZnVuY3Rpb258dW5kZWZpbmVkfSBtZXNzYWdlQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHdyYXBcbiAgICogQHJldHVybnMge01lc3NhZ2VDQkluZm99IEEgTWVzc2FnZUNCSW5mbyBvYmplY3QgdGhhdCBoYW5kbGVzIGFsbCBjYWxsYmFja3MuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB3cmFwTWVzc2FnZUNhbGxiYWNrKG1lc3NhZ2VDYWxsYmFjaykge1xuICAgIGNvbnN0IHsgTE9HX1dBUk4gfSA9IHRoaXMubG9nZ2VyO1xuXG4gICAgY29uc3QgbWVzc2FnZUNhbGxiYWNrSW5mbyA9ICgoKSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2VDYWxsYmFjaykgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobWVzc2FnZUNhbGxiYWNrLm1lc3NhZ2VSeENCRnVuY3Rpb24pIHJldHVybiBtZXNzYWdlQ2FsbGJhY2s7XG4gICAgICByZXR1cm4gbmV3IE1lc3NhZ2VSeENCSW5mbyhtZXNzYWdlQ2FsbGJhY2spO1xuICAgIH0pKCk7XG5cbiAgICBjb25zdCBmb3JtYXR0ZWROYW1lID0gYFNlc3Npb25FdmVudENvZGUuJHtTZXNzaW9uRXZlbnRDb2RlLmRlc2NyaWJlKFNlc3Npb25FdmVudENvZGUuTUVTU0FHRSl9YDtcbiAgICBjb25zdCBidWlsZEVycm9yRXZlbnQgPSAoZXgsIG1lc3NhZ2UsIG9iamVjdCkgPT4gT2JqZWN0LmFzc2lnbihcbiAgICAgIG5ldyBPcGVyYXRpb25FcnJvcihgVW5oYW5kbGVkIGVycm9yIGluIE1lc3NhZ2VSeENCSW5mbyBjYWxsYmFjay9oYW5kbGVyIGZvciAke2Zvcm1hdHRlZE5hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuQ0FMTEJBQ0tfRVJST1IpLFxuICAgICAge1xuICAgICAgICBzdGFjazogZXguc3RhY2ssXG4gICAgICAgIGluZm86ICB7XG4gICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgIG5hbWU6IFNlc3Npb25FdmVudENvZGUuTUVTU0FHRSxcbiAgICAgICAgICAgIGZvcm1hdHRlZE5hbWUsXG4gICAgICAgICAgICBhcmdzOiBbbWVzc2FnZSwgb2JqZWN0XSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBleCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlUnhDQkluZm8oKHNlc3Npb24sIG1lc3NhZ2UsIG9iamVjdCkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VDYWxsYmFja0luZm8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZXNzYWdlQ2FsbGJhY2tJbmZvLm1lc3NhZ2VSeENCRnVuY3Rpb24oc2Vzc2lvbiwgbWVzc2FnZSwgb2JqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGJ1aWxkRXJyb3JFdmVudChleCwgbWVzc2FnZSwgb2JqZWN0KS50b1N0cmluZygpO1xuICAgICAgICAgIExPR19XQVJOKGVycm9yLCBlcnJvci5pbmZvLCBleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZW1pdERpcmVjdChtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBidWlsZEVycm9yRXZlbnQoZXgsIG1lc3NhZ2UsIG9iamVjdCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZWFkb25seVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IGFkTG9jYWxseURpc2FibGVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2FkRGlzYWJsZWRSZWFzb247XG4gIH1cblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgY2FuQ29ubmVjdENvbnN1bWVyKCkge1xuICAgIGlmICh0aGlzLmFkTG9jYWxseURpc2FibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2NhcGFiaWxpdGllcykge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDYXBhYmxlKENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBjYW5Db25uZWN0UHVibGlzaGVyKCkge1xuICAgIGlmICh0aGlzLmFkTG9jYWxseURpc2FibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2NhcGFiaWxpdGllcykge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDYXBhYmxlKENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9QVUJMSVNIKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldCBkaXNwb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcG9zZWQ7XG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdzZXNzaW9uSWQnOiB0aGlzLl9zZXNzaW9uRlNNICYmIHRoaXMuX3Nlc3Npb25GU00uc2Vzc2lvbklkSGV4IHx8ICcoTi9BKScsXG4gICAgICAndHJhbnNwb3J0JzogdGhpcy5nZXRUcmFuc3BvcnRJbmZvKCksXG4gICAgICAnc3RhdGUnOiAgICAgU2Vzc2lvblN0YXRlLmRlc2NyaWJlKHRoaXMuZ2V0U2Vzc2lvblN0YXRlKCkpLFxuICAgIH07XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHRoaXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc2Vzc2lvbi9saWIvc2Vzc2lvbi5qcyIsImNvbnN0IHsgU2Vzc2lvblJlcXVlc3RUeXBlIH0gPSByZXF1aXJlKCcuL3Nlc3Npb24tcmVxdWVzdC10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3Vic2NyaXB0aW9uVXBkYXRlVGltZW91dE1lc3NhZ2VzOiB7XG4gICAgW1Nlc3Npb25SZXF1ZXN0VHlwZS5BRERfU1VCU0NSSVBUSU9OXTogICAgICAgICdBZGQgc3Vic2NyaXB0aW9uIHJlcXVlc3QgdGltZW91dCcsXG4gICAgW1Nlc3Npb25SZXF1ZXN0VHlwZS5SRU1PVkVfU1VCU0NSSVBUSU9OXTogICAgICdSZW1vdmUgc3Vic2NyaXB0aW9uIHJlcXVlc3QgdGltZW91dCcsXG4gICAgW1Nlc3Npb25SZXF1ZXN0VHlwZS5BRERfUDJQSU5CT1hdOiAgICAgICAgICAgICdBZGQgUDJQIGluYm94IHN1YnNjcmlwdGlvbiB0aW1lb3V0JyxcbiAgICBbU2Vzc2lvblJlcXVlc3RUeXBlLlJFTU9WRV9QMlBJTkJPWF06ICAgICAgICAgJ1JlbW92ZSBQMlAgaW5ib3ggc3Vic2NyaXB0aW9uIHRpbWVvdXQnLFxuICAgIFtTZXNzaW9uUmVxdWVzdFR5cGUuUkVNT1ZFX0RURV9TVUJTQ1JJUFRJT05dOiAnUmVtb3ZlIGVuZHBvaW50IHRvcGljIHN1YnNjcmlwdGlvbicsXG4gICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXF1ZXN0IHRpbWVvdXQnLFxuICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNlc3Npb24vbGliL3N1YnNjcmlwdGlvbi11cGRhdGUtdGltZW91dC1tZXNzYWdlcy5qcyIsImNvbnN0IHsgQ29udGVudFN1bW1hcnlUeXBlIH0gPSByZXF1aXJlKCcuL2NvbnRlbnQtc3VtbWFyeS10eXBlcycpO1xuY29uc3QgeyBEZWNvZGUgfSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5jb25zdCB7IEVuY29kZSB9ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbmNvbnN0IHsgUGFyYW1QYXJzZSB9ID0gcmVxdWlyZSgnLi9wYXJhbS1wYXJzZScpO1xuY29uc3QgeyBQYXJzZVNNRiB9ID0gcmVxdWlyZSgnLi9wYXJzZS1zbWYnKTtcbmNvbnN0IHsgVHJhbnNwb3J0IH0gPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5Db250ZW50U3VtbWFyeVR5cGUgPSBDb250ZW50U3VtbWFyeVR5cGU7XG5tb2R1bGUuZXhwb3J0cy5FbmNvZGUgPSBFbmNvZGU7XG5tb2R1bGUuZXhwb3J0cy5EZWNvZGUgPSBEZWNvZGU7XG5tb2R1bGUuZXhwb3J0cy5QYXJhbVBhcnNlID0gUGFyYW1QYXJzZTtcbm1vZHVsZS5leHBvcnRzLlBhcnNlU01GID0gUGFyc2VTTUY7XG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvYXBpLmpzIiwiY29uc3QgRGVidWdMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtZGVidWcnKTtcbmNvbnN0IFNvbGNsaWVudERlc3RpbmF0aW9uTGliID0gcmVxdWlyZSgnc29sY2xpZW50LWRlc3RpbmF0aW9uJyk7XG5jb25zdCBTb2xjbGllbnRNZXNzYWdlTGliID0gcmVxdWlyZSgnc29sY2xpZW50LW1lc3NhZ2UnKTtcbmNvbnN0IFNvbGNsaWVudFNEVExpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1zZHQnKTtcbmNvbnN0IHsgQmluYXJ5TWV0YUJsb2NrLCBLZWVwQWxpdmVNZXNzYWdlIH0gPSByZXF1aXJlKCcuLi9tZXNzYWdlLW9iamVjdHMnKTtcbmNvbnN0IHsgQ29udGVudFN1bW1hcnlUeXBlIH0gPSByZXF1aXJlKCcuL2NvbnRlbnQtc3VtbWFyeS10eXBlcycpO1xuY29uc3QgeyBIZXgsIExvbmcgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IExhenkgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lc2tpdCcpO1xuY29uc3QgeyBMb2dGb3JtYXR0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgcGFyc2VBZHBBdCB9ID0gcmVxdWlyZSgnLi9hZHByb3RvY29sJyk7XG5jb25zdCB7IHBhcnNlQ0NBdCB9ID0gcmVxdWlyZSgnLi9jbGllbnQtY3RybCcpO1xuY29uc3QgeyBQYXJzZVNNRiB9ID0gcmVxdWlyZSgnLi9wYXJzZS1zbWYnKTtcbmNvbnN0IHsgUHJpb3JpdHlVc2VyQ29zTWFwIH0gPSByZXF1aXJlKCcuL3ByaW9yaXR5LXVzZXItY29zLW1hcCcpO1xuY29uc3QgeyBTTUZQcm90b2NvbCB9ID0gcmVxdWlyZSgnLi4vc21mLXByb3RvY29scycpO1xuY29uc3QgeyBTTVAgfSA9IHJlcXVpcmUoJy4vc21wJyk7XG5jb25zdCB7IFRyYW5zcG9ydCB9ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblxuY29uc3QgeyBmb3JtYXRIZXhTdHJpbmcgfSA9IEhleDtcbmNvbnN0IHsgbGF6eVZhbHVlIH0gPSBMYXp5O1xuY29uc3QgeyBwYXJzZVNNRkF0IH0gPSBQYXJzZVNNRjtcbmNvbnN0IHsgcGFyc2VTTVBBdCB9ID0gU01QO1xuY29uc3QgeyBwYXJzZVRzU21mTXNnQXQgfSA9IFRyYW5zcG9ydDtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ0Zvcm1hdHRlcignW3NtZi1kZWNvZGVdJyk7XG5jb25zdCB7IExPR19UUkFDRSxcbiAgICAgICAgTE9HX0RFQlVHLFxuICAgICAgICBMT0dfRVJST1IgfSA9IGxvZ2dlcjtcblxuY29uc3QgdXNlckNvc0ZvclByaW9yaXR5ID0gbGF6eVZhbHVlKCgpID0+IG5ldyBQcmlvcml0eVVzZXJDb3NNYXAoKS5yZXZlcnNlKTtcblxuY29uc3QgQklOX1NUUlVDVFlQRVMgPSB7XG4gIDB4MEE6IFNvbGNsaWVudE1lc3NhZ2VMaWIuTWVzc2FnZVR5cGUuTUFQLFxuICAweDBCOiBTb2xjbGllbnRNZXNzYWdlTGliLk1lc3NhZ2VUeXBlLlNUUkVBTSxcbiAgMHgwNzogU29sY2xpZW50TWVzc2FnZUxpYi5NZXNzYWdlVHlwZS5URVhULFxufTtcblxuZnVuY3Rpb24gYWRhcHRCaW5hcnlNZXRhVG9NZXNzYWdlKGJpbmFyeU1ldGEsIG1lc3NhZ2VJbikge1xuICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUluO1xuICBjb25zdCBtZXNzYWdlU2R0ID0gU29sY2xpZW50U0RUTGliLkNvZGVjLnBhcnNlU2luZ2xlRWxlbWVudChiaW5hcnlNZXRhLnBheWxvYWQsIDApO1xuXG4gIGlmICghKG1lc3NhZ2VTZHQgJiYgbWVzc2FnZVNkdC5nZXRUeXBlKCkgPT09IFNvbGNsaWVudFNEVExpYi5TRFRGaWVsZFR5cGUuU1RSRUFNKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNkdHN0cmVhbSA9IG1lc3NhZ2VTZHQuZ2V0VmFsdWUoKTtcbiAgbGV0IHNkdGZpZWxkID0gc2R0c3RyZWFtLmdldE5leHQoKTtcbiAgaWYgKHNkdGZpZWxkICYmIHNkdGZpZWxkLmdldFR5cGUoKSA9PT0gU29sY2xpZW50U0RUTGliLlNEVEZpZWxkVHlwZS5CWVRFQVJSQVkpIHtcbiAgICAvLyBQcmVhbWJsZSBieXRlIGFycmF5IGlzIHByZXNlbnRcbiAgICBjb25zdCBwcmVhbWJsZUJ5dGUwID0gc2R0ZmllbGQuZ2V0VmFsdWUoKS5jaGFyQ29kZUF0KDApICYgMHhGRjtcbiAgICBpZiAoKHByZWFtYmxlQnl0ZTAgJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gc3RydWN0dXJlZCBtZXNzYWdlOiBvdmVycmlkZSBkZWZhdWx0IFwiQklOXCIgbWVzc2FnZSB0eXBlXG4gICAgICBtZXNzYWdlLl9tZXNzYWdlVHlwZSA9IChCSU5fU1RSVUNUWVBFU1twcmVhbWJsZUJ5dGUwICYgMHgwRl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvbGNsaWVudE1lc3NhZ2VMaWIuTWVzc2FnZVR5cGUuQklOQVJZKTtcbiAgICB9XG4gICAgaWYgKHNkdGZpZWxkLmdldFZhbHVlKCkubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvbnN0IHByZWFtYmxlQnl0ZTEgPSBzZHRmaWVsZC5nZXRWYWx1ZSgpLmNoYXJDb2RlQXQoMSkgJiAweEZGO1xuICAgICAgbWVzc2FnZS5zZXRBc1JlcGx5TWVzc2FnZSgocHJlYW1ibGVCeXRlMSAmIDB4ODApICE9PSAwKTtcbiAgICB9XG4gIH1cblxuICBzZHRmaWVsZCA9IHNkdHN0cmVhbS5nZXROZXh0KCk7XG4gIGlmIChzZHRmaWVsZCAmJiBzZHRmaWVsZC5nZXRUeXBlKCkgPT09IFNvbGNsaWVudFNEVExpYi5TRFRGaWVsZFR5cGUuTUFQKSB7XG4gICAgY29uc3Qgc2R0TWFwID0gc2R0ZmllbGQuZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwID0gc2R0TWFwLmdldEZpZWxkKCdwJyk7XG4gICAgY29uc3QgaCA9IHNkdE1hcC5nZXRGaWVsZCgnaCcpO1xuICAgIGlmIChwKSB7XG4gICAgICBtZXNzYWdlLnNldFVzZXJQcm9wZXJ0eU1hcChwLmdldFZhbHVlKCkpO1xuICAgIH1cbiAgICBpZiAoaCkge1xuICAgICAgY29uc3QgaGVhZGVyTWFwID0gaC5nZXRWYWx1ZSgpO1xuICAgICAgY29uc3QgY2kgPSBoZWFkZXJNYXAuZ2V0RmllbGQoJ2NpJyk7XG4gICAgICBjb25zdCBtaSA9IGhlYWRlck1hcC5nZXRGaWVsZCgnbWknKTtcbiAgICAgIGNvbnN0IG10ID0gaGVhZGVyTWFwLmdldEZpZWxkKCdtdCcpO1xuICAgICAgY29uc3QgcnQgPSBoZWFkZXJNYXAuZ2V0RmllbGQoJ3J0Jyk7XG4gICAgICBjb25zdCBzaSA9IGhlYWRlck1hcC5nZXRGaWVsZCgnc2knKTtcbiAgICAgIGNvbnN0IHNuID0gaGVhZGVyTWFwLmdldEZpZWxkKCdzbicpO1xuICAgICAgY29uc3QgdHMgPSBoZWFkZXJNYXAuZ2V0RmllbGQoJ3RzJyk7XG4gICAgICBjb25zdCBleCA9IGhlYWRlck1hcC5nZXRGaWVsZCgnZXgnKTtcbiAgICAgIGlmIChjaSkge1xuICAgICAgICBtZXNzYWdlLnNldENvcnJlbGF0aW9uSWQoY2kuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICBpZiAobWkpIHtcbiAgICAgICAgbWVzc2FnZS5zZXRBcHBsaWNhdGlvbk1lc3NhZ2VJZChtaS5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtdCkge1xuICAgICAgICBtZXNzYWdlLnNldEFwcGxpY2F0aW9uTWVzc2FnZVR5cGUobXQuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICBpZiAocnQpIHtcbiAgICAgICAgbWVzc2FnZS5zZXRSZXBseVRvKHJ0LmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHNpKSB7XG4gICAgICAgIG1lc3NhZ2Uuc2V0U2VuZGVySWQoc2kuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgICBpZiAoc24pIHtcbiAgICAgICAgbWVzc2FnZS5zZXRTZXF1ZW5jZU51bWJlcihzbi5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cykge1xuICAgICAgICBtZXNzYWdlLnNldFNlbmRlclRpbWVzdGFtcCh0cy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmIChleCkge1xuICAgICAgICBtZXNzYWdlLnNldEdNRXhwaXJhdGlvbihleC5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBhZGFwdFNtZlRvTWVzc2FnZShzbWZIZWFkZXIsIG1lc3NhZ2VJbiwgc3RyZWFtLCBvZmZzZXQpIHtcbiAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VJbjtcbiAgbWVzc2FnZS5fc2V0RGVsaXZlclRvT25lKCEhc21mSGVhZGVyLnNtZl9kdG8pO1xuICBtZXNzYWdlLl9zZXREZWxpdmVyeU1vZGUoc21mSGVhZGVyLnBtX2RlbGl2ZXJ5bW9kZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBTb2xjbGllbnRNZXNzYWdlTGliLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLkRJUkVDVCk7XG4gIGlmIChzbWZIZWFkZXIucG1fdHJfdG9waWNuYW1lX2J5dGVzICE9PSBudWxsKSB7XG4gICAgbWVzc2FnZS5fc2V0RGVzdGluYXRpb24oXG4gICAgICBTb2xjbGllbnREZXN0aW5hdGlvbkxpYi5EZXN0aW5hdGlvbkZyb21OZXR3b3JrLmNyZWF0ZURlc3RpbmF0aW9uRnJvbUJ5dGVzKFxuICAgICAgICBzbWZIZWFkZXIucG1fdHJfdG9waWNuYW1lX2J5dGVzKSk7XG4gIH1cbiAgbWVzc2FnZS5fc2V0RGlzY2FyZEluZGljYXRpb24oISFzbWZIZWFkZXIuc21mX2RpKTtcbiAgbWVzc2FnZS5fc2V0RWxpZGluZ0VsaWdpYmxlKCEhc21mSGVhZGVyLnNtZl9lbGlkaW5nRWxpZ2libGUpO1xuICBtZXNzYWdlLl9zZXRETVFFbGlnaWJsZSghIXNtZkhlYWRlci5zbWZfZGVhZE1lc3NhZ2VRdWV1ZUVsaWdpYmxlKTtcbiAgbWVzc2FnZS5fc2V0VXNlckNvcyh1c2VyQ29zRm9yUHJpb3JpdHkudmFsdWUuZ2V0KHNtZkhlYWRlci5zbWZfcHJpb3JpdHkpKTtcbiAgbWVzc2FnZS5fc2V0UHJpb3JpdHkoc21mSGVhZGVyLnBtX21zZ19wcmlvcml0eSk7XG4gIGlmIChzbWZIZWFkZXIucG1fdXNlcmRhdGEpIG1lc3NhZ2UuX3NldFVzZXJEYXRhKHNtZkhlYWRlci5wbV91c2VyZGF0YSk7XG5cbiAgbWVzc2FnZS5zZXRSZWRlbGl2ZXJlZCghIXNtZkhlYWRlci5wbV9hZF9yZWRlbGZsYWcgfHwgISFzbWZIZWFkZXIucG1fYWRfZmxvd3JlZGVsZmxhZyk7XG5cbiAgbWVzc2FnZS5zZXRGbG93SWQoc21mSGVhZGVyLnBtX2FkX2Zsb3dpZCk7XG4gIG1lc3NhZ2Uuc2V0R3VhcmFudGVlZE1lc3NhZ2VJZChzbWZIZWFkZXIucG1fYWRfbXNnaWQpO1xuICBtZXNzYWdlLnNldEd1YXJhbnRlZWRQcmV2aW91c01lc3NhZ2VJZChzbWZIZWFkZXIucG1fYWRfcHJldm1zZ2lkKTtcbiAgbWVzc2FnZS5zZXRQdWJsaXNoZXJJZChzbWZIZWFkZXIucG1fYWRfcHVibGlzaGVyaWQpO1xuICBtZXNzYWdlLnNldFB1Ymxpc2hlck1lc3NhZ2VJZChzbWZIZWFkZXIucG1fYWRfcHVibGlzaGVybXNnaWQpO1xuICBtZXNzYWdlLnNldFRvcGljU2VxdWVuY2VOdW1iZXIoc21mSGVhZGVyLnBtX2FkX3RvcGljU2VxdWVuY2VOdW1iZXIpO1xuXG4gIGlmIChMb25nLmlzTG9uZyhzbWZIZWFkZXIucG1fYWRfdHRsKSkge1xuICAgIG1lc3NhZ2Uuc2V0VGltZVRvTGl2ZShzbWZIZWFkZXIucG1fYWRfdHRsLnRvTnVtYmVyKCkpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2Uuc2V0VGltZVRvTGl2ZShzbWZIZWFkZXIucG1fYWRfdHRsKTtcbiAgfVxuXG4gIC8vIENvcHkgY29udGVudCBpbnRvIGZpZWxkcyAoZnJvbSBpbnB1dCBieXRlcylcbiAgY29uc3QgcGF5bG9hZE9mZnNldCA9IG9mZnNldCArIHNtZkhlYWRlci5oZWFkZXJMZW5ndGg7XG4gIGNvbnN0IGNzID0gc21mSGVhZGVyLnBtX2NvbnRlbnRfc3VtbWFyeTtcblxuICBpZiAoIShjcyAmJiBjcy5sZW5ndGgpKSB7XG4gICAgLy8gTm8gY29udGVudC1zdW1tYXJ5LCBhc3N1bWUgYmluYXJ5IGF0dGFjaG1lbnRcbiAgICBtZXNzYWdlLl9zZXRCaW5hcnlBdHRhY2htZW50KHNtZkhlYWRlci5wYXlsb2FkTGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN0cmVhbS5zdWJzdHIocGF5bG9hZE9mZnNldCwgc21mSGVhZGVyLnBheWxvYWRMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbiA9IGNzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IGNzW2ldO1xuICAgIGNvbnN0IGNodW5rRGF0YSA9IHN0cmVhbS5zdWJzdHIocGF5bG9hZE9mZnNldCArIGN1cnJlbnRDaHVuay5wb3NpdGlvbiwgY3VycmVudENodW5rLmxlbmd0aCk7XG4gICAgc3dpdGNoIChjdXJyZW50Q2h1bmsudHlwZSkge1xuICAgICAgY2FzZSBDb250ZW50U3VtbWFyeVR5cGUuQklOQVJZX0FUVEFDSE1FTlQ6XG4gICAgICAgIG1lc3NhZ2UuX3NldEJpbmFyeUF0dGFjaG1lbnQoY2h1bmtEYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRlbnRTdW1tYXJ5VHlwZS5CSU5BUllfTUVUQURBVEE6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBiaW5hcnlNZXRhID0gQmluYXJ5TWV0YUJsb2NrLmZyb21FbmNvZGVkU21mKGNodW5rRGF0YSk7XG4gICAgICAgICAgbWVzc2FnZS5iaW5hcnlNZXRhZGF0YUNodW5rID0gYmluYXJ5TWV0YTtcbiAgICAgICAgICBpZiAoYmluYXJ5TWV0YS50eXBlID09PSAwKSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIFNEVCBKTVMgbWV0YWRhdGFcbiAgICAgICAgICAgIGFkYXB0QmluYXJ5TWV0YVRvTWVzc2FnZShiaW5hcnlNZXRhLCBtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ29udGVudFN1bW1hcnlUeXBlLlhNTF9NRVRBOlxuICAgICAgICBtZXNzYWdlLl9zZXRYbWxNZXRhZGF0YShjaHVua0RhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGVudFN1bW1hcnlUeXBlLlhNTF9QQVlMT0FEOlxuICAgICAgICBtZXNzYWdlLl9zZXRYbWxDb250ZW50SW50ZXJuYWwoY2h1bmtEYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBMT0dfRVJST1IoYFVuaGFuZGxlZCBDb250ZW50U3VtbWFyeVR5cGU6ICR7Q29udGVudFN1bW1hcnlUeXBlLmRlc2NyaWJlKGN1cnJlbnRDaHVuay50eXBlKX1gKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29tcG91bmRNZXNzYWdlKGRhdGEsIHBvcykge1xuICBjb25zdCBoZWFkZXIgPSBwYXJzZVNNRkF0KGRhdGEsIHBvcyk7XG4gIGlmICghaGVhZGVyKSB7XG4gICAgTE9HX0RFQlVHKCdkZWNvZGVDb21wb3VuZE1lc3NhZ2U6IFNNRiBwYXJzaW5nIGZhaWxlZCcpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gdGhlIHBhcnNlciBkZXRlcm1pbmVkIHRoZXJlIHdhcyBhIGZ1bGwgU01GIG1lc3NhZ2VcbiAgY29uc3QgcGF5bG9hZFBvc2l0aW9uID0gcG9zICsgaGVhZGVyLmhlYWRlckxlbmd0aDtcbiAgY29uc3QgcGF5bG9hZExlbiA9IGhlYWRlci5wYXlsb2FkTGVuZ3RoO1xuICBsZXQgbWVzc2FnZTtcbiAgc3dpdGNoIChoZWFkZXIuc21mX3Byb3RvY29sKSB7XG4gICAgY2FzZSBTTUZQcm90b2NvbC5UU0VTU0lPTjpcbiAgICAgIG1lc3NhZ2UgPSBwYXJzZVRzU21mTXNnQXQoZGF0YSwgcGF5bG9hZFBvc2l0aW9uLCBoZWFkZXIpO1xuICAgICAgaWYgKCFtZXNzYWdlKSBicmVhaztcblxuICAgICAgbWVzc2FnZS5zbWZIZWFkZXIgPSBoZWFkZXI7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcblxuICAgIGNhc2UgU01GUHJvdG9jb2wuVFJNU0c6XG4gICAgICBtZXNzYWdlID0gbmV3IFNvbGNsaWVudE1lc3NhZ2VMaWIuTWVzc2FnZSgpO1xuICAgICAgbWVzc2FnZS5fc21mSGVhZGVyID0gaGVhZGVyO1xuICAgICAgYWRhcHRTbWZUb01lc3NhZ2UoaGVhZGVyLCBtZXNzYWdlLCBkYXRhLCBwb3MpO1xuICAgICAgTE9HX1RSQUNFKCdEZWNvZGVkIFNNRiBtZXNzYWdlJyk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcblxuICAgIGNhc2UgU01GUHJvdG9jb2wuQURDVFJMOlxuICAgICAgbWVzc2FnZSA9IHBhcnNlQWRwQXQoZGF0YSwgcGF5bG9hZFBvc2l0aW9uLCBwYXlsb2FkTGVuKTtcbiAgICAgIGlmICghbWVzc2FnZSkgYnJlYWs7XG4gICAgICBtZXNzYWdlLnNtZkhlYWRlciA9IGhlYWRlcjtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuXG4gICAgY2FzZSBTTUZQcm90b2NvbC5DTElFTlRDVFJMOlxuICAgICAgbWVzc2FnZSA9IHBhcnNlQ0NBdChkYXRhLCBwYXlsb2FkUG9zaXRpb24sIHBheWxvYWRMZW4pO1xuICAgICAgaWYgKCFtZXNzYWdlKSBicmVhaztcblxuICAgICAgbWVzc2FnZS5zbWZIZWFkZXIgPSBoZWFkZXI7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcblxuICAgIGNhc2UgU01GUHJvdG9jb2wuU01QOlxuICAgICAgbWVzc2FnZSA9IHBhcnNlU01QQXQoZGF0YSwgcGF5bG9hZFBvc2l0aW9uKTtcbiAgICAgIGlmICghbWVzc2FnZSkgYnJlYWs7XG5cbiAgICAgIG1lc3NhZ2Uuc21mSGVhZGVyID0gaGVhZGVyO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG5cbiAgICBjYXNlIFNNRlByb3RvY29sLktFRVBBTElWRTpcbiAgICBjYXNlIFNNRlByb3RvY29sLktFRVBBTElWRVYyOlxuICAgICAgbWVzc2FnZSA9IG5ldyBLZWVwQWxpdmVNZXNzYWdlKCk7XG4gICAgICBtZXNzYWdlLnNtZkhlYWRlciA9IGhlYWRlcjtcbiAgICAgIExPR19UUkFDRSgnRGVjb2RlZCBrZWVwIGFsaXZlIHJlc3BvbnNlJyk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBMT0dfRVJST1IoYFVua25vd24gcHJvdG9jb2w6IDB4JHtmb3JtYXRIZXhTdHJpbmcoaGVhZGVyLnNtZl9wcm90b2NvbCl9LCBgICtcbiAgICAgICAgICAgICAgICBgZHVtcCBtZXNzYWdlIGNvbnRlbnQ6IFxcbiR7XG4gICAgICAgICAgICAgICAgRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKGRhdGEuc3Vic3RyaW5nKHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLm1lc3NhZ2VMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLCAwKX1gKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBEZWNvZGUgPSB7XG4gIGRlY29kZUNvbXBvdW5kTWVzc2FnZSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkRlY29kZSA9IERlY29kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvY29kZWMvZGVjb2RlLmpzIiwiY29uc3QgTWVzc2FnZUxpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1tZXNzYWdlJyk7XG5jb25zdCB7IEJhc2U2NCwgQml0cywgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgQmluYXJ5TWV0YUJsb2NrLCBTTUZIZWFkZXIsIFNNUE1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4uL21lc3NhZ2Utb2JqZWN0cycpO1xuY29uc3QgeyBDaGVjayB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5jb25zdCB7IENsaWVudEN0cmxNZXNzYWdlLCBLZWVwQWxpdmVNZXNzYWdlLCBBZFByb3RvY29sTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi4vbWVzc2FnZS1vYmplY3RzJyk7XG5jb25zdCB7IENvZGVjOiBTRFRDb2RlYyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXNkdCcpO1xuY29uc3QgeyBDb250ZW50U3VtbWFyeUVsZW1lbnQgfSA9IHJlcXVpcmUoJy4vY29udGVudC1zdW1tYXJ5LWVsZW1lbnQnKTtcbmNvbnN0IHsgQ29udGVudFN1bW1hcnlUeXBlIH0gPSByZXF1aXJlKCcuL2NvbnRlbnQtc3VtbWFyeS10eXBlcycpO1xuY29uc3QgeyBEZXN0aW5hdGlvblR5cGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBlbmNBZHAgfSA9IHJlcXVpcmUoJy4vYWRwcm90b2NvbCcpO1xuY29uc3QgeyBlbmNDQyB9ID0gcmVxdWlyZSgnLi9jbGllbnQtY3RybCcpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUsIE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgTGF6eSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7IExPR19UUkFDRSwgTE9HX0lORk8gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgUGFyYW1QYXJzZSB9ID0gcmVxdWlyZSgnLi9wYXJhbS1wYXJzZScpO1xuY29uc3QgeyBQcmlvcml0eVVzZXJDb3NNYXAgfSA9IHJlcXVpcmUoJy4vcHJpb3JpdHktdXNlci1jb3MtbWFwJyk7XG5jb25zdCB7IFNEVEZpZWxkLCBTRFRGaWVsZFR5cGUsIFNEVE1hcENvbnRhaW5lciwgU0RUU3RyZWFtQ29udGFpbmVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2R0Jyk7XG5jb25zdCB7IFNNRlBhcmFtZXRlclR5cGUgfSA9IHJlcXVpcmUoJy4uL3NtZi1wYXJhbWV0ZXItdHlwZXMnKTtcbmNvbnN0IHsgU01GUHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3NtZi1wcm90b2NvbHMnKTtcbmNvbnN0IHsgU01QIH0gPSByZXF1aXJlKCcuL3NtcCcpO1xuXG5jb25zdCB7IGVuY29kZTogYmFzZTY0RW5jb2RlIH0gPSBCYXNlNjQ7XG5jb25zdCB7IHNldDogc2V0Qml0cyB9ID0gQml0cztcbmNvbnN0IHtcbiAgaW50OFRvU3RyLFxuICBpbnQxNlRvU3RyLFxuICBpbnQyNFRvU3RyLFxuICBpbnQzMlRvU3RyLFxuICBpbnQ2NFRvU3RyLFxufSA9IENvbnZlcnQ7XG5jb25zdCB7IGxhenlWYWx1ZSB9ID0gTGF6eTtcbmNvbnN0IHtcbiAgZW5jQ29udGVudFN1bW1hcnksXG4gIGVuY0RlbGl2ZXJ5TW9kZSxcbiAgZW5jTGlnaHRTTUZQYXJhbSxcbiAgZW5jb2RlU01GUGFyYW0sXG59ID0gUGFyYW1QYXJzZTtcbmNvbnN0IHsgZW5jb2RlU2luZ2xlRWxlbWVudCB9ID0gU0RUQ29kZWM7XG5jb25zdCB7IGVuY1NtcCB9ID0gU01QO1xuXG5jb25zdCBwcmlvcml0eUZvclVzZXJDb3MgPSBsYXp5VmFsdWUoKCkgPT4gbmV3IFByaW9yaXR5VXNlckNvc01hcCgpLmZvcndhcmQpO1xuXG5mdW5jdGlvbiBhZGRDb250ZW50RWxlbWVudFRvQXJyYXlzKGNzdW1tLCBwYXlsb2FkQXJyYXksIGRhdGFDaHVuaywgY3N0eXBlKSB7XG4gIGlmIChDaGVjay5hbnl0aGluZyhkYXRhQ2h1bmspICYmIGRhdGFDaHVuay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3NlID0gbmV3IENvbnRlbnRTdW1tYXJ5RWxlbWVudChjc3R5cGUsIE5hTiwgZGF0YUNodW5rLmxlbmd0aCk7XG4gICAgY3N1bW0ucHVzaChjc2UpO1xuICAgIHBheWxvYWRBcnJheS5wdXNoKGRhdGFDaHVuayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVG9NYXBJZlByZXNlbnQoaGVhZGVyTWFwLCBrZXksIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChDaGVjay5hbnl0aGluZyh2YWx1ZSkpIHtcbiAgICBoZWFkZXJNYXAuYWRkRmllbGQoa2V5LCBTRFRGaWVsZC5jcmVhdGUodHlwZSwgdmFsdWUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGFwdE1lc3NhZ2VUb0JpbmFyeU1ldGEobWVzc2FnZSkge1xuICAvLyBzb2xhY2UgaGVhZGVyIG1hcFxuICBjb25zdCBoZWFkZXJNYXAgPSBuZXcgU0RUTWFwQ29udGFpbmVyKCk7XG4gIGFkZFRvTWFwSWZQcmVzZW50KGhlYWRlck1hcCwgJ2NpJywgU0RURmllbGRUeXBlLlNUUklORywgbWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCkpO1xuICBhZGRUb01hcElmUHJlc2VudChoZWFkZXJNYXAsICdtaScsIFNEVEZpZWxkVHlwZS5TVFJJTkcsIG1lc3NhZ2UuZ2V0QXBwbGljYXRpb25NZXNzYWdlSWQoKSk7XG4gIGFkZFRvTWFwSWZQcmVzZW50KGhlYWRlck1hcCwgJ210JywgU0RURmllbGRUeXBlLlNUUklORywgbWVzc2FnZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKCkpO1xuICBhZGRUb01hcElmUHJlc2VudChoZWFkZXJNYXAsICdydCcsIFNEVEZpZWxkVHlwZS5ERVNUSU5BVElPTiwgbWVzc2FnZS5nZXRSZXBseVRvKCkpO1xuICBhZGRUb01hcElmUHJlc2VudChoZWFkZXJNYXAsICdzaScsIFNEVEZpZWxkVHlwZS5TVFJJTkcsIG1lc3NhZ2UuZ2V0U2VuZGVySWQoKSk7XG4gIGFkZFRvTWFwSWZQcmVzZW50KGhlYWRlck1hcCwgJ3NuJywgU0RURmllbGRUeXBlLklOVDY0LCBtZXNzYWdlLmdldFNlcXVlbmNlTnVtYmVyKCkpO1xuICBhZGRUb01hcElmUHJlc2VudChoZWFkZXJNYXAsICd0cycsIFNEVEZpZWxkVHlwZS5JTlQ2NCwgbWVzc2FnZS5nZXRTZW5kZXJUaW1lc3RhbXAoKSk7XG4gIGFkZFRvTWFwSWZQcmVzZW50KGhlYWRlck1hcCwgJ2V4JywgU0RURmllbGRUeXBlLklOVDY0LCBtZXNzYWdlLmdldEdNRXhwaXJhdGlvbigpKTtcblxuICAvLyBjb250YWluZXIgbWFwOiBzb2xhY2UgaGVhZGVycyArIHVzZXIgcHJvcCBtYXBcbiAgY29uc3Qgc2R0TWFwID0gbmV3IFNEVE1hcENvbnRhaW5lcigpO1xuICBpZiAobWVzc2FnZS5nZXRVc2VyUHJvcGVydHlNYXAoKSkge1xuICAgIHNkdE1hcC5hZGRGaWVsZCgncCcsIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuTUFQLCBtZXNzYWdlLmdldFVzZXJQcm9wZXJ0eU1hcCgpKSk7XG4gIH1cbiAgaWYgKGhlYWRlck1hcC5nZXRLZXlzKCkubGVuZ3RoID4gMCkge1xuICAgIHNkdE1hcC5hZGRGaWVsZCgnaCcsIFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuTUFQLCBoZWFkZXJNYXApKTtcbiAgfVxuXG4gIGxldCBlbmNvZGVkU2R0UGF5bG9hZCA9IG51bGw7XG4gIGxldCBwcmVhbWJsZUJ5dGUwID0gMDtcbiAgc3dpdGNoIChtZXNzYWdlLmdldFR5cGUoKSkge1xuICAgIGNhc2UgTWVzc2FnZUxpYi5NZXNzYWdlVHlwZS5CSU5BUlk6XG4gICAgICBwcmVhbWJsZUJ5dGUwIHw9IDB4ODA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1lc3NhZ2VMaWIuTWVzc2FnZVR5cGUuTUFQOlxuICAgICAgcHJlYW1ibGVCeXRlMCB8PSAweDBBO1xuICAgICAgZW5jb2RlZFNkdFBheWxvYWQgPSBlbmNvZGVTaW5nbGVFbGVtZW50KG1lc3NhZ2UuX3N0cnVjdHVyZWRDb250YWluZXIpO1xuICAgICAgaWYgKGVuY29kZWRTZHRQYXlsb2FkKSB7XG4gICAgICAgIG1lc3NhZ2UuX3NldEJpbmFyeUF0dGFjaG1lbnQoZW5jb2RlZFNkdFBheWxvYWQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBNZXNzYWdlTGliLk1lc3NhZ2VUeXBlLlNUUkVBTTpcbiAgICAgIHByZWFtYmxlQnl0ZTAgfD0gMHgwQjtcbiAgICAgIGVuY29kZWRTZHRQYXlsb2FkID0gZW5jb2RlU2luZ2xlRWxlbWVudChtZXNzYWdlLl9zdHJ1Y3R1cmVkQ29udGFpbmVyKTtcbiAgICAgIGlmIChlbmNvZGVkU2R0UGF5bG9hZCkge1xuICAgICAgICBtZXNzYWdlLl9zZXRCaW5hcnlBdHRhY2htZW50KGVuY29kZWRTZHRQYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTWVzc2FnZUxpYi5NZXNzYWdlVHlwZS5URVhUOlxuICAgICAgcHJlYW1ibGVCeXRlMCB8PSAweDA3O1xuICAgICAgZW5jb2RlZFNkdFBheWxvYWQgPSBlbmNvZGVTaW5nbGVFbGVtZW50KG1lc3NhZ2UuX3N0cnVjdHVyZWRDb250YWluZXIpO1xuICAgICAgaWYgKGVuY29kZWRTZHRQYXlsb2FkKSB7XG4gICAgICAgIG1lc3NhZ2UuX3NldEJpbmFyeUF0dGFjaG1lbnQoZW5jb2RlZFNkdFBheWxvYWQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIExPR19JTkZPKGBVbmhhbmRsZWQgbWVzc2FnZVR5cGU6ICR7bWVzc2FnZS5nZXRUeXBlKCl9YCk7XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCBwcmVhbWJsZUJ5dGUxID0gbWVzc2FnZS5pc1JlcGx5TWVzc2FnZSgpID8gMHg4MCA6IDA7XG4gIGNvbnN0IHNkdFByZWFtYmxlID0gU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5CWVRFQVJSQVksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUocHJlYW1ibGVCeXRlMCwgcHJlYW1ibGVCeXRlMSkpO1xuXG4gIC8vIFB1dHRpbmcgaXQgYWxsIHRvZ2V0aGVyOiBhIHN0cmVhbSB3aXRoIHRoZSBwcmVhbWJsZSBhbmQgbWFwXG4gIGNvbnN0IHNkdFN0cmVhbUNvbnRhaW5lciA9IG5ldyBTRFRTdHJlYW1Db250YWluZXIoKTtcbiAgc2R0U3RyZWFtQ29udGFpbmVyLmFkZEZpZWxkKHNkdFByZWFtYmxlKTtcbiAgc2R0U3RyZWFtQ29udGFpbmVyLmFkZEZpZWxkKFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuTUFQLCBzZHRNYXApKTtcblxuICBjb25zdCBiaW5hcnlNZXRhID0gbmV3IEJpbmFyeU1ldGFCbG9jaygpO1xuICBiaW5hcnlNZXRhLnR5cGUgPSAwO1xuICBiaW5hcnlNZXRhLnBheWxvYWQgPSBlbmNvZGVTaW5nbGVFbGVtZW50KFNEVEZpZWxkLmNyZWF0ZShTRFRGaWVsZFR5cGUuU1RSRUFNLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZHRTdHJlYW1Db250YWluZXIpKTtcbiAgbWVzc2FnZS5iaW5hcnlNZXRhZGF0YUNodW5rID0gYmluYXJ5TWV0YTtcbn1cblxuXG5mdW5jdGlvbiBhZGFwdE1lc3NhZ2VUb1NtZihtZXNzYWdlLCBzbWZIZWFkZXJJbikge1xuICBjb25zdCBzbWZIZWFkZXIgPSBzbWZIZWFkZXJJbjtcbiAgY29uc3QgZGVsaXZlcnlNb2RlID0gbWVzc2FnZS5nZXREZWxpdmVyeU1vZGUoKTtcblxuICBzbWZIZWFkZXIuc21mX2R0byA9IG1lc3NhZ2UuaXNEZWxpdmVyVG9PbmUoKTtcbiAgc21mSGVhZGVyLnBtX2RlbGl2ZXJ5bW9kZSA9IGRlbGl2ZXJ5TW9kZTtcbiAgc21mSGVhZGVyLnNtZl9hZGYgPSBkZWxpdmVyeU1vZGUgPT09IE1lc3NhZ2VMaWIuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUuRElSRUNUID8gMCA6IDE7XG4gIHNtZkhlYWRlci5zbWZfZGkgPSBtZXNzYWdlLmlzRGlzY2FyZEluZGljYXRpb24oKTtcbiAgc21mSGVhZGVyLnNtZl9lbGlkaW5nRWxpZ2libGUgPSBtZXNzYWdlLmlzRWxpZGluZ0VsaWdpYmxlKCk7XG4gIHNtZkhlYWRlci5zbWZfZGVhZE1lc3NhZ2VRdWV1ZUVsaWdpYmxlID0gbWVzc2FnZS5pc0RNUUVsaWdpYmxlKCk7XG4gIHNtZkhlYWRlci5wbV9hZF9mbG93aWQgPSBtZXNzYWdlLmdldEZsb3dJZCgpO1xuICBzbWZIZWFkZXIucG1fYWRfcHVibGlzaGVyaWQgPSBtZXNzYWdlLmdldFB1Ymxpc2hlcklkKCk7XG4gIHNtZkhlYWRlci5wbV9hZF9wdWJsaXNoZXJtc2dJZCA9IG1lc3NhZ2UuZ2V0UHVibGlzaGVyTWVzc2FnZUlkKCk7XG4gIHNtZkhlYWRlci5wbV9hZF9tc2dpZCA9IG1lc3NhZ2UuZ2V0R3VhcmFudGVlZE1lc3NhZ2VJZCgpO1xuICBzbWZIZWFkZXIucG1fYWRfcHJldm1zZ2lkID0gbWVzc2FnZS5nZXRHdWFyYW50ZWVkUHJldmlvdXNNZXNzYWdlSWQoKTtcbiAgc21mSGVhZGVyLnBtX2FkX3R0bCA9IG1lc3NhZ2UuZ2V0VGltZVRvTGl2ZSgpO1xuICBzbWZIZWFkZXIucG1fYWRfYWNraW1tID0gbWVzc2FnZS5pc0Fja25vd2xlZGdlSW1tZWRpYXRlbHkoKTtcbiAgc21mSGVhZGVyLnBtX2FkX3JlZGVsZmxhZyA9IG1lc3NhZ2UuaXNSZWRlbGl2ZXJlZCgpO1xuXG4gIGNvbnN0IGRlc3QgPSBtZXNzYWdlLmdldERlc3RpbmF0aW9uKCk7XG4gIGlmIChkZXN0KSB7XG4gICAgc21mSGVhZGVyLnBtX3RyX3RvcGljbmFtZV9ieXRlcyA9IGRlc3QuZ2V0Qnl0ZXMoKTtcbiAgICBpZiAoZGVzdC50eXBlID09PSBEZXN0aW5hdGlvblR5cGUuUVVFVUUgfHxcbiAgICAgICAgZGVzdC50eXBlID09PSBEZXN0aW5hdGlvblR5cGUuVEVNUE9SQVJZX1FVRVVFKSB7XG4gICAgICBjb25zdCB7IG9mZnNldCB9ID0gZGVzdDtcbiAgICAgIHNtZkhlYWRlci5wbV9xdWV1ZV9sZW4gPSBzbWZIZWFkZXIucG1fdHJfdG9waWNuYW1lX2J5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgIHNtZkhlYWRlci5wbV9xdWV1ZV9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0dXAgdXNlciBwcm9wZXJ0aWVzLCBoZWFkZXIgcHJvcGVydGllcywgbXNndHlwZVxuICBpZiAobWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCkgfHxcbiAgICAgIG1lc3NhZ2UuZ2V0QXBwbGljYXRpb25NZXNzYWdlSWQoKSB8fFxuICAgICAgbWVzc2FnZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlKCkgfHxcbiAgICAgIG1lc3NhZ2UuZ2V0UmVwbHlUbygpIHx8XG4gICAgICBtZXNzYWdlLmdldFNlbmRlcklkKCkgfHxcbiAgICAgIG1lc3NhZ2UuZ2V0U2VxdWVuY2VOdW1iZXIoKSB8fFxuICAgICAgbWVzc2FnZS5nZXRTZW5kZXJUaW1lc3RhbXAoKSB8fFxuICAgICAgbWVzc2FnZS5nZXRVc2VyUHJvcGVydHlNYXAoKSB8fFxuICAgICAgbWVzc2FnZS5pc1JlcGx5TWVzc2FnZSgpIHx8XG4gICAgICAobWVzc2FnZS5nZXRUeXBlKCkgIT09IE1lc3NhZ2VMaWIuTWVzc2FnZVR5cGUuQklOQVJZKSkge1xuICAgIC8vIGFkZCBTRFQgYmluYXJ5IG1ldGFkYXRhXG4gICAgYWRhcHRNZXNzYWdlVG9CaW5hcnlNZXRhKG1lc3NhZ2UpO1xuICB9XG5cbiAgc21mSGVhZGVyLnNtZl9wcmlvcml0eSA9IHByaW9yaXR5Rm9yVXNlckNvcy52YWx1ZS5nZXQobWVzc2FnZS5nZXRVc2VyQ29zKCkpO1xuXG4gIGlmIChtZXNzYWdlLmdldFByaW9yaXR5KCkgIT09IHVuZGVmaW5lZFxuICAgICYmIHR5cGVvZiBtZXNzYWdlLmdldFByaW9yaXR5KCkgPT09ICdudW1iZXInXG4gICAgJiYgbWVzc2FnZS5nZXRQcmlvcml0eSgpIDw9IDI1NVxuICAgICYmIG1lc3NhZ2UuZ2V0UHJpb3JpdHkoKSA+PSAwKSB7XG4gICAgc21mSGVhZGVyLnBtX21zZ19wcmlvcml0eSA9IG1lc3NhZ2UuZ2V0UHJpb3JpdHkoKTtcbiAgfSBlbHNlIHtcbiAgICBzbWZIZWFkZXIucG1fbXNnX3ByaW9yaXR5ID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHVzZXJEYXRhID0gbWVzc2FnZS5nZXRVc2VyRGF0YSgpO1xuICBzbWZIZWFkZXIucG1fdXNlcmRhdGEgPSAodXNlckRhdGEgPT09IG51bGwgfHwgdXNlckRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IG51bGxcbiAgICA6IG1lc3NhZ2UuZ2V0VXNlckRhdGEoKTtcblxuICAvLyBCdWlsZCBhcnJheSBvZiBDb250ZW50U3VtbWFyeUVsZW1lbnRzXG4gIGNvbnN0IGNzdW1tID0gW107XG4gIGNvbnN0IHBheWxvYWQgPSBbXTtcbiAgYWRkQ29udGVudEVsZW1lbnRUb0FycmF5cyhjc3VtbSwgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdldFhtbE1ldGFkYXRhKCksIENvbnRlbnRTdW1tYXJ5VHlwZS5YTUxfTUVUQSk7XG4gIGFkZENvbnRlbnRFbGVtZW50VG9BcnJheXMoY3N1bW0sIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nZXRYbWxDb250ZW50KCksIENvbnRlbnRTdW1tYXJ5VHlwZS5YTUxfUEFZTE9BRCk7XG4gIGFkZENvbnRlbnRFbGVtZW50VG9BcnJheXMoY3N1bW0sIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nZXRCaW5hcnlBdHRhY2htZW50KCksIENvbnRlbnRTdW1tYXJ5VHlwZS5CSU5BUllfQVRUQUNITUVOVCk7XG5cbiAgY29uc3QgYmluYXJ5TWV0YSA9IG1lc3NhZ2UuYmluYXJ5TWV0YWRhdGFDaHVuaztcbiAgaWYgKGJpbmFyeU1ldGEgIT09IG51bGwpIHtcbiAgICBjb25zdCBiaW5hcnlNZXRhU01GID0gYmluYXJ5TWV0YS5hc0VuY29kZWRTbWYoKTtcbiAgICBjb25zdCBNQVhfMjRCSVRTID0gMTY3NzcyMTU7XG4gICAgaWYgKGJpbmFyeU1ldGFTTUYubGVuZ3RoID4gTUFYXzI0QklUUykge1xuICAgICAgTE9HX1RSQUNFKGBiaW5hcnktbWV0YSBkYXRhICgke2JpbmFyeU1ldGFTTUYubGVuZ3RofSkgb3ZlciB0aGUgJHtNQVhfMjRCSVRTfSBsaW1pdGApO1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBiaW5hcnktbWV0YSBkYXRhICgke2JpbmFyeU1ldGFTTUYubGVuZ3RofSkgb3ZlciB0aGUgJHtNQVhfMjRCSVRTfSBsaW1pdGAsIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ29udGVudEVsZW1lbnRUb0FycmF5cyhjc3VtbSwgcGF5bG9hZCwgYmluYXJ5TWV0YVNNRiwgQ29udGVudFN1bW1hcnlUeXBlLkJJTkFSWV9NRVRBREFUQSk7XG4gICAgfVxuICB9XG4gIGlmIChjc3VtbS5sZW5ndGggPT09IDAgfHxcbiAgICAgIChjc3VtbS5sZW5ndGggPT09IDEgJiYgY3N1bW1bMF0udHlwZSA9PT0gQ29udGVudFN1bW1hcnlUeXBlLkJJTkFSWV9BVFRBQ0hNRU5UKSkge1xuICAgIC8vIE5VTEwgb3IgUkFXIHBheWxvYWQgKG5vIGNvbnRlbnQtc3VtbWFyeSlcbiAgICAvLyAgV2FzIHRoaXMgaGVyZSB0byBpbnZlcnQgdGhlIGNvbmRpdGlvbj9cbiAgICAvLyBMT0dfVFJBQ0UoJ05VTEwgb3IgUkFXIHBheWxvYWQgKG5vIGNvbnRlbnQtc3VtbWFyeSknKTtcbiAgfSBlbHNlIHtcbiAgICBzbWZIZWFkZXIucG1fY29udGVudF9zdW1tYXJ5ID0gY3N1bW07XG4gIH1cblxuICBjb25zdCBwYXlsb2FkQnl0ZXMgPSBwYXlsb2FkLmpvaW4oJycpO1xuICBzbWZIZWFkZXIucGF5bG9hZCA9IHBheWxvYWRCeXRlcztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGFsbCB2YWx1ZXMgdGhhdCBmaXQgaW4gdGhlIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogZS5nLiBiaXRSYW5nZSgxKSA9PiBbMCwgMV0sIGJpdFJhbmdlKDIpID0+IFswLCAxLCAyLCAzXVxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSByYW5nZVxuICogQHJldHVybnMge051bWJlcn0gQWxsIHZhbHVlcyB0aGF0IGZpdCBpbiB0aGF0IG51bWJlciBvZiBiaXRzXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBiaXRSYW5nZSA9IGJpdHMgPT4gQXJyYXkuZnJvbShBcnJheShNYXRoLnBvdygyLCBiaXRzKSkpLm1hcCgoZWwsIGkpID0+IGkpO1xuY29uc3QgbWFza1ZhbHVlcyA9IChzaGlmdCwgYml0cykgPT4gYml0UmFuZ2UoYml0cykubWFwKHZhbCA9PiBzZXRCaXRzKDAsIHZhbCwgc2hpZnQsIGJpdHMpKTtcbmNvbnN0IERJX0JJVCA9IG1hc2tWYWx1ZXMoMzEsIDEpO1xuY29uc3QgRUxJRElOR19FTElHSUJMRV9CSVQgPSBtYXNrVmFsdWVzKDMwLCAxKTtcbmNvbnN0IERUT19CSVQgPSBtYXNrVmFsdWVzKDI5LCAxKTtcbmNvbnN0IEFERl9CSVQgPSBtYXNrVmFsdWVzKDI4LCAxKTtcbmNvbnN0IERNUUVfQklUID0gbWFza1ZhbHVlcygyNywgMSk7XG5jb25zdCBWRVJTSU9OX0JJVFMgPSBtYXNrVmFsdWVzKDI0LCAzKTtcbmNvbnN0IFVIX0JJVFMgPSBtYXNrVmFsdWVzKDIyLCAyKTtcbmNvbnN0IFBST1RPQ09MX0JJVFMgPSBtYXNrVmFsdWVzKDE2LCA2KTtcbmNvbnN0IFBSSU9SSVRZX0JJVFMgPSBtYXNrVmFsdWVzKDEyLCA0KTtcbmNvbnN0IFRUTF9CSVRTID0gbWFza1ZhbHVlcygwLCA4KTtcbmNvbnN0IFFUX09GRlNFVF9CWVRFUyA9IG1hc2tWYWx1ZXMoOCwgOCk7XG5jb25zdCBRVF9MRU5fQllURVMgPSBtYXNrVmFsdWVzKDAsIDgpO1xuXG5mdW5jdGlvbiBlbmNvZGVTTUYoaGVhZGVyKSB7XG4gIC8vIEZpcnN0IDQgYnl0ZXM6IHByb3RvY29sLCB0dGwsIGV0Y1xuICBsZXQgdzEgPSAwO1xuXG4gIC8vIFBFUkY6IHNpbmdsZSBleHByZXNzaW9uIHRvIG1ha2UgdzEgY29uc3RcbiAgdzEgfD0gRElfQklUW2hlYWRlci5zbWZfZGkgJiYgMSB8fCAwXTtcbiAgdzEgfD0gRUxJRElOR19FTElHSUJMRV9CSVRbaGVhZGVyLnNtZl9lbGlkaW5nRWxpZ2libGUgJiYgMSB8fCAwXTtcbiAgdzEgfD0gRFRPX0JJVFtoZWFkZXIuc21mX2R0byAmJiAxIHx8IDBdO1xuICB3MSB8PSBBREZfQklUW2hlYWRlci5zbWZfYWRmICYmIDEgfHwgMF07XG4gIHcxIHw9IERNUUVfQklUW2hlYWRlci5zbWZfZGVhZE1lc3NhZ2VRdWV1ZUVsaWdpYmxlICYmIDEgfHwgMF07XG4gIHcxIHw9IFZFUlNJT05fQklUU1toZWFkZXIuc21mX3ZlcnNpb24gfHwgMF07XG4gIHcxIHw9IFVIX0JJVFNbaGVhZGVyLnNtZl91aCB8fCAwXTtcbiAgdzEgfD0gUFJPVE9DT0xfQklUU1toZWFkZXIuc21mX3Byb3RvY29sIHx8IDBdO1xuICB3MSB8PSBQUklPUklUWV9CSVRTW2hlYWRlci5zbWZfcHJpb3JpdHkgfHwgMF07XG4gIHcxIHw9IFRUTF9CSVRTW2hlYWRlci5zbWZfdHRsIHx8IDBdOyAvLyBQRVJGOiBvciBzZXQgdzEgdG8gdHRsIGluaXRpYWxseS5cblxuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgLy8gRW5jb2RlIGFsbCBzdGFuZGFyZCBTTUYgcGFyYW1ldGVyc1xuICAvLyBUb3BpYyBuYW1lIGFuZCBxdWV1ZS90b3BpYyBvZmZzZXRzIGFyZSBzdXBwb3NlZCB0byBjb21lIGZpcnN0XG4gIGlmIChoZWFkZXIucG1fdHJfdG9waWNuYW1lX2J5dGVzKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMiwgU01GUGFyYW1ldGVyVHlwZS5UUl9UT1BJQ05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7aGVhZGVyLnBtX3RyX3RvcGljbmFtZV9ieXRlc31gKSk7XG4gIH1cbiAgaWYgKGhlYWRlci5wbV9xdWV1ZV9sZW4pIHtcbiAgICBwYXJhbXMucHVzaChlbmNMaWdodFNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuTElHSFRfUVVFVUVfTkFNRV9PRkZTRVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQxNlRvU3RyKFFUX09GRlNFVF9CWVRFU1toZWFkZXIucG1fcXVldWVfb2Zmc2V0XSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFFUX0xFTl9CWVRFU1toZWFkZXIucG1fcXVldWVfbGVuXSkpKTtcbiAgfVxuICBpZiAoaGVhZGVyLnBtX3RvcGljX2xlbikge1xuICAgIHBhcmFtcy5wdXNoKGVuY0xpZ2h0U01GUGFyYW0oMCwgU01GUGFyYW1ldGVyVHlwZS5MSUdIVF9UT1BJQ19OQU1FX09GRlNFVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDE2VG9TdHIoUVRfT0ZGU0VUX0JZVEVTW2hlYWRlci5wbV90b3BpY19vZmZzZXRdIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUVRfT0ZGU0VUX0JZVEVTW2hlYWRlci5wbV90b3BpY19sZW5dKSkpO1xuICB9XG5cbiAgaWYgKGhlYWRlci5wbV9jb3JydGFnICE9PSBudWxsICYmIGhlYWRlci5wbV9jb3JydGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMucHVzaChlbmNMaWdodFNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuTElHSFRfQ09SUkVMQVRJT04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQyNFRvU3RyKGhlYWRlci5wbV9jb3JydGFnKSkpO1xuICB9XG4gIGlmIChoZWFkZXIucG1fYWRfYWNraW1tKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jTGlnaHRTTUZQYXJhbSgwLCBTTUZQYXJhbWV0ZXJUeXBlLkxJR0hUX0FDS19JTU1FRElBVEVMWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnKSk7XG4gIH1cblxuICBpZiAoaGVhZGVyLnBtX21zZ19wcmlvcml0eSAhPT0gbnVsbCkge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuTUVTU0FHRVBSSU9SSVRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDhUb1N0cihoZWFkZXIucG1fbXNnX3ByaW9yaXR5KSkpO1xuICB9XG4gIGlmIChoZWFkZXIucG1fdXNlcmRhdGEgIT09IG51bGwgJiYgaGVhZGVyLnBtX3VzZXJkYXRhICE9PSAnJykge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuVVNFUkRBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnBtX3VzZXJkYXRhKSk7XG4gIH1cbiAgaWYgKGhlYWRlci5wbV91c2VybmFtZSkge1xuICAgIC8vIGRvIGEgc2xvcHB5IGJhc2U2NCAobm8gbmV3bGluZXMpXG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMCwgU01GUGFyYW1ldGVyVHlwZS5VU0VSTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjRFbmNvZGUoaGVhZGVyLnBtX3VzZXJuYW1lKSkpO1xuICB9XG4gIGlmIChoZWFkZXIucG1fcGFzc3dvcmQpIHtcbiAgICAvLyBkbyBhIHNsb3BweSBiYXNlNjQgKG5vIG5ld2xpbmVzKVxuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuUEFTU1dPUkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0RW5jb2RlKGhlYWRlci5wbV9wYXNzd29yZCkpKTtcbiAgfVxuICBpZiAoaGVhZGVyLnBtX3Jlc3Bjb2RlKSB7XG4gICAgLy8gbm90IHVzZWZ1bCBBUEktPnJvdXRlclxuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50MzJUb1N0cihoZWFkZXIucG1fcmVzcGNvZGUpICsgaGVhZGVyLnBtX3Jlc3BzdHIpKTtcbiAgfVxuXG4gIGlmIChoZWFkZXIucG1fZGVsaXZlcnltb2RlICE9PSBudWxsKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMCwgU01GUGFyYW1ldGVyVHlwZS5ERUxJVkVSWV9NT0RFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY0RlbGl2ZXJ5TW9kZShoZWFkZXIucG1fZGVsaXZlcnltb2RlKSkpO1xuICB9XG5cbiAgaWYgKGhlYWRlci5wbV9hZF9tc2dpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMiwgU01GUGFyYW1ldGVyVHlwZS5BU1NVUkVEX01FU1NBR0VfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50NjRUb1N0cihoZWFkZXIucG1fYWRfbXNnaWQpKSk7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMiwgU01GUGFyYW1ldGVyVHlwZS5BU1NVUkVEX1BSRVZNRVNTQUdFX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDY0VG9TdHIoaGVhZGVyLnBtX2FkX3ByZXZtc2dpZCkpKTtcbiAgfVxuXG4gIGlmIChoZWFkZXIucG1fYWRfZmxvd2lkKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMCwgU01GUGFyYW1ldGVyVHlwZS5BU1NVUkVEX0ZMT1dJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQzMlRvU3RyKGhlYWRlci5wbV9hZF9mbG93aWQpKSk7XG4gIH1cblxuICAvLyBoZWFkZXIucG1fYWRfcmVkZWxmbGFnXG4gIC8vIEFkIHJlZGVsaXZlcmVkXG4gIGlmIChoZWFkZXIucG1fYWRfcmVkZWxmbGFnKSB7XG4gICAgcGFyYW1zLnB1c2goZW5jb2RlU01GUGFyYW0oMCwgU01GUGFyYW1ldGVyVHlwZS5BU1NVUkVEX1JFREVMSVZFUkVEX0ZMQUcsIHVuZGVmaW5lZCkpO1xuICB9XG4gIC8vIGhlYWRlci5wbV9hZF9mbG93cmVkZWxmbGFnXG5cbiAgaWYgKGhlYWRlci5wbV9hZF90dGwgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuQURfVElNRVRPTElWRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQ2NFRvU3RyKGhlYWRlci5wbV9hZF90dGwpKSk7XG4gIH1cblxuICAvLyBzZXF1ZW5jZSBudW1iZXI/XG5cbiAgaWYgKGhlYWRlci5wbV9hZF9wdWJsaXNoZXJpZCkge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuUFVCTElTSEVSX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDMyVG9TdHIoaGVhZGVyLnBtX2FkX3B1Ymxpc2hlcmlkKSkpO1xuICB9XG5cbiAgaWYgKGhlYWRlci5wbV9hZF9wdWJsaXNoZXJNc2dJZCkge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDAsIFNNRlBhcmFtZXRlclR5cGUuUFVCTElTSEVSX01TR0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDY0VG9TdHIoaGVhZGVyLnBtX2FkX3B1Ymxpc2hlck1zZ0lkKSkpO1xuICB9XG5cbiAgLy8gdHJhbnNhY3Rpb25zOiBhY2ttZXNzYWdlaWQsIHRyYW5zYWN0aW9uaWQsIHRyYW5zYWN0aW9uZmxhZ3NcblxuICBpZiAoaGVhZGVyLnBtX2NvbnRlbnRfc3VtbWFyeSkge1xuICAgIHBhcmFtcy5wdXNoKGVuY29kZVNNRlBhcmFtKDIsIFNNRlBhcmFtZXRlclR5cGUuTUVTU0FHRV9DT05URU5UX1NVTU1BUlksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jQ29udGVudFN1bW1hcnkoaGVhZGVyLnBtX2NvbnRlbnRfc3VtbWFyeSkpKTtcbiAgfVxuICAvLyBkb25lIGNvbW1vbiBTTUYgcGFyYW1ldGVycyFcblxuICAvLyBjb21wdXRlIGhlYWRlciBzaXplIGFuZCBmdWxsIG1lc3NhZ2Ugc2l6ZVxuICBjb25zdCBlbmNvZGVkUGFyYW1zID0gcGFyYW1zLmpvaW4oJycpO1xuICBjb25zdCBoZHJsZW4gPSAxMiArIGVuY29kZWRQYXJhbXMubGVuZ3RoO1xuICBjb25zdCBtc2dsZW4gPSBoZHJsZW4gKyBoZWFkZXIucGF5bG9hZExlbmd0aDtcblxuICAvLyA/IEFscmVhZHkgZW5jb2RlZC4gV2h5IGJvdGhlcj9cbiAgaGVhZGVyLnNldE1lc3NhZ2VTaXplcyhoZHJsZW4sIGhlYWRlci5wYXlsb2FkTGVuZ3RoKTtcblxuICByZXR1cm4gKFxuICAgIGludDMyVG9TdHIodzEpICtcbiAgICBpbnQzMlRvU3RyKGhkcmxlbikgK1xuICAgIGludDMyVG9TdHIobXNnbGVuKSArXG4gICAgZW5jb2RlZFBhcmFtc1xuICApO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb21wb3VuZE1lc3NhZ2UobXNnKSB7XG4gIGxldCBwYXlsb2FkID0gJyc7XG4gIGlmIChtc2cgaW5zdGFuY2VvZiBNZXNzYWdlTGliLk1lc3NhZ2UpIHtcbiAgICBpZiAoIW1zZy5zbWZIZWFkZXIpIHtcbiAgICAgIG1zZy5zbWZIZWFkZXIgPSBuZXcgU01GSGVhZGVyKFNNRlByb3RvY29sLlRSTVNHLCAyNTUpO1xuICAgIH1cbiAgICBhZGFwdE1lc3NhZ2VUb1NtZihtc2csIG1zZy5fc21mSGVhZGVyKTtcbiAgICBwYXlsb2FkID0gbXNnLl9zbWZIZWFkZXIucGF5bG9hZDtcbiAgfSBlbHNlIGlmIChtc2cgaW5zdGFuY2VvZiBDbGllbnRDdHJsTWVzc2FnZSkge1xuICAgIHBheWxvYWQgPSBlbmNDQyhtc2cpO1xuICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIFNNUE1lc3NhZ2UpIHtcbiAgICBwYXlsb2FkID0gZW5jU21wKG1zZyk7XG4gIH0gZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgS2VlcEFsaXZlTWVzc2FnZSkge1xuICAgIExPR19UUkFDRSgnU2tpcHBpbmcgcmV0cmlldmUgcGF5bG9hZCBhcyB0aGVyZSBpcyBub25lIGluIGEgS2VlcEFsaXZlTWVzc2FnZScpO1xuICB9IGVsc2UgaWYgKG1zZyBpbnN0YW5jZW9mIEFkUHJvdG9jb2xNZXNzYWdlKSB7XG4gICAgcGF5bG9hZCA9IGVuY0FkcChtc2cpO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IG1zZy5zbWZIZWFkZXI7XG4gIGhlYWRlci5zZXRQYXlsb2FkU2l6ZShwYXlsb2FkLmxlbmd0aCk7XG4gIGNvbnN0IGVuY29kZWRIZWFkZXIgPSBlbmNvZGVTTUYoaGVhZGVyKTtcbiAgcmV0dXJuIGVuY29kZWRIZWFkZXIgKyBwYXlsb2FkO1xufVxuXG5jb25zdCBFbmNvZGUgPSB7XG4gIGVuY29kZUNvbXBvdW5kTWVzc2FnZSxcbiAgZW5jb2RlU01GLFxufTtcblxubW9kdWxlLmV4cG9ydHMuRW5jb2RlID0gRW5jb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9jb2RlYy9lbmNvZGUuanMiLCIvKipcbiAqIENyZWF0ZWQgYnkgcnBhdWxzb24gb24gMDYvMDIvMjAxNy5cbiAqL1xuY29uc3QgeyBCYXNlTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9iYXNlLW1lc3NhZ2UnKTtcbmNvbnN0IHsgQ29udmVydCwgTG9uZyB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgRGVzdGluYXRpb25UeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgTE9HX1RSQUNFIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgUXVldWVBY2Nlc3NUeXBlLFxuICAgICAgICBRdWV1ZURpc2NhcmRCZWhhdmlvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXF1ZXVlJyk7XG5jb25zdCB7IFF1ZXVlUGVybWlzc2lvbnMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1xdWV1ZScpO1xuY29uc3QgeyBTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUgfSA9IHJlcXVpcmUoJy4uL3NtZi1hZHByb3RvY29sLW1lc3NhZ2UtdHlwZXMnKTtcbmNvbnN0IHsgU01GQWRQcm90b2NvbFBhcmFtIH0gPSByZXF1aXJlKCcuLi9zbWYtYWRwcm90b2NvbC1wYXJhbXMnKTtcbmNvbnN0IHsgU01GSGVhZGVyIH0gPSByZXF1aXJlKCcuL3NtZi1oZWFkZXInKTtcbmNvbnN0IHsgU01GUGFyYW1ldGVyIH0gPSByZXF1aXJlKCcuL3NtZi1wYXJhbWV0ZXInKTtcbmNvbnN0IHsgU01GUHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3NtZi1wcm90b2NvbHMnKTtcbmNvbnN0IHsgU01GVUggfSA9IHJlcXVpcmUoJy4vc21mLXVoJyk7XG5jb25zdCB7IFN0cmluZ1V0aWxzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtdXRpbCcpO1xuXG5jb25zdCB7XG4gIHN0clRvSW50OCxcbiAgc3RyVG9JbnQxNixcbiAgc3RyVG9VSW50MzIsXG4gIHN0clRvVUludDY0LFxufSA9IENvbnZlcnQ7XG5cbmNvbnN0IHtcbiAgc3RyaXBOdWxsVGVybWluYXRlLFxufSA9IFN0cmluZ1V0aWxzO1xuXG4vLyBRVUVVRU5BTUUvVE9QSUNOQU1FXG5jb25zdCBFbmRwb2ludFR5cGVUb1BhcmFtID0ge1xuICBbRGVzdGluYXRpb25UeXBlLlRPUElDXTogU01GQWRQcm90b2NvbFBhcmFtLkRURU5BTUUsXG4gIFtEZXN0aW5hdGlvblR5cGUuUVVFVUVdOiBTTUZBZFByb3RvY29sUGFyYW0uUVVFVUVOQU1FLFxufTtcblxuY29uc3QgUVVFVUVfUEVSTUlTU0lPTlNfVE9fQklUUyA9IHtcbiAgW1F1ZXVlUGVybWlzc2lvbnMuTk9ORV06ICAgICAgICAgMHgwMDAwLFxuICBbUXVldWVQZXJtaXNzaW9ucy5SRUFEX09OTFldOiAgICAweDAwMDEsXG4gIFtRdWV1ZVBlcm1pc3Npb25zLkNPTlNVTUVdOiAgICAgIDB4MDAwMyxcbiAgW1F1ZXVlUGVybWlzc2lvbnMuTU9ESUZZX1RPUElDXTogMHgwMDA3LFxuICBbUXVldWVQZXJtaXNzaW9ucy5ERUxFVEVdOiAgICAgICAweDAwMGYsXG59O1xuXG5jb25zdCBBQ0NFU1NfVFlQRV9JTlRfVE9fRU5VTSA9IHtcbiAgMHgwMTogUXVldWVBY2Nlc3NUeXBlLkVYQ0xVU0lWRSxcbiAgMHgwMjogUXVldWVBY2Nlc3NUeXBlLk5PTkVYQ0xVU0lWRSxcbn07XG5cbmNvbnN0IERJU0NBUkRfRU5VTV9UT19WQUxVRSA9IHtcbiAgW1F1ZXVlRGlzY2FyZEJlaGF2aW9yLk5PVElGWV9TRU5ERVJfT0ZGXTogMHgwMSxcbiAgW1F1ZXVlRGlzY2FyZEJlaGF2aW9yLk5PVElGWV9TRU5ERVJfT05dOiAgMHgwMixcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIEFkUHJvdG9jb2xNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlfSBbbWVzc2FnZVR5cGU9U01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLk9QRU5QVUJGTE9XXVxuICAgKiAgVGhlIHR5cGUgb2YgbWVzc2FnZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ZlcnNpb249M10gVGhlIEFEIHByb3RvY29sIHZlcnNpb24gZm9yIHRoZSBtZXNzYWdlXG4gICAqIEBleHRlbmRzIHtCYXNlTWVzc2FnZX1cbiAgICogQG1lbWJlcm9mIHNvbGFjZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2VUeXBlID0gMCwgdmVyc2lvbiA9IDMpIHtcbiAgICBzdXBlcihuZXcgU01GSGVhZGVyKFNNRlByb3RvY29sLkFEQ1RSTCwgMSkpO1xuXG4gICAgLy8gRmllbGQ6IG1zZ3R5cGVcbiAgICB0aGlzLm1zZ1R5cGUgPSBtZXNzYWdlVHlwZTtcblxuICAgIC8vIEZpZWxkOiB2ZXJzaW9uXG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgfVxuXG4gIF9yZWFkUGFyYW1ldGVyKHBhcmFtdHlwZSwgZGVjb2RlciA9IG51bGwpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKHBhcmFtdHlwZSk7XG4gICAgaWYgKHBhcmFtID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbS5nZXRWYWx1ZSgpO1xuICAgIHJldHVybiBkZWNvZGVyID8gZGVjb2Rlcih2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P1F1ZXVlQWNjZXNzVHlwZX0gVGhlIGFjY2VzcyB0eXBlLCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRBY2Nlc3NUeXBlKCkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uQUNDRVNTVFlQRSwgc3RyVG9JbnQ4KTtcbiAgICByZXR1cm4gQUNDRVNTX1RZUEVfSU5UX1RPX0VOVU1bcGFyYW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/Qm9vbGVhbn0gVGhlIGFjdGl2ZSBmbG93IGluZGljYXRpb24sIGlmIHByZXNlbnRcbiAgICovXG4gIGdldEFjdGl2ZUZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXJhbWV0ZXIoU01GQWRQcm90b2NvbFBhcmFtLkFDVElWRV9GTE9XX0lORElDQVRJT04sIHN0clRvSW50OCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9RdWV1ZURpc2NhcmRCZWhhdmlvcn0gVGhlIGRpc2NhcmQgYmVoYXZpb3IgZm9yIHRoZSBlbmRwb2ludCwgaWYgcHJlc2VudFxuICAgKi9cbiAgZ2V0UXVldWVEaXNjYXJkQmVoYXZpb3IoKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLl9yZWFkUGFyYW1ldGVyKFNNRkFkUHJvdG9jb2xQYXJhbS5FUF9CRUhBVklPVVIsIHN0clRvSW50MTYpO1xuICAgIC8vIEdldCBOb3RpZnlTZW5kZXIgZmxhZ1xuICAgIGNvbnN0IG1hc2tlZCA9IChwYXJhbSAmIDB4MzAwMCkgPj4gMTI7XG4gICAgaWYgKG1hc2tlZCA9PT0gRElTQ0FSRF9FTlVNX1RPX1ZBTFVFW1F1ZXVlRGlzY2FyZEJlaGF2aW9yLk5PVElGWV9TRU5ERVJfT0ZGXSkge1xuICAgICAgcmV0dXJuIFF1ZXVlRGlzY2FyZEJlaGF2aW9yLk5PVElGWV9TRU5ERVJfT0ZGO1xuICAgIH1cbiAgICByZXR1cm4gUXVldWVEaXNjYXJkQmVoYXZpb3IuTk9USUZZX1NFTkRFUl9PTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P051bWJlcn0gVGhlIGVuZHBvaW50IElELCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRFbmRwb2ludElkKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkUGFyYW1ldGVyKFNNRkFkUHJvdG9jb2xQYXJhbS5FTkRQT0lOVF9JRCwgc3RyVG9VSW50MzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBXaGV0aGVyIGVuZHBvaW50IHJlc3BlY3RzIFRUTFxuICAgKi9cbiAgZ2V0UmVzcGVjdHNUVEwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uRVBfUkVTUEVDVFNfVFRMLCBzdHJUb0ludDgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBUaGUgcm91dGVyLWFzc2lnbmVkIGZsb3cgbmFtZSwgaWYgcHJlc2VudFxuICAgKi9cbiAgZ2V0Rmxvd05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXJhbWV0ZXIoU01GQWRQcm90b2NvbFBhcmFtLkZMT1dOQU1FLCBzdHJpcE51bGxUZXJtaW5hdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgcm91dGVyLWFzc2lnbmVkIGZsb3cgSUQsIGlmIHByZXNlbnRcbiAgICovXG4gIGdldEZsb3dJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uRkxPV0lELCBzdHJUb1VJbnQzMik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9TdHJpbmd9IFRoZSBVVEYtOCBlbmNvZGVkLCBudWxsIHRlcm1pbmF0ZWQgZW5kcG9pbnQgbmFtZVxuICAgKi9cbiAgZ2V0VG9waWNFbmRwb2ludEJ5dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkUGFyYW1ldGVyKFNNRkFkUHJvdG9jb2xQYXJhbS5EVEVOQU1FKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P1F1ZXVlUGVybWlzc2lvbnN9IFRoZSBncmFudGVkIHBlcm1pc3Npb25zIGZvciB0aGUgZmxvdywgaWYgcHJlc2VudFxuICAgKi9cbiAgZ2V0R3JhbnRlZFBlcm1pc3Npb25zKCkge1xuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uR1JBTlRFRF9QRVJNSVNTSU9OUywgc3RyVG9VSW50MzIpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgT2JqZWN0LmtleXMoUVVFVUVfUEVSTUlTU0lPTlNfVE9fQklUUykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoUVVFVUVfUEVSTUlTU0lPTlNfVE9fQklUU1trZXldID09PSBwZXJtaXNzaW9ucykge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P0xvbmd9IFRoZSBsYXN0IG1lc3NhZ2UgSUQgYWNrZWQsIGlmIHByZXNlbnRcbiAgICovXG4gIGdldExhc3RNc2dJZEFja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkUGFyYW1ldGVyKFNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURBQ0tFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJUb1VJbnQ2NCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9Mb25nfSBUaGUgbGFzdCBtZXNzYWdlIElEIHJlY2VpdmVkLCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRMYXN0TXNnSWRSZWNlaXZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uTEFTVE1TR0lEUkVDRUlWRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyVG9VSW50NjQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgcHVibGlzaGVyIElELCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRQdWJsaXNoZXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uUFVCTElTSEVSX0lELCBzdHJUb1VJbnQzMik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgez9OdW1iZXJ9IFdoZXRoZXIgd2Ugd2FudCBmbG93IGNoYW5nZSBub3RpZmljYXRpb25zLCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRXYW50Rmxvd0NoYW5nZU5vdGlmeSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9yZWFkUGFyYW1ldGVyKFNNRkFkUHJvdG9jb2xQYXJhbS5XQU5UX0ZMT1dfQ0hBTkdFX05PVElGWSwgc3RyVG9JbnQ4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7P051bWJlcn0gVGhlIFdpbmRvdyBwYXJhbWV0ZXIsIGlmIHByZXNlbnRcbiAgICovXG4gIGdldFdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhcmFtZXRlcihTTUZBZFByb3RvY29sUGFyYW0uV0lORE9XLCBzdHJUb0ludDgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHs/TnVtYmVyfSBUaGUgbWF4IHVuYWNrZWQgbWVzc2FnZXMgcGFyYW1ldGVyLCBpZiBwcmVzZW50XG4gICAqL1xuICBnZXRNYXhVbmFja2VkTWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXJhbWV0ZXIoU01GQWRQcm90b2NvbFBhcmFtLk1BWF9ERUxJVkVSRURfVU5BQ0tFRF9NRVNTQUdFU19QRVJfRkxPVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJUb1VJbnQzMik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIENMT1NFUFVCRkxPVyBtZXNzYWdlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmbG93SWQgVGhlIHB1Ymxpc2hlciBmbG93IHRvIGNsb3NlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JyZWxhdGlvblRhZyBUaGUgY29ycmVsYXRpb24gdGFnIGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7QWRQcm90b2NvbE1lc3NhZ2V9IFRoZSBuZXdseSBjcmVhdGVkIG1lc3NhZ2VcbiAgICogQGludGVybmFsXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXRDbG9zZU1lc3NhZ2VQdWJsaXNoZXIoZmxvd0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFnKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xPU0VQVUJGTE9XKTtcblxuICAgIGNvbnN0IGhlYWRlciA9IG1lc3NhZ2Uuc21mSGVhZGVyO1xuICAgIGhlYWRlci5wbV9jb3JydGFnID0gY29ycmVsYXRpb25UYWc7XG5cbiAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILlJFSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5GTE9XSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG93SWQpKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFkUHJvdG9jb2xNZXNzYWdlIHRoYXQgZGVzY3JpYmVzIGEgcHVibGlzaGVyIG9wZW4tZmxvdyByZXF1ZXN0LlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7P0xvbmd9IGxhc3RNc2dJZEFja2VkIExhc3QgbWVzc2FnZSBJRCBhY2tlZCwgaWYgcmUtb3BlbmluZ1xuICAgKiBAcGFyYW0gez9Mb25nfSBsYXN0TXNnSWRTZW50IExhc3QgbWVzc2FnZSBJRCBzZW50LCBpZiByZS1vcGVuaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dTaXplIERlc2lyZWQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZsb3dOYW1lIExhc3QgZmxvdyBuYW1lIGluIHVzZSwgaWYgcmUtb3BlbmluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29ycmVsYXRpb25UYWcgQ29ycmVsYXRpb24gdGFnIGZvciB0aGUgcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7c29sYWNlLkFkUHJvdG9jb2xNZXNzYWdlfSBUaGUgT1BFTlBVQkZMT1cgbWVzc2FnZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBnZXRPcGVuTWVzc2FnZVB1Ymxpc2hlcihcbiAgICAgICAgICAgIGxhc3RNc2dJZEFja2VkLFxuICAgICAgICAgICAgbGFzdE1zZ0lkU2VudCxcbiAgICAgICAgICAgIHdpbmRvd1NpemUsXG4gICAgICAgICAgICBmbG93TmFtZSxcbiAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFnKSB7XG4gICAgY29uc3QgYWRNc2cgPSBuZXcgQWRQcm90b2NvbE1lc3NhZ2UoU01GQWRQcm90b2NvbE1lc3NhZ2VUeXBlLk9QRU5QVUJGTE9XKTtcblxuICAgIGNvbnN0IHNtZkhlYWRlciA9IGFkTXNnLnNtZkhlYWRlcjtcbiAgICBzbWZIZWFkZXIucG1fY29ycnRhZyA9IGNvcnJlbGF0aW9uVGFnO1xuXG4gICAgaWYgKGxhc3RNc2dJZEFja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFkTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILlJFSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURBQ0tFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNc2dJZEFja2VkKSk7XG4gICAgfVxuICAgIGlmIChsYXN0TXNnSWRTZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFkTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILlJFSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURTRU5ULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1zZ0lkU2VudCkpO1xuICAgIH1cblxuICAgIGFkTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILlJFSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZBZFByb3RvY29sUGFyYW0uV0lORE9XLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1NpemUpKTtcblxuICAgIGFkTXNnLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILklHTk9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZBZFByb3RvY29sUGFyYW0uRkxPV05BTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvd05hbWUgfHwgJycpKTtcblxuICAgIExPR19UUkFDRShgQ3JlYXRlIG9wZW4gcHVibGlzaGVyOiBsYXN0TXNnSWRBY2tlZD0ke2xhc3RNc2dJZEFja2VkfSBsYXN0TXNnSWRTZW50PSR7bGFzdE1zZ0lkU2VudH0gd2luZG93PSR7d2luZG93U2l6ZX0gZmxvd05hbWU9JHtmbG93TmFtZSB8fCAnKG51bGwpJ31gKTtcblxuICAgIHJldHVybiBhZE1zZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFkUHJvdG9jb2xNZXNzYWdlIHRoYXQgZGVzY3JpYmVzIGEgc3Vic2NyaWJlciAoTWVzc2FnZUNvbnN1bWVyKSBiaW5kIHJlcXVlc3QuXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtzb2xhY2UuUXVldWVEZXNjcmlwdG9yfSBxdWV1ZURlc2NyaXB0b3IgVGhlIGVuZHBvaW50IGRlc2NyaXB0b3IgZm9yIHRoZSBiaW5kIHJlcXVlc3RcbiAgICogQHBhcmFtIHs/c29sYWNlLlF1ZXVlUHJvcGVydGllc30gcXVldWVQcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgYmluZCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7c29sYWNlLkRlc3RpbmF0aW9ufSBlbmRwb2ludCBUaGUgZW5kcG9pbnQgZm9yIHRoZSBiaW5kIHJlcXVlc3RcbiAgICogQHBhcmFtIHs/c29sYWNlLlRvcGljfSB0b3BpY1N1YnNjcmlwdGlvbiBUaGUgdG9waWMgZW5kcG9pbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvcnJlbGF0aW9uVGFnIFRoZSBjb3JyZWxhdGlvbiB0YWcgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aW5kb3dTaXplIFRoZSBkZXNpcmVkIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vTG9jYWw9ZmFsc2VdIElmIHRydWUsIGxvY2FsIHB1Ymxpc2hlciBtZXNzYWdlcyBhcmUgbm90IGRlbGl2ZXJlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3YW50Rmxvd0NoYW5nZVVwZGF0ZV0gZGVmYXVsdCBpcyB0cnVlIGlmIGRlc3RpbmF0aW9uIGlzIGEge3NvbGFjZS5RdWV1ZX1cbiAgICogQHBhcmFtIHtMb25nfSBbbGFzdE1zZ0lkQWNrZWQ9TG9uZy5VWkVST10gTGFzdCBtZXNzYWdlIElEIGFja2VkLCBpZiByZS1iaW5kaW5nXG4gICAqIEBwYXJhbSB7TG9uZ30gW2xhc3RNc2dJZFJlY2VpdmVkPUxvbmcuVVpFUk9dIExhc3QgbWVzc2FnZSBJRCByZWNlaXZlZCwgaWYgcmUtYmluZGluZ1xuICAgKiBAcmV0dXJucyB7c29sYWNlLkFkUHJvdG9jb2xNZXNzYWdlfSBUaGUgQklORCBtZXNzYWdlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGdldE9wZW5NZXNzYWdlQ29uc3VtZXIocXVldWVEZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpY1N1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVsYXRpb25UYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1NpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vTG9jYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRGbG93Q2hhbmdlVXBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TXNnSWRBY2tlZCA9IExvbmcuVVpFUk8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNc2dJZFJlY2VpdmVkID0gTG9uZy5VWkVSTykge1xuICAgIC8qXG4gICAgUVVFVUUgRkxPVyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVEUgRkxPV1xuXG4gICAge1NNRiBIZWFkZXIsIHByb3RvY29sPUFzc3VyZWRDdHJsIHR0bD0xfSAgICAgICAge1NNRiBIZWFkZXIsIHByb3RvY29sPUFzc3VyZWRDdHJsIHR0bD0xfVxuICAgIFtDb3JyZWxhdGlvbiBUYWcgUGFyYW1ldGVyXSAgICAgICAgICAgICAgICAgICAgIFtDb3JyZWxhdGlvbiBUYWcgUGFyYW1ldGVyXVxuICAgIHtBc3N1cmVkQ3RybCBNZXNzYWdlIEhlYWRlciwgbXNnVHlwZT1CaW5kfSAgICAgIHtBc3N1cmVkQ3RybCBNZXNzYWdlIEhlYWRlciwgbXNnVHlwZT1CaW5kfVxuXG4gICAge0Fzc3VyZWRDdHJsIFF1ZXVlTmFtZSBQYXJhbWV0ZXJ9ICAgICAgICAgICAgICAge0Fzc3VyZWRDdHJsIFRvcGljRW5kcG9pbnROYW1lIFBhcmFtZXRlcn1cbiAgICAqKiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXNzdXJlZEN0cmwgVG9waWNOYW1lIFBhcmFtZXRlcn1cbiAgICBbQXNzdXJlZEN0cmwgTGFzdCBNZXNzYWdlIElkIEFja2VkIFBhcmFtZXRlcl0gICAqKipcbiAgICBbQXNzdXJlZEN0cmwgTGFzdCBNZXNzYWdlIElkIFJlY3YnZCBQYXJhbWV0ZXJdICAqKipcbiAgICB7QXNzdXJlZEN0cmwgVHJhbnNwb3J0IFdpbmRvdyBTaXplIFBhcmFtZXRlcn0gICB7QXNzdXJlZEN0cmwgVHJhbnNwb3J0IFdpbmRvdyBTaXplIFBhcmFtZXRlcn1cbiAgICBbQXNzdXJlZEN0cmwgRHVyYWJpbGl0eSBQYXJhbWV0ZXJdICAgICAgICAgICAgICBbQXNzdXJlZEN0cmwgRHVyYWJpbGl0eSBQYXJhbWV0ZXJdXG4gICAgW0Fzc3VyZWRDdHJsIE1lc3NhZ2UgU2VsZWN0b3IgUGFyYW1ldGVyXSAgICAgICAgW0Fzc3VyZWRDdHJsIE1lc3NhZ2UgU2VsZWN0b3IgUGFyYW1ldGVyXVxuICAgIFtBc3N1cmVkQ3RybCBGbG93VHlwZSBQYXJhbWV0ZXJdICAgICAgICAgICAgICAgIFtBc3N1cmVkQ3RybCBGbG93VHlwZSBQYXJhbWV0ZXJdXG4gICAgW0Fzc3VyZWRDdHJsIFNlbGVjdG9yIFBhcmFtZXRlcl0gICAgICAgICAgICAgICAgW0Fzc3VyZWRDdHJsIFNlbGVjdG9yIFBhcmFtZXRlcl1cbiAgICBbQXNzdXJlZEN0cmwgQWxsT3RoZXJzUGVybWlzc2lvbnMgUGFyYW1ldGVyXSAgICBbQXNzdXJlZEN0cmwgQWxsT3RoZXJzUGVybWlzc2lvbnMgUGFyYW1ldGVyXVxuICAgIFtBc3N1cmVkQ3RybCBFbmRwb2ludFF1b3RhTUIgUGFyYW1ldGVyXSAgICAgICAgIFtBc3N1cmVkQ3RybCBFbmRwb2ludFF1b3RhTUIgUGFyYW1ldGVyXVxuICAgIFtBc3N1cmVkQ3RybCBFbmRwb2ludE1heE1lc3NhZ2VTaXplIFBhcmFtZXRlcl0gIFtBc3N1cmVkQ3RybCBFbmRwb2ludE1heE1lc3NhZ2VTaXplIFBhcmFtZXRlcl1cbiAgICBbQXNzdXJlZEN0cmwgVHJhbnNhY3RlZFNlc3Npb25JZCBQYXJhbWV0ZXJdICAgICBbQXNzdXJlZEN0cmwgVHJhbnNhY3RlZFNlc3Npb25JZCBQYXJhbWV0ZXJdXG4gICAgW0Fzc3VyZWRDdHJsIE5vTG9jYWwgUGFyYW1ldGVyXSAgICAgICAgICAgICAgICAgW0Fzc3VyZWRDdHJsIE5vTG9jYWwgUGFyYW1ldGVyXVxuICAgIFtBc3N1cmVkQ3RybCB3YW50Rmxvd0NoYW5nZVVwZGF0ZSBQYXJhbWV0ZXJdICAgICoqKlxuICAgIFtBc3N1cmVkQ3RybCBxRW5kcG9pbnRCZWhhdmlvdXJGbGFncyBQYXJhbWV0ZXJdIFtBc3N1cmVkQ3RybCBxRW5kcG9pbnRCZWhhdmlvdXJGbGFncyBQYXJhbWV0ZXJdXG4gICAgW0Fzc3VyZWRDdHJsIE1heFJlZGVsaXZlcnkgUGFyYW1ldGVyXSAgICAgICAgICAgW0Fzc3VyZWRDdHJsIE1heFJlZGVsaXZlcnkgUGFyYW1ldGVyXVxuXG4gICAgKi9cbiAgICBjb25zdCBkdXJhYmxlID0gcXVldWVEZXNjcmlwdG9yLmR1cmFibGU7XG4gICAgY29uc3QgZW5kcG9pbnRCeXRlcyA9IGVuZHBvaW50LmJ5dGVzO1xuICAgIGNvbnN0IGVuZHBvaW50VHlwZSA9IGVuZHBvaW50LnR5cGU7XG5cbiAgICAvLyB7U01GIEhlYWRlciwgcHJvdG9jb2w9QXNzdXJlZEN0cmwgdHRsPTF9ICAgICAgICB7U01GIEhlYWRlciwgcHJvdG9jb2w9QXNzdXJlZEN0cmwgdHRsPTF9XG4gICAgLy8gW0NvcnJlbGF0aW9uIFRhZyBQYXJhbWV0ZXJdICAgICAgICAgICAgICAgICAgICAgW0NvcnJlbGF0aW9uIFRhZyBQYXJhbWV0ZXJdXG4gICAgLy8ge0Fzc3VyZWRDdHJsIE1lc3NhZ2UgSGVhZGVyLCBtc2dUeXBlPUJpbmR9ICAgICAge0Fzc3VyZWRDdHJsIE1lc3NhZ2UgSGVhZGVyLCBtc2dUeXBlPUJpbmR9XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQklORCk7XG4gICAgY29uc3QgaGVhZGVyID0gbWVzc2FnZS5zbWZIZWFkZXI7XG4gICAgaGVhZGVyLnBtX2NvcnJ0YWcgPSBjb3JyZWxhdGlvblRhZztcblxuICAgIC8vIHtBc3N1cmVkQ3RybCBRdWV1ZU5hbWUgUGFyYW1ldGVyfSAgICAgICAgICAgICAgIHtBc3N1cmVkQ3RybCBUb3BpY0VuZHBvaW50TmFtZSBQYXJhbWV0ZXJ9XG4gICAgY29uc3QgZW5kcG9pbnRUeXBlUGFyYW0gPSBFbmRwb2ludFR5cGVUb1BhcmFtW2VuZHBvaW50VHlwZV07XG4gICAgaWYgKGVuZHBvaW50VHlwZVBhcmFtID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignVW5rbm93biBkZXN0aW5hdGlvbiB0eXBlJyk7XG4gICAgbWVzc2FnZS5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcihcbiAgICAgIFNNRlVILlJFSkVDVCxcbiAgICAgIGVuZHBvaW50VHlwZVBhcmFtLFxuICAgICAgZW5kcG9pbnRCeXRlc1xuICAgICkpO1xuXG4gICAgLy8gKioqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0Fzc3VyZWRDdHJsIFRvcGljTmFtZSBQYXJhbWV0ZXJ9XG4gICAgaWYgKHRvcGljU3Vic2NyaXB0aW9uKSB7XG4gICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5UT1BJQ05BTUUsXG4gICAgICAgIHRvcGljU3Vic2NyaXB0aW9uLmJ5dGVzXG4gICAgICApKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kcG9pbnRUeXBlID09PSBEZXN0aW5hdGlvblR5cGUuUVVFVUUpIHtcbiAgICAgIC8vICAgICBbQXNzdXJlZEN0cmwgTGFzdCBNZXNzYWdlIElkIEFja2VkIFBhcmFtZXRlcl0gICAqKipcbiAgICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICAgIFNNRlVILlJFSkVDVCxcbiAgICAgICAgU01GQWRQcm90b2NvbFBhcmFtLkxBU1RNU0dJREFDS0VELFxuICAgICAgICBsYXN0TXNnSWRBY2tlZFxuICAgICAgKSk7XG4gICAgICAvLyAgICAgW0Fzc3VyZWRDdHJsIExhc3QgTWVzc2FnZSBJZCBSZWN2J2QgUGFyYW1ldGVyXSAgKioqXG4gICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICBTTUZVSC5JR05PUkUsXG4gICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURSRUNFSVZFRCxcbiAgICAgICAgbGFzdE1zZ0lkUmVjZWl2ZWRcbiAgICAgICkpO1xuICAgIH1cblxuICAgIC8vIHtBc3N1cmVkQ3RybCBUcmFuc3BvcnQgV2luZG93IFNpemUgUGFyYW1ldGVyfVxuICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICBTTUZBZFByb3RvY29sUGFyYW0uV0lORE9XLFxuICAgICAgd2luZG93U2l6ZVxuICAgICkpO1xuXG4gICAgLy8gW0Fzc3VyZWRDdHJsIER1cmFiaWxpdHkgUGFyYW1ldGVyXVxuICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICBTTUZVSC5JR05PUkUsXG4gICAgICBTTUZBZFByb3RvY29sUGFyYW0uRVBfRFVSQUJMRSxcbiAgICAgIGR1cmFibGVcbiAgICApKTtcblxuICAgIC8vIE9taXQgTWVzc2FnZSBTZWxlY3RvclxuICAgIC8vIE9taXQgRmxvd1R5cGUsIENPTlNVTUVSIGFzc3VtZWQgKG5vdCBCUk9XU0VSIGN1cnJlbnRseSlcbiAgICAvLyBPbWl0IFRyYW5zYWN0ZWRTZXNzaW9uSWRcblxuICAgIGlmIChxdWV1ZVByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlzY2FyZEJlaGF2aW9yLFxuICAgICAgICBtYXhNZXNzYWdlUmVkZWxpdmVyeSxcbiAgICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgICBxdW90YU1CLFxuICAgICAgICByZXNwZWN0c1RUTCxcbiAgICAgIH0gPSBxdWV1ZVByb3BlcnRpZXM7XG5cbiAgICAgIC8vIFtBc3N1cmVkQ3RybCBBbGxPdGhlcnNQZXJtaXNzaW9ucyBQYXJhbWV0ZXJdXG4gICAgICBpZiAocGVybWlzc2lvbnMgJiYgUVVFVUVfUEVSTUlTU0lPTlNfVE9fQklUU1twZXJtaXNzaW9uc10pIHtcbiAgICAgICAgbWVzc2FnZS5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcihcbiAgICAgICAgICBTTUZVSC5JR05PUkUsXG4gICAgICAgICAgU01GQWRQcm90b2NvbFBhcmFtLkVQX0FMTE9USEVSX1BFUk1JU1NJT04sXG4gICAgICAgICAgUVVFVUVfUEVSTUlTU0lPTlNfVE9fQklUU1twZXJtaXNzaW9uc11cbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFtBc3N1cmVkQ3RybCBFbmRwb2ludFF1b3RhTUIgUGFyYW1ldGVyXVxuICAgICAgaWYgKHF1b3RhTUIgIT09IG51bGwgJiYgcXVvdGFNQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICAgICAgU01GVUguSUdOT1JFLFxuICAgICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5FUF9RVU9UQSxcbiAgICAgICAgICBxdW90YU1CXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICAvLyBbQXNzdXJlZEN0cmwgRW5kcG9pbnRNYXhNZXNzYWdlU2l6ZSBQYXJhbWV0ZXJdXG4gICAgICBpZiAobWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICAgIFNNRlVILklHTk9SRSxcbiAgICAgICAgICBTTUZBZFByb3RvY29sUGFyYW0uRVBfTUFYX01TR1NJWkUsXG4gICAgICAgICAgbWF4TWVzc2FnZVNpemVcbiAgICAgICAgKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBmbGFncyA9IDB4MDAwMDtcbiAgICAgIGlmIChkaXNjYXJkQmVoYXZpb3IgIT09IG51bGwgJiYgZGlzY2FyZEJlaGF2aW9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGlzY2FyZEJlaGF2aW9yVmFsdWUgPSBESVNDQVJEX0VOVU1fVE9fVkFMVUVbZGlzY2FyZEJlaGF2aW9yXTtcbiAgICAgICAgZmxhZ3MgfD0gKGRpc2NhcmRCZWhhdmlvclZhbHVlIDw8IDEyKTtcbiAgICAgICAgLy8gT21pdCBjdXRUaHJvdWdoLCA8PCAxNFxuICAgICAgfVxuICAgICAgaWYgKGZsYWdzIC8qIGlzIG5vbnplcm8gKi8pIHtcbiAgICAgICAgbWVzc2FnZS5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcihcbiAgICAgICAgICBTTUZVSC5JR05PUkUsXG4gICAgICAgICAgU01GQWRQcm90b2NvbFBhcmFtLkVQX0JFSEFWSU9VUixcbiAgICAgICAgICBmbGFnc1xuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heE1lc3NhZ2VSZWRlbGl2ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVzc2FnZS5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcihcbiAgICAgICAgICBTTUZVSC5JR05PUkUsXG4gICAgICAgICAgU01GQWRQcm90b2NvbFBhcmFtLk1BWF9SRURFTElWRVJZLFxuICAgICAgICAgIG1heE1lc3NhZ2VSZWRlbGl2ZXJ5XG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzcGVjdHNUVEwgLyogaXMgdHJ1ZSAqLykge1xuICAgICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICAgIFNNRlVILklHTk9SRSxcbiAgICAgICAgICBTTUZBZFByb3RvY29sUGFyYW0uRVBfUkVTUEVDVFNfVFRMLFxuICAgICAgICAgIDB4MVxuICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9Mb2NhbCAvKiBpcyB0cnVlICovKSB7XG4gICAgICAvLyBbQXNzdXJlZEN0cmwgTm9Mb2NhbCBQYXJhbWV0ZXJdXG4gICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5OT0xPQ0FMLFxuICAgICAgICAweDFcbiAgICAgICkpO1xuICAgIH1cblxuICAgIGlmICh3YW50Rmxvd0NoYW5nZVVwZGF0ZSAvKiBpcyB0cnVlICovKSB7XG4gICAgICAvLyBbQXNzdXJlZEN0cmwgd2FudEZsb3dDaGFuZ2VVcGRhdGUgUGFyYW1ldGVyXSAgICAqKipcbiAgICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICAgIFNNRlVILklHTk9SRSxcbiAgICAgICAgU01GQWRQcm90b2NvbFBhcmFtLldBTlRfRkxPV19DSEFOR0VfTk9USUZZLFxuICAgICAgICAweDFcbiAgICAgICkpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gVU5CSU5EIHJlcXVlc3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZsb3dJZCBUaGUgZmxvdyBJRCB0byB1bmJpbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvcnJlbGF0aW9uVGFnIFRoZSBjb3JyZWxhdGlvbiB0YWcgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7P0xvbmd9IGxhc3RNZXNzYWdlSWRBY2tlZCBUaGUgbGFzdCBtZXNzYWdlIElEIG1hcmtlZCBhcyBsb2NhbGx5IGFja2VkXG4gICAqIEByZXR1cm5zIHtBZFByb3RvY29sTWVzc2FnZX0gVGhlIG5ldyBVTkJJTkQgcmVxdWVzdFxuICAgKiBAc3RhdGljXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGdldENsb3NlTWVzc2FnZUNvbnN1bWVyKGZsb3dJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlbGF0aW9uVGFnKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuVU5CSU5EKTtcblxuICAgIGNvbnN0IGhlYWRlciA9IG1lc3NhZ2Uuc21mSGVhZGVyO1xuICAgIGhlYWRlci5wbV9jb3JydGFnID0gY29ycmVsYXRpb25UYWc7XG5cbiAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFNNRlVILlJFSkVDVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5GTE9XSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG93SWQpKTtcbiAgICAvLyBsaW5nZXI6IGFzc3VtZSBub1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0RFRFVW5zdWJzY3JpYmVNZXNzYWdlKGNvcnJlbGF0aW9uVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuVU5TVUJTQ1JJQkUpO1xuICAgIGNvbnN0IGhlYWRlciA9IG1lc3NhZ2Uuc21mSGVhZGVyO1xuICAgIGhlYWRlci5wbV9jb3JydGFnID0gY29ycmVsYXRpb25UYWc7XG5cbiAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgU01GVUguUkVKRUNULFxuICAgICAgU01GQWRQcm90b2NvbFBhcmFtLkRURU5BTUUsXG4gICAgICB0b3BpYy5nZXRCeXRlcygpXG4gICAgKSk7XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmxvd0lkIFRoZSBmbG93IG9uIHdoaWNoIHRvIGFja25vd2xlZGdlIG1lc3NhZ2VzLlxuICAgKiBAcGFyYW0gez9Mb25nfSBbbGFzdE1lc3NhZ2VJZEFja2VkPXVuZGVmaW5lZF0gVGhlIHRyYW5zcG9ydCBhY2tub3dsZWRnZXMgcmVjZWlwdCBvZiBhbGxcbiAgICogIG1lc3NhZ2VzIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhpcyBJRC5cbiAgICogQHBhcmFtIHs/TG9uZ30gW3dpbmRvd1NpemU9dW5kZWZpbmVkXSBUaGUgc2l6ZSB0byB3aGljaCB0aGUgZmxvdyB3aW5kb3cgc2hvdWxkIGJlIHNldC5cbiAgICogQHBhcmFtIHs/QXJyYXkuPEFycmF5LjxMb25nPj59IFthcHBsaWNhdGlvbkFja1Jhbmdlcz11bmRlZmluZWRdIExvdy1oaWdoIElEIHBhaXJzIG9mXG4gICAqICBtZXNzYWdlIElEcyB0byBhY2tub3dsZWRnZSBhdCB0aGUgYXBwbGljYXRpb24gbGV2ZWwuIFRvIGFwcGxpY2F0aW9uIGFjayBhIHNpbmdsZSBtZXNzYWdlLFxuICAgKiAgcGFzcyBgWyBbc2luZ2xlTWVzc2FnZUlkLCBzaW5nbGVNZXNzYWdlSWRdIF1gLlxuICAgKiBAcmV0dXJucyB7c29sYWNlLkFkUHJvdG9jb2xNZXNzYWdlfSBBIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICogQGludGVybmFsXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBnZXRBY2soZmxvd0lkLFxuICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlSWRBY2tlZCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dTaXplID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uQWNrUmFuZ2VzID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBBZFByb3RvY29sTWVzc2FnZShTTUZBZFByb3RvY29sTWVzc2FnZVR5cGUuQ0xJRU5UQUNLKTtcblxuICAgIG1lc3NhZ2UuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoXG4gICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICBTTUZBZFByb3RvY29sUGFyYW0uRkxPV0lELFxuICAgICAgZmxvd0lkXG4gICAgKSk7XG5cbiAgICBpZiAobGFzdE1lc3NhZ2VJZEFja2VkKSB7XG4gICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5MQVNUTVNHSURBQ0tFRCxcbiAgICAgICAgbGFzdE1lc3NhZ2VJZEFja2VkXG4gICAgICApKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93U2l6ZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvd1NpemUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGFyZSB0d28gd2luZG93U2l6ZSBvcHRpb25zOyB3ZSdsbCB1c2UgdGhlIGxlZ2FjeSBvbmUgZm9yIHNtYWxsZXJcbiAgICAgIC8vIHdpbmRvdyBzaXplc1xuICAgICAgbWVzc2FnZS5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcihcbiAgICAgICAgU01GVUguUkVKRUNULFxuICAgICAgICAod2luZG93U2l6ZSA8PSAweEZGKSA/IFNNRkFkUHJvdG9jb2xQYXJhbS5XSU5ET1cgOiBTTUZBZFByb3RvY29sUGFyYW0uVFJBTlNQT1JUX1dJTkRPVyxcbiAgICAgICAgd2luZG93U2l6ZVxuICAgICAgKSk7XG4gICAgfVxuXG4gICAgaWYgKGFwcGxpY2F0aW9uQWNrUmFuZ2VzICYmIGFwcGxpY2F0aW9uQWNrUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgaWYgKGFwcGxpY2F0aW9uQWNrUmFuZ2VzLmxlbmd0aCA+IEFkUHJvdG9jb2xNZXNzYWdlLk1BWF9DTElFTlRfQUNLX1JBTkdFUykge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0FwcGxpY2F0aW9uIGFjayByYW5nZSBjb3VudCBleGNlZWRzIGxpbWl0IG9mIDY0Jyk7XG4gICAgICB9XG4gICAgICBtZXNzYWdlLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKFxuICAgICAgICBTTUZVSC5SRUpFQ1QsXG4gICAgICAgIFNNRkFkUHJvdG9jb2xQYXJhbS5BUFBMSUNBVElPTl9BQ0ssXG4gICAgICAgIGFwcGxpY2F0aW9uQWNrUmFuZ2VzIC8vIERBTkdFUjogdGhpcyBuZWVkcyB0byBiZSBlbmNvZGVkIGltbWVkaWF0ZWx5LCBvciBlbHNlIGRlZXAtY2xvbmVkXG4gICAgICApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxufVxuXG5BZFByb3RvY29sTWVzc2FnZS5NQVhfQ0xJRU5UX0FDS19SQU5HRVMgPSA2NDtcblxubW9kdWxlLmV4cG9ydHMuQWRQcm90b2NvbE1lc3NhZ2UgPSBBZFByb3RvY29sTWVzc2FnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2FkcHJvdG9jb2wtbWVzc2FnZS5qcyIsImNvbnN0IHsgQml0cywgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcblxuY29uc3Qge1xuICBnZXQ6IGJpdHMsXG59ID0gQml0cztcbmNvbnN0IHtcbiAgaW50OFRvU3RyLCBzdHJUb0ludDgsXG4gIGludDI0VG9TdHIsXG4gIHN0clRvSW50MzIsXG59ID0gQ29udmVydDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQmluYXJ5TWV0YUJsb2NrIHJlcHJlc2VudHMgYSBiaW5hcnkgbWV0YWRhdGEgYmxvY2sgaW4gYSBUck1zZ1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEJpbmFyeU1ldGFCbG9jayB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHBheWxvYWQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gIH1cblxuICBhc0VuY29kZWRTbWYoKSB7XG4gICAgY29uc3Qgc21mID0gW107XG4gICAgc21mLnB1c2goaW50OFRvU3RyKDEpKTtcbiAgICBzbWYucHVzaChpbnQ4VG9TdHIodGhpcy50eXBlKSk7XG4gICAgc21mLnB1c2goaW50MjRUb1N0cih0aGlzLnBheWxvYWQubGVuZ3RoKSk7XG4gICAgc21mLnB1c2godGhpcy5wYXlsb2FkKTtcbiAgICByZXR1cm4gc21mLmpvaW4oJycpO1xuICB9XG5cbiAgc3RhdGljIGZyb21FbmNvZGVkU21mKHN0clNtZiwgb2Zmc2V0ID0gMCkge1xuICAgIGlmICgoc3RyU21mLmxlbmd0aCAtIG9mZnNldCkgPCA2KSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGVub3VnaCBkYXRhXG4gICAgfVxuICAgIGNvbnN0IGNodW5rQ291bnQgPSBzdHJUb0ludDgoc3RyU21mLnN1YnN0cihvZmZzZXQsIDEpKTtcbiAgICBjb25zdCBmb3VyYnl0ZSA9IHN0clRvSW50MzIoc3RyU21mLnN1YnN0cihvZmZzZXQgKyAxLCA0KSk7XG4gICAgY29uc3QgdHlwZSA9IGJpdHMoZm91cmJ5dGUsIDI0LCA4KTtcbiAgICBjb25zdCBwYXlsb2FkTGVuID0gYml0cyhmb3VyYnl0ZSwgMCwgMjQpO1xuICAgIGNvbnN0IHBheWxvYWRPZmZzZXQgPSBjaHVua0NvdW50ICogNCArIDE7XG4gICAgY29uc3QgcGF5bG9hZCA9IHN0clNtZi5zdWJzdHIob2Zmc2V0ICsgcGF5bG9hZE9mZnNldCwgcGF5bG9hZExlbik7XG4gICAgcmV0dXJuIG5ldyBCaW5hcnlNZXRhQmxvY2sodHlwZSwgcGF5bG9hZCk7XG4gIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzLkJpbmFyeU1ldGFCbG9jayA9IEJpbmFyeU1ldGFCbG9jaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2JpbmFyeS1tZXRhLWJsb2NrLmpzIiwiY29uc3QgeyBBdXRoZW50aWNhdGlvblNjaGVtZSwgQ2FwYWJpbGl0eVR5cGUsIE11dGFibGVTZXNzaW9uUHJvcGVydHksIFNlc3Npb25Qcm9wZXJ0aWVzIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2Vzc2lvbicpO1xuY29uc3QgeyBCYXNlTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9iYXNlLW1lc3NhZ2UnKTtcbmNvbnN0IHsgQml0cywgQ29udmVydCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgRGVzdGluYXRpb25UeXBlLCBEZXN0aW5hdGlvblV0aWwgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUsIE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgUHJvY2VzcywgU3RyaW5nVXRpbHMsIFZlcnNpb24gfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC11dGlsJyk7XG5jb25zdCB7IFNNRkNsaWVudEN0cmxNZXNzYWdlVHlwZSB9ID0gcmVxdWlyZSgnLi4vc21mLWNsaWVudC1jdHJsLW1lc3NhZ2UtdHlwZXMnKTtcbmNvbnN0IHsgU01GQ2xpZW50Q3RybFBhcmFtIH0gPSByZXF1aXJlKCcuLi9zbWYtY2xpZW50LWN0cmwtcGFyYW1zJyk7XG5jb25zdCB7IFNNRkhlYWRlciB9ID0gcmVxdWlyZSgnLi9zbWYtaGVhZGVyJyk7XG5jb25zdCB7IFNNRlBhcmFtZXRlciB9ID0gcmVxdWlyZSgnLi9zbWYtcGFyYW1ldGVyJyk7XG5jb25zdCB7IFNNRlByb3RvY29sIH0gPSByZXF1aXJlKCcuLi9zbWYtcHJvdG9jb2xzJyk7XG5cbmNvbnN0IHtcbiAgZ2V0OiBiaXRzLFxuICBzZXQ6IHNldEJpdHMsXG59ID0gQml0cztcbmNvbnN0IHtcbiAgc3RyVG9JbnQ4LFxuICBpbnQxNlRvU3RyLCBzdHJUb0ludDE2LFxuICBzdHJUb0ludDMyLFxufSA9IENvbnZlcnQ7XG5jb25zdCB7XG4gIG51bGxUZXJtaW5hdGUsXG4gIHN0cmlwTnVsbFRlcm1pbmF0ZSxcbn0gPSBTdHJpbmdVdGlscztcbmNvbnN0IHtcbiAgdmFsaWRhdGVBbmRFbmNvZGUsXG59ID0gRGVzdGluYXRpb25VdGlsO1xuXG5jb25zdCBCT09MRUFOX0NBUFNfQklUUyA9IFtcbiAgQ2FwYWJpbGl0eVR5cGUuSk5ESSxcbiAgQ2FwYWJpbGl0eVR5cGUuQ09NUFJFU1NJT04sXG4gIENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FLFxuICBDYXBhYmlsaXR5VHlwZS5URU1QT1JBUllfRU5EUE9JTlQsXG4gIENhcGFiaWxpdHlUeXBlLkdVQVJBTlRFRURfTUVTU0FHRV9QVUJMSVNILFxuICBDYXBhYmlsaXR5VHlwZS5HVUFSQU5URUVEX01FU1NBR0VfQlJPV1NFLFxuICBDYXBhYmlsaXR5VHlwZS5FTkRQT0lOVF9NR01ULFxuICBDYXBhYmlsaXR5VHlwZS5TRUxFQ1RPUixcbiAgQ2FwYWJpbGl0eVR5cGUuRU5EUE9JTlRfTUVTU0FHRV9UVEwsXG4gIENhcGFiaWxpdHlUeXBlLlFVRVVFX1NVQlNDUklQVElPTlMsXG4gIG51bGwsIC8vIHNraXAgb2Jzb2xldGUgRkxPV19SRUNPVkVSXG4gIENhcGFiaWxpdHlUeXBlLlNVQlNDUklQVElPTl9NQU5BR0VSLFxuICBDYXBhYmlsaXR5VHlwZS5NRVNTQUdFX0VMSURJTkcsXG4gIENhcGFiaWxpdHlUeXBlLlRSQU5TQUNURURfU0VTU0lPTixcbiAgQ2FwYWJpbGl0eVR5cGUuTk9fTE9DQUwsXG4gIENhcGFiaWxpdHlUeXBlLkFDVElWRV9DT05TVU1FUl9JTkRJQ0FUSU9OLFxuICBDYXBhYmlsaXR5VHlwZS5QRVJfVE9QSUNfU0VRVUVOQ0VfTlVNQkVSSU5HLFxuICBDYXBhYmlsaXR5VHlwZS5FTkRQT0lOVF9ESVNDQVJEX0JFSEFWSU9SLFxuICBDYXBhYmlsaXR5VHlwZS5DVVRfVEhST1VHSCxcbiAgbnVsbCwgLy8gc2tpcCBPUEVOTUFNQVxuXTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIENsaWVudEN0cmxNZXNzYWdlXG4gKiBSZXByZXNlbnRzIGEgQ2xpZW50Q3RybCByZXF1ZXN0IG9yIHJlcGx5IG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENsaWVudEN0cmxNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlVHlwZSA9IDApIHtcbiAgICBzdXBlcihuZXcgU01GSGVhZGVyKFNNRlByb3RvY29sLkNMSUVOVENUUkwsIDEpKTtcblxuICAgIC8vIEZpZWxkOiBtc2d0eXBlXG4gICAgdGhpcy5tc2dUeXBlID0gbWVzc2FnZVR5cGU7XG5cbiAgICAvLyBGaWVsZDogdmVyc2lvblxuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gIH1cblxuICBnZXRQMlBUb3BpY1ZhbHVlKCkge1xuICAgIGNvbnN0IHAycFBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoU01GQ2xpZW50Q3RybFBhcmFtLlAyUFRPUElDKTtcbiAgICBpZiAoIXAycFBhcmFtKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlwTnVsbFRlcm1pbmF0ZShwMnBQYXJhbS5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFZwbk5hbWVJblVzZVZhbHVlKCkge1xuICAgIGNvbnN0IHZwblBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoU01GQ2xpZW50Q3RybFBhcmFtLk1TR1ZQTk5BTUUpO1xuICAgIGlmICghdnBuUGFyYW0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaXBOdWxsVGVybWluYXRlKHZwblBhcmFtLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0VnJpZEluVXNlVmFsdWUoKSB7XG4gICAgY29uc3QgdnJpZFBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoU01GQ2xpZW50Q3RybFBhcmFtLlZSSUROQU1FKTtcbiAgICBpZiAoIXZyaWRQYXJhbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdHJpcE51bGxUZXJtaW5hdGUodnJpZFBhcmFtLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0VXNlcklkVmFsdWUoKSB7XG4gICAgY29uc3QgdXNlcklkUGFyYW0gPSB0aGlzLmdldFBhcmFtZXRlcihTTUZDbGllbnRDdHJsUGFyYW0uVVNFUklEKTtcbiAgICBpZiAoIXVzZXJJZFBhcmFtKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlwTnVsbFRlcm1pbmF0ZSh1c2VySWRQYXJhbS5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFJvdXRlckNhcGFiaWxpdGllcygpIHtcbiAgICBsZXQgY2FwcyA9IFtdO1xuXG4gICAgLy8gUGFyc2UgdGhlIGNvbXBvc2l0ZSBjYXBhYmlsaXRpZXMgcGFyYW1ldGVyXG4gICAgbGV0IGNhcFBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoU01GQ2xpZW50Q3RybFBhcmFtLlJPVVRFUl9DQVBBQklMSVRJRVMpO1xuICAgIGlmIChjYXBQYXJhbSkge1xuICAgICAgY2FwcyA9IENsaWVudEN0cmxNZXNzYWdlLnBybVBhcnNlQ2FwYWJpbGl0aWVzVmFsdWUoY2FwUGFyYW0uZ2V0VmFsdWUoKSwgY2Fwcyk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugb3V0IHRoZSByb3V0ZXIgc3RhdHVzIHN0cmluZ3NcbiAgICBjYXBQYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKFNNRkNsaWVudEN0cmxQYXJhbS5TT0ZUV0FSRVZFUlNJT04pO1xuICAgIGlmIChjYXBQYXJhbSkge1xuICAgICAgY2Fwc1tDYXBhYmlsaXR5VHlwZS5QRUVSX1NPRlRXQVJFX1ZFUlNJT05dID0gc3RyaXBOdWxsVGVybWluYXRlKGNhcFBhcmFtLmdldFZhbHVlKCkpO1xuICAgIH1cbiAgICBjYXBQYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKFNNRkNsaWVudEN0cmxQYXJhbS5TT0ZUV0FSRURBVEUpO1xuICAgIGlmIChjYXBQYXJhbSkge1xuICAgICAgY2Fwc1tDYXBhYmlsaXR5VHlwZS5QRUVSX1NPRlRXQVJFX0RBVEVdID0gc3RyaXBOdWxsVGVybWluYXRlKGNhcFBhcmFtLmdldFZhbHVlKCkpO1xuICAgIH1cbiAgICBjYXBQYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKFNNRkNsaWVudEN0cmxQYXJhbS5QTEFURk9STSk7XG4gICAgaWYgKGNhcFBhcmFtKSB7XG4gICAgICBjYXBzW0NhcGFiaWxpdHlUeXBlLlBFRVJfUExBVEZPUk1dID0gc3RyaXBOdWxsVGVybWluYXRlKGNhcFBhcmFtLmdldFZhbHVlKCkpO1xuICAgIH1cbiAgICBjYXBQYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKFNNRkNsaWVudEN0cmxQYXJhbS5QSFlTSUNBTFJPVVRFUk5BTUUpO1xuICAgIGlmIChjYXBQYXJhbSkge1xuICAgICAgY2Fwc1tDYXBhYmlsaXR5VHlwZS5QRUVSX1JPVVRFUl9OQU1FXSA9IHN0cmlwTnVsbFRlcm1pbmF0ZShjYXBQYXJhbS5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhcHM7XG4gIH1cblxuXG4gIHN0YXRpYyBwcm1HZXREdG9Qcmlvcml0eVZhbHVlKGR0bykge1xuICAgIGlmIChkdG8ubG9jYWwgPT09IHVuZGVmaW5lZCB8fCBkdG8ubmV0d29yayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB0d29ieXRlID0gMDtcbiAgICB0d29ieXRlID0gc2V0Qml0cyh0d29ieXRlLCBkdG8ubG9jYWwsIDgsIDgpO1xuICAgIHR3b2J5dGUgPSBzZXRCaXRzKHR3b2J5dGUsIGR0by5uZXR3b3JrLCAwLCA4KTtcbiAgICByZXR1cm4gaW50MTZUb1N0cih0d29ieXRlKTtcbiAgfVxuXG4gIHN0YXRpYyBwcm1QYXJzZUR0b1ByaW9yaXR5VmFsdWUoc3RyRHRvUHJpb3JpdHkpIHtcbiAgICBjb25zdCBkdG8gPSB7fTtcbiAgICBjb25zdCB0d29ieXRlID0gc3RyVG9JbnQxNihzdHJEdG9Qcmlvcml0eS5zdWJzdHIoMCwgMikpO1xuICAgIGR0by5sb2NhbCA9IGJpdHModHdvYnl0ZSwgOCwgOCk7XG4gICAgZHRvLm5ldHdvcmsgPSBiaXRzKHR3b2J5dGUsIDAsIDgpO1xuICAgIHJldHVybiBkdG87XG4gIH1cblxuICAvKlxuICBzdHJDYXBhYmlsaXRpZXM6IHBhcmFtZXRlciB2YWx1ZVxuICBjYXBzOiBhbiBhbHJlYWR5IGV4aXN0aW5nIGhhc2ggYXJyYXkgb2YgQ2FwYWJpbGl0eVR5cGVcbiAgICovXG4gIHN0YXRpYyBwcm1QYXJzZUNhcGFiaWxpdGllc1ZhbHVlKHN0ckNhcGFiaWxpdGllcywgY2Fwc0luKSB7XG4gICAgY29uc3QgY2FwcyA9IGNhcHNJbjtcbiAgICBpZiAoIShzdHJDYXBhYmlsaXRpZXMgJiYgY2FwcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgQ1QgPSBDYXBhYmlsaXR5VHlwZTtcbiAgICBsZXQgcG9zID0gMDtcblxuICAgIC8vIHBhcnNlIGJvb2xlYW4gY2FwYWJpbGl0aWVzXG4gICAgY29uc3QgYm9vbENhcENvdW50ID0gc3RyVG9JbnQ4KHN0ckNhcGFiaWxpdGllc1twb3NdKTtcbiAgICArK3BvcztcblxuICAgIC8vIFRoZSBib29sZWFuIGNhcHMgYXJlIGxpc3RlZCBpbiBvcmRlciBhcyBpbiB0aGUgZG9jdW1lbnRhdGlvbixcbiAgICAvLyB0aGF0IGlzIGZyb20gTVNCIHRvIExTQiBmb3IgZWFjaCBjYXBzIGJ5dGUuXG4gICAgbGV0IGNhcHNCeXRlO1xuICAgIGZvciAobGV0IGJpdEluZGV4ID0gMDsgYml0SW5kZXggPCBib29sQ2FwQ291bnQ7ICsrYml0SW5kZXgpIHtcbiAgICAgIGNvbnN0IG1zYkluZGV4ID0gYml0SW5kZXggJiAweDc7XG4gICAgICBpZiAobXNiSW5kZXggPT09IDApIHsgLy8gQ29uc3VtZSBhIGJ5dGVcbiAgICAgICAgY2Fwc0J5dGUgPSBzdHJUb0ludDgoc3RyQ2FwYWJpbGl0aWVzW3Bvc10pO1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhcHNLZXkgPSBCT09MRUFOX0NBUFNfQklUU1tiaXRJbmRleF07XG4gICAgICBpZiAoIWNhcHNLZXkpIGNvbnRpbnVlOyAvLyBXZSBkb24ndCBrbm93IGFib3V0IHRoaXMgY2FwXG4gICAgICAvLyBCT09MRUFOX0NBUFNfQklUUyBjb3VudHMgbGVmdCB0byByaWdodCxcbiAgICAgIC8vIHNvIHNldCBjYXBzIGJpdHMgZnJvbSBNU0IgKGJpdCA3KSB0byBMU0IgKGJpdCAwKVxuICAgICAgY2Fwc1tjYXBzS2V5XSA9ICEhYml0cyhjYXBzQnl0ZSwgNyAtIG1zYkluZGV4LCAxKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBub24tYm9vbGVhbiBjYXBhYmlsaXRpZXNcbiAgICBjb25zdCBzYW5pdHlMb29wID0gNTAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBwb3MgPCBzdHJDYXBhYmlsaXRpZXMubGVuZ3RoICYmIGkgPCBzYW5pdHlMb29wOyArK2kpIHtcbiAgICAgIGNvbnN0IG9uZWJ5dGUgPSBzdHJUb0ludDgoc3RyQ2FwYWJpbGl0aWVzW3Bvc10pOyAvLyB0eXBlXG4gICAgICBwb3MrKztcbiAgICAgIGNvbnN0IGNhcExlbiA9IHN0clRvSW50MzIoc3RyQ2FwYWJpbGl0aWVzLnN1YnN0cihwb3MsIDQpKSAtIDU7XG4gICAgICBwb3MgKz0gNDtcbiAgICAgIGNvbnN0IHN0clZhbHVlID0gc3RyQ2FwYWJpbGl0aWVzLnN1YnN0cihwb3MsIGNhcExlbik7XG4gICAgICBwb3MgKz0gY2FwTGVuO1xuICAgICAgc3dpdGNoIChvbmVieXRlKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICBjYXBzW0NULlBFRVJfUE9SVF9TUEVFRF0gPSAoc3RyVmFsdWUubGVuZ3RoID09PSA0KSA/IHN0clRvSW50MzIoc3RyVmFsdWUpIDogMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgIGNhcHNbQ1QuUEVFUl9QT1JUX1RZUEVdID0gKHN0clZhbHVlLmxlbmd0aCA9PT0gMSkgPyBzdHJUb0ludDgoc3RyVmFsdWUpIDogMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgIGNhcHNbQ1QuTUFYX0dVQVJBTlRFRURfTVNHX1NJWkVdID0gKHN0clZhbHVlLmxlbmd0aCA9PT0gNCkgPyBzdHJUb0ludDMyKHN0clZhbHVlKSA6IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICBjYXBzW0NULk1BWF9ESVJFQ1RfTVNHX1NJWkVdID0gKHN0clZhbHVlLmxlbmd0aCA9PT0gNCkgPyBzdHJUb0ludDMyKHN0clZhbHVlKSA6IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTk9PUCAodW5rbm93biBjYXApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYXBzO1xuICB9XG5cbiAgc3RhdGljIGdldExvZ2luKHNwcm9wLCBjb3JyZWxhdGlvblRhZykge1xuICAgIGlmICghKHNwcm9wIGluc3RhbmNlb2YgU2Vzc2lvblByb3BlcnRpZXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY2MgPSBuZXcgQ2xpZW50Q3RybE1lc3NhZ2UoU01GQ2xpZW50Q3RybE1lc3NhZ2VUeXBlLkxPR0lOKTtcbiAgICBjb25zdCBzbWZIZWFkZXIgPSBjYy5fc21mSGVhZGVyO1xuICAgIGNvbnN0IGlzQ2xpZW50Q2VydCA9IHNwcm9wLmF1dGhlbnRpY2F0aW9uU2NoZW1lID09PSBBdXRoZW50aWNhdGlvblNjaGVtZS5DTElFTlRfQ0VSVElGSUNBVEU7XG4gICAgc21mSGVhZGVyLnBtX2NvcnJ0YWcgPSBjb3JyZWxhdGlvblRhZztcbiAgICBpZiAoc3Byb3AucGFzc3dvcmQgJiYgIWlzQ2xpZW50Q2VydCkge1xuICAgICAgc21mSGVhZGVyLnBtX3Bhc3N3b3JkID0gc3Byb3AucGFzc3dvcmQ7XG4gICAgfVxuICAgIGlmIChzcHJvcC51c2VyTmFtZSkge1xuICAgICAgc21mSGVhZGVyLnBtX3VzZXJuYW1lID0gc3Byb3AudXNlck5hbWU7XG4gICAgfVxuICAgIGlmIChzcHJvcC5zdWJzY3JpYmVyTG9jYWxQcmlvcml0eSAmJiBzcHJvcC5zdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5KSB7XG4gICAgICBjYy5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcigwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU01GQ2xpZW50Q3RybFBhcmFtLkRFTElWRVJUT09ORVBSSU9SSVRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xpZW50Q3RybE1lc3NhZ2UucHJtR2V0RHRvUHJpb3JpdHlWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsOiAgIHNwcm9wLnN1YnNjcmliZXJMb2NhbFByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBzcHJvcC5zdWJzY3JpYmVyTmV0d29ya1ByaW9yaXR5IH0pKSk7XG4gICAgfVxuICAgIGlmIChzcHJvcC52cG5OYW1lICYmIHNwcm9wLnZwbk5hbWUubGVuZ3RoID4gMCkge1xuICAgICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkNsaWVudEN0cmxQYXJhbS5NU0dWUE5OQU1FLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFRlcm1pbmF0ZShzcHJvcC52cG5OYW1lKSkpO1xuICAgIH1cblxuICAgIGlmIChzcHJvcC5hcHBsaWNhdGlvbkRlc2NyaXB0aW9uICYmIHNwcm9wLmFwcGxpY2F0aW9uRGVzY3JpcHRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkNsaWVudEN0cmxQYXJhbS5DTElFTlRERVNDLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFRlcm1pbmF0ZShzcHJvcC5hcHBsaWNhdGlvbkRlc2NyaXB0aW9uKSkpO1xuICAgIH1cblxuICAgIGlmIChzcHJvcC51c2VySWRlbnRpZmljYXRpb24gJiYgc3Byb3AudXNlcklkZW50aWZpY2F0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgIGNjLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uVVNFUklELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFRlcm1pbmF0ZShzcHJvcC51c2VySWRlbnRpZmljYXRpb24pKSk7XG4gICAgfVxuXG4gICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uQ0xJRU5UTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsVGVybWluYXRlKHNwcm9wLmNsaWVudE5hbWUpKSk7XG4gICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uUExBVEZPUk0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFRlcm1pbmF0ZShgJHtQcm9jZXNzLnBsYXRmb3JtfSAtIEpTIEFQSSAoJHtWZXJzaW9uLm1vZGV9KWApKSk7XG5cbiAgICBpZiAoc3Byb3Aubm9Mb2NhbCkge1xuICAgICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkNsaWVudEN0cmxQYXJhbS5OT19MT0NBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXHgwMScpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDbGllbnRDZXJ0KSB7XG4gICAgICBjYy5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcigxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU01GQ2xpZW50Q3RybFBhcmFtLkFVVEhFTlRJQ0FUSU9OX1NDSEVNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXHgwMScpKTtcbiAgICB9XG5cbiAgICBjYy5hZGRQYXJhbWV0ZXIobmV3IFNNRlBhcmFtZXRlcigwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNNRkNsaWVudEN0cmxQYXJhbS5TT0ZUV0FSRURBVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFRlcm1pbmF0ZShWZXJzaW9uLmZvcm1hdHRlZERhdGUpKSk7XG4gICAgY2MuYWRkUGFyYW1ldGVyKG5ldyBTTUZQYXJhbWV0ZXIoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uU09GVFdBUkVWRVJTSU9OLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxUZXJtaW5hdGUoVmVyc2lvbi52ZXJzaW9uKSkpO1xuICAgIHJldHVybiBjYztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBDQyB1cGRhdGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtNdXRhYmxlU2Vzc2lvblByb3BlcnR5fSBtdXRhYmxlU2Vzc2lvblByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25UYWcgVGhlIGNvcnJlbGF0aW9uIHRhZyBmb3IgdGhlIHJlcXVlc3RcbiAgICogQHJldHVybnMge0NsaWVudEN0cmxNZXNzYWdlfSBUaGUgbmV3IFVQREFURSBtZXNzYWdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZ2V0VXBkYXRlKG11dGFibGVTZXNzaW9uUHJvcGVydHksIG5ld1ZhbHVlLCBjb3JyZWxhdGlvblRhZykge1xuICAgIGNvbnN0IGNjID0gbmV3IENsaWVudEN0cmxNZXNzYWdlKFNNRkNsaWVudEN0cmxNZXNzYWdlVHlwZS5VUERBVEUpO1xuICAgIGNvbnN0IHNtZkhlYWRlciA9IGNjLnNtZkhlYWRlcjtcbiAgICBzbWZIZWFkZXIucG1fY29ycnRhZyA9IGNvcnJlbGF0aW9uVGFnO1xuICAgIGlmIChtdXRhYmxlU2Vzc2lvblByb3BlcnR5ID09PSBNdXRhYmxlU2Vzc2lvblByb3BlcnR5LkNMSUVOVF9ERVNDUklQVElPTikge1xuICAgICAgY29uc3QgYXBwZGVzYyA9IChuZXdWYWx1ZSB8fCAnJykudG9TdHJpbmcoKS5zdWJzdHIoMCwgMjUwKTtcbiAgICAgIGNjLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uQ0xJRU5UREVTQyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxUZXJtaW5hdGUoYXBwZGVzYykpKTtcbiAgICB9IGVsc2UgaWYgKG11dGFibGVTZXNzaW9uUHJvcGVydHkgPT09IE11dGFibGVTZXNzaW9uUHJvcGVydHkuQ0xJRU5UX05BTUUpIHtcbiAgICAgIGNvbnN0IGVycm9yID1cbiAgICAgICAgQ2xpZW50Q3RybE1lc3NhZ2UudmFsaWRhdGVDbGllbnROYW1lKFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIGVycm9yTWVzc2FnZSA9PlxuICAgICAgICAgICAgbmV3IE9wZXJhdGlvbkVycm9yKGBJbnZhbGlkIGNsaWVudE5hbWU6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGNjLmFkZFBhcmFtZXRlcihuZXcgU01GUGFyYW1ldGVyKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTTUZDbGllbnRDdHJsUGFyYW0uQ0xJRU5UTkFNRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxUZXJtaW5hdGUobmV3VmFsdWUpKSk7XG4gICAgfVxuICAgIHJldHVybiBjYztcbiAgfVxuXG4gIHN0YXRpYyB2YWxpZGF0ZUNsaWVudE5hbWUoc3RyTmFtZSwgZXhjZXB0aW9uQ3JlYXRvcikge1xuICAgIGNvbnN0IGVuY29kZVJlc3VsdCA9IHZhbGlkYXRlQW5kRW5jb2RlKERlc3RpbmF0aW9uVHlwZS5UT1BJQywgc3RyTmFtZSwgZXhjZXB0aW9uQ3JlYXRvcik7XG4gICAgaWYgKGVuY29kZVJlc3VsdC5lcnJvcikge1xuICAgICAgcmV0dXJuIGVuY29kZVJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgLy8gQWRkIDE6IGJ5dGVzIGluY2x1ZGVzIHRlcm1pbmF0b3IsIDE2MCBleGNsdWRlcyB0ZXJtaW5hdG9yXG4gICAgaWYgKGVuY29kZVJlc3VsdC5ieXRlcy5sZW5ndGggPiAxNjEpIHtcbiAgICAgIHJldHVybiBleGNlcHRpb25DcmVhdG9yKCdDbGllbnQgTmFtZSB0b28gbG9uZyAobWF4IGxlbmd0aDogMTYwKS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5DbGllbnRDdHJsTWVzc2FnZSA9IENsaWVudEN0cmxNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9tZXNzYWdlLW9iamVjdHMvY2xpZW50LWN0cmwtbWVzc2FnZS5qcyIsImNvbnN0IHsgQmFzZU1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4vYmFzZS1tZXNzYWdlJyk7XG5jb25zdCB7IFNNRkhlYWRlciB9ID0gcmVxdWlyZSgnLi9zbWYtaGVhZGVyJyk7XG5jb25zdCB7IFNNRlByb3RvY29sIH0gPSByZXF1aXJlKCcuLi9zbWYtcHJvdG9jb2xzJyk7XG5cbmNsYXNzIEtlZXBBbGl2ZU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG5ldyBTTUZIZWFkZXIoU01GUHJvdG9jb2wuS0VFUEFMSVZFVjIsIDIpKTtcbiAgICB0aGlzLl9zbWZIZWFkZXIuc21mX3VoID0gMjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5LZWVwQWxpdmVNZXNzYWdlID0gS2VlcEFsaXZlTWVzc2FnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL2tlZXAtYWxpdmUtbWVzc2FnZS5qcyIsImNvbnN0IHsgYXNzZXJ0IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgQmFzZU1lc3NhZ2UgfSA9IHJlcXVpcmUoJy4vYmFzZS1tZXNzYWdlJyk7XG5jb25zdCB7IERlc3RpbmF0aW9uIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbmNvbnN0IHsgU01GSGVhZGVyIH0gPSByZXF1aXJlKCcuL3NtZi1oZWFkZXInKTtcbmNvbnN0IHsgU01GUHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3NtZi1wcm90b2NvbHMnKTtcbmNvbnN0IHsgU01GU01QTWVzc2FnZVR5cGUgfSA9IHJlcXVpcmUoJy4uL3NtZi1zbXAtbWVzc2FnZS10eXBlcycpO1xuY29uc3QgeyBTTUZTTVBNZXNzYWdlVHlwZUZsYWdzIH0gPSByZXF1aXJlKCcuLi9zbWYtc21wLW1lc3NhZ2UtdHlwZS1mbGFncycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gU01QIHJlcXVlc3Qgb3IgcmVwbHkgbWVzc2FnZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU01QTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTTVBNZXNzYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgU01QTWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIobmV3IFNNRkhlYWRlcihTTUZQcm90b2NvbC5TTVAsIDEpKTtcblxuICAgIC8vIEZpZWxkOiBtc2d0eXBlXG4gICAgdGhpcy5tc2dUeXBlID0gMDtcblxuICAgIC8vIEZpZWxkOiBzdWJzY3JpcHRpb24gc3RyaW5nXG4gICAgdGhpcy5lbmNvZGVkVXRmOFN1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLnNtcEZsYWdzID0gKDAgfCBTTUZTTVBNZXNzYWdlVHlwZUZsYWdzLlNNRl9TTVBfRkxBR19UT1BJQyk7IC8vIGRlZmF1bHQgZmxhZ3NcblxuICAgIHRoaXMuX2VuY29kZWRRdWV1ZU5hbWUgPSBudWxsOyAvLyB1bnVzZWQgaW4gc29sY2xpZW50anNcbiAgICB0aGlzLl9lbmNvZGVkQ2xpZW50TmFtZSA9IG51bGw7IC8vIHVudXNlZCBpbiBzb2xjbGllbnRqc1xuICB9XG5cbiAgaXNGbGFnKGZsYWdNYXNrKSB7XG4gICAgcmV0dXJuICh0aGlzLnNtcEZsYWdzICYgZmxhZ01hc2spO1xuICB9XG5cbiAgc2V0RmxhZyhmbGFnTWFzaywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc21wRmxhZ3MgfD0gZmxhZ01hc2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc21wRmxhZ3MgJj0gKH5mbGFnTWFzayk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldFN1YnNjcmlwdGlvbk1lc3NhZ2UoY29ycmVsYXRpb25UYWcsIHRvcGljLCBhZGQsIHJlcXVlc3RDb25maXJtKSB7XG4gICAgYXNzZXJ0KHRvcGljIGluc3RhbmNlb2YgRGVzdGluYXRpb24sICdUb3BpY3MgYXJlIG5vdCBVQ1MtMiBzdHJpbmdzLiBQYXNzIGEgVG9waWMgb2JqZWN0LicpO1xuICAgIGNvbnN0IHNtcCA9IG5ldyBTTVBNZXNzYWdlKCk7XG4gICAgc21wLm1zZ1R5cGUgPSBhZGRcbiAgICAgID8gU01GU01QTWVzc2FnZVR5cGUuQUREU1VCU0NSSVBUSU9OXG4gICAgICA6IFNNRlNNUE1lc3NhZ2VUeXBlLlJFTVNVQlNDUklQVElPTjtcbiAgICBzbXAuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24gPSB0b3BpYy5nZXRCeXRlcygpO1xuICAgIGFzc2VydChzbXAuZW5jb2RlZFV0ZjhTdWJzY3JpcHRpb24sICdUb3BpYyBoYWQgbm8gZW5jb2RpbmcnKTtcbiAgICBzbXAuc2V0RmxhZyhTTUZTTVBNZXNzYWdlVHlwZUZsYWdzLlNNRl9TTVBfRkxBR19UT1BJQywgdHJ1ZSk7XG4gICAgaWYgKHJlcXVlc3RDb25maXJtKSB7XG4gICAgICBzbXAuc2V0RmxhZyhTTUZTTVBNZXNzYWdlVHlwZUZsYWdzLlNNRl9TTVBfRkxBR19SRVNQUkVRVUlSRUQsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBwdXQgYSBjb3JyZWxhdGlvbiB0YWdcbiAgICBzbXAuX3NtZkhlYWRlci5wbV9jb3JydGFnID0gY29ycmVsYXRpb25UYWc7XG4gICAgcmV0dXJuIHNtcDtcbiAgfVxuXG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5TTVBNZXNzYWdlID0gU01QTWVzc2FnZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNtZi9saWIvbWVzc2FnZS1vYmplY3RzL3NtcC1tZXNzYWdlLmpzIiwiY29uc3QgeyBCYXNlTWVzc2FnZSB9ID0gcmVxdWlyZSgnLi9iYXNlLW1lc3NhZ2UnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUcmFuc3BvcnQgU01GIE1lc3NhZ2VcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFRyYW5zcG9ydFNNRk1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG51bGwsIG51bGwpO1xuICAgIHRoaXMudWggPSAwO1xuICAgIHRoaXMubWVzc2FnZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuc2Vzc2lvbklkID0gbnVsbDtcbiAgICB0aGlzLnJvdXRlclRhZyA9IG51bGw7XG4gICAgdGhpcy5wYXlsb2FkID0gbnVsbDtcbiAgICB0aGlzLnBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMudHNIZWFkZXJMZW5ndGggPSAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFNNRk1lc3NhZ2UgPSBUcmFuc3BvcnRTTUZNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc21mL2xpYi9tZXNzYWdlLW9iamVjdHMvdHJhbnNwb3J0LXNtZi1tZXNzYWdlLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ2FjaGVHZXRSZXN1bHRDb2RlID0ge1xuICBJTlZBTElEOiAwLFxuICBPSzogICAgICAxLFxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVHZXRSZXN1bHRDb2RlID0gRW51bS5uZXcoQ2FjaGVHZXRSZXN1bHRDb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLWdldC1yZXN1bHQtY29kZXMuanMiLCJjb25zdCB7IENhY2hlR2V0UmVzdWx0Q29kZSB9ID0gcmVxdWlyZSgnLi9jYWNoZS1nZXQtcmVzdWx0LWNvZGVzJyk7XG5cbmNvbnN0IERFRkFVTFRTID0ge1xuICBtZXNzYWdlSUQ6ICAgICAgICAgbnVsbCxcbiAgdmVyc2lvbjogICAgICAgICAgIDAsXG4gIHJlc3BvbnNlQ29kZTogICAgICBDYWNoZUdldFJlc3VsdENvZGUuSU5WQUxJRCxcbiAgcmVzcG9uc2VTdHJpbmc6ICAgICcnLFxuICBtYXRjaFRvcGljOiAgICAgICAgJycsXG4gIHNlc3Npb25JRDogICAgICAgICBudWxsLFxuICBpc1N1c3BlY3Q6ICAgICAgICAgbnVsbCxcbiAgaGFzTW9yZTogICAgICAgICAgIG51bGwsXG4gIGhhc1RpbWVzdGFtcHM6ICAgICBudWxsLFxuICByZXBseVRvOiAgICAgICAgICAgbnVsbCxcbiAgbWVzc2FnZVN0cmVhbTogICAgIG51bGwsXG4gIGNsdXN0ZXJOYW1lU3RyZWFtOiBudWxsLFxufTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIENhY2hlR2V0UmVzdWx0IGVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGEgY2FjaGUgZ2V0IHJlcXVlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENhY2hlR2V0UmVzdWx0IHtcbiAgLypcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0gREVGQVVMVFMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmVhZEZyb21TdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5tZXNzYWdlSUQgPSBzdHJlYW0uZ2V0TmV4dCgpLmdldFZhbHVlKCk7XG4gICAgdGhpcy52ZXJzaW9uID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIHRoaXMucmVzcG9uc2VDb2RlID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIHRoaXMucmVzcG9uc2VTdHJpbmcgPSBzdHJlYW0uZ2V0TmV4dCgpLmdldFZhbHVlKCk7XG4gICAgLy8gU0QgY2xhaW1zIGluc3RhbmNlTmFtZSBpcyBwcmVzZW50IGhlcmUgYnV0IGVtcGlyaWNhbGx5LCBpdCdzIG5vdFxuXG4gICAgdGhpcy5tYXRjaFRvcGljID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuc2Vzc2lvbklEID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuaXNTdXNwZWN0ID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuaGFzTW9yZSA9IHN0cmVhbS5nZXROZXh0KCkuZ2V0VmFsdWUoKTtcblxuICAgIHRoaXMuaGFzVGltZXN0YW1wcyA9IHN0cmVhbS5nZXROZXh0KCkuZ2V0VmFsdWUoKTtcblxuICAgIGlmIChzdHJlYW0uaGFzTmV4dCgpKSB7IC8vIGZpcnN0IHN0cmVhbVxuICAgICAgdGhpcy5tZXNzYWdlU3RyZWFtID0gc3RyZWFtLmdldE5leHQoKS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmhhc05leHQoKSkgeyAvLyBpZiB0d28gc3RyZWFtcywgZmlyc3Qgd2FzIGNsdXN0ZXIgbmFtZSBzdHJlYW1cbiAgICAgIHRoaXMuY2x1c3Rlck5hbWVTdHJlYW0gPSB0aGlzLm1lc3NhZ2VTdHJlYW07XG4gICAgICB0aGlzLm1lc3NhZ2VTdHJlYW0gPSBzdHJlYW0uZ2V0TmV4dCgpLmdldFZhbHVlKCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNhY2hlR2V0UmVzdWx0ID0gQ2FjaGVHZXRSZXN1bHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1nZXQtcmVzdWx0LmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ2FjaGVSZXF1ZXN0VHlwZSA9IHtcbiAgSU5WQUxJRDogICAgICAgICAgICAgICAgICAgICAgIDAsXG4gIEJVTEtfTVNHOiAgICAgICAgICAgICAgICAgICAgICAxLFxuICBSRUdJU1RFUl9SRVFVRVNUOiAgICAgICAgICAgICAgMixcbiAgUkVHSVNURVJfUkVTUE9OU0U6ICAgICAgICAgICAgIDMsXG4gIEhFQVJUQkVBVF9SRVFVRVNUOiAgICAgICAgICAgICA0LFxuICBIRUFSVEJFQVRfUkVTUE9OU0U6ICAgICAgICAgICAgNSxcbiAgRVZFTlRfTk9USUZZOiAgICAgICAgICAgICAgICAgIDYsXG4gIEVWRU5UX0FDSzogICAgICAgICAgICAgICAgICAgICA3LFxuICBBQ1RJT05fUkVRVUVTVDogICAgICAgICAgICAgICAgOCxcbiAgQUNUSU9OX1JFU1BPTlNFOiAgICAgICAgICAgICAgIDksXG4gIEdFVF9SRVFVRVNUOiAgICAgICAgICAgICAgICAgICAxMCxcbiAgR0VUX1JFU1BPTlNFOiAgICAgICAgICAgICAgICAgIDExLFxuICBHRVRfTkVYVF9SRVFVRVNUOiAgICAgICAgICAgICAgMTIsXG4gIEdFVF9ORVhUX1JFU1BPTlNFOiAgICAgICAgICAgICAxMyxcbiAgU0VUX1JFUVVFU1Q6ICAgICAgICAgICAgICAgICAgIDE0LFxuICBTRVRfUkVTUE9OU0U6ICAgICAgICAgICAgICAgICAgMTUsXG4gIEdFVF9NU0dfUkVRVUVTVDogICAgICAgICAgICAgICAxNixcbiAgR0VUX01TR19SRVNQT05TRTogICAgICAgICAgICAgIDE3LFxuICBHRVRfTkVYVF9NU0dfUkVRVUVTVDogICAgICAgICAgMTgsXG4gIEdFVF9ORVhUX01TR19SRVNQT05TRTogICAgICAgICAxOSxcbiAgVU5SRUdJU1RFUl9JTkQ6ICAgICAgICAgICAgICAgIDIwLFxuICBCVUxLX1NFVF9SRVFVRVNUOiAgICAgICAgICAgICAgMjEsXG4gIEJVTEtfU0VUX1JFU1BPTlNFOiAgICAgICAgICAgICAyMixcbiAgUFVSR0VfTVNHX1NFUVVFTkNFX1JFUVVFU1Q6ICAgIDIzLFxuICBQVVJHRV9NU0dfU0VRVUVOQ0VfUkVTUE9OU0U6ICAgMjQsXG4gIEdFVF9NU0dfU0VRVUVOQ0VfUkVRVUVTVDogICAgICAyNSxcbiAgR0VUX05FWFRfTVNHX1NFUVVFTkNFX1JFUVVFU1Q6IDI2LFxuICBHRVRfVE9QSUNfSU5GT19SRVFVRVNUOiAgICAgICAgMjcsXG4gIEdFVF9UT1BJQ19JTkZPX1JFU1BPTlNFOiAgICAgICAyOCxcbiAgUkVBRFlfTUFSS0VSOiAgICAgICAgICAgICAgICAgIDI5LFxuICBHRVRfVE9QSUNfSU5GT19SRVFVRVNUX1JBTkdFOiAgMzAsXG4gIFNZTkNfUkVBRFlfTUFSS0VSOiAgICAgICAgICAgICAzMSxcbiAgVkFDVVVNX1JFUVVFU1Q6ICAgICAgICAgICAgICAgIDMyLFxuICBWQUNVVU1fUkVTUE9OU0U6ICAgICAgICAgICAgICAgMzMsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DYWNoZVJlcXVlc3RUeXBlID0gRW51bS5uZXcoQ2FjaGVSZXF1ZXN0VHlwZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC1zb2xjYWNoZS1zZXNzaW9uL2xpYi9jYWNoZS1yZXF1ZXN0LXR5cGVzLmpzIiwiLyoqXG4gKiBBIHR1cGxlIGFzc29jaWF0aW5nIHN1YnNjcmlwdGlvbnMsIGNvcnJlbGF0aW9uIElEcyBhbmQgY2FjaGUgc2Vzc2lvbnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29ycmVsYXRpb25JRCBUaGUgY29ycmVsYXRpb24gSUQgZm9yIHRoaXMgdHVwbGVcbiAqIEBwYXJhbSB7VG9waWN9IHRvcGljIFRoZSB0b3BpYyBmb3IgdGhpcyB0dXBsZVxuICogQHBhcmFtIHtDYWNoZVNlc3Npb259IGNhY2hlU2Vzc2lvbiBUaGUgY2FjaGUgc2Vzc2lvbiBmb3IgdGhpcyB0dXBsZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2FjaGVTZXNzaW9uU3Vic2NyaWJlSW5mbyB7XG4gIGNvbnN0cnVjdG9yKGNvcnJlbGF0aW9uSUQsIHRvcGljLCBjYWNoZVNlc3Npb24pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIGNvcnJlbGF0aW9uSUQsXG4gICAgICB0b3BpYyxcbiAgICAgIGNhY2hlU2Vzc2lvbixcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5DYWNoZVNlc3Npb25TdWJzY3JpYmVJbmZvID0gQ2FjaGVTZXNzaW9uU3Vic2NyaWJlSW5mbztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXNvbGNhY2hlLXNlc3Npb24vbGliL2NhY2hlLXNlc3Npb24tc3Vic2NyaWJlLWluZm8uanMiLCJjb25zdCBNZXNzYWdlTGliID0gcmVxdWlyZSgnc29sY2xpZW50LW1lc3NhZ2UnKTtcbmNvbnN0IFNlc3Npb25MaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtc2Vzc2lvbicpO1xuY29uc3QgU01GTGliID0gcmVxdWlyZSgnc29sY2xpZW50LXNtZicpO1xuY29uc3QgU3RhdFR5cGUgPSByZXF1aXJlKCdzb2xjbGllbnQtc3RhdHMnKTtcbmNvbnN0IHtcbiAgRXJyb3JTdWJjb2RlLFxuICBPcGVyYXRpb25FcnJvcixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHtcbiAgTE9HX1RSQUNFLFxuICBMT0dfREVCVUcsXG4gIExPR19JTkZPLFxuICBMT0dfV0FSTixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7XG4gIFNEVEZpZWxkLFxuICBTRFRGaWVsZFR5cGUsXG4gIFNEVFN0cmVhbUNvbnRhaW5lcixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtc2R0Jyk7XG5jb25zdCB7IENhY2hlQ0JJbmZvIH0gPSByZXF1aXJlKCcuL2NhY2hlLWNiLWluZm8nKTtcbmNvbnN0IHsgQ2FjaGVDb250ZXh0IH0gPSByZXF1aXJlKCcuL2NhY2hlLWNvbnRleHQnKTtcbmNvbnN0IHsgQ2FjaGVHZXRSZXN1bHQgfSA9IHJlcXVpcmUoJy4vY2FjaGUtZ2V0LXJlc3VsdCcpO1xuY29uc3QgeyBDYWNoZUxpdmVEYXRhQWN0aW9uIH0gPSByZXF1aXJlKCcuL2NhY2hlLWxpdmUtZGF0YS1hY3Rpb25zJyk7XG5jb25zdCB7IENhY2hlUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi9jYWNoZS1yZXF1ZXN0Jyk7XG5jb25zdCB7IENhY2hlUmVxdWVzdFJlc3VsdCB9ID0gcmVxdWlyZSgnLi9jYWNoZS1yZXF1ZXN0LXJlc3VsdCcpO1xuY29uc3QgeyBDYWNoZVJlcXVlc3RUeXBlIH0gPSByZXF1aXJlKCcuL2NhY2hlLXJlcXVlc3QtdHlwZXMnKTtcbmNvbnN0IHsgQ2FjaGVSZXR1cm5Db2RlIH0gPSByZXF1aXJlKCcuL2NhY2hlLXJldHVybi1jb2RlcycpO1xuY29uc3QgeyBDYWNoZVJldHVyblN1YmNvZGUgfSA9IHJlcXVpcmUoJy4vY2FjaGUtcmV0dXJuLXN1YmNvZGVzJyk7XG5jb25zdCB7IENhY2hlU2Vzc2lvblByb3BlcnRpZXMgfSA9IHJlcXVpcmUoJy4vY2FjaGUtc2Vzc2lvbi1wcm9wZXJ0aWVzJyk7XG5jb25zdCB7IENhY2hlU2Vzc2lvblN1YnNjcmliZUluZm8gfSA9IHJlcXVpcmUoJy4vY2FjaGUtc2Vzc2lvbi1zdWJzY3JpYmUtaW5mbycpO1xuY29uc3QgeyBEZXN0aW5hdGlvbixcbiAgICAgICAgVG9waWMgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZXN0aW5hdGlvbicpO1xuXG5jb25zdCB7IENBQ0hFX1JFUVVFU1RfUFJFRklYIH0gPSBDYWNoZUNvbnRleHQ7XG5cbmNvbnN0IG5vT3AgPSAoKSA9PiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogPGI+VGhpcyBjbGFzcyBpcyBub3QgZXhwb3NlZCBmb3IgY29uc3RydWN0aW9uIGJ5IEFQSSB1c2Vycy4gVXNlcnMgc2hvdWxkIG9idGFpbiBhbiBpbnN0YW5jZSBmcm9tXG4gKiB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlQ2FjaGVTZXNzaW9ufTwvYj5cbiAqIDxwPlxuICogQSBzZXNzaW9uIGZvciBwZXJmb3JtaW5nIGNhY2hlIHJlcXVlc3RzLlxuICpcbiAqIEFwcGxpY2F0aW9ucyBtdXN0IHVzZSB7QGxpbmsgc29sYWNlLlNlc3Npb24jY3JlYXRlQ2FjaGVTZXNzaW9ufSB0byBjb25zdHJ1Y3QgdGhpcyBjbGFzcy5cbiAqXG4gKiBUaGUgc3VwcGxpZWQge0BsaW5rIHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzfSB3aWxsIGJlIGNvcGllZC4gU3Vic2VxdWVudCBtb2RpZmljYXRpb25zXG4gKiB0byB0aGUgcGFzc2VkIHByb3BlcnRpZXMgd2lsbCBub3QgbW9kaWZ5IHRoZSBzZXNzaW9uLiBUaGUgcHJvcGVydGllcyBtYXkgYmUgcmV1c2VkLlxuICpcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqL1xuY2xhc3MgQ2FjaGVTZXNzaW9uIHtcbiAgLypcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7c29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXN9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgY2FjaGUgc2Vzc2lvbi5cbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgU2Vzc2lvbiBvbiB3aGljaCB0aGUgQ2FjaGVTZXNzaW9uIHdpbGwgaXNzdWVcbiAgICogIGNhY2hlIHJlcXVlc3RzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJpdmF0ZUludGVyZmFjZSBQcml2YXRlIG1ldGhvZHMgZXhwb3NlZCB0byB0aGlzIENhY2hlU2Vzc2lvbi5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfVxuICAgKiAgKiBpZiB0aGUgcGFyYW1ldGVycyBoYXZlIGFuIGludmFsaWQgdHlwZSBvciB2YWx1ZTtcbiAgICogICAgc3ViY29kZSB7QGxpbmsgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEV9LlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMsIHNlc3Npb24sIHByaXZhdGVJbnRlcmZhY2UpIHtcbiAgICBDYWNoZVNlc3Npb24uX3ZhbGlkYXRlUHJvcHMocHJvcHMpO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgQ2FjaGVTZXNzaW9uUHJvcGVydGllcyhwcm9wcy5jYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLm1heEFnZVNlYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMubWF4TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnRpbWVvdXRNc2VjKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF9vdXRzdGFuZGluZ1JlcXVlc3RzOiAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgX291dHN0YW5kaW5nSURzOiAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBfZGlzcG9zZWQ6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIF9uZXh0TWVzc2FnZUNhbGxiYWNrSW5mbzogICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBfbmV4dFNlc3Npb25FdmVudENhbGxiYWNrSW5mbzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgX3Byb3BlcnRpZXM6ICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgIF9zZXNzaW9uOiAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBfc2Vzc2lvbklGOiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUludGVyZmFjZSxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgIHRoaXMuX2Nvbm5lY3RUb1Nlc3Npb24oc2Vzc2lvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgc2Vzc2lvbiB0byBjb25uZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29ubmVjdFRvU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgdGhpcy5fbmV4dFNlc3Npb25FdmVudENhbGxiYWNrSW5mbyA9IHNlc3Npb24uZ2V0RXZlbnRDQkluZm8oKTtcbiAgICB0aGlzLl9uZXh0TWVzc2FnZUNhbGxiYWNrSW5mbyA9IHNlc3Npb24uZ2V0TWVzc2FnZUNCSW5mbygpO1xuICAgIHNlc3Npb24uc2V0TWVzc2FnZUNCSW5mbyhuZXcgU2Vzc2lvbkxpYi5NZXNzYWdlUnhDQkluZm8oKF8sIG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSwgdGhpcykpO1xuICAgIHNlc3Npb24uc2V0RXZlbnRDQkluZm8odGhpcy5fY3JlYXRlQ29tcG91bmRFdmVudENCKHRoaXMuX25leHRTZXNzaW9uRXZlbnRDYWxsYmFja0luZm8pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgc2Vzc2lvbidzIGV4aXN0aW5nIGV2ZW50IGNhbGxiYWNrIGFuZCBzZXRzIGl0IGFzIHRoZSBuZXh0IGRlbGVnYXRlIGluIGFcbiAgICogY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuIFRoZSBuZXh0IGRlbGVnYXRlIGNvdWxkIGJlIHRoZSBjbGllbnQgYXBwbGljYXRpb24sIG9yIGFub3RoZXJcbiAgICogY2FjaGUgc2Vzc2lvbi5cbiAgICogQHBhcmFtIHtTZXNzaW9uRXZlbnRDQkluZm99IG5leHREZWxlZ2F0ZSBUaGUgbmV4dCBldmVudCByZWNlaXZlciBpbiB0aGUgY2hhaW5cbiAgICogQHJldHVybnMge1Nlc3Npb25FdmVudENCSW5mb30gQW4gZXZlbnQgcmVjZWl2ZXIgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIHN1cHBsaWVkIHJlY2VpdmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ29tcG91bmRFdmVudENCKG5leHREZWxlZ2F0ZSkge1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbkxpYi5TZXNzaW9uRXZlbnRDQkluZm8oKHNlc3Npb24sIHNlc3Npb25FdmVudCwgdXNlck9iamVjdCwgcmZ1T2JqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVTZXNzaW9uRXZlbnQobmV4dERlbGVnYXRlLCBzZXNzaW9uLCBzZXNzaW9uRXZlbnQsIHVzZXJPYmplY3QsIHJmdU9iamVjdCk7XG4gICAgfSwgbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZWQgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuIEhhbmRsZXMgdGhlIGV2ZW50LCB0aGVuIHBhc3NlcyB0aGUgZXZlbnQgdG8gdGhlIG5leHRcbiAgICogZGVsZWdhdGUuXG4gICAqIEBwYXJhbSB7U2Vzc2lvbkV2ZW50Q0JJbmZvfSBuZXh0RGVsZWdhdGUgVGhlIG5leHQgZGVsZWdhdGUgdG8gbm90aWZ5XG4gICAqIEBwYXJhbSB7c29sYWNlLlNlc3Npb259IHNlc3Npb24gVGhlIGFzc29jaWF0ZWQgc2Vzc2lvblxuICAgKiBAcGFyYW0ge1Nlc3Npb25FdmVudH0gc2Vzc2lvbkV2ZW50IFRoZSBzZXNzaW9uIGV2ZW50IHRvIGRpc3BhdGNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlU2Vzc2lvbkV2ZW50KG5leHREZWxlZ2F0ZSwgc2Vzc2lvbiwgc2Vzc2lvbkV2ZW50IC8qLCB1c2VyT2JqZWN0LCByZnVPYmplY3QgKi8pIHtcbiAgICBjb25zdCBwYXNzRXZlbnQgPSB0aGlzLl9wcm9jZXNzU2Vzc2lvbkV2ZW50KHNlc3Npb24sIHNlc3Npb25FdmVudCk7XG4gICAgaWYgKCFwYXNzRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2JVc2VyT2JqZWN0ID0gbmV4dERlbGVnYXRlLnVzZXJPYmplY3Q7XG4gICAgaWYgKCFjYlVzZXJPYmplY3QpIHtcbiAgICAgIG5leHREZWxlZ2F0ZS5zZXNzaW9uRXZlbnRDQkZ1bmN0aW9uKHNlc3Npb24sIHNlc3Npb25FdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHREZWxlZ2F0ZS5zZXNzaW9uRXZlbnRDQkZ1bmN0aW9uKHNlc3Npb24sIHNlc3Npb25FdmVudCwgY2JVc2VyT2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGZvcndhcmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZW5kVG9OZXh0RGVsZWdhdGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNiVXNlck9iamVjdCA9IHRoaXMuX25leHRNZXNzYWdlQ2FsbGJhY2tJbmZvLnVzZXJPYmplY3Q7XG4gICAgaWYgKCFjYlVzZXJPYmplY3QpIHtcbiAgICAgIHRoaXMuX25leHRNZXNzYWdlQ2FsbGJhY2tJbmZvLm1lc3NhZ2VSeENCRnVuY3Rpb24odGhpcy5fc2Vzc2lvbiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25leHRNZXNzYWdlQ2FsbGJhY2tJbmZvLm1lc3NhZ2VSeENCRnVuY3Rpb24odGhpcy5fc2Vzc2lvbiwgbWVzc2FnZSwgY2JVc2VyT2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgYXNzb2NpYXRlZCBzZXNzaW9uXG4gICAqIEBwYXJhbSB7U2Vzc2lvbkV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBldmVudCBzaG91bGQgcGFzcyB0byBuZXh0IGRlbGVnYXRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Nlc3Npb25FdmVudChzZXNzaW9uLCBldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQuc2Vzc2lvbkV2ZW50Q29kZSkge1xuICAgICAgY2FzZSBTZXNzaW9uTGliLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX0VSUk9SOlxuICAgICAgY2FzZSBTZXNzaW9uTGliLlNlc3Npb25FdmVudENvZGUuU1VCU0NSSVBUSU9OX09LOlxuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tTdWJzY3JpcHRpb25TdGF0dXMoZXZlbnQpO1xuICAgICAgY2FzZSBTZXNzaW9uTGliLlNlc3Npb25FdmVudENvZGUuRE9XTl9FUlJPUjpcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgTE9HX1RSQUNFKGBVbmhhbmRsZWQgc2Vzc2lvbiBldmVudDogJHtldmVudC5zZXNzaW9uRXZlbnRDb2RlfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTZXNzaW9uRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGV2ZW50IHNob3VsZCBwYXNzIHRvIG5leHQgZGVsZWdhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1N1YnNjcmlwdGlvblN0YXR1cyhldmVudCkge1xuICAgIC8vIEluY3JlbWVudGFsIGNoZWNrcyBmb3Igd2hldGhlciB0aGlzIGlzIG91ciBzdWJzY3JpcHRpb24uXG4gICAgaWYgKChldmVudC5jb3JyZWxhdGlvbktleSA9PT0gbnVsbCB8fCBldmVudC5jb3JyZWxhdGlvbktleSA9PT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAoIShldmVudC5jb3JyZWxhdGlvbktleSBpbnN0YW5jZW9mIENhY2hlU2Vzc2lvblN1YnNjcmliZUluZm8pKSB8fFxuICAgICAgICAoZXZlbnQuY29ycmVsYXRpb25LZXkuY2FjaGVTZXNzaW9uICE9PSB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9nZXRPdXRzdGFuZGluZ1JlcXVlc3QoZXZlbnQuY29ycmVsYXRpb25LZXkuY29ycmVsYXRpb25JRCk7XG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICBMT0dfV0FSTihgTm8gcmVxdWVzdCBmb3VuZCBmb3Igc3Vic2NyaXB0aW9uIHN1Y2Nlc3Mgb24gJHtldmVudC5jb3JyZWxhdGlvbktleS50b3BpY31gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuc2Vzc2lvbkV2ZW50Q29kZSA9PT0gU2Vzc2lvbkxpYi5TZXNzaW9uRXZlbnRDb2RlLlNVQlNDUklQVElPTl9PSykge1xuICAgICAgdGhpcy5faGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VzcyhyZXF1ZXN0LCBldmVudC5jb3JyZWxhdGlvbktleS50b3BpYyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVN1YnNjcmlwdGlvbkVycm9yKHJlcXVlc3QsIGV2ZW50KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWNoZVJlcXVlc3R9IHJlcXVlc3RJbiBUaGUgY2FjaGUgb24gd2hpY2ggdG8gcmVnaXN0ZXIgc3VjY2Vzc1xuICAgKiBAcGFyYW0ge1RvcGljfSB0b3BpYyBUaGUgdG9waWMgb24gd2hpY2ggdG8gaXNzdWUgdGhlIHJlcXVlc3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VzcyhyZXF1ZXN0SW4gLyosIHRvcGljICovKSB7XG4gICAgLy8gTnVsbCBvdXQgdGhpcyBmaWVsZCBhbmQgY2hlY2sgY29tcGxldGlvbiBzdGF0dXMuXG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RJbjtcbiAgICByZXF1ZXN0LnN1YnNjcmlwdGlvbldhaXRpbmcgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0Q2FjaGVSZXF1ZXN0KHJlcXVlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FjaGVSZXF1ZXN0fSByZXF1ZXN0IFRoZSBjYWNoZSByZXF1ZXN0IG9uIHdoaWNoIHRvIHJlZ2lzdGVyIGZhaWx1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVTdWJzY3JpcHRpb25FcnJvcihyZXF1ZXN0LyosIGV2ZW50ICovKSB7XG4gICAgdGhpcy5fdGVybWluYXRlUmVxdWVzdChyZXF1ZXN0LCBDYWNoZVJldHVybkNvZGUuRkFJTCwgQ2FjaGVSZXR1cm5TdWJjb2RlLlNVQlNDUklQVElPTl9FUlJPUik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWNoZVJlcXVlc3R9IHJlcXVlc3QgVGhlIGNhY2hlIHJlcXVlc3Qgb24gd2hpY2ggdG8gY2hlY2sgY29tcGxldGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrUmVxdWVzdENvbXBsZXRpb24ocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LmNoaWxkUmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICAvLyBOb3QgZmluaXNoZWQgd2l0aCBzcGF3bmVkIGNoaWxkIHJlcXVlc3RzLlxuICAgICAgTE9HX0RFQlVHKGBBd2FpdGluZyB0ZXJtaW5hdGlvbiBvZiAke3JlcXVlc3QuY2hpbGRSZXF1ZXN0cy5sZW5ndGh9IGNoaWxkcmVuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnN1YnNjcmlwdGlvbldhaXRpbmcpIHtcbiAgICAgIC8vIFdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbiBvZiBzdWJzY3JpcHRpb24gdG8gYSB0b3BpYy5cbiAgICAgIExPR19ERUJVRygnQXdhaXRpbmcgc3Vic2NyaXB0aW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnRpbWVvdXRIYW5kbGUgIT09IG51bGwgJiYgKCFyZXF1ZXN0LnJlcGx5UmVjZWl2ZWQpKSB7XG4gICAgICBMT0dfREVCVUcoJ0F3YWl0aW5nIHRpbWVvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QucGFyZW50UmVxdWVzdCkge1xuICAgICAgLy8gV2UncmUgbm8gbG9uZ2VyIHdhaXRpbmcgZm9yIGEgY2hpbGQgdG8gY29tcGxldGUuXG4gICAgICBjb25zdCBwYXJlbnQgPSByZXF1ZXN0LnBhcmVudFJlcXVlc3Q7XG4gICAgICByZXF1ZXN0LmNhbmNlbCgpO1xuICAgICAgdGhpcy5fdW5yZWdpc3RlclJlcXVlc3QocmVxdWVzdCk7XG4gICAgICB0aGlzLl9jaGVja1JlcXVlc3RDb21wbGV0aW9uKHBhcmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBhIHBhcmVudCByZXF1ZXN0IGFuZCBpdCBpcyBkb25lLlxuICAgIGxldCBjb2RlO1xuICAgIGxldCBzdWJjb2RlO1xuICAgIGlmIChyZXF1ZXN0LmlzU3VzcGVjdCkge1xuICAgICAgY29kZSA9IENhY2hlUmV0dXJuQ29kZS5JTkNPTVBMRVRFO1xuICAgICAgc3ViY29kZSA9IENhY2hlUmV0dXJuU3ViY29kZS5TVVNQRUNUX0RBVEE7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmRhdGFSZWNlaXZlZCkge1xuICAgICAgY29kZSA9IENhY2hlUmV0dXJuQ29kZS5PSztcbiAgICAgIGlmIChyZXF1ZXN0LmxpdmVEYXRhRnVsZmlsbGVkKSB7XG4gICAgICAgIHN1YmNvZGUgPSBDYWNoZVJldHVyblN1YmNvZGUuTElWRV9EQVRBX0ZVTEZJTEw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJjb2RlID0gQ2FjaGVSZXR1cm5TdWJjb2RlLlJFUVVFU1RfQ09NUExFVEU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlcGx5UmVjZWl2ZWQpIHtcbiAgICAgIGNvZGUgPSBDYWNoZVJldHVybkNvZGUuSU5DT01QTEVURTtcbiAgICAgIHN1YmNvZGUgPSBDYWNoZVJldHVyblN1YmNvZGUuTk9fREFUQTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYW5pdHk6IHNob3VsZCBuZXZlciBoYXBwZW4nKTtcbiAgICB9XG4gICAgdGhpcy5fdGVybWluYXRlUmVxdWVzdChyZXF1ZXN0LCBjb2RlLCBzdWJjb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcGFyZW50UmVxdWVzdCBUaGUgcGFyZW50IG5vZGUgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0NhY2hlR2V0UmVzdWx0fSBjYWNoZUdldFJlc3VsdCBUaGUgcmVzdWx0IG9mIHRoaXMgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmRTZWVPdGhlcihwYXJlbnRSZXF1ZXN0LCBjYWNoZUdldFJlc3VsdCkge1xuICAgIGNvbnN0IGNsdXN0ZXJOYW1lID0gY2FjaGVHZXRSZXN1bHQuY2x1c3Rlck5hbWVTdHJlYW0uZ2V0TmV4dCgpLmdldFZhbHVlKCk7XG4gICAgLy8gdmFyIHJvb3QgPSBwYXJlbnRSZXF1ZXN0LmdldFJvb3RSZXF1ZXN0KCk7XG4gICAgTE9HX0RFQlVHKGBTZWUgT3RoZXIgZm9yICR7Y2x1c3Rlck5hbWV9LiBTZW5kaW5nIGNoaWxkIHJlcXVlc3RgKTtcbiAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSBuZXcgQ2FjaGVSZXF1ZXN0KHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWNoZVJlcXVlc3RUeXBlLkdFVF9NU0dfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlcXVlc3QucmVxdWVzdElELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhY2hlQ0JJbmZvKG5vT3AsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVxdWVzdC5saXZlRGF0YUFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlcXVlc3QudG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyTmFtZSk7XG4gICAgLy8gQWRkIHRoaXMgcmVxdWVzdCB0byBpdHMgcGFyZW50XG4gICAgcGFyZW50UmVxdWVzdC5hZGRDaGlsZChjaGlsZFJlcXVlc3QpO1xuICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0XG4gICAgdGhpcy5fcmVnaXN0ZXJSZXF1ZXN0KGNoaWxkUmVxdWVzdCk7XG4gICAgY2hpbGRSZXF1ZXN0LnN0YXJ0UmVxdWVzdFRpbWVvdXQoQ2FjaGVTZXNzaW9uLl9oYW5kbGVDYWNoZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXMudGltZW91dE1zZWMpO1xuICAgIHRoaXMuX3N0YXJ0Q2FjaGVSZXF1ZXN0KGNoaWxkUmVxdWVzdCwgLy8gcmVxdWVzdCB0byBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgLy8gbm8gc2Vzc2lvbiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIC8vIG5vIHNwZWNpZmljIGluc3RhbmNlIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpOyAvLyBkb24ndCByZXR1cm4gb3RoZXIgY2x1c3RlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcGFyZW50UmVxdWVzdCBUaGUgcGFyZW50IG5vZGUgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0NhY2hlR2V0UmVzdWx0fSBjYWNoZUdldFJlc3VsdCBUaGUgcmVzdWx0IG9mIHRoaXMgcmVxdWVzdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmRHZXROZXh0KHBhcmVudFJlcXVlc3QsIGNhY2hlR2V0UmVzdWx0KSB7XG4gICAgTE9HX0RFQlVHKCdDYWNoZSByZXN1bHQgaGFzIG1vcmUsIHNlbmRpbmcgR0VUX05FWFRfTVNHX1JFUVVFU1QgYXMgY2hpbGQnKTtcbiAgICBjb25zdCBuZXh0UmVxdWVzdCA9IG5ldyBDYWNoZVJlcXVlc3QodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FjaGVSZXF1ZXN0VHlwZS5HRVRfTkVYVF9NU0dfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVxdWVzdC5yZXF1ZXN0SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDYWNoZUNCSW5mbyhub09wLCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVxdWVzdC5saXZlRGF0YUFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVxdWVzdC50b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UmVxdWVzdC5jYWNoZU5hbWUpO1xuICAgIC8vIFNldCB1cCBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwXG4gICAgcGFyZW50UmVxdWVzdC5hZGRDaGlsZChuZXh0UmVxdWVzdCk7XG4gICAgLy8gU3RhcnQgdGhlIHJlcXVlc3RcbiAgICB0aGlzLl9yZWdpc3RlclJlcXVlc3QobmV4dFJlcXVlc3QpO1xuICAgIG5leHRSZXF1ZXN0LnN0YXJ0UmVxdWVzdFRpbWVvdXQoQ2FjaGVTZXNzaW9uLl9oYW5kbGVDYWNoZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllcy50aW1lb3V0TXNlYyk7XG4gICAgdGhpcy5fc3RhcnRDYWNoZVJlcXVlc3QobmV4dFJlcXVlc3QsIC8vIHJlcXVlc3QgdG8gc2VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlR2V0UmVzdWx0LnNlc3Npb25JRCwgLy8gc3VwcGxpZWQgc2Vzc2lvbiBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlR2V0UmVzdWx0LnJlcGx5VG8pOyAvLyBzdXBwbGllZCBjYWNoZSBpbnN0YW5jZSB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaW5zcGVjdCBhbmQgaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXNzYWdlIGlzIGFzc29jaWF0ZWQgd2l0aCBvbmUgb2YgdGhpcyBzZXNzaW9uJ3MgcmVxdWVzdHNcbiAgICBjb25zdCBjb3JyZWxhdGlvbklEID0gbWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IGNvcnJlbGF0aW9uSUQgPT09IG51bGwgfHwgY29ycmVsYXRpb25JRCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG51bGxcbiAgICAgIDogdGhpcy5fb3V0c3RhbmRpbmdSZXF1ZXN0c1tjb3JyZWxhdGlvbklEXTtcblxuICAgIC8vIFRoaXMgY291bGQgYmUgbGl2ZSBkYXRhIG9uIGEgcmVsZXZhbnQgdG9waWMuICBDaGVjayB0aGF0LlxuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgaWYgKHRoaXMuX3JlbGV2YW50TGl2ZURhdGEobWVzc2FnZSkpIHtcbiAgICAgICAgdGhpcy5fc2VuZFRvTmV4dERlbGVnYXRlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEl0J3Mgb3VycyFcbiAgICBMT0dfREVCVUcoYFByb2Nlc3NpbmcgcmVwbHkgdG8gJHtyZXF1ZXN0fWApO1xuICAgIC8vIGJ1ZyAzNjQwNDogV2UgaGF2ZSBhIHJlc3BvbnNlLiBDYW5jZWwgdGhlIHRpbWVvdXQgZm9yIHRoaXMgcmVxdWVzdC5cbiAgICByZXF1ZXN0LmNsZWFyUmVxdWVzdFRpbWVvdXQoKTtcbiAgICBjb25zdCBzdHJlYW1GaWVsZCA9IG1lc3NhZ2UuZ2V0U2R0Q29udGFpbmVyKCk7XG4gICAgY29uc3Qgc3RyZWFtID0gc3RyZWFtRmllbGQgJiYgc3RyZWFtRmllbGQuZ2V0VmFsdWUoKTtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgTE9HX0lORk8oXG4gICAgICAgIGBJbnZhbGlkIG1lc3NhZ2UgZm9ybWF0IGZvciBjYWNoZSByZXNwb25zZTogbm8gU0RUIGNvbnRhaW5lciAoJHtcbiAgICAgICAgc3RyZWFtRmllbGR9KSBvciBzdHJlYW0gKCR7c3RyZWFtfSlgKTtcbiAgICAgIHRoaXMuX3Rlcm1pbmF0ZVJlcXVlc3QocmVxdWVzdCwgQ2FjaGVSZXR1cm5Db2RlLkZBSUwsIENhY2hlUmV0dXJuU3ViY29kZS5FUlJPUl9SRVNQT05TRSk7XG4gICAgfVxuICAgIC8vIFRoZSBzZXNzaW9uIHdpbGwgbmV2ZXIgc2VlIHRoaXMgcmVwbHksIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBzdGF0c1xuICAgIC8vIGZyb20gaGVyZS5cbiAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLlJYX1JFUExZX01TR19SRUNWRUQpO1xuICAgIHJlcXVlc3QucmVwbHlSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCB3YXMgZnVsZmlsbGVkIGJ5IGxpdmUgZGF0YSwgZGlzY2FyZCB0aGUgcmVwbHkgYW5kIHN0b3AgcHJvY2Vzc2luZ1xuICAgIC8vIHRoZSByZXNwb25zZS5cbiAgICBpZiAocmVxdWVzdC5nZXRSb290UmVxdWVzdCgpLmxpdmVEYXRhRnVsZmlsbGVkKSB7XG4gICAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLkNBQ0hFX1JFUVVFU1RfRlVMRklMTF9ESVNDQVJEX1JFU1BPTlNFKTtcbiAgICAgIHRoaXMuX2NoZWNrUmVxdWVzdENvbXBsZXRpb24ocmVxdWVzdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIExPR19JTkZPKCdJbnZhbGlkIGNhY2hlIHJlc3BvbnNlIGRpZCBub3QgZnVsZmlsbCByZXF1ZXN0LiBTa2lwcGluZyByZXNwb25zZSBwcm9jZXNzaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpbGwgdGhlIHJlc3VsdCBvYmplY3Qgd2l0aCB2YWx1ZXMgZnJvbSB0aGUgcmVzdWx0IHN0cmVhbS5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBDYWNoZUdldFJlc3VsdCgpO1xuICAgICAgcmVzdWx0LnJlYWRGcm9tU3RyZWFtKHN0cmVhbSk7XG4gICAgICByZXN1bHQucmVwbHlUbyA9IG1lc3NhZ2UuZ2V0UmVwbHlUbygpO1xuICAgICAgaWYgKHJlc3VsdC5yZXNwb25zZVN0cmluZykge1xuICAgICAgICBMT0dfREVCVUcoYENsdXN0ZXIgcmVzcG9uc2U6ICR7cmVzdWx0LnJlc3BvbnNlU3RyaW5nfWApO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgdGhlIGlzU3VzcGVjdCBmbGFnLiBEb24ndCBjbGVhciBpdCBpZiB0aGUgcmVzdWx0IGlzIGFscmVhZHkgc3VzcGVjdC5cbiAgICAgIHJlcXVlc3QuaXNTdXNwZWN0ID0gcmVxdWVzdC5pc1N1c3BlY3QgfHwgcmVzdWx0LmlzU3VzcGVjdDtcbiAgICAgIC8vIEdldCBhbnkgaW5uZXIgbWVzc2FnZXMuXG4gICAgICBjb25zdCBtZXNzYWdlcyA9IENhY2hlU2Vzc2lvbi5fZGVjb2RlTWVzc2FnZVN0cmVhbShyZXF1ZXN0LCByZXN1bHQpO1xuICAgICAgLy8gVXBkYXRlIHN0YXRpc3RpY3MuXG4gICAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLlJYX0NBQ0hFX01TRywgbWVzc2FnZXMubGVuZ3RoKTtcbiAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSByZXN1bHRzIHRvIGNvbWUsIHNlbmQgYSBnZXQgbmV4dCByZXF1ZXN0LlxuICAgICAgaWYgKHJlc3VsdC5oYXNNb3JlKSB7XG4gICAgICAgIHRoaXMuX3NlbmRHZXROZXh0KHJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgY2x1c3RlcnMgdG8gdmlzaXQsIHNlbmQgcmVxdWVzdHMgdG8gdGhvc2UgY2x1c3RlcnMuXG4gICAgICBpZiAocmVzdWx0LmNsdXN0ZXJOYW1lU3RyZWFtKSB7XG4gICAgICAgIExPR19ERUJVRygnUmVjZWl2aW5nIGNsdXN0ZXIgc3RyZWFtJyk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQuY2x1c3Rlck5hbWVTdHJlYW0uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgdGhpcy5fc2VuZFNlZU90aGVyKHJlcXVlc3QsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZvcndhcmQgYW55IHJldHJpZXZlZCBtZXNzYWdlcy5cbiAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZFRvTmV4dERlbGVnYXRlKG0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoZWNrUmVxdWVzdENvbXBsZXRpb24ocmVxdWVzdCk7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICBMT0dfSU5GTyhgSW52YWxpZCBtZXNzYWdlIGZvcm1hdCBmb3IgY2FjaGUgcmVzcG9uc2U6ICR7ZXhjZXB0aW9uLnN0YWNrfWApO1xuICAgICAgdGhpcy5fdGVybWluYXRlUmVxdWVzdChyZXF1ZXN0LCBDYWNoZVJldHVybkNvZGUuRkFJTCwgQ2FjaGVSZXR1cm5TdWJjb2RlLkVSUk9SX1JFU1BPTlNFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGluc3BlY3QgYW5kIGhhbmRsZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBuZXh0IGRlbGVnYXRlIHNob3VsZCBoYW5kbGUgdGhpcyBtZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVsZXZhbnRMaXZlRGF0YShtZXNzYWdlKSB7XG4gICAgLy8gSWYgdGhlIG5leHQgbWVzc2FnZSBwcm9jZXNzb3IgZG9lcyBub3QgYmVsb25nIHRvIGEgY2FjaGVcbiAgICAvLyBzZXNzaW9uLCBhbmQgdGhpcyBpcyBhIENSUSBtZXNzYWdlLCBzdXBwcmVzcyBpdC5cbiAgICBpZiAobWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCkgJiZcbiAgICAgICAgbWVzc2FnZS5nZXRDb3JyZWxhdGlvbklkKCkuc3RhcnRzV2l0aChDQUNIRV9SRVFVRVNUX1BSRUZJWCkgJiZcbiAgICAgICAgISh0aGlzLl9uZXh0TWVzc2FnZUNhbGxiYWNrSW5mby51c2VyT2JqZWN0IGluc3RhbmNlb2YgQ2FjaGVTZXNzaW9uKSkge1xuICAgICAgTE9HX1dBUk4oJ0RST1A6IERyb3BwaW5nIENSUSByZXBseSBkdWUgdG8gbm8gcmVtYWluaW5nIENhY2hlIFNlc3Npb24gcHJvY2Vzc29ycyBvbiBtZXNzYWdlICcgK1xuICAgICAgICAgICAgICAgJ2NhbGxiYWNrIGNoYWluJyk7XG4gICAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLlJYX1JFUExZX01TR19ESVNDQVJEKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgdGhlIG1lc3NhZ2Ugc2hvdWxkIGZsb3cgdGhyb3VnaC5cbiAgICAvLyBJZiBhbGwgX3BlcmZvcm1MaXZlRGF0YUFjdGlvbiBjYWxscyByZXR1cm4gdHJ1ZSwgd2UgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHMpLmV2ZXJ5KGNoZWNrQ0lEID0+XG4gICAgICB0aGlzLl9wZXJmb3JtTGl2ZURhdGFBY3Rpb24odGhpcy5fb3V0c3RhbmRpbmdSZXF1ZXN0c1tjaGVja0NJRF0sIG1lc3NhZ2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcmVxdWVzdEluIFRoZSBjYWNoZSByZXF1ZXN0IGZvciB3aGljaCB0byBwZXJmb3JtIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHByb2Nlc3Mgb24gdGhlIHJlcXVlc3RcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgbWVzc2FnZSBzaG91bGQgZmxvdyB0aHJvdWdoIGFmdGVyIGFjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtTGl2ZURhdGFBY3Rpb24ocmVxdWVzdEluLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RJbjtcbiAgICByZXF1ZXN0LmRhdGFSZWNlaXZlZCA9IHRydWU7XG4gICAgc3dpdGNoIChyZXF1ZXN0LmxpdmVEYXRhQWN0aW9uKSB7XG4gICAgICBjYXNlIENhY2hlTGl2ZURhdGFBY3Rpb24uUVVFVUU6XG4gICAgICAgIHJlcXVlc3QucXVldWVkTGl2ZURhdGEucHVzaChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIENhY2hlTGl2ZURhdGFBY3Rpb24uRlVMRklMTDpcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmxpdmVEYXRhRnVsZmlsbGVkKSB7XG4gICAgICAgICAgdGhpcy5fZnVsZmlsbFJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcmVxdWVzdEluIFRoZSByZXF1ZXN0IHRvIGZ1bGZpbGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9mdWxmaWxsUmVxdWVzdChyZXF1ZXN0SW4pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdEluO1xuICAgIHJlcXVlc3QubGl2ZURhdGFGdWxmaWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RyYWNrQ29tcGxldGlvblN0YXRzKENhY2hlUmV0dXJuQ29kZS5PSywgQ2FjaGVSZXR1cm5TdWJjb2RlLkxJVkVfREFUQV9GVUxGSUxMKTtcbiAgICAvLyBXZSBoYXZlIG1vcmUgd29yayB0byBkbyBoZXJlIC0tIHdlIG5lZWQgdG8gcmV0dXJuIHRoZSBsaXZlIGRhdGEgZmlyc3QuXG4gICAgLy8gU2NoZWR1bGUgdGhlIG5vdGlmaWNhdGlvbiBmb3IgbGF0ZXIuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBDYWNoZVNlc3Npb24uX25vdGlmeUNhbGxiYWNrKHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlUmV0dXJuQ29kZS5PSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FjaGVSZXR1cm5TdWJjb2RlLkxJVkVfREFUQV9GVUxGSUxMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmdldFRvcGljKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSBzZXNzaW9uLiAgTm8gY2FjaGUgcmVxdWVzdHMgd2lsbCBiZSBzZW50IGJ5IHRoaXMgQ2FjaGVTZXNzaW9uIGFmdGVyIGl0IGlzXG4gICAqIF9kaXNwb3NlZC5cbiAgICpcbiAgICogQW55IHN1YnNlcXVlbnQgb3BlcmF0aW9ucyBvbiB0aGUgc2Vzc2lvbiB3aWxsIHRocm93IHtPcGVyYXRpb25FcnJvcn0uXG4gICAqXG4gICAqIEFueSBwZW5kaW5nIG9wZXJhdGlvbnMgd2lsbCBpbW1lZGlhdGVseSB0ZXJtaW5hdGUsIHJldHVybmluZ1xuICAgKiAgICoge0BsaW5rIHNvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHR9XG4gICAqICAgICAqICNyZXR1cm5Db2RlID09PSB7QGxpbmsgc29sYWNlLkNhY2hlUmV0dXJuQ29kZS5JTkNPTVBMRVRFfVxuICAgKiAgICAgKiAjc3ViY29kZSA9PT0ge0BsaW5rIHNvbGFjZS5DYWNoZVJldHVyblN1YmNvZGUuQ0FDSEVfU0VTU0lPTl9ESVNQT1NFRH1cbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBpZiB0aGUgQ2FjaGVTZXNzaW9uIGlzIGFscmVhZHkgX2Rpc3Bvc2VkLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICBjb25zdCB0b1Rlcm1pbmF0ZSA9IE9iamVjdC5rZXlzKHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHMpXG4gICAgICAubWFwKGNvcnJlbGF0aW9uSUQgPT4gdGhpcy5fb3V0c3RhbmRpbmdSZXF1ZXN0c1tjb3JyZWxhdGlvbklEXSlcbiAgICAgIC5maWx0ZXIocmVxdWVzdCA9PiByZXF1ZXN0IGluc3RhbmNlb2YgQ2FjaGVSZXF1ZXN0KTtcbiAgICB0b1Rlcm1pbmF0ZS5mb3JFYWNoKChyZXF1ZXN0KSA9PiB7XG4gICAgICB0aGlzLl90ZXJtaW5hdGVSZXF1ZXN0KHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlUmV0dXJuQ29kZS5JTkNPTVBMRVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWNoZVJldHVyblN1YmNvZGUuQ0FDSEVfU0VTU0lPTl9ESVNQT1NFRCk7XG4gICAgfSk7XG4gICAgdGhpcy5fb3V0c3RhbmRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgdGhpcy5fc2Vzc2lvbi5zZXRFdmVudENCSW5mbyh0aGlzLl9uZXh0U2Vzc2lvbkV2ZW50Q2FsbGJhY2tJbmZvKTtcbiAgICB0aGlzLl9zZXNzaW9uLnNldE1lc3NhZ2VDQkluZm8odGhpcy5fbmV4dE1lc3NhZ2VDYWxsYmFja0luZm8pO1xuICAgIC8vIFNldCBfZGlzcG9zZWRcbiAgICB0aGlzLl9kaXNwb3NlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY2FjaGUgc2Vzc2lvbiBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXN9IFRoZSBwcm9wZXJ0aWVzIGZvciB0aGUgc2Vzc2lvbi5cbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBpZiB0aGUgQ2FjaGVTZXNzaW9uIGlzIGRpc3Bvc2VkLlxuICAgKi9cbiAgZ2V0UHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYW4gYXN5bmNocm9ub3VzIGNhY2hlIHJlcXVlc3QuIFRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3Qgd2lsbCBiZSByZXR1cm5lZCB2aWEgdGhlXG4gICAqIGxpc3RlbmVyLiBNZXNzYWdlcyByZXR1cm5lZCBhcyBhIHJlc3VsdCBvZiBpc3N1aW5nIHRoZSByZXF1ZXN0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlXG4gICAqIGFwcGxpY2F0aW9uIHZpYSB0aGUge0BsaW5rIHNvbGFjZS5NZXNzYWdlUnhDQkluZm99IGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAqIHtAbGluayBzb2xhY2UuQ2FjaGVTZXNzaW9ufSdzIHtAbGluayBzb2xhY2UuU2Vzc2lvbn1cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcXVlc3RJRCBUaGUgYXBwbGljYXRpb24tYXNzaWduZWQgSUQgbnVtYmVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzb2xhY2UuRGVzdGluYXRpb259IHRvcGljIFRoZSB0b3BpYyBkZXN0aW5hdGlvbiBmb3Igd2hpY2ggdGhlIGNhY2hlIHJlcXVlc3Qgd2lsbCBiZVxuICAgKiAgICBtYWRlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnNjcmliZSBJZiB0cnVlLCB0aGUgc2Vzc2lvbiB3aWxsIHN1YnNjcmliZSB0byB0aGUgZ2l2ZW4ge1RvcGljfSwgaWYgaXQgaXNcbiAgICogbm90IGFscmVhZHkgc3Vic2NyaWJlZCwgYmVmb3JlIHBlcmZvcm1pbmcgdGhlIGNhY2hlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c29sYWNlLkNhY2hlTGl2ZURhdGFBY3Rpb259IGxpdmVEYXRhQWN0aW9uIFRoZSBhY3Rpb24gdG8gcGVyZm9ybSB3aGVuIHRoZVxuICAgKiAgICB7QGxpbmsgc29sYWNlLkNhY2hlU2Vzc2lvbn0gcmVjZWl2ZXMgbGl2ZSBkYXRhIG9uIHRoZSBnaXZlbiB0b3BpYy5cbiAgICogQHBhcmFtIHtzb2xhY2UuQ2FjaGVDQkluZm99IGNiSW5mbyBDYWxsYmFjayBpbmZvIGZvciB0aGUgY2FjaGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHRocm93cyB7c29sYWNlLk9wZXJhdGlvbkVycm9yfSBJbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgKiAqIElmIHRoZSBDYWNoZVNlc3Npb24gaXMgZGlzcG9zZWQuXG4gICAqICAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLklOVkFMSURfT1BFUkFUSU9OfVxuICAgKiAqIElmIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMgd2VyZSBpbnZhbGlkLlxuICAgKiAgICBTdWJjb2RlOiB7QGxpbmsgc29sYWNlLkVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFfVxuICAgKiAqIElmIHRoZSBzdXBwbGllZCB0b3BpYyBhbmQgbGl2ZSBkYXRhIGFjdGlvbiBjYW5ub3QgYmUgY29tYmluZWQuXG4gICAqICAgIFN1YmNvZGU6IHtAbGluayBzb2xhY2UuRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVH1cbiAgICogKiBJZiB0aGUgc3VwcGxpZWQgdG9waWMgb3IgbGl2ZSBkYXRhIGFjdGlvbiBjYW5ub3QgYmUgdXNlZCBnaXZlbiB0aGUgY3VycmVudCBvdXRzdGFuZGluZ1xuICAgKiAgICByZXF1ZXN0cy5cbiAgICogICAgU3ViY29kZToge0BsaW5rIHNvbGFjZS5FcnJvclN1YmNvZGUuUEFSQU1FVEVSX0NPTkZMSUNUfVxuICAgKi9cbiAgc2VuZENhY2hlUmVxdWVzdChyZXF1ZXN0SUQsIHRvcGljLCBzdWJzY3JpYmUsIGxpdmVEYXRhQWN0aW9uLCBjYkluZm8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBzZW5kQ2FjaGVSZXF1ZXN0KCkgaW52b2tlZCB3aXRoIGFuIGlsbGVnYWwgYXJndW1lbnQgY291bnQgb2YgJHtcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpYmUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCBzdWJzY3JpYmUgZmxhZyBhcmd1bWVudCwgc2hvdWxkIGJlIGEgYm9vbGVhbiBidXQgd2FzICR7dHlwZW9mIHN1YnNjcmliZX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SUQgIT09ICdudW1iZXInIHx8IE51bWJlci5pc05hTihyZXF1ZXN0SUQpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0ludmFsaWQgcmVxdWVzdElEJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsIG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3V0c3RhbmRpbmdJRHNbcmVxdWVzdElEXSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3Mgd2l0aCB0aGlzIHJlcXVlc3RJRCcpO1xuICAgIH1cbiAgICBpZiAoISh0b3BpYyBpbnN0YW5jZW9mIERlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdJbnZhbGlkIHRvcGljJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsICh0eXBlb2YgdG9waWMpKTtcbiAgICB9XG4gICAgdG9waWMudmFsaWRhdGUoKTtcbiAgICBpZiAoIShsaXZlRGF0YUFjdGlvbiA9PT0gQ2FjaGVMaXZlRGF0YUFjdGlvbi5GTE9XX1RIUlUgfHwgbGl2ZURhdGFBY3Rpb24gPT09XG4gICAgICAgIENhY2hlTGl2ZURhdGFBY3Rpb24uRlVMRklMTCB8fCBsaXZlRGF0YUFjdGlvbiA9PT0gQ2FjaGVMaXZlRGF0YUFjdGlvbi5RVUVVRSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCBsaXZlIGRhdGEgYWN0aW9uJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgIH1cbiAgICBpZiAodG9waWMuaXNXaWxkY2FyZGVkKCkgJiYgbGl2ZURhdGFBY3Rpb24gIT09IENhY2hlTGl2ZURhdGFBY3Rpb24uRkxPV19USFJVKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ1dpbGRjYXJkZWQgdG9waWMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBsaXZlIGRhdGEgYWN0aW9uJyxcbiAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9DT05GTElDVCk7XG4gICAgfVxuICAgIGlmICghKGNiSW5mbyBpbnN0YW5jZW9mIENhY2hlQ0JJbmZvKSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdDYWxsYmFjayBpbmZvIHdhcyBub3QgYW4gaW5zdGFuY2Ugb2YgQ2FjaGVDQkluZm8nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSB7XG4gICAgICBDYWNoZVNlc3Npb24uX25vdGlmeUNhbGxiYWNrRXJyb3IoY2JJbmZvLCByZXF1ZXN0SUQsIENhY2hlUmV0dXJuQ29kZS5GQUlMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlUmV0dXJuU3ViY29kZS5DQUNIRV9TRVNTSU9OX0RJU1BPU0VELCB0b3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2FjaGUgcmVxdWVzdCBmYWlsZWQ6IHRoZSBjYWNoZSBzZXNzaW9uIGlzIGRpc3Bvc2VkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2Vzc2lvbi5fZGlzcG9zZWQpIHtcbiAgICAgIENhY2hlU2Vzc2lvbi5fbm90aWZ5Q2FsbGJhY2tFcnJvcihjYkluZm8sIHJlcXVlc3RJRCwgQ2FjaGVSZXR1cm5Db2RlLkZBSUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FjaGVSZXR1cm5TdWJjb2RlLklOVkFMSURfU0VTU0lPTiwgdG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NhY2hlIHJlcXVlc3QgZmFpbGVkOiB0aGUgc2Vzc2lvbiBpcyBkaXNwb3NlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IENhY2hlUmVxdWVzdCh0aGlzLFxuICAgICAgQ2FjaGVSZXF1ZXN0VHlwZS5HRVRfTVNHX1JFUVVFU1QsXG4gICAgICByZXF1ZXN0SUQsXG4gICAgICBjYkluZm8sXG4gICAgICBsaXZlRGF0YUFjdGlvbixcbiAgICAgIHRvcGljLFxuICAgICAgdGhpcy5fcHJvcGVydGllcy5jYWNoZU5hbWUpO1xuXG4gICAgY29uc3QgbWF0Y2hpbmdSZXF1ZXN0S2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHMpLmZpbHRlcihrZXkgPT5cbiAgICAgIHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHNba2V5XS50b3BpYy5nZXROYW1lKCkgPT09IHRvcGljLmdldE5hbWUoKSk7XG5cbiAgICBpZiAobWF0Y2hpbmdSZXF1ZXN0S2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIFRvcGljIG5hbWUgbWF0Y2hlcyBtZWFuIGEgY29uZmxpY3QgdW5sZXNzIGJvdGggcmVxdWVzdHMgYXJlIEZMT1dfVEhSVVxuICAgICAgY29uc3QgY29uZmxpY3RLZXlzID0gKFxuICAgICAgICBsaXZlRGF0YUFjdGlvbiAhPT0gQ2FjaGVMaXZlRGF0YUFjdGlvbi5GTE9XX1RIUlVcbiAgICAgICAgICA/IG1hdGNoaW5nUmVxdWVzdEtleXNcbiAgICAgICAgICA6IG1hdGNoaW5nUmVxdWVzdEtleXMuZmlsdGVyKGsgPT5cbiAgICAgICAgICAgIHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHNba10ubGl2ZURhdGFBY3Rpb24gIT09IENhY2hlTGl2ZURhdGFBY3Rpb24uRkxPV19USFJVKSk7XG4gICAgICBpZiAoY29uZmxpY3RLZXlzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjb25mbGljdFJlcXVlc3QgPSB0aGlzLl9vdXRzdGFuZGluZ1JlcXVlc3RzW2NvbmZsaWN0S2V5c1swXV07XG4gICAgICAgIExPR19XQVJOKGBFeGlzdGluZyByZXF1ZXN0ICR7Y29uZmxpY3RSZXF1ZXN0fSBjb25mbGljdHMuIFJlamVjdGluZyByZXF1ZXN0ICR7cmVxdWVzdH1gKTtcbiAgICAgICAgIC8vIFJlZ2lzdGVyIHRoaXMgcmVxdWVzdCBzbyB0aGF0IGl0IGlzIG5vdCBkaXNtaXNzZWQgYXMgYW4gb3JwaGFuLlxuICAgICAgICB0aGlzLl9yZWdpc3RlclJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVJlcXVlc3QocmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWNoZVJldHVybkNvZGUuRkFJTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYWNoZVJldHVyblN1YmNvZGUuUkVRVUVTVF9BTFJFQURZX0lOX1BST0dSRVNTKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3JlZ2lzdGVyUmVxdWVzdChyZXF1ZXN0KTtcbiAgICByZXF1ZXN0LnN0YXJ0UmVxdWVzdFRpbWVvdXQoQ2FjaGVTZXNzaW9uLl9oYW5kbGVDYWNoZVJlcXVlc3RUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLnRpbWVvdXRNc2VjKTtcbiAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICBjb25zdCB3YWl0aW5nRm9yU3Vic2NyaWJlSW5mbyA9IG5ldyBDYWNoZVNlc3Npb25TdWJzY3JpYmVJbmZvKHJlcXVlc3QuY29ycmVsYXRpb25JRCwgdG9waWMsXG4gICAgICAgIHRoaXMpO1xuICAgICAgcmVxdWVzdC5fc3Vic2NyaXB0aW9uV2FpdGluZyA9IHdhaXRpbmdGb3JTdWJzY3JpYmVJbmZvO1xuICAgICAgdGhpcy5fc2Vzc2lvbi5zdWJzY3JpYmUodG9waWMsIHRydWUsIHdhaXRpbmdGb3JTdWJzY3JpYmVJbmZvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRDYWNoZVJlcXVlc3QocmVxdWVzdCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzb2xhY2UuU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtTZXNzaW9uRXZlbnR9IHNlc3Npb25FdmVudCBUaGUgc2Vzc2lvbiBldmVudFxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gdXNlck9iamVjdCBUaGUgdXNlci1zcGVjaWZpZWQgY29udGV4dCBvYmplY3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVDYWNoZVJlcXVlc3RGYWlsZWQoc2Vzc2lvbiwgc2Vzc2lvbkV2ZW50LCB1c2VyT2JqZWN0IC8qLCByZnVPYmplY3QgKi8pIHtcbiAgICB0aGlzLl90ZXJtaW5hdGVSZXF1ZXN0KHVzZXJPYmplY3QuZ2V0UmVxdWVzdElEKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBDYWNoZVJldHVybkNvZGUuRkFJTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIENhY2hlUmV0dXJuU3ViY29kZS5FUlJPUl9SRVNQT05TRSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWNoZVJlcXVlc3R9IHJlcXVlc3QgVGhlIG5ldyByZXF1ZXN0IHRvIHJlZ2lzdGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVnaXN0ZXJSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICB0aGlzLl9vdXRzdGFuZGluZ1JlcXVlc3RzW3JlcXVlc3QuY29ycmVsYXRpb25JRF0gPSByZXF1ZXN0O1xuICAgIGlmICghcmVxdWVzdC5wYXJlbnRSZXF1ZXN0KSB7XG4gICAgICB0aGlzLl9vdXRzdGFuZGluZ0lEc1tyZXF1ZXN0LnJlcXVlc3RJRF0gPSByZXF1ZXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29ycmVsYXRpb25JRCBUaGUgSUQgb2YgYW4gZXhpc3RpbmcgcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7Q2FjaGVSZXF1ZXN0fSBUaGUgZXhpc3RpbmcgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBJRFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE91dHN0YW5kaW5nUmVxdWVzdChjb3JyZWxhdGlvbklEKSB7XG4gICAgcmV0dXJuIHRoaXMuX291dHN0YW5kaW5nUmVxdWVzdHNbY29ycmVsYXRpb25JRF07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYWNoZVJlcXVlc3R9IHJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gc3RhcnRcbiAgICogQHBhcmFtIHs/TnVtYmVyfSBzZXNzaW9uSUQgT25seSB3aGVuIHJldHVybmVkIGZyb20gYSBjYWNoZSBpbnN0YW5jZSBhcyBwYXJ0IG9mIGFcbiAgICogcHJldmlvdXMgbWVzc2FnZVxuICAgKiBAcGFyYW0gez9Ub3BpY30gZGVzdGluYXRpb24gT25seSB3aGVuIHJlcXVpcmVkIGJ5IGEgY2FjaGUgcmVwbHlcbiAgICogQHBhcmFtIHs/Qm9vbGVhbn0gc3VwcHJlc3NDbHVzdGVycyBUcnVlIHdoZW4gb3RoZXIgY2x1c3RlcnMgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb21cbiAgICogdGhlIHJlc3BvbnNlLCBhcyBpbiBhIHJlcXVlc3QgcmVzdWx0aW5nIGZyb20gYSBcInNlZSBvdGhlclwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhcnRDYWNoZVJlcXVlc3QocmVxdWVzdCwgc2Vzc2lvbklELCBkZXN0aW5hdGlvbiwgc3VwcHJlc3NDbHVzdGVycykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZUxpYi5NZXNzYWdlKCk7XG5cbiAgICAvLyBQcmVwYXJlIG1lc3NhZ2VcbiAgICBtZXNzYWdlLnNldENvcnJlbGF0aW9uSWQocmVxdWVzdC5jb3JyZWxhdGlvbklEKTtcbiAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgIG1lc3NhZ2Uuc2V0RGVzdGluYXRpb24oZGVzdGluYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnNldERlc3RpbmF0aW9uKFxuICAgICAgICBUb3BpYy5jcmVhdGVGcm9tTmFtZSh0aGlzLl9wcm9wZXJ0aWVzLmNhY2hlUHJlZml4ICsgcmVxdWVzdC5jYWNoZU5hbWUpKTtcbiAgICB9XG4gICAgbWVzc2FnZS5zZXRSZXBseVRvKFRvcGljLmNyZWF0ZUZyb21OYW1lKHRoaXMuX3Nlc3Npb24uZ2V0U2Vzc2lvblByb3BlcnRpZXMoKS5wMnBJbmJveEluVXNlKSk7XG4gICAgbWVzc2FnZS5zZXREZWxpdmVyVG9PbmUocmVxdWVzdC5jYWNoZU1lc3NhZ2VUeXBlID09PSBDYWNoZVJlcXVlc3RUeXBlLkdFVF9NU0dfUkVRVUVTVCk7XG5cbiAgICAvLyBQcmVwYXJlIHN0cmVhbSBjb250YWluZXJcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgU0RUU3RyZWFtQ29udGFpbmVyKCk7XG4gICAgc3RyZWFtLmFkZEZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMzIsIHJlcXVlc3QuY2FjaGVNZXNzYWdlVHlwZSk7XG4gICAgc3RyZWFtLmFkZEZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMzIsIENhY2hlUmVxdWVzdC5WRVJTSU9OKTtcbiAgICBzdHJlYW0uYWRkRmllbGQoU0RURmllbGRUeXBlLlNUUklORywgcmVxdWVzdC50b3BpYy5nZXROYW1lKCkpO1xuICAgIHN0cmVhbS5hZGRGaWVsZChTRFRGaWVsZFR5cGUuVUlOVDMyLCBDYWNoZVJlcXVlc3QuUkVQTFlfU0laRV9MSU1JVCk7XG5cbiAgICBpZiAodHlwZW9mIHNlc3Npb25JRCA9PT0gJ251bWJlcicpIHtcbiAgICAgIExPR19ERUJVRyhgSW5jbHVkaW5nIHNlc3Npb24gSUQ6ICR7c2Vzc2lvbklEfWApO1xuICAgICAgc3RyZWFtLmFkZEZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMzIsIHNlc3Npb25JRCk7XG4gICAgfVxuXG4gICAgc3RyZWFtLmFkZEZpZWxkKFNEVEZpZWxkVHlwZS5VSU5UMzIsIHRoaXMuX3Byb3BlcnRpZXMubWF4TWVzc2FnZXMpO1xuICAgIHN0cmVhbS5hZGRGaWVsZChTRFRGaWVsZFR5cGUuVUlOVDMyLCB0aGlzLl9wcm9wZXJ0aWVzLm1heEFnZVNlYyk7XG4gICAgaWYgKHJlcXVlc3QuY2FjaGVNZXNzYWdlVHlwZSA9PT0gQ2FjaGVSZXF1ZXN0VHlwZS5HRVRfTVNHX1JFUVVFU1QpIHtcbiAgICAgIHN0cmVhbS5hZGRGaWVsZChTRFRGaWVsZFR5cGUuQk9PTCxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzLmluY2x1ZGVPdGhlckNsdXN0ZXJzICYmICghc3VwcHJlc3NDbHVzdGVycykpO1xuICAgIH1cblxuICAgIHN0cmVhbS5hZGRGaWVsZChTRFRGaWVsZFR5cGUuQk9PTCwgZmFsc2UpOyAvLyBpbmNsdWRlVGltZXN0YW1wcywgNi4xNy4xXG4gICAgaWYgKHJlcXVlc3QuY2FjaGVNZXNzYWdlVHlwZSA9PT0gQ2FjaGVSZXF1ZXN0VHlwZS5HRVRfTVNHX1JFUVVFU1QpIHtcbiAgICAgIHN0cmVhbS5hZGRGaWVsZChTRFRGaWVsZFR5cGUuVUlOVDMyLCBNYXRoLnJvdW5kKHRoaXMuX3Byb3BlcnRpZXMudGltZW91dE1zZWMgLyAxMDAwKSk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCBzdHJlYW0gY29udGFpbmVyXG4gICAgbWVzc2FnZS5zZXRTZHRDb250YWluZXIoU0RURmllbGQuY3JlYXRlKFNEVEZpZWxkVHlwZS5TVFJFQU0sIHN0cmVhbSkpO1xuICAgIHRyeSB7XG4gICAgICBMT0dfREVCVUcoYFNlbmRpbmcgJHtyZXF1ZXN0fWApO1xuICAgICAgdGhpcy5fc2Vzc2lvbi5zZW5kKG1lc3NhZ2UpO1xuXG4gICAgICBpZiAoIXJlcXVlc3QucGFyZW50UmVxdWVzdCkgeyAvLyBEb24ndCBjb3VudCBjaGlsZCByZXF1ZXN0cyBpbiBDQUNIRV9SRVFVRVNUX1NFTlQgdG90YWxcbiAgICAgICAgdGhpcy5faW5jU3RhdChTdGF0VHlwZS5DQUNIRV9SRVFVRVNUX1NFTlQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExPR19JTkZPKGBGYWlsZWQgdG8gc2VuZCByZXF1ZXN0OiAke2UubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMuX3Rlcm1pbmF0ZVJlcXVlc3QocmVxdWVzdCwgQ2FjaGVSZXR1cm5Db2RlLkZBSUwsIENhY2hlUmV0dXJuU3ViY29kZS5FUlJPUl9SRVNQT05TRSwgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYSBzdGF0LlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHN0YXRUeXBlIFRoZSBzdGF0IHRvIGluY3JlbWVudFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlICAgIFRoZSBhbW91bnQgYnkgd2hpY2ggdG8gaW5jcmVtZW50IHRoZSBzdGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luY1N0YXQoc3RhdFR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLl9zZXNzaW9uKSB7XG4gICAgICBMT0dfREVCVUcoXCJDYW4ndCBsb2cgc3RhdDogc2Vzc2lvbiBpcyBkaXNwb3NlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zZXNzaW9uSUYpIHtcbiAgICAgIExPR19JTkZPKFwiQ2FuJ3QgbG9nIHN0YXQ6IHNlc3Npb24gc3RhdGlzdGljcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXNzaW9uSUYuaW5jU3RhdChzdGF0VHlwZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiByZXF1ZXN0LlxuICAgKiBAcGFyYW0gIHtDYWNoZVJlcXVlc3R9IHJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gdW5yZWd1c3RlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VucmVnaXN0ZXJSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBkZWxldGUgdGhpcy5fb3V0c3RhbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmNvcnJlbGF0aW9uSURdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRzdGFuZGluZ0lEc1tyZXF1ZXN0LnJlcXVlc3RJRF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYWNoZVJldHVybkNvZGV9IHJldHVybkNvZGUgVGhlIHJldHVybiBjb2RlIGZvciB0aGlzIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtDYWNoZVJldHVyblN1YmNvZGV9IHN1YmNvZGUgVGhlIHN1YmNvZGUgZm9yIHRoaXMgY29tcGxldGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYWNrQ29tcGxldGlvblN0YXRzKHJldHVybkNvZGUsIHN1YmNvZGUpIHtcbiAgICBzd2l0Y2ggKHJldHVybkNvZGUpIHtcbiAgICAgIGNhc2UgQ2FjaGVSZXR1cm5Db2RlLk9LOlxuICAgICAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLkNBQ0hFX1JFUVVFU1RfT0tfUkVTUE9OU0UpO1xuICAgICAgICBpZiAoc3ViY29kZSA9PT0gQ2FjaGVSZXR1cm5TdWJjb2RlLkxJVkVfREFUQV9GVUxGSUxMKSB7XG4gICAgICAgICAgdGhpcy5faW5jU3RhdChTdGF0VHlwZS5DQUNIRV9SRVFVRVNUX0xJVkVfREFUQV9GVUxGSUxMKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2FjaGVSZXR1cm5Db2RlLklOQ09NUExFVEU6XG4gICAgICAgIHRoaXMuX2luY1N0YXQoU3RhdFR5cGUuQ0FDSEVfUkVRVUVTVF9JTkNPTVBMRVRFX1JFU1BPTlNFKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENhY2hlUmV0dXJuQ29kZS5GQUlMOlxuICAgICAgICB0aGlzLl9pbmNTdGF0KFN0YXRUeXBlLkNBQ0hFX1JFUVVFU1RfRkFJTF9SRVNQT05TRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYW5pdHk6IG5vIHJldHVybiBjb2RlIHN1cHBsaWVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FjaGVSZXF1ZXN0fSByZXF1ZXN0SW4gVGhlIHJlcXVlc3QgdG8gdGVybWluYXRlXG4gICAqIEBwYXJhbSB7Q2FjaGVSZXR1cm5Db2RlfSByZXR1cm5Db2RlIFRoZSByZXR1cm4gY29kZSBmb3IgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtDYWNoZVJldHVyblN1YmNvZGV9IHN1YmNvZGUgVGhlIHN1YmNvZGUgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIEFueSBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBvcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90ZXJtaW5hdGVSZXF1ZXN0KHJlcXVlc3RJbiwgcmV0dXJuQ29kZSwgc3ViY29kZSwgZXJyb3IpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdEluLmdldFJvb3RSZXF1ZXN0KCk7XG4gICAgaWYgKCF0aGlzLl9vdXRzdGFuZGluZ1JlcXVlc3RzW3JlcXVlc3QuY29ycmVsYXRpb25JRF0pIHtcbiAgICAgIC8vIFJlcXVlc3QgaXMgdW5rbm93biBvciB3YXMgcHJldmlvdXNseSB0ZXJtaW5hdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNiSW5mbyA9IHJlcXVlc3QuY2JJbmZvO1xuICAgIGlmICghY2JJbmZvKSB7XG4gICAgICBMT0dfV0FSTihgTm8gY2FsbGJhY2sgaW5mbyBwcm92aWRlZCBmb3IgJHtyZXF1ZXN0fS4gQ2Fubm90IG5vdGlmeWApO1xuICAgICAgcmV0dXJuOyAvLyBDYW5ub3QgY29udGludWVcbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2sgPSBjYkluZm8uZ2V0Q2FsbGJhY2soKTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICBMT0dfV0FSTihgTm8gY2FsbGJhY2sgcHJvdmlkZWQgZm9yICR7cmVxdWVzdH0uIENhbm5vdCBub3RpZnlgKTtcbiAgICAgIHJldHVybjsgLy8gQ2Fubm90IGNvbnRpbnVlXG4gICAgfVxuICAgIGNvbnN0IHRvcGljID0gcmVxdWVzdC5nZXRUb3BpYygpO1xuICAgIGlmICghdG9waWMpIHtcbiAgICAgIExPR19XQVJOKGBObyB0b3BpYyBwcm92aWRlZCBmb3IgJHtyZXF1ZXN0fWApO1xuICAgIH1cbiAgICByZXF1ZXN0LnF1ZXVlZExpdmVEYXRhLmZvckVhY2goZGF0YSA9PiB0aGlzLl9zZW5kVG9OZXh0RGVsZWdhdGUoZGF0YSkpO1xuXG4gICAgLy8gVW5yZWdpc3RlciBiZWZvcmUgY2FsbGJhY2sgc28gdGhhdCB0aGUgY2xpZW50IGFwcGxpY2F0aW9uIGNhbiB0cmVhdCB0aGUgcmVxdWVzdCBJRFxuICAgIC8vIGFzIFwiZnJlZWRcIiBhbmQgcmV1c2UgaXRcbiAgICByZXF1ZXN0LmNhbmNlbCgpO1xuICAgIHRoaXMuX3VucmVnaXN0ZXJSZXF1ZXN0KHJlcXVlc3QpO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmxpdmVEYXRhRnVsZmlsbGVkKSB7XG4gICAgICAvLyBBbGwgb2YgdGhpcyBoYXMgYWxyZWFkeSBiZWVuIGRvbmUgb24gZnVsZmlsbC5cbiAgICAgIHRoaXMuX3RyYWNrQ29tcGxldGlvblN0YXRzKHJldHVybkNvZGUsIHN1YmNvZGUpO1xuICAgICAgQ2FjaGVTZXNzaW9uLl9ub3RpZnlDYWxsYmFjayhyZXF1ZXN0LCByZXR1cm5Db2RlLCBzdWJjb2RlLCB0b3BpYywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcmVxdWVzdEluIFRoZSByZXF1ZXN0IHdpdGggYSByZXN1bHQgdG8gZGVjb2RlXG4gICAqIEBwYXJhbSB7Q2FjaGVHZXRSZXN1bHR9IHJlc3VsdCBUaGUgcmVzdWx0IHRvIGRlY29kZVxuICAgKiBAcmV0dXJucyB7QXJyYXkuPE1lc3NhZ2U+fSBUaGUgbWVzc2FnZXMgY29udGFpbmVkIGluIHRoZSByZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfZGVjb2RlTWVzc2FnZVN0cmVhbShyZXF1ZXN0SW4sIHJlc3VsdCkge1xuICAgIGlmICghcmVzdWx0Lm1lc3NhZ2VTdHJlYW0pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ1JlY2VpdmluZyBtZXNzYWdlcycpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RJbjtcbiAgICB3aGlsZSAocmVzdWx0Lm1lc3NhZ2VTdHJlYW0uaGFzTmV4dCgpKSB7XG4gICAgICByZXF1ZXN0LmRhdGFSZWNlaXZlZCA9IHRydWU7XG4gICAgICBjb25zdCBkYXRhID0gcmVzdWx0Lm1lc3NhZ2VTdHJlYW0uZ2V0TmV4dCgpLmdldFZhbHVlKCk7XG4gICAgICBjb25zdCBpbm5lck1lc3NhZ2UgPSBTTUZMaWIuQ29kZWMuRGVjb2RlLmRlY29kZUNvbXBvdW5kTWVzc2FnZShkYXRhLCAwKTtcbiAgICAgIGlmICghaW5uZXJNZXNzYWdlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVTdGF0dXMgPSByZXN1bHQuaXNTdXNwZWN0XG4gICAgICAgID8gTWVzc2FnZUxpYi5NZXNzYWdlQ2FjaGVTdGF0dXMuU1VTUEVDVFxuICAgICAgICA6IE1lc3NhZ2VMaWIuTWVzc2FnZUNhY2hlU3RhdHVzLkNBQ0hFRDtcbiAgICAgIGlubmVyTWVzc2FnZS5fc2V0Q2FjaGVTdGF0dXMoY2FjaGVTdGF0dXMpO1xuICAgICAgaW5uZXJNZXNzYWdlLl9zZXRDYWNoZVJlcXVlc3RJRChyZXF1ZXN0LnJlcXVlc3RJRCk7XG4gICAgICBtZXNzYWdlcy5wdXNoKGlubmVyTWVzc2FnZSk7XG4gICAgfVxuICAgIExPR19ERUJVRyhgJHttZXNzYWdlcy5sZW5ndGh9IGNhY2hlZCBtZXNzYWdlcyByZWNlaXZlZGApO1xuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zdXJlIGNhbGwgY29udGV4dDsgYHRoaXNgIHdpbGwgYmUgcmVkZWZpbmVkXG4gICAqIEBwYXJhbSB7Q2FjaGVSZXF1ZXN0fSBjYWNoZVJlcXVlc3QgVGhlIHJlcXVlc3QgdGhhdCB0aW1lZCBvdXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfaGFuZGxlQ2FjaGVSZXF1ZXN0VGltZW91dChjYWNoZVJlcXVlc3QpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FjaGVSZXF1ZXN0LmNhY2hlU2Vzc2lvbjtcbiAgICBpZiAoIWNvbnRleHQuX2dldE91dHN0YW5kaW5nUmVxdWVzdChjYWNoZVJlcXVlc3QuY29ycmVsYXRpb25JRCkpIHtcbiAgICAgIExPR19JTkZPKGBUaW1lb3V0IGZvciAke2NhY2hlUmVxdWVzdH0gd2FzIG5vdCB1bnJlZ2lzdGVyZWQuIElnbm9yaW5nYCk7XG4gICAgICAvLyBhbHJlYWR5IGNvbXBsZXRlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJ1ZyAzNjQwNDogQ2FjaGUgcmVxdWVzdCB0aW1lb3V0IGlzIHRvIGJlIGludGVycHJldGVkIGFzIHRpbWVvdXQgcGVyIHNlc3Npb24gcmVxdWVzdC1yZXBseSxcbiAgICAvLyBub3QgdGltZW91dCBwZXIgY2FjaGUgcmVxdWVzdC1yZXBseS5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbjogVGltZW91dHMgb24gcGFyZW50IHJlcXVlc3RzIGFyZSBjYW5jZWxsZWQgd2hlbiBhIGNoaWxkIHJlcXVlc3QgaXMgc3Bhd25lZC5cbiAgICAvLyBUaW1lb3V0cyBvbiBjaGlsZCByZXF1ZXN0cyBjYXVzZSB0aGUgcm9vdCByZXF1ZXN0IHRvIGZhaWwuXG4gICAgTE9HX0lORk8oYFJlcXVlc3QgJHtjYWNoZVJlcXVlc3R9IHRpbWVkIG91dGApO1xuICAgIGNvbnRleHQuX3Rlcm1pbmF0ZVJlcXVlc3QoY2FjaGVSZXF1ZXN0LmdldFJvb3RSZXF1ZXN0KCksIENhY2hlUmV0dXJuQ29kZS5JTkNPTVBMRVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FjaGVSZXR1cm5TdWJjb2RlLlJFUVVFU1RfVElNRU9VVCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhY2hlUmVxdWVzdH0gcmVxdWVzdCBUaGUgcmVxdWVzdCB0aGF0IGlzIG5vdGlmeWluZ1xuICAgKiBAcGFyYW0ge0NhY2hlUmV0dXJuQ29kZX0gcmV0dXJuQ29kZSBUaGUgcmV0dXJuIGNvZGUgZm9yIHRoZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIHtDYWNoZVJldHVyblN1YmNvZGV9IHN1YmNvZGUgVGhlIHN1YmNvZGUgZm9yIHRoZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIHtEZXN0aW5hdGlvbn0gdG9waWMgVGhlIHRvcGljIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm90aWZpY2F0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIEFueSBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vdGlmaWNhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9ub3RpZnlDYWxsYmFjayhyZXF1ZXN0LCByZXR1cm5Db2RlLCBzdWJjb2RlLCB0b3BpYywgZXJyb3IpIHtcbiAgICBjb25zdCBjYkluZm8gPSByZXF1ZXN0LmNiSW5mbztcbiAgICBjb25zdCBjYWxsYmFjayA9IGNiSW5mby5nZXRDYWxsYmFjaygpO1xuICAgIGNhbGxiYWNrKHJlcXVlc3QucmVxdWVzdElELFxuICAgICAgICAgICAgIG5ldyBDYWNoZVJlcXVlc3RSZXN1bHQocmV0dXJuQ29kZSwgc3ViY29kZSwgdG9waWMsIGVycm9yKSxcbiAgICAgICAgICAgICBjYkluZm8uZ2V0VXNlck9iamVjdCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3NvbGFjZS5DYWNoZUNCSW5mb30gY2JJbmZvIENhbGxiYWNrIGluZm8gZm9yIHRoZSBjYWNoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gcmVxdWVzdElEIFRoZSBhcHBsaWNhdGlvbi1hc3NpZ25lZCBJRCBudW1iZXIgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7Q2FjaGVSZXR1cm5Db2RlfSByZXR1cm5Db2RlIFRoZSByZXR1cm4gY29kZSBmb3IgdGhlIG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0ge0NhY2hlUmV0dXJuU3ViY29kZX0gc3ViY29kZSBUaGUgc3ViY29kZSBmb3IgdGhlIG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0ge0Rlc3RpbmF0aW9ufSB0b3BpYyBUaGUgdG9waWMgYXNzb2NpYXRlZCB3aXRoIHRoZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgQW55IGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm90aWZpY2F0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX25vdGlmeUNhbGxiYWNrRXJyb3IoY2JJbmZvLCByZXF1ZXN0SUQsIHJldHVybkNvZGUsIHN1YmNvZGUsIHRvcGljLCBlcnJvcikge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2JJbmZvLmdldENhbGxiYWNrKCk7XG4gICAgY2FsbGJhY2socmVxdWVzdElELFxuICAgICAgICAgICAgIG5ldyBDYWNoZVJlcXVlc3RSZXN1bHQocmV0dXJuQ29kZSwgc3ViY29kZSwgdG9waWMsIGVycm9yKSxcbiAgICAgICAgICAgICBjYkluZm8uZ2V0VXNlck9iamVjdCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGNhY2hlIHNlc3Npb24gcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllc30gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gdmFsaWRhdGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBfdmFsaWRhdGVQcm9wcyhwcm9wcykge1xuICAgIGlmICgodHlwZW9mIChwcm9wcy5jYWNoZU5hbWUpICE9PSAnc3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgdHlwZSBmb3IgY2FjaGVOYW1lJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgZnJvbSBuYW1lIHdpbGwgdGhyb3cgaWYgdGhlIGNhY2hlTmFtZSBpcyBpbnZhbGlkLiAgVGhpcyBwZXJmb3JtcyBtb3JlIGNoZWNraW5nIHRoYW5cbiAgICAvLyB0aGUgbGVnYWN5IEFQSSBkaWQsIGJ1dCBJIHRoaW5rIGl0IGlzIGFsbCBqdXN0aWZpZWQgYXMgd2Ugc2hvdWxkbid0IGJlIGFibGUgdG8gdXNlIGFueXRoaW5nXG4gICAgLy8gdGhhdCB3b3VsZCBiZSByZWplY3RlZCBoZXJlIGFzIGEgY2FjaGVOYW1lLlxuICAgIGlmIChUb3BpYy5jcmVhdGVGcm9tTmFtZShwcm9wcy5jYWNoZU5hbWUpLmlzV2lsZGNhcmRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGNhY2hlTmFtZSAnJHtwcm9wcy5jYWNoZU5hbWV9Jy4gVGhlIGNhY2hlTmFtZSBjYW5ub3QgYmUgd2lsZGNhcmRlZGAsXG4gICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgKHByb3BzLm1heEFnZVNlYykgIT09ICdudW1iZXInKSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciB0eXBlIGZvciBtYXhBZ2VTZWMnLCBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tYXhBZ2VTZWMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIG1heEFnZVNlYzsgbXVzdCBiZSA+PSAwJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiAocHJvcHMubWF4TWVzc2FnZXMpICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCBwYXJhbWV0ZXIgdHlwZSBmb3IgbWF4TWVzc2FnZXMnLCBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tYXhNZXNzYWdlcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgbWF4TWVzc2FnZXM7IG11c3QgYmUgPj0gMCcsIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgKHByb3BzLnRpbWVvdXRNc2VjKSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyIHR5cGUgZm9yIHRpbWVvdXRNc2VjJywgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGltZW91dE1zZWMgPCAzMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHRpbWVvdXRNc2VjOyBtdXN0IGJlID49IDMwMDAnLCBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuQ2FjaGVTZXNzaW9uID0gQ2FjaGVTZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc29sY2FjaGUtc2Vzc2lvbi9saWIvY2FjaGUtc2Vzc2lvbi5qcyIsImNvbnN0IHsgU3RhdFR5cGUgfSA9IHJlcXVpcmUoJy4vc3RhdC10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3RhdHNCeU1vZGU6IHtcbiAgICBTVEFUX1RYX0JZTU9ERV9NU0dTOiBbXG4gICAgICBTdGF0VHlwZS5UWF9ESVJFQ1RfTVNHUyxcbiAgICAgIFN0YXRUeXBlLlRYX1BFUlNJU1RFTlRfTVNHUyxcbiAgICAgIFN0YXRUeXBlLlRYX05PTlBFUlNJU1RFTlRfTVNHUyxcbiAgICBdLFxuICAgIFNUQVRfVFhfQllNT0RFX0JZVEVTOiBbXG4gICAgICBTdGF0VHlwZS5UWF9ESVJFQ1RfQllURVMsXG4gICAgICBTdGF0VHlwZS5UWF9QRVJTSVNURU5UX0JZVEVTLFxuICAgICAgU3RhdFR5cGUuVFhfTk9OUEVSU0lTVEVOVF9CWVRFUyxcbiAgICBdLFxuICAgIFNUQVRfVFhfQllNT0RFX1JFREVMSVZFUkVEOiBbXG4gICAgICBTdGF0VHlwZS5UWF9ESVJFQ1RfTVNHUywgICAgIC8vIHVudXNlZCBwbGFjZWhvbGRlciwgZGlyZWN0IG1lc3NzYWdlcyBhcmUgbm90IHJlZGVsaXZlcmVkXG4gICAgICBTdGF0VHlwZS5UWF9QRVJTSVNURU5UX1JFREVMSVZFUkVELFxuICAgICAgU3RhdFR5cGUuVFhfTk9OUEVSU0lTVEVOVF9SRURFTElWRVJFRCxcbiAgICBdLFxuICAgIFNUQVRfVFhfQllNT0RFX0JZVEVTX1JFREVMSVZFUkVEOiBbXG4gICAgICBTdGF0VHlwZS5UWF9ESVJFQ1RfQllURVMsICAgICAvLyB1bnVzZWQgcGxhY2Vob2xkZXIsIGRpcmVjdCBtZXNzc2FnZXMgYXJlIG5vdCByZWRlbGl2ZXJlZFxuICAgICAgU3RhdFR5cGUuVFhfUEVSU0lTVEVOVF9CWVRFU19SRURFTElWRVJFRCxcbiAgICAgIFN0YXRUeXBlLlRYX05PTlBFUlNJU1RFTlRfQllURVNfUkVERUxJVkVSRUQsXG4gICAgXSxcbiAgICBTVEFUX1JYX0JZTU9ERV9NU0dTOiBbXG4gICAgICBTdGF0VHlwZS5SWF9ESVJFQ1RfTVNHUyxcbiAgICAgIFN0YXRUeXBlLlJYX1BFUlNJU1RFTlRfTVNHUyxcbiAgICAgIFN0YXRUeXBlLlJYX05PTlBFUlNJU1RFTlRfTVNHUyxcbiAgICBdLFxuICAgIFNUQVRfUlhfQllNT0RFX0JZVEVTOiBbXG4gICAgICBTdGF0VHlwZS5SWF9ESVJFQ1RfQllURVMsXG4gICAgICBTdGF0VHlwZS5SWF9QRVJTSVNURU5UX0JZVEVTLFxuICAgICAgU3RhdFR5cGUuUlhfTk9OUEVSU0lTVEVOVF9CWVRFUyxcbiAgICBdLFxuICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXN0YXRzL2xpYi9zdGF0LWJ5bW9kZS5qcyIsImNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXZlbnRzJyk7XG5jb25zdCB7IFN0YXRUeXBlIH0gPSByZXF1aXJlKCcuL3N0YXQtdHlwZXMnKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0cyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fc3RhdHNNYXAgPSBbXTtcbiAgICBTdGF0VHlwZS52YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIHRoaXMuX3N0YXRzTWFwW3ZhbHVlXSA9IDA7XG4gICAgfSk7XG4gIH1cblxuICByZXNldFN0YXRzKCkge1xuICAgIHRoaXMuZW1pdCgncmVzZXQnKTtcbiAgICAvLyBUaGUgc3RhdCB0eXBlcyBhcmUgc2VxdWVudGlhbCwgc28gLmZpbGwoMCkgd291bGQgd29yaywgYnV0IHRoZSBBUEkgZGVzaWduXG4gICAgLy8gZG9lc24ndCByZWFsbHkgZ3VhcmFudGVlIHRoaXMgc28gb3ZlcndyaXRpbmcgZXZlcnkgZXhpc3RpbmcgaW5kZXggaXMgc2FmZXIuXG4gICAgdGhpcy5fc3RhdHNNYXAgPSB0aGlzLl9zdGF0c01hcC5tYXAoKCkgPT4gMCk7XG4gIH1cblxuICBpbmNTdGF0KHN0YXRUeXBlLCB2YWx1ZSA9IDEpIHtcbiAgICAvLyBzaG91bGQgd2UgdmFsaWRhdGUgc3RhdFR5cGU/XG4gICAgdGhpcy5fc3RhdHNNYXBbc3RhdFR5cGVdICs9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5pbmNTdGF0KHN0YXRUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdChzdGF0VHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0c01hcFtzdGF0VHlwZV07XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5TdGF0cyA9IFN0YXRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtc3RhdHMvbGliL3N0YXRzLmpzIiwiXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbmNvbnN0IEJ1ZmZlckltcGwgPSBCdWZmZXIgfHwgcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZSkge1xuICAvKiBlc2xpbnQtZW52IHNoYXJlZC1icm93c2VyLW5vZGUgKi9cbiAgaWYgKEJ1ZmZlckltcGwuYWxsb2NVbnNhZmUpIHJldHVybiBCdWZmZXJJbXBsLmFsbG9jVW5zYWZlKHNpemUpO1xuICBpZiAoQnVmZmVySW1wbC5hbGxvYykgcmV0dXJuIEJ1ZmZlckltcGwuYWxsb2Moc2l6ZSk7XG4gIHJldHVybiBuZXcgQnVmZmVySW1wbChzaXplKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQnVmZmVyRGF0YVF1ZXVlIHtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSkge1xuICAgIGNvbnN0IF9idWZmZXIgPSBuZXdCdWZmZXIobWF4U2l6ZSk7XG4gICAgbGV0IF9wb3NpdGlvbiA9IDA7XG4gICAgbGV0IF9yZW1haW5pbmcgPSAwO1xuXG4gICAgLy8gRnVuY3Rpb25zIHRoYXQgZGlyZWN0bHkgYWNjZXNzIHRoZSBidWZmZXIgYXJlIGRlY2xhcmVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAvLyBUaGlzIHJlbW92ZXMgX2J1ZmZlciBmcm9tIGluc3BlY3Rpb24gc2NvcGUgYW5kIGxldHMgdGhlIGNsYXNzIGJlIGRlYnVnZ2FibGUuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2UgKHZpZXcpIG9mIHRoZSBidWZmZXIgd2l0aCB0aGUgZ2l2ZW4gc2l6ZS4gSWYgdGhlIHJlYWRcbiAgICAgKiBvdmVybGFwcyB0aGUgZW5kIG9mIHRoZSBidWZmZXIsIHRoZSBidWZmZXIgaXMgY29tcGFjdGVkLCBpbnZhbGlkYXRpbmdcbiAgICAgKiBhbGwgcHJldmlvdXMgcGVla1ZpZXdzLlxuICAgICAqXG4gICAgICogQ29udGVudHMgb2Ygdmlld3Mgc2hvdWxkIGJlIGNvcGllZCBieSB0aGUgY2FsbGVyIGlmIHRoZXkgYXJlIHRvIGJlIHJldGFpbmVkLFxuICAgICAqIGJlZm9yZSBhbnkgb3RoZXIgYnVmZmVyIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBCeXRlcyB0byB2aWV3XG4gICAgICogQHJldHVybnMgez9CdWZmZXJ9IGlmIHRoZXJlIHdhcyBlbm91Z2ggZGF0YSB0byBwZWVrLCBvciBgbnVsbGBcbiAgICAgKi9cbiAgICB0aGlzLnBlZWtWaWV3ID0gZnVuY3Rpb24gcGVla1ZpZXcoc2l6ZSkge1xuICAgICAgaWYgKHNpemUgPiBfcmVtYWluaW5nKSB7IHJldHVybiBudWxsOyB9XG4gICAgICBpZiAoX3Bvc2l0aW9uICsgc2l6ZSA+IG1heFNpemUpIHsgdGhpcy5jb21wYWN0KCk7IH1cbiAgICAgIGNvbnN0IGxpbmVhckVuZCA9IF9wb3NpdGlvbiArIHNpemU7XG4gICAgICByZXR1cm4gX2J1ZmZlci5zbGljZShfcG9zaXRpb24sIGxpbmVhckVuZCk7XG4gICAgfTtcblxuICAgIHRoaXMuYWR2YW5jZSA9IGZ1bmN0aW9uIGFkdmFuY2Uoc2l6ZSkge1xuICAgICAgX3JlbWFpbmluZyAtPSBzaXplO1xuICAgICAgX3Bvc2l0aW9uICs9IHNpemU7XG4gICAgfTtcblxuICAgIHRoaXMucmVtYWluaW5nID0gZnVuY3Rpb24gcmVtYWluaW5nKCkge1xuICAgICAgcmV0dXJuIF9yZW1haW5pbmc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1dHMgYnl0ZXMgZnJvbSBhIHNvdXJjZSBidWZmZXIgaW50byB0aGUgaW50ZXJuYWwgYnVmZmVyLiAgQ29tcGFjdHMgdGhlIGJ1ZmZlclxuICAgICAqIGlmIG5lZWRlZC4gIFJldHVybnMgaWYgdGhlIG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bC4gIHB1dCgpIHdpbGwgZmFpbCBpZiB0aGVcbiAgICAgKiBpbnRlcm5hbCBidWZmZXIgKGFmdGVyIGNvbXBhY3Rpb24pIGRvZXMgbm90IGhhdmUgc3BhY2UgdG8gaG9sZCB0aGUgc291cmNlXG4gICAgICogYnVmZmVyLlxuICAgICAqXG4gICAgICogVGhpcyBvcGVyYXRpb24gY2FuIGludmFsaWRhdGUgcHJldmlvdXMgdmlld3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YUluIFNvdXJjZSBkYXRhXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhbGwgYnl0ZXMgd2VyZSBpbnNlcnRlZFxuICAgICAqL1xuICAgIHRoaXMucHV0ID0gZnVuY3Rpb24gcHV0KGRhdGFJbikge1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyRGF0YVF1ZXVlLmFkYXB0RGF0YShkYXRhSW4pO1xuICAgICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAgIGlmIChfcmVtYWluaW5nICsgc2l6ZSA+PSBtYXhTaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoX3Bvc2l0aW9uICsgX3JlbWFpbmluZyArIHNpemUgPj0gbWF4U2l6ZSkgeyB0aGlzLmNvbXBhY3QoKTsgfVxuXG4gICAgICBidWZmZXIuY29weShfYnVmZmVyLCBfcG9zaXRpb24gKyBfcmVtYWluaW5nKTtcbiAgICAgIF9yZW1haW5pbmcgKz0gc2l6ZTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgX3Bvc2l0aW9uID0gMDtcbiAgICAgIF9yZW1haW5pbmcgPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIHJlbWFpbmluZyBkYXRhIHNvIHRoYXQgaXQgaXMgYWxpZ25lZCBhdCB6ZXJvLlxuICAgICAqL1xuICAgIHRoaXMuY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QoKSB7XG4gICAgICBfYnVmZmVyLmNvcHkoX2J1ZmZlciwgMCwgX3Bvc2l0aW9uLCBfcG9zaXRpb24gKyBfcmVtYWluaW5nKTtcbiAgICAgIF9wb3NpdGlvbiA9IDA7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZWVrcyBhIHNwZWNpZmllZCBsZW5ndGggYW5kIGZvcm1hdHMgaXQgYXMgYSBzdHJpbmcuIFRoaXMgb3BlcmF0aW9uIGNhbiBpbnZhbGlkYXRlXG4gICAqIHByZXZpb3VzIHZpZXdzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHBlZWtcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz0nYmluYXJ5J10gVGhlIGVuY29kaW5nIGZvciB0aGUgc3RyaW5nIHRvIGJlIHJldHVybmVkXG4gICAqIEByZXR1cm5zIHs/U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmdcbiAgICovXG4gIHBlZWtTdHJpbmcoc2l6ZSwgZW5jb2RpbmcgPSAnYmluYXJ5Jykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucGVla1ZpZXcoc2l6ZSk7XG4gICAgcmV0dXJuIHRhcmdldCA/IHRhcmdldC50b1N0cmluZyhlbmNvZGluZykgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzbGljZSAodmlldykgb2YgdGhlIGJ1ZmZlciB3aXRoIHRoZSBnaXZlbiBzaXplLiBJZiB0aGUgcmVhZFxuICAgKiBvdmVybGFwcyB0aGUgZW5kIG9mIHRoZSBidWZmZXIsIHRoZSBidWZmZXIgaXMgY29tcGFjdGVkLCBpbnZhbGlkYXRpbmdcbiAgICogYWxsIHByZXZpb3VzIHBlZWtWaWV3cy4gVGhlIGJ5dGVzIGFyZSBjb25zdW1lZC5cbiAgICpcbiAgICogQ29udGVudHMgb2Ygdmlld3Mgc2hvdWxkIGJlIGNvcGllZCBieSB0aGUgY2FsbGVyIGlmIHRoZXkgYXJlIHRvIGJlIHJldGFpbmVkLFxuICAgKiBiZWZvcmUgYW55IG90aGVyIGJ1ZmZlciBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZSBCeXRlcyB0byBjb3B5XG4gICAqIEByZXR1cm5zIHs/QnVmZmVyfSBpZiB0aGVyZSB3YXMgZW5vdWdoIGRhdGEgdG8gcGVlaywgb3IgYG51bGxgXG4gICAqL1xuICBnZXRWaWV3KHNpemUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnBlZWtWaWV3KHNpemUpO1xuICAgIGlmICh0YXJnZXQpIHRoaXMuYWR2YW5jZShzaXplKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzcGVjaWZpZWQgbGVuZ3RoIGFuZCBmb3JtYXRzIGl0IGFzIGEgc3RyaW5nLiBUaGlzIG9wZXJhdGlvbiBjYW4gaW52YWxpZGF0ZVxuICAgKiBwcmV2aW91cyB2aWV3cy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9J2JpbmFyeSddIFRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyB0byBiZSByZXR1cm5lZFxuICAgKiBAcmV0dXJucyB7P1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nIGlmIHRoZXJlIHdhcyBlbm91Z2ggZGF0YSB0byBjb25zdW1lciwgb3IgYG51bGxgXG4gICAqL1xuICBnZXRTdHJpbmcoc2l6ZSwgZW5jb2RpbmcgPSAnYmluYXJ5Jykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0VmlldyhzaXplKTtcbiAgICByZXR1cm4gdGFyZ2V0ID8gdGFyZ2V0LnRvU3RyaW5nKGVuY29kaW5nKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWRhcHQgaW5jb21pbmcgZGF0YSB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoaXMucHV0KCkuXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgZGF0YSB0byBhZGFwdC5cbiAgICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGFkYXB0ZWQgZGF0YS5cbiAgICovXG4gIHN0YXRpYyBhZGFwdERhdGEoZGF0YSkge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gZGF0YTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQnVmZmVyRGF0YVF1ZXVlID0gQnVmZmVyRGF0YVF1ZXVlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi9idWZmZXItZGF0YS1xdWV1ZS5qcyIsImNvbnN0IERlYnVnTGliID0gcmVxdWlyZSgnc29sY2xpZW50LWRlYnVnJyk7XG5jb25zdCBTTUZMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5jb25zdCB7IEJhc2VTTUZDbGllbnQgfSA9IHJlcXVpcmUoJy4vYmFzZS1zbWYtY2xpZW50Jyk7XG5jb25zdCB7IEJ1ZmZlckRhdGFRdWV1ZSB9ID0gcmVxdWlyZSgnLi9idWZmZXItZGF0YS1xdWV1ZScpO1xuY29uc3QgeyBDb252ZXJ0LCBIZXggfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IExvZ0Zvcm1hdHRlciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuXG5jb25zdCB7IHN0cmluZ1RvVWludDhBcnJheSB9ID0gQ29udmVydDtcbmNvbnN0IHsgZm9ybWF0SGV4U3RyaW5nIH0gPSBIZXg7XG5cbmNvbnN0IFNNRl9MT1NUX0ZSQU1JTkdfVEhSRVNIT0xEID0gODAwMDAwMDA7XG5cbmNvbnN0IHsgTE9HX1RSQUNFLFxuICAgICAgICBMT0dfRVJST1IgfSA9IG5ldyBMb2dGb3JtYXR0ZXIoJ1tidWZmZXItc21mLWNsaWVudF0nKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhlc2UgZnVuY3Rpb25zIHByb3Blcmx5IGJlbG9uZyBpbiBhIGJpbmFyeSBTTUYgZGVjb2RlciBwYWNrYWdlXG4vLyB2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXJidWZmZXIocmluZ2J1ZmZlcikge1xuICBpZiAocmluZ2J1ZmZlci5yZW1haW5pbmcoKSA8IDEyKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHJpbmdidWZmZXIucGVla1ZpZXcoMTIpO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRlcmJ1ZmZlclZhbGlkKGhlYWRlcmJ1ZmZlcikge1xuICBjb25zdCB2ZXJzaW9uID0gaGVhZGVyYnVmZmVyWzBdICYgMHg3O1xuICBpZiAodmVyc2lvbiAhPT0gMykge1xuICAgIExPR19FUlJPUihgSW52YWxpZCBzbWYgdmVyc2lvbiBpbiBzbWYgaGVhZGVyLCB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cblxuZnVuY3Rpb24gbWFrZU1lc3NhZ2VidWZmZXIoaGVhZGVyYnVmZmVyLCByaW5nYnVmZmVyKSB7XG4gIGNvbnN0IG1lc3NhZ2VMZW4gPSBoZWFkZXJidWZmZXIucmVhZFVJbnQzMkJFKDgpO1xuICBjb25zdCByZW1haW5pbmcgPSByaW5nYnVmZmVyLnJlbWFpbmluZygpO1xuICBpZiAobWVzc2FnZUxlbiA+IHJlbWFpbmluZykgcmV0dXJuIG51bGw7XG4gIHJldHVybiByaW5nYnVmZmVyLnBlZWtWaWV3KG1lc3NhZ2VMZW4pO1xufVxuXG5mdW5jdGlvbiBsb2dQZWVrQnVmZmVyKGJ1ZmZlcikge1xuICBMT0dfRVJST1IoYEZpcnN0IDY0IGJ5dGVzIChvciBmZXdlcikgb2YgaW5jb21pbmcgYnVmZmVyOiBcXG4ke1xuICAgIERlYnVnTGliLkRlYnVnLmZvcm1hdER1bXBCeXRlcyhidWZmZXIucGVla1N0cmluZyhNYXRoLm1pbihidWZmZXIucmVtYWluaW5nKCksIDY0KSksIHRydWUsIDApfWApO1xufVxuXG4vKipcbiAqIEludGVyYWN0IHdpdGggdW5kZXJseWluZyB0cmFuc3BvcnQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBTTUYgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEJ1ZmZlclNNRkNsaWVudCBleHRlbmRzIEJhc2VTTUZDbGllbnQge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcnhTbWZDQiBUaGUgY2FsbGJhY2sgdG8gbm90aWZ5IG9uIFNNRiBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByeE1lc3NhZ2VFcnJvckNCIFRoZSBjYWxsYmFjayB0byBub3RpZnkgb24gbWVzc2FnZSBlcnJvcnNcbiAgICogQHBhcmFtIHtTZXNzaW9ufSBzZXNzaW9uIFRoZSBzZXNzaW9uIG93bmluZyB0aGlzIGNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3IocnhTbWZDQiwgcnhNZXNzYWdlRXJyb3JDQiwgc2Vzc2lvbikge1xuICAgIHN1cGVyKHJ4U21mQ0IsIHJ4TWVzc2FnZUVycm9yQ0IsIHNlc3Npb24pO1xuICAgIHRoaXMuX2luY29taW5nQnVmZmVyID0gbmV3IEJ1ZmZlckRhdGFRdWV1ZShTTUZfTE9TVF9GUkFNSU5HX1RIUkVTSE9MRCk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIC8vIENhbGxlZCBmcm9tIHN1cGVyIGNvbnN0cnVjdG9yLCBzbyBndWFyZCB0aGlzXG4gICAgaWYgKHRoaXMuX2luY29taW5nQnVmZmVyKSB0aGlzLl9pbmNvbWluZ0J1ZmZlci5yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIEluY29taW5nIGRhdGEgYXMgYmluYXJ5IHN0cmluZ1xuICAgKi9cbiAgcnhEYXRhU3RyaW5nKGRhdGEpIHtcbiAgICB0aGlzLl9yeERhdGFDQihCdWZmZXIuZnJvbShzdHJpbmdUb1VpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhIEluY29taW5nIGRhdGFcbiAgICovXG4gIHJ4RGF0YUFycmF5QnVmZmVyKGRhdGEpIHtcbiAgICB0aGlzLl9yeERhdGFDQihCdWZmZXIuZnJvbShkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgSW5jb21pbmcgZGF0YVxuICAgKi9cbiAgcnhEYXRhQnVmZmVyKGRhdGEpIHtcbiAgICB0aGlzLl9yeERhdGFDQihkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IHRyYW5zcG9ydCBzZXNzaW9uLiBIYW5kbGVzIG11bHRpcGxlIFNNRiBtZXNzYWdlcyBpbiBpbnB1dCwgYXMgd2VsbCBhcyBkZWZyYWdtZW50aW5nXG4gICAqIHBhcnRpYWwgU01GIG1lc3NhZ2VzLiBUaGUgc3RhdGUgd2Uga2VlcCBpcyBpbiB0aGlzLl9pbmNvbWluZ0J1ZmZlci5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGJpbmFyeSBkYXRhIHRvIGRlY29kZVxuICAgKi9cbiAgX3J4RGF0YUNCKGRhdGEpIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmNvbWluZ0J1ZmZlcjtcbiAgICBpZiAodGhpcy5fc2Vzc2lvbikge1xuICAgICAgTE9HX1RSQUNFKCdSZXNldCBLZWVwQWxpdmVDb3VudGVyJyk7XG4gICAgICAvLyBlYWNoIGluY29taW5nIGRhdGEgY2h1bmsgcmVzZXRzIEtBIGNvdW50ZXJcbiAgICAgIHRoaXMuX3Nlc3Npb24ucmVzZXRLZWVwQWxpdmVDb3VudGVyKCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGluY29taW5nIGRhdGEgdG8gdGhlIGJ1ZmZlci4gSW4gbm9kZSwgdGhpcyBpcyBvbmx5IG9uZSBjb3B5OlxuICAgIC8vIHdyYXBwaW5nIEFycmF5QnVmZmVyIGluIEJ1ZmZlciBjcmVhdGVzIGEgdmlldyBvZiB0aGUgdW5kZXJseWluZyBhbGxvY2F0aW9uLlxuICAgIGNvbnN0IHB1dFN1Y2Nlc3MgPSBidWZmZXIucHV0KGRhdGEpO1xuICAgIGxldCByZW1haW5pbmcgPSBidWZmZXIucmVtYWluaW5nKCk7XG5cbiAgICBpZiAoIXB1dFN1Y2Nlc3MpIHtcbiAgICAgIC8vIDgwIG1lZ2FieXRlcyAtIGxvc3QgU01GIGZyYW1pbmc6IG1heSBuZXZlciBjb21wbGV0ZVxuICAgICAgbG9nUGVla0J1ZmZlcihidWZmZXIpO1xuICAgICAgdGhpcy5fcnhNZXNzYWdlRXJyb3JDQihgQnVmZmVyIG92ZXJmbG93IChsZW5ndGg6ICR7cmVtYWluaW5nfSlgKTtcbiAgICAgIHRoaXMuX2luY29taW5nQnVmZmVyLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRlcmJ1ZmZlcjtcbiAgICB3aGlsZSAocmVtYWluaW5nID4gMCkge1xuICAgICAgaGVhZGVyYnVmZmVyID0gbWFrZUhlYWRlcmJ1ZmZlcihidWZmZXIpO1xuICAgICAgaWYgKCFoZWFkZXJidWZmZXIpIGJyZWFrOyAvLyBubyBoZWFkZXIgeWV0XG5cbiAgICAgIGlmICghaXNIZWFkZXJidWZmZXJWYWxpZChoZWFkZXJidWZmZXIpKSB7XG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGJ1ZmZlciBhbmQgYmFpbCBvdXRcbiAgICAgICAgTE9HX0VSUk9SKFwiQnVmZmVyU01GQ2xpZW50Ll9yeERhdGFDQigpOiBjb3VsZG4ndCBkZWNvZGUgbWVzc2FnZSBkdWUgdG8gaW52YWxpZCBzbWYgaGVhZGVyXCIpO1xuICAgICAgICBsb2dQZWVrQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2luY29taW5nQnVmZmVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3J4TWVzc2FnZUVycm9yQ0IoJ0Vycm9yIHBhcnNpbmcgaW5jb21pbmcgU01GIC0gaW52YWxpZCBTTUYgaGVhZGVyIGRldGVjdGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IG1ha2VNZXNzYWdlYnVmZmVyKGhlYWRlcmJ1ZmZlciwgYnVmZmVyKTtcbiAgICAgIGlmICghbWVzc2FnZUJ1ZmZlcikge1xuICAgICAgICBicmVhazsgLy8gbm8gZnVsbCBtZXNzYWdlXG4gICAgICB9XG5cbiAgICAgIExPR19UUkFDRSgnQnVmZmVyU01GQ2xpZW50IGluY29taW5nIGJ1ZmZlciBoYXMgYSBmdWxsIFNNRiBtZXNzYWdlJyk7XG4gICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBtZXNzYWdlQnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIGNvbnN0IGluY29taW5nTXNnID0gU01GTGliLkNvZGVjLkRlY29kZS5kZWNvZGVDb21wb3VuZE1lc3NhZ2UoYmluYXJ5U3RyaW5nLCAwKTtcbiAgICAgIGlmIChpbmNvbWluZ01zZyAmJiBpbmNvbWluZ01zZy5zbWZIZWFkZXIpIHtcbiAgICAgICAgYnVmZmVyLmFkdmFuY2UoaW5jb21pbmdNc2cuc21mSGVhZGVyLm1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICB0aGlzLl9yeFNtZkNCKGluY29taW5nTXNnKTsgLy8gaGFuZCBvdmVyIHRvIGNvcmUgQVBJIGNhbGxiYWNrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb3VsZG4ndCBkZWNvZGUhIExvc3QgU01GIGZyYW1pbmcuXG4gICAgICAgIC8vIHRocm93IGF3YXkgdGhlIGJ1ZmZlciBhbmQgYmFpbCBvdXRcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gdGhpcy5fc2Vzc2lvbiA/IHRoaXMuX3Nlc3Npb24uX3Nlc3Npb25JZCA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZEhleCA9IHNlc3Npb25JZCA/IGZvcm1hdEhleFN0cmluZyhzZXNzaW9uSWQpIDogJ04vQSc7XG4gICAgICAgIExPR19FUlJPUihgQnVmZmVyU01GQ2xpZW50Ll9yeERhdGFDQigpOiBjb3VsZG4ndCBkZWNvZGUgbWVzc2FnZSAoc2Vzc2lvbklkPSR7c2Vzc2lvbklkSGV4fSlgKTtcbiAgICAgICAgbG9nUGVla0J1ZmZlcihidWZmZXIpO1xuICAgICAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlci5yZXNldCgpO1xuICAgICAgICB0aGlzLl9yeE1lc3NhZ2VFcnJvckNCKCdFcnJvciBwYXJzaW5nIGluY29taW5nIFNNRicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSBidWZmZXIucmVtYWluaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHJlbWFpbmluZykge1xuICAgICAgLy8gV2UgaGF2ZSBhIHBhcnRpYWwgaGVhZGVyLCBvciBhIHZhbGlkIGhlYWRlciBhbmQgYSBwYXJ0aWFsIG1lc3NhZ2UuXG4gICAgICBMT0dfVFJBQ0UoYEJ1ZmZlclNNRkNsaWVudCBtZXNzYWdlIGNodW5rIG9mICR7cmVtYWluaW5nfSBieXRlczogcGFydGlhbCBtZXNzYWdlIGtlcHQgaW4gaW5jb21pbmcgYnVmZmVyYCk7XG4gICAgICAvLyBwYXJ0aWFsIG1lc3NhZ2UgcmVtYWluaW5nOiBrZWVwIGl0IGluIGluY29taW5nIGJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICBMT0dfVFJBQ0UoJ0J1ZmZlclNNRkNsaWVudCBjbGVhciBpbmNvbWluZyBidWZmZXInKTtcbiAgICAgIC8vIGNsZWFyIGluY29taW5nIGJ1ZmZlclxuICAgICAgdGhpcy5faW5jb21pbmdCdWZmZXIucmVzZXQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuQnVmZmVyU01GQ2xpZW50ID0gQnVmZmVyU01GQ2xpZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi9idWZmZXItc21mLWNsaWVudC5qcyIsImNvbnN0IERlYnVnTGliID0gcmVxdWlyZSgnc29sY2xpZW50LWRlYnVnJyk7XG5jb25zdCBTTUZMaWIgPSByZXF1aXJlKCdzb2xjbGllbnQtc21mJyk7XG5jb25zdCB7IEJhc2VTTUZDbGllbnQgfSA9IHJlcXVpcmUoJy4vYmFzZS1zbWYtY2xpZW50Jyk7XG5jb25zdCB7IENvbnZlcnQsIEhleCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgTG9nRm9ybWF0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5cbmNvbnN0IHsgYXJyYXlCdWZmZXJUb1N0cmluZyB9ID0gQ29udmVydDtcbmNvbnN0IHsgZm9ybWF0SGV4U3RyaW5nIH0gPSBIZXg7XG5cbmNvbnN0IFNNRl9MT1NUX0ZSQU1JTkdfVEhSRVNIT0xEID0gODAwMDAwMDA7XG5cbmNvbnN0IHsgTE9HX0RFQlVHLFxuICAgICAgICBMT0dfRVJST1IgfSA9IG5ldyBMb2dGb3JtYXR0ZXIoJ1tzdHJpbmctc21mLWNsaWVudF0nKTtcblxuLyoqXG4gKiBJbnRlcmFjdCB3aXRoIHVuZGVybHlpbmcgdHJhbnNwb3J0IHRvIHNlbmQgYW5kIHJlY2VpdmUgU01GIG1lc3NhZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdHJpbmdTTUZDbGllbnQgZXh0ZW5kcyBCYXNlU01GQ2xpZW50IHtcblxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIHRoaXMuX2luY29taW5nQnVmZmVyID0gJyc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgSW5jb21pbmcgZGF0YVxuICAgKi9cbiAgcnhEYXRhU3RyaW5nKGRhdGEpIHtcbiAgICB0aGlzLl9yeERhdGFDQihkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBJbmNvbWluZyBkYXRhXG4gICAqL1xuICByeERhdGFBcnJheUJ1ZmZlcihkYXRhKSB7XG4gICAgdGhpcy5fcnhEYXRhQ0IoYXJyYXlCdWZmZXJUb1N0cmluZyhkYXRhKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgaW5jb21pbmcgZGF0YVxuICAgKi9cbiAgcnhEYXRhQnVmZmVyKGRhdGEpIHtcbiAgICB0aGlzLl9yeERhdGFDQihkYXRhLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgdHJhbnNwb3J0IHNlc3Npb24uIEhhbmRsZXMgbXVsdGlwbGUgU01GIG1lc3NhZ2VzIGluIGlucHV0LCBhcyB3ZWxsIGFzIGRlZnJhZ21lbnRpbmdcbiAgICogcGFydGlhbCBTTUYgbWVzc2FnZXMuIFRoZSBzdGF0ZSB3ZSBrZWVwIGlzIGluIHRoaXMuX2luY29taW5nQnVmZmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgYmluYXJ5IGRhdGEgdG8gZGVjb2RlXG4gICAqL1xuICBfcnhEYXRhQ0IoZGF0YSkge1xuICAgIGlmICh0aGlzLl9zZXNzaW9uKSB7XG4gICAgICBMT0dfREVCVUcoJ1Jlc2V0IEtlZXBBbGl2ZUNvdW50ZXInKTtcbiAgICAgIC8vIGVhY2ggaW5jb21pbmcgZGF0YSBjaHVuayByZXNldHMgS0EgY291bnRlclxuICAgICAgdGhpcy5fc2Vzc2lvbi5yZXNldEtlZXBBbGl2ZUNvdW50ZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luY29taW5nQnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gb3B0aW1pemF0aW9uOiBzZXQgcmVmZXJlbmNlIChjaGVhcGVyIHRoYW4gYXBwZW5kKVxuICAgICAgdGhpcy5faW5jb21pbmdCdWZmZXIgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhcHBlbmQgdG8gZXhpc3RpbmcgZGF0YVxuICAgICAgdGhpcy5faW5jb21pbmdCdWZmZXIgKz0gZGF0YTtcbiAgICAgIGlmICh0aGlzLl9pbmNvbWluZ0J1ZmZlci5sZW5ndGggPiBTTUZfTE9TVF9GUkFNSU5HX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBzYW5pdHkgY2hlY2tcbiAgICAgICAgLy8gODAgbWVnYWJ5dGVzIC0gbG9zdCBTTUYgZnJhbWluZzogbWF5IG5ldmVyIGNvbXBsZXRlXG4gICAgICAgIExPR19FUlJPUihgRmlyc3QgNjQgYnl0ZXMgKG9yIGZld2VyKSBvZiBpbmNvbWluZyBidWZmZXI6IFxcbiR7XG4gICAgICAgICAgRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKHRoaXMuX2luY29taW5nQnVmZmVyLnN1YnN0cigwLCA2NCksIHRydWUsIDApfWApO1xuICAgICAgICB0aGlzLl9yeE1lc3NhZ2VFcnJvckNCKGBCdWZmZXIgb3ZlcmZsb3cgKGxlbmd0aDogJHt0aGlzLl9pbmNvbWluZ0J1ZmZlci5sZW5ndGh9KWApO1xuICAgICAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlciA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwb3MgPSAwO1xuICAgIHdoaWxlICgocG9zIDwgdGhpcy5faW5jb21pbmdCdWZmZXIubGVuZ3RoKSAmJlxuICAgICAgICAgIChTTUZMaWIuQ29kZWMuUGFyc2VTTUYuaXNTTUZBdmFpbGFibGUodGhpcy5faW5jb21pbmdCdWZmZXIsIHBvcykpKSB7XG4gICAgICBMT0dfREVCVUcoJ1N0cmluZ1NNRkNsaWVudCBpbmNvbWluZyBidWZmZXIgaGFzIGEgZnVsbCBTTUYgbWVzc2FnZScpO1xuXG4gICAgICBjb25zdCBpbmNvbWluZ01zZyA9IFNNRkxpYi5Db2RlYy5EZWNvZGUuZGVjb2RlQ29tcG91bmRNZXNzYWdlKHRoaXMuX2luY29taW5nQnVmZmVyLCBwb3MpO1xuICAgICAgaWYgKGluY29taW5nTXNnICYmIGluY29taW5nTXNnLnNtZkhlYWRlcikge1xuICAgICAgICBwb3MgKz0gaW5jb21pbmdNc2cuc21mSGVhZGVyLm1lc3NhZ2VMZW5ndGg7XG4gICAgICAgIHRoaXMuX3J4U21mQ0IoaW5jb21pbmdNc2cpOyAvLyBoYW5kIG92ZXIgdG8gY29yZSBBUEkgY2FsbGJhY2tcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvdWxkbid0IGRlY29kZSEgTG9zdCBTTUYgZnJhbWluZy5cbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gdGhpcy5fc2Vzc2lvbiA/IHRoaXMuX3Nlc3Npb24uX3Nlc3Npb25JZCA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZEhleCA9IHNlc3Npb25JZCA/IGZvcm1hdEhleFN0cmluZyhzZXNzaW9uSWQpIDogJ04vQSc7XG4gICAgICAgIExPR19FUlJPUihgU3RyaW5nU01GQ2xpZW50LnJ4RGF0YUNCKCk6IGNvdWxkbid0IGRlY29kZSBtZXNzYWdlIChzZXNzaW9uSWQ9JHtzZXNzaW9uSWRIZXhcbiAgICAgICAgICAgICAgICAgIH0pLCBkdW1waW5nIGJ1ZmZlciBjb250ZW50OlxcbiR7XG4gICAgICAgICAgICAgICAgICBEZWJ1Z0xpYi5EZWJ1Zy5mb3JtYXREdW1wQnl0ZXModGhpcy5faW5jb21pbmdCdWZmZXIuc3Vic3RyKHBvcyksIHRydWUsIDApfWApO1xuICAgICAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlciA9ICcnO1xuICAgICAgICB0aGlzLl9yeE1lc3NhZ2VFcnJvckNCKGBFcnJvciBwYXJzaW5nIGluY29taW5nIFNNRiBhdCBwb3NpdGlvbiAke3Bvc31gKTtcbiAgICAgICAgcmV0dXJuOyAvLyB0aHJvdyBhd2F5IGFsbCB3ZSBoYXZlIGZvciBub3dcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zIDwgdGhpcy5faW5jb21pbmdCdWZmZXIubGVuZ3RoKSB7XG4gICAgICBMT0dfREVCVUcoYFN0cmluZ1NNRkNsaWVudCBtZXNzYWdlIGNodW5rIG9mICR7ZGF0YS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9IGJ5dGVzOiBwYXJ0aWFsIG1lc3NhZ2Uga2VwdCBpbiBpbmNvbWluZyBidWZmZXJgKTtcbiAgICAgIC8vIGlzU01GSGVhZGVyVmFsaWQgY2FsbHMgaXNTTUZIZWFkZXJBdmFpbGFibGVcbiAgICAgIC8vIFBFUkZcbiAgICAgIGlmIChTTUZMaWIuQ29kZWMuUGFyc2VTTUYuaXNTTUZIZWFkZXJBdmFpbGFibGUodGhpcy5faW5jb21pbmdCdWZmZXIsIHBvcykgJiZcbiAgICAgICAgICAoIVNNRkxpYi5Db2RlYy5QYXJzZVNNRi5pc1NNRkhlYWRlclZhbGlkKHRoaXMuX2luY29taW5nQnVmZmVyLCBwb3MpKSkge1xuICAgICAgICBMT0dfRVJST1IoXCJTdHJpbmdTTUZDbGllbnQucnhEYXRhQ0IoKTogY291bGRuJ3QgZGVjb2RlIG1lc3NhZ2UgZHVlIHRvIGludmFsaWQgc21mIGhlYWRlciwgZHVtcCBcIiArXG4gICAgICAgICAgICAgICAgICBgZmlyc3QgNjQgYnl0ZXMgKG9yIGZld2VyKSBvZiBidWZmZXIgY29udGVudDpcXG4ke1xuICAgICAgICAgICAgICAgICAgRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKHRoaXMuX2luY29taW5nQnVmZmVyLnN1YnN0cmluZyhwb3MsIDY0KSwgdHJ1ZSwgMCl9YCk7XG4gICAgICAgIHRoaXMuX2luY29taW5nQnVmZmVyID0gJyc7XG4gICAgICAgIHRoaXMuX3J4TWVzc2FnZUVycm9yQ0IoYEVycm9yIHBhcnNpbmcgaW5jb21pbmcgU01GIGF0IHBvc2l0aW9uICR7cG9zfSAtIGludmFsaWQgU01GIGhlYWRlciBkZXRlY3RlZGApO1xuICAgICAgICByZXR1cm47IC8vIHRocm93IGF3YXkgYWxsIHdlIGhhdmUgZm9yIG5vd1xuICAgICAgfVxuICAgICAgLy8gcGFydGlhbCBtZXNzYWdlIHJlbWFpbmluZzoga2VlcCBpdCBpbiBpbmNvbWluZyBidWZmZXJcbiAgICAgIGNvbnN0IGluQnVmZmVyID0gdGhpcy5faW5jb21pbmdCdWZmZXI7XG4gICAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlciA9IGluQnVmZmVyLnN1YnN0cihwb3MsIGluQnVmZmVyLmxlbmd0aCAtIHBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIExPR19ERUJVRygnU3RyaW5nU01GQ2xpZW50IGNsZWFyIGluY29taW5nIGJ1ZmZlcicpO1xuICAgICAgLy8gY2xlYXIgaW5jb21pbmcgYnVmZmVyXG4gICAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlciA9ICcnO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5TdHJpbmdTTUZDbGllbnQgPSBTdHJpbmdTTUZDbGllbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3N0cmluZy1zbWYtY2xpZW50LmpzIiwiY29uc3QgeyBUY3BUcmFuc3BvcnRTZXNzaW9uIH0gPSByZXF1aXJlKCcuL3RyYW5zcG9ydC10Y3AnKTtcblxubW9kdWxlLmV4cG9ydHMuVGNwVHJhbnNwb3J0U2Vzc2lvbiA9IFRjcFRyYW5zcG9ydFNlc3Npb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RjcC9hcGkuanMiLCJjb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3QgeyBIZXggfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IExPR19UUkFDRSwgTE9HX0RFQlVHLCBMT0dfV0FSTiwgTE9HX0VSUk9SIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IG1peGluIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcbmNvbnN0IHsgTm9kZVRMU09wdHNNaXhpbiB9ID0gcmVxdWlyZSgnLi4vbm9kZS10bHMtb3B0cy1taXhpbicpO1xuY29uc3QgeyBwYXJzZVVSTCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXV0aWwnKTtcbmNvbnN0IHsgVHJhbnNwb3J0QmFzZSB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LWJhc2UnKTtcbmNvbnN0IHsgVHJhbnNwb3J0Q2xpZW50U3RhdHMgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1jbGllbnQtc3RhdHMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1lcnJvcicpO1xuY29uc3QgeyBUcmFuc3BvcnRSZXR1cm5Db2RlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtcmV0dXJuLWNvZGVzJyk7XG5jb25zdCB7IFRyYW5zcG9ydFNlc3Npb25FdmVudCB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXNlc3Npb24tZXZlbnQnKTtcbmNvbnN0IHsgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZSB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXNlc3Npb24tZXZlbnQtY29kZXMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0U2Vzc2lvblN0YXRlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1zdGF0ZXMnKTtcblxuXG5jb25zdCB7XG4gIGZvcm1hdEhleFN0cmluZyxcbn0gPSBIZXg7XG5cbi8qKlxuICpcbiAqIFRjcCAoc21mKSB0cmFuc3BvcnQgd2l0aCBUTFMgKHRjcHM6Ly8pIHN1cHBvcnQuXG4gKiBPbmx5IHdvcmtzIGluIG5vZGUuanMuXG4gKiBNb2RlbGxlZCBhZnRlciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCBtb3N0bHksXG4gKiBleGNlcHQgdGhlcmUgaXMgbm8gZG93bmdyYWRlIG1lY2hhbmlzbS5cbiAqIFRoZXJlIGlzIG5vIHNlcGFyYXRlIFwiVHJhbnNwb3J0XCIgY2xhc3NcbiAqIHRvIG1hbmFnZSB0aGUgZG93bmdyYWRlIEZTTTpcbiAqIFRoZSBUcmFuc3BvcnRTZXNzaW9uIGlzIHRoZSBUcmFuc3BvcnQuXG5cbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFRjcFRyYW5zcG9ydFNlc3Npb24gZXh0ZW5kcyBUcmFuc3BvcnRCYXNlIHtcblxuICBjb25zdHJ1Y3Rvcih1cmwsIGV2ZW50Q0IsIGNsaWVudCwgcHJvcHMpIHtcbiAgICAvLyBpbnN0YW5pdGF0ZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gVHJhbnNwb3J0QmFzZVxuICAgIHN1cGVyKHVybCwgZXZlbnRDQiwgY2xpZW50LCBwcm9wcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUcmFuc3BvcnRDbGllbnRTdGF0c31cbiAgICAgKi9cbiAgICB0aGlzLl9jbGllbnRzdGF0cyA9IG5ldyBUcmFuc3BvcnRDbGllbnRTdGF0cygpO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhbW91bnQgb2Ygc2VuZCBkYXRhIHRoYW4gY2FuIGJlIHF1ZXVlZC5cbiAgICAgKiBOb2RlSlMgc29ja2V0LndyaXRlIGFjY2VwdHMgYWxsIHdyaXRlcywgZ3Jvd2luZyBhXG4gICAgICogdXNlciBzcGFjZSBidWZmZXIgaW5kZWZpbml0ZWx5LlxuICAgICAqIFRoZSBUQ1AgdHJhbnNwb3J0IChzYW1lIGFzIFdTIHRyYW5zcG9ydClcbiAgICAgKiBtYW5hZ2VzIHRoZSBzaXplIG9mIHRoYXQgYnVmZmVyIHRvIHN0YXkgYmVsb3cgdGhpcyBsaW1pdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fc2VuZEJ1ZmZlck1heFNpemUgPSBwcm9wcy5zZW5kQnVmZmVyTWF4U2l6ZTtcblxuICAgIC8qXG4gICAgICogV2hlbiB0cnVlLCB0aGUgdXBwZXIgbGF5ZXIgd2FzIHRvbGQgTk9fU1BBQ0UgYW5kIG11c3QgYmUgbm90aWZpZWRcbiAgICAgKiBvZiB0aGUgbmV4dCBcImRyYWluZWRcIiBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2NhblNlbmROZWVkZWQgPSBmYWxzZTtcblxuICAgIC8qXG4gICAgICogT25lLXNob3QgZmx1c2ggY2FsbGJhY2suXG4gICAgICogU2V0IG9uIGZsdXNoKCksIHJhbiBhbmQgY2xlYXJlZCBvbiBzb2NrZXQgZHJhaW4gZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEZsYWcgdG8ga2VlcCB0cmFjayBvZiBzb2NrZXQgZHJhaW5lZCBzdGF0ZTpcbiAgICAgKiBTZXQgdG8gZmFsc2Ugd2hlbiBzb2NrZXQud3JpdGUgcmV0dXJucyBmYWxzZSxcbiAgICAgKiAoaW5kaWNhdGluZyB1c2VyLXNwYWNlIGJ1ZmZlcmluZylcbiAgICAgKiBTZXQgdG8gdHJ1ZSBvbiBzb2NrZXQgZHJhaW4gZXZlbnRzLlxuICAgICAqIChpbmRpY2F0aW5nIHRoZSB1c2VyIHNwYWNlIGJ1ZmZlciBoYXMgZmx1c2hlZCB0byB0aGUgT1MuKVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZHJhaW5lZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhbnNwb3J0U2Vzc2lvblN0YXRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/U29ja2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIEV2ZW50IGluIHRoZSBvbkVycm9yIGxpc3RlbmVyXG4gICAgICogVXNlIGl0IGluIG9uQ2xvc2UgdG8gcG9wdWxhdGUgdGhlIGV2ZW50LlxuICAgICAqIChUY3Agc29ja2V0IGNhbGxzIG9uRXJyb3Igd2l0aCB0aGUgZXJyb3IgdGhlbiBvbkNsb3NlLlxuICAgICAqIFdTIHNvY2tldCBjYWxscyBvbmx5IG9uQ2xvc2UgYW5kIHBhc3NlcyB0aGUgZXJyb3IgZGlyZWN0bHkuKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FcnJvcn1cbiAgICAgKi9cbiAgICB0aGlzLl9zb2NrZXRFcnJvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb25JZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gU29tZSB3aGl0ZWJveCB0ZXN0cyBleHBlY3QgYSB0cmFuc3BvcnQtPnRyYW5zcG9ydFNlc3Npb24gbmVzdGluZy5cbiAgICB0aGlzLl90cmFuc3BvcnRTZXNzaW9uID0gdGhpcztcblxuICAgIHRoaXMuX3Byb3BzLnRyYW5zcG9ydFByb3RvY29sID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldENsaWVudFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzdGF0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBob3N0IGFuZCBwb3J0IGZyb20gdGhlIHJvdXRlciBVUkwuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxTdHJpbmcgdGhlIHVybFxuICAgKiBAcmV0dXJucyB7e1N0cmluZywgTnVtYmVyfX0gaG9zdCBhbmQgcG9ydFxuICAgKi9cbiAgcGFyc2VIb3N0UG9ydCh1cmxTdHJpbmcpIHtcbiAgICBsZXQgcG9ydCA9IG51bGw7XG4gICAgY29uc3QgdXJsUGFyc2VkID0gcGFyc2VVUkwodXJsU3RyaW5nKTtcbiAgICBpZiAodXJsUGFyc2VkLnByb3RvY29sICE9PSAndGNwOicgJiYgdXJsUGFyc2VkLnByb3RvY29sICE9PSAndGNwczonKSB7XG4gICAgICAvLyBTaG91bGQgbm90IGhhcHBlbi5cbiAgICAgIExPR19FUlJPUihgVGNwIFRyYW5zcG9ydDogVVJMIHdpdGggdW5leHBlY3RlZCBzY2hlbWU6ICR7dXJsUGFyc2VkLnByb3RvY29sfWApO1xuICAgIH1cbiAgICBjb25zdCBob3N0ID0gdXJsUGFyc2VkLmhvc3RuYW1lO1xuICAgIHBvcnQgPSB1cmxQYXJzZWQucG9ydDtcbiAgICBpZiAocG9ydCA9PT0gbnVsbCkge1xuICAgICAgcG9ydCA9IHRoaXMuX3NzbCA/IDU1NDQzIDogNTU1NTU7XG4gICAgfVxuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBVUkwgKHBhdGgsIGV0YykgaXMgaWdub3JlZC5cbiAgICBMT0dfVFJBQ0UoYFBhcnNpbmcgdXJsICR7dXJsU3RyaW5nfSAtPiBob3N0OiAke2hvc3R9ICwgcG9ydDogJHtwb3J0fWApO1xuICAgIHJldHVybiB7IGhvc3QsIHBvcnQgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb2NrZXQgY2FsbGJhY2suXG4gICAqIEJpbmQgdGhlIHNvY2tldCBvbiBzZXR1cCB0byBhdm9pZCBzdHJheSBlcnJvcnMgZnJvbSBvbGQgc29ja2V0c1xuICAgKiBpbiBxdWljayBjb25uZWN0KCktZGVzdHJ5KCktY29ubmVjdCgpIHNjZW5hcmlvcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTb2NrZXR9IG9yaWdpbmFsU29ja2V0IHRoZSBvcmlnaW5hbCBzb2NrZXRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAgICovXG4gIG9uRGF0YShvcmlnaW5hbFNvY2tldCwgZGF0YSkge1xuICAgIC8vIFdlIGRvIG5vdCBjb2xsZWN0IFJ4IHN0YXRzLlxuICAgIGlmIChvcmlnaW5hbFNvY2tldCAmJiBvcmlnaW5hbFNvY2tldCAhPT0gdGhpcy5fc29ja2V0KSB7XG4gICAgICBMT0dfREVCVUcoJ1RjcFRyYW5zcG9ydFNlc3Npb24gc3RyYXkgb25EYXRhIGZvciBwcmV2aW91cyBzb2NrZXQsIGlnbm9yaW5nLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2xpZW50KSB7XG4gICAgICB0aGlzLl9jbGllbnQucnhEYXRhQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb2NrZXQgY2FsbGJhY2suXG4gICAqIEJpbmQgdGhlIHNvY2tldCBvbiBzZXR1cCB0byBhdm9pZCBzdHJheSBlcnJvcnMgZnJvbSBvbGQgc29ja2V0c1xuICAgKiBpbiBxdWljayBjb25uZWN0KCktZGVzdHJ5KCktY29ubmVjdCgpIHNjZW5hcmlvcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTb2NrZXR9IG9yaWdpbmFsU29ja2V0IHRoZSBvcmlnaW5hbCBzb2NrZXRcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgdGhlIGVycm9yXG4gICAqL1xuICBvbkVycm9yKG9yaWdpbmFsU29ja2V0LCBlcnJvcikge1xuICAgIGlmIChvcmlnaW5hbFNvY2tldCAmJiBvcmlnaW5hbFNvY2tldCAhPT0gdGhpcy5fc29ja2V0KSB7XG4gICAgICBMT0dfREVCVUcoJ1RjcFRyYW5zcG9ydFNlc3Npb24gc3RyYXkgb25FcnJvciBmb3IgcHJldmlvdXMgc29ja2V0LCBpZ25vcmluZy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgTE9HX1RSQUNFKCdUY3AgdHJhbnNwb3J0IGlzIGJlaW5nIGRlc3Ryb3llZCwgaWdub3JlIGVycm9yJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIExPR19ERUJVRyhgVGNwIHRyYW5zcG9ydCBjb25uZWN0aW9uIGVycm9yICR7ZXJyb3J9YCk7XG4gICAgLy8gbmV0LnNvY2tldCBpbnZva2VzIHRoZSBlcnJvciBoYW5kbGVyIGJlZm9yZSB0aGUgY2xvc2UgaGFuZGxlci5cbiAgICAvLyBXZWJzb2NrZXQgZG9lcyBub3QsIGFuZCB0aGF0J3Mgd2hhdCB0aGUgdXBwZXIgbGF5ZXIgZXhwZWN0cy5cbiAgICAvLyBTdXBwcmVzc2luZyB0aGUgXCJkb3VibGUgdGFwXCIgZXJyb3IgZXZlbnRzIHdoZW4gY29ubmVjdGVkLFxuICAgIC8vIHNhdmluZyB0aGUgZXJyb3IgZm9yIHRoZSBvbkNsb3NlIGhhbmRsZXIgaW4gX3NvY2tldGVycm9yLlxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLlNFU1NJT05fVVApIHtcbiAgICAgIHRoaXMuX2V2ZW50Q0IoXG4gICAgICAgIG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoXG4gICAgICAgICAgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5TRU5EX0VSUk9SLFxuICAgICAgICAgIGBDb25uZWN0aW9uIGVycm9yJHtlcnJvcn1gLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1IsIG51bGwpKTtcbiAgICB9IGVsc2UgeyAvLyB3ZSByZWx5IG9uIHRoZSBjbG9zZSBsaXN0ZW5lciB0byBub3RpZnkgdGhlIHVwcGVyIGxheWVyLlxuICAgICAgdGhpcy5fc29ja2V0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29ja2V0IGNhbGxiYWNrLlxuICAgKiBCaW5kIHRoZSBzb2NrZXQgYXJndW1lbnQgdG8gZ3VhcmQgYWdhaW5zdCBzdHJheSBpbnZvY2F0aW9ucyBpbiBhXG4gICAqIHF1aWNrIGNvbm5lY3QoKS1kZXN0cm95KCktY29ubmVjdCgpIHNjZW5hcmlvLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1NvY2tldH0gb3JpZ2luYWxTb2NrZXQgb3JpZ2luYWwgc29ja2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFkRXJyb3Igd2hldGVyIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgKi9cbiAgb25DbG9zZShvcmlnaW5hbFNvY2tldCwgaGFkRXJyb3IpIHtcbiAgICAvL3Byb2Nlc3Muc3Rkb3V0LndyaXRlKCdUQ1AgdHJhbnNwb3J0IG9uQ2xvc2UgY2FsbGVkLlxcbicpO1xuICAgIGlmIChvcmlnaW5hbFNvY2tldCAmJiBvcmlnaW5hbFNvY2tldCAhPT0gdGhpcy5fc29ja2V0KSB7XG4gICAgICBMT0dfREVCVUcoJ1RjcFRyYW5zcG9ydFNlc3Npb24gc3RyYXkgb25DbG9zZSBmb3IgcHJldmlvdXMgc29ja2V0LCBpZ25vcmluZy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgTE9HX1RSQUNFKCdUY3AgdHJhbnNwb3J0IGlzIGJlaW5nIGRlc3Ryb3llZCwgaWdub3JlIGNsb3NlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1zZyA9IGhhZEVycm9yID8gJ3dpdGggZXJyb3InIDogJ2NsZWFubHknO1xuICAgIGNvbnN0IGVycm9yTXNnID0gdGhpcy5fc29ja2V0RXJyb3IgJiYgdGhpcy5fc29ja2V0RXJyb3IubWVzc2FnZTtcbiAgICB0aGlzLl9zb2NrZXRFcnJvciA9IG51bGw7IC8vIGNsZWFyIG9uIHJlYWQuXG4gICAgTE9HX0RFQlVHKGBUY3AgdHJhbnNwb3J0IGNvbm5lY3Rpb24gaXMgY2xvc2VkICR7bXNnfS4gTWVzc2FnZTogaSR7ZXJyb3JNc2d9YCk7XG4gICAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShgVGNwIHRyYW5zcG9ydCBjb25uZWN0aW9uIGlzIGNsb3NlZCAke21zZ30uIE1lc3NhZ2U6ICR7ZXJyb3JNc2d9YCk7XG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuQ09OTkVDVElPTl9GQUlMRUQ7XG4gICAgdGhpcy5kZXN0cm95KGBDb25uZWN0aW9uIGNsb3NlZCAke21zZ30uIE1lc3NhZ2U6JHtlcnJvck1zZ31gLCBFcnJvclN1YmNvZGUuQ09NTVVOSUNBVElPTl9FUlJPUik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIFNvY2tldC5jb25uZWN0LlxuICAgKiBCaW5kIHRoZSBzb2NrZXQgYXJndW1lbnQgdG8gZ3VhcmQgYWdhaW5zdCBzdHJheSBpbnZvY2F0aW9ucyBpbiBhXG4gICAqIHF1aWNrIGNvbm5lY3QoKS1kZXN0cm95KCktY29ubmVjdCgpIHNjZW5hcmlvLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1NvY2tldH0gb3JpZ2luYWxTb2NrZXQgb3JpZ2luYWwgc29ja2V0XG4gICAqL1xuICBvbk9wZW4ob3JpZ2luYWxTb2NrZXQpIHtcbiAgICBMT0dfVFJBQ0UoJ1RjcFRyYW5zcG9ydFNlc3Npb24gcmVjZWl2ZWQgc29ja2V0IG9wZW4gZXZlbnQuJyk7XG4gICAgaWYgKG9yaWdpbmFsU29ja2V0ICYmIG9yaWdpbmFsU29ja2V0ICE9PSB0aGlzLl9zb2NrZXQpIHtcbiAgICAgIExPR19ERUJVRygnVGNwVHJhbnNwb3J0U2Vzc2lvbiBzdHJheSBvbk9wZW4gZm9yIHByZXZpb3VzIHNvY2tldCwgaWdub3JpbmcuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0NSRUFURSkge1xuICAgICAgTE9HX0RFQlVHKGBUY3BUcmFuc3BvcnRTZXNzaW9uIHN0cmF5IG9uT3BlbiB3aGVuIGluIHN0YXRlICR7dGhpcy5fc3RhdGV9LCBpZ25vcmluZy5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuU0VTU0lPTl9VUDtcbiAgICAgIC8vIFNlbmQgdGhlIGV2ZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBsZXR0aW5nIGl0IGtub3cgdGhhdCB0aGUgc2Vzc2lvbiBpcyB1cFxuICAgIHRoaXMuX2V2ZW50Q0IoXG4gICAgICAgICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChcbiAgICAgICAgICAgICAgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5VUF9OT1RJQ0UsXG4gICAgICAgICAgICAgICdDb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uSWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIHJlc3VsdCBvZiB0aGlzIG9wZXJhdGlvblxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5ET1dOKSB7XG4gICAgICBMT0dfRVJST1IoYEludmFsaWQgc3RhdGUgZm9yIG9wZXJhdGlvbjogJHtUcmFuc3BvcnRTZXNzaW9uU3RhdGUubmFtZU9mKHRoaXMuX3N0YXRlKX1gKTtcbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLklOVkFMSURfU1RBVEVfRk9SX09QRVJBVElPTjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgTE9HX0VSUk9SKCdUQ1AgdHJhbnNwb3J0IGNhbiBub3QgY29ubmVjdCBvbmNlIF9zb2NrZXQgZXhpc3RzLicpO1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuSU5WQUxJRF9TVEFURV9GT1JfT1BFUkFUSU9OO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VybCkge1xuICAgICAgTE9HX1dBUk4oJ0Nhbm5vdCBjb25uZWN0IHRvIG51bGwgVVJMJyk7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5DT05ORUNUSU9OX0VSUk9SO1xuICAgIH1cblxuICAgIExPR19ERUJVRygnRXN0YWJsaXNoaW5nIFRjcCB0cmFuc3BvcnQgc2Vzc2lvbicpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5XQUlUSU5HX0ZPUl9DUkVBVEU7XG4gICAgICBjb25zdCB7IGhvc3QsIHBvcnQgfSA9IHRoaXMucGFyc2VIb3N0UG9ydCh0aGlzLl91cmwpO1xuICAgICAgTE9HX0RFQlVHKCdDb25zdHJ1Y3Rpbmcgc29ja2V0Jyk7XG4gICAgICAvLyBMdWNraWx5IHJhdyBhbmQgdGxzIHNvY2tldHMgaGF2ZSB0aGUgc2FtZSBBUEkuXG4gICAgICBpZiAoIXRoaXMuX3NzbCkge1xuICAgICAgICB0aGlzLl9zb2NrZXQgPSBuZXcgbmV0LlNvY2tldCgpO1xuICAgICAgICB0aGlzLl9zb2NrZXQuY29ubmVjdChcbiAgICAgICAgICBwb3J0LCBob3N0LFxuICAgICAgICAgIHRoaXMub25PcGVuLmJpbmQodGhpcywgdGhpcy5fc29ja2V0KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGxzT3B0aW9ucyA9IHRoaXMuY3JlYXRlVExTT3B0aW9ucygpO1xuICAgICAgICB0aGlzLl9zb2NrZXQgPSB0bHMuY29ubmVjdChcbiAgICAgICAgICBwb3J0LCBob3N0LCB0bHNPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbignc2VjdXJlQ29ubmVjdCcsIHRoaXMub25PcGVuLmJpbmQodGhpcywgdGhpcy5fc29ja2V0KSk7XG4gICAgICB9XG4gICAgICBMT0dfVFJBQ0UoJ0Fzc2lnbmluZyBwcm9wZXJ0aWVzIHRvIHNvY2tldCcpO1xuICAgICAgLy8gV0FSTklORyFcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGtpbmQgb2YgdGhpbmcgdGhhdCBicmVha3Mgb24gbWluaWZpY2F0aW9uLlxuICAgICAgLy8gUmUtcnVuIHVuaXQgdGVzdHMgaW4gcHJvZHVjdGlvbiBtb2RlIHdoZW4gY2hhbmdlZDpcbiAgICAgIC8vIGdydW50IC0tZ3J1bnRmaWxlPUdydW50ZmlsZV9Qcm9kdWN0aW9uLmpzXG4gICAgICAvLyBXaGVuIGJyb2tlbiwgY29uc3VsdCB0aGUgY2xvc3VyZSBjb21waWxlciBleGNlcHRpb25zIGZpbGU6XG4gICAgICAvLyAoc2RrLXJvb3QpL2J1aWxkZXIvdGVtcGxhdGUvLWNvbW1vbi9lbnYvZXh0ZXJucy5qc1xuICAgICAgdGhpcy5fc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5vbkRhdGEuYmluZCh0aGlzLCB0aGlzLl9zb2NrZXQpKTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbignZXJyb3InLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzLCB0aGlzLl9zb2NrZXQpKTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbignY2xvc2UnLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzLCB0aGlzLl9zb2NrZXQpKTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbignZHJhaW4nLCB0aGlzLm9uRHJhaW4uYmluZCh0aGlzLCB0aGlzLl9zb2NrZXQpKTtcbiAgICAgIHRoaXMuX3NvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuXG4gICAgICBMT0dfVFJBQ0UoJ1ByZXBhcmVkIHNvY2tldCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBMT0dfREVCVUcoYEVycm9yIGNvbm5lY3Rpbmc6ICR7ZXJyb3J9YCk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBUY3Agc29ja2V0OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3Iuc3ViY29kZSB8fCBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfVxuICAgIExPR19ERUJVRygnVGNwIHRyYW5zcG9ydCBpcyBjb25uZWN0aW5nJyk7XG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAqIFJldHVybnMgdHJhbnNwb3J0IHJldHVybiBjb2RlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHs/U3RyaW5nfSBtc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgb3BlcmF0aW9uLCBpZiBhbnkuXG4gICAqIEBwYXJhbSB7P0Vycm9yU3ViY29kZX0gc3ViY29kZSBUaGUgc3ViY29kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBvcGVyYXRpb24sIGlmIGFueS5cbiAgICogQHJldHVybnMge1RyYW5zcG9ydFJldHVybkNvZGV9IFRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIGRlc3Ryb3kobXNnLCBzdWJjb2RlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTikge1xuICAgICAgTE9HX0RFQlVHKGBEZXN0cm95IFRjcCB0cmFuc3BvcnQ6ICR7bXNnfWApO1xuXG4gICAgICAvLyBTZXQgc3RhdGUgZm9yIGNvbm5lY3Rpb24gdGVhcmRvd24uXG4gICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5XQUlUSU5HX0ZPUl9ERVNUUk9ZO1xuXG4gICAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICAgIGNvbnN0IG9uZXJyb3JTdHViID0gZnVuY3Rpb24gb25lcnJvclN0dWIoKSB7IH07XG4gICAgICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xuICAgICAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgb25lcnJvclN0dWIpOyAvLyBQcmV2ZW50IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgLy8gUHJlZmVyaW5nIGRlc3Ryb3koKSBvdmVyIGVuZCgpIGFzIGl0IHNlZW1zIHRvXG4gICAgICAgIC8vIGNhbmNlbCBwZW5kaW5nIGNhbGxiYWNrcyBsaWtlIG9uT3BlbiBtb3JlIHJlbGlhYmx5LlxuICAgICAgICAvL3RoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FuU2VuZE5lZWRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IG51bGw7XG4gICAgICB0aGlzLl9kcmFpbmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkRPV047XG4gICAgICB0aGlzLl9jbGllbnQgPSBudWxsOyAvLyBEb24ndCBhY2NlcHQgZGF0YS5cbiAgICB9XG5cbiAgICAvLyBhbHdheXMgc2VuZCBhIERFU1RST1lFRF9OT1RJQ0UgaW4gcmVzcG9uc2UgdG8gYSBkZXN0cm95KCkgZXZlblxuICAgIC8vIGlmIHdlIHRoaW5rIHRoZSB0cmFuc3BvcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcbiAgICBMT0dfVFJBQ0UoYERlc3Ryb3lpbmcgVENQIHRyYW5zcG9ydC4gbXNnOiAke21zZ30gc3ViY29kZTogJHtzdWJjb2RlfWApO1xuICAgIGlmICh0aGlzLl9ldmVudENCKSB7XG4gICAgICB0aGlzLl9ldmVudENCKG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5ERVNUUk9ZRURfTk9USUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZyB8fCAnU2Vzc2lvbiBpcyBkZXN0cm95ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY29kZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25JZCkpO1xuICAgICAgLy8gUmVsZWFzZSByZWZlcmVuY2VzIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICAgIHRoaXMuX2V2ZW50Q0IgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGRlc2NyaXB0aW9uIEludGVuZGVkIGZvciBjbGVhbiBzaHV0ZG93bnMuXG4gICAqIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBhbGwgbm9kZWpzLWJ1ZmZlcmVkIGRhdGFcbiAgICogaGFzIGJlZW4gZmx1c2hlZCB0byB0aGUgT1Mgc29ja2V0LlxuICAgKi9cbiAgZmx1c2goY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fZHJhaW5lZCkge1xuICAgICAgTE9HX0RFQlVHKCdUcmFuc3BvcnQgZW1pdHRpbmcgRkxVU0ggaW1tZWRpYXRlbHkuJyk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEBkZXNjcmlwdGlvbiBTZW5kIGVuY29kZWQgU01GIG1lc3NhZ2VcbiAgICogUmV0dXJucyB0cmFuc3BvcnQgcmV0dXJuIGNvZGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlbmNvZGVkIFNNRiBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHs/Qm9vbGVhbn0gW2ZvcmNlQWxsb3dFbnF1ZXVlPWZhbHNlXSBJZiB0cnVlLCBkbyBub3QgZmFpbCBkdWUgdG8gdHJhbnNwb3J0IGJ1ZmZlciBmdWxsXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgcmVzdWx0IG9mIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBzZW5kKG1lc3NhZ2UsIGZvcmNlQWxsb3dFbnF1ZXVlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5TRVNTSU9OX1VQKSB7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5JTlZBTElEX1NUQVRFX0ZPUl9PUEVSQVRJT047XG4gICAgfVxuXG4gICAgLy8gTGltaXRpbmcgc29ja2V0IGJ1ZmZlciBzaXplIHRvIF9zZW5kQnVmZmVyTWF4U2l6ZSB1bmxlc3NcbiAgICAvLyB0aGUgZm9yY2UgZmxhZyB3YXMgc2V0XG4gICAgLy8gb3IgdGhlIHNvY2tldCBpcyBkcmFpbmVkLCBpbiB3aGljaCBjYXNlIGFueSBzaXplIG1lc3NhZ2UgZ29lcy5cbiAgICBpZiAoZm9yY2VBbGxvd0VucXVldWVcbiAgICAgIHx8IHRoaXMuX2RyYWluZWRcbiAgICAgIHx8IHRoaXMuX3NvY2tldC5idWZmZXJTaXplICsgbWVzc2FnZS5sZW5ndGggPFxuICAgICAgdGhpcy5fc2VuZEJ1ZmZlck1heFNpemUpIHtcbiAgICAgIC8vIF9kcmFpbmVkIGtlZXBzIHRyYWNrIG9mIFwib3ZlcmZsb3dpbmdcIiB3cml0ZXMuXG4gICAgICAvLyBub2RlanMgbmV2ZXIgcmVmdXNlcyBhIHJlYWQgYnV0IHdhcm5zIHdoZW4gaXQgc3RhcnRzIGJ1ZmZlcmluZy5cbiAgICAgIHRoaXMuX2RyYWluZWQgPSB0aGlzLl9zb2NrZXQud3JpdGUobWVzc2FnZSwgJ2FzY2lpJyk7XG4gICAgICB0aGlzLl9jbGllbnRzdGF0cy5ieXRlc1dyaXR0ZW4gKz0gbWVzc2FnZS5sZW5ndGg7XG4gICAgICArK3RoaXMuX2NsaWVudHN0YXRzLm1zZ1dyaXR0ZW47XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgICB9XG4gICAgLy8gV2UnbGwgdW5ibG9jayB0aGUgdXNlciBvbiB0aGUgbmV4dCBvbkRyYWluLlxuICAgIHRoaXMuX2NhblNlbmROZWVkZWQgPSB0cnVlO1xuICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk5PX1NQQUNFO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvY2tldCBjYWxsYmFjay5cbiAgICogQmluZCB0aGUgc29ja2V0IG9uIHNldHVwIHRvIGF2b2lkIHN0cmF5IGVycm9ycyBmcm9tIG9sZCBzb2NrZXRzXG4gICAqIGluIHF1aWNrIGNvbm5lY3QoKS1kZXN0cnkoKS1jb25uZWN0KCkgc2NlbmFyaW9zLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1NvY2tldH0gb3JpZ2luYWxTb2NrZXQgdGhlIG9yaWdpbmFsIHNvY2tldFxuICAgKi9cbiAgb25EcmFpbihvcmlnaW5hbFNvY2tldCkge1xuICAgIGlmIChvcmlnaW5hbFNvY2tldCAmJiBvcmlnaW5hbFNvY2tldCAhPT0gdGhpcy5fc29ja2V0KSB7XG4gICAgICBMT0dfREVCVUcoJ1RjcFRyYW5zcG9ydFNlc3Npb24gc3RyYXkgb25EcmFpbiBmb3IgcHJldmlvdXMgc29ja2V0LCBpZ25vcmluZy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZHJhaW5lZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5fZmx1c2hDYWxsYmFjaykge1xuICAgICAgTE9HX0RFQlVHKCdUcmFuc3BvcnQgZW1pdHRpbmcgRkxVU0ggYWZ0ZXIgZHJhaW4uJyk7XG4gICAgICBjb25zdCBwcmV2Q2FsbGJhY2sgPSB0aGlzLl9mbHVzaENhbGxiYWNrO1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjayA9IG51bGw7XG4gICAgICBwcmV2Q2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FuU2VuZE5lZWRlZCkge1xuICAgICAgTE9HX1RSQUNFKCdUcmFuc3BvcnQgZW1pdHRpbmcgQ0FOX0FDQ0VQVF9EQVRBJyk7XG4gICAgICB0aGlzLl9jYW5TZW5kTmVlZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9ldmVudENCKFxuICAgICAgICBuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuQ0FOX0FDQ0VQVF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnLCBudWxsLCAwLCB0aGlzLl9zZXNzaW9uSWQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRJbmZvU3RyKCkge1xuICAgIGNvbnN0IHN0ciA9IGBUY3BUcmFuc3BvcnRTZXNzaW9uOyBzaWQ9JHtmb3JtYXRIZXhTdHJpbmcodGhpcy5fc2Vzc2lvbklkKX1gO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxufVxuXG5taXhpbihUY3BUcmFuc3BvcnRTZXNzaW9uLCBOb2RlVExTT3B0c01peGluKTtcblxubW9kdWxlLmV4cG9ydHMuVGNwVHJhbnNwb3J0U2Vzc2lvbiA9IFRjcFRyYW5zcG9ydFNlc3Npb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RjcC90cmFuc3BvcnQtdGNwLmpzIiwiY29uc3QgeyBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vd2ViJyk7XG5cbmNvbnN0IFRyYW5zcG9ydENhcGFiaWxpdGllcyA9IHtcbiAgd2ViOiBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRDYXBhYmlsaXRpZXMgPSBUcmFuc3BvcnRDYXBhYmlsaXRpZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3RyYW5zcG9ydC1jYXBhYmlsaXRpZXMuanMiLCJjb25zdCBUY3BUcmFuc3BvcnRzTGliID0gQlVJTERfRU5WLlRBUkdFVF9OT0RFID8gcmVxdWlyZSgnLi90Y3AnKSA6IG51bGw7XG5jb25zdCB7IFdlYlRyYW5zcG9ydCB9ID0gcmVxdWlyZSgnLi93ZWInKTtcblxuY29uc3QgVHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgY3JlYXRlVHJhbnNwb3J0KGhvc3QsIGV2ZW50Q0IsIGNsaWVudCwgcHJvcHMsIGdldElkKSB7XG4gICAgY29uc3QgdXJsID0gaG9zdDtcbiAgICBPYmplY3QuYXNzaWduKHByb3BzLCB7XG4gICAgICBjb25uZWN0VGltZW91dEluTXNlY3M6IDEwMDAwMCwgIC8vIFRPRE86IGNhbiB3ZSBlbGltaW5hdGUgdGhpc1xuICAgIH0pO1xuICAgIC8vIFRDUCB0cmFuc3BvcnQgaXMgZGljdGF0ZWQgYnkgdGhlIFVSTCAodGNwOi8vIG9yIHRjcHM6Ly8pXG4gICAgLy8gSXQgaXMgdW5hZmZlY3RlZCBieSB0aGUgdHJhbnNwb3J0UHJvdG9jb2wgY29uZmlnIHBhcmFtZXRlci5cbiAgICBpZiAoVGNwVHJhbnNwb3J0c0xpYiAmJiB1cmwudHJpbSgpLnN0YXJ0c1dpdGgoJ3RjcCcpKSB7XG4gICAgICByZXR1cm4gbmV3IFRjcFRyYW5zcG9ydHNMaWIuVGNwVHJhbnNwb3J0U2Vzc2lvbih1cmwsIGV2ZW50Q0IsIGNsaWVudCwgcHJvcHMsIGdldElkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJUcmFuc3BvcnQodXJsLCBldmVudENCLCBjbGllbnQsIHByb3BzLCBnZXRJZCk7XG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UcmFuc3BvcnRGYWN0b3J5ID0gVHJhbnNwb3J0RmFjdG9yeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LWZhY3RvcnkuanMiLCJjb25zdCBXZWJUcmFuc3BvcnRzTGliID0gcmVxdWlyZSgnLi93ZWInKTtcbmNvbnN0IHsgTGF6eSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVza2l0Jyk7XG5jb25zdCB7IExPR19UUkFDRSB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWxvZycpO1xuY29uc3QgeyBUcmFuc3BvcnRCYXNlIH0gPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1iYXNlJyk7XG5jb25zdCB7IFRyYW5zcG9ydFByb3RvY29sIH0gPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcblxuY29uc3QgeyBsYXp5VmFsdWUgfSA9IExhenk7XG5cbi8vIERlZmluZSB0cmFuc3BvcnRQcm90b2NvbCB0byB0cmFuc3BvcnQgbWFwcGluZ1xuY29uc3QgbHV0VHJhbnNwb3J0UHJvdG9jb2xzID0gbGF6eVZhbHVlKCgpID0+IHtcbiAgY29uc3QgcHJvdG9jb2xzID0ge1xuICAgIFtUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JBU0U2NF06ICAgICAgICAgICBXZWJUcmFuc3BvcnRzTGliLlN0YXRlQmFzZTY0LFxuICAgIFtUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV06ICAgICAgICAgICBXZWJUcmFuc3BvcnRzTGliLlN0YXRlQmluYXJ5LFxuICAgIFtUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV9TVFJFQU1JTkddOiBXZWJUcmFuc3BvcnRzTGliLlN0YXRlU3RyZWFtaW5nQW5kQmluYXJ5LFxuICAgIFtUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUlldOiAgICAgICAgICAgICBXZWJUcmFuc3BvcnRzTGliLlN0YXRlV2ViU29ja2V0QmluYXJ5LFxuICB9O1xuICByZXR1cm4gcHJvdG9jb2xzO1xufSk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSGFuZGxlcyB3ZWIgdHJhbnNwb3J0IHNlbGVjdGlvbiBhbmQgZG93bmdyYWRlIHdpdGhvdXQgY3JlYXRpbmcgdGhlIGFjdHVhbCB0cmFuc3BvcnRcbiAqIHNlc3Npb24gb2JqZWN0XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBUcmFuc3BvcnRQcm90b2NvbEhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdCkge1xuICAgIGNvbnN0IHVzZVNTTCA9IFRyYW5zcG9ydEJhc2UudXNlU3NsKHVybCk7XG4gICAgbGV0IHRyYW5zcG9ydCA9IG51bGw7XG4gICAgbGV0IGRvd25ncmFkZVRyYW5zcG9ydCA9IG51bGw7XG4gICAgd2ViVHJhbnNwb3J0UHJvdG9jb2xMaXN0LnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICBjb25zdCBUcmFuc3BvcnRDb25zdHJ1Y3RvciA9IGx1dFRyYW5zcG9ydFByb3RvY29scy52YWx1ZVtlbF07XG4gICAgICB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Q29uc3RydWN0b3IodXNlU1NMLCB0aGlzLnN3aXRjaFN0YXRlLmJpbmQodGhpcyksIGRvd25ncmFkZVRyYW5zcG9ydCk7XG4gICAgICBkb3duZ3JhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfSk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3RyYW5zcG9ydC5vbkVudGVyKCk7XG4gIH1cblxuICBnZXRUcmFuc3BvcnRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFRyYW5zcG9ydFByb3RvY29sKCk7XG4gIH1cblxuICBjb21wbGV0ZURvd25ncmFkZShlcnIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNvbXBsZXRlRG93bmdyYWRlKGVycik7XG4gIH1cblxuICBjYW5Db21wbGV0ZURvd25ncmFkZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RyYW5zcG9ydC5nZXROZXh0U3RhdGUoKSAhPT0gbnVsbCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnRvU3RyaW5nKCk7XG4gIH1cblxuICBzd2l0Y2hTdGF0ZShuZXdTdGF0ZSwgcmVhc29uKSB7XG4gICAgTE9HX1RSQUNFKGBTd2l0Y2hpbmcgJHt0aGlzLl90cmFuc3BvcnR9ID0+ICR7bmV3U3RhdGV9ICgke3JlYXNvbn0pYCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3U3RhdGU7XG4gICAgbmV3U3RhdGUub25FbnRlcigpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlRyYW5zcG9ydFByb3RvY29sSGFuZGxlciA9IFRyYW5zcG9ydFByb3RvY29sSGFuZGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvdHJhbnNwb3J0LXByb3RvY29sLWhhbmRsZXIuanMiLCJjb25zdCBEZWJ1Z0xpYiA9IHJlcXVpcmUoJ3NvbGNsaWVudC1kZWJ1ZycpO1xuY29uc3QgU01GTGliID0gcmVxdWlyZSgnc29sY2xpZW50LXNtZicpO1xuY29uc3QgeyBDaGVjayB9ID0gcmVxdWlyZSgnc29sY2xpZW50LXZhbGlkYXRlJyk7XG5jb25zdCB7IENvbnZlcnQsIEhleCB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWNvbnZlcnQnKTtcbmNvbnN0IHsgRXJyb3JTdWJjb2RlLCBPcGVyYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnc29sY2xpZW50LWVycm9yJyk7XG5jb25zdCB7IEhUVFBDb25uZWN0aW9uIH0gPSByZXF1aXJlKCcuL2h0dHAtY29ubmVjdGlvbicpO1xuY29uc3QgeyBMb2dGb3JtYXR0ZXIgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1sb2cnKTtcbmNvbnN0IHsgU01GQ2xpZW50IH0gPSByZXF1aXJlKCcuLi8uLi9zbWYtY2xpZW50Jyk7XG5jb25zdCB7IFRyYW5zcG9ydEVycm9yIH0gPSByZXF1aXJlKCcuLi8uLi90cmFuc3BvcnQtZXJyb3InKTtcbmNvbnN0IHsgVHJhbnNwb3J0UHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0UmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNwb3J0LXJldHVybi1jb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zcG9ydC1zZXNzaW9uLWV2ZW50Jyk7XG5jb25zdCB7IFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUgfSA9IHJlcXVpcmUoJy4uLy4uL3RyYW5zcG9ydC1zZXNzaW9uLWV2ZW50LWNvZGVzJyk7XG5jb25zdCB7IFRyYW5zcG9ydFNlc3Npb25TdGF0ZSB9ID0gcmVxdWlyZSgnLi4vLi4vdHJhbnNwb3J0LXNlc3Npb24tc3RhdGVzJyk7XG5jb25zdCB7IFdlYlRyYW5zcG9ydFNlc3Npb25CYXNlIH0gPSByZXF1aXJlKCcuLi93ZWItdHJhbnNwb3J0LXNlc3Npb24tYmFzZScpO1xuXG5jb25zdCB7IGludDMyVG9TdHIsIHN0clRvQnl0ZUFycmF5LCBzdHJUb0hleEFycmF5IH0gPSBDb252ZXJ0O1xuY29uc3QgeyBmb3JtYXRIZXhTdHJpbmcgfSA9IEhleDtcblxuY29uc3Qge1xuICBMT0dfVFJBQ0UsXG4gIExPR19ERUJVRyxcbiAgTE9HX0VSUk9SLFxuICBMT0dfSU5GTyxcbn0gPSBuZXcgTG9nRm9ybWF0dGVyKCdbaHR0cC10cmFuc3BvcnQtc2Vzc2lvbl0nKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWVzcGFjZSBWYWx1ZXMgZm9yIHRyYWNraW5nIGN1cnJlbnQgc3RhdGUgb2YgaW5jb21pbmcgc3RyZWFtaW5nIGRhdGFcbiAqL1xuY29uc3QgUGFja2V0UmVhZFN0YXRlID0ge1xuICBSRUFESU5HX0hFQURFUjogMCxcbiAgU1RSRUFNSU5HOiAgICAgIDEsXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IE1TSUVfVFJBTlNQT1JUX1BBRERJTkcgPSAyNTc7XG5cbmZ1bmN0aW9uIGFkYXB0VVJMKHVybCkge1xuICBjb25zdCB2ID0gdXJsLm1hdGNoKC8od3N8aHR0cCkocz86XFwvXFwvLispLyk7XG4gIHJldHVybiBgaHR0cCR7dlsyXX1gO1xufVxuXG4vKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBIVFRQVHJhbnNwb3J0U2Vzc2lvbiA6XG4gKlxuICogVGhpcyBjb250YWlucyBhbGwgZGF0YSBhbmQgY29kZSByZXF1aXJlZCB0byBtYWludGFpbiBIVFRQIHRyYW5zcG9ydCBzZXNzaW9uc1xuICogd2l0aCBTb2xhY2Ugcm91dGVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQGV4dGVuZHMgV2ViVHJhbnNwb3J0U2Vzc2lvbkJhc2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEhUVFBUcmFuc3BvcnRTZXNzaW9uIGV4dGVuZHMgV2ViVHJhbnNwb3J0U2Vzc2lvbkJhc2Uge1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsLCBldmVudENCLCBjbGllbnQsIHByb3BzKSB7XG4gICAgLy8gT3VyIGludGVybmFsIGRhdGEgZm9ybWF0IChmb3Igbm93KSBpcyBiaW5hcnkgc3RyaW5nLCBzbyB3ZSB3cmFwIHRoZSBjYWxsYmFja1xuICAgIC8vIGluIGEgZnVuY3Rpb24gdGhhdCBkb2VzIHRoZSByZXF1aXJlZCBjb252ZXJzaW9uIHRvIEFycmF5QnVmZmVyLlxuICAgIHN1cGVyKGJhc2VVcmwsXG4gICAgICAgICAgZXZlbnRDQixcbiAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgcHJvcHMpO1xuXG4gICAgLy8gY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgLy8gbG9nZ2VyLmZvcm1hdHRlciA9IGZ1bmN0aW9uIGZvcm1hdHRlciguLi5hcmdzKSB7XG4gICAgLy8gICByZXR1cm4gW3NlbGYuc2Vzc2lvbklkSGV4LCAuLi5hcmdzXTtcbiAgICAvLyB9O1xuXG4gICAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSB0aGUgZGF0YSB0b2tlbiB0aGF0IHdlIG5lZWQgZm9yIHNlbmRpbmcgZGF0YSB0byB0aGUgcm91dGVyXG4gICAgdGhpcy5faGF2ZVRva2VuID0gdHJ1ZTtcblxuICAgIC8vIE1heGltdW0gcGF5bG9hZCBjaHVuayBzaXplIGluIHdlYiB0cmFuc3BvcnRcbiAgICB0aGlzLl9jb25mTWF4V2ViUGF5bG9hZCA9IHByb3BzLm1heFdlYlBheWxvYWQ7XG4gICAgdGhpcy5fbWF4UGF5bG9hZEJ5dGVzID0gMDtcblxuICAgIC8vIFRpbWVyIHRoYXQgd2lsbCBrZWVwIHRyYWNrIG9mIHRoZSBkZXN0cm95IHRpbWVcbiAgICB0aGlzLl9kZXN0cm95VGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Rlc3Ryb3lUaW1lb3V0ID0gcHJvcHMuY29ubmVjdFRpbWVvdXRJbk1zZWNzO1xuXG4gICAgLy8gVGhlIFVSTCB1c2VkIGZvciBjcmVhdGUgbWVzc2FnZXNcbiAgICB0aGlzLl9jcmVhdGVVcmwgPSBhZGFwdFVSTChiYXNlVXJsKTtcblxuICAgIC8vIFRoZSBVUkwgdXNlZCBmb3IgYWxsIG90aGVyIG1lc3NhZ2VzIC0gaXQgd2lsbCBoYXZlIHRoZSByb3V0ZXIgdGFnIGFwcGVuZGVkXG4gICAgLy8gYWZ0ZXIgdGhlIHNlc3Npb24gaGFzIGJlZW4gY3JlYXRlZFxuICAgIHRoaXMuX3JvdXRlclVybCA9IHRoaXMuX2NyZWF0ZVVybDtcblxuICAgIC8vIFNNRiBjbGllbnQgKGluc3RhbnRpYXRlZCBhZnRlciBzZXNzaW9uIGlzIGNyZWF0ZWQpXG4gICAgdGhpcy5fcnhDaGFubmVsQ2xpZW50ID0gbnVsbDtcbiAgICAvLyBTZW5kIGRhdGEgY29ubmVjdGlvbiAoaW5zdGFudGlhdGVkIGFmdGVyIHNlc3Npb24gaXMgY3JlYXRlZClcbiAgICB0aGlzLl9odHRwU2VuZENvbm4gPSBudWxsO1xuXG4gICAgLy8gUmVjZWl2ZSBkYXRhIGNvbm5lY3Rpb24gKGluc3RhbnRpYXRlZCBhZnRlciBzZXNzaW9uIGlzIGNyZWF0ZWQpXG4gICAgdGhpcy5faHR0cFJlY2VpdmVDb25uID0gbnVsbDtcblxuICAgIC8vIERhdGEgVG9rZW4gU01GIGhlYWRlciAtIHRoaXMgaXMgcHJlZm9ybWF0dGVkIGZvciBwZXJmb3JtYW5jZVxuICAgIC8vIEl0IHdpbGwgYmUgc2V0IGFmdGVyIHNlc3Npb24gaXMgY3JlYXRlZFxuICAgIHRoaXMuX3NtZkRhdGFUb2tlblRTSGVhZGVyID0gbnVsbDtcblxuICAgIC8vIFJvdXRlciBUYWcgLSBhIHN0cmluZyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gSFRUUCByZXF1ZXN0IFVSTHNcbiAgICB0aGlzLl9yb3V0ZXJUYWcgPSAnJztcblxuICAgIC8vIFNlc3Npb24gSUQgLSA4LWJ5dGUgaWRlbnRpZmllciB0aGF0IHdpbGwgYXNzb2NpYXRlIHRoaXMgY2xpZW50XG4gICAgLy8gd2l0aCBjbGllbnQgcmVzb3VyY2VzIG9uIHRoZSByb3V0ZXJcbiAgICB0aGlzLl9zaWQgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLnRyYW5zcG9ydFByb3RvY29sID09PSBudWxsIHx8IHByb3BzLnRyYW5zcG9ydFByb3RvY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcigndHJhbnNwb3J0UHJvdG9jb2wgaXMgbm90IHNldCcsIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRQcm90b2NvbCA9IHByb3BzLnRyYW5zcG9ydFByb3RvY29sO1xuICAgIHRoaXMuX3VzZUJpbmFyeVRyYW5zcG9ydCA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVN0cmVhbWluZ1RyYW5zcG9ydCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0cmVhbWluZ1RyYW5zcG9ydFBhZGRpbmcgPSAwO1xuXG4gICAgdGhpcy5fdXNlQmluYXJ5VHJhbnNwb3J0ID0gKHByb3BzLnRyYW5zcG9ydFByb3RvY29sICE9PSBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JBU0U2NCk7XG4gICAgdGhpcy5fdXNlU3RyZWFtaW5nVHJhbnNwb3J0ID0gKHByb3BzLnRyYW5zcG9ydFByb3RvY29sID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV9TVFJFQU1JTkcpO1xuXG4gICAgLy8gZXh0cmEgc3RhdGUgZm9yIFNUUkVBTUlORyB0cmFuc3BvcnRcbiAgICB0aGlzLl9pbmNvbWluZ0J1ZmZlciA9ICcnO1xuICAgIHRoaXMuX3BhY2tldFJlYWRTdGF0ZSA9IFBhY2tldFJlYWRTdGF0ZS5SRUFESU5HX0hFQURFUjtcblxuICAgIGNvbnN0IGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICBpZiAoYWdlbnQubWF0Y2goL3RyaWRlbnQvaSkgfHwgYWdlbnQubWF0Y2goL21zaWUvaSkpIHtcbiAgICAgIHRoaXMuX3N0cmVhbWluZ1RyYW5zcG9ydFBhZGRpbmcgPSBNU0lFX1RSQU5TUE9SVF9QQURESU5HO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy50cmFuc3BvcnRDb250ZW50VHlwZSA9PT0gbnVsbCB8fCBwcm9wcy50cmFuc3BvcnRDb250ZW50VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoJ3RyYW5zcG9ydENvbnRlbnRUeXBlIGlzIG5vdCBzZXQnLCBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gcHJvcHMudHJhbnNwb3J0Q29udGVudFR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb25uZWN0VGltZXJFeHBpcnkoKSB7XG4gICAgTE9HX0lORk8oJ0hUVFAgdHJhbnNwb3J0IGNvbm5lY3QgdGltZW91dCcpO1xuICAgIHRoaXMuZGVzdHJveUNsZWFudXAoJ0hUVFAgdHJhbnNwb3J0IGNvbm5lY3QgdGltZW91dCcsIEVycm9yU3ViY29kZS5USU1FT1VUKTtcbiAgfVxuXG4gIGdldCBzZXNzaW9uSWRIZXgoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9zaWQpID8gZm9ybWF0SGV4U3RyaW5nKHRoaXMuX3NpZCkgOiAnJztcbiAgfVxuXG4gIHVwZGF0ZU1heFdlYlBheWxvYWQoKSB7XG4gICAgLy8gMjIgQnl0ZXMgb2YgVHJhbnNwb3J0U01GIHdyYXBwaW5nIG92ZXJoZWFkXG4gICAgY29uc3QgdHJMZXNzRW5jYXBTTUYgPSB0aGlzLl9jb25mTWF4V2ViUGF5bG9hZCAtIDIyO1xuICAgIC8vIEJhc2U2NCBoYXMgYSA0OjMgZXhwYW5zaW9uXG4gICAgdGhpcy5fbWF4UGF5bG9hZEJ5dGVzID0gdGhpcy5fdXNlQmluYXJ5VHJhbnNwb3J0XG4gICAgICA/IHRyTGVzc0VuY2FwU01GXG4gICAgICA6IE1hdGguZmxvb3IodHJMZXNzRW5jYXBTTUYgKiAwLjc1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRyYW5zcG9ydCBzZXNzaW9uIHRvIHJvdXRlclxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIC8vIENoZWNrIHRoYXQgd2Ugd2UgYXJlIGluIGFuIGFjY2VwdGFibGUgc3RhdGUgZm9yIGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5ET1dOKSB7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5JTlZBTElEX1NUQVRFX0ZPUl9PUEVSQVRJT047XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdEludGVybmFsKCk7XG4gIH1cblxuICBjb25uZWN0SW50ZXJuYWwoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBYSFIgdG8gdGFsayB0byB0aGUgcm91dGVyXG4gICAgdGhpcy5fY29ubkVycm9yID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fY3JlYXRlQ29ubiA9IG5ldyBIVFRQQ29ubmVjdGlvbih0aGlzLl9jcmVhdGVVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEodGhpcy5fdXNlQmluYXJ5VHJhbnNwb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyYywgZGF0YSkgPT4gdGhpcy5oYW5kbGVDcmVhdGVSZXNwb25zZShyYywgZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyYywgZGF0YSkgPT4gdGhpcy5oYW5kbGVDcmVhdGVDb25uRmFpbHVyZShyYywgZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMT0dfSU5GTyhgRmFpbGVkIHRvIGNyZWF0ZSBjb25uZWN0aW9uIHRvIHJvdXRlcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLl9jb25uRXJyb3IgPSBlO1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuQ09OTkVDVElPTl9FUlJPUjtcbiAgICB9XG4gICAgaWYgKENoZWNrLm5vdGhpbmcodGhpcy5fY3JlYXRlQ29ubikpIHtcbiAgICAgIExPR19JTkZPKCdGYWlsZWQgdG8gY3JlYXRlIGNvbm5lY3Rpb24gdG8gcm91dGVyJyk7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5DT05ORUNUSU9OX0VSUk9SO1xuICAgIH1cblxuICAgIC8vIEdldCBhbiBTTUYgdHJhbnNwb3J0IHNlc3Npb24gY3JlYXRlIG1lc3NhZ2VcbiAgICBjb25zdCBjcmVhdGVNc2cgPSBTTUZMaWIuQ29kZWMuVHJhbnNwb3J0LmdlblRzQ3JlYXRlSGVhZGVyKCk7XG5cbiAgICAvLyBUT0RPOiBXaGF0IGlzIGdvaW5nIG9uIGhlcmU/ICBJZiB3ZSBhcmUgYWxyZWFkeSB3YWl0aW5nIGZvciBjcmVhdGVcbiAgICAvLyBUT0RPOiB3ZSBqdXN0IHNraXAgc3RhcnRpbmcgdGhlIHRpbWVyIGJ1dCBvdGhlciBkbyBldmVyeXRoaW5nIGVsc2UsIG92ZXJ3cml0aW5nXG4gICAgLy8gVE9ETzogX2NyZWF0ZUNvbm4gaW4gdGhlIHByb2Nlc3Mgd2l0aCBhIG5ldyBYTUxIVFRQUmVxdWVzdCBvYmplY3Q/XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfQ1JFQVRFKSB7XG4gICAgICAvLyBhbHJlYWR5IGNvbm5lY3RpbmcgKHRoaXMgaXMgbGlrZWx5IGEgcmV0cnkgd2l0aCBCYXNlNjQgZW5jb2RpbmcpXG4gICAgICBMT0dfREVCVUcoJ0Nvbm5lY3QgYXR0ZW1wdCB3aGlsZSBpbiBXQUlUSU5HX0ZPUl9DUkVBVEUgKHJldHJ5KScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZUNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0NSRUFURTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSBjcmVhdGUgbWVzc2FnZSB0byB0aGUgcm91dGVyLiAgV2hlbiB0aGUgcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIHRoZVxuICAgIC8vIGhhbmRsZUNyZWF0ZVJlc3BvbnNlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZFxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jcmVhdGVDb25uLnNlbmQoY3JlYXRlTXNnKTtcbiAgICB9IGNhdGNoIChjb25uRXJyb3IpIHtcbiAgICAgIExPR19ERUJVRyhgRXJyb3IgY29ubmVjdGluZzogJHtjb25uRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIExPR19UUkFDRSgnRXJyb3IgZGV0YWlsczonLCBjb25uRXJyb3Iuc3RhY2sgfHwgY29ubkVycm9yKTtcbiAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkNPTk5FQ1RJT05fRkFJTEVEO1xuICAgICAgdGhpcy5jYW5jZWxDb25uZWN0VGltZW91dCgpO1xuICAgICAgaWYgKGNvbm5FcnJvciBpbnN0YW5jZW9mIFRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5FcnJvciA9IGNvbm5FcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Nvbm5FcnJvciA9IG5ldyBUcmFuc3BvcnRFcnJvcihcbiAgICAgICAgICBgQ291bGQgbm90IGNyZWF0ZSBIVFRQIHRyYW5zcG9ydCBzZXNzaW9uOiAke2Nvbm5FcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgY29ubkVycm9yLnN1YmNvZGUgfHwgRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuQ09OTkVDVElPTl9FUlJPUjtcbiAgICB9XG5cbiAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRyYW5zcG9ydCBzZXNzaW9uIHRvIHJvdXRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIFRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JTdWJjb2RlfSBzdWJjb2RlIFRoZSBzdWJjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGRlc3Ryb3kobXNnLCBzdWJjb2RlKSB7XG4gICAgTE9HX1RSQUNFKGBEZXN0cm95IHRyYW5zcG9ydCBzZXNzaW9uIHdoZW4gaW4gc3RhdGUgJHt0aGlzLl9zdGF0ZX1gKTtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5XQUlUSU5HX0ZPUl9ERVNUUk9ZIHx8XG4gICAgICAgIHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTikge1xuICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuQ09OTkVDVElPTl9GQUlMRUQgfHxcbiAgICAgICAgdGhpcy5fc3RhdGUgPT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5XQUlUSU5HX0ZPUl9DUkVBVEUpIHtcbiAgICAgIC8vIFRoZSBjb25uZWN0aW9ucyBhcmUgaW4gYW4gdW5yZWxpYWJsZSBzdGF0ZSAtIHdlIHdpbGwganVzdFxuICAgICAgLy8ga2lsbCBvdXIgbG9jYWwgb2JqZWN0IGFuZCBsZXQgdGhlIHJvdXRlciBjbGVhbiBpdHNlbGYgdXAgd2l0aCBpdHMgaW5hY3Rpdml0eSB0aW1lclxuICAgICAgTE9HX0RFQlVHKCdUaGUgY29ubmVjdGlvbiBpcyBpbiB1bnJlbGlhYmxlIHN0YXRlLCBjbG9zZSB0cmFuc3BvcnQnKTtcbiAgICAgIHRoaXMuZGVzdHJveUNsZWFudXAobXNnLCBzdWJjb2RlLCB0cnVlKTtcbiAgICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICAgIH1cblxuICAgIExPR19ERUJVRygnRGVzdHJveSB0cmFuc3BvcnQgc2Vzc2lvbiBpbW1lZGlhdGVseScpO1xuICAgIC8vIFNldCB0aGUgY3VycmVudCBzdGF0ZVxuICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0RFU1RST1k7XG5cbiAgICAvLyBBYm9ydCBhbnkgY3VycmVudCByZXF1ZXN0cyBmb3IgdGhpcyBzZXNzaW9uXG4gICAgaWYgKHRoaXMuX2h0dHBTZW5kQ29ubiAhPT0gbnVsbCkge1xuICAgICAgTE9HX0RFQlVHKCdEZXN0cm95IHRyYW5zcG9ydCBzZXNzaW9uOiBhYm9ydCBzZW5kQ29ubicpO1xuICAgICAgdGhpcy5faHR0cFNlbmRDb25uLmFib3J0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9odHRwUmVjZWl2ZUNvbm4gIT09IG51bGwpIHtcbiAgICAgIExPR19ERUJVRygnRGVzdHJveSB0cmFuc3BvcnQgc2Vzc2lvbjogYWJvcnQgcmVjZWl2ZUNvbm4nKTtcbiAgICAgIHRoaXMuX2h0dHBSZWNlaXZlQ29ubi5hYm9ydCgpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IGEgdGltZXJcbiAgICB0aGlzLl9kZXN0cm95VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveVRpbWVyRXhwaXJ5KCk7XG4gICAgfSwgdGhpcy5fZGVzdHJveVRpbWVvdXQpO1xuXG4gICAgLy8gU2VuZCB0aGUgZGVzdHJveSBtZXNzYWdlIG92ZXIgbmV3IEhUVFBDb25uZWN0aW9uIHRvIHRoZSByb3V0ZXIgc28gdGhhdCB0aGUgYXN5bmMgYWJvcnRcbiAgICAvLyBjYW4gcHJvcGVybHkgZmluaXNoIGluIHRoZSBvbGQgX2h0dHBTZW5kQ29ubi5cbiAgICAvLyBXaGVuIHRoZSByZXNwb25zZSBpcyByZWNlaXZlZCwgdGhlIGhhbmRsZURlc3Ryb3lSZXNwb25zZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuXG4gICAgdGhpcy5faHR0cFNlbmRDb25uID0gbmV3IEhUVFBDb25uZWN0aW9uKFxuICAgICAgICB0aGlzLl9yb3V0ZXJVcmwsXG4gICAgICAgICEodGhpcy5fdXNlQmluYXJ5VHJhbnNwb3J0KSwgZmFsc2UsXG4gICAgICAgIChyYywgZGF0YSkgPT4gdGhpcy5oYW5kbGVSeERhdGFUb2tlbihyYywgZGF0YSksIC8vIFJ4RGF0YSBjYWxsYmFja1xuICAgICAgICAocmMsIGRhdGEpID0+IHRoaXMuaGFuZGxlU2VuZEZhaWx1cmUocmMsIGRhdGEpLCAvLyBjb25uZWN0aW9uIGNsb3NlIG9yIGVycm9yIGNhbGxiYWNrXG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlLFxuICAgICAgICB0cnVlKTtcblxuICAgIC8vIEdldCBhbiBTTUYgdHJhbnNwb3J0IHNlc3Npb24gZGVzdHJveSBtZXNzYWdlXG4gICAgY29uc3QgZGVzdHJveU1zZyA9IFNNRkxpYi5Db2RlYy5UcmFuc3BvcnQuZ2VuVHNEZXN0cm95SGVhZGVyKHRoaXMuX3NpZCk7XG5cbiAgICBMT0dfVFJBQ0UoYGRlc3Ryb3kgbWVzc2FnZTogJHtzdHJUb0hleEFycmF5KGRlc3Ryb3lNc2cpfWApO1xuICAgIHRoaXMuX2h0dHBTZW5kQ29ubi5zZW5kKGRlc3Ryb3lNc2cpO1xuXG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBkYXRhIG92ZXIgdGhlIGNvbm5lY3Rpb24gLSB0aGlzIHJlcXVpcmVzIGEgc2VuZCB0b2tlblxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUluIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBbGxvd0VucXVldWU9ZmFsc2VdIElmIGB0cnVlYCwgZG8gbm90IGZhaWwgZHVlIHRvIG91dCBvZiBzcGFjZVxuICAgKiBAcmV0dXJucyB7VHJhbnNwb3J0UmV0dXJuQ29kZX0gVGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBzZW5kKGRhdGFJbiwgZm9yY2VBbGxvd0VucXVldWUgPSBmYWxzZSkge1xuICAgIGxldCBkYXRhID0gZGF0YUluO1xuICAgIC8vIExPR19UUkFDRShgSFRUUFRyYW5zcG9ydFNlc3Npb246c2VuZCAke2RhdGEubGVuZ3RofSwgdHhfcXVldWVkOiR7dGhpcy5fcXVldWVkRGF0YVNpemV9YCk7XG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuU0VTU0lPTl9VUCkge1xuICAgICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuSU5WQUxJRF9TVEFURV9GT1JfT1BFUkFUSU9OO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgcXVldWVkIGRhdGFcbiAgICBpZiAoKHRoaXMuX3F1ZXVlZERhdGEubGVuZ3RoID4gMCkgfHwgKCF0aGlzLl9oYXZlVG9rZW4pKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlRGF0YShkYXRhLCBmb3JjZUFsbG93RW5xdWV1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjaG9wIHVwIHRoZSBwYXlsb2FkXG4gICAgbGV0IHJlbWFpbmRlciA9IG51bGw7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZEJ5dGVzKSB7XG4gICAgICByZW1haW5kZXIgPSBkYXRhLnN1YnN0cih0aGlzLl9tYXhQYXlsb2FkQnl0ZXMpO1xuICAgICAgZGF0YSA9IGRhdGEuc3Vic3RyKDAsIHRoaXMuX21heFBheWxvYWRCeXRlcyk7XG5cbiAgICAgIC8vIElmIG5vIHNwYWNlIGZvciByZW1haW5kZXIsIHJldHVybiBGQUlMIHdpdGhvdXQgc2VuZGluZyBhbnl0aGluZy5cbiAgICAgIGlmICghdGhpcy5hbGxvd0VucXVldWUocmVtYWluZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZUZhaWxOb1NwYWNlKCk7XG4gICAgICB9XG5cbiAgICAvLyBMT0dfREVCVUcoXCIkJCBzZW5kIGRhdGFDaHVuazpcIiArIGRhdGEubGVuZ3RoICsgXCIsIHJlbWFpbmRlckNodW5rOlwiICsgcmVtYWluZGVyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSB0aGUgdG9rZW4sIHNvIHNlbmQgdGhlIGRhdGFcbiAgICB0aGlzLl9oYXZlVG9rZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IHRyYW5zcG9ydFBhY2tldExlbiA9ICh0aGlzLl9zbWZEYXRhVFNIZWFkZXJQYXJ0c1swXS5sZW5ndGggKyA0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc21mRGF0YVRTSGVhZGVyUGFydHNbMV0ubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuXG4gICAgdGhpcy5faHR0cFNlbmRDb25uLnNlbmQodGhpcy5fc21mRGF0YVRTSGVhZGVyUGFydHNbMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludDMyVG9TdHIodHJhbnNwb3J0UGFja2V0TGVuKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc21mRGF0YVRTSGVhZGVyUGFydHNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEpO1xuICAgIHRoaXMuX2NsaWVudHN0YXRzLmJ5dGVzV3JpdHRlbiArPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChyZW1haW5kZXIpIHtcbiAgICAgIC8vIFRoZSBtZXNzYWdlIHdhcyBwYXJ0aWFsbHkgc2VudC4gVGhlIG1lc3NhZ2Ugd3JpdHRlbiBjb3VudCB3aWxsIGJlIGluY3JlbWVudGVkXG4gICAgICAvLyB3aGVuIGl0cyBsYXN0IGJ5dGVzIGdvIG91dC5cbiAgICAgIHJldHVybiB0aGlzLmVucXVldWVEYXRhKHJlbWFpbmRlciwgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHdob2xlIG1lc3NhZ2Ugd2FzIHNlbnQuXG4gICAgdGhpcy5fY2xpZW50c3RhdHMubXNnV3JpdHRlbisrO1xuICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggZGF0YSBvbnRvIHRoZSBwZW5kaW5nIHNlbmQgcXVldWUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IHZpb2xhdGVcbiAgICogdGhlIG1heCBzdG9yZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGVucXVldWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VBbGxvd0VucXVldWU9ZmFsc2VdIElmIGB0cnVlYCwgZG9uJ3QgZmFpbCBkdWUgdG8gbm8gc3BhY2UuXG4gICAqIEByZXR1cm5zIHtUcmFuc3BvcnRSZXR1cm5Db2RlfSBUaGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb24uXG4gICAqL1xuICBlbnF1ZXVlRGF0YShkYXRhLCBmb3JjZUFsbG93RW5xdWV1ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgLy8gTE9HX0RFQlVHKFwiZW5xdWV1ZWluZyBkYXRhOiBcIiArIGRhdGEubGVuZ3RoICsgXCIsIHF1ZXVlIGRlcHRoOiBcIiArIHRoaXMuX3F1ZXVlZERhdGFTaXplKTtcbiAgICBpZiAoZm9yY2VBbGxvd0VucXVldWUgfHwgdGhpcy5hbGxvd0VucXVldWUoZGF0YUxlbikpIHtcbiAgICAgIHRoaXMuX3F1ZXVlZERhdGFTaXplICs9IGRhdGFMZW47XG4gICAgICB0aGlzLl9xdWV1ZWREYXRhLnB1c2goZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVucXVldWVGYWlsTm9TcGFjZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGF0YSBpbiB0aGUgcHJlZm9ybWF0dGVkIGhlYWRlcnMuICBUaGUgaGVhZGVycyBhcmUgc2V0IHVwIHRoaXMgd2F5XG4gICAqIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaWQgVGhlIHNlc3Npb24gSUQgdG8gaW5jb3Jwb3JhdGUgaW50byB0aGUgaGVhZGVyc1xuICAgKi9cbiAgaW5pdFByZWZvcm1hdHRlZEhlYWRlcnMoc2lkKSB7XG4gICAgLy8gX3NtZkRhdGFUU0hlYWRlclBhcnRzIGlzIGEgdHdvIGVudHJ5IGFycmF5IC0gb25lIHBhcnQgYmVmb3JlIHRoZSB0b3RhbCBsZW5ndGhcbiAgICAvLyBhbmQgdGhlIG90aGVyIGFmdGVyLiAgVGhlIHRvdGFsIGxlbmd0aCBpcyBub3Qga25vd24gdW50aWwgYWN0dWFsIGRhdGEgaXMgc2VudFxuICAgIHRoaXMuX3NtZkRhdGFUU0hlYWRlclBhcnRzID0gU01GTGliLkNvZGVjLlRyYW5zcG9ydC5nZW5Uc0RhdGFNc2dIZWFkZXJQYXJ0cyhzaWQpO1xuXG4gICAgLy8gX3NtZkRhdGFUb2tlblRTSGVhZGVyIGlzIGEgc2luZ2xlIGhlYWRlciB0aGF0IGFsbCBkYXRhLXRva2VuIG1lc3NhZ2VzIHJlcXVpcmVcbiAgICBpZiAodGhpcy5fdXNlU3RyZWFtaW5nVHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl9zbWZEYXRhVG9rZW5UU0hlYWRlciA9IFNNRkxpYi5Db2RlYy5UcmFuc3BvcnQuZ2VuVHNEYXRhU3RyZWFtVG9rZW5Nc2coXG4gICAgICAgIHNpZCxcbiAgICAgICAgdGhpcy5fc3RyZWFtaW5nVHJhbnNwb3J0UGFkZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NtZkRhdGFUb2tlblRTSGVhZGVyID0gU01GTGliLkNvZGVjLlRyYW5zcG9ydC5nZW5Uc0RhdGFUb2tlbk1zZyhzaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGZsdXNoKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZERhdGFTaXplKSB7XG4gICAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZXJlIGlzIGFueSBkYXRhIHdhaXRpbmcgdG8gYmUgc2VudCB0byB0aGUgcm91dGVyLlxuICAgKiBJZiB0aGVyZSBpcywgc2VuZCBpdC5cbiAgICovXG4gIHNlbmRRdWV1ZWREYXRhKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWREYXRhU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9oYXZlVG9rZW4gPSBmYWxzZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRRdWV1ZWREYXRhVG9TZW5kKCk7XG4gICAgY29uc3QgdHJhbnNwb3J0UGFja2V0TGVuID0gdGhpcy5fc21mRGF0YVRTSGVhZGVyUGFydHNbMF0ubGVuZ3RoICsgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc21mRGF0YVRTSGVhZGVyUGFydHNbMV0ubGVuZ3RoICsgZGF0YS5sZW5ndGg7XG5cbiAgICB0aGlzLl9odHRwU2VuZENvbm4uc2VuZCh0aGlzLl9zbWZEYXRhVFNIZWFkZXJQYXJ0c1swXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50MzJUb1N0cih0cmFuc3BvcnRQYWNrZXRMZW4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zbWZEYXRhVFNIZWFkZXJQYXJ0c1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgdGhpcy5fY2xpZW50c3RhdHMuYnl0ZXNXcml0dGVuICs9IGRhdGEubGVuZ3RoO1xuXG5cbiAgICBpZiAodGhpcy5fY2FuU2VuZE5lZWRlZCkge1xuICAgICAgdGhpcy5fY2FuU2VuZE5lZWRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZXZlbnRDQihcbiAgICAgICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLkNBTl9BQ0NFUFRfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lkKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsdXNoQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gdGhpcy5fZmx1c2hDYWxsYmFjaztcbiAgICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBDYWxsYmFja3NcblxuICAvLyBDYWxsZWQgd2hlbiBhIGNyZWF0ZSByZXNwb25zZSBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkXG4gIGhhbmRsZUNyZWF0ZVJlc3BvbnNlKHRzUmMsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSB8fFxuICAgICAgICB0aGlzLl9zdGF0ZSA9PT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkRPV04pIHtcbiAgICAgIExPR19ERUJVRygnUmVjZWl2ZWQgY3JlYXRlIHJlc3BvbnNlIG9uIGEgZGVzdHJveWVkIHRyYW5zcG9ydCBzZXNzaW9uLCBpZ25vcmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXYXM6IHN0b3AgdGhlIGNvbm5lY3QgdGltZXIuIFdlIGRvbid0IGRvIHRoYXQgaW4gdGhpcyB0cmFuc3BvcnQgbm93LlxuICAgIC8vIFdlIHdhaXQgZm9yIHRoZSBsb2dpbiByZXNwb25zZS5cblxuICAgIC8vIFdlIGtub3cgd2hldGhlciB3ZSdyZSB1c2luZyBCYXNlNjQgb3Igbm90LCBzbyB1cGRhdGUgb3VyIG1heCBwYXlsb2FkIHNpemUuXG4gICAgdGhpcy51cGRhdGVNYXhXZWJQYXlsb2FkKCk7XG5cbiAgICBpZiAodHNSYyAhPT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgTE9HX0RFQlVHKGBSZWNlaXZlZCBjcmVhdGUgcmVzcG9uc2Ugd2l0aCByZXR1cm4gY29kZSAke1RyYW5zcG9ydFJldHVybkNvZGUuZGVzY3JpYmUodHNSYyl9YCk7XG4gICAgICBpZiAodHNSYyA9PT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5EQVRBX0RFQ09ERV9FUlJPUikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lDbGVhbnVwKCdSZWNlaXZlZCBkYXRhIGRlY29kZSBlcnJvciBvbiBjcmVhdGUgc2Vzc2lvbiByZXNwb25zZScsIEVycm9yU3ViY29kZS5EQVRBX0RFQ09ERV9FUlJPUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3lDbGVhbnVwKCdGYWlsZWQgdG8gaGFuZGxlIGNyZWF0ZSBzZXNzaW9uIHJlc3BvbnNlJywgRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gbnVsbCByZWFkIGluZGljYXRpbmcgZW5kIG9mIHN0cmVhbVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSBUcmFuc3BvcnQgU2Vzc2lvbiBTTUZcbiAgICBjb25zdCBwYXJzZWRSZXNwb25zZSA9IFNNRkxpYi5Db2RlYy5EZWNvZGUuZGVjb2RlQ29tcG91bmRNZXNzYWdlKHJlc3BvbnNlLCAwKTtcblxuICAgIGlmICghcGFyc2VkUmVzcG9uc2UpIHtcbiAgICAgIExPR19FUlJPUignQ291bGQgbm90IHBhcnNlIGNyZWF0ZSByZXNwb25zZSBhcyBTTUYuIERlc3Ryb3lpbmcgdHJhbnNwb3J0Jyk7XG4gICAgICB0aGlzLmRlc3Ryb3lDbGVhbnVwKCdGYWlsZWQgdG8gcGFyc2UgY3JlYXRlIHJlc3BvbnNlIG1lc3NhZ2UnLCBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc21mcmVzcG9uc2UgPSBwYXJzZWRSZXNwb25zZS5nZXRSZXNwb25zZSgpO1xuICAgIGlmIChzbWZyZXNwb25zZS5yZXNwb25zZUNvZGUgIT09IDIwMCkge1xuICAgICAgdGhpcy5kZXN0cm95Q2xlYW51cChgVHJhbnNwb3J0IGNyZWF0ZSByZXF1ZXN0IGZhaWxlZCAoJHtzbWZyZXNwb25zZS5yZXNwb25zZUNvZGV9LCAke3NtZnJlc3BvbnNlLnJlc3BvbnNlU3RyaW5nfSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYW5jZWxDb25uZWN0VGltZW91dCgpO1xuICAgIHRoaXMuX2NyZWF0ZUNvbm4uYWJvcnQoKTtcbiAgICB0aGlzLl9jcmVhdGVDb25uID0gbnVsbDtcbiAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5TRVNTSU9OX1VQO1xuICAgIHRoaXMuX3NpZCA9IHBhcnNlZFJlc3BvbnNlLnNlc3Npb25JZDtcbiAgICB0aGlzLl9yb3V0ZXJUYWcgPSBwYXJzZWRSZXNwb25zZS5yb3V0ZXJUYWc7XG5cbiAgICAvLyBUcmltIGFueSBwYXJhbWV0ZXJzIG9mZiB0aGUgY3JlYXRlIHVybCBiZWZvcmUgdXNpbmcgaXQgZm9yIHRoZSByb3V0ZXJVcmxcbiAgICB0aGlzLl9yb3V0ZXJVcmwgPSB0aGlzLl9jcmVhdGVVcmwucmVwbGFjZSgvXFw/LiovLCAnJyk7XG4gICAgaWYgKHRoaXMuX3JvdXRlclRhZyAhPT0gJycpIHtcbiAgICAgIHRoaXMuX3JvdXRlclVybCA9IHRoaXMuX3JvdXRlclVybCArIHRoaXMuX3JvdXRlclRhZztcbiAgICB9XG5cbiAgICB0aGlzLmluaXRQcmVmb3JtYXR0ZWRIZWFkZXJzKHRoaXMuX3NpZCk7XG4gICAgY29uc3QgdXNlQmFzZTY0ID0gIXRoaXMuX3VzZUJpbmFyeVRyYW5zcG9ydDtcbiAgICBjb25zdCB1c2VTdHJlYW1pbmcgPSB0aGlzLl91c2VTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHR3byBjb25uZWN0aW9ucyB0byB0aGUgcm91dGVyXG4gICAgLy8gQnkgbm93LCBnZXRYaHJPYmooKSBzaG91bGQgbm90IHRocm93IGFueSBleGNlcHRpb24gaW5zaWRlIEhUVFBDb25uZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgdGhpcy5faHR0cFNlbmRDb25uID0gbmV3IEhUVFBDb25uZWN0aW9uKHRoaXMuX3JvdXRlclVybCwgdXNlQmFzZTY0LCBmYWxzZSxcbiAgICAgICAgKHJjLCBkYXRhKSA9PiB0aGlzLmhhbmRsZVJ4RGF0YVRva2VuKHJjLCBkYXRhKSwgLy8gUnhEYXRhIGNhbGxiYWNrXG4gICAgICAgIChyYywgZGF0YSkgPT4gdGhpcy5oYW5kbGVTZW5kRmFpbHVyZShyYywgZGF0YSksIC8vIGNvbm5lY3Rpb24gY2xvc2Ugb3IgZXJyb3IgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5fY29udGVudFR5cGUpO1xuICAgIGlmICh0aGlzLl91c2VTdHJlYW1pbmdUcmFuc3BvcnQpIHtcbiAgICAgIC8vIFdoZW4gdGhlIHRyYW5zcG9ydCBpcyBIVFRQX0JJTkFSWV9TVFJFQU1JTkcgdGhlIFNNRiBlbmNhcHN1bGF0aW9uXG4gICAgICAvLyBpcyBjb21wbGV0ZSwgdGhlIFNNRiBoZWFkZXIgaW5kaWNhdGVzIGEgbWVzc2FnZSBsZW5ndGggb2YgMHhGRkZGRkZGRlxuICAgICAgLy8gYW5kIGFmdGVyIGRlY29kaW5nIGp1c3QgdGhlIGhlYWRlciBhbG9uZSB0aGUgZGF0YSBpcyBwYXNzZWQgdGhyb3VnaFxuICAgICAgLy8gdG8gdGhlIHNlc3Npb24gbGF5ZXIsIHNvIHdlIG11c3QgdXNlIGEgc2ltcGxpZmllZCBTTUYgcGFyc2VyIGFuZCBhXG4gICAgICAvLyBzdGF0ZWZ1bCBkYXRhIGNhbGxiYWNrIGluIHRoYXQgY2FzZS5cbiAgICAgIHRoaXMuX2h0dHBSZWNlaXZlQ29ubiA9IG5ldyBIVFRQQ29ubmVjdGlvbih0aGlzLl9yb3V0ZXJVcmwsIHVzZUJhc2U2NCwgdXNlU3RyZWFtaW5nLFxuICAgICAgICAgICAgKHJjLCBkYXRhKSA9PiB0aGlzLmhhbmRsZVJ4U3RyZWFtaW5nKHJjLCBkYXRhKSwgLy8gUnhEYXRhIENhbGxiYWNrXG4gICAgICAgICAgICAocmMsIGRhdGEpID0+IHRoaXMuaGFuZGxlU2VuZEZhaWx1cmUocmMsIGRhdGEpLCAvLyBjb25uZWN0aW9uIGNsb3NlIG9yIGVycm9yIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50VHlwZSxcbiAgICAgICAgICAgIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBTTUYgY2xpZW50IGZvciB0aGUgUmVjZWl2ZSBEYXRhIGNoYW5uZWwsIHdoZW4gaHR0cCBpcyB1c2VkLlxuICAgICAgLy8gU01GIG1lc3NhZ2VzIGFyZSBlbmNhcHN1YWxhdGVkIGluIGEgc29sYWNlIGh0dHAtdHJhbnNwb3J0IHdoaWNoIGlzIGl0c2VsZlxuICAgICAgLy8gZW5jYXBzdWxhdGVkIGluIFNNRi4gIFNvIGNyZWF0ZSBhbiBTTUYgY2xpZW50IHRoYXQgd2lsbCBjYWxsYmFjayB3aXRoXG4gICAgICAvLyBhbiBzbWZNZXNzYWdlIGNvbnN0cnVjdCB0byB0aGUgSFRUUFRyYW5zcG9ydFNlc3Npb24uXG4gICAgICB0aGlzLl9yeENoYW5uZWxDbGllbnQgPSBuZXcgU01GQ2xpZW50KFxuICAgICAgICAgICAgcnhEYXRhID0+IHRoaXMuaGFuZGxlU21mTWVzc2FnZShyeERhdGEpLFxuICAgICAgICAgICAgcnhFcnJvciA9PiB0aGlzLmhhbmRsZVNtZlBhcnNlRXJyb3IocnhFcnJvciksXG4gICAgICAgICAgICBudWxsKTsgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhICdzZXNzaW9uJyBmb3IgdGhpcyBjbGllbnQuIEl0J3MganVzdCBhIHBhcnNlci5cbiAgICAgIHRoaXMuX2h0dHBSZWNlaXZlQ29ubiA9IG5ldyBIVFRQQ29ubmVjdGlvbih0aGlzLl9yb3V0ZXJVcmwsIHVzZUJhc2U2NCwgdXNlU3RyZWFtaW5nLFxuICAgICAgICAgICAgKHJjLCBkYXRhKSA9PiB0aGlzLmhhbmRsZVJ4RGF0YShyYywgZGF0YSksIC8vIFJ4RGF0YSBDYWxsYmFja1xuICAgICAgICAgICAgKHJjLCBkYXRhKSA9PiB0aGlzLmhhbmRsZVNlbmRGYWlsdXJlKHJjLCBkYXRhKSwgLy8gY29ubmVjdGlvbiBjbG9zZSBvciBlcnJvciBjYWxsYmFja1xuICAgICAgICAgICAgdGhpcy5fY29udGVudFR5cGUpO1xuICAgIH1cblxuICAgIC8vIEdpdmUgdGhlIHJvdXRlciB0aGUgZGF0YSB0b2tlbiBzbyB0aGF0IGl0IHdpbGwgYmUgYWJsZSB0byBzZW5kIGRhdGFcbiAgICB0aGlzLl9odHRwUmVjZWl2ZUNvbm4uc2VuZCh0aGlzLl9zbWZEYXRhVG9rZW5UU0hlYWRlcik7XG5cbiAgICAvLyBTZW5kIHRoZSBldmVudCB0byB0aGUgYXBwbGljYXRpb24gbGV0dGluZyBpdCBrbm93IHRoYXQgdGhlIHNlc3Npb24gaXMgdXBcbiAgICB0aGlzLl9ldmVudENCKFxuICAgICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLlVQX05PVElDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21mcmVzcG9uc2UucmVzcG9uc2VTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtZnJlc3BvbnNlLnJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2Uuc2Vzc2lvbklkKSk7XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiByZWNlaXZpbmcgYSBkZXN0cm95IHJlc3BvbnNlXG4gIGhhbmRsZURlc3Ryb3lSZXNwb25zZShyZXNwb25zZSkge1xuICAgIExPR19ERUJVRygnSGFuZGxlIGRlc3Ryb3kgcmVzcG9uc2UnKTtcbiAgICAvLyBTdG9wIHRoZSB0aW1lclxuICAgIHRoaXMuY2FuY2VsRGVzdHJveVRpbWVvdXQoKTtcbiAgICBjb25zdCBpbm5lclJlc3BvbnNlID0gcmVzcG9uc2UuZ2V0UmVzcG9uc2UoKTtcbiAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IGlubmVyUmVzcG9uc2UgPyBpbm5lclJlc3BvbnNlLnJlc3BvbnNlU3RyaW5nIDogJyc7XG4gICAgdGhpcy5kZXN0cm95Q2xlYW51cChcbiAgICAgIGAke3Jlc3BvbnNlU3RyaW5nfSBoYW5kbGVkIERlc3Ryb3kgUmVzcG9uc2UgYWRkcmVzc2VkIHRvIHNlc3Npb24gJHtcbiAgICAgIGZvcm1hdEhleFN0cmluZyhyZXNwb25zZS5zZXNzaW9uSWQpfSwgb24gc2Vzc2lvbiAke2Zvcm1hdEhleFN0cmluZyh0aGlzLl9zaWQpfWAsXG4gICAgICAwKTtcbiAgfVxuXG4gIGhhbmRsZVNtZk1lc3NhZ2UodHNtc2cpIHtcbiAgICBjb25zdCBzbWZIZWFkZXIgPSB0c21zZy5zbWZIZWFkZXI7XG4gICAgaWYgKHNtZkhlYWRlci5zbWZfcHJvdG9jb2wgIT09IFNNRkxpYi5TTUZQcm90b2NvbC5UU0VTU0lPTikge1xuICAgICAgdGhpcy5oYW5kbGVTbWZQYXJzZUVycm9yKGBVbmV4cGVjdGVkIE1lc3NhZ2UgUHJvdG90Y29sICgke3NtZkhlYWRlci5zbWZfcHJvdG9jb2x9KSBvbiBSZWNlaXZlRGF0YSBjb25uZWN0aW9uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgICAvLyB3ZSBoYXZlIGZvdW5kIGEgdHJhbnNwb3J0IFNNRiwgY2FuIHdlIG5vdyByZWFkIHRoZSBUcmFuc3BvcnQgU01GIGNodW5rXG4gICAgY29uc3QgZGF0YSA9IHRzbXNnLnBheWxvYWQ7XG4gICAgY29uc3QgVG90YWxQYXlsb2FkVG9SZWFkID0gdHNtc2cucGF5bG9hZExlbmd0aDtcblxuICAgIHN3aXRjaCAodHNtc2cubWVzc2FnZVR5cGUpIHtcbiAgICAgIGNhc2UgU01GTGliLlNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZS5ERVNUUk9ZX1JFU1A6XG4gICAgICAgIHRoaXMuaGFuZGxlRGVzdHJveVJlc3BvbnNlKHRzbXNnKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIFNNRkxpYi5TTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUuREFUQTpcbiAgICAgICAgaWYgKHRzbXNnLnNlc3Npb25JZCAhPT0gdGhpcy5fc2lkKSB7XG4gICAgICAgICAgLy8gVGhlIHJvdXRlciBtYXkgaGF2ZSBnaXZlbiB1cyBhbiBlcnJvciBjb2RlOyBpZiBzbywgaW5jbHVkZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICBjb25zdCBzbWZFcnJSZXNwb25zZSA9IHRzbXNnLmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VFcnJTdHIgPSBzbWZFcnJSZXNwb25zZVxuICAgICAgICAgICAgICA/IChgICgke3NtZkVyclJlc3BvbnNlLnJlc3BvbnNlQ29kZX0gJHtzbWZFcnJSZXNwb25zZS5yZXNwb25zZVN0cmluZ30pYClcbiAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICBjb25zdCByZXNwb25zZUNvZGUgPSBzbWZFcnJSZXNwb25zZSA/IHNtZkVyclJlc3BvbnNlLnJlc3BvbnNlQ29kZSA6IG51bGw7XG5cbiAgICAgICAgICBMT0dfREVCVUcoYEhhbmRsZVJ4RGF0YSBCYWQgU2Vzc2lvbiBJRCByZWNlaXZlZCBpbiBtZXNzYWdlLiBFeHBlY3RlZDogJHtzdHJUb0J5dGVBcnJheSh0aGlzLl9zaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBSZWNlaXZlZDogJHtzdHJUb0J5dGVBcnJheSh0c21zZy5zZXNzaW9uSWQpfSR7cmVzcG9uc2VFcnJTdHJ9YCk7XG5cbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICAgICAgICB0aGlzLl9ldmVudENCKG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5QQVJTRV9GQUlMVVJFLFxuICAgICAgICAgICAgICAgICAgICAgICAgYFNlc3Npb24gSUQgbWlzbWF0Y2ggaW4gZGF0YSBtZXNzYWdlLCBleHBlY3RlZDogJHtmb3JtYXRIZXhTdHJpbmcodGhpcy5fc2lkKX0sIGdvdDogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdEhleFN0cmluZyh0c21zZy5zZXNzaW9uSWQpfSwgJHtyZXNwb25zZUVyclN0cn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBST1RPQ09MX0VSUk9SLCB0aGlzLl9zaWQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXNzLXRocm91Z2ggZW5jYXBzdWxhdGVkIGRhdGEgdG8gcGFyZW50XG4gICAgICAgIGlmIChUb3RhbFBheWxvYWRUb1JlYWQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5fY2xpZW50LnJ4RGF0YVN0cmluZyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFVuZXhwZWN0ZWQgbWVzc2FnZSB0eXBlXG4gICAgICAgIHRoaXMuaGFuZGxlU21mUGFyc2VFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGUgKCR7XG4gICAgICAgICAgICAgICAgICAgIHRzbXNnLm1lc3NhZ2VUeXBlfSkgb24gUmVjZWl2ZURhdGEgY29ubmVjdGlvbmApO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVNtZlBhcnNlRXJyb3IoKSB7XG4gICAgdGhpcy5fZXZlbnRDQihuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuREFUQV9ERUNPREVfRVJST1IsXG4gICAgICAgICdSZWNlaXZlZCBkYXRhIGRlY29kZSBlcnJvcicsIG51bGwsXG4gICAgICAgIEVycm9yU3ViY29kZS5EQVRBX0RFQ09ERV9FUlJPUiwgdGhpcy5fc2lkKSk7XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiBkYXRhIGlzIHJlY2VpdmVkIG9uIHRoZSBjb25uZWN0aW9uXG4gIGhhbmRsZVJ4RGF0YSh0c1JjLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2h0dHBSZWNlaXZlQ29ubiA9PT0gbnVsbCB8fCB0aGlzLl9yeENoYW5uZWxDbGllbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkRPV04pIHtcbiAgICAgICAgTE9HX0RFQlVHKCdUcmFuc3BvcnQgc2Vzc2lvbiBpcyBkb3duLCBpZ25vcmUgZGF0YSBmcm9tIHJlY2VpdmUgY29ubmVjdGlvbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTE9HX0VSUk9SKGBUcmFuc3BvcnQgc2Vzc2lvbiBpcyBub3QgaW4gd29ya2luZyBzdGF0ZSwgc3RhdGU6ICR7dGhpcy5fc3RhdGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgTE9HX0RFQlVHKCdUcmFuc3BvcnQgc2Vzc2lvbiBpcyBiZWluZyBkZXN0cm95ZWQsIGlnbm9yZSBkYXRhIGZyb20gcmVjZWl2ZSBjb25uZWN0aW9uLCAnICtcbiAgICAgICAgICAgICAgIGBkdW1wIGZpcnN0IDY0IGJ5dGVzIChvciBmZXdlcikgb2YgZGF0YTpcXG4ke1xuICAgICAgICAgICAgICAgICBEZWJ1Z0xpYi5EZWJ1Zy5mb3JtYXREdW1wQnl0ZXMoZGF0YS5zdWJzdHJpbmcoMCwgNjQpLCB0cnVlLCAwKX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9odHRwUmVjZWl2ZUNvbm4ucmVjU3RhdCgnR290RGF0YScpO1xuICAgIGlmICh0c1JjICE9PSBUcmFuc3BvcnRSZXR1cm5Db2RlLk9LKSB7XG4gICAgICB0aGlzLmhhbmRsZVJ4RXJyb3IodHNSYywgZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICBMT0dfREVCVUcoJ1NlbmQgd3JpdGUgdG9rZW4gdG8gcm91dGVyJyk7XG4gICAgICB0aGlzLl9odHRwUmVjZWl2ZUNvbm4uc2VuZCh0aGlzLl9zbWZEYXRhVG9rZW5UU0hlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3J4Q2hhbm5lbENsaWVudC5yeERhdGFTdHJpbmcoZGF0YSk7XG4gICAgfSAvLyBlbmQgaGF2ZSBkYXRhIHRvIHByb2Nlc3NcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgb24gYSBIVFRQX0JJTkFSWV9TVFJFQU1JTkcgY29ubmVjdGlvblxuICBoYW5kbGVSeFN0cmVhbWluZyh0c1JjLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2h0dHBSZWNlaXZlQ29ubiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTikge1xuICAgICAgICBMT0dfREVCVUcoJ1RyYW5zcG9ydCBzZXNzaW9uIGlzIGRvd24sIGlnbm9yZSBkYXRhIGZyb20gcmVjZWl2ZSBjb25uZWN0aW9uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMT0dfRVJST1IoYFRyYW5zcG9ydCBzZXNzaW9uIGlzIG5vdCBpbiB3b3JraW5nIHN0YXRlLCBzdGF0ZTogJHt0aGlzLl9zdGF0ZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5XQUlUSU5HX0ZPUl9ERVNUUk9ZKSB7XG4gICAgICBMT0dfREVCVUcoJ1RyYW5zcG9ydCBzZXNzaW9uIGlzIGJlaW5nIGRlc3Ryb3llZCwgaWdub3JlIGRhdGEgZnJvbSBzdHJlYW1pbmcgcmVjZWl2ZSAnICtcbiAgICAgICAgICAgICAgIGBjb25uZWN0aW9uLCBkdW1wIGZpcnN0IDY0IGJ5dGVzIChvciBmZXdlcikgb2YgZGF0YTpcXG4ke1xuICAgICAgICAgICAgICAgRGVidWdMaWIuRGVidWcuZm9ybWF0RHVtcEJ5dGVzKGRhdGEuc3Vic3RyaW5nKDAsIDY0KSwgdHJ1ZSwgMCl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faHR0cFJlY2VpdmVDb25uLnJlY1N0YXQoJ0dvdERhdGEnKTtcbiAgICBpZiAodHNSYyAhPT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSykge1xuICAgICAgdGhpcy5oYW5kbGVSeEVycm9yKHRzUmMsIGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgTE9HX1RSQUNFKCdTZW5kIHdyaXRlIHRva2VuIHRvIHJvdXRlcicpO1xuICAgICAgdGhpcy5fcGFja2V0UmVhZFN0YXRlID0gUGFja2V0UmVhZFN0YXRlLlJFQURJTkdfSEVBREVSO1xuICAgICAgdGhpcy5faHR0cFJlY2VpdmVDb25uLnNlbmQodGhpcy5fc21mRGF0YVRva2VuVFNIZWFkZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhc3MtdGhyb3VnaCBlbmNhcHN1bGF0ZWQgZGF0YSB0byBwYXJlbnRcbiAgICBpZiAodGhpcy5fcGFja2V0UmVhZFN0YXRlID09PSBQYWNrZXRSZWFkU3RhdGUuU1RSRUFNSU5HKSB7XG4gICAgICB0aGlzLl9jbGllbnQucnhEYXRhU3RyaW5nKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luY29taW5nQnVmZmVyICs9IGRhdGE7XG4gICAgY29uc3Qgc21maGVhZGVyID0gU01GTGliLkNvZGVjLlBhcnNlU01GLnBhcnNlU01GQXQodGhpcy5faW5jb21pbmdCdWZmZXIsIDAsIHRydWUpO1xuICAgIGlmIChzbWZoZWFkZXIpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHZhbGlkIHNtZiBoZWFkZXIsIHNlZSBpZiB0aGVyZSBpcyBhIHRyYW5zcG9ydCBoZWFkZXIgYW5kIHNlc3Npb24taWRcbiAgICAgIGNvbnN0IHRzbXNnID0gU01GTGliLkNvZGVjLlRyYW5zcG9ydC5wYXJzZVRzU21mSGRyQXQodGhpcy5faW5jb21pbmdCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtZmhlYWRlci5oZWFkZXJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtZmhlYWRlcik7XG4gICAgICBpZiAoIXRzbXNnKSB7XG4gICAgICAgIC8vIE5vdCB0c01zZyBidXQgdGhlcmUgaXMgYW4gc21mIGhlYWRlciwganVzdCByZXR1cm4gdW50aWwgbW9yZSBkYXRhIGFycml2ZXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBoYXZlIHRoZSB0cmFuc3BvcnQgbWVzc2FnZSBoZWFkZXIgdG9vLCBpZiBpdCBpcyBhIERBVEEgbWVzc2FnZSBlbnRlclxuICAgICAgLy8gU1RSRUFNSU5HIHN0YXRlXG4gICAgICBzd2l0Y2ggKHRzbXNnLm1lc3NhZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgU01GTGliLlNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZS5ERVNUUk9ZX1JFU1A6XG4gICAgICAgICAgdGhpcy5oYW5kbGVEZXN0cm95UmVzcG9uc2UodHNtc2cpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFNNRkxpYi5TTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUuREFUQTpcbiAgICAgICAgICBpZiAodHNtc2cuc2Vzc2lvbklkICE9PSB0aGlzLl9zaWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSByb3V0ZXIgbWF5IGhhdmUgZ2l2ZW4gdXMgYW4gZXJyb3IgY29kZSwgaWYgc28sIGluY2x1ZGUgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICBjb25zdCBzbWZFcnJSZXNwb25zZSA9IHRzbXNnLmdldFJlc3BvbnNlKCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUVyclN0ciA9IHNtZkVyclJlc3BvbnNlXG4gICAgICAgICAgICAgICAgPyAoYCAoJHtzbWZFcnJSZXNwb25zZS5yZXNwb25zZUNvZGV9ICR7c21mRXJyUmVzcG9uc2UucmVzcG9uc2VTdHJpbmd9KWApXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29kZSA9IHNtZkVyclJlc3BvbnNlID8gc21mRXJyUmVzcG9uc2UucmVzcG9uc2VDb2RlIDogbnVsbDtcblxuICAgICAgICAgICAgTE9HX0RFQlVHKGBIYW5kbGVSeERhdGEgQmFkIFNlc3Npb24gSUQgcmVjZWl2ZWQgaW4gbWVzc2FnZS4gIEV4cGVjdGVkOiAke3N0clRvQnl0ZUFycmF5KHRoaXMuX3NpZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFJlY2VpdmVkOiAke3N0clRvQnl0ZUFycmF5KHRzbXNnLnNlc3Npb25JZCl9JHtyZXNwb25zZUVyclN0cn1gKTtcbiAgICAgICAgICAgIExPR19ERUJVRyhgRmlyc3QgNjQgYnl0ZXMgKG9yIGZld2VyKSBvZiBtZXNzYWdlOiAke3N0clRvQnl0ZUFycmF5KGRhdGEuc3Vic3RyKDAsIDY0KSl9YCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkNPTk5FQ1RJT05fRkFJTEVEO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRDQihcbiAgICAgICAgICAgICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLlBBUlNFX0ZBSUxVUkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFNlc3Npb24gSUQgbWlzbWF0Y2ggaW4gZGF0YSBtZXNzYWdlLCBleHBlY3RlZDogJHtmb3JtYXRIZXhTdHJpbmcodGhpcy5fc2lkKX0sIGdvdDogJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRIZXhTdHJpbmcodHNtc2cuc2Vzc2lvbklkKX0sICR7cmVzcG9uc2VFcnJTdHJ9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBST1RPQ09MX0VSUk9SLCB0aGlzLl9zaWQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYWxsIGlzIGdvb2QuIFdlIGNhbiBub3cgU1RSRUFNIHRoZSByZXN0IG9mIHRoZSBkYXRhIHVudGlsIGEgZW1wdHkgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAgICAgICAgICB0aGlzLl9wYWNrZXRSZWFkU3RhdGUgPSBQYWNrZXRSZWFkU3RhdGUuU1RSRUFNSU5HO1xuICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaCBhbnkgcmVtYWluaW5nIGRhdGFcbiAgICAgICAgICBpZiAodGhpcy5faW5jb21pbmdCdWZmZXIubGVuZ3RoID4gKHNtZmhlYWRlci5oZWFkZXJMZW5ndGggKyB0c21zZy50c0hlYWRlckxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5yeERhdGFTdHJpbmcoXG4gICAgICAgICAgICAgIHRoaXMuX2luY29taW5nQnVmZmVyLnN1YnN0cihzbWZoZWFkZXIuaGVhZGVyTGVuZ3RoICsgdHNtc2cudHNIZWFkZXJMZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faW5jb21pbmdCdWZmZXIgPSAnJztcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVxuICAgICAgICAgIHRocm93IG5ldyBUcmFuc3BvcnRFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGUgKCR7dHNtc2cubWVzc2FnZVR5cGV9KSBvbiBSZWNlaXZlRGF0YSBjb25uZWN0aW9uYCwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTTUZMaWIuQ29kZWMuUGFyc2VTTUYuaXNTTUZIZWFkZXJBdmFpbGFibGUodGhpcy5faW5jb21pbmdCdWZmZXIsIDApICYmXG4gICAgICAgICAgICAgICAhU01GTGliLkNvZGVjLlBhcnNlU01GLmlzU01GSGVhZGVyVmFsaWQodGhpcy5faW5jb21pbmdCdWZmZXIsIDApKSB7XG4gICAgICAvLyBQcm9iYWJseSBsb3N0IGZyYW1pbmdcbiAgICAgIExPR19FUlJPUihgQ291bGRuJ3QgZGVjb2RlIG1lc3NhZ2UgZHVlIHRvIGludmFsaWQgc21mIGhlYWRlciwgZHVtcCBmaXJzdCA2NCBieXRlcyAob3IgZmV3ZXIpIG9mIGJ1ZmZlciBjb250ZW50OlxcbiR7XG4gICAgICAgICAgICAgICAgIERlYnVnTGliLkRlYnVnLmZvcm1hdER1bXBCeXRlcyh0aGlzLl9pbmNvbWluZ0J1ZmZlci5zdWJzdHJpbmcoMCwgNjQpLCB0cnVlLCAwKX1gKTtcblxuICAgICAgY29uc3QgZXJyb3JJbmZvID0gJ0Vycm9yIHBhcnNpbmcgaW5jb21pbmcgbWVzc2FnZSAtIGludmFsaWQgU01GIGhlYWRlciBkZXRlY3RlZCc7XG4gICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICAgIHRoaXMuX2V2ZW50Q0IoXG4gICAgICAgIG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5QQVJTRV9GQUlMVVJFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySW5mbywgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQgb24gdGhlIGh0dHBEYXRhU2VuZFxuICBoYW5kbGVSeERhdGFUb2tlbih0c1JjLCBkYXRhKSB7XG4gICAgaWYgKHRzUmMgIT09IFRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgIHRoaXMuaGFuZGxlUnhFcnJvcih0c1JjLCBkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gaGFuZGxlIEVuZCBvZiBTdHJlYW1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRSZXNwb25zZSA9IFNNRkxpYi5Db2RlYy5EZWNvZGUuZGVjb2RlQ29tcG91bmRNZXNzYWdlKGRhdGEsIDApO1xuICAgIGlmICghcGFyc2VkUmVzcG9uc2UpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0RFU1RST1kpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuQ09OTkVDVElPTl9GQUlMRUQ7XG4gICAgICAgIHRoaXMuX2V2ZW50Q0IobmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLlBBUlNFX0ZBSUxVUkUsXG4gICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBwYXJzZSByZWNlaXZlZCBkYXRhIG1lc3NhZ2UnLCBudWxsLFxuICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QUk9UT0NPTF9FUlJPUiwgdGhpcy5fc2lkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3lDbGVhbnVwKCdGYWlsZWQgdG8gcGFyc2UgcmVjZWl2ZWQgZGF0YSBtZXNzYWdlJywgRXJyb3JTdWJjb2RlLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkUmVzcG9uc2UubWVzc2FnZVR5cGUgPT09IFNNRkxpYi5TTUZUcmFuc3BvcnRTZXNzaW9uTWVzc2FnZVR5cGUuREVTVFJPWV9SRVNQKSB7XG4gICAgICB0aGlzLmhhbmRsZURlc3Ryb3lSZXNwb25zZShwYXJzZWRSZXNwb25zZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlZFJlc3BvbnNlLnNlc3Npb25JZCAhPT0gdGhpcy5fc2lkKSB7XG4gICAgICAgIC8vIFRoZSByb3V0ZXIgbWF5IGhhdmUgZ2l2ZW4gdXMgYW4gZXJyb3IgY29kZSwgaWYgc28sIGluY2x1ZGUgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICBjb25zdCBzbWZFcnJSZXNwb25zZSA9IHBhcnNlZFJlc3BvbnNlLmdldFJlc3BvbnNlKCk7XG4gICAgICBjb25zdCByZXNwb25zZUVyclN0ciA9IHNtZkVyclJlc3BvbnNlID9cbiAgICAgICAgICAgIChgICgke3NtZkVyclJlc3BvbnNlLnJlc3BvbnNlQ29kZX0gJHtzbWZFcnJSZXNwb25zZS5yZXNwb25zZVN0cmluZ30pYCkgOlxuICAgICAgICAgICAgJyc7XG4gICAgICBjb25zdCByZXNwb25zZUNvZGUgPSBzbWZFcnJSZXNwb25zZSA/IHNtZkVyclJlc3BvbnNlLnJlc3BvbnNlQ29kZSA6IG51bGw7XG5cbiAgICAgIExPR19ERUJVRyhgSGFuZGxlUnhEYXRhVG9rZW4gQmFkIFNJRCByZWNlaXZlZCBpbiBtZXNzYWdlLiAgRXhwZWN0ZWQ6ICR7c3RyVG9CeXRlQXJyYXkodGhpcy5fc2lkKVxuICAgICAgICAgICAgfSwgUmVjZWl2ZWQ6ICR7c3RyVG9CeXRlQXJyYXkocGFyc2VkUmVzcG9uc2Uuc2Vzc2lvbklkKX0ke3Jlc3BvbnNlRXJyU3RyfWApO1xuICAgICAgTE9HX0RFQlVHKGBGaXJzdCA2NCBieXRlcyAob3IgZmV3ZXIpIG9mIG1lc3NhZ2U6ICR7c3RyVG9CeXRlQXJyYXkoZGF0YS5zdWJzdHIoMCwgNjQpKX1gKTtcblxuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuV0FJVElOR19GT1JfREVTVFJPWSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICAgICAgdGhpcy5fZXZlbnRDQihuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuUEFSU0VfRkFJTFVSRSxcbiAgICAgICAgICAgICAgICBgU2Vzc2lvbiBJRCBtaXNtYXRjaCBpbiByZXNwb25zZSBtZXNzYWdlLCBleHBlY3RlZDogJHtmb3JtYXRIZXhTdHJpbmcodGhpcy5fc2lkKX0sIGdvdDogJHtmb3JtYXRIZXhTdHJpbmcocGFyc2VkUmVzcG9uc2Uuc2Vzc2lvbklkKX0sICR7cmVzcG9uc2VFcnJTdHJ9YCxcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvZGUsIEVycm9yU3ViY29kZS5QUk9UT0NPTF9FUlJPUiwgdGhpcy5fc2lkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3lDbGVhbnVwKCdTZXNzaW9uIElEIG1pc21hdGNoIGluIHJlc3BvbnNlIG1lc3NhZ2UnLCBFcnJvclN1YmNvZGUuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYXJzZWRSZXNwb25zZS5tZXNzYWdlVHlwZSA9PT1cbiAgICAgICAgU01GTGliLlNNRlRyYW5zcG9ydFNlc3Npb25NZXNzYWdlVHlwZS5EQVRBX1RPS0VOIHx8XG4gICAgICAgIHBhcnNlZFJlc3BvbnNlLm1lc3NhZ2VUeXBlID09PVxuICAgICAgICBTTUZMaWIuU01GVHJhbnNwb3J0U2Vzc2lvbk1lc3NhZ2VUeXBlLkRBVEFfU1RSRUFNX1RPS0VOKSB7XG4gICAgICB0aGlzLl9oYXZlVG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5faHR0cFNlbmRDb25uLnJlY1N0YXQoJ0dvdFRva2VuJyk7XG4gICAgICAvLyB0aGlzLl9ldmVudENCKFxuICAgICAgLy8gICAgbmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudChUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLk5PVElGWV9HT1RfVE9LRU4sIFwiXCIsIG51bGwsIG51bGwpKTtcbiAgICAgIHRoaXMuc2VuZFF1ZXVlZERhdGEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVbmV4cGVjdGVkIG1lc3NhZ2UgdHlwZVxuICAgICAgdGhyb3cgKG5ldyBUcmFuc3BvcnRFcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIHR5cGUgKCR7XG4gICAgICAgICAgICBwYXJzZWRSZXNwb25zZS5tZXNzYWdlVHlwZX0pIG9uIFNlbmREYXRhIGNvbm5lY3Rpb25gLCAwKSk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUnhFcnJvcih0c1JjIC8qLCBkYXRhICovKSB7XG4gICAgTE9HX0lORk8oYGhhbmRsZVJ4RXJyb3IsIHRyYW5zcG9ydCByZXR1cm4gY29kZSAke1RyYW5zcG9ydFJldHVybkNvZGUubmFtZSh0c1JjKX1gKTtcbiAgICB0aGlzLl9zdGF0ZSA9IFRyYW5zcG9ydFNlc3Npb25TdGF0ZS5DT05ORUNUSU9OX0ZBSUxFRDtcbiAgICBpZiAodHNSYyA9PT0gVHJhbnNwb3J0UmV0dXJuQ29kZS5EQVRBX0RFQ09ERV9FUlJPUikge1xuICAgICAgdGhpcy5fZXZlbnRDQihuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuREFUQV9ERUNPREVfRVJST1IsXG4gICAgICAgICAgICAnUmVjZWl2ZWQgZGF0YSBkZWNvZGUgZXJyb3InLCBudWxsLFxuICAgICAgICAgICAgRXJyb3JTdWJjb2RlLkRBVEFfREVDT0RFX0VSUk9SLCB0aGlzLl9zaWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRDQihuZXcgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50KFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuU0VORF9FUlJPUixcbiAgICAgICAgICAgICdDb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SLCB0aGlzLl9zaWQpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBvbiBhIGNvbm5lY3Rpb24gb3IgdGhlIGNvbm5lY3Rpb24gaXMgYWJvcnRlZFxuICBoYW5kbGVTZW5kRmFpbHVyZShzdGF0dXMsIG1zZykge1xuICAgIC8vIGZhaWxlZCB0byBzZW5kIG1lc3NhZ2UsIGlmIGl0IGlzIGEgZGVzdHJveSBtZXNzYWdlLCBqdXN0IGNvbXBsZXRlIHRoZSBkZXN0cm95IHByb2Nlc3NcXFxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLldBSVRJTkdfRk9SX0RFU1RST1kpIHtcbiAgICAgIExPR19JTkZPKGBDb25uZWN0aW9uIGRlc3Ryb3kgZmFpbHVyZSAoJHttc2d9KSB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuX3N0YXRlfWApO1xuICAgICAgdGhpcy5kZXN0cm95Q2xlYW51cChgQ29ubmVjdGlvbiBkZXN0cm95IGZhaWx1cmU6ICR7bXNnfWAsIEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFpbGVkIHRvIHNlbmQgbWVzc2FnZSwgcmV0dXJuIGVycm9yIHRvIHVwcGVyIGxheWVyIHdoaWNoIG1heSAgdGVhciB0aGUgc2Vzc2lvbiBkb3duXG4gICAgICBMT0dfSU5GTyhgQ29ubmVjdGlvbiBmYWlsdXJlICgke21zZ30pIHdoaWxlIGluIHN0YXRlICR7dGhpcy5fc3RhdGV9YCk7XG4gICAgICB0aGlzLl9ldmVudENCKG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5TRU5EX0VSUk9SLFxuICAgICAgICAgICAgYENvbm5lY3Rpb24gZXJyb3I6ICR7bXNnfWAsIHN0YXR1cyxcbiAgICAgICAgICAgIEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SLCB0aGlzLl9zaWQpKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGVyZSBpcyBhbiBlcnJvciBvbiBhIGNvbm5lY3Rpb24gZm9yIGEgc2Vzc2lvbiBjcmVhdGUgcmVxdWVzdFxuICBoYW5kbGVDcmVhdGVDb25uRmFpbHVyZShzdGF0dXMsIG1zZykge1xuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gVHJhbnNwb3J0U2Vzc2lvblN0YXRlLkRPV04pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBMT0dfSU5GTyhgQ29ubmVjdGlvbiBjcmVhdGUgZmFpbHVyZSAoJHttc2d9KSB3aGlsZSBpbiBzdGF0ZSAke3RoaXMuX3N0YXRlfWApO1xuICAgIHRoaXMuZGVzdHJveUNsZWFudXAoYENvbm5lY3Rpb24gY3JlYXRlIGZhaWx1cmU6ICR7bXNnfWAsIEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SKTtcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIHRoZSBkZXN0cm95IHRpbWVyIGV4cGlyZXNcbiAgZGVzdHJveVRpbWVyRXhwaXJ5KCkge1xuICAgIHRoaXMuZGVzdHJveUNsZWFudXAoJ0Rlc3Ryb3kgcmVxdWVzdCB0aW1lb3V0JywgRXJyb3JTdWJjb2RlLkNPTk5FQ1RJT05fRVJST1IpO1xuICB9XG5cbiAgY2FuY2VsRGVzdHJveVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3lUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Rlc3Ryb3lUaW1lcik7XG4gICAgICB0aGlzLl9kZXN0cm95VGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgcmVjZWl2aW5nIHRzIGRlc3Ryb3kgcmVzcG9uc2UgZnJvbSByb3V0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluZm9TdHIgVGhlIGluZm9ybWF0aW9uYWwgc3RyaW5nIHRvIHBhc3MgYWxvbmdcbiAgICogQHBhcmFtIHtFcnJvclN1YmNvZGV9IHN1YmNvZGUgVGhlIHN1YmNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFzeW5jU2VuZEV2ZW50IElmIHRydWUsIGFsd2F5cyBzZW5kIHRoZSBldmVudCBhc3luY2hyb25vdXNseS5cbiAgICovXG4gIGRlc3Ryb3lDbGVhbnVwKGluZm9TdHIsIHN1YmNvZGUsIGFzeW5jU2VuZEV2ZW50KSB7XG4gICAgTE9HX0RFQlVHKGBEZXN0cm95IGNsZWFudXA6ICR7aW5mb1N0cn1gKTtcblxuICAgIC8vIEFib3J0IGFueSBjdXJyZW50IHJlcXVlc3RzIGZvciB0aGlzIHNlc3Npb25cbiAgICBpZiAodGhpcy5fY3JlYXRlQ29ubikge1xuICAgICAgTE9HX0RFQlVHKCdEZXN0cm95IGNsZWFudXA6IEFib3J0IGNyZWF0ZUNvbm4nKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUNvbm4uYWJvcnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2h0dHBTZW5kQ29ubikge1xuICAgICAgTE9HX0RFQlVHKCdEZXN0cm95IGNsZWFudXA6IEFib3J0IHNlbmRDb25uJyk7XG4gICAgICB0aGlzLl9odHRwU2VuZENvbm4uYWJvcnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2h0dHBSZWNlaXZlQ29ubikge1xuICAgICAgTE9HX0RFQlVHKCdEZXN0cm95IGNsZWFudXA6IEFib3J0IHJlY2VpdmVDb25uJyk7XG4gICAgICB0aGlzLl9odHRwUmVjZWl2ZUNvbm4uYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBtb3N0IGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5fY3JlYXRlVXJsID0gbnVsbDtcbiAgICB0aGlzLl9yb3V0ZXJVcmwgPSBudWxsO1xuICAgIHRoaXMuX2NyZWF0ZUNvbm4gPSBudWxsO1xuICAgIHRoaXMuX2h0dHBTZW5kQ29ubiA9IG51bGw7XG4gICAgdGhpcy5faHR0cFJlY2VpdmVDb25uID0gbnVsbDtcbiAgICB0aGlzLl9zbWZEYXRhVG9rZW5UU0hlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcnhDaGFubmVsQ2xpZW50ID0gbnVsbDtcbiAgICB0aGlzLl9yb3V0ZXJUYWcgPSAnJztcbiAgICB0aGlzLl9xdWV1ZWREYXRhID0gW107XG4gICAgdGhpcy5fcXVldWVkRGF0YVNpemUgPSAwO1xuICAgIHRoaXMuX2NhblNlbmROZWVkZWQgPSBmYWxzZTtcblxuICAgIC8vIENsZWFyIHRpbWVycy5cbiAgICB0aGlzLmNhbmNlbERlc3Ryb3lUaW1lb3V0KCk7XG4gICAgdGhpcy5jYW5jZWxDb25uZWN0VGltZW91dCgpO1xuXG4gICAgLy8gU2V0IGZpbmFsIHN0YXRlXG4gICAgdGhpcy5fc3RhdGUgPSBUcmFuc3BvcnRTZXNzaW9uU3RhdGUuRE9XTjtcblxuICAgIC8vIFNlbmQgdGhlIGV2ZW50IHRvIHRoZSBhcHBsaWNhdGlvbiBsZXR0aW5nIGl0IGtub3cgdGhhdCB0aGUgc2Vzc2lvbiBpcyBkb3duXG4gICAgY29uc3QgZmluYWxpemUgPSAoKSA9PiB7XG4gICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBjYWxsYmFjayB3YXMgY2xlYXJlZCBiZWZvcmUgdGhlIHRpbWVvdXQgY29tcGxldGVzLlxuICAgICAgaWYgKHRoaXMuX2V2ZW50Q0IpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRDQihcbiAgICAgICAgICAgIG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5ERVNUUk9ZRURfTk9USUNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvU3RyIHx8ICdTZXNzaW9uIGlzIGRlc3Ryb3llZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNvZGUgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lkKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbGVhc2UgcmVmZXJlbmNlIHRvIHNtZiBjbGllbnQgb2JqZWN0XG4gICAgICB0aGlzLl9jbGllbnQgPSBudWxsO1xuICAgICAgLy8gcmVsZWFzZSByZWZlcmVuY2UgdG8gc2Vzc2lvbiBvYmplY3RcbiAgICAgIHRoaXMuX2V2ZW50Q0IgPSBudWxsO1xuICAgIH07XG5cbiAgICBpZiAoYXN5bmNTZW5kRXZlbnQpIHtcbiAgICAgIHNldFRpbWVvdXQoZmluYWxpemUsIDApOyAvLyBUT0RPOiBzZXRJbW1lZGlhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxpemUoKTtcbiAgICB9XG4gIH1cblxuICBnZXRJbmZvU3RyKCkge1xuICAgIGNvbnN0IHN0ciA9IGBIVFRQVHJhbnNwb3J0U2Vzc2lvbjsgc2lkPSR7XG4gICAgICAgIGZvcm1hdEhleFN0cmluZyh0aGlzLl9zaWQpXG4gICAgICAgIH07IHJvdXRlclRhZz0ke3RoaXMuX3JvdXRlclRhZ31gO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cy5IVFRQVHJhbnNwb3J0U2Vzc2lvbiA9IEhUVFBUcmFuc3BvcnRTZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdHJhbnNwb3J0L2xpYi93ZWIvaHR0cC9odHRwLXRyYW5zcG9ydC1zZXNzaW9uLmpzIiwiY29uc3QgeyBCYXNlNjQsIENvbnZlcnQgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1jb252ZXJ0Jyk7XG5jb25zdCB7IFhIUkZhY3RvcnkgfSA9IHJlcXVpcmUoJy4veGhyLWZhY3RvcnknKTtcblxuY29uc3QgeyBlbmNvZGU6IGJhc2U2NEVuY29kZSB9ID0gQmFzZTY0O1xuY29uc3QgeyBzdHJpbmdUb1VpbnQ4QXJyYXkgfSA9IENvbnZlcnQ7XG5cbmZ1bmN0aW9uIHNlbmRYaHJCaW5hcnlNU0lFMTAoeGhyLCBkYXRhLCBjb250ZW50VHlwZSkge1xuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgeGhyLm92ZXJyaWRlTWltZVR5cGUoYCR7Y29udGVudFR5cGV9OyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkYCk7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBgJHtjb250ZW50VHlwZX07IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRgKTtcbiAgeGhyLnNlbmQoc3RyaW5nVG9VaW50OEFycmF5KGRhdGEpKTtcbn1cblxuZnVuY3Rpb24gc2VuZFhockJpbmFyeVhIUjIoeGhyLCBkYXRhLCBjb250ZW50VHlwZSkge1xuICB4aHIub3ZlcnJpZGVNaW1lVHlwZShgJHtjb250ZW50VHlwZX07IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRgKTtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGAke2NvbnRlbnRUeXBlfTsgY2hhcnNldD14LXVzZXItZGVmaW5lZGApO1xuICB4aHIuc2VuZChzdHJpbmdUb1VpbnQ4QXJyYXkoZGF0YSkuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gc2VuZFhoclRleHQoeGhyLCBkYXRhLCBjb250ZW50VHlwZSwgY29ubkNsb3NlKSB7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBgJHtjb250ZW50VHlwZX07IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRgKTtcbiAgeGhyLnNlbmQoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB1bmRlZmluZWQgPyBkYXRhIDogYmFzZTY0RW5jb2RlKGRhdGEpLCBjb25uQ2xvc2UpO1xufVxuXG5jb25zdCBzZW5kWGhyQmluYXJ5ID0gKCgpID0+IHtcbiAgLy8gVWludDhBcnJheSBpcyBwcm9iYWJseSBzaGltbWVkIGJ5IGNvcmUtanMuIFdlIGRvbid0IHVzZSB3aW5kb3cuQmxvYiwgYnV0XG4gIC8vIGl0IGlzIGEgV29ya2luZyBEcmFmdCwgbm90ICBwYXJ0IG9mIEVTNiwgYW5kIG5vdCBzaGltbWVkIGJ5IGNvcmUtanMuXG4gIC8vIFRoZXJlZm9yZSBpdCBtYWtlcyBhIHdvcmthYmxlIGNhbmFyeSBmb3IgSUUxMCBkZXRlY3Rpb24uXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVWludDhBcnJheSAmJiB3aW5kb3cuQmxvYiAvKiAhaWU5ICovKSB7XG4gICAgY29uc3QgeGhyID0gWEhSRmFjdG9yeS5jcmVhdGUodHJ1ZSk7XG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgLyogaWUxMCAqLykge1xuICAgICAgcmV0dXJuIHNlbmRYaHJCaW5hcnlNU0lFMTA7XG4gICAgfVxuICAgIHJldHVybiBzZW5kWGhyQmluYXJ5WEhSMjtcbiAgfVxuICByZXR1cm4gc2VuZFhoclRleHQ7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZW5kWGhyQmluYXJ5ID0gc2VuZFhockJpbmFyeTtcbm1vZHVsZS5leHBvcnRzLnNlbmRYaHJUZXh0ID0gc2VuZFhoclRleHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9odHRwL3NlbmQteGhyLmpzIiwiY29uc3QgeyBUcmFuc3BvcnRQcm90b2NvbCB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXByb3RvY29scycpO1xuY29uc3QgeyBUU0hTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vdHNoLXN0YXRlJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSFRUUCBCYXNlNjQgdHJhbnNwb3J0XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0ZUJhc2U2NCBleHRlbmRzIFRTSFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBUU0hTdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVNzbCBUcnVlIGlmIFNTTCBzaG91bGQgYmUgdXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGl0Q2IgQ2FsbGJhY2sgdG8gbm90aWZ5IG9uIGV4aXRcbiAgICogQHBhcmFtIHs/VFNIU3RhdGV9IG5leHRTdGF0ZSBEb3duZ3JhZGUgdGFyZ2V0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VTc2wsIGV4aXRDYiwgbmV4dFN0YXRlKSB7XG4gICAgc3VwZXIodXNlU3NsLCBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JBU0U2NCwgZXhpdENiLCBuZXh0U3RhdGUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlN0YXRlQmFzZTY0ID0gU3RhdGVCYXNlNjQ7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3N0YXRlLWJhc2U2NC5qcyIsImNvbnN0IHsgVHJhbnNwb3J0UHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcbmNvbnN0IHsgVFNIU3RhdGUgfSA9IHJlcXVpcmUoJy4uL3RzaC1zdGF0ZScpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydC1jYXBhYmlsaXRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIVFRQIEJpbmFyeSB0cmFuc3BvcnRcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFN0YXRlQmluYXJ5IGV4dGVuZHMgVFNIU3RhdGUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFRTSFN0YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlU3NsIFRydWUgaWYgU1NMIHNob3VsZCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV4aXRDYiBDYWxsYmFjayB0byBub3RpZnkgb24gZXhpdFxuICAgKiBAcGFyYW0gez9UU0hTdGF0ZX0gbmV4dFN0YXRlIERvd25ncmFkZSB0YXJnZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVzZVNzbCwgZXhpdENiLCBuZXh0U3RhdGUpIHtcbiAgICBzdXBlcih1c2VTc2wsIFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQklOQVJZLCBleGl0Q2IsIG5leHRTdGF0ZSk7XG4gIH1cblxuICB2YWxpZGF0ZUxlZ2FsKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICByZXR1cm4gV2ViVHJhbnNwb3J0Q2FwYWJpbGl0aWVzLnhockJpbmFyeSgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlN0YXRlQmluYXJ5ID0gU3RhdGVCaW5hcnk7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3N0YXRlLWJpbmFyeS5qcyIsImNvbnN0IHsgVHJhbnNwb3J0UHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcbmNvbnN0IHsgVFNIU3RhdGUgfSA9IHJlcXVpcmUoJy4uL3RzaC1zdGF0ZScpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydC1jYXBhYmlsaXRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIVFRQIEJpbmFyeSBTdHJlYW1pbmcgdHJhbnNwb3J0XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0ZVN0cmVhbWluZ0FuZEJpbmFyeSBleHRlbmRzIFRTSFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBUU0hTdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVNzbCBUcnVlIGlmIFNTTCBzaG91bGQgYmUgdXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGl0Q2IgQ2FsbGJhY2sgdG8gbm90aWZ5IG9uIGV4aXRcbiAgICogQHBhcmFtIHs/VFNIU3RhdGV9IG5leHRTdGF0ZSBEb3duZ3JhZGUgdGFyZ2V0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VTc2wsIGV4aXRDYiwgbmV4dFN0YXRlKSB7XG4gICAgc3VwZXIodXNlU3NsLCBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV9TVFJFQU1JTkcsIGV4aXRDYiwgbmV4dFN0YXRlKTtcbiAgfVxuXG4gIHZhbGlkYXRlTGVnYWwoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMuc3RyZWFtaW5nKCkgJiYgV2ViVHJhbnNwb3J0Q2FwYWJpbGl0aWVzLnhockJpbmFyeSgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLlN0YXRlU3RyZWFtaW5nQW5kQmluYXJ5ID0gU3RhdGVTdHJlYW1pbmdBbmRCaW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi9zdGF0ZS1zdHJlYW1pbmctYW5kLWJpbmFyeS5qcyIsImNvbnN0IHsgVHJhbnNwb3J0UHJvdG9jb2wgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1wcm90b2NvbHMnKTtcbmNvbnN0IHsgVFNIU3RhdGUgfSA9IHJlcXVpcmUoJy4uL3RzaC1zdGF0ZScpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMgfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydC1jYXBhYmlsaXRpZXMnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0XG4gKiBAbWVtYmVyb2Ygc29sYWNlXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTdGF0ZVdlYlNvY2tldEJpbmFyeSBleHRlbmRzIFRTSFN0YXRlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBUU0hTdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVNzbCBUcnVlIGlmIFNTTCBzaG91bGQgYmUgdXNlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGl0Q2IgQ2FsbGJhY2sgdG8gbm90aWZ5IG9uIGV4aXRcbiAgICogQHBhcmFtIHs/VFNIU3RhdGV9IG5leHRTdGF0ZSBEb3duZ3JhZGUgdGFyZ2V0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1c2VTc2wsIGV4aXRDYiwgbmV4dFN0YXRlKSB7XG4gICAgc3VwZXIodXNlU3NsLCBUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUlksIGV4aXRDYiwgbmV4dFN0YXRlKTtcbiAgfVxuXG4gIHZhbGlkYXRlTGVnYWwoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIHJldHVybiBXZWJUcmFuc3BvcnRDYXBhYmlsaXRpZXMud2ViU29ja2V0KCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuU3RhdGVXZWJTb2NrZXRCaW5hcnkgPSBTdGF0ZVdlYlNvY2tldEJpbmFyeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3N0YXRlLXdlYnNvY2tldC1iaW5hcnkuanMiLCJcbmNvbnN0IHsgRXJyb3JTdWJjb2RlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcbmNvbnN0IHsgRnNtRXZlbnQsIFN0YXRlLCBTdGF0ZU1hY2hpbmUgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1mc20nKTtcbmNvbnN0IHsgTG9nRm9ybWF0dGVyIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IFRyYW5zcG9ydFJldHVybkNvZGUgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1yZXR1cm4tY29kZXMnKTtcbmNvbnN0IHsgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50IH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudCcpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRFdmVudCB9ID0gcmVxdWlyZSgnLi93ZWItdHJhbnNwb3J0LWV2ZW50cycpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRTdGF0ZSB9ID0gcmVxdWlyZSgnLi93ZWItdHJhbnNwb3J0LXN0YXRlcycpO1xuXG5jb25zdCB7XG4gIExPR19UUkFDRSxcbiAgTE9HX0RFQlVHLFxufSA9IG5ldyBMb2dGb3JtYXR0ZXIoKTtcblxuY2xhc3MgV2ViVHJhbnNwb3J0RlNNIGV4dGVuZHMgU3RhdGVNYWNoaW5lIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0SW4sIGdldElkKSB7XG4gICAgc3VwZXIoeyBuYW1lOiAnV2ViVHJhbnNwb3J0RlNNJyB9KTtcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0cmFuc3BvcnRJbjtcbiAgICBjb25zdCBmc20gPSB0aGlzO1xuICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBMb2dGb3JtYXR0ZXIoKTtcbiAgICBsb2dnZXIuZm9ybWF0dGVyID0gZnVuY3Rpb24gbG9nRm9ybWF0dGVyKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbYFt3ZWItdHJhbnNwb3J0LWZzbT0ke2dldElkKCl9XWAsIC4uLmFyZ3NdO1xuICAgIH07XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIud3JhcCh0aGlzLmxvZywgdGhpcyk7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgICB0aGlzLmluaXRpYWwoZnVuY3Rpb24gb25Jbml0aWFsKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgICB0aGlzLldlYlRyYW5zcG9ydERvd24sXG4gICAgICAgIChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgTE9HX1RSQUNFKGBTdGFydGluZyAke2NvbnRleHQuZ2V0U3RhdGVNYWNoaW5lKCkuZ2V0TmFtZSgpfWApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMudW5oYW5kbGVkRXZlbnRSZWFjdGlvbihmdW5jdGlvbiBvblVuaGFuZGxlZEV2ZW50KHdFdmVudCkge1xuICAgICAgTE9HX1RSQUNFKGBJZ25vcmluZyBldmVudCAke3dFdmVudC5nZXROYW1lKCl9IGluIHN0YXRlICR7dGhpcy5nZXRDdXJyZW50U3RhdGUoKS5nZXROYW1lKCl9YCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcblxuICAgIHRoaXMuV2ViVHJhbnNwb3J0RG93biA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBXZWJUcmFuc3BvcnRTdGF0ZS5ET1dOLFxuICAgICAgcGFyZW50Q29udGV4dDogdGhpcyxcbiAgICB9KVxuICAgICAgLnJlYWN0aW9uKFdlYlRyYW5zcG9ydEV2ZW50LkNPTk5FQ1QsIGZ1bmN0aW9uIG9uQ29ubmVjdCgvKiB3RWV2ZW50ICovKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2ViVHJhbnNwb3J0Q29ubmVjdGluZyk7XG4gICAgICB9KVxuICAgICAgLnJlYWN0aW9uKFdlYlRyYW5zcG9ydEV2ZW50LkRFU1RST1ksIGZ1bmN0aW9uIG9uRGVzdHJveSh3RXZlbnQpIHtcbiAgICAgICAgdHJhbnNwb3J0LmRlc3Ryb3lJbnRlcm5hbCh3RXZlbnQuX2Rlc3Ryb3lNc2csIHdFdmVudC5fc3ViY29kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2ViVHJhbnNwb3J0RGVzdHJveWluZyk7XG4gICAgICB9KTtcblxuICAgIHRoaXMuV2ViVHJhbnNwb3J0Q29ubmVjdGluZyA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBXZWJUcmFuc3BvcnRTdGF0ZS5DT05ORUNUSU5HLFxuICAgICAgcGFyZW50Q29udGV4dDogdGhpcyxcbiAgICB9KVxuICAgICAgLmVudHJ5KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByYyA9IHRyYW5zcG9ydC5jb25uZWN0SW50ZXJuYWwoKTtcbiAgICAgICAgICBpZiAocmMgIT09IFRyYW5zcG9ydFJldHVybkNvZGUuT0spIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5FcnJvciA9IHRyYW5zcG9ydC5nZXRDb25uRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IHdFdmVudCA9IG5ldyBGc21FdmVudCh7IG5hbWU6IFdlYlRyYW5zcG9ydEV2ZW50LkRFU1RST1kgfSk7XG4gICAgICAgICAgICB3RXZlbnQuX2Rlc3Ryb3lNc2cgPSBjb25uRXJyb3IgPyBjb25uRXJyb3IubWVzc2FnZSA6ICdFcnJvciBvY2N1cnJlZCB3aGlsZSBlc3RhYmxpc2hpbmcgdHJhbnNwb3J0JztcbiAgICAgICAgICAgIHdFdmVudC5fc3ViY29kZSA9IGNvbm5FcnJvciA/IGNvbm5FcnJvci5zdWJjb2RlIDogbnVsbDtcbiAgICAgICAgICAgIHdFdmVudC5fZXZlbnRSZWFzb24gPSBjb25uRXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRXZlbnQod0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBMT0dfREVCVUcoYHRyYW5zcG9ydC5jb25uZWN0SW50ZXJuYWwgdGhyZXc6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgIGNvbnN0IHdFdmVudCA9IG5ldyBGc21FdmVudCh7IG5hbWU6IFdlYlRyYW5zcG9ydEV2ZW50LkRFU1RST1kgfSk7XG4gICAgICAgICAgd0V2ZW50Ll9kZXN0cm95TXNnID0gZS5tZXNzYWdlO1xuICAgICAgICAgIHdFdmVudC5fc3ViY29kZSA9IGUuc3ViY29kZSA/IGUuc3ViY29kZSA6IEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SO1xuICAgICAgICAgIHdFdmVudC5fZXZlbnRSZWFzb24gPSBlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NFdmVudCh3RXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KVxuICAgICAgLy8gVHJhbnNwb3J0IGRlc3Ryb3kgaXMgYXN5bmMsIHNvIGluIGRvd25ncmFkZSBjYXNlcyB3ZSBuZWVkIGFuIGV2ZW50IHRvIHN0YXJ0IHRoZSBkb3duZ3JhZGVcbiAgICAgIC8vIChhbmQgYXNzb2NpYXRlZCB0cmFuc3BvcnQgZGVzdHJveSkgYW5kIG9uZSB0byBjb21wbGV0ZSBpdCAoREVTVFJPWUVEX05PVElDRSkuXG4gICAgICAvLyBUaGVzZSB0d28gZXZlbnRzIHRyaWdnZXIgZG93bmdyYWRlOiBTRU5EX0VSUk9SIG9uIGNvbm5lY3Rpb24gKHByb3RvY29sIGlzc3VlKSBhbmRcbiAgICAgIC8vIENPTk5FQ1RfVElNRU9VVCAocG9zc2libGUgYmxhY2sgaG9sZSBwcm94eSkuXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuU0VORF9FUlJPUiwgKHdFdmVudCkgPT4ge1xuICAgICAgICB0cmFuc3BvcnQubm90aWZ5RXZlbnQod0V2ZW50Ll90cmFuc3BvcnRFdmVudCk7IC8vIEdpdmUgdGhlIHNlc3Npb24gYSBjaGFuY2UgdG8gaW50ZXJ2ZW5lXG4gICAgICAgIHJldHVybiBmc20uYXR0ZW1wdERvd25ncmFkZSh3RXZlbnQuX3RyYW5zcG9ydEV2ZW50KTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuQ09OTkVDVF9USU1FT1VULCBlID0+IGZzbS5hdHRlbXB0RG93bmdyYWRlKGUuX3RyYW5zcG9ydEV2ZW50KSlcbiAgICAgIC5yZWFjdGlvbihXZWJUcmFuc3BvcnRFdmVudC5ERVNUUk9ZRURfTk9USUNFLCAod0V2ZW50KSA9PiB7XG4gICAgICAgIHRyYW5zcG9ydC5ub3RpZnlFdmVudCh3RXZlbnQuX3RyYW5zcG9ydEV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnREb3duKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuVVBfTk9USUNFLCBmdW5jdGlvbiBvblVwTm90aWNlKHdFdmVudCkge1xuICAgICAgICB0cmFuc3BvcnQubm90aWZ5RXZlbnQod0V2ZW50Ll90cmFuc3BvcnRFdmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2ViVHJhbnNwb3J0VXApO1xuICAgICAgfSlcbiAgICAgIC5yZWFjdGlvbihXZWJUcmFuc3BvcnRFdmVudC5ERVNUUk9ZLCBmdW5jdGlvbiBvbkRlc3Ryb3kod0V2ZW50KSB7XG4gICAgICAgIHRyYW5zcG9ydC5kZXN0cm95SW50ZXJuYWwod0V2ZW50Ll9kZXN0cm95TXNnLCB3RXZlbnQuX3N1YmNvZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8oZnNtLldlYlRyYW5zcG9ydERlc3Ryb3lpbmcpO1xuICAgICAgfSk7XG4gICAgdGhpcy5XZWJUcmFuc3BvcnREb3duZ3JhZGluZyA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBXZWJUcmFuc3BvcnRTdGF0ZS5ET1dOR1JBRElORyxcbiAgICAgIHBhcmVudENvbnRleHQ6IHRoaXMsXG4gICAgfSlcbiAgICAgIC5yZWFjdGlvbihXZWJUcmFuc3BvcnRFdmVudC5ERVNUUk9ZRURfTk9USUNFLCBmdW5jdGlvbiBvbkRlc3Ryb3llZCh3RXZlbnQpIHtcbiAgICAgICAgTE9HX0RFQlVHKCdXZWIgdHJhbnNwb3J0OiByZXF1ZXN0IGRvd25ncmFkZScpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5jb21wbGV0ZURvd25ncmFkZSgpKSB7XG4gICAgICAgICAgTE9HX0RFQlVHKCdXZWIgdHJhbnNwb3J0OiBjb25uZWN0aW9uIGVycm9yLCBubyBkb3duZ3JhZGUnKTtcbiAgICAgICAgICB0cmFuc3BvcnQubm90aWZ5RXZlbnQod0V2ZW50Ll90cmFuc3BvcnRFdmVudCk7XG4gICAgICAgICAgZnNtLm5vdGlmeURvd25ncmFkZUZhaWxlZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2ViVHJhbnNwb3J0RG93bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnRDb25uZWN0aW5nKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuREVTVFJPWSwgZnVuY3Rpb24gb25EZXN0cm95KHdFdmVudCkge1xuICAgICAgICB0cmFuc3BvcnQuZGVzdHJveUludGVybmFsKHdFdmVudC5fZGVzdHJveU1zZywgd0V2ZW50Ll9zdWJjb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnREZXN0cm95aW5nKTtcbiAgICAgIH0pO1xuICAgIHRoaXMuV2ViVHJhbnNwb3J0VXAgPSBuZXcgU3RhdGUoe1xuICAgICAgbmFtZTogICAgICAgICAgV2ViVHJhbnNwb3J0U3RhdGUuVVAsXG4gICAgICBwYXJlbnRDb250ZXh0OiB0aGlzLFxuICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuRE9XTkdSQURFLCB3RXZlbnQgPT5cbiAgICAgICAgZnNtLmF0dGVtcHREb3duZ3JhZGUobmV3IFRyYW5zcG9ydFNlc3Npb25FdmVudCh3RXZlbnQuX2Rvd25ncmFkZU1zZywgd0V2ZW50Ll9zdWJjb2RlKSkpXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuREVTVFJPWUVEX05PVElDRSwgZnVuY3Rpb24gb25EZXN0cm95ZWQod0V2ZW50KSB7XG4gICAgICAgIHRyYW5zcG9ydC5ub3RpZnlFdmVudCh3RXZlbnQuX3RyYW5zcG9ydEV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnREb3duKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuREVTVFJPWSwgZnVuY3Rpb24gb25EZXN0cm95KHdFdmVudCkge1xuICAgICAgICB0cmFuc3BvcnQuZGVzdHJveUludGVybmFsKHdFdmVudC5fZGVzdHJveU1zZywgd0V2ZW50Ll9zdWJjb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnREZXN0cm95aW5nKTtcbiAgICAgIH0pXG4gICAgICAucmVhY3Rpb24oV2ViVHJhbnNwb3J0RXZlbnQuU0VORF9FUlJPUiwgZnVuY3Rpb24gb25VcE5vdGljZSh3RXZlbnQpIHtcbiAgICAgICAgdHJhbnNwb3J0Lm5vdGlmeUV2ZW50KHdFdmVudC5fdHJhbnNwb3J0RXZlbnQpO1xuICAgICAgICB0cmFuc3BvcnQuZGVzdHJveUludGVybmFsKHdFdmVudC5fZGVzdHJveU1zZywgd0V2ZW50Ll9zdWJjb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKGZzbS5XZWJUcmFuc3BvcnREZXN0cm95aW5nKTtcbiAgICAgIH0pO1xuICAgIHRoaXMuV2ViVHJhbnNwb3J0RGVzdHJveWluZyA9IG5ldyBTdGF0ZSh7XG4gICAgICBuYW1lOiAgICAgICAgICBXZWJUcmFuc3BvcnRTdGF0ZS5ERVNUUk9ZSU5HLFxuICAgICAgcGFyZW50Q29udGV4dDogdGhpcyxcbiAgICB9KVxuICAgICAgLnJlYWN0aW9uKFdlYlRyYW5zcG9ydEV2ZW50LkRFU1RST1lFRF9OT1RJQ0UsIGZ1bmN0aW9uIG9uRGVzdHJveWVkKHdFdmVudCkge1xuICAgICAgICB0cmFuc3BvcnQubm90aWZ5RXZlbnQod0V2ZW50Ll90cmFuc3BvcnRFdmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyhmc20uV2ViVHJhbnNwb3J0RG93bik7XG4gICAgICB9KTtcbiAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IGEgZG93bmdyYWRlLiBUaGlzIGlzIHRoZSBwcm9jZWR1cmUuXG4gICAgICogMS4gQ2FsbCB0aGlzLiBJZiBpdCByZXR1cm5zIHRydWUsIHdhaXQgZm9yIERFU1RST1lFRF9OT1RJQ0UsIHRoZW5cbiAgICAgKiAyLiBDYWxsIHRyYW5zcG9ydC5jb21wbGV0ZURvd25ncmFkZSgpLlxuICAgICAqIEBwYXJhbSB7VHJhbnNwb3J0U2Vzc2lvbkV2ZW50fSB0c0V2ZW50IFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoZSBkb3duZ3JhZGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGRvd25ncmFkZSBpcyBzdGFydGluZyAoYnkgZGVzdHJveWluZyB0aGUgdHJhbnNwb3J0KVxuICAgICAqL1xuICBhdHRlbXB0RG93bmdyYWRlKHRzRXZlbnQpIHtcbiAgICBjb25zdCB7IGluZm9TdHIsIGVycm9yU3ViY29kZSB9ID0gdHNFdmVudDtcbiAgICBpZiAoIXRoaXMudHJhbnNwb3J0LmJlZ2luRG93bmdyYWRlKGluZm9TdHIsIGVycm9yU3ViY29kZSkpIHtcbiAgICAgIExPR19UUkFDRSgnRG93bmdyYWRlIHVuYXZhaWxhYmxlJyk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5kZXN0cm95SW50ZXJuYWwoaW5mb1N0ciwgZXJyb3JTdWJjb2RlKTtcbiAgICAgIHRoaXMudHJhbnNwb3J0Lm5vdGlmeUV2ZW50KHRzRXZlbnQpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRoaXMuV2ViVHJhbnNwb3J0RGVzdHJveWluZyk7XG4gICAgfVxuICAgIExPR19UUkFDRSgnRG93bmdyYWRlIGF2YWlsYWJsZScpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25Ubyh0aGlzLldlYlRyYW5zcG9ydERvd25ncmFkaW5nKTtcbiAgfVxuXG4gIG5vdGlmeURvd25ncmFkZUZhaWxlZCgpIHtcbiAgICBMT0dfVFJBQ0UoJ05vdGlmeWluZyBvZiBkb3duZ3JhZGUgZmFpbHVyZScpO1xuICAgIHRoaXMudHJhbnNwb3J0Lm5vdGlmeUV2ZW50KG5ldyBUcmFuc3BvcnRTZXNzaW9uRXZlbnQoVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5ET1dOR1JBREVfRkFJTEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEb3duZ3JhZGUgZmFpbGVkJykpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLldlYlRyYW5zcG9ydEZTTSA9IFdlYlRyYW5zcG9ydEZTTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtZnNtLmpzIiwiY29uc3QgeyBFbnVtIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXNraXQnKTtcblxuLy8gV2ViVHJhbnNwb3J0IHN0YXRlcywgdXNlZCBieSBXZWJUcmFuc3BvcnRcbmNvbnN0IFdlYlRyYW5zcG9ydFN0YXRlID0ge1xuICBET1dOOiAgICAgICAgJ1dlYlRyYW5zcG9ydERvd24nLFxuICBDT05ORUNUSU5HOiAgJ1dlYlRyYW5zcG9ydENvbm5lY3RpbmcnLFxuICBET1dOR1JBRElORzogJ1dlYlRyYW5zcG9ydERvd25ncmFkaW5nJyxcbiAgREVTVFJPWUlORzogICdXZWJUcmFuc3BvcnREZXN0cm95aW5nJyxcbiAgVVA6ICAgICAgICAgICdXZWJUcmFuc3BvcnRVcCcsXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5XZWJUcmFuc3BvcnRTdGF0ZSA9IEVudW0ubmV3KFdlYlRyYW5zcG9ydFN0YXRlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYi10cmFuc3BvcnQtc3RhdGVzLmpzIiwiY29uc3Qge1xuICBFcnJvclN1YmNvZGUsXG4gIE9wZXJhdGlvbkVycm9yLFxufSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuY29uc3Qge1xuICBIVFRQVHJhbnNwb3J0U2Vzc2lvbixcbn0gPSByZXF1aXJlKCcuL2h0dHAnKTtcbmNvbnN0IHtcbiAgTE9HX1RSQUNFLFxuICBMT0dfREVCVUcsXG4gIExPR19FUlJPUixcbn0gPSByZXF1aXJlKCdzb2xjbGllbnQtbG9nJyk7XG5jb25zdCB7IEZzbUV2ZW50IH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZnNtJyk7XG5jb25zdCB7IFRyYW5zcG9ydEJhc2UgfSA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydC1iYXNlJyk7XG5jb25zdCB7IFRyYW5zcG9ydFByb3RvY29sIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtcHJvdG9jb2xzJyk7XG5jb25zdCB7IFRyYW5zcG9ydFByb3RvY29sSGFuZGxlciB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXByb3RvY29sLWhhbmRsZXInKTtcbmNvbnN0IHsgVHJhbnNwb3J0UmV0dXJuQ29kZSB9ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0LXJldHVybi1jb2RlcycpO1xuY29uc3QgeyBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlIH0gPSByZXF1aXJlKCcuLi90cmFuc3BvcnQtc2Vzc2lvbi1ldmVudC1jb2RlcycpO1xuY29uc3QgeyBXZWJTb2NrZXRUcmFuc3BvcnRTZXNzaW9uIH0gPSByZXF1aXJlKCcuL3dlYnNvY2tldC10cmFuc3BvcnQtc2Vzc2lvbicpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRFdmVudCB9ID0gcmVxdWlyZSgnLi93ZWItdHJhbnNwb3J0LWV2ZW50cycpO1xuY29uc3QgeyBXZWJUcmFuc3BvcnRGU00gfSA9IHJlcXVpcmUoJy4vd2ViLXRyYW5zcG9ydC1mc20nKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgYWxsIHRoZSB3ZWIgYmFzZWQgdHJhbnNwb3J0IHByb3RvY29scy5cbiAqIDx1bD5cbiAqICAgICA8bGk+e0BsaW5rIFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQkFTRTY0fVxuICogICAgIDxsaT57QGxpbmsgVHJhbnNwb3J0UHJvdG9jb2wuSFRUUF9CSU5BUll9XG4gKiAgICAgPGxpPntAbGluayBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWV9TVFJFQU1JTkd9XG4gKiAgICAgPGxpPntAbGluayBUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUll9XG4gKiA8L3VsPlxuICogQGV4dGVuZHMgVHJhbnNwb3J0QmFzZVxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgV2ViVHJhbnNwb3J0IGV4dGVuZHMgVHJhbnNwb3J0QmFzZSB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1VSTH0gdXJsIFRoZSB1cmwgdG8gY29ubmVjdCB0b1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudENCIFRoZSBjYWxsYmFjayBmb3IgdHJhbnNwb3J0IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Jhc2VTTUZDbGllbnR9IGNsaWVudCBBbiBTTUYgY2xpZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBZGRpdGlvbmFsIHRyYW5zcG9ydCBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldElkIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoaXMgdHJhbnNwb3J0J3MgdW5pcXVlIElEXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIGV2ZW50Q0IsIGNsaWVudCwgcHJvcHMsIGdldElkKSB7XG4gICAgc3VwZXIodXJsLCBldmVudENCLCBjbGllbnQsIHByb3BzKTtcbiAgICBMT0dfVFJBQ0UoYHdlYlRyYW5zcG9ydFByb3RvY29sTGlzdCAke3Byb3BzLndlYlRyYW5zcG9ydFByb3RvY29sTGlzdH1gKTtcbiAgICB0aGlzLl90cmFuc3BvcnRIYW5kbGVyID0gbmV3IFRyYW5zcG9ydFByb3RvY29sSGFuZGxlcih1cmwsIHByb3BzLndlYlRyYW5zcG9ydFByb3RvY29sTGlzdCk7XG4gICAgdGhpcy5fd2ViVHJhbnNwb3J0RnNtID0gbmV3IFdlYlRyYW5zcG9ydEZTTSh0aGlzLCBnZXRJZCk7XG4gICAgdGhpcy5fd2ViVHJhbnNwb3J0RnNtLnN0YXJ0KCk7XG4gIH1cblxuICBub3RpZnlFdmVudChldmVudCkge1xuICAgIHRoaXMuX2V2ZW50Q0IoZXZlbnQpO1xuICB9XG5cbiAgaGFuZGxlRGVzdHJveWVkKCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydFNlc3Npb24gPSBudWxsO1xuICB9XG5cbiAgaGFuZGxlVHJhbnNwb3J0RXZlbnQodHJhbnNwb3J0RXZlbnQpIHtcbiAgICBMT0dfREVCVUcoYFdlYiB0cmFuc3BvcnQgcmVjZWl2ZSB0cmFuc3BvcnQgZXZlbnQ6ICR7dHJhbnNwb3J0RXZlbnR9YCk7XG4gICAgbGV0IHdFdmVudDtcbiAgICBzd2l0Y2ggKHRyYW5zcG9ydEV2ZW50LmdldFRyYW5zcG9ydEV2ZW50Q29kZSgpKSB7XG4gICAgICBjYXNlIFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuVVBfTk9USUNFOlxuICAgICAgICB3RXZlbnQgPSBuZXcgRnNtRXZlbnQoeyBuYW1lOiBXZWJUcmFuc3BvcnRFdmVudC5VUF9OT1RJQ0UgfSk7XG4gICAgICAgIHdFdmVudC5fdHJhbnNwb3J0RXZlbnQgPSB0cmFuc3BvcnRFdmVudDtcbiAgICAgICAgdGhpcy5fd2ViVHJhbnNwb3J0RnNtLnByb2Nlc3NFdmVudCh3RXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLkRFU1RST1lFRF9OT1RJQ0U6XG4gICAgICAgIHRoaXMuaGFuZGxlRGVzdHJveWVkKCk7XG4gICAgICAgIHdFdmVudCA9IG5ldyBGc21FdmVudCh7IG5hbWU6IFdlYlRyYW5zcG9ydEV2ZW50LkRFU1RST1lFRF9OT1RJQ0UgfSk7XG4gICAgICAgIHdFdmVudC5fdHJhbnNwb3J0RXZlbnQgPSB0cmFuc3BvcnRFdmVudDtcbiAgICAgICAgdGhpcy5fd2ViVHJhbnNwb3J0RnNtLnByb2Nlc3NFdmVudCh3RXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLlNFTkRfRVJST1I6XG4gICAgICAgIHdFdmVudCA9IG5ldyBGc21FdmVudCh7IG5hbWU6IFdlYlRyYW5zcG9ydEV2ZW50LlNFTkRfRVJST1IgfSk7XG4gICAgICAgIHdFdmVudC5fdHJhbnNwb3J0RXZlbnQgPSB0cmFuc3BvcnRFdmVudDtcbiAgICAgICAgdGhpcy5fd2ViVHJhbnNwb3J0RnNtLnByb2Nlc3NFdmVudCh3RXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRTZXNzaW9uRXZlbnRDb2RlLkNPTk5FQ1RfVElNRU9VVDpcbiAgICAgICAgd0V2ZW50ID0gbmV3IEZzbUV2ZW50KHsgbmFtZTogV2ViVHJhbnNwb3J0RXZlbnQuQ09OTkVDVF9USU1FT1VUIH0pO1xuICAgICAgICB3RXZlbnQuX3RyYW5zcG9ydEV2ZW50ID0gdHJhbnNwb3J0RXZlbnQ7XG4gICAgICAgIHRoaXMuX3dlYlRyYW5zcG9ydEZzbS5wcm9jZXNzRXZlbnQod0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHJhbnNwb3J0U2Vzc2lvbkV2ZW50Q29kZS5ET1dOR1JBREVfRkFJTEVEOlxuICAgICAgICB0aGlzLl9sYXN0RG93bmdyYWRlU3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRyYW5zcG9ydFNlc3Npb25FdmVudENvZGUuRE9XTkdSQURFX1NVQ0NFRURFRDpcbiAgICAgICAgdGhpcy5fbGFzdERvd25ncmFkZVN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBBbGwgb3RoZXIgdHJhbnNwb3J0IGV2ZW50cyBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgd2ViIHRyYW5zcG9ydCBhbmQgYXJlIHBhc3NlZCB0aHJvdWdoXG4gICAgICAgIHRoaXMuX2V2ZW50Q0IodHJhbnNwb3J0RXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgY29uc3Qgd0V2ZW50ID0gbmV3IEZzbUV2ZW50KHsgbmFtZTogV2ViVHJhbnNwb3J0RXZlbnQuQ09OTkVDVCB9KTtcbiAgICB0aGlzLl93ZWJUcmFuc3BvcnRGc20ucHJvY2Vzc0V2ZW50KHdFdmVudCk7XG4gICAgcmV0dXJuIFRyYW5zcG9ydFJldHVybkNvZGUuT0s7XG4gIH1cblxuICBjb25uZWN0SW50ZXJuYWwoKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0U2Vzc2lvbiA9IG51bGw7XG4gICAgY29uc3QgdHBQcm90b2NvbCA9IHRoaXMuX3RyYW5zcG9ydEhhbmRsZXIuZ2V0VHJhbnNwb3J0UHJvdG9jb2woKTtcbiAgICB0aGlzLl9wcm9wcy50cmFuc3BvcnRQcm90b2NvbCA9IHRwUHJvdG9jb2w7XG4gICAgc3dpdGNoICh0cFByb3RvY29sKSB7XG4gICAgICBjYXNlIFRyYW5zcG9ydFByb3RvY29sLkhUVFBfQkFTRTY0OlxuICAgICAgY2FzZSBUcmFuc3BvcnRQcm90b2NvbC5IVFRQX0JJTkFSWTpcbiAgICAgIGNhc2UgVHJhbnNwb3J0UHJvdG9jb2wuSFRUUF9CSU5BUllfU1RSRUFNSU5HOlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRTZXNzaW9uID0gbmV3IEhUVFBUcmFuc3BvcnRTZXNzaW9uKFxuICAgICAgICAgIHRoaXMuX3VybCxcbiAgICAgICAgICBldnQgPT4gdGhpcy5oYW5kbGVUcmFuc3BvcnRFdmVudChldnQpLFxuICAgICAgICAgIHRoaXMuX2NsaWVudCxcbiAgICAgICAgICB0aGlzLl9wcm9wc1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc3BvcnRQcm90b2NvbC5XU19CSU5BUlk6XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFNlc3Npb24gPSBuZXcgV2ViU29ja2V0VHJhbnNwb3J0U2Vzc2lvbihcbiAgICAgICAgICB0aGlzLl91cmwsXG4gICAgICAgICAgZXZ0ID0+IHRoaXMuaGFuZGxlVHJhbnNwb3J0RXZlbnQoZXZ0KSxcbiAgICAgICAgICB0aGlzLl9jbGllbnQsXG4gICAgICAgICAgdGhpcy5fcHJvcHNcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIExPR19FUlJPUihgV2ViIHRyYW5zcG9ydCB1bnJlY29nbml6ZWQgVHJhbnNwb3J0UHJvdG9jb2w6ICR7dHBQcm90b2NvbH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBObyB0cmFuc3BvcnQgc2Vzc2lvbiBwcm92aWRlciBmb3Igc2NoZW1lOiAke3RwUHJvdG9jb2x9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5DT05ORUNUSU9OX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHBQcm90b2NvbCk7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKGBDb25uZWN0IFRyYW5zcG9ydCAke3RwUHJvdG9jb2x9YCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydFNlc3Npb24uY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZGVzdHJveShtc2csIHN1YmNvZGUpIHtcbiAgICBjb25zdCB3RXZlbnQgPSBuZXcgRnNtRXZlbnQoeyBuYW1lOiBXZWJUcmFuc3BvcnRFdmVudC5ERVNUUk9ZIH0pO1xuICAgIHdFdmVudC5fZGVzdHJveU1zZyA9IG1zZztcbiAgICB3RXZlbnQuX3N1YmNvZGUgPSBzdWJjb2RlO1xuICAgIHRoaXMuX3dlYlRyYW5zcG9ydEZzbS5wcm9jZXNzRXZlbnQod0V2ZW50KTtcbiAgICByZXR1cm4gVHJhbnNwb3J0UmV0dXJuQ29kZS5PSztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIFRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZG93bmdyYWRlXG4gICAqIEBwYXJhbSB7RXJyb3JTdWJjb2RlfSBzdWJjb2RlIFRoZSBzdWJjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZG93bmdyYWRlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlcmUgYXJlIGRvd25ncmFkZSBvcHRpb25zIGF2YWlsYWJsZS4gYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiZWdpbkRvd25ncmFkZShtc2csIHN1YmNvZGUpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0SGFuZGxlci5jYW5Db21wbGV0ZURvd25ncmFkZSgpKSB7XG4gICAgICBMT0dfVFJBQ0UoJ1dlYiB0cmFuc3BvcnQgZG93bmdyYWRlJyk7XG4gICAgICAvLyBEZXN0cm95IHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBzZXNzaW9uXG4gICAgICAvLyBUaGlzIHdpbGwgYXN5bmNocm9ub3VzbHkgY2F1c2UgREVTVFJPWUVEX05PVElDRSB0byBiZSBlbWl0dGVkLlxuICAgICAgLy8gVGhlIHJlY2VpdmVyIGNhbiB0aGVuIGNhbGwgY29tcGxldGVEb3duZ3JhZGUsIHdoaWNoIHdpbGwgY29tcGxldGUgdGhlIGRvd25ncmFkZS5cbiAgICAgIHRoaXMuZGVzdHJveUludGVybmFsKG1zZywgc3ViY29kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTE9HX1RSQUNFKCdXZWIgdHJhbnNwb3J0IGRvd25ncmFkZSByZWplY3RlZCcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbXBsZXRlRG93bmdyYWRlKCkge1xuICAgIGlmICghdGhpcy5fdHJhbnNwb3J0SGFuZGxlci5jYW5Db21wbGV0ZURvd25ncmFkZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRIYW5kbGVyLmNvbXBsZXRlRG93bmdyYWRlKCk7XG4gIH1cblxuICBkZXN0cm95SW50ZXJuYWwobXNnLCBzdWJjb2RlKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFNlc3Npb24pIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFNlc3Npb24uZGVzdHJveShtc2csIHN1YmNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGZsdXNoKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydFNlc3Npb24uZmx1c2goY2FsbGJhY2spO1xuICB9XG5cbiAgZ2V0Q29ubkVycm9yKCkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRTZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0U2Vzc2lvbi5fY29ubkVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEluZm9TdHIoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFNlc3Npb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRTZXNzaW9uLmdldEluZm9TdHIoKTtcbiAgICB9XG4gICAgcmV0dXJuICdOb3QgY29ubmVjdGVkLic7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXRUcmFuc3BvcnRQcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0SGFuZGxlci5nZXRUcmFuc3BvcnRQcm90b2NvbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0Q2xpZW50U3RhdHMoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFNlc3Npb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRTZXNzaW9uLmdldENsaWVudFN0YXRzKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVxdWVzdERvd25ncmFkZShtc2csIHN1YmNvZGUpIHtcbiAgICBMT0dfVFJBQ0UoJ0NyZWF0aW5nIGRvd25ncmFkZSByZXF1ZXN0IGV2ZW50Jyk7XG4gICAgdGhpcy5fbGFzdERvd25ncmFkZVN1Y2NlZWRlZCA9IHVuZGVmaW5lZDsgLy8gd2lsbCBiZSByZXNldCBieSBoYW5kbGVyIGZvciBUUyBET1dOR1JBREVfIGV2ZW50c1xuICAgIGNvbnN0IHdFdmVudCA9IG5ldyBGc21FdmVudCh7IG5hbWU6IFdlYlRyYW5zcG9ydEV2ZW50LkRPV05HUkFERSB9KTtcbiAgICB3RXZlbnQuX2Rvd25ncmFkZU1zZyA9IG1zZztcbiAgICB3RXZlbnQuX3N1YmNvZGUgPSBzdWJjb2RlO1xuICAgIHRoaXMuX3dlYlRyYW5zcG9ydEZzbS5wcm9jZXNzRXZlbnQod0V2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fbGFzdERvd25ncmFkZVN1Y2NlZWRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNlbmQobWVzc2FnZSwgZm9yY2VBbGxvd0VucXVldWUpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0U2Vzc2lvbi5zZW5kKG1lc3NhZ2UsIGZvcmNlQWxsb3dFbnF1ZXVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5XZWJUcmFuc3BvcnQgPSBXZWJUcmFuc3BvcnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC10cmFuc3BvcnQvbGliL3dlYi93ZWItdHJhbnNwb3J0LmpzIiwibW9kdWxlLmV4cG9ydHMuV2ViU29ja2V0Q2xvc2VDb2RlcyA9IHtcbiAgMDoge1xuICAgIG5hbWU6ICAgICAgICAnVW5rbm93biBjb2RlJyxcbiAgICBkZXNjcmlwdGlvbjogJ05vIHN0YXR1cyBjb2RlIHdhcyByZXR1cm5lZCBieSB0aGUgb3BlcmF0aW9uJyxcbiAgfSxcbiAgMTAwMDoge1xuICAgIG5hbWU6ICAgICAgICAnTm9ybWFsIENsb3N1cmUnLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIGNvbm5lY3Rpb24gY2xvc2VkIG5vcm1hbGx5JyxcbiAgfSxcbiAgMTAwMToge1xuICAgIG5hbWU6ICAgICAgICAnR29pbmcgQXdheScsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgZW5kcG9pbnQgaXMgZ29pbmcgYXdheSBkdWUgdG8gYSBzZXJ2ZXIgZmFpbHVyZSBvciBjbGllbnQgbmF2aWdhdGlvbicsXG4gIH0sXG4gIDEwMDI6IHtcbiAgICBuYW1lOiAgICAgICAgJ1Byb3RvY29sIEVycm9yJyxcbiAgICBkZXNjcmlwdGlvbjogJ0EgV2ViU29ja2V0IHByb3RvY29sIGVycm9yIG9jY3VycmVkJyxcbiAgfSxcbiAgMTAwMzoge1xuICAgIG5hbWU6ICAgICAgICAnVW5zdXBwb3J0ZWQgRGF0YScsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgZW5kcG9pbnQgY2Fubm90IGhhbmRsZSB0aGUgc3BlY2lmaWVkIGRhdGEgdHlwZScsXG4gIH0sXG4gIDEwMDQ6IHtcbiAgICBuYW1lOiAgICAgICAgJ1Jlc2VydmVkJyxcbiAgICBkZXNjcmlwdGlvbjogJycsXG4gIH0sXG4gIDEwMDU6IHtcbiAgICBuYW1lOiAgICAgICAgJ05vIFN0YXR1cyBSZWN2ZCcsXG4gICAgZGVzY3JpcHRpb246ICdFeHBlY3RlZCBhIHN0YXR1cyBjb2RlIGJ1dCBub25lIHdhcyBwcm92aWRlZCcsXG4gIH0sXG4gIDEwMDY6IHtcbiAgICBuYW1lOiAgICAgICAgJ0Fibm9ybWFsIENsb3N1cmUnLFxuICAgIGRlc2NyaXB0aW9uOiAnTm8gY2xvc2UgZnJhbWUgd2FzIHJlY2VpdmVkIGJlZm9yZSByZW1vdGUgaGFuZ3VwJyxcbiAgfSxcbiAgMTAwNzoge1xuICAgIG5hbWU6ICAgICAgICAnSW52YWxpZCBGcmFtZSBQYXlsb2FkIERhdGEnLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBtZXNzYWdlIGNvbnRhaW5lZCBkYXRhIGluY29uc2lzdGVudCB3aXRoIGl0cyBlbmNvZGluZycsXG4gIH0sXG4gIDEwMDg6IHtcbiAgICBuYW1lOiAgICAgICAgJ1BvbGljeSBWaW9sYXRpb24nLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBtZXNzYWdlIHZpb2xhdGVkIGVuZHBvaW50IHBvbGljeScsXG4gIH0sXG4gIDEwMDk6IHtcbiAgICBuYW1lOiAgICAgICAgJ01lc3NhZ2UgVG9vIEJpZycsXG4gICAgZGVzY3JpcHRpb246ICdBIGRhdGEgZnJhbWUgd2FzIHRvbyBsYXJnZScsXG4gIH0sXG4gIDEwMTA6IHtcbiAgICBuYW1lOiAgICAgICAgJ01pc3NpbmcgRXh0ZW5zaW9uJyxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBlbmRwb2ludCBkaWQgbm90IG5lZ290aWF0ZSBhbiBleHBlY3RlZCBleHRlbnNpb24nLFxuICB9LFxuICAxMDExOiB7XG4gICAgbmFtZTogICAgICAgICdJbnRlcm5hbCBFcnJvcicsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgc2VydmVyIGVuY291bnRlcmVkIGFuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHRoYXQgcHJldmVudGVkIGl0IGZyb20gZnVsZmlsbGluZyB0aGUgcmVxdWVzdCcsXG4gIH0sXG4gIDEwMTI6IHtcbiAgICBuYW1lOiAgICAgICAgJ1NlcnZpY2UgUmVzdGFydCcsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgc2VydmVyIGlzIHJlc3RhcnRpbmcnLFxuICB9LFxuICAxMDEzOiB7XG4gICAgbmFtZTogICAgICAgICdUcnkgQWdhaW4gTGF0ZXInLFxuICAgIGRlc2NyaXB0aW9uOiAnVGhlIHNlcnZlciBpcyB0ZXJtaW5hdGluZyB0aGUgY29ubmVjdGlvbiBkdWUgdG8gYSB0ZW1wb3JhcnkgY29uZGl0aW9uJyxcbiAgfSxcbiAgMTAxNDoge1xuICAgIG5hbWU6ICAgICAgICAnQmFkIEdhdGV3YXknLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBnYXRld2F5IG9yIHByb3h5IHJlY2VpdmVkIGFuIGludmFsaWQgcmVzcG9uc2UgZnJvbSB0aGUgdXBzdHJlYW0gc2VydmVyJyxcbiAgfSxcbiAgMTAxNToge1xuICAgIG5hbWU6ICAgICAgICAnVExTIEhhbmRzaGFrZScsXG4gICAgZGVzY3JpcHRpb246ICdUaGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGR1ZSB0byBhIGZhaWx1cmUgdG8gcGVyZm9ybSBhIFRMUyBoYW5kc2hha2UnLFxuICB9LFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXRyYW5zcG9ydC9saWIvd2ViL3dlYnNvY2tldC1jbG9zZS1jb2Rlcy5qcyIsImNvbnN0IHsgQ2hlY2sgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC12YWxpZGF0ZScpO1xuY29uc3QgeyBFcnJvclN1YmNvZGUsIE9wZXJhdGlvbkVycm9yIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZXJyb3InKTtcblxuY29uc3QgQVBJUHJvcGVydGllc1ZhbGlkYXRvcnMgPSB7XG4gIHZhbGlkYXRlSW5zdGFuY2UodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lLCAuLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKChjaGVjaykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gY2hlY2suc2hpZnQoKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRvckFyZ3MgPSBbdHlwZURlc2MsIGluc3RhbmNlLCBuYW1lLCAuLi5jaGVja107XG4gICAgICB2YWxpZGF0b3IoLi4udmFsaWRhdG9yQXJncyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgdmFsSW5zdGFuY2UodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lLCB0eXBlSW5zdGFuY2UsIHR5cGVJbnN0YW5jZURlc2MpIHtcbiAgICBpZiAoIUNoZWNrLmluc3RhbmNlT2YoaW5zdGFuY2VbbmFtZV0sIHR5cGVJbnN0YW5jZSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIG11c3QgYmUgaW5zdGFuY2Ugb2YgJHt0eXBlSW5zdGFuY2VEZXNjfWApO1xuICAgIH1cbiAgfSxcblxuICB2YWxOb3RFbXB0eSh0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgICBpZiAoQ2hlY2subm9uZShpbnN0YW5jZVtuYW1lXSkgfHwgaW5zdGFuY2VbbmFtZV0gPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgY2Fubm90IGJlIGVtcHR5LmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsTGVuZ3RoKHR5cGVEZXNjLCBpbnN0YW5jZSwgbmFtZSwgbWF4KSB7XG4gICAgaWYgKENoZWNrLnN0cmluZyhpbnN0YW5jZVtuYW1lXSkgJiYgaW5zdGFuY2VbbmFtZV0ubGVuZ3RoID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgZXhjZWVkZWQgbWF4IGxlbmd0aCAke21heH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICB9LFxuXG4gIHZhbFJhbmdlKHR5cGVEZXNjLCBpbnN0YW5jZSwgbmFtZSwgbWluLCBtYXgpIHtcbiAgICBpZiAoQ2hlY2subnVtYmVyKGluc3RhbmNlW25hbWVdKSAmJiAoaW5zdGFuY2VbbmFtZV0gPCBtaW4gfHwgaW5zdGFuY2VbbmFtZV0gPiBtYXgpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIG91dCBvZiByYW5nZSBbJHttaW59OyAke21heH1dLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICB9LFxuXG4gIHZhbFN0cmluZyh0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgICBpZiAoIUNoZWNrLnN0cmluZyhpbnN0YW5jZVtuYW1lXSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBtdXN0IGJlIHR5cGUgc3RyaW5nOyB3YXMgJHt0eXBlb2YgaW5zdGFuY2VbbmFtZV19YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cbiAgfSxcblxuICB2YWxOdW1iZXIodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgaWYgKCFDaGVjay5udW1iZXIoaW5zdGFuY2VbbmFtZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgbXVzdCBiZSB0eXBlIG51bWJlcjsgd2FzICR7dHlwZW9mIGluc3RhbmNlW25hbWVdfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsQm9vbGVhbih0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgICBjb25zdCB2YWwgPSBpbnN0YW5jZVtuYW1lXTtcbiAgICBpZiAoIUNoZWNrLmJvb2xlYW4odmFsKSkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0nIG11c3QgYmUgdHlwZSBib29sZWFuOyB3YXMgJHt0eXBlb2YgdmFsfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsSXNNZW1iZXIodHlwZURlc2MsIGluc3RhbmNlLCBrZXksIGVudW1JbnN0YW5jZSwgZW51bU5hbWUsIGFsbG93TnVsbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdmFsID0gaW5zdGFuY2Vba2V5XTtcbiAgICBpZiAoYWxsb3dOdWxsICYmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpKSByZXR1cm47XG4gICAgaWYgKGVudW1JbnN0YW5jZS52YWx1ZXMuaW5kZXhPZih2YWwpID49IDApIHJldHVybjtcbiAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke2tleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9Jz0ke3ZhbH0gbXVzdCBiZSBhIG1lbWJlciBvZiAke2VudW1OYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgfSxcblxuICB2YWxTdHJpbmdPckFycmF5KHR5cGVEZXNjLCBpbnN0YW5jZSwgbmFtZSkge1xuICAgIGNvbnN0IHZhbCA9IGluc3RhbmNlW25hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsQXJyYXlJc01lbWJlcih0eXBlRGVzYywgaW5zdGFuY2UsIG5hbWUsIGVudW1JbnN0YW5jZSwgZW51bU5hbWUsXG4gICAgICAgICAgICAgICAgICAgYWxsb3dVbmRlZmluZWQsIGFsbG93RW1wdHksIGFsbG93RHVwbGljYXRlKSB7XG4gICAgY29uc3QgdmFsID0gaW5zdGFuY2VbbmFtZV07XG4gICAgaWYgKCh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpKSB7XG4gICAgICBpZiAoYWxsb3dVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBtdXN0IGJlIHR5cGUgQXJyYXlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZVtuYW1lXSkpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfScgbXVzdCBiZSB0eXBlIEFycmF5YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd0VtcHR5ICYmIGluc3RhbmNlW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBjYW5ub3QgYmUgZW1wdHlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgIH1cblxuICAgIGluc3RhbmNlW25hbWVdLmZvckVhY2goKGVsZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghZW51bUluc3RhbmNlLnZhbHVlcy5pbmNsdWRlcyhlbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBtdXN0IGJlIGFuIGFycmF5IG9mICR7ZW51bU5hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUpO1xuICAgICAgfVxuICAgICAgaWYgKCFhbGxvd0R1cGxpY2F0ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2VbbmFtZV0uaW5kZXhPZihlbGUsIGluZGV4ICsgMSkgPj0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlRGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBjYW5ub3QgaGF2ZSBkdXBsaWNhdGUgZWxlbWVudCB2YWx1ZWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHZhbEFycmF5T2ZTdHJpbmcodHlwZURlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgY29uc3QgdmFsID0gaW5zdGFuY2VbbmFtZV07XG4gICAgaWYgKENoZWNrLnNvbWV0aGluZyh2YWwpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYCR7dHlwZURlc2N9IHZhbGlkYXRpb246IFByb3BlcnR5ICcke25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBtdXN0IGJlIHR5cGUgQXJyYXlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFKTtcbiAgICAgIH1cbiAgICAgIHZhbC5mb3JFYWNoKChlbGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGAke3R5cGVEZXNjfSB2YWxpZGF0aW9uOiBQcm9wZXJ0eSAnJHtuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9JyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB2YWxUb3BpY1N0cmluZyh0eXBlZGVzYywgaW5zdGFuY2UsIG5hbWUpIHtcbiAgICAvLyBQYXJkb24gdGhpcyBsYXRlIGltcG9ydC4gSSBuZWVkIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICBjb25zdCB7IERlc3RpbmF0aW9uVXRpbCwgRGVzdGluYXRpb25UeXBlIH0gPSByZXF1aXJlKCdzb2xjbGllbnQtZGVzdGluYXRpb24nKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5BUElQcm9wZXJ0aWVzVmFsaWRhdG9ycy52YWxTdHJpbmcodHlwZWRlc2MsIGluc3RhbmNlLCBuYW1lKTtcbiAgICBjb25zdCB2YWwgPSBpbnN0YW5jZVtuYW1lXTtcbiAgICBjb25zdCByZXN1bHQgPSBEZXN0aW5hdGlvblV0aWwudmFsaWRhdGVBbmRFbmNvZGUoRGVzdGluYXRpb25UeXBlLlRPUElDLCB2YWwpO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgJHt0eXBlZGVzY30gdmFsaWRhdGlvbjogUHJvcGVydHkgJyR7bmFtZX0nIG11c3QgYmUgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGEgdmFsaWQgdG9waWMgc3RyaW5nOiAke3Jlc3VsdC5lcnJvcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UpO1xuICAgIH1cbiAgfSxcblxuICB2YWxUb3BpY1N0cmluZ09yRW1wdHkodHlwZWRlc2MsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgY29uc3QgdmFsID0gaW5zdGFuY2VbbmFtZV07XG4gICAgaWYgKHZhbCAmJiB2YWwubGVuZ3RoKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cy5BUElQcm9wZXJ0aWVzVmFsaWRhdG9ycy52YWxUb3BpY1N0cmluZyh0eXBlZGVzYywgaW5zdGFuY2UsIG5hbWUpO1xuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzLkFQSVByb3BlcnRpZXNWYWxpZGF0b3JzID0gQVBJUHJvcGVydGllc1ZhbGlkYXRvcnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC11dGlsL2xpYi9hcGktcHJvcGVydGllcy12YWxpZGF0b3JzLmpzIiwiY29uc3QgY2xvbmVPYmogPSByZXF1aXJlKCdjbG9uZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgQ0xPTkVfQ0lSQ1VMQVIgPSBmYWxzZTsgLy8gSWYgdHJ1ZSwgaGFuZGxlcyBjaXJjdWxhciByZWZlcmVuY2VzIHNhZmVseS5cbmNvbnN0IENMT05FX0RFUFRIID0gMTsgLy8gRG9uJ3QgZGVlcC1jbG9uZSBuZXN0ZWQgdmFsdWVzLlxuXG4vKipcbiAqIEBtZW1iZXJvZiBzb2xhY2VcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEFQSVByb3BlcnRpZXMge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgQVBJIHByb3BlcnRpZXMgc3RydWN0dXJlcy4gUHJvdmlkZXMgdGhlIGNsb25lKCkgbWV0aG9kIHRvXG4gICAqIG1ha2UgYWxsIHByb3BlcnRpZXMgY2xvbmVhYmxlLlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFQSVByb3BlcnRpZXMuIEFzc2lnbnMgcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlXG4gICAqIG9iamVjdHMgaW4gaW5jcmVhc2luZyBwcmlvcml0eSBvcmRlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogc3VwZXIoeyBmb286ICdkZWZhdWx0Rm9vJywgYmFyOiA0MiB9LCB7IGZvbzogJ3F1dXgnIH0pOyAvLyAuZm9vID09IHF1dXgsIC5iYXIgPSA0MlxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gb3B0aW9ucyBUaGUgcHJvcGVydGllcyBzb3VyY2VzIHRvIGFzc2lnbi5cbiAgICpcbiAgICogQHNpbmNlIDEwLjAuMFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLm9wdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIC4uLm9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbiBiZSBvdmVycmlkZGVuLiAgRm9yIGluc3RhbmNlIHNlc3Npb25Qcm9wZXJ0aWVzXG4gICAqIG92ZXJyaWRlcyB0aGlzIHRvIHN1cHByZXNzIHByaW50aW5nIHRoZSBwYXNzd29yZC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBjbG9uZU9iaih0aGlzLCBDTE9ORV9DSVJDVUxBUiwgQ0xPTkVfREVQVEgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkFQSVByb3BlcnRpZXMgPSBBUElQcm9wZXJ0aWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdXRpbC9saWIvYXBpLXByb3BlcnRpZXMuanMiLCJmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGFjYywgZWwpID0+IGFjYy5jb25jYXQoQXJyYXkuaXNBcnJheShlbCkgPyBmbGF0dGVuKGVsKSA6IGVsKSwgW10pO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgZWwpIHtcbiAgcmV0dXJuIGFycmF5LnNvbWUodiA9PiB2ID09PSBlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLkFycmF5VXRpbHMgPSB7XG4gIGZsYXR0ZW4sXG4gIGluY2x1ZGVzLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXV0aWwvbGliL2FycmF5LXV0aWxzLmpzIiwiXG5jb25zdCBXSU5ET1dTX1ZFUlNJT05fTUFQID0ge1xuICAnNi40JzogICcxMC4wJyxcbiAgJzYuMyc6ICAnOC4xJyxcbiAgJzYuMic6ICAnOCcsXG4gICc2LjEnOiAgJzcnLFxuICAnNi4wJzogICdWaXN0YScsXG4gICc1LjInOiAgJ1NlcnZlciAyMDAzJyxcbiAgJzUuMSc6ICAnWFAnLFxuICAnNS4wMSc6ICcyMDAwIFNQMScsXG4gICc1LjAnOiAgJzIwMDAnLFxuICAnNC4wJzogICc0LjAnLFxufTtcblxuY29uc3QgTk9ERV9PU19UWVBFUyA9IHtcbiAgRGFyd2luOiAgICAgJ09TWCcsXG4gIFdpbmRvd3NfTlQ6ICdXaW5kb3dzJyxcbn07XG5cbmNvbnN0IGNvbnRleHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcblxuY29uc3QgREVGQVVMVCA9IHtcbn07XG5cbmNvbnN0IE5PREVfUFJPQ0VTUyA9IHtcbiAgcHJvZHVjdDogICdzb2xjbGllbnRqcycsXG4gIHBsYXRmb3JtOiAnbm9kZScsXG4gIGFnZW50OiAgICAnbm9kZScsXG4gIHByb2Nlc3M6ICBjb250ZXh0LnByb2Nlc3MsXG59O1xuXG4vLyBXb3JzdCBjYXNlIGZhbGxiYWNrc1xuY29uc3QgQlJPV1NFUl9QUk9DRVNTID0ge1xuICBwcm9kdWN0OiAgJ3NvbGNsaWVudGpzJyxcbiAgcGxhdGZvcm06ICd1bmtub3duJyxcbiAgYWdlbnQ6ICAgICdHZWNrbycsXG59O1xuXG5mdW5jdGlvbiBnZXRCcm93c2VyQWdlbnRJbmZvKCkge1xuICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgY29uc3QgbmF2T2JqID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IgOiBudWxsO1xuICBpZiAoIW5hdk9iaikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFnZW50U3RyID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAvLyBFeGVjdXRlIHRoZXNlIHJlZ2V4IGNoZWNrcyBhZ2FpbnN0IHRoZSB1c2VyIGFnZW50IHN0cmluZyBpbiB0aGlzIG9yZGVyLlxuICAvLyBUaGUgZWFybGllciBicm93c2VycyBoYXZlIGEgbG90IG9mIGltcGVyc29uYXRpb24gc3Vic3RyaW5ncyBpbiB0aGVpciB1c2VyXG4gIC8vIGFnZW50IGxpc3Qgc28gd2UgcG9zaXRpdmVseSB0ZXN0IGZvciB0aGVtIGJlZm9yZSBjb25zaWRlcmluZyB0aGUgYnJvd3NlcnNcbiAgLy8gdGhhdCBhcmUgZnJlcXVlbnRseSBpbXBlcnNvbmF0ZWQuXG4gIGNvbnN0IGJyb3dzZXJzID0gW1xuICAgIFsnZWRnZScsIC9FZGdlXFwvKFswLTkuX10rKS9dLFxuICAgIFsnY2hyb21lJywgLyg/IUNocm9tLipPUFIpQ2hyb20oPzplfGl1bSlcXC8oWzAtOS5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2ZpcmVmb3gnLCAvRmlyZWZveFxcLyhbMC05Ll0rKSg/Olxcc3wkKS9dLFxuICAgIFsnb3BlcmEnLCAvT3BlcmFcXC8oWzAtOS5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ29wZXJhJywgL09QUlxcLyhbMC05Ll0rKSg6P1xcc3wkKSQvXSxcbiAgICBbJ2llJywgL1RyaWRlbnRcXC83XFwuMC4qcnY6KFswLTkuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05Ll0rKTsuKlRyaWRlbnRcXC9bNC04XS4wL10sIC8vIEVkaXQ6IElFMTEgaW4gSUU5IGVtdSBtb2RlIHVzZXMgVHJpZGVudCA4XG4gICAgWydpZScsIC9NU0lFXFxzKDdcXC4wKS9dLFxuICAgIFsnYmIxMCcsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTkuXSspL10sXG4gICAgWydhbmRyb2lkJywgL0FuZHJvaWRcXHMoWzAtOS5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTkuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLFxuICAgIFsnc2FmYXJpJywgL1ZlcnNpb25cXC8oWzAtOS5fXSspLipTYWZhcmkvXSxcbiAgXTtcblxuICBjb25zdCBhZ2VudEluZm8gPSB7XG4gICAgYnJvd3NlcjogIHsgbmFtZTogJ3Vua25vd24nLCB2ZXJzaW9uOiAnMC4wLjAnIH0sXG4gICAgcGxhdGZvcm06IHsgb3M6ICd1bmtub3duJywgYXJjaDogJ3Vua25vd24nLCB2ZXJzaW9uOiAndW5rbm93bicgfSxcbiAgfTtcblxuICBjb25zdCBhZ2VudEhhcyA9ICguLi5zdHJzKSA9PiBzdHJzLnNvbWUoc3RyID0+IGFnZW50U3RyLmluZGV4T2Yoc3RyKSA+PSAwKTtcbiAgY29uc3QgZmlyc3RWYWx1ZSA9ICguLi52YWxzKSA9PiB2YWxzLmZpbHRlcihCb29sZWFuKS5zaGlmdCgpO1xuXG4gIE9iamVjdC5hc3NpZ24oXG4gICAgYWdlbnRJbmZvLCAvLyBzdGFydCB3aXRoIGZhbGxiYWNrcyBhYm92ZVxuICAgIC8vIDEuIFJ1biB0aGUgY2FsbGJhY2sgYmVsb3cgZm9yIGVhY2ggYnJvd3NlciBuYW1lL3JlZ2V4LXJ1bGUgcGFpci5cbiAgICAvLyAyLiBEZWNvbXBvc2UgdGhlIHBhaXIgaW50byB2YXJpYWJsZXMgY2FsbGVkIGBrZXlgIGFuZCBgcnVsZWAuXG4gICAgYnJvd3NlcnMubWFwKChba2V5LCBydWxlXSkgPT4ge1xuICAgICAgLy8gMy4gU2tpcCBpZiB0aGUgcnVsZSBkb2Vzbid0IG1hdGNoIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAgICAgIGlmICghcnVsZS50ZXN0KGFnZW50U3RyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gNC4gR2V0IHRoZSBtYXRjaGVzIGZvciB0aGUgcnVsZS5cbiAgICAgIGNvbnN0IG1hdGNoID0gcnVsZS5leGVjKGFnZW50U3RyKTtcbiAgICAgIC8vIDUuIEV4dHJhY3QgdGhlIHZlcnNpb24gZnJvbSBtYXRjaCBncm91cCAxLlxuICAgICAgY29uc3QgdmVyc2lvblN0cnMgPSBtYXRjaCAmJiBtYXRjaFsxXS5zcGxpdCgvWy5fXS8pLnNsaWNlKDAsIDMpO1xuICAgICAgLy8gNi4gQ29udmVydCB0aGUgdmVyc2lvbiBzdHJpbmdzIHRvIG51bWJlcnMuXG4gICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvblN0cnMubWFwKHN0ciA9PiBwYXJzZUludChzdHIsIDEwKSk7XG4gICAgICAvLyA3LiBFbnN1cmUgb3VyIHZlcnNpb24gdHVwbGUgaXMgbGVuZ3RoIDMgYnkgYXBwZW5kaW5nIDAgZWxlbWVudHMuXG4gICAgICB3aGlsZSAodmVyc2lvbi5sZW5ndGggPCAzKSB2ZXJzaW9uLnB1c2goMCk7XG4gICAgICAvLyA4LiBSZXR1cm4gYW4gYWdlbnRJbmZvIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtIGFzIGFib3ZlLCBjb25zdW1pbmcgdGhlIHZlcnNpb24gYXJyYXkuXG4gICAgICByZXR1cm4geyBicm93c2VyOiB7IG5hbWU6IGtleSwgdmVyc2lvbjogdmVyc2lvbi5qb2luKCcuJykgfSB9O1xuICAgIH0pLmZpbHRlcihCb29sZWFuKS5zaGlmdCgpKTsgLy8gOS4gRmlsdGVyIG91dCBhbnl0aGluZyB0aGF0IHJldHVybmVkIGBmYWxzZWAgKCMzKS4uLlxuICAgIC8vIDEwLiAuLi5hbmQgcmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50LlxuXG4gIC8vIE5vdyB0cnkgdG8gZXh0cmFjdCBwbGF0Zm9ybSBpbmZvXG4gIGNvbnN0IG9zID0gZmlyc3RWYWx1ZShcbiAgICBhZ2VudEhhcygnV2luZG93cyBQaG9uZScpICYmICdXaW5kb3dzUGhvbmUnLFxuICAgIGFnZW50SGFzKCdXaW5kb3dzJykgJiYgJ1dpbmRvd3MnLFxuICAgIGFnZW50SGFzKCdMaW51eCcpICYmICdMaW51eCcsXG4gICAgYWdlbnRIYXMoJ2xpa2UgTWFjIE9TIFgnKSAmJiAnaU9TJyxcbiAgICBhZ2VudEhhcygnT1MgWCcpICYmICdPU1gnLFxuICAgIGFnZW50SGFzKCdBbmRyb2lkJywgJ0FkcicpICYmICdBbmRyb2lkJyxcbiAgICBhZ2VudEhhcygnQkIxMCcsICdSSU0gVGFibGV0IE9TJywgJ0JsYWNrQmVycnknKSAmJiAnQmxhY2tCZXJyeSdcbiAgKTtcbiAgY29uc3QgdmVyc2lvblRlc3RzID0ge1xuICAgICdXaW5kb3dzJzogKCkgPT4gZmlyc3RWYWx1ZShcbiAgICAgIGFnZW50SGFzKCdXaW4xNicpICYmICczLjEuMScsXG4gICAgICBhZ2VudEhhcygnV2luZG93cyBDRScpICYmICdDRScsXG4gICAgICBhZ2VudEhhcygnV2luZG93cyA5NScpICYmICc0LjAwLjk1MCcsXG4gICAgICBhZ2VudEhhcygnV2luZG93cyA5ODsgV2luIDl4IDQuOTAnKSAmJiAnNC45MCcsXG4gICAgICBhZ2VudEhhcygnV2luZG93cyA5OCcpICYmICc0LjEwJyxcbiAgICAgICgoKSA9PiB7XG4gICAgICAgIC8vIExvb2sgaW4gdGhlIGZpcnN0IHNldCBvZiBwYXJlbnRoZXNlcyBmb3IgYSB2ZXJzaW9uIHN0cmluZyBrZXkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBmYWlsIHdoZW4gV2luZG93cyAxNiBjb21lcyBvdXRcbiAgICAgICAgY29uc3QgcGFyZW5QYXJ0cyA9IGFnZW50U3RyLm1hdGNoKC9cXCguKz9cXCkvKTtcbiAgICAgICAgY29uc3QgdmVyc2lvblBhcnQgPSBwYXJlblBhcnRzWzBdO1xuICAgICAgICBpZiAoIXZlcnNpb25QYXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHN0ciA9PiB2ZXJzaW9uUGFydC5pbmRleE9mKHN0cikgPj0gMDtcbiAgICAgICAgcmV0dXJuIGZpcnN0VmFsdWUoLi4uT2JqZWN0LmtleXMoV0lORE9XU19WRVJTSU9OX01BUCkubWFwKGsgPT5cbiAgICAgICAgICAgIHZlcnNpb25NYXRjaChrKSAmJiBXSU5ET1dTX1ZFUlNJT05fTUFQW2tdKSk7XG4gICAgICB9KSgpXG4gICAgKSxcbiAgICAnT1NYJzogICAgICAgICgpID0+IGFnZW50U3RyLm1hdGNoKC9PUyBYICgoXFxkK1suX10pK1xcZCspXFxiLylbMV0sXG4gICAgJ0xpbnV4JzogICAgICAoKSA9PiAnJyxcbiAgICAnaU9TJzogICAgICAgICgpID0+IGFnZW50U3RyLm1hdGNoKC9PUyAoKFxcZCtbLl9dKStcXGQrKSBsaWtlIE1hYyBPUyBYLylbMV0sXG4gICAgJ0FuZHJvaWQnOiAgICAoKSA9PiBhZ2VudFN0ci5tYXRjaCgvKD86QW5kcm9pZHxBZHIpICgoXFxkK1suX10pK1xcZF8pLylbMV0sXG4gICAgJ0JsYWNrQmVycnknOiAoKSA9PiBhZ2VudFN0ci5tYXRjaCgvKD86VmVyc2lvblxcL3xSSU0gVGFibGV0IE9TICkoKFxcZCtcXC4pK1xcZCspLylbMV0sXG4gIH07XG4gIGNvbnN0IHZlcnNpb25UZXN0ID0gdmVyc2lvblRlc3RzW29zXTtcbiAgYWdlbnRJbmZvLnBsYXRmb3JtLm9zID0gb3MgfHwgJ1Vua25vd24nO1xuICBhZ2VudEluZm8ucGxhdGZvcm0udmVyc2lvbiA9ICh2ZXJzaW9uVGVzdCAmJiB2ZXJzaW9uVGVzdCgpIHx8ICcwLjAuMCcpLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgcmV0dXJuIGFnZW50SW5mbztcbn1cbi8qIGVzbGludC1lbnYgc2hhcmVkLWJyb3dzZXItbm9kZSAqL1xuXG50cnkge1xuICBpZiAoY29udGV4dC5uYXZpZ2F0b3IpIHtcbiAgICAvLyBUaGVzZSBhcmUgaGlzdG9yaWNhbCBkZWZhdWx0c1xuICAgIGNvbnN0IHNhZmVFbmNvZGUgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1teYS16QS1aMC05Xy8uXS9nLCAnLScpO1xuICAgIE9iamVjdC5hc3NpZ24oQlJPV1NFUl9QUk9DRVNTLCB7XG4gICAgICBwbGF0Zm9ybTogICAgY29udGV4dC5uYXZpZ2F0b3IucGxhdGZvcm0sXG4gICAgICBhZ2VudDogICAgICAgY29udGV4dC5uYXZpZ2F0b3IucHJvZHVjdCxcbiAgICAgIGRlc2NyaXB0aW9uOiBzYWZlRW5jb2RlKGNvbnRleHQubmF2aWdhdG9yLnVzZXJBZ2VudCksXG4gICAgICBuYXZpZ2F0b3I6ICAgY29udGV4dC5uYXZpZ2F0b3IsXG4gICAgfSk7XG4gICAgY29uc3QgYnJvd3NlckFnZW50SW5mbyA9IGdldEJyb3dzZXJBZ2VudEluZm8oKTtcbiAgICBpZiAoYnJvd3NlckFnZW50SW5mbykge1xuICAgICAgQlJPV1NFUl9QUk9DRVNTLmFnZW50ID0gc2FmZUVuY29kZShgJHticm93c2VyQWdlbnRJbmZvLmJyb3dzZXIubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0tJHticm93c2VyQWdlbnRJbmZvLmJyb3dzZXIudmVyc2lvbn1gKTtcbiAgICAgIEJST1dTRVJfUFJPQ0VTUy5wbGF0Zm9ybSA9IGAke0JST1dTRVJfUFJPQ0VTUy5hZ2VudH0tJHtzYWZlRW5jb2RlKFxuICAgICAgICBgJHticm93c2VyQWdlbnRJbmZvLnBsYXRmb3JtLm9zfS0ke2Jyb3dzZXJBZ2VudEluZm8ucGxhdGZvcm0udmVyc2lvbn1gKX1gO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGV4dC5wcm9jZXNzKSB7XG4gICAgY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG4gICAgY29uc3Qgb3N0eXBlID0gb3MudHlwZSgpO1xuICAgIGNvbnN0IG9zbmFtZSA9IE5PREVfT1NfVFlQRVNbb3N0eXBlXSB8fCBvc3R5cGUgfHwgJ3Vua25vd24nO1xuICAgIGNvbnN0IG5vZGVWZXJzaW9uU3RyID0gYG5vZGUtJHtwcm9jZXNzLnZlcnNpb24uc3Vic3RyKDEpfWA7XG4gICAgT2JqZWN0LmFzc2lnbihOT0RFX1BST0NFU1MsIHtcbiAgICAgIHBsYXRmb3JtOiAgICBgJHtub2RlVmVyc2lvblN0cn0tJHtvc25hbWV9LSR7b3MucmVsZWFzZSgpfS0ke29zLmFyY2goKX1gLFxuICAgICAgYWdlbnQ6ICAgICAgIG5vZGVWZXJzaW9uU3RyLFxuICAgICAgZGVzY3JpcHRpb246IG5vZGVWZXJzaW9uU3RyLFxuICAgIH0pO1xuICB9XG59IGNhdGNoIChleCkge1xuICAvLyBGYWxsIGJhY2sgdG8gZGVmYXVsdHNcbn1cblxuY29uc3QgUHJvY2VzcyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCVUlMRF9FTlYuVEFSR0VUX0JST1dTRVIgPyBCUk9XU0VSX1BST0NFU1MgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJVSUxEX0VOVi5UQVJHRVRfTk9ERSA/IE5PREVfUFJPQ0VTUyA6IHt9KTtcblxubW9kdWxlLmV4cG9ydHMuUHJvY2VzcyA9IFByb2Nlc3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC11dGlsL2xpYi9wcm9jZXNzLmpzIiwiY29uc3QgeyBTdHJpbmdCdWZmZXIgfSA9IHJlcXVpcmUoJy4vc3RyaW5nLWJ1ZmZlcicpO1xuXG5jb25zdCBQQURfTEVGVCA9IDA7XG5jb25zdCBQQURfUklHSFQgPSAxO1xuXG5jb25zdCBMVVRfUFJJTlRBQkxFID0gKCgpID0+IHtcbiAgY29uc3QgdG1wID0gW107XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgMjU2OyArK2MpIHtcbiAgICB0bXBbY10gPSAoYyA8IDMzIHx8IGMgPiAxMjYpID8gJy4nIDogU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICByZXR1cm4gdG1wO1xufSkoKTtcblxuZnVuY3Rpb24gcGFkTGVmdFJpZ2h0KHN0ciwgbWluTGVuLCBwYWRTaWRlLCBwYWRDaGFyID0gJyAnKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHN0ci5sZW5ndGggPj0gbWluTGVuKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGNvbnN0IGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAobWluTGVuIC0gc3RyLmxlbmd0aCk7IGkrKykge1xuICAgIGJ1Zi5hcHBlbmQocGFkQ2hhci5jaGFyQXQoMCkpO1xuICB9XG4gIHN3aXRjaCAocGFkU2lkZSkge1xuICAgIGNhc2UgUEFEX0xFRlQ6XG4gICAgICByZXR1cm4gYCR7YnVmfSR7c3RyfWA7XG4gICAgY2FzZSBQQURfUklHSFQ6XG4gICAgICByZXR1cm4gYCR7c3RyfSR7YnVmfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhc3RTcGFjZXMobGVuZ3RoLCBsaW5lKSB7XG4gIGlmICghbGluZS5sZW5ndGgpIHJldHVybiBsZW5ndGg7XG4gIGNvbnN0IHNwYWNlcyA9IGxpbmUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICByZXR1cm4gc3BhY2VzIDwgbGVuZ3RoID8gc3BhY2VzIDogbGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplV29yZChzdHIpIHtcbiAgcmV0dXJuIGAke3N0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3N0ci5zdWJzdHIoMSl9YDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge1N0cmluZ1V0aWxzfVxuICovXG5jb25zdCBTdHJpbmdVdGlscyA9IHtcblxuICBjYXBpdGFsaXplKHN0cikge1xuICAgIGlmICghKHN0ciAmJiBzdHIubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGNhcGl0YWxpemVXb3JkKS5qb2luKCcgJyk7XG4gIH0sXG5cbiAgaXNFbXB0eShzdHIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RyID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHN0ciA9PT0gbnVsbCB8fFxuICAgICAgc3RyLmxlbmd0aCA9PT0gMFxuICAgICk7XG4gIH0sXG5cbiAgbm90RW1wdHkoc3RyKSB7XG4gICAgcmV0dXJuICEodGhpcy5pc0VtcHR5KHN0cikpO1xuICB9LFxuXG4gIHRvU2FmZUNoYXJzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW15hLXpBLVowLTlfLy5dL2csICcnKTtcbiAgfSxcblxuICBwYWRMZWZ0KHN0ciwgbWluTGVuLCBwYWRDaGFyKSB7XG4gICAgcmV0dXJuIHBhZExlZnRSaWdodChzdHIsIG1pbkxlbiwgUEFEX0xFRlQsIHBhZENoYXIpO1xuICB9LFxuXG4gIHBhZFJpZ2h0KHN0ciwgbWluTGVuLCBwYWRDaGFyKSB7XG4gICAgcmV0dXJuIHBhZExlZnRSaWdodChzdHIsIG1pbkxlbiwgUEFEX1JJR0hULCBwYWRDaGFyKTtcbiAgfSxcblxuICBudWxsVGVybWluYXRlOiBmdW5jdGlvbiBudWxsVGVybWluYXRlKHN0cikge1xuICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIHN0ciBpbiBudWxsVGVybWluYXRlJyk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RDaGFyID0gc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChsYXN0Q2hhciA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCk7XG4gIH0sXG5cbiAgc3RyaXBOdWxsVGVybWluYXRlOiBmdW5jdGlvbiBzdHJpcE51bGxUZXJtaW5hdGUoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdudWxsIHN0ciBpbiBzdHJpcE51bGxUZXJtaW5hdGUnKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENoYXIgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGxhc3RDaGFyID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgaGV4ZHVtcChzKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICAgIGNvbnN0IHByaW50YWJsZSA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgICBjb25zdCBzcGFjZXIgPSBwb3MgPT4gKHBvcyA9PT0gOCB8fCBwb3MgPT09IDE2ID8gJyAgJyA6ICcgJyk7XG4gICAgbGV0IGxpbmVsZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBzTGVuZ3RoID0gcy5sZW5ndGg7IGkgPCBzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNjb2RlID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgb3V0cHV0LmFwcGVuZCh0aGlzLnBhZExlZnQoY2NvZGUudG9TdHJpbmcoMTYpLCAyKSk7XG4gICAgICBwcmludGFibGUuYXBwZW5kKExVVF9QUklOVEFCTEVbY2NvZGVdIHx8ICcuJyk7XG4gICAgICBvdXRwdXQuYXBwZW5kKHNwYWNlcigrK2xpbmVsZW4pKTtcblxuICAgICAgaWYgKGkgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBpbnB1dCBmaW5pc2hlZDogY29tcGxldGUgdGhlIGxpbmVcbiAgICAgICAgd2hpbGUgKGxpbmVsZW4gPCAxNikge1xuICAgICAgICAgIG91dHB1dC5hcHBlbmQoYCAgJHtzcGFjZXIoKytsaW5lbGVuKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGluZWxlbiA9PT0gMTYpIHtcbiAgICAgICAgb3V0cHV0LmFwcGVuZChwcmludGFibGUuam9pbignJykpO1xuICAgICAgICBvdXRwdXQuYXBwZW5kKCdcXG4nKTtcbiAgICAgICAgbGluZWxlbiA9IDA7XG4gICAgICAgIHByaW50YWJsZS5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LnRvU3RyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSBoZXJlZG9jYC4uLi5gIHRvIGNyZWF0ZSBtdWx0aS1saW5lIGhlcmVkb2Mgc3RyaW5ncy4gTGVhZGluZyBibGFuayBsaW5lcyBhcmUgcmVtb3ZlZCwgYXMgYXJlXG4gICAqIGxlYWRpbmcgc3BhY2VzLCB1cCB0byB0aGUgbnVtYmVyIG9mIHNwYWNlcyBvbiB0aGUgbGVhc3QtaW5kZW50ZWQgbGluZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpdGVyYWxzIFRoZSBkb2N1bWVudCB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gc3Vic3RpdHV0aW9ucyBUaGUgc3Vic3RpdHV0aW9ucyB0byBtYWtlIGluIHRoZSBkb2N1bWVudFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgaW50ZXJwb2xhdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkb2N1bWVudFxuICAgKi9cbiAgaGVyZWRvYyhsaXRlcmFscywgLi4uc3Vic3RpdHV0aW9ucykge1xuICAgIGNvbnN0IHN1YnN0ID0gWy4uLnN1YnN0aXR1dGlvbnMsICcnXTtcbiAgICBjb25zdCBsaW5lcyA9IGxpdGVyYWxzLm1hcChrID0+IGsgKyBzdWJzdC5zaGlmdCgpKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBjb25zdCBzcGFjZXMgPSBsaW5lcy5sZW5ndGggPT09IDEgPyAwIDogbGluZXMucmVkdWNlKGxlYXN0U3BhY2VzLCBJbmZpbml0eSk7XG4gICAgd2hpbGUgKGxpbmVzWzBdID09PSAnJykge1xuICAgICAgbGluZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLm1hcChsaW5lID0+IGxpbmUuc3Vic3RyaW5nKHNwYWNlcykpLmpvaW4oJ1xcbicpO1xuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMuU3RyaW5nVXRpbHMgPSBTdHJpbmdVdGlscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXV0aWwvbGliL3N0cmluZy11dGlscy5qcyIsImNsYXNzIFRpbWluZ0J1Y2tldCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGludGVydmFsKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgdGhpcy5idWNrZXRzID0gW107XG4gIH1cblxuICBnZXQgYnVja2V0Q291bnQoKSB7XG4gICAgbGV0IGMgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5idWNrZXRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgYyArPSB0aGlzLmJ1Y2tldHNbaV0gfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBsb2codikge1xuICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgaXNOYU4odikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IE1hdGguZmxvb3IodiAvIHRoaXMuaW50ZXJ2YWwpICogdGhpcy5pbnRlcnZhbDtcbiAgICB0aGlzLmJ1Y2tldHNbbm9ybWFsaXplZF0gPSB0aGlzLmJ1Y2tldHNbbm9ybWFsaXplZF0gfHwgMDtcbiAgICB0aGlzLmJ1Y2tldHNbbm9ybWFsaXplZF0rKztcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IGNvbnQgPSBbXTtcbiAgICB0aGlzLmJ1Y2tldHMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29udC5wdXNoKGAke2l9OiAke3RoaXMuYnVja2V0c1tpXX1gKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYHske2NvbnQuam9pbignLCAnKX19YDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5UaW1pbmdCdWNrZXQgPSBUaW1pbmdCdWNrZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC11dGlsL2xpYi90aW1pbmctYnVja2V0LmpzIiwiLyogZXNsaW50LWRpc2FibGUgZ2xvYmFsLXJlcXVpcmUgKi9cbmxldCBwYXJzZVVSTDtcbmlmIChCVUlMRF9FTlYuVEFSR0VUX05PREUpIHtcbiAgLyogZXNsaW50LWVudiBub2RlICovXG4gIHBhcnNlVVJMID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG59IGVsc2Uge1xuICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgY29uc3Qgc2NvcGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXM7XG4gIHJlcXVpcmUoJy4vYnJvd3Nlci11cmwtcG9seWZpbGwnKShzY29wZSk7XG4gIHBhcnNlVVJMID0gZnVuY3Rpb24gbWFrZVVSTCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoLi4uYXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlVVJMID0gcGFyc2VVUkw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC11dGlsL2xpYi91cmwuanMiLCIvLyBUT0RPOiBjb25zaWRlciB1c2luZyBoaWdoLXByZWNpc2lvbiB0aW1lciBmcm9tIHBlcmZvcm1hbmNlXG4vLyAgICAgICBvciBjb25zaWRlciB1c2luZyBhIEpTIGxpYnJhcnksIHN1Y2ggYXMgdXVpZC1qc1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7IC8vIFB1YmxpYyBEb21haW4vTUlUXG4gIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIC8vIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICBkICs9IHBlcmZvcm1hbmNlLm5vdygpOyAvL3VzZSBoaWdoLXByZWNpc2lvbiB0aW1lciBpZiBhdmFpbGFibGVcbiAgLy8gfVxuXG5cbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgcmV0dXJuIChjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpKS50b1N0cmluZygxNik7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5VVUlEID0ge1xuICBnZW5lcmF0ZVVVSUQsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zb2xjbGllbnQtdXRpbC9saWIvdXVpZC5qcyIsImNvbnN0IFZFUlNJT04gPSBCVUlMRF9FTlYuVkVSU0lPTiB8fCAnMC4wLjAtc291cmNlJztcbi8vIFBhcnNlIHRoZSBkYXRlIGlmIHByb3ZpZGVkLiBXYXMgc2VlaW5nIE5hTiBmb3JtYXR0ZWQgZGF0ZXMgaW4gc291cmNlIG1vZGUsIHNvIGFkZCBmYWxsYmFja1xuY29uc3QgREFURSA9IEJVSUxEX0VOVi5EQVRFXG4gID8gbmV3IERhdGUoRGF0ZS5wYXJzZShCVUlMRF9FTlYuREFURSkpXG4gIDogbmV3IERhdGUoKTtcbmNvbnN0IE1PREUgPSBCVUlMRF9FTlYuTU9ERV9OQU1FO1xuXG4vLyBUaGVzZSBwcm9wZXJ0eSBuYW1lcyBhcmUgYWxsIGZvciBleHBvcnQsIHNvIG1ha2Ugc3VyZSB0aGV5J3JlIG5vdCBtYW5nbGVkXG5jb25zdCBUQVJHRVQgPSB7XG4gICduYW1lJzogICAgQlVJTERfRU5WLlRBUkdFVF9OQU1FLFxuICAnbm9kZSc6ICAgIEJVSUxEX0VOVi5UQVJHRVRfTk9ERSxcbiAgJ2Jyb3dzZXInOiBCVUlMRF9FTlYuVEFSR0VUX0JST1dTRVIsXG59O1xuXG5jb25zdCBGT1JNQVRURURfREFURSA9ICgoKSA9PiB7XG4gIGNvbnN0IHBhZCA9IG4gPT4gKG4gPCAxMCA/IGAwJHtufWAgOiBuKTtcbiAgY29uc3QgZCA9IERBVEU7XG4gIGNvbnN0IFlZWVkgPSBkLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IE1NID0gcGFkKGQuZ2V0TW9udGgoKSArIDEpO1xuICBjb25zdCBERCA9IHBhZChkLmdldERhdGUoKSk7XG4gIGNvbnN0IGhoID0gcGFkKGQuZ2V0SG91cnMoKSk7XG4gIGNvbnN0IG1tID0gcGFkKGQuZ2V0TWludXRlcygpKTtcbiAgcmV0dXJuIGAke1lZWVl9LyR7TU19LyR7RER9ICR7aGh9OiR7bW19YDtcbn0pKCk7XG5jb25zdCBTVU1NQVJZID0gWydTb2xjbGllbnRKUycsIEJVSUxEX0VOVi5WRVJTSU9OLCBNT0RFLCBGT1JNQVRURURfREFURV0uam9pbignLCAnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBBUEkgdmVyc2lvbi4gVXNlIHZlcnNpb24sIGRhdGUgYW5kIG1vZGUgcHJvcGVydGllcyBmb3IgYnVpbGQgZGV0YWlscy5cbiAqIFVzZSB0aGUgc3VtbWFyeSBwcm9wZXJ0eSBvciB0aGUgLnRvU3RyaW5nKCkgbWV0aG9kIHRvIHJldHVybiBhIHN1bW1hcnkuXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIHNvbGFjZVxuICovXG5jb25zdCBWZXJzaW9uID0ge1xuICAvKipcbiAgICogVGhlIEFQSSB2ZXJzaW9uLCBhcyBhbiBpbmZvcm1hdGlvbmFsIHN0cmluZy4gVGhlIGZvcm1hdCBvZiB0aGlzIHN0cmluZyBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gICd2ZXJzaW9uJzogICAgICAgVkVSU0lPTixcbiAgLyoqXG4gICAqIFRoZSBBUEkgYnVpbGQgZGF0ZS5cbiAgICogQHR5cGUge0RhdGV9XG4gICAqL1xuICAnZGF0ZSc6ICAgICAgICAgIERBVEUsXG4gIC8qKlxuICAgKiBUaGUgQVBJIGJ1aWxkIGRhdGUsIGFzIGEgZm9ybWF0dGVkIHN0cmluZy5cbiAgICogVGhlIGZvcm1hdCBvZiB0aGlzIGRhdGUgaXM6XG4gICAqIGBZWVlZLU1NLUREIGhoOm1tYFxuICAgKiB3aGVyZVxuICAgKiAgKiBgWVlZWWAgaXMgdGhlIDQtZGlnaXQgeWVhcixcbiAgICogICogYE1NYCBpcyB0aGUgMi1kaWdpdCBtb250aCAgICgwMS0xMiksXG4gICAqICAqIGBERGAgaXMgdGhlIDItZGlnaXQgZGF5ICAgICAoMDEtMzEpLFxuICAgKiAgKiBgaGhgIGlzIHRoZSAyLWRpZ2l0IGhvdXIgICAgKDAwLTIzKSxcbiAgICogICogYG1tYCBpcyB0aGUgMi1kaWdpdCBtaW51dGUgICgwMC01OSlcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gICdmb3JtYXR0ZWREYXRlJzogRk9STUFUVEVEX0RBVEUsXG4gIC8qKlxuICAgKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgYnVpbGQgdGFyZ2V0LiBUaGlzIG9iamVjdCBpcyBpbmZvcm1hdGlvbmFsOyBpdHMgdHlwZSwgc3RydWN0dXJlIGFuZFxuICAgKiBjb250ZW50IGFyZSBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICd0YXJnZXQnOiAgICAgICAgVEFSR0VULFxuICAvKipcbiAgICogVGhlIGJ1aWxkIG1vZGUuIFRoaXMgbWF5IGJlIG9uZSBvZiAnZGVidWcnIG9yICdyZWxlYXNlJy4gT3RoZXIgYnVpbGQgbW9kZXMgbWF5IGJlIGFkZGVkXG4gICAqIGluIHRoZSBmdXR1cmUuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICAnbW9kZSc6ICAgICAgICAgIE1PREUsXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHRoaXMgaXMgYW4gdW5vcHRpbWl6ZWQgZGVidWcgYnVpbGQuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgJ2RlYnVnJzogICAgICAgICBCVUlMRF9FTlYuTU9ERV9ERUJVRyxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhpcyBpcyBhbiBvcHRpbWl6ZWQgcmVsZWFzZSBidWlsZC4gTm90ZSB0aGF0IHRoZXJlIG1heSBiZSBtdWx0aXBsZSByZWxlYXNlXG4gICAqIGJ1aWxkcyBpbiBhIGRpc3RyaWJ1dGlvbiwgd2l0aCB2YXJ5aW5nIGRlZ3JlZXMgb2Ygb3B0aW1pemF0aW9uLlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gICdyZWxlYXNlJzogICAgICAgQlVJTERfRU5WLk1PREVfUkVMRUFTRSxcbiAgLyoqXG4gICAqIEFuIGluZm9ybWF0aW9uYWwgc3RyaW5nIHN1bW1hcml6aW5nIHRoZSBBUEkgbmFtZSwgdmVyc2lvbiBhbmQgYnVpbGQgZGF0ZS5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gICdzdW1tYXJ5JzogICAgICAgU1VNTUFSWSxcblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gU1VNTUFSWTtcbiAgfSxcbn07XG5tb2R1bGUuZXhwb3J0cy5WZXJzaW9uID0gVmVyc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXV0aWwvbGliL3ZlcnNpb24uanMiLCJjb25zdCBFUFNJTE9OID0gMWU2O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gZmxhdHRlblxuICogQHJldHVybnMge0FycmF5fSBBIG1heGltYWxseSBmbGF0dGVuZWQgYXJyYXkuIFRoZSBvcmlnaW5hbCBhcnJheSBpcyBub3QgbW9kaWZpZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoQXJyYXkuaXNBcnJheShiKSA/IGZsYXR0ZW4oYikgOiBiKSwgW10pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IEJhc2VDaGVja3MgPSAoKCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG5vdGhpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgYW55dGhpbmcsIGkuZS4gbm90IHVuZGVmaW5lZCBvciBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgeyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIHVubGVzcyB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFueXRoaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gIUJhc2VDaGVja3Mubm90aGluZyh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgdW5kZWZpbmVkLiBVc2VzIHRoZSBjb25zZXJ2YXRpdmVcbiAgICAgKiB0eXBlb2YgY2hlY2sgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwYXJ0aWN1bGFybHkgaWxsLWJlaGF2ZWRcbiAgICAgKiBsaWJyYXJpZXMgdGhhdCByZWRlZmluZSA8Y29kZT51bmRlZmluZWQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogQHBhcmFtICAgeyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgZGVmaW5lZC4gVGhpcyBpcyB0cnVlIGZvciBhbnkgdmFsdWUgd2l0aFxuICAgICAqIGEgdHlwZSB0aGF0IGlzIG5vdCAndW5kZWZpbmVkJy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICFCYXNlQ2hlY2tzLnVuZGVmaW5lZCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIEJhc2VDaGVja3MuYW55dGhpbmcodmFsdWUpICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIGFuIG9iamVjdC4gSWYgYSB2YWx1ZSBpcyBhbiBhcnJheSwgaXQgaXMgbm90IGFuIG9iamVjdC5cbiAgICAgKiBJZiBhIHZhbHVlIGlzIG51bGwsIGl0IGlzIG5vdCBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCAoYW5kIG5vdCBhbiBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuICghQmFzZUNoZWNrcy5hcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IHR5cGUgVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0eXBlIGlzIGluIHZhbHVlJ3MgcHJvdG90eXBlIGNoYWluLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbnN0YW5jZU9mKHZhbCwgdHlwZSkge1xuICAgICAgcmV0dXJuIEJhc2VDaGVja3Mub2JqZWN0KHZhbCkgJiYgdmFsIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSdzIHR5cGVvZiBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gdHlwZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgc3RyaW5nIGZvciBjb21wYXJpc29uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdHlwZW9mKHZhbCkgPT0gdHlwZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0eXBlKHZhbCwgdHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IHR5cGU7IC8qIGR5bmFtaWMgKi8gLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhbnkgb2YgdGhlIGdpdmVuIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgeyp9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtICAge09iamVjdH0gdHlwZXMgVGhlIHR5cGVzIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYW55IGVsZW1lbnQgb2YgdHlwZXMgaXMgaW4gdmFsJ3MgcHJvdG90eXBlIGNoYWluLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbnN0YW5jZU9mQW55KHZhbCwgLi4udHlwZXMpIHtcbiAgICAgIHJldHVybiAoQmFzZUNoZWNrcy5hcnJheSh0eXBlcykgJiZcbiAgICAgICAgICAgICAgZmxhdHRlbih0eXBlcykuc29tZSh0eXBlID0+IEJhc2VDaGVja3MuaW5zdGFuY2VPZih2YWwsIHR5cGUpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqIEVtcHRpbmVzcyBpcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSBmb2xsb3dpbmcgY2hlY2tzOlxuICAgICAqXG4gICAgICogPG9sPlxuICAgICAqICA8bGk+SWYgYW4gb2JqZWN0IGlzIG5vdGhpbmcsIGl0IGlzIGVtcHR5LjwvbGk+XG4gICAgICogIDxsaT5JZiBpdCBpcyBhbiBvYmplY3QsIGFuZCBpdCBoYXMgbm8ga2V5cyBvZiBpdHMgb3duLCBpdCBpcyBlbXB0eS48L2xpPlxuICAgICAqICA8bGk+SWYgaXQgaGFzIGEgbGVuZ3RoIHByb3BlcnR5LCBpdCBpcyBlbXB0eSBpZiBsZW5ndGggPT09IDAuPC9saT5cbiAgICAgKiAgPGxpPklmIG5vbmUgb2YgdGhlIGFib3ZlIGFwcGx5LCB0aGUgb2JqZWN0IGlzIG5vdCBlbXB0eS48L2xpPlxuICAgICAqIDwvb2w+XG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZW1wdHkodmFsKSB7XG4gICAgICBpZiAoQmFzZUNoZWNrcy5ub3RoaW5nKHZhbCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKEJhc2VDaGVja3Mub2JqZWN0KHZhbCkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHVzZXItZGVmaW5lZCBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24odmFsKSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24sIGNvZXJjZWQgdG8gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0cnV0aHkodmFsLCBmbikge1xuICAgICAgcmV0dXJuICEhZm4odmFsKTtcbiAgICB9LFxuXG4gICAgcmFuZ2VHZSh2YWwsIHJhbmdlTWluSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gdmFsID49IHJhbmdlTWluSW5jbHVzaXZlO1xuICAgIH0sXG5cbiAgICByYW5nZUd0KHZhbCwgcmFuZ2VNaW4pIHtcbiAgICAgIHJldHVybiB2YWwgPiByYW5nZU1pbjtcbiAgICB9LFxuXG4gICAgcmFuZ2VMZSh2YWwsIHJhbmdlTWF4SW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gdmFsIDw9IHJhbmdlTWF4SW5jbHVzaXZlO1xuICAgIH0sXG5cbiAgICByYW5nZUx0KHZhbCwgcmFuZ2VNYXgpIHtcbiAgICAgIHJldHVybiB2YWwgPCByYW5nZU1heDtcbiAgICB9LFxuXG4gICAgcmFuZ2VDb21wYXJlKHZhbCwgb3BlcmF0b3IsIG9wZXJhbmQsIC4uLmFyZ3MpIHtcbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICByZXR1cm4gdmFsID09PSBvcGVyYW5kO1xuICAgICAgICBjYXNlICd+PSc6XG4gICAgICAgIGNhc2UgJz1+JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlcHNpbG9uID0gYXJnc1swXSB8fCBFUFNJTE9OO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbCAtIG9wZXJhbmQpIDwgZXBzaWxvbjtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIHJldHVybiB2YWwgPCBvcGVyYW5kO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgcmV0dXJuIHZhbCA8PSBvcGVyYW5kO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICByZXR1cm4gdmFsID4gb3BlcmFuZDtcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIHJldHVybiB2YWwgPj0gb3BlcmFuZDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgb3BlcmF0b3IgZm9yIHJhbmdlQ29tcGFyZTogJHtvcGVyYXRvcn1gKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgTmFOKHZhbCkge1xuICAgICAgcmV0dXJuIE51bWJlci5pc05hTih2YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB2YWwgaXMgaW5jbHVkZWQgaW4gdGhlIG9iamVjdC4gSWYgb2JqIGlzIGFuIGFycmF5LCB2YWwgaXMgaW5jbHVkZWQgaWZcbiAgICAgKiB2YWwgaXMgYW4gZWxlbWVudCBvZiB0aGUgYXJyYXkuIE90aGVyd2lzZSwgaWYgb2JqIGlzIGFuIG9iamVjdCwgdmFsIGlzIGluY2x1ZGVkIGlmXG4gICAgICogdmFsIGlzIG9uZSBvZiB0aGUga2V5cyBvZiBvYmouXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHBhcmFtICAgeyp9IG9iaiBUaGUgb2JqZWN0IHRvIHRlc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBpbmNsdWRlZCBpbiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgaW5jbHVkZWQodmFsLCBvYmopIHtcbiAgICAgIGlmIChCYXNlQ2hlY2tzLm5vdGhpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqLmluY2x1ZGVzKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5jbHVkZXModmFsKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gTm90IGV4YWN0bHkgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzLCB3aGljaCB1c2VzIFNhbWVWYWx1ZVplcm8gKCswID09IC0wKVxuICAgICAgICByZXR1cm4gb2JqLmluZGV4T2YodmFsKSA+PSAwO1xuICAgICAgfVxuICAgICAgaWYgKEJhc2VDaGVja3Mub2JqZWN0KG9iaikpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIHJldHVybiBCYXNlQ2hlY2tzLmluY2x1ZGVkKHZhbCwga2V5cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHZhbCBpcyBlcXVhbCB0byBleHBlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7YW55fSBleHBlY3RlZCBUaGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZXF1YWwodmFsLCBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBhcHBlYXJzIGFzIGFuIGF0dHJpYnV0ZSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvYmplY3QsXG4gICAgICogZS5nLiB3aGV0aGVyIGFuIGVudW1lcmF0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiB2YWx1ZS4gSWYgdGhlIGF0dHJpYnV0ZXMgb2JqZWN0IGlzIGFuIGFycmF5LFxuICAgICAqIHRoZSBhcnJheSBtZW1iZXJzaGlwIGNoZWNrIHtAbGluayAjaW5jbHVkZWR9IGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHdpdGggYXR0cmlidXRlcyB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGF0dHJzIGhhcyBhbnkgYXR0cmlidXRlIGVxdWFsIHRvIHZhbC5cbiAgICAgKi9cbiAgICBtZW1iZXIodmFsLCBvYmopIHtcbiAgICAgIHJldHVybiAoQmFzZUNoZWNrcy5hbnl0aGluZyhvYmopICYmXG4gICAgICAgICAgICAgIChCYXNlQ2hlY2tzLmFycmF5KG9iailcbiAgICAgICAgICAgICAgICA/IEJhc2VDaGVja3MuaW5jbHVkZWQodmFsLCBvYmopXG4gICAgICAgICAgICAgICAgOiBPYmplY3Qua2V5cyhvYmopLnNvbWUoayA9PiBvYmpba10gPT09IHZhbCkpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBib29sZWFuKHYpIHtcbiAgICAgIHJldHVybiBCYXNlQ2hlY2tzLnR5cGUodiwgJ2Jvb2xlYW4nKTtcbiAgICB9LFxuXG4gICAgbnVtYmVyKHYpIHtcbiAgICAgIHJldHVybiBCYXNlQ2hlY2tzLnR5cGUodiwgJ251bWJlcicpO1xuICAgIH0sXG5cbiAgICBzdHJpbmcodikge1xuICAgICAgcmV0dXJuIEJhc2VDaGVja3MudHlwZSh2LCAnc3RyaW5nJyk7XG4gICAgfSxcblxuICAgIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBCYXNlQ2hlY2tzLnR5cGUodiwgJ2Z1bmN0aW9uJyk7XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIG5vbmUuIFRoaXMgaXMgdGhlIHNhbWUgY2hlY2sgYXMgPGNvZGU+bm90aGluZzwvY29kZT5cbiAgICogQHNlZSB7QGxpbmsgbm90aGluZ31cbiAgICovXG4gIHJlc3VsdC5ub25lID0gcmVzdWx0Lm5vdGhpbmc7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFuIG9iamVjdCBpcyBzb21ldGhpbmcuIFRoaXMgaXMgdGhlIHNhbWUgY2hlY2sgYXMgPGNvZGU+YW55dGhpbmc8L2NvZGU+XG4gICAqL1xuICByZXN1bHQuc29tZXRoaW5nID0gcmVzdWx0LmFueXRoaW5nO1xuXG4gIC8vIEFkZCBjaGVjay1sb29zZW5pbmcgc3VmZml4ZXMsICh0IHwgbnVsbCksICh0IHwgdW5kZWZpbmVkKSBhbmQgKHQgfCBudWxsIHwgdW5kZWZpbmVkKS5cbiAgLy8gRG8gdGhlIHQgY2hlY2sgbGFzdCwganVzdCBpbiBjYXNlIGl0IGlzIG5vdCAobnVsbCB8IHVuZGVmaW5lZCkgc2FmZS5cbiAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAvKipcbiAgICAgKiAub3JOdWxsIGNoZWNrcy4gVGhlc2UgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIHNpbWlsYXJseSBuYW1lZCBjaGVjaywgYnV0IGFsc28gcGFzcyBpZiB0aGUgdmFsdWVcbiAgICAgKiBzdXBwbGllZCB3YXMgZXF1YWwgdG8gbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvIHRoZSBiYXNlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSB3YXMgbnVsbCBvciBwYXNzZWQgdGhlIHNpbWlsYXJseSBuYW1lZCB2YWxpZGF0b3IuXG4gICAgICovXG4gICAgcmVzdWx0W2tleV0ub3JOdWxsID0gZnVuY3Rpb24gb3JOdWxsKHZhbCwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCByZXN1bHRba2V5XSh2YWwsIC4uLmFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAub3JVbmRlZmluZWQgY2hlY2tzLiBUaGVzZSBhcmUgZXF1aXZhbGVudCB0byB0aGUgc2ltaWxhcmx5IG5hbWVkIGNoZWNrLCBidXQgYWxzbyBwYXNzIGlmIHRoZVxuICAgICAqIHZhbHVlIHN1cHBsaWVkIHdhcyBlcXVhbCB0byBudWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGZvcndhcmQgdG8gdGhlIGJhc2UgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBudWxsIG9yIHBhc3NlZCB0aGUgc2ltaWxhcmx5IG5hbWVkIHZhbGlkYXRvci5cbiAgICAgKi9cbiAgICByZXN1bHRba2V5XS5vclVuZGVmaW5lZCA9IGZ1bmN0aW9uIG9yVW5kZWZpbmVkKHZhbCwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkIHx8IHJlc3VsdFtrZXldKHZhbCwgLi4uYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIC5vck5vdGhpbmcgY2hlY2tzLiBUaGVzZSBhcmUgZXF1aXZhbGVudCB0byB0aGUgc2ltaWxhcmx5IG5hbWVkIGNoZWNrLCBidXQgYWxzbyBwYXNzIGlmIHRoZVxuICAgICAqIHZhbHVlIHN1cHBsaWVkIHdhcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBmb3J3YXJkIHRvIHRoZSBiYXNlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSB3YXMgbnVsbCBvciBwYXNzZWQgdGhlIHNpbWlsYXJseSBuYW1lZCB2YWxpZGF0b3IuXG4gICAgICovXG4gICAgcmVzdWx0W2tleV0ub3JOb3RoaW5nID0gZnVuY3Rpb24gb3JOb3RoaW5nKHZhbCwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHJlc3VsdC5ub3RoaW5nKHZhbCkgfHwgcmVzdWx0W2tleV0odmFsLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMuQmFzZUNoZWNrcyA9IEJhc2VDaGVja3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3NvbGNsaWVudC12YWxpZGF0ZS9saWIvYmFzZS1jaGVja3MuanMiLCJjb25zdCB7IENoZWNrIH0gPSByZXF1aXJlKCcuL2NoZWNrJyk7XG5jb25zdCB7IEVycm9yU3ViY29kZSwgT3BlcmF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJ3NvbGNsaWVudC1lcnJvcicpO1xuXG5jb25zdCBOT19PQkogPSB7fTsgLy8gYW5vbnltb3VzIG9iamVjdFxuXG5mdW5jdGlvbiBvYmplY3RWYWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChrID0+IG9iamVjdFtrXSk7XG59XG5cbmZ1bmN0aW9uIHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsIGV4cGVjdGVkID0gbnVsbCwgZ290ID0gTk9fT0JKKSB7XG4gIGNvbnN0IGV4cGVjdGVkU3RyID0gZXhwZWN0ZWQgPyBgOyBleHBlY3RlZDogJHtleHBlY3RlZH1gIDogJyc7XG4gIGNvbnN0IGdvdFN0ciA9IGdvdCAhPT0gTk9fT0JKID8gYDsgZ290OiAke2dvdH1gIDogJyc7XG4gIHN3aXRjaCAoc3ViY29kZSkge1xuICAgIGNhc2UgRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEU6XG4gICAgICByZXR1cm4gYFBhcmFtZXRlciB0eXBlIHdhcyBpbnZhbGlkJHtleHBlY3RlZFN0cn0ke2dvdFN0cn1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRXJyb3JTdWJjb2RlLm5hbWVPZihzdWJjb2RlKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vLCAnICcpICsgZXhwZWN0ZWRTdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFcnJvcihuYW1lLCBzdWJjb2RlLCBtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgUGFyYW1ldGVyICR7bmFtZX0gZmFpbGVkIHZhbGlkYXRpb25gLCBzdWJjb2RlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgY2hlY2ssIHZhbHVlLCAuLi52YWxpZGF0b3JBcmdzKSB7XG4gIGlmICghY2hlY2sodmFsdWUsIC4uLnZhbGlkYXRvckFyZ3MpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlRXJyb3IobmFtZSwgc3ViY29kZSwgbWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCB0eXBlbmFtZSA9IHggPT4geCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3IubmFtZSB8fCB0eXBlb2YgeDtcblxuLyoqXG4gKiBUaGUgQ2hlY2sgb2JqZWN0IGlzIGEgcG93ZXJmdWwgdmFsaWRhdGlvbiBBUEkgYnV0IGl0IGlzIHBhcnRpYWxseSBidWlsdCBhdCBydW50aW1lIGJ5IGNvbXBvc2luZ1xuICogZnVuY3Rpb25zLCBhbmQgaXQgcmVxdWlyZXMgc2lnbmlmaWNhbnQgYm9pbGVycGxhdGUgZm9yIHBhcmFtZXRlciB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSBQYXJhbWV0ZXIgQVBJIGV4cHJlc3NlcyBjb25jcmV0ZSB2YWxpZGF0aW9ucyB1c2luZyB0aGUgQ2hlY2sgQVBJLCByZXR1cm5pbmcgdmFsdWVzIG9uIHN1Y2Nlc3NcbiAqIGFuZCB0aHJvd2luZyB0aGUgYXBwcm9wcmlhdGUgU0RLIGV4Y2VwdGlvbiBvbiBmYWlsdXJlLiBJdCB3b3VsZCBiZSB0ZW1wdGluZyB0byB0cnkgdG9cbiAqIGF1dG9tYXRpY2FsbHkgYnVpbGQgYSBQYXJhbWV0ZXIgbWV0aG9kIGZvciBldmVyeSBDaGVjayBtZXRob2QsIGJ1dCB0aGlzIHdvdWxkIG1ha2UgUGFyYW1ldGVyXG4gKiBkaWZmaWN1bHQgdG8gdW5kZXJzdGFuZCBhbmQgdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFBhcmFtZXRlciA9IHtcblxuICBpc0FycmF5KG5hbWUsIHZhbHVlLFxuICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSwgJ2FycmF5JywgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKG5hbWUsIHN1YmNvZGUsIG1lc3NhZ2UsIENoZWNrLmlzQXJyYXksIHZhbHVlKTtcbiAgfSxcblxuICBpc0Jvb2xlYW4obmFtZSwgdmFsdWUsXG4gICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsXG4gICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSwgJ2Jvb2xlYW4nLCB2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2suYm9vbGVhbiwgdmFsdWUpO1xuICB9LFxuXG4gIGlzQm9vbGVhbk9yTm90aGluZyhuYW1lLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzdWJjb2RlU3VtbWFyeShzdWJjb2RlLCAnYm9vbGVhbiBvciBub3RoaW5nJywgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKG5hbWUsIHN1YmNvZGUsIG1lc3NhZ2UsIENoZWNrLmJvb2xlYW4ub3JOb3RoaW5nLCB2YWx1ZSk7XG4gIH0sXG5cbiAgaXNFbnVtTWVtYmVyKG5hbWUsIHZhbHVlLCBtZW1iZXJPZkVudW0sXG4gICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UsXG4gICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoXG4gICAgICAgICAgICAgICAgc3ViY29kZSxcbiAgICAgICAgICAgICAgICBgb25lIG9mIFske21lbWJlck9mRW51bS5uYW1lcy5qb2luKCcsICcpfV1gLFxuICAgICAgICAgICAgICAgIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5tZW1iZXIsIHZhbHVlLCBtZW1iZXJPZkVudW0pO1xuICB9LFxuXG4gIGlzRW51bU1lbWJlck9yTm90aGluZyhuYW1lLCB2YWx1ZSwgbWVtYmVyT2ZFbnVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KFxuICAgICAgICAgICAgICAgIHN1YmNvZGUsXG4gICAgICAgICAgICAgICAgYG9uZSBvZiBbJHttZW1iZXJPZkVudW0ubmFtZXMuam9pbignLCAnKX1dYCxcbiAgICAgICAgICAgICAgICB2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2subWVtYmVyLm9yTm90aGluZywgdmFsdWUsIG1lbWJlck9mRW51bSk7XG4gIH0sXG5cbiAgaXNGdW5jdGlvbihuYW1lLCB2YWx1ZSxcbiAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsXG4gICAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsICdmdW5jdGlvbicsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5mdW5jdGlvbiwgdmFsdWUpO1xuICB9LFxuXG4gIGlzRnVuY3Rpb25Pck5vdGhpbmcobmFtZSwgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzdWJjb2RlU3VtbWFyeShzdWJjb2RlLCAnZnVuY3Rpb24gb3Igbm90aGluZycsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5mdW5jdGlvbi5vck5vdGhpbmcsIHZhbHVlKTtcbiAgfSxcblxuICBpc0luc3RhbmNlT2YobmFtZSwgdmFsdWUsIGluc3RhbmNlT2YsXG4gICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsXG4gICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSwgaW5zdGFuY2VPZi5uYW1lLCB0eXBlbmFtZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKG5hbWUsIHN1YmNvZGUsIG1lc3NhZ2UsIENoZWNrLmluc3RhbmNlT2YsIHZhbHVlLCBpbnN0YW5jZU9mKTtcbiAgfSxcblxuICBpc0luc3RhbmNlT2ZPck5vdGhpbmcobmFtZSwgdmFsdWUsIGluc3RhbmNlT2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtpbnN0YW5jZU9mLm5hbWV9IG9yIG5vdGhpbmdgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2suaW5zdGFuY2VPZi5vck5vdGhpbmcsIHZhbHVlLCBpbnN0YW5jZU9mKTtcbiAgfSxcblxuICBpc0luc3RhbmNlT2ZPck51bGwobmFtZSwgdmFsdWUsIGluc3RhbmNlT2YsXG4gICAgICAgICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9JTlZBTElEX1RZUEUsXG4gICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtpbnN0YW5jZU9mLm5hbWV9IG9yIG51bGxgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2suaW5zdGFuY2VPZi5vck51bGwsIHZhbHVlLCBpbnN0YW5jZU9mKTtcbiAgfSxcblxuICBpc0luc3RhbmNlT2ZPclVuZGVmaW5lZChuYW1lLCB2YWx1ZSwgaW5zdGFuY2VPZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2luc3RhbmNlT2YubmFtZX0gb3IgdW5kZWZpbmVkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2suaW5zdGFuY2VPZi5vclVuZGVmaW5lZCwgdmFsdWUsIGluc3RhbmNlT2YpO1xuICB9LFxuXG4gIGlzTWVtYmVyKG5hbWUsIHZhbHVlLCBtZW1iZXJPZixcbiAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfT1VUX09GX1JBTkdFLFxuICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoXG4gICAgICAgICAgICBzdWJjb2RlLFxuICAgICAgICAgICAgYG9uZSBvZiAke21lbWJlck9mLm5hbWV9Llske29iamVjdFZhbHVlcyhtZW1iZXJPZikuam9pbignLCAnKX1dYCxcbiAgICAgICAgICAgIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5tZW1iZXIsIHZhbHVlLCBtZW1iZXJPZik7XG4gIH0sXG5cbiAgaXNOdW1iZXIobmFtZSwgdmFsdWUsXG4gICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsICdudW1iZXInLCB2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2subnVtYmVyLCB2YWx1ZSk7XG4gIH0sXG5cbiAgaXNOdW1iZXJPck5vdGhpbmcobmFtZSwgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsICdudW1iZXIgb3Igbm90aGluZycsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5udW1iZXIub3JOb3RoaW5nLCB2YWx1ZSk7XG4gIH0sXG5cbiAgaXNOdW1iZXJPck51bGwobmFtZSwgdmFsdWUsXG4gICAgICAgICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsICdudW1iZXIgb3IgbnVsbCcsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5udW1iZXIub3JOdWxsLCB2YWx1ZSk7XG4gIH0sXG5cbiAgaXNSYW5nZUNvbXBhcmUobmFtZSwgdmFsdWUsIG9wZXJhdG9yLCBvcGVyYW5kLFxuICAgICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UsXG4gICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzdWJjb2RlU3VtbWFyeShzdWJjb2RlLCBgJHtvcGVyYXRvcn0gJHtvcGVyYW5kfWAsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5yYW5nZUNvbXBhcmUsIHZhbHVlLCBvcGVyYXRvciwgb3BlcmFuZCk7XG4gIH0sXG5cbiAgaXNSYW5nZUNvbXBhcmVPck5vdGhpbmcobmFtZSwgdmFsdWUsIG9wZXJhdG9yLCBvcGVyYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBzdWJjb2RlU3VtbWFyeShzdWJjb2RlLCBgJHtvcGVyYXRvcn0gJHtvcGVyYW5kfSBvciBub3RoaW5nYCwgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKG5hbWUsIHN1YmNvZGUsIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIENoZWNrLnJhbmdlQ29tcGFyZS5vck5vdGhpbmcsIHZhbHVlLCBvcGVyYXRvciwgb3BlcmFuZCk7XG4gIH0sXG5cbiAgaXNTdHJpbmdPck51bGwobmFtZSwgdmFsdWUsXG4gICAgICAgICAgICAgICAgIHN1YmNvZGUgPSBFcnJvclN1YmNvZGUuUEFSQU1FVEVSX0lOVkFMSURfVFlQRSxcbiAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsICdzdHJpbmcgb3IgbnVsbCcsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5zdHJpbmcub3JOdWxsLCB2YWx1ZSk7XG4gIH0sXG5cblxuICBpc1N0cmluZyhuYW1lLCB2YWx1ZSxcbiAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFLFxuICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSwgJ3N0cmluZycsIHZhbHVlKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZShuYW1lLCBzdWJjb2RlLCBtZXNzYWdlLCBDaGVjay5zdHJpbmcsIHZhbHVlKTtcbiAgfSxcblxuICBpc1N0cmluZ09yTm90aGluZyhuYW1lLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3ViY29kZSA9IEVycm9yU3ViY29kZS5QQVJBTUVURVJfSU5WQUxJRF9UWVBFLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gc3ViY29kZVN1bW1hcnkoc3ViY29kZSwgJ3N0cmluZyBvciBub3RoaW5nJywgdmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKG5hbWUsIHN1YmNvZGUsIG1lc3NhZ2UsIENoZWNrLnN0cmluZy5vck5vdGhpbmcsIHZhbHVlKTtcbiAgfSxcblxuICBpc1ZhbHVlKG5hbWUsIHZhbHVlLCBleHBlY3RlZCxcbiAgICAgICAgICBzdWJjb2RlID0gRXJyb3JTdWJjb2RlLlBBUkFNRVRFUl9PVVRfT0ZfUkFOR0UsXG4gICAgICAgICAgbWVzc2FnZSA9IHN1YmNvZGVTdW1tYXJ5KHN1YmNvZGUsIGBtdXN0IGJlICR7dmFsdWV9YCkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGUobmFtZSwgc3ViY29kZSwgbWVzc2FnZSwgQ2hlY2suZXF1YWwsIHZhbHVlLCBleHBlY3RlZCk7XG4gIH0sXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLlBhcmFtZXRlciA9IFBhcmFtZXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vc29sY2xpZW50LXZhbGlkYXRlL2xpYi9wYXJhbWV0ZXIuanMiLCJcbmZ1bmN0aW9uIHByb3BlcnR5U3BlYyh2YWx1ZSwgc3BlYykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7IHZhbHVlOiB2YWx1ZSB9LCBcbiAgICBzcGVjLmluZGV4T2YoJ2MnKSA+PSAwID8geyBjb25maWd1cmFibGU6IHRydWUgfSA6IHt9LFxuICAgIHNwZWMuaW5kZXhPZignZScpID49IDAgPyB7IGVudW1lcmFibGU6IHRydWUgfSAgIDoge30sXG4gICAgc3BlYy5pbmRleE9mKCd3JykgPj0gMCA/IHsgd3JpdGFibGU6IHRydWUgfSAgICAgOiB7fVxuICApO1xufVxuXG52YXIgc29sYWNlID0gcmVxdWlyZSgnc29sY2xpZW50LWNvcmUnKTtcbnRyeSB7XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogc29sYWNlIG5hbWVzcGFjZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0Fic3RyYWN0UXVldWVEZXNjcmlwdG9yJ10gPSBzb2xhY2UuQWJzdHJhY3RRdWV1ZURlc2NyaXB0b3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yLnByb3RvdHlwZSwgJ2dldFR5cGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yLnByb3RvdHlwZS5nZXRUeXBlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5BYnN0cmFjdFF1ZXVlRGVzY3JpcHRvci5wcm90b3R5cGUsICdpc0R1cmFibGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkFic3RyYWN0UXVldWVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc0R1cmFibGUsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydBdXRoZW50aWNhdGlvblNjaGVtZSddID0gc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lO1xuc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLl9zZXRDYW5vbmljYWwoe1wiQkFTSUNcIjpcIkF1dGhlbnRpY2F0aW9uU2NoZW1lX2Jhc2ljXCIsXCJDTElFTlRfQ0VSVElGSUNBVEVcIjpcIkF1dGhlbnRpY2F0aW9uU2NoZW1lX2NsaWVudENlcnRpZmljYXRlXCIsXCJBVVRIRU5USUNBVElPTl9TQ0hFTUVfQkFTSUNcIjpcIkF1dGhlbnRpY2F0aW9uU2NoZW1lX2Jhc2ljXCIsXCJBVVRIRU5USUNBVElPTl9TQ0hFTUVfQ0xJRU5UX0NFUlRJRklDQVRFXCI6XCJBdXRoZW50aWNhdGlvblNjaGVtZV9jbGllbnRDZXJ0aWZpY2F0ZVwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkF1dGhlbnRpY2F0aW9uU2NoZW1lLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5BdXRoZW50aWNhdGlvblNjaGVtZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuQXV0aGVudGljYXRpb25TY2hlbWUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5DYWNoZUNCSW5mb1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnQ2FjaGVDQkluZm8nXSA9IHNvbGFjZS5DYWNoZUNCSW5mbztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FjaGVDQkluZm8ucHJvdG90eXBlLCAnZ2V0Q2FsbGJhY2snLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkNhY2hlQ0JJbmZvLnByb3RvdHlwZS5nZXRDYWxsYmFjaywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FjaGVDQkluZm8ucHJvdG90eXBlLCAnZ2V0VXNlck9iamVjdCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVDQkluZm8ucHJvdG90eXBlLmdldFVzZXJPYmplY3QsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkNhY2hlTGl2ZURhdGFBY3Rpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0NhY2hlTGl2ZURhdGFBY3Rpb24nXSA9IHNvbGFjZS5DYWNoZUxpdmVEYXRhQWN0aW9uO1xuc29sYWNlLkNhY2hlTGl2ZURhdGFBY3Rpb24uX3NldENhbm9uaWNhbCh7XCJGVUxGSUxMXCI6MSxcIlFVRVVFXCI6MixcIkZMT1dfVEhSVVwiOjN9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FjaGVMaXZlRGF0YUFjdGlvbiwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZUxpdmVEYXRhQWN0aW9uLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZUxpdmVEYXRhQWN0aW9uLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZUxpdmVEYXRhQWN0aW9uLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuQ2FjaGVSZXF1ZXN0UmVzdWx0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydDYWNoZVJlcXVlc3RSZXN1bHQnXSA9IHNvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlUmVxdWVzdFJlc3VsdC5wcm90b3R5cGUsICdnZXRSZXR1cm5Db2RlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHQucHJvdG90eXBlLmdldFJldHVybkNvZGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlUmVxdWVzdFJlc3VsdC5wcm90b3R5cGUsICdnZXRSZXR1cm5TdWJjb2RlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVJlcXVlc3RSZXN1bHQucHJvdG90eXBlLmdldFJldHVyblN1YmNvZGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlUmVxdWVzdFJlc3VsdC5wcm90b3R5cGUsICdnZXRUb3BpYycsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVSZXF1ZXN0UmVzdWx0LnByb3RvdHlwZS5nZXRUb3BpYywgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuQ2FjaGVSZXR1cm5Db2RlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydDYWNoZVJldHVybkNvZGUnXSA9IHNvbGFjZS5DYWNoZVJldHVybkNvZGU7XG5zb2xhY2UuQ2FjaGVSZXR1cm5Db2RlLl9zZXRDYW5vbmljYWwoe1wiT0tcIjoxLFwiRkFJTFwiOjIsXCJJTkNPTVBMRVRFXCI6M30sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVJldHVybkNvZGUsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVSZXR1cm5Db2RlLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVJldHVybkNvZGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkNhY2hlUmV0dXJuQ29kZS5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkNhY2hlUmV0dXJuU3ViY29kZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnQ2FjaGVSZXR1cm5TdWJjb2RlJ10gPSBzb2xhY2UuQ2FjaGVSZXR1cm5TdWJjb2RlO1xuc29sYWNlLkNhY2hlUmV0dXJuU3ViY29kZS5fc2V0Q2Fub25pY2FsKHtcIlJFUVVFU1RfQ09NUExFVEVcIjowLFwiTElWRV9EQVRBX0ZVTEZJTExcIjoxLFwiRVJST1JfUkVTUE9OU0VcIjoyLFwiSU5WQUxJRF9TRVNTSU9OXCI6MyxcIlJFUVVFU1RfVElNRU9VVFwiOjQsXCJSRVFVRVNUX0FMUkVBRFlfSU5fUFJPR1JFU1NcIjo1LFwiTk9fREFUQVwiOjYsXCJTVVNQRUNUX0RBVEFcIjo3LFwiQ0FDSEVfU0VTU0lPTl9ESVNQT1NFRFwiOjgsXCJTVUJTQ1JJUFRJT05fRVJST1JcIjo5fSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlUmV0dXJuU3ViY29kZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVJldHVyblN1YmNvZGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlUmV0dXJuU3ViY29kZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVSZXR1cm5TdWJjb2RlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuQ2FjaGVTZXNzaW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydDYWNoZVNlc3Npb24nXSA9IHNvbGFjZS5DYWNoZVNlc3Npb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlU2Vzc2lvbi5wcm90b3R5cGUsICdnZXRQcm9wZXJ0aWVzJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVNlc3Npb24ucHJvdG90eXBlLmdldFByb3BlcnRpZXMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlU2Vzc2lvbi5wcm90b3R5cGUsICdzZW5kQ2FjaGVSZXF1ZXN0JywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVNlc3Npb24ucHJvdG90eXBlLnNlbmRDYWNoZVJlcXVlc3QsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0NhY2hlU2Vzc2lvblByb3BlcnRpZXMnXSA9IHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgJ2dldENhY2hlTmFtZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUuZ2V0Q2FjaGVOYW1lLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgJ3NldENhY2hlTmFtZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUuc2V0Q2FjaGVOYW1lLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgJ2dldE1heE1lc3NhZ2VBZ2VTZWMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXMucHJvdG90eXBlLmdldE1heE1lc3NhZ2VBZ2VTZWMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXMucHJvdG90eXBlLCAnc2V0TWF4TWVzc2FnZUFnZVNlYycsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUuc2V0TWF4TWVzc2FnZUFnZVNlYywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUsICdnZXRNYXhNZXNzYWdlcycsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUuZ2V0TWF4TWVzc2FnZXMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXMucHJvdG90eXBlLCAnc2V0TWF4TWVzc2FnZXMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkNhY2hlU2Vzc2lvblByb3BlcnRpZXMucHJvdG90eXBlLnNldE1heE1lc3NhZ2VzLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgJ2dldFRpbWVvdXRNc2VjJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYWNoZVNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvdHlwZS5nZXRUaW1lb3V0TXNlYywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUsICdzZXRUaW1lb3V0TXNlYycsIHByb3BlcnR5U3BlYyhzb2xhY2UuQ2FjaGVTZXNzaW9uUHJvcGVydGllcy5wcm90b3R5cGUuc2V0VGltZW91dE1zZWMsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkNhcGFiaWxpdHlUeXBlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydDYXBhYmlsaXR5VHlwZSddID0gc29sYWNlLkNhcGFiaWxpdHlUeXBlO1xuc29sYWNlLkNhcGFiaWxpdHlUeXBlLl9zZXRDYW5vbmljYWwoe1wiUEVFUl9TT0ZUV0FSRV9WRVJTSU9OXCI6MCxcIlBFRVJfU09GVFdBUkVfREFURVwiOjEsXCJQRUVSX1BMQVRGT1JNXCI6MixcIlBFRVJfUE9SVF9TUEVFRFwiOjMsXCJQRUVSX1BPUlRfVFlQRVwiOjQsXCJNQVhfRElSRUNUX01TR19TSVpFXCI6NSxcIlBFRVJfUk9VVEVSX05BTUVcIjo2LFwiTUVTU0FHRV9FTElESU5HXCI6NyxcIk5PX0xPQ0FMXCI6OCxcIkdVQVJBTlRFRURfTUVTU0FHRV9DT05TVU1FXCI6OSxcIlRFTVBPUkFSWV9FTkRQT0lOVFwiOjEwLFwiR1VBUkFOVEVFRF9NRVNTQUdFX1BVQkxJU0hcIjoxMSxcIkdVQVJBTlRFRURfTUVTU0FHRV9CUk9XU0VcIjoxMixcIkVORFBPSU5UX01HTVRcIjoxMyxcIlNFTEVDVE9SXCI6MTQsXCJNQVhfR1VBUkFOVEVFRF9NU0dfU0laRVwiOjE1LFwiQUNUSVZFX0NPTlNVTUVSX0lORElDQVRJT05cIjoxNixcIkNPTVBSRVNTSU9OXCI6MTcsXCJDVVRfVEhST1VHSFwiOjE4LFwiRU5EUE9JTlRfRElTQ0FSRF9CRUhBVklPUlwiOjE5LFwiRU5EUE9JTlRfTUVTU0FHRV9UVExcIjoyMCxcIkpORElcIjoyMSxcIlBFUl9UT1BJQ19TRVFVRU5DRV9OVU1CRVJJTkdcIjoyMixcIlFVRVVFX1NVQlNDUklQVElPTlNcIjoyMyxcIlNVQlNDUklQVElPTl9NQU5BR0VSXCI6MjQsXCJUUkFOU0FDVEVEX1NFU1NJT05cIjoyNX0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5DYXBhYmlsaXR5VHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5DYXBhYmlsaXR5VHlwZS5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuQ2FwYWJpbGl0eVR5cGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkNhcGFiaWxpdHlUeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuQ29uc29sZUxvZ0ltcGxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0NvbnNvbGVMb2dJbXBsJ10gPSBzb2xhY2UuQ29uc29sZUxvZ0ltcGw7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkRlc3RpbmF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydEZXN0aW5hdGlvbiddID0gc29sYWNlLkRlc3RpbmF0aW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5EZXN0aW5hdGlvbi5wcm90b3R5cGUsICdnZXRUeXBlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5EZXN0aW5hdGlvbi5wcm90b3R5cGUuZ2V0VHlwZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuRGVzdGluYXRpb24ucHJvdG90eXBlLCAnZ2V0Qnl0ZXMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkRlc3RpbmF0aW9uLnByb3RvdHlwZS5nZXRCeXRlcywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuRGVzdGluYXRpb24ucHJvdG90eXBlLCAnZ2V0T2Zmc2V0JywgcHJvcGVydHlTcGVjKHNvbGFjZS5EZXN0aW5hdGlvbi5wcm90b3R5cGUuZ2V0T2Zmc2V0LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5EZXN0aW5hdGlvbi5wcm90b3R5cGUsICd2YWxpZGF0ZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuRGVzdGluYXRpb24ucHJvdG90eXBlLnZhbGlkYXRlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5EZXN0aW5hdGlvbi5wcm90b3R5cGUsICdpc1dpbGRjYXJkZWQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkRlc3RpbmF0aW9uLnByb3RvdHlwZS5pc1dpbGRjYXJkZWQsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkRlc3RpbmF0aW9uVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnRGVzdGluYXRpb25UeXBlJ10gPSBzb2xhY2UuRGVzdGluYXRpb25UeXBlO1xuc29sYWNlLkRlc3RpbmF0aW9uVHlwZS5fc2V0Q2Fub25pY2FsKHtcIlRPUElDXCI6XCJ0b3BpY1wiLFwiUVVFVUVcIjpcInF1ZXVlXCIsXCJURU1QT1JBUllfUVVFVUVcIjpcInRlbXBvcmFyeV9xdWV1ZVwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkRlc3RpbmF0aW9uVHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5EZXN0aW5hdGlvblR5cGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkRlc3RpbmF0aW9uVHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuRGVzdGluYXRpb25UeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuRXJyb3JTdWJjb2RlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydFcnJvclN1YmNvZGUnXSA9IHNvbGFjZS5FcnJvclN1YmNvZGU7XG5zb2xhY2UuRXJyb3JTdWJjb2RlLl9zZXRDYW5vbmljYWwoe1wiVU5LTk9XTl9FUlJPUlwiOjQyOTQ5NjcyOTUsXCJOT19FUlJPUlwiOjAsXCJTRVNTSU9OX05PVF9DT05ORUNURURcIjoyLFwiSU5WQUxJRF9TRVNTSU9OX09QRVJBVElPTlwiOjMsXCJJTlZBTElEX09QRVJBVElPTlwiOjMsXCJUSU1FT1VUXCI6NCxcIk1FU1NBR0VfVlBOX05PVF9BTExPV0VEXCI6NSxcIk1FU1NBR0VfVlBOX1VOQVZBSUxBQkxFXCI6NixcIkNMSUVOVF9VU0VSTkFNRV9JU19TSFVURE9XTlwiOjcsXCJEWU5BTUlDX0NMSUVOVFNfTk9UX0FMTE9XRURcIjo4LFwiQ0xJRU5UX05BTUVfQUxSRUFEWV9JTl9VU0VcIjo5LFwiQ0xJRU5UX05BTUVfSU5WQUxJRFwiOjEwLFwiQ0xJRU5UX0RFTEVURV9JTl9QUk9HUkVTU1wiOjExLFwiVE9PX01BTllfQ0xJRU5UU1wiOjEyLFwiTE9HSU5fRkFJTFVSRVwiOjEzLFwiSU5WQUxJRF9WSVJUVUFMX0FERFJFU1NcIjoxNCxcIkNMSUVOVF9BQ0xfREVOSUVEXCI6MTUsXCJTVUJTQ1JJUFRJT05fQUNMX0RFTklFRFwiOjE2LFwiUFVCTElTSF9BQ0xfREVOSUVEXCI6MTcsXCJQQVJBTUVURVJfT1VUX09GX1JBTkdFXCI6MTgsXCJQQVJBTUVURVJfQ09ORkxJQ1RcIjoxOSxcIlBBUkFNRVRFUl9JTlZBTElEX1RZUEVcIjoyMCxcIklOVEVSTkFMX0VSUk9SXCI6MjEsXCJJTlNVRkZJQ0lFTlRfU1BBQ0VcIjoyMixcIk9VVF9PRl9SRVNPVVJDRVNcIjoyMyxcIlBST1RPQ09MX0VSUk9SXCI6MjQsXCJDT01NVU5JQ0FUSU9OX0VSUk9SXCI6MjUsXCJLRUVQX0FMSVZFX0ZBSUxVUkVcIjoyNixcIlRPUElDX01JU1NJTkdcIjoyOCxcIklOVkFMSURfVE9QSUNfU1lOVEFYXCI6MzEsXCJNRVNTQUdFX1RPT19MQVJHRVwiOjMyLFwiWE1MX1BBUlNFX0VSUk9SXCI6MzMsXCJTVUJTQ1JJUFRJT05fQUxSRUFEWV9QUkVTRU5UXCI6MzQsXCJTVUJTQ1JJUFRJT05fTk9UX0ZPVU5EXCI6MzUsXCJTVUJTQ1JJUFRJT05fSU5WQUxJRFwiOjM2LFwiU1VCU0NSSVBUSU9OX0VSUk9SX09USEVSXCI6MzcsXCJTVUJTQ1JJUFRJT05fVE9PX01BTllcIjozOCxcIlNVQlNDUklQVElPTl9BVFRSSUJVVEVTX0NPTkZMSUNUXCI6MzksXCJOT19MT0NBTF9OT1RfU1VQUE9SVEVEXCI6NDAsXCJEQVRBX0VSUk9SX09USEVSXCI6NDIsXCJDUkVBVEVfWEhSX0ZBSUxFRFwiOjQzLFwiQ09OTkVDVElPTl9FUlJPUlwiOjQ0LFwiREFUQV9ERUNPREVfRVJST1JcIjo0NSxcIklOQUNUSVZJVFlfVElNRU9VVFwiOjQ2LFwiVU5LTk9XTl9UUkFOU1BPUlRfU0VTU0lPTl9JRFwiOjQ3LFwiQURfTUVTU0FHSU5HX05PVF9TVVBQT1JURURcIjo0OCxcIkNSRUFURV9XRUJTT0NLRVRfRkFJTEVEXCI6NDksXCJSRVBMSUNBVElPTl9JU19TVEFOREJZXCI6NTAsXCJCQVNJQ19BVVRIRU5USUNBVElPTl9JU19TSFVURE9XTlwiOjUxLFwiQ0xJRU5UX0NFUlRJRklDQVRFX0FVVEhFTlRJQ0FUSU9OX0lTX1NIVVRET1dOXCI6NTIsXCJHTV9VTkFWQUlMQUJMRVwiOjEwMCxcIlVOS05PV05fRkxPV19OQU1FXCI6MTExLFwiQUxSRUFEWV9CT1VORFwiOjExMixcIklOVkFMSURfVE9QSUNfTkFNRV9GT1JfVE9QSUNfRU5EUE9JTlRcIjoxMTMsXCJVTktOT1dOX1FVRVVFX05BTUVcIjoxMTQsXCJVTktOT1dOX1RPUElDX0VORFBPSU5UX05BTUVcIjoxMTUsXCJNQVhfQ0xJRU5UU19GT1JfUVVFVUVcIjoxMTYsXCJNQVhfQ0xJRU5UU19GT1JfVEVcIjoxMTcsXCJVTkVYUEVDVEVEX1VOQklORFwiOjExOCxcIlFVRVVFX05PVF9GT1VORFwiOjExOSxcIlNQT09MX09WRVJfUVVPVEFcIjoxMjAsXCJRVUVVRV9TSFVURE9XTlwiOjEyMSxcIlRPUElDX0VORFBPSU5UX1NIVVRET1dOXCI6MTIyLFwiTk9fTU9SRV9OT05fRFVSQUJMRV9RVUVVRV9PUl9UT1BJQ19FTkRQT0lOVFwiOjEyMyxcIkVORFBPSU5UX0FMUkVBRFlfRVhJU1RTXCI6MTI0LFwiUEVSTUlTU0lPTl9OT1RfQUxMT1dFRFwiOjEyNSxcIklOVkFMSURfU0VMRUNUT1JcIjoxMjYsXCJNQVhfTUVTU0FHRV9VU0FHRV9FWENFRURFRFwiOjEyNyxcIkVORFBPSU5UX1BST1BFUlRZX01JU01BVENIXCI6MTI4LFwiTk9fU1VCU0NSSVBUSU9OX01BVENIXCI6MTI5LFwiTUVTU0FHRV9ERUxJVkVSWV9NT0RFX01JU01BVENIXCI6MTMwLFwiTUVTU0FHRV9BTFJFQURZX0FDS05PV0xFREdFRFwiOjEzMSxcIlNVQlNDUklQVElPTl9ET0VTX05PVF9NQVRDSFwiOjEzMyxcIlNFTEVDVE9SX0RPRVNfTk9UX01BVENIXCI6MTM0LFwiSU5WQUxJRF9EVEVfTkFNRVwiOjEzNSxcIlVOU1VCU0NSSUJFX05PVF9BTExPV0VEX0NMSUVOVFNfQk9VTkRcIjoxMzYsXCJDQUxMQkFDS19FUlJPUlwiOjEzNyxcIk5PTE9DQUxfRElTQ0FSRFwiOjEzOCxcIkdNX05PVF9SRUFEWVwiOjE0MCxcIkxPV19QUklPUklUWV9NU0dfQ09OR0VTVElPTlwiOjE0MSxcIlFVT1RBX09VVF9PRl9SQU5HRVwiOjE0MixcIkZBSUxFRF9MT0FESU5HX1RSVVNUU1RPUkVcIjoxNDMsXCJGQUlMRURfTE9BRElOR19DRVJUSUZJQ0FURV9BTkRfS0VZXCI6MTQ0LFwiVU5SRVNPTFZFRF9IT1NUU1wiOjE0NX0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5FcnJvclN1YmNvZGUsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuRXJyb3JTdWJjb2RlLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5FcnJvclN1YmNvZGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLkVycm9yU3ViY29kZS5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkxvZ0ltcGxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0xvZ0ltcGwnXSA9IHNvbGFjZS5Mb2dJbXBsO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5Mb2dMZXZlbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnTG9nTGV2ZWwnXSA9IHNvbGFjZS5Mb2dMZXZlbDtcbnNvbGFjZS5Mb2dMZXZlbC5fc2V0Q2Fub25pY2FsKHtcIkZBVEFMXCI6MCxcIkVSUk9SXCI6MSxcIldBUk5cIjoyLFwiSU5GT1wiOjMsXCJERUJVR1wiOjQsXCJUUkFDRVwiOjV9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTG9nTGV2ZWwsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTG9nTGV2ZWwuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLkxvZ0xldmVsLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Mb2dMZXZlbC5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLkxvbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ0xvbmcnXSA9IHNvbGFjZS5Mb25nO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydNZXNzYWdlJ10gPSBzb2xhY2UuTWVzc2FnZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRUeXBlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRUeXBlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEFwcGxpY2F0aW9uTWVzc2FnZUlkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5zZXRBcHBsaWNhdGlvbk1lc3NhZ2VJZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRBcHBsaWNhdGlvbk1lc3NhZ2VJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0QXBwbGljYXRpb25NZXNzYWdlSWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0QXBwbGljYXRpb25NZXNzYWdlVHlwZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0QXBwbGljYXRpb25NZXNzYWdlVHlwZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRBcHBsaWNhdGlvbk1lc3NhZ2VUeXBlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldEJpbmFyeUF0dGFjaG1lbnQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldEJpbmFyeUF0dGFjaG1lbnQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0QmluYXJ5QXR0YWNobWVudCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0QmluYXJ5QXR0YWNobWVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRDYWNoZVJlcXVlc3RJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q2FjaGVSZXF1ZXN0SWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0Q29ycmVsYXRpb25JZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0Q29ycmVsYXRpb25JZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRDb3JyZWxhdGlvbklkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5zZXRDb3JyZWxhdGlvbklkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldENvcnJlbGF0aW9uS2V5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRDb3JyZWxhdGlvbktleSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRDb3JyZWxhdGlvbktleScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0Q29ycmVsYXRpb25LZXksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnaXNEZWxpdmVyVG9PbmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmlzRGVsaXZlclRvT25lLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldERlbGl2ZXJUb09uZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0RGVsaXZlclRvT25lLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldERlbGl2ZXJ5TW9kZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0RGVsaXZlcnlNb2RlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldERlbGl2ZXJ5TW9kZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0RGVsaXZlcnlNb2RlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldERlc3RpbmF0aW9uJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXREZXN0aW5hdGlvbiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXREZXN0aW5hdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0RGVzdGluYXRpb24sICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnaXNEaXNjYXJkSW5kaWNhdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuaXNEaXNjYXJkSW5kaWNhdGlvbiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXREaXNjYXJkSW5kaWNhdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0RGlzY2FyZEluZGljYXRpb24sICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnaXNFbGlkaW5nRWxpZ2libGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmlzRWxpZGluZ0VsaWdpYmxlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEVsaWRpbmdFbGlnaWJsZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0RWxpZGluZ0VsaWdpYmxlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFB1Ymxpc2hlcklkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRQdWJsaXNoZXJJZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRQdWJsaXNoZXJJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0UHVibGlzaGVySWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0UHVibGlzaGVyTWVzc2FnZUlkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRQdWJsaXNoZXJNZXNzYWdlSWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0UHVibGlzaGVyTWVzc2FnZUlkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5zZXRQdWJsaXNoZXJNZXNzYWdlSWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0VGltZVRvTGl2ZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0VGltZVRvTGl2ZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRUaW1lVG9MaXZlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5zZXRUaW1lVG9MaXZlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldEdNRXhwaXJhdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0R01FeHBpcmF0aW9uLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEdNRXhwaXJhdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0R01FeHBpcmF0aW9uLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2lzRE1RRWxpZ2libGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmlzRE1RRWxpZ2libGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0RE1RRWxpZ2libGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLnNldERNUUVsaWdpYmxlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldEZsb3dJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0Rmxvd0lkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEZsb3dJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0Rmxvd0lkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldEd1YXJhbnRlZWRQcmV2aW91c01lc3NhZ2VJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0R3VhcmFudGVlZFByZXZpb3VzTWVzc2FnZUlkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEd1YXJhbnRlZWRQcmV2aW91c01lc3NhZ2VJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0R3VhcmFudGVlZFByZXZpb3VzTWVzc2FnZUlkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldE1lc3NhZ2VDb25zdW1lcicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0TWVzc2FnZUNvbnN1bWVyLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldE1lc3NhZ2VDb25zdW1lcicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0TWVzc2FnZUNvbnN1bWVyLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldEd1YXJhbnRlZWRNZXNzYWdlSWQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldEd1YXJhbnRlZWRNZXNzYWdlSWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0R3VhcmFudGVlZE1lc3NhZ2VJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0R3VhcmFudGVlZE1lc3NhZ2VJZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRUb3BpY1NlcXVlbmNlTnVtYmVyJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRUb3BpY1NlcXVlbmNlTnVtYmVyLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldFRvcGljU2VxdWVuY2VOdW1iZXInLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLnNldFRvcGljU2VxdWVuY2VOdW1iZXIsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnYWNrbm93bGVkZ2UnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmFja25vd2xlZGdlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2lzQWNrbm93bGVkZ2VJbW1lZGlhdGVseScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuaXNBY2tub3dsZWRnZUltbWVkaWF0ZWx5LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldEFja25vd2xlZGdlSW1tZWRpYXRlbHknLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLnNldEFja25vd2xlZGdlSW1tZWRpYXRlbHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0Q2FjaGVTdGF0dXMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldENhY2hlU3RhdHVzLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2lzUmVwbHlNZXNzYWdlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5pc1JlcGx5TWVzc2FnZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdpc1JlZGVsaXZlcmVkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5pc1JlZGVsaXZlcmVkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldFJlZGVsaXZlcmVkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5zZXRSZWRlbGl2ZXJlZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRBc1JlcGx5TWVzc2FnZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0QXNSZXBseU1lc3NhZ2UsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0UmVjZWl2ZXJUaW1lc3RhbXAnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldFJlY2VpdmVyVGltZXN0YW1wLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFJlcGx5VG8nLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldFJlcGx5VG8sICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0UmVwbHlUbycsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0UmVwbHlUbywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRTZW5kZXJJZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VuZGVySWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0U2VuZGVySWQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLnNldFNlbmRlcklkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFNlbmRlclRpbWVzdGFtcCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2VuZGVyVGltZXN0YW1wLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldFNlbmRlclRpbWVzdGFtcCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0U2VuZGVyVGltZXN0YW1wLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFNlcXVlbmNlTnVtYmVyJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5nZXRTZXF1ZW5jZU51bWJlciwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRTZXF1ZW5jZU51bWJlcicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0U2VxdWVuY2VOdW1iZXIsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0VXNlckNvcycsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0VXNlckNvcywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRQcmlvcml0eScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0UHJpb3JpdHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0VXNlckNvcycsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0VXNlckNvcywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRQcmlvcml0eScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0UHJpb3JpdHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0WG1sQ29udGVudCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0WG1sQ29udGVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdnZXRYbWxDb250ZW50RGVjb2RlZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0WG1sQ29udGVudERlY29kZWQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnc2V0WG1sQ29udGVudCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0WG1sQ29udGVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUsICdzZXRYbWxNZXRhZGF0YScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0WG1sTWV0YWRhdGEsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLCAnZ2V0WG1sTWV0YWRhdGEnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2UucHJvdG90eXBlLmdldFhtbE1ldGFkYXRhLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFVzZXJQcm9wZXJ0eU1hcCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0VXNlclByb3BlcnR5TWFwLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldFVzZXJQcm9wZXJ0eU1hcCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0VXNlclByb3BlcnR5TWFwLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3NldFNkdENvbnRhaW5lcicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuc2V0U2R0Q29udGFpbmVyLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ2dldFNkdENvbnRhaW5lcicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZS5wcm90b3R5cGUuZ2V0U2R0Q29udGFpbmVyLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZSwgJ3Jlc2V0JywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlLnByb3RvdHlwZS5yZXNldCwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydNZXNzYWdlQ2FjaGVTdGF0dXMnXSA9IHNvbGFjZS5NZXNzYWdlQ2FjaGVTdGF0dXM7XG5zb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzLl9zZXRDYW5vbmljYWwoe1wiTElWRVwiOjAsXCJDQUNIRURcIjoxLFwiU1VTUEVDVFwiOjJ9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDYWNoZVN0YXR1cy5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNhY2hlU3RhdHVzLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ2FjaGVTdGF0dXMubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ01lc3NhZ2VDb25zdW1lciddID0gc29sYWNlLk1lc3NhZ2VDb25zdW1lcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2dldERlc3RpbmF0aW9uJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLmdldERlc3RpbmF0aW9uLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLCAnYXBwbGljYXRpb25BY2snLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuYXBwbGljYXRpb25BY2ssICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUsICdnZXREaXNwb3NlZEV2ZW50JywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLmdldERpc3Bvc2VkRXZlbnQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUsICdoYW5kbGVEYXRhTWVzc2FnZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZS5oYW5kbGVEYXRhTWVzc2FnZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2hhbmRsZVVuY29ycmVsYXRlZENvbnRyb2xNZXNzYWdlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLmhhbmRsZVVuY29ycmVsYXRlZENvbnRyb2xNZXNzYWdlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLCAnZ2V0UHJvcGVydGllcycsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLCAnb25WUk5DaGFuZ2VkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLm9uVlJOQ2hhbmdlZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2NsZWFyU3RhdHMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuY2xlYXJTdGF0cywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2dldERpc3Bvc2VkRXZlbnQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuZ2V0RGlzcG9zZWRFdmVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2dldFByb3BlcnRpZXMnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuZ2V0UHJvcGVydGllcywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2dldFN0YXQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuZ2V0U3RhdCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2hhbmRsZVVuY29ycmVsYXRlZENvbnRyb2xNZXNzYWdlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLmhhbmRsZVVuY29ycmVsYXRlZENvbnRyb2xNZXNzYWdlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLCAnaW5jU3RhdCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZS5pbmNTdGF0LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLCAncHJvY2Vzc0ZTTUV2ZW50JywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLnByb2Nlc3NGU01FdmVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2Zvcm1hdEVycm9yRXZlbnQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lci5wcm90b3R5cGUuZm9ybWF0RXJyb3JFdmVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZUNvbnN1bWVyLnByb3RvdHlwZSwgJ2Rpc2FibGVFbWl0dGVyJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXIucHJvdG90eXBlLmRpc2FibGVFbWl0dGVyLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ01lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSddID0gc29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZTtcbnNvbGFjZS5NZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGUuX3NldENhbm9uaWNhbCh7XCJBVVRPXCI6XCJBVVRPXCIsXCJDTElFTlRcIjpcIkNMSUVOVFwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJBY2tub3dsZWRnZU1vZGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VDb25zdW1lckFja25vd2xlZGdlTW9kZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUNvbnN1bWVyQWNrbm93bGVkZ2VNb2RlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUnXSA9IHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWU7XG5zb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLl9zZXRDYW5vbmljYWwoe1wiVVBcIjpcIk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV91cFwiLFwiRE9XTlwiOlwiTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2Rvd25cIixcIkFDVElWRVwiOlwiTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2FjdGl2ZVwiLFwiSU5BQ1RJVkVcIjpcIk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV9pbmFjdGl2ZVwiLFwiRE9XTl9FUlJPUlwiOlwiTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX2Rvd25FcnJvclwiLFwiQ09OTkVDVF9GQUlMRURfRVJST1JcIjpcIk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV9jb25uZWN0RmFpbGVkRXJyb3JcIixcIkdNX0RJU0FCTEVEXCI6XCJNZXNzYWdlQ29uc3VtZXJFdmVudE5hbWVfR01EaXNhYmxlZFwiLFwiRElTUE9TRURcIjpcIk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZV9kaXNwb3NlZFwiLFwiTUVTU0FHRVwiOlwiTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lX21lc3NhZ2VcIn0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUNvbnN1bWVyRXZlbnROYW1lLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJFdmVudE5hbWUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VDb25zdW1lckV2ZW50TmFtZS5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLk1lc3NhZ2VDb25zdW1lclByb3BlcnRpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ01lc3NhZ2VDb25zdW1lclByb3BlcnRpZXMnXSA9IHNvbGFjZS5NZXNzYWdlQ29uc3VtZXJQcm9wZXJ0aWVzO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUnXSA9IHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZTtcbnNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5fc2V0Q2Fub25pY2FsKHtcIkRJUkVDVFwiOjAsXCJQRVJTSVNURU5UXCI6MSxcIk5PTl9QRVJTSVNURU5UXCI6Mn0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlRGVsaXZlcnlNb2RlVHlwZS5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZURlbGl2ZXJ5TW9kZVR5cGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VEZWxpdmVyeU1vZGVUeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuTWVzc2FnZUR1bXBGbGFnXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydNZXNzYWdlRHVtcEZsYWcnXSA9IHNvbGFjZS5NZXNzYWdlRHVtcEZsYWc7XG5zb2xhY2UuTWVzc2FnZUR1bXBGbGFnLl9zZXRDYW5vbmljYWwoe1wiTVNHRFVNUF9CUklFRlwiOjAsXCJNU0dEVU1QX0ZVTExcIjoxfSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VEdW1wRmxhZywgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlRHVtcEZsYWcuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VEdW1wRmxhZywgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZUR1bXBGbGFnLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSddID0gc29sYWNlLk1lc3NhZ2VQdWJsaXNoZXJBY2tub3dsZWRnZU1vZGU7XG5zb2xhY2UuTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZS5fc2V0Q2Fub25pY2FsKHtcIlBFUl9NRVNTQUdFXCI6XCJQRVJfTUVTU0FHRVwiLFwiV0lORE9XRURcIjpcIldJTkRPV0VEXCJ9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlckFja25vd2xlZGdlTW9kZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlUHVibGlzaGVyQWNrbm93bGVkZ2VNb2RlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ01lc3NhZ2VQdWJsaXNoZXJQcm9wZXJ0aWVzJ10gPSBzb2xhY2UuTWVzc2FnZVB1Ymxpc2hlclByb3BlcnRpZXM7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLk1lc3NhZ2VSeENCSW5mb1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnTWVzc2FnZVJ4Q0JJbmZvJ10gPSBzb2xhY2UuTWVzc2FnZVJ4Q0JJbmZvO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnTWVzc2FnZVR5cGUnXSA9IHNvbGFjZS5NZXNzYWdlVHlwZTtcbnNvbGFjZS5NZXNzYWdlVHlwZS5fc2V0Q2Fub25pY2FsKHtcIkJJTkFSWVwiOjAsXCJNQVBcIjoxLFwiU1RSRUFNXCI6MixcIlRFWFRcIjozfSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk1lc3NhZ2VUeXBlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VUeXBlLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NZXNzYWdlVHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuTWVzc2FnZVR5cGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NZXNzYWdlVXNlckNvc1R5cGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ01lc3NhZ2VVc2VyQ29zVHlwZSddID0gc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZTtcbnNvbGFjZS5NZXNzYWdlVXNlckNvc1R5cGUuX3NldENhbm9uaWNhbCh7XCJDT1MxXCI6MCxcIkNPUzJcIjoxLFwiQ09TM1wiOjJ9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZVVzZXJDb3NUeXBlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk1lc3NhZ2VVc2VyQ29zVHlwZS5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTWVzc2FnZVVzZXJDb3NUeXBlLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5NZXNzYWdlVXNlckNvc1R5cGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5NdXRhYmxlU2Vzc2lvblByb3BlcnR5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydNdXRhYmxlU2Vzc2lvblByb3BlcnR5J10gPSBzb2xhY2UuTXV0YWJsZVNlc3Npb25Qcm9wZXJ0eTtcbnNvbGFjZS5NdXRhYmxlU2Vzc2lvblByb3BlcnR5Ll9zZXRDYW5vbmljYWwoe1wiQ0xJRU5UX05BTUVcIjoxLFwiQ0xJRU5UX0RFU0NSSVBUSU9OXCI6Mn0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5NdXRhYmxlU2Vzc2lvblByb3BlcnR5LCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk11dGFibGVTZXNzaW9uUHJvcGVydHkuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLk11dGFibGVTZXNzaW9uUHJvcGVydHksICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLk11dGFibGVTZXNzaW9uUHJvcGVydHkubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5Ob3RJbXBsZW1lbnRlZEVycm9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydOb3RJbXBsZW1lbnRlZEVycm9yJ10gPSBzb2xhY2UuTm90SW1wbGVtZW50ZWRFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuTm90SW1wbGVtZW50ZWRFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJywgcHJvcGVydHlTcGVjKFwiXCIsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLk9wZXJhdGlvbkVycm9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydPcGVyYXRpb25FcnJvciddID0gc29sYWNlLk9wZXJhdGlvbkVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5PcGVyYXRpb25FcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJywgcHJvcGVydHlTcGVjKFwiXCIsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlF1ZXVlQWNjZXNzVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnUXVldWVBY2Nlc3NUeXBlJ10gPSBzb2xhY2UuUXVldWVBY2Nlc3NUeXBlO1xuc29sYWNlLlF1ZXVlQWNjZXNzVHlwZS5fc2V0Q2Fub25pY2FsKHtcIkVYQ0xVU0lWRVwiOlwiRVhDTFVTSVZFXCIsXCJOT05FWENMVVNJVkVcIjpcIk5PTkVYQ0xVU0lWRVwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlQWNjZXNzVHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5RdWV1ZUFjY2Vzc1R5cGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlQWNjZXNzVHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuUXVldWVBY2Nlc3NUeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuUXVldWVEZXNjcmlwdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydRdWV1ZURlc2NyaXB0b3InXSA9IHNvbGFjZS5RdWV1ZURlc2NyaXB0b3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlRGVzY3JpcHRvciwgJ2NyZWF0ZUZyb21TcGVjJywgcHJvcGVydHlTcGVjKHNvbGFjZS5RdWV1ZURlc2NyaXB0b3IuY3JlYXRlRnJvbVNwZWMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlRGVzY3JpcHRvci5wcm90b3R5cGUsICdnZXRUeXBlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5RdWV1ZURlc2NyaXB0b3IucHJvdG90eXBlLmdldFR5cGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlRGVzY3JpcHRvci5wcm90b3R5cGUsICdpc0R1cmFibGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlF1ZXVlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNEdXJhYmxlLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnUXVldWVEaXNjYXJkQmVoYXZpb3InXSA9IHNvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvcjtcbnNvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvci5fc2V0Q2Fub25pY2FsKHtcIk5PVElGWV9TRU5ERVJfT05cIjpcIk5PVElGWV9TRU5ERVJfT05cIixcIk5PVElGWV9TRU5ERVJfT0ZGXCI6XCJOT1RJRllfU0VOREVSX09GRlwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlRGlzY2FyZEJlaGF2aW9yLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlF1ZXVlRGlzY2FyZEJlaGF2aW9yLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5RdWV1ZURpc2NhcmRCZWhhdmlvciwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuUXVldWVEaXNjYXJkQmVoYXZpb3IubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5RdWV1ZVBlcm1pc3Npb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydRdWV1ZVBlcm1pc3Npb25zJ10gPSBzb2xhY2UuUXVldWVQZXJtaXNzaW9ucztcbnNvbGFjZS5RdWV1ZVBlcm1pc3Npb25zLl9zZXRDYW5vbmljYWwoe1wiTk9ORVwiOlwiTk9ORVwiLFwiUkVBRF9PTkxZXCI6XCJSRUFEX09OTFlcIixcIkNPTlNVTUVcIjpcIkNPTlNVTUVcIixcIk1PRElGWV9UT1BJQ1wiOlwiTU9ESUZZX1RPUElDXCIsXCJERUxFVEVcIjpcIkRFTEVURVwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlUGVybWlzc2lvbnMsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuUXVldWVQZXJtaXNzaW9ucy5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuUXVldWVQZXJtaXNzaW9ucywgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuUXVldWVQZXJtaXNzaW9ucy5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlF1ZXVlUHJvcGVydGllc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnUXVldWVQcm9wZXJ0aWVzJ10gPSBzb2xhY2UuUXVldWVQcm9wZXJ0aWVzO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5RdWV1ZVR5cGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1F1ZXVlVHlwZSddID0gc29sYWNlLlF1ZXVlVHlwZTtcbnNvbGFjZS5RdWV1ZVR5cGUuX3NldENhbm9uaWNhbCh7XCJRVUVVRVwiOlwiUVVFVUVcIixcIlRPUElDX0VORFBPSU5UXCI6XCJUT1BJQ19FTkRQT0lOVFwifSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlVHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5RdWV1ZVR5cGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlF1ZXVlVHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuUXVldWVUeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuUmVxdWVzdEVycm9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydSZXF1ZXN0RXJyb3InXSA9IHNvbGFjZS5SZXF1ZXN0RXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlJlcXVlc3RFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJywgcHJvcGVydHlTcGVjKFwiXCIsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlJlcXVlc3RFdmVudENvZGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1JlcXVlc3RFdmVudENvZGUnXSA9IHNvbGFjZS5SZXF1ZXN0RXZlbnRDb2RlO1xuc29sYWNlLlJlcXVlc3RFdmVudENvZGUuX3NldENhbm9uaWNhbCh7XCJSRVFVRVNUX0FCT1JURURcIjo4LFwiUkVRVUVTVF9USU1FT1VUXCI6OX0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5SZXF1ZXN0RXZlbnRDb2RlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlJlcXVlc3RFdmVudENvZGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlJlcXVlc3RFdmVudENvZGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlJlcXVlc3RFdmVudENvZGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5TRFRGaWVsZFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnU0RURmllbGQnXSA9IHNvbGFjZS5TRFRGaWVsZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RURmllbGQsICdjcmVhdGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNEVEZpZWxkLmNyZWF0ZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RURmllbGQucHJvdG90eXBlLCAnZ2V0VHlwZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RURmllbGQucHJvdG90eXBlLmdldFR5cGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVEZpZWxkLnByb3RvdHlwZSwgJ2dldFZhbHVlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRGaWVsZC5wcm90b3R5cGUuZ2V0VmFsdWUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVEZpZWxkLnByb3RvdHlwZSwgJ3NldEVycm9yJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRGaWVsZC5wcm90b3R5cGUuc2V0RXJyb3IsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlNEVEZpZWxkVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnU0RURmllbGRUeXBlJ10gPSBzb2xhY2UuU0RURmllbGRUeXBlO1xuc29sYWNlLlNEVEZpZWxkVHlwZS5fc2V0Q2Fub25pY2FsKHtcIkJPT0xcIjowLFwiVUlOVDhcIjoxLFwiSU5UOFwiOjIsXCJVSU5UMTZcIjozLFwiSU5UMTZcIjo0LFwiVUlOVDMyXCI6NSxcIklOVDMyXCI6NixcIlVJTlQ2NFwiOjcsXCJJTlQ2NFwiOjgsXCJXQ0hBUlwiOjksXCJTVFJJTkdcIjoxMCxcIkJZVEVBUlJBWVwiOjExLFwiRkxPQVRUWVBFXCI6MTIsXCJET1VCTEVUWVBFXCI6MTMsXCJNQVBcIjoxNCxcIlNUUkVBTVwiOjE1LFwiREVTVElOQVRJT05cIjoxNixcIk5VTExUWVBFXCI6MTcsXCJVTktOT1dOXCI6MTgsXCJTTUZfTUVTU0FHRVwiOjE5fSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVEZpZWxkVHlwZSwgJ2Rlc2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRGaWVsZFR5cGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVEZpZWxkVHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RURmllbGRUeXBlLm5hbWVPZiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU0RUTWFwQ29udGFpbmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTRFRNYXBDb250YWluZXInXSA9IHNvbGFjZS5TRFRNYXBDb250YWluZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVE1hcENvbnRhaW5lci5wcm90b3R5cGUsICdnZXRLZXlzJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRNYXBDb250YWluZXIucHJvdG90eXBlLmdldEtleXMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVE1hcENvbnRhaW5lci5wcm90b3R5cGUsICdnZXRGaWVsZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RUTWFwQ29udGFpbmVyLnByb3RvdHlwZS5nZXRGaWVsZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUTWFwQ29udGFpbmVyLnByb3RvdHlwZSwgJ2RlbGV0ZUZpZWxkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRNYXBDb250YWluZXIucHJvdG90eXBlLmRlbGV0ZUZpZWxkLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TRFRNYXBDb250YWluZXIucHJvdG90eXBlLCAnYWRkRmllbGQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNEVE1hcENvbnRhaW5lci5wcm90b3R5cGUuYWRkRmllbGQsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlNEVFN0cmVhbUNvbnRhaW5lclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnU0RUU3RyZWFtQ29udGFpbmVyJ10gPSBzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXIucHJvdG90eXBlLCAnaGFzTmV4dCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyLnByb3RvdHlwZS5oYXNOZXh0LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXIucHJvdG90eXBlLCAnZ2V0TmV4dCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyLnByb3RvdHlwZS5nZXROZXh0LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXIucHJvdG90eXBlLCAncmV3aW5kJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXIucHJvdG90eXBlLnJld2luZCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUU3RyZWFtQ29udGFpbmVyLnByb3RvdHlwZSwgJ2FkZEZpZWxkJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRTdHJlYW1Db250YWluZXIucHJvdG90eXBlLmFkZEZpZWxkLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5TRFRVbnN1cHBvcnRlZFZhbHVlRXJyb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1NEVFVuc3VwcG9ydGVkVmFsdWVFcnJvciddID0gc29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yLnByb3RvdHlwZSwgJ2luc3BlY3QnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvci5wcm90b3R5cGUuaW5zcGVjdCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yLnByb3RvdHlwZSwgJ2dldFN1YmNvZGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvci5wcm90b3R5cGUuZ2V0U3ViY29kZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yLnByb3RvdHlwZSwgJ2dldFNvdXJjZURhdGEnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNEVFVuc3VwcG9ydGVkVmFsdWVFcnJvci5wcm90b3R5cGUuZ2V0U291cmNlRGF0YSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUVW5zdXBwb3J0ZWRWYWx1ZUVycm9yLnByb3RvdHlwZSwgJ21lc3NhZ2UnLCBwcm9wZXJ0eVNwZWMoXCJcIiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU0RUVmFsdWVFcnJvclN1YmNvZGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1NEVFZhbHVlRXJyb3JTdWJjb2RlJ10gPSBzb2xhY2UuU0RUVmFsdWVFcnJvclN1YmNvZGU7XG5zb2xhY2UuU0RUVmFsdWVFcnJvclN1YmNvZGUuX3NldENhbm9uaWNhbCh7XCJWQUxVRV9PVVRTSURFX1NVUFBPUlRFRF9SQU5HRVwiOjF9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU0RUVmFsdWVFcnJvclN1YmNvZGUsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU0RUVmFsdWVFcnJvclN1YmNvZGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNEVFZhbHVlRXJyb3JTdWJjb2RlLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TRFRWYWx1ZUVycm9yU3ViY29kZS5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlNlc3Npb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1Nlc3Npb24nXSA9IHNvbGFjZS5TZXNzaW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ3N1YnNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuc3Vic2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ3Vuc3Vic2NyaWJlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICd1bnN1YnNjcmliZUR1cmFibGVUb3BpY0VuZHBvaW50JywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS51bnN1YnNjcmliZUR1cmFibGVUb3BpY0VuZHBvaW50LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ3VwZGF0ZVByb3BlcnR5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS51cGRhdGVQcm9wZXJ0eSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdzZW5kUmVxdWVzdCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuc2VuZFJlcXVlc3QsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnc2VuZFJlcGx5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5zZW5kUmVwbHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnZ2V0U3RhdCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuZ2V0U3RhdCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdyZXNldFN0YXRzJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5yZXNldFN0YXRzLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2dldFNlc3Npb25Qcm9wZXJ0aWVzJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRTZXNzaW9uUHJvcGVydGllcywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdpc0NhcGFibGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmlzQ2FwYWJsZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdnZXRDYXBhYmlsaXR5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRDYXBhYmlsaXR5LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2dldFNlc3Npb25TdGF0ZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuZ2V0U2Vzc2lvblN0YXRlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2dldEZTTVN0YXRlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRGU01TdGF0ZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdjcmVhdGVDYWNoZVNlc3Npb24nLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmNyZWF0ZUNhY2hlU2Vzc2lvbiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdjcmVhdGVNZXNzYWdlQ29uc3VtZXInLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmNyZWF0ZU1lc3NhZ2VDb25zdW1lciwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdjcmVhdGVEZXN0aW5hdGlvbkZyb21EZXNjcmlwdG9yJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5jcmVhdGVEZXN0aW5hdGlvbkZyb21EZXNjcmlwdG9yLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2NyZWF0ZVRlbXBvcmFyeURlc3RpbmF0aW9uJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5jcmVhdGVUZW1wb3JhcnlEZXN0aW5hdGlvbiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdzZW5kRXZlbnQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLnNlbmRFdmVudCwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdnZXRUcmFuc3BvcnRJbmZvJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRUcmFuc3BvcnRJbmZvLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2luamVjdFRyYW5zcG9ydEludGVyY2VwdG9yJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5pbmplY3RUcmFuc3BvcnRJbnRlcmNlcHRvciwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdhbGxvd09wZXJhdGlvbicsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuYWxsb3dPcGVyYXRpb24sICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAndXBkYXRlQ2FwYWJpbGl0aWVzJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS51cGRhdGVDYXBhYmlsaXRpZXMsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAndmFsaWRhdGVBbmRTZW5kTWVzc2FnZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUudmFsaWRhdGVBbmRTZW5kTWVzc2FnZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdlbnF1ZXVlT3V0c3RhbmRpbmdEYXRhUmVxJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5lbnF1ZXVlT3V0c3RhbmRpbmdEYXRhUmVxLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2NhbmNlbE91dHN0YW5kaW5nRGF0YVJlcScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuY2FuY2VsT3V0c3RhbmRpbmdEYXRhUmVxLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2NsZWFudXBTZXNzaW9uJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5jbGVhbnVwU2Vzc2lvbiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdoYW5kbGVEYXRhTWVzc2FnZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuaGFuZGxlRGF0YU1lc3NhZ2UsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlUmVzcG9uc2UnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmhhbmRsZVN1YnNjcmlwdGlvblVwZGF0ZVJlc3BvbnNlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2hhbmRsZURURVVuc3Vic2NyaWJlUmVzcG9uc2UnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmhhbmRsZURURVVuc3Vic2NyaWJlUmVzcG9uc2UsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnaGFuZGxlU3Vic2NyaXB0aW9uVXBkYXRlRXJyb3InLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLmhhbmRsZVN1YnNjcmlwdGlvblVwZGF0ZUVycm9yLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2dldEV2ZW50Q0JJbmZvJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRFdmVudENCSW5mbywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdzZXRFdmVudENCSW5mbycsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuc2V0RXZlbnRDQkluZm8sICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnZ2V0TWVzc2FnZUNCSW5mbycsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUuZ2V0TWVzc2FnZUNCSW5mbywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdzZXRNZXNzYWdlQ0JJbmZvJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5zZXRNZXNzYWdlQ0JJbmZvLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2dldENvcnJlbGF0aW9uVGFnJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5nZXRDb3JyZWxhdGlvblRhZywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICd3cmFwRXZlbnRDYWxsYmFjaycsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUud3JhcEV2ZW50Q2FsbGJhY2ssICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb24ucHJvdG90eXBlLCAnd3JhcE1lc3NhZ2VDYWxsYmFjaycsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUud3JhcE1lc3NhZ2VDYWxsYmFjaywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbi5wcm90b3R5cGUsICdmb3JtYXRFcnJvckV2ZW50JywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5mb3JtYXRFcnJvckV2ZW50LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZSwgJ2Rpc2FibGVFbWl0dGVyJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uLnByb3RvdHlwZS5kaXNhYmxlRW1pdHRlciwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU2Vzc2lvbkV2ZW50XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTZXNzaW9uRXZlbnQnXSA9IHNvbGFjZS5TZXNzaW9uRXZlbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb25FdmVudC5wcm90b3R5cGUsICdoYXNPd25Qcm9wZXJ0eScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbkV2ZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvbkV2ZW50LnByb3RvdHlwZSwgJ3RvTG9jYWxlU3RyaW5nJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uRXZlbnQucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uRXZlbnQucHJvdG90eXBlLCAndmFsdWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbkV2ZW50LnByb3RvdHlwZS52YWx1ZU9mLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uRXZlbnQucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuU2Vzc2lvbkV2ZW50LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uRXZlbnQucHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb25FdmVudC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlNlc3Npb25FdmVudENCSW5mb1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnU2Vzc2lvbkV2ZW50Q0JJbmZvJ10gPSBzb2xhY2UuU2Vzc2lvbkV2ZW50Q0JJbmZvO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTZXNzaW9uRXZlbnRDb2RlJ10gPSBzb2xhY2UuU2Vzc2lvbkV2ZW50Q29kZTtcbnNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLl9zZXRDYW5vbmljYWwoe1wiVVBfTk9USUNFXCI6MCxcIkRPV05fRVJST1JcIjoxLFwiQ09OTkVDVF9GQUlMRURfRVJST1JcIjoyLFwiUkVKRUNURURfTUVTU0FHRV9FUlJPUlwiOjQsXCJTVUJTQ1JJUFRJT05fRVJST1JcIjo1LFwiU1VCU0NSSVBUSU9OX09LXCI6NixcIlZJUlRVQUxST1VURVJfTkFNRV9DSEFOR0VEXCI6NyxcIlJFUVVFU1RfQUJPUlRFRFwiOjgsXCJSRVFVRVNUX1RJTUVPVVRcIjo5LFwiUFJPUEVSVFlfVVBEQVRFX09LXCI6MTAsXCJQUk9QRVJUWV9VUERBVEVfRVJST1JcIjoxMSxcIkNBTl9BQ0NFUFRfREFUQVwiOjEzLFwiRElTQ09OTkVDVEVEXCI6MTQsXCJSRUNPTk5FQ1RJTkdfTk9USUNFXCI6MjIsXCJSRUNPTk5FQ1RFRF9OT1RJQ0VcIjoyMyxcIlJFUFVCTElTSElOR19VTkFDS0VEX01FU1NBR0VTXCI6MjQsXCJBQ0tOT1dMRURHRURfTUVTU0FHRVwiOjI1LFwiVU5TVUJTQ1JJQkVfVEVfVE9QSUNfT0tcIjoyNixcIlVOU1VCU0NSSUJFX1RFX1RPUElDX0VSUk9SXCI6MjcsXCJNRVNTQUdFXCI6MjgsXCJHVUFSQU5URUVEX01FU1NBR0VfUFVCTElTSEVSX0RPV05cIjoyOX0sIHRydWUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TZXNzaW9uRXZlbnRDb2RlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb25FdmVudENvZGUuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNlc3Npb25FdmVudENvZGUsICduYW1lT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb25FdmVudENvZGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5TZXNzaW9uUHJvcGVydGllc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnU2Vzc2lvblByb3BlcnRpZXMnXSA9IHNvbGFjZS5TZXNzaW9uUHJvcGVydGllcztcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU2Vzc2lvblN0YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTZXNzaW9uU3RhdGUnXSA9IHNvbGFjZS5TZXNzaW9uU3RhdGU7XG5zb2xhY2UuU2Vzc2lvblN0YXRlLl9zZXRDYW5vbmljYWwoe1wiQ09OTkVDVElOR1wiOjEsXCJDT05ORUNURURcIjoyLFwiU0VTU0lPTl9FUlJPUlwiOjMsXCJESVNDT05ORUNUSU5HXCI6NCxcIkRJU0NPTk5FQ1RFRFwiOjV9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvblN0YXRlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNlc3Npb25TdGF0ZS5kZXNjcmliZSwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU2Vzc2lvblN0YXRlLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5TZXNzaW9uU3RhdGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTb2xjbGllbnRGYWN0b3J5J10gPSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU29sY2xpZW50RmFjdG9yeSwgJ2hhc093blByb3BlcnR5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5Lmhhc093blByb3BlcnR5LCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LCAndG9Mb2NhbGVTdHJpbmcnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNvbGNsaWVudEZhY3RvcnkudG9Mb2NhbGVTdHJpbmcsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnksICd2YWx1ZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LnZhbHVlT2YsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnksICdpc1Byb3RvdHlwZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5LmlzUHJvdG90eXBlT2YsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnksICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuU29sY2xpZW50RmFjdG9yeS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMnXSA9IHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcywgJ2hhc093blByb3BlcnR5JywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMuaGFzT3duUHJvcGVydHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcywgJ3RvTG9jYWxlU3RyaW5nJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMudG9Mb2NhbGVTdHJpbmcsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcywgJ3ZhbHVlT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy52YWx1ZU9mLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMsICdpc1Byb3RvdHlwZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Tb2xjbGllbnRGYWN0b3J5UHJvZmlsZXMuaXNQcm90b3R5cGVPZiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb2ZpbGVzLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlNvbGNsaWVudEZhY3RvcnlQcm9maWxlcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1NvbGNsaWVudEZhY3RvcnlQcm9wZXJ0aWVzJ10gPSBzb2xhY2UuU29sY2xpZW50RmFjdG9yeVByb3BlcnRpZXM7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlN0YXRUeXBlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuc29sYWNlWydTdGF0VHlwZSddID0gc29sYWNlLlN0YXRUeXBlO1xuc29sYWNlLlN0YXRUeXBlLl9zZXRDYW5vbmljYWwoe1wiVFhfVE9UQUxfREFUQV9CWVRFU1wiOjAsXCJUWF9UT1RBTF9EQVRBX01TR1NcIjoxLFwiVFhfRElSRUNUX0JZVEVTXCI6MixcIlRYX0RJUkVDVF9NU0dTXCI6MyxcIlRYX0NPTlRST0xfQllURVNcIjo0LFwiVFhfQ09OVFJPTF9NU0dTXCI6NSxcIlRYX1JFUVVFU1RfU0VOVFwiOjYsXCJUWF9SRVFVRVNUX1RJTUVPVVRcIjo3LFwiUlhfVE9UQUxfREFUQV9CWVRFU1wiOjgsXCJSWF9UT1RBTF9EQVRBX01TR1NcIjo5LFwiUlhfRElSRUNUX0JZVEVTXCI6MTAsXCJSWF9ESVJFQ1RfTVNHU1wiOjExLFwiUlhfQ09OVFJPTF9CWVRFU1wiOjEyLFwiUlhfQ09OVFJPTF9NU0dTXCI6MTMsXCJSWF9ESVNDQVJEX01TR19JTkRJQ0FUSU9OXCI6MTQsXCJSWF9SRVBMWV9NU0dfUkVDVkVEXCI6MTUsXCJSWF9SRVBMWV9NU0dfRElTQ0FSRFwiOjE2LFwiUlhfRElTQ0FSRF9TTUZfVU5LTk9XTl9FTEVNRU5UXCI6MTcsXCJDQUNIRV9SRVFVRVNUX1NFTlRcIjoxOCxcIkNBQ0hFX1JFUVVFU1RfT0tfUkVTUE9OU0VcIjoxOSxcIkNBQ0hFX1JFUVVFU1RfRkFJTF9SRVNQT05TRVwiOjIwLFwiQ0FDSEVfUkVRVUVTVF9GVUxGSUxMX0RJU0NBUkRfUkVTUE9OU0VcIjoyMSxcIlJYX0NBQ0hFX01TR1wiOjIyLFwiQ0FDSEVfUkVRVUVTVF9JTkNPTVBMRVRFX1JFU1BPTlNFXCI6MjMsXCJDQUNIRV9SRVFVRVNUX0xJVkVfREFUQV9GVUxGSUxMXCI6MjQsXCJUWF9QRVJTSVNURU5UX0JZVEVTXCI6MjUsXCJUWF9QRVJTSVNURU5UX01TR1NcIjoyNixcIlRYX05PTlBFUlNJU1RFTlRfQllURVNcIjoyNyxcIlRYX05PTlBFUlNJU1RFTlRfTVNHU1wiOjI4LFwiVFhfUEVSU0lTVEVOVF9CWVRFU19SRURFTElWRVJFRFwiOjI5LFwiVFhfUEVSU0lTVEVOVF9SRURFTElWRVJFRFwiOjMwLFwiVFhfTk9OUEVSU0lTVEVOVF9CWVRFU19SRURFTElWRVJFRFwiOjMxLFwiVFhfTk9OUEVSU0lTVEVOVF9SRURFTElWRVJFRFwiOjMyLFwiVFhfQUNLU19SWEVEXCI6MzMsXCJUWF9XSU5ET1dfQ0xPU0VcIjozNCxcIlRYX0FDS19USU1FT1VUXCI6MzUsXCJSWF9QRVJTSVNURU5UX0JZVEVTXCI6MzYsXCJSWF9QRVJTSVNURU5UX01TR1NcIjozNyxcIlJYX05PTlBFUlNJU1RFTlRfQllURVNcIjozOCxcIlJYX05PTlBFUlNJU1RFTlRfTVNHU1wiOjM5LFwiUlhfQUNLRURcIjo0MCxcIlJYX0RJU0NBUkRfRFVQTElDQVRFXCI6NDEsXCJSWF9ESVNDQVJEX05PX01BVENISU5HX0NPTlNVTUVSXCI6NDIsXCJSWF9ESVNDQVJEX09VVF9PRl9PUkRFUlwiOjQzfSwgdHJ1ZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlN0YXRUeXBlLCAnZGVzY3JpYmUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlN0YXRUeXBlLmRlc2NyaWJlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5TdGF0VHlwZSwgJ25hbWVPZicsIHByb3BlcnR5U3BlYyhzb2xhY2UuU3RhdFR5cGUubmFtZU9mLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5Ub3BpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnNvbGFjZVsnVG9waWMnXSA9IHNvbGFjZS5Ub3BpYztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuVG9waWMsICdjcmVhdGVGcm9tTmFtZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuVG9waWMuY3JlYXRlRnJvbU5hbWUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlRvcGljLnByb3RvdHlwZSwgJ2dldFR5cGUnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlRvcGljLnByb3RvdHlwZS5nZXRUeXBlLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5Ub3BpYy5wcm90b3R5cGUsICdnZXRCeXRlcycsIHByb3BlcnR5U3BlYyhzb2xhY2UuVG9waWMucHJvdG90eXBlLmdldEJ5dGVzLCAnY3cnKSk7IC8vIEdEUFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5Ub3BpYy5wcm90b3R5cGUsICdnZXRPZmZzZXQnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlRvcGljLnByb3RvdHlwZS5nZXRPZmZzZXQsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlRvcGljLnByb3RvdHlwZSwgJ3ZhbGlkYXRlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5Ub3BpYy5wcm90b3R5cGUudmFsaWRhdGUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlRvcGljLnByb3RvdHlwZSwgJ2lzV2lsZGNhcmRlZCcsIHByb3BlcnR5U3BlYyhzb2xhY2UuVG9waWMucHJvdG90eXBlLmlzV2lsZGNhcmRlZCwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuVHJhbnNwb3J0RXJyb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1RyYW5zcG9ydEVycm9yJ10gPSBzb2xhY2UuVHJhbnNwb3J0RXJyb3I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlRyYW5zcG9ydEVycm9yLnByb3RvdHlwZSwgJ21lc3NhZ2UnLCBwcm9wZXJ0eVNwZWMoXCJcIiwgJ2N3JykpOyAvLyBHRFBcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzb2xhY2UuVHJhbnNwb3J0UHJvdG9jb2xcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1RyYW5zcG9ydFByb3RvY29sJ10gPSBzb2xhY2UuVHJhbnNwb3J0UHJvdG9jb2w7XG5zb2xhY2UuVHJhbnNwb3J0UHJvdG9jb2wuX3NldENhbm9uaWNhbCh7XCJIVFRQX0JBU0U2NFwiOlwiSFRUUF9CQVNFNjRcIixcIkhUVFBfQklOQVJZXCI6XCJIVFRQX0JJTkFSWVwiLFwiSFRUUF9CSU5BUllfU1RSRUFNSU5HXCI6XCJIVFRQX0JJTkFSWV9TVFJFQU1JTkdcIixcIldTX0JJTkFSWVwiOlwiV1NfQklOQVJZXCJ9LCB0cnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuVHJhbnNwb3J0UHJvdG9jb2wsICdkZXNjcmliZScsIHByb3BlcnR5U3BlYyhzb2xhY2UuVHJhbnNwb3J0UHJvdG9jb2wuZGVzY3JpYmUsICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlRyYW5zcG9ydFByb3RvY29sLCAnbmFtZU9mJywgcHJvcGVydHlTcGVjKHNvbGFjZS5UcmFuc3BvcnRQcm90b2NvbC5uYW1lT2YsICdjdycpKTsgLy8gR0RQXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc29sYWNlLlZlcnNpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ1ZlcnNpb24nXSA9IHNvbGFjZS5WZXJzaW9uO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNvbGFjZS5WZXJzaW9uLCAnaGFzT3duUHJvcGVydHknLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlZlcnNpb24uaGFzT3duUHJvcGVydHksICdjdycpKTsgLy8gR0RQXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc29sYWNlLlZlcnNpb24sICd0b0xvY2FsZVN0cmluZycsIHByb3BlcnR5U3BlYyhzb2xhY2UuVmVyc2lvbi50b0xvY2FsZVN0cmluZywgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuVmVyc2lvbiwgJ3ZhbHVlT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlZlcnNpb24udmFsdWVPZiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuVmVyc2lvbiwgJ2lzUHJvdG90eXBlT2YnLCBwcm9wZXJ0eVNwZWMoc29sYWNlLlZlcnNpb24uaXNQcm90b3R5cGVPZiwgJ2N3JykpOyAvLyBHRFBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb2xhY2UuVmVyc2lvbiwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgcHJvcGVydHlTcGVjKHNvbGFjZS5WZXJzaW9uLnByb3BlcnR5SXNFbnVtZXJhYmxlLCAnY3cnKSk7IC8vIEdEUFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNvbGFjZS5tYWtlSXRlcmF0b3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5zb2xhY2VbJ21ha2VJdGVyYXRvciddID0gc29sYWNlLm1ha2VJdGVyYXRvcjtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzb2xhY2U7XG59IGNhdGNoIChlKSB7XG4gIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYnVmZmVyXCJcbi8vIG1vZHVsZSBpZCA9IDI2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb25zdGFudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb25zdGFudHNcIlxuLy8gbW9kdWxlIGlkID0gMjY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L2FycmF5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29yZS1qcy9lczYvYXJyYXlcIlxuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L2RhdGVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9kYXRlXCJcbi8vIG1vZHVsZSBpZCA9IDI2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2VzNi9mdW5jdGlvblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImNvcmUtanMvZXM2L2Z1bmN0aW9uXCJcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2VzNi9tYXBcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9tYXBcIlxuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L21hdGhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9tYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2VzNi9udW1iZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9udW1iZXJcIlxuLy8gbW9kdWxlIGlkID0gMjczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L29iamVjdFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImNvcmUtanMvZXM2L29iamVjdFwiXG4vLyBtb2R1bGUgaWQgPSAyNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9lczYvcGFyc2UtZmxvYXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9wYXJzZS1mbG9hdFwiXG4vLyBtb2R1bGUgaWQgPSAyNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9lczYvcGFyc2UtaW50XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29yZS1qcy9lczYvcGFyc2UtaW50XCJcbi8vIG1vZHVsZSBpZCA9IDI3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2VzNi9yZWdleHBcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9yZWdleHBcIlxuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L3NldFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImNvcmUtanMvZXM2L3NldFwiXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9lczYvc3RyaW5nXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29yZS1qcy9lczYvc3RyaW5nXCJcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2VzNi9zeW1ib2xcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2VzNi9zeW1ib2xcIlxuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZXM2L3R5cGVkXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29yZS1qcy9lczYvdHlwZWRcIlxuLy8gbW9kdWxlIGlkID0gMjgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvZm4vYXJyYXkvaW5jbHVkZXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb3JlLWpzL2ZuL2FycmF5L2luY2x1ZGVzXCJcbi8vIG1vZHVsZSBpZCA9IDI4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzL2ZuL3NldC9mcm9tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29yZS1qcy9mbi9zZXQvZnJvbVwiXG4vLyBtb2R1bGUgaWQgPSAyODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZG5zXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZG5zXCJcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJldmVudHNcIlxuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gMjg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5ldFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIm5ldFwiXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvc1wiXG4vLyBtb2R1bGUgaWQgPSAyODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidGxzXCJcbi8vIG1vZHVsZSBpZCA9IDI5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1cmxcIlxuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIndzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid3NcIlxuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=