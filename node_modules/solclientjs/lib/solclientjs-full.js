/**
 * @license
 * ==============================================================================
 *   Solace Corporation
 *   SOLACE CORPORATION MESSAGING API FOR JAVASCRIPT
 *   SolclientJS
 * ==============================================================================
 * Copyright 2009-2018 Solace Corporation. All rights reserved.
 *
 * This software is proprietary software of Solace Corporation and intended only
 * for use in conjunction with one or more Solace Message Routers.  By using this
 * software, you are agreeing to the license terms and conditions located at
 * https://solace.com/license-software.
 */

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 265);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(165);
var ArrayOperations = ref.ArrayOperations;
var ref$1 = __webpack_require__(166);
var assert = ref$1.assert;
var ref$2 = __webpack_require__(167);
var BidiMap = ref$2.BidiMap;
var ref$3 = __webpack_require__(168);
var Enum = ref$3.Enum;
var ref$4 = __webpack_require__(169);
var Iterator = ref$4.Iterator;
var ref$5 = __webpack_require__(90);
var Lazy = ref$5.Lazy;
var ref$6 = __webpack_require__(170);
var makeMap = ref$6.makeMap;
var ref$7 = __webpack_require__(171);
var Mixin = ref$7.Mixin;
var ref$8 = __webpack_require__(172);
var Resolver = ref$8.Resolver;
var ref$9 = __webpack_require__(173);
var SetOperations = ref$9.SetOperations;

module.exports.assert = assert;
module.exports.ArrayOperations = ArrayOperations;
module.exports.BidiMap = BidiMap;
module.exports.Enum = Enum;
module.exports.Iterator = Iterator;
module.exports.Lazy = Lazy;
module.exports.makeIterator = Iterator.makeIterator;
module.exports.makeMap = makeMap;
module.exports.Mixin = Mixin;
module.exports.mixin = Mixin.mixin;
module.exports.Resolver = Resolver;
module.exports.resolve = Resolver.resolve;
module.exports.SetOperations = SetOperations;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(182);
var ConsoleLogImpl = ref.ConsoleLogImpl;
var ref$1 = __webpack_require__(183);
var GlobalBinding = ref$1.GlobalBinding;
var ref$2 = __webpack_require__(97);
var LogImpl = ref$2.LogImpl;
var ref$3 = __webpack_require__(98);
var LogLevel = ref$3.LogLevel;

var ref$4 = __webpack_require__(7);
var Parameter = ref$4.Parameter;
var ref$5 = __webpack_require__(9);
var SolclientFactory = ref$5.SolclientFactory;

var isEnumMember = Parameter.isEnumMember;
var isFunction = Parameter.isFunction;

var getImpl = GlobalBinding.getImpl;
var getLogLevel = GlobalBinding.getLogLevel;
var setImpl = GlobalBinding.setImpl;
var setLogLevel = GlobalBinding.setLogLevel;

var forwarder = {};
function buildLogForwarder() {
  Object.assign(forwarder, {
    trace: function trace() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.trace && getLogLevel() >= LogLevel.TRACE) {
        impl.trace.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    debug: function debug() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.debug && getLogLevel() >= LogLevel.DEBUG) {
        impl.debug.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    info: function info() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.info && getLogLevel() >= LogLevel.INFO) {
        impl.info.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    warn: function warn() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.warn && getLogLevel() >= LogLevel.WARN) {
        impl.warn.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    error: function error() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.error && getLogLevel() >= LogLevel.ERROR) {
        impl.error.apply(null, ['solclientjs: ' ].concat( args));
      }
    },

    fatal: function fatal() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var impl = getImpl();
      if (impl && impl.fatal) {
        impl.fatal.apply(null, ['solclientjs: ' ].concat( args));
      }
    },
  });
}
buildLogForwarder(); // stripped by production build

function addGlobalFuncs(source, target) {
  Object.keys(forwarder).forEach(function (k) {
    target[("LOG_" + (k.toUpperCase()))] = source[k];
  });
}

var LogFormatter = function LogFormatter(formatter) {
  var this$1 = this;

  this._formatter = (function () {
    if (typeof formatter === 'function') { return formatter; }
    if (typeof formatter === 'string') { return function prepend() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 return [formatter ].concat( args); }; }
    if (!formatter) { return function passthrough() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 return [].concat( args ); }; }
    return formatter;
  })();
  var self = this;
  Object.keys(forwarder).forEach(function (key) {
    this$1[key] = function forward() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return forwarder[key].apply(null, self._formatter.apply(self, args));
    };
  });
  addGlobalFuncs(this, this);
};

var prototypeAccessors = { formatter: {} };

prototypeAccessors.formatter.get = function () {
  return this._formatter;
};
prototypeAccessors.formatter.set = function (func) {
  this._formatter = func;
};

LogFormatter.prototype.wrap = function wrap (genericFunction, targetSelf) {
  var self = this;
  return function genericLogWrapper() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

    return genericFunction.apply(targetSelf, self._formatter.apply(self, args));
  };
};

Object.defineProperties( LogFormatter.prototype, prototypeAccessors );

/**
 * Gets the current log level, which was set by {@link solace.SolclientFactory.init} or a
 * subsequent call to {@link solace.SolclientFactory.setLogLevel}.
 *
 * @returns {solace.LogLevel} The current log level.
 */
SolclientFactory.getLogLevel = function () { return getLogLevel(); };

  /**
   * This method changes the current log level from the level set when
   * {@link solace.SolclientFactory.init} was called.
   *
   * @param {solace.LogLevel} newLevel The new log level to set.
   * @throws {solace.OperationError} Invalid log level
   */
SolclientFactory.setLogLevel = function (newLevel) {
  isEnumMember('logLevel', newLevel, LogLevel);
  setLogLevel(newLevel);
};

SolclientFactory.addInitializer(function (props) {
  setLogLevel(props.logLevel);

  var logger = props.logger || getImpl() || new ConsoleLogImpl();
  // Validate that the supplied log implementation is a superset of LogImpl
  Object.keys(new LogImpl()).forEach(function (key) { return isFunction(("logger." + key), logger[key]); });

  setImpl(logger);
});

addGlobalFuncs(forwarder, module.exports);
module.exports.LogImpl = LogImpl;
module.exports.LogLevel = LogLevel;
module.exports.Binding = GlobalBinding;
module.exports.ConsoleLogImpl = ConsoleLogImpl;
GlobalBinding.setImpl(new ConsoleLogImpl());
module.exports.LogFormatter = LogFormatter;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(162);
var ErrorResponseSubcodeMapper = ref.ErrorResponseSubcodeMapper;
var ref$1 = __webpack_require__(51);
var ErrorSubcode = ref$1.ErrorSubcode;
var ref$2 = __webpack_require__(163);
var NotImplementedError = ref$2.NotImplementedError;
var ref$3 = __webpack_require__(88);
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(164);
var RequestError = ref$4.RequestError;
var ref$5 = __webpack_require__(89);
var RequestEventCode = ref$5.RequestEventCode;
var ref$6 = __webpack_require__(52);
var SolaceError = ref$6.SolaceError;

module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
module.exports.ErrorSubcode = ErrorSubcode;
module.exports.NotImplementedError = NotImplementedError;
module.exports.OperationError = OperationError;
module.exports.RequestError = RequestError;
module.exports.RequestEventCode = RequestEventCode;
module.exports.SolaceError = SolaceError;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(152);
var Base64 = ref.Base64;
var ref$1 = __webpack_require__(153);
var Bits = ref$1.Bits;
var ref$2 = __webpack_require__(154);
var Convert = ref$2.Convert;
var ref$3 = __webpack_require__(155);
var Hex = ref$3.Hex;
var ref$4 = __webpack_require__(156);
var Long = ref$4.Long;

module.exports.Base64 = Base64;
module.exports.Bits = Bits;
module.exports.Convert = Convert;
module.exports.Hex = Hex;
module.exports.Long = Long;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(255);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(254);
var APIPropertiesValidators = ref$1.APIPropertiesValidators;
var ref$2 = __webpack_require__(256);
var ArrayUtils = ref$2.ArrayUtils;
var ref$3 = __webpack_require__(260);
var parseURL = ref$3.parseURL;
var ref$4 = __webpack_require__(257);
var Process = ref$4.Process;
var ref$5 = __webpack_require__(147);
var StringBuffer = ref$5.StringBuffer;
var ref$6 = __webpack_require__(258);
var StringUtils = ref$6.StringUtils;
var ref$7 = __webpack_require__(259);
var TimingBucket = ref$7.TimingBucket;
var ref$8 = __webpack_require__(261);
var UUID = ref$8.UUID;
var ref$9 = __webpack_require__(262);
var Version = ref$9.Version;

module.exports = {
  parseURL: parseURL,

  APIProperties: APIProperties,
  APIPropertiesValidators: APIPropertiesValidators,
  ArrayUtils: ArrayUtils,
  Process: Process,
  StringBuffer: StringBuffer,
  StringUtils: StringUtils,
  TimingBucket: TimingBucket,
  UUID: UUID,
  Version: Version,
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(50);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(160);
var DestinationFromNetwork = ref$1.DestinationFromNetwork;
var ref$2 = __webpack_require__(25);
var DestinationType = ref$2.DestinationType;
var ref$3 = __webpack_require__(26);
var DestinationUtil = ref$3.DestinationUtil;
var ref$4 = __webpack_require__(7);
var Parameter = ref$4.Parameter;
var ref$5 = __webpack_require__(86);
var Queue = ref$5.Queue;
var ref$6 = __webpack_require__(9);
var SolclientFactory = ref$6.SolclientFactory;
var ref$7 = __webpack_require__(87);
var Topic = ref$7.Topic;


/**
 * Creates a topic {@link solace.Destination} instance. When the returned Destination is set as
 * the destination of a message via {@link solace.Message#setDestination}, the message will be
 * delivered to direct subscribers or topic endpoints subscribed to the given topic.
 *
 * @param {String} topicName The topic string for the new topic.
 * @returns {solace.Destination} The newly created topic destination.
 * @method
 * @name solace.SolclientFactory.createTopicDestination
 */
SolclientFactory.createTopicDestination = SolclientFactory.createFactory(function (topicName) {
  Parameter.isString('topicName', topicName);
  return Topic.createFromName(topicName);
});
/* @deprecated @*/
SolclientFactory.createTopic = SolclientFactory.createFactory(function (topicName) { return new Topic(topicName); });

/**
 * Creates a durable queue {@link solace.Destination} instance. When the returned Destination is
 * set as the destination of a message via {@link solace.Message#setDestination}, the message will
 * be delivered to the Guaranteed Message queue on the Solace Message Router of the same name.
 *
 * @since 10.0.0
 * @param {String} queueName The queueName of the queue
 * @returns {solace.Destination} The newly created queue destination.
 * @method
 * @name solace.SolclientFactory.createDurableQueueDestination
 */
SolclientFactory.createDurableQueueDestination = SolclientFactory.createFactory(function (queueName) {
  Parameter.isString('queueName', queueName);
  return Queue.createFromLocalName(queueName);
});

module.exports.Destination = Destination;
module.exports.DestinationFromNetwork = DestinationFromNetwork;
module.exports.DestinationType = DestinationType;
module.exports.DestinationUtil = DestinationUtil;
module.exports.Queue = Queue;
module.exports.Topic = Topic;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(148);
var Check = ref.Check;
var ref$1 = __webpack_require__(264);
var Parameter = ref$1.Parameter;

module.exports.Check = Check;
module.exports.Parameter = Parameter;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var CodecLib = __webpack_require__(220);
var ref = __webpack_require__(13);
var AdProtocolMessage = ref.AdProtocolMessage;
var BinaryMetaBlock = ref.BinaryMetaBlock;
var ClientCtrlMessage = ref.ClientCtrlMessage;
var KeepAliveMessage = ref.KeepAliveMessage;
var SMPMessage = ref.SMPMessage;
var ref$1 = __webpack_require__(126);
var SMFAdProtocolMessageType = ref$1.SMFAdProtocolMessageType;
var ref$2 = __webpack_require__(127);
var SMFAdProtocolParam = ref$2.SMFAdProtocolParam;
var ref$3 = __webpack_require__(128);
var SMFClientCtrlMessageType = ref$3.SMFClientCtrlMessageType;
var ref$4 = __webpack_require__(129);
var SMFClientCtrlParam = ref$4.SMFClientCtrlParam;
var ref$5 = __webpack_require__(78);
var SMFParameterType = ref$5.SMFParameterType;
var ref$6 = __webpack_require__(22);
var SMFProtocol = ref$6.SMFProtocol;
var ref$7 = __webpack_require__(79);
var SMFSMPMessageType = ref$7.SMFSMPMessageType;
var ref$8 = __webpack_require__(130);
var SMFSMPMessageTypeFlags = ref$8.SMFSMPMessageTypeFlags;
var ref$9 = __webpack_require__(131);
var SMFTransportSessionMessageType = ref$9.SMFTransportSessionMessageType;

module.exports.AdProtocolMessage = AdProtocolMessage;
module.exports.BinaryMetaBlock = BinaryMetaBlock;
module.exports.ClientCtrlMessage = ClientCtrlMessage;
module.exports.Codec = CodecLib;
module.exports.KeepAliveMessage = KeepAliveMessage;
module.exports.SMFAdProtocolMessageType = SMFAdProtocolMessageType;
module.exports.SMFAdProtocolParam = SMFAdProtocolParam;
module.exports.SMFClientCtrlMessageType = SMFClientCtrlMessageType;
module.exports.SMFClientCtrlParam = SMFClientCtrlParam;
module.exports.SMFParameterType = SMFParameterType;
module.exports.SMFProtocol = SMFProtocol;
module.exports.SMFSMPMessageTypeFlags = SMFSMPMessageTypeFlags;
module.exports.SMFSMPMessageType = SMFSMPMessageType;
module.exports.SMFTransportSessionMessageType = SMFTransportSessionMessageType;
module.exports.SMPMessage = SMPMessage;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(92);
var FactoryProfile = ref.FactoryProfile;
var SolclientFactoryProfiles = ref.SolclientFactoryProfiles;
var ref$1 = __webpack_require__(91);
var ProfileBinding = ref$1.ProfileBinding;
var ref$2 = __webpack_require__(176);
var SolclientFactory = ref$2.SolclientFactory;
var ref$3 = __webpack_require__(93);
var SolclientFactoryProperties = ref$3.SolclientFactoryProperties;

module.exports.FactoryProfile = FactoryProfile;
module.exports.ProfileBinding = ProfileBinding;
module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
module.exports.SolclientFactory = SolclientFactory;



/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(200);
var Codec = ref.Codec;
var ref$1 = __webpack_require__(70);
var SDTDestType = ref$1.SDTDestType;
var ref$2 = __webpack_require__(12);
var SDTField = ref$2.SDTField;
var ref$3 = __webpack_require__(11);
var SDTFieldType = ref$3.SDTFieldType;
var ref$4 = __webpack_require__(41);
var SDTMapContainer = ref$4.SDTMapContainer;
var ref$5 = __webpack_require__(42);
var SDTStreamContainer = ref$5.SDTStreamContainer;
var ref$6 = __webpack_require__(109);
var SDTUnsupportedValueError = ref$6.SDTUnsupportedValueError;
var ref$7 = __webpack_require__(110);
var SDTValueErrorSubcode = ref$7.SDTValueErrorSubcode;

module.exports.Codec = Codec;
module.exports.SDTDestType = SDTDestType;
module.exports.SDTField = SDTField;
module.exports.SDTFieldType = SDTFieldType;
module.exports.SDTMapContainer = SDTMapContainer;
module.exports.SDTStreamContainer = SDTStreamContainer;
module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
module.exports.SDTValueErrorSubcode = SDTValueErrorSubcode;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SDTFieldType = {
  /**
   * @type {Number}
   * @description Maps to a boolean.
   */
  BOOL:        0,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT8:       1,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  INT8:        2,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT16:      3,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  INT16:       4,
  /**
   * @type {Number}
   * @description Maps to a number.
   */
  UINT32:      5,
  /**
   *@type {Number}
   * @description Maps to a number.
   */
  INT32:       6,
  /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers (range: 0 to 2<sup>48</sup>-1).
   * When decoding, only the lower 48 bits are considered significant.
   */
  UINT64:      7,
  /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers + sign (range: -(2<sup>48</sup>-1) to
   * 2<sup>48</sup>-1). When decoding, only the lower 48 bits are considered significant.
   */
  INT64:       8,
  /**
   * @type {Number}
   * @description A single character; maps to a string.
   */
  WCHAR:       9,
  /**
   * @type {Number}
   * @description Maps to a string.
   */
  STRING:      10,
  /**
   * @type {Number}
   * @description Maps to a string (string representation of a byte array).
   */
  BYTEARRAY:   11,
  /**
   * @type {Number}
   * @description Single-precision float; maps to a number.
   */
  FLOATTYPE:   12,
  /**
   * @type {Number}
   * @description Double-precision float; maps to a number.
   */
  DOUBLETYPE:  13,
  /**
   * @type {Number}
   * @description Maps to {@link SDTMapContainer}.
   */
  MAP:         14,
  /**
   * @type {Number}
   * @description Maps to {@link SDTStreamContainer}.
   */
  STREAM:      15,
  /**
   * @type {Number}
   * @description Maps to {@link Destination}.
   */
  DESTINATION: 16,
  /**
   * @type {Number}
   * @description Maps to <code>null</code>.
   */
  NULLTYPE:    17,
  /**
   * @type {Number}
   * @description Maps to an unknown type.
   */
  UNKNOWN:     18,
  /**
   * @type {Number}
   * @description Maps to an encoded SMF message.
   */
  SMF_MESSAGE: 19,
};

module.exports.SDTFieldType = Enum.new(SDTFieldType);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(11);
var SDTFieldType = ref.SDTFieldType;
var ref$1 = __webpack_require__(208);
var validateSdtField = ref$1.validateSdtField;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT (Structured Data Type) field. To create an instance of an <code>SDTField</code>,
 * call {@link solace.SDTField.create}.
 *
 * SDTField objects are used in Solace Containers ({@link solace.SDTMapContainer}
 * and {@link solace.SDTStreamContainer}). The <b>deprecated</b> usage of
 * {@link solace.SDTMapContainer#addField} and {@link solace.SDTStreamContainer#addField}
 * take a SDTField object as an argument. The preferred usage is to pass a
 * {@link solace.SDTFieldType} and value as arguments.
 *
 * SDTField objectts must be used as an argument to {@link solace.Message#setSdtContainer}.
 * The only valid SDTField objects for {@link solace.Message#setSdtContainer} are:
 * * {@link solace.SDTFieldType.STREAM}
 * * {@link solace.SDTFieldType.MAP}
 * * {@link solace.SDTFieldType.STRING}
 * @memberof solace
 */
var SDTField = function SDTField(type, value) {
  if ( type === void 0 ) type = SDTFieldType.NULLTYPE;
  if ( value === void 0 ) value = null;

  var err = validateSdtField(type, value);
  if (err !== null) {
    throw (err);
  }
  this._type = type;
  this._value = value;
  this._error = undefined;
};

/**
 * Gets the type of field represented.
 * @returns {solace.SDTFieldType} The type of field represented.
 */
SDTField.prototype.getType = function getType () {
  return this._type;
};

/**
 * Gets the field value.
 * @returns {*} Field value (as one of the supported data types).
 * @throws {solace.SDTUnsupportedValueError} if value found in the field
 * is not in range supported by the platform/runtime.
 */
SDTField.prototype.getValue = function getValue () {
  if (this._error !== undefined) {
    throw (this._error);
  }
  return this._value;
};

/**
 * Sets an error on the object to be thrown on getValue().
 * Used only by parse-integer, as it is possible to receive
 * 64 bit integers that cannot be represented in a javaScript number.
 * JavaScript numbers are floats and can only hold a 48 bit integer.
 * @private
 * @param {solace.SDTUnsupportedValueError} err error object.
 */
SDTField.prototype.setError = function setError (err) {
  this._error = err;
};

SDTField.prototype.toString = function toString () {
  return ("[SDTField type:" + (this._type) + " value:" + (this._value) + "]");
};

/**
 * Create a new SDTField instance representing a Value of a given Type.
 *
 * @param {solace.SDTFieldType} type The type of field represented.
 * @param {*} value The corresponding value to store in the field.
 * @returns {solace.SDTField} The new SDT field with the given type and value
 * @throws {solace.OperationError} if value does not match type
 * @static
 */
SDTField.create = function create (type, value) {
  return new SDTField(type, value);
};

module.exports.SDTField = SDTField;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(223);
var AdProtocolMessage = ref.AdProtocolMessage;
var ref$1 = __webpack_require__(224);
var BinaryMetaBlock = ref$1.BinaryMetaBlock;
var ref$2 = __webpack_require__(225);
var ClientCtrlMessage = ref$2.ClientCtrlMessage;
var ref$3 = __webpack_require__(226);
var KeepAliveMessage = ref$3.KeepAliveMessage;
var ref$4 = __webpack_require__(32);
var SMFHeader = ref$4.SMFHeader;
var ref$5 = __webpack_require__(77);
var SMFParameter = ref$5.SMFParameter;
var ref$6 = __webpack_require__(125);
var SMFUH = ref$6.SMFUH;
var ref$7 = __webpack_require__(227);
var SMPMessage = ref$7.SMPMessage;
var ref$8 = __webpack_require__(228);
var TransportSMFMessage = ref$8.TransportSMFMessage;

module.exports.AdProtocolMessage = AdProtocolMessage;
module.exports.BinaryMetaBlock = BinaryMetaBlock;
module.exports.ClientCtrlMessage = ClientCtrlMessage;
module.exports.KeepAliveMessage = KeepAliveMessage;
module.exports.SMFHeader = SMFHeader;
module.exports.SMFParameter = SMFParameter;
module.exports.SMFUH = SMFUH;
module.exports.SMPMessage = SMPMessage;
module.exports.TransportSMFMessage = TransportSMFMessage;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(159);
var Debug = ref.Debug;

module.exports.Debug = Debug;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module solace/fsm
 */

var ref = __webpack_require__(179);
var FsmEvent = ref.FsmEvent;
var ref$1 = __webpack_require__(27);
var State = ref$1.State;
var ref$2 = __webpack_require__(181);
var StateMachine = ref$2.StateMachine;

module.exports.FsmEvent = FsmEvent;
module.exports.State = State;
module.exports.StateMachine = StateMachine;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(196);
var Message = ref.Message;
var ref$1 = __webpack_require__(58);
var MessageCacheStatus = ref$1.MessageCacheStatus;
var ref$2 = __webpack_require__(59);
var MessageDeliveryModeType = ref$2.MessageDeliveryModeType;
var ref$3 = __webpack_require__(40);
var MessageDumpFlag = ref$3.MessageDumpFlag;
var ref$4 = __webpack_require__(103);
var MessageDumpStandardProvider = ref$4.MessageDumpStandardProvider;
var ref$5 = __webpack_require__(60);
var MessageDumpUtil = ref$5.MessageDumpUtil;
var ref$6 = __webpack_require__(104);
var MessageType = ref$6.MessageType;
var ref$7 = __webpack_require__(61);
var MessageUserCosType = ref$7.MessageUserCosType;

var ref$8 = __webpack_require__(9);
var SolclientFactory = ref$8.SolclientFactory;

/**
 * Creates a {@link solace.Message} instance.
 * @returns {solace.Message} a new message instance.
 * @method
 * @name solace.SolclientFactory.createMessage
 */
SolclientFactory.createMessage = SolclientFactory.createFactory(function () { return new Message(); });

module.exports.Message = Message;
module.exports.MessageCacheStatus = MessageCacheStatus;
module.exports.MessageDeliveryModeType = MessageDeliveryModeType;
module.exports.MessageDumpFlag = MessageDumpFlag;
module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
module.exports.MessageDumpUtil = MessageDumpUtil;
module.exports.MessageType = MessageType;
module.exports.MessageUserCosType = MessageUserCosType;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var TransportReturnCode = {
  OK:                          0,
  FAIL:                        1,
  NO_SPACE:                    2,
  DATA_DECODE_ERROR:           3,
  INVALID_STATE_FOR_OPERATION: 4,
  CONNECTION_ERROR:            5,
};

module.exports.TransportReturnCode = Enum.new(TransportReturnCode);

/* eslint-disable */
// Manually demangle these names; bug 70031
module.exports.TransportReturnCode._setCanonical({
  'OK':                          TransportReturnCode.OK,
  'FAIL':                        TransportReturnCode.FAIL,
  'NO_SPACE':                    TransportReturnCode.NO_SPACE,
  'DATA_DECODE_ERROR':           TransportReturnCode.DATA_DECODE_ERROR,
  'INVALID_STATE_FOR_OPERATION': TransportReturnCode.INVALID_STATE_FOR_OPERATION,
  'CONNECTION_ERRROR':           TransportReturnCode.CONNECTION_ERROR
});
/* eslint-enable */


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(105);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var ref$1 = __webpack_require__(62);
var QueueAccessType = ref$1.QueueAccessType;
var ref$2 = __webpack_require__(106);
var QueueDescriptor = ref$2.QueueDescriptor;
var ref$3 = __webpack_require__(197);
var QueueDescriptorValidator = ref$3.QueueDescriptorValidator;
var ref$4 = __webpack_require__(63);
var QueueDiscardBehavior = ref$4.QueueDiscardBehavior;
var ref$5 = __webpack_require__(64);
var QueuePermissions = ref$5.QueuePermissions;
var ref$6 = __webpack_require__(199);
var QueueProperties = ref$6.QueueProperties;
var ref$7 = __webpack_require__(198);
var QueuePropertiesValidator = ref$7.QueuePropertiesValidator;
var ref$8 = __webpack_require__(65);
var QueueType = ref$8.QueueType;

module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
module.exports.QueueAccessType = QueueAccessType;
module.exports.QueueDescriptor = QueueDescriptor;
module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
module.exports.QueueDiscardBehavior = QueueDiscardBehavior;
module.exports.QueuePermissions = QueuePermissions;
module.exports.QueueProperties = QueueProperties;
module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
module.exports.QueueType = QueueType;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(235);
var Stats = ref.Stats;
var ref$1 = __webpack_require__(234);
var StatsByMode = ref$1.StatsByMode;
var ref$2 = __webpack_require__(82);
var StatType = ref$2.StatType;

module.exports = {
  Stats: Stats,
  StatType: StatType,
  StatsByMode: StatsByMode,
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Connection scheme types referenced by {@link solace.SessionProperties#transportProtocol},
 * {@link solace.SessionProperties#webTransportProtocolList} (browser only), and
 * {@link solace.SessionProperties#transportProtocolInUse}.
 *
 * @target browser
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var TransportProtocol = {

  /**
   * A COMET model that uses base64 payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BASE64: 'HTTP_BASE64',

  /**
   * A COMET model that uses binary payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BINARY: 'HTTP_BINARY',

  /**
   * A COMET model that uses binary payload encoding. HTTP responses use Chunked Transfer-Encoding
   * to stream data from the Solace Message Router to the client without needing to terminate the
   * HTTP response.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
  HTTP_BINARY_STREAMING: 'HTTP_BINARY_STREAMING',

  /**
   * A WebSocket communication channel uses binary payload encoding and provides full-duplex
   * communication between the client and the Solace Message Router over a single TCP connection.
   *
   * This is the preferred protocol to use if all networking infrastructure betweed the application
   * and the Solace Message router support WebSockets. If this is not the case, it may be necessary
   * to use one of the HTTP protocols that use the COMET model of messaging.
   *
   * This transport protocol supports Guaranteed Messaging.
   */
  WS_BINARY: 'WS_BINARY',

};

module.exports.TransportProtocol = Enum.new(TransportProtocol);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(71);
var AuthenticationScheme = ref.AuthenticationScheme;
var ref$1 = __webpack_require__(43);
var CapabilityType = ref$1.CapabilityType;
var ref$2 = __webpack_require__(111);
var MessageRxCBInfo = ref$2.MessageRxCBInfo;
var ref$3 = __webpack_require__(112);
var MutableSessionProperty = ref$3.MutableSessionProperty;
var ref$4 = __webpack_require__(218);
var Session = ref$4.Session;
var ref$5 = __webpack_require__(73);
var SessionEvent = ref$5.SessionEvent;
var ref$6 = __webpack_require__(114);
var SessionEventCBInfo = ref$6.SessionEventCBInfo;
var ref$7 = __webpack_require__(44);
var SessionEventCode = ref$7.SessionEventCode;
var ref$8 = __webpack_require__(72);
var SessionEventName = ref$8.SessionEventName;
var ref$9 = __webpack_require__(74);
var SessionProperties = ref$9.SessionProperties;
var ref$10 = __webpack_require__(117);
var SessionState = ref$10.SessionState;

var ref$11 = __webpack_require__(9);
var SolclientFactory = ref$11.SolclientFactory;

/**
 * Creates a session instance.
 * @param {solace.SessionProperties} sessionProperties Properties to configure the session.
 * @param {solace.MessageRxCBInfo} [messageCallbackInfo] <b>Deprecated:</b>
 *    Callback method for messages.  Instead applications should receive message events via
 *    `session.on(solace.SessionEventCode.MESSAGE, (message) => { ... });`
 * @param {solace.SessionEventCBInfo} [eventCallbackInfo] <b>Deprecated:</b> Callback method for
 *    events on the <i>Session</i>. Instaead applications should receive session events via
 *    `session.on(solace.SessionEventCode.<code>, (event) => { ... });`
 * @returns {solace.Session} The newly-created session.
 * @throws {solace.OperationError} if the parameters have an invalid type or value.
 *                          Subcode: {@link ErrorSubcode.PARAMETER_INVALID_TYPE}.
 * @method
 * @name solace.SolclientFactory.createSession
 */
SolclientFactory.createSession = SolclientFactory.createFactory(
  function (sessionProperties, messageCallbackInfo, eventCallbackInfo) { return new Session(sessionProperties, messageCallbackInfo, eventCallbackInfo); });

module.exports.AuthenticationScheme = AuthenticationScheme;
module.exports.CapabilityType = CapabilityType;
module.exports.MessageRxCBInfo = MessageRxCBInfo;
module.exports.MutableSessionProperty = MutableSessionProperty;
module.exports.Session = Session;
module.exports.SessionEventCBInfo = SessionEventCBInfo;
module.exports.SessionEventCode = SessionEventCode;
module.exports.SessionEvent = SessionEvent;
module.exports.SessionEventName = SessionEventName;
module.exports.SessionProperties = SessionProperties;
module.exports.SessionState = SessionState;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * SMFProtocol
 * @private
 * @enum {number}
 */
var SMFProtocol = {
  CSPF:               0x01,
  CSMP:               0x02,
  PUBMSG:             0x03,
  XMLLINK:            0x04,
  WSE:                0x05,
  SEMP:               0x06,
  SUBCTRL:            0x07,
  PUBCTRL:            0x08,
  ADCTRL:             0x09,
  KEEPALIVE:          0x0a,
  KEEPALIVEV2:        0x0b,
  CLIENTCTRL:         0x0c,
  TRMSG:              0x0d,
  JNDI:               0x0e,
  SMP:                0x0f,
  SMRP:               0x10,
  SMF_IN_SMF:         0x11,
  SMF_IN_RV:          0x12,
  ADCTRL_PASSTHROUGH: 0x13,
  TSESSION:           0x14,

};

module.exports.SMFProtocol = Enum.new(SMFProtocol);


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(140);
var SMFClient = ref.SMFClient;
var ref$1 = __webpack_require__(241);
var TransportCapabilities = ref$1.TransportCapabilities;
var ref$2 = __webpack_require__(33);
var TransportError = ref$2.TransportError;
var ref$3 = __webpack_require__(242);
var TransportFactory = ref$3.TransportFactory;
var ref$4 = __webpack_require__(20);
var TransportProtocol = ref$4.TransportProtocol;
var ref$5 = __webpack_require__(17);
var TransportReturnCode = ref$5.TransportReturnCode;
var ref$6 = __webpack_require__(24);
var TransportSessionEventCode = ref$6.TransportSessionEventCode;
var ref$7 = __webpack_require__(34);
var TransportSessionStates = ref$7.TransportSessionStates;


module.exports.SMFClient = SMFClient;
module.exports.TransportCapabilities = TransportCapabilities;
module.exports.TransportError = TransportError;
module.exports.TransportFactory = TransportFactory;
module.exports.TransportProtocol = TransportProtocol;
module.exports.TransportReturnCode = TransportReturnCode;
module.exports.TransportSessionEventCode = TransportSessionEventCode;
module.exports.TransportSessionStates = TransportSessionStates;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Defines the possible TransportSessionEvent codes.
 * @private
 * @enum {number}
 */
var TransportSessionEventCode = {
  // Raised when TransportSession is up and ready to send/receive data
  UP_NOTICE:           1,
  // Raised if the session is destroyed
  DESTROYED_NOTICE:    2,
  // Raised when the send queue had reached its maximum, but now has space again
  CAN_ACCEPT_DATA:     4,
  // Raised when there is a decode error on received data.  The app should destroy the session
  DATA_DECODE_ERROR:   5,
  // Raised when there is a decode error on received data.  The app should destroy the session
  PARSE_FAILURE:       6,
  // Raised when the connection times out. The app should attempt downgrade if available.
  CONNECT_TIMEOUT:     7,
  // There was an error sending a message on an etablished transport
  SEND_ERROR:          8,
  // The requested downgrade was rejected.
  DOWNGRADE_FAILED:    10,
  // The requested downgrade completed.
  DOWNGRADE_SUCCEEDED: 11,
};

module.exports.TransportSessionEventCode = Enum.new(TransportSessionEventCode);


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumerates destination types for destination objects.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var DestinationType = {
  /**
   * A Topic destination.
   */
  TOPIC:           'topic',
  /**
   * A queue destination.
   */
  QUEUE:           'queue',
  /**
   * A temporary queue destination.
   */
  TEMPORARY_QUEUE: 'temporary_queue',
};

module.exports.DestinationType = Enum.new(DestinationType);

/* eslint-disable */
// Manually demangle these names; bug 70131
module.exports.DestinationType._setCanonical({
  'TOPIC':           DestinationType.TOPIC,
  'QUEUE':           DestinationType.QUEUE,
  'TEMPORARY_QUEUE': DestinationType.TEMPORARY_QUEUE
});
/* eslint-enable */


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(25);
var DestinationType = ref$1.DestinationType;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(4);
var UUID = ref$3.UUID;
var StringUtils = ref$3.StringUtils;

var ucs2ToUtf8 = Convert.ucs2ToUtf8;
var utf8ToUcs2 = Convert.utf8ToUcs2;
var ProfileBinding = SolclientFactoryLib.ProfileBinding;

var toSafeChars = StringUtils.toSafeChars;
var stripNullTerminate = StringUtils.stripNullTerminate;
var ref$4 = __webpack_require__(2);
var ErrorSubcode = ref$4.ErrorSubcode;
var OperationError = ref$4.OperationError;

var DESTINATION_PREFIX_FROM_TYPE = {};
DESTINATION_PREFIX_FROM_TYPE[DestinationType.QUEUE] = '#P2P/QUE/';
DESTINATION_PREFIX_FROM_TYPE[DestinationType.TEMPORARY_QUEUE] = '#P2P/QTMP/';

function createTemporaryName(type, vrid, name) {
  var id = name || UUID.generateUUID();
  switch (type) {
    case DestinationType.TOPIC:
      return ("#P2P/TTMP/" + vrid + "/" + id);
    case DestinationType.TEMPORARY_QUEUE:
      return ("#P2P/QTMP/" + vrid + "/" + id);
    default:
      LOG_ERROR('Unknown/invalid destination type', DestinationType.describe(type));
  }
  return undefined;
}

function createPrefix(type) {
  return DESTINATION_PREFIX_FROM_TYPE[type] || '';
}

function createOperationError(type, errorStr) {
  return new OperationError(("Invalid " + type + ": " + errorStr), ErrorSubcode.INVALID_TOPIC_SYNTAX);
}

// This function validates topics in all code paths -- legacy code paths that relied on validating
// topics as they were used, and newer code paths that validate Destinations on construction.  We
// must not add validation here that could break legacy apps that used the deprecated 'new Topic'
// interface that doesn't perform validation, and subsequently rely on validate-on-use.
//
// More strict checks done during Destination construction should be placed in validateAndEncode.
// @return { error, isWildcarded }.  isWildcarded will not be defined if erorr is defined.
function legacyValidate(type, bytes, name,
                        exceptionCreator) {
  if ( exceptionCreator === void 0 ) exceptionCreator = createOperationError.bind(null, type);

  var error;

  /*
    * TRB topics can contain any utf-8 character and must be <= 250 bytes
    * in length.
    * '*', if present in a level, must be the last character in that level.
    * May not have empty levels.
    */

  // Check minimum length using name, since the bytes may include a destination type prefix.
  // e.g. #P2P/QUE/ should fail on length, not empty level.
  var nameLength = name.length;
  if (nameLength < 1) {
    error = exceptionCreator('Too short (must be >= 1 character).');
    return { error: error };
  }

  // Check maximum length using encoded bytes, since UTF-8 is a variable length encoding.
  var bytesLength = bytes.length;
  if (bytesLength > 251) { // null terminator doesn't count
    error = exceptionCreator(("Too long (encoding must be <= 250 bytes); name is " + bytesLength + " bytes: '" + name + "'"));
    return { error: error };
  }

  var isWildcarded = false;
  if (name.charAt(nameLength - 1) === '>') {
    isWildcarded = true;
  }

  for (var i = 0; i < nameLength; ++i) {
    switch (name.charAt(i)) {
      case '/':
        if (i === 0 || i === (nameLength - 1) || name.charAt(i - 1) === '/') {
          error = exceptionCreator(("Empty level(s) in '" + name + "'@" + i + "."));
          return { error: error };
        }
        break;

      case '*':
        if ((i < (nameLength - 1)) && (name.charAt(i + 1) !== '/')) {
          // must not have something other than '/' to the right
          error = exceptionCreator(("Illegal wildcard(s) in '" + name + "'@" + i + "."));
          return { error: error };
        }

        isWildcarded = true;
        break;

      default:
        break;
    }
  }

  return { isWildcarded: isWildcarded };
}

function encodeBytes(bytes) {
  return ProfileBinding.value.topicUtf8Encode
    ? ((ucs2ToUtf8(bytes)) + "\u0000")
    : (bytes + "\u0000");
}

function decodeBytes(bytes) {
  return stripNullTerminate(ProfileBinding.value.topicUtf8Encode
    ? utf8ToUcs2(bytes)
    : bytes);
}

/**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @returns {Object} {bytes, offset, networkName} The result of the encoding.
 *
 * @private
 */
function encode(type, name) {
  var prefix = createPrefix(type);
  var offset = prefix.length;
  var networkName = prefix + name;
  var bytes = encodeBytes(networkName);
  return { bytes: bytes, offset: offset, networkName: networkName };
}

/**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {Function} [exceptionCreator=createOperationError] A function to create an exception if an
 *   error is encountered.
 * @returns {Object} {bytes, error, offset, isWildcarded} The result of the encoding and any
 *      validation error
 *
 * @private
 */
function validateAndEncode(type, name, exceptionCreator) {
  if ( exceptionCreator === void 0 ) exceptionCreator = createOperationError.bind(null, type);

  var ref = encode(type, name);
  var bytes = ref.bytes;
  var offset = ref.offset;
  var ref$1 = legacyValidate(type, bytes, name, exceptionCreator);
  var constError = ref$1.error;
  var isWildcarded = ref$1.isWildcarded;
  var error = constError;

  // If there was no 'legacy' error, perform an additional check to see if the provided name starts
  // with a reserved prefix.  It shouldn't.  Prefixes should always be added by us by encode().
  if (!error) {
    Object.keys(DESTINATION_PREFIX_FROM_TYPE).some(function (prefixType) {
      var prefix = DESTINATION_PREFIX_FROM_TYPE[prefixType];
      if (!name.startsWith(prefix)) {
        return false; // keep processing more array elements.
      }

      error = exceptionCreator(("Reserved prefix '" + prefix + "' found at start of '" + name + "'"));
      return true;
    });
  }

  return { bytes: bytes, offset: offset, error: error, isWildcarded: isWildcarded };
}

var DestinationUtil = {
  createPrefix: createPrefix,
  createTemporaryName: createTemporaryName,
  decodeBytes: decodeBytes,
  encode: encode,
  encodeBytes: encodeBytes,
  legacyValidate: legacyValidate,
  toSafeChars: toSafeChars,
  validateAndEncode: validateAndEncode,
};

module.exports.DestinationUtil = DestinationUtil;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(178);
var EntryPoint = ref.EntryPoint;
var ref$1 = __webpack_require__(180);
var ExitPoint = ref$1.ExitPoint;
var ref$2 = __webpack_require__(96);
var StateContext = ref$2.StateContext;

/**
 * @classdesc
 * This class represents a state in a state machine.
 * @private
 */
var State = (function (StateContext) {
  function State(spec, extensions) {
    var this$1 = this;
    if ( extensions === void 0 ) extensions = null;

    StateContext.call(this, spec);

    var parentContext = spec.parentContext;
    Object.assign(this.impl, {
      parentContext: parentContext,
      reactions:            {},
      entryPoints:          {},
      exitPoints:           {},
      ancestorList:         parentContext.getAncestorList().concat( [this]),
      handleUnhandledEvent: function (e) { return (
        parentContext.handleEvent
          ? parentContext.handleEvent(e)
          : parentContext.impl.handleUnhandledEvent(e)
      ); },
    });
    if (parentContext) { this.log = parentContext.log.bind(this); }

    // Extend and bind functions
    Object.keys(extensions || {}).forEach(function (k) {
      var extension = extensions[k];
      this$1[k] = typeof extension === 'function' ? extension.bind(this$1) : extension;
    });

    this.setLogPadding(' '.repeat(this.impl.ancestorList.length));
  }

  if ( StateContext ) State.__proto__ = StateContext;
  State.prototype = Object.create( StateContext && StateContext.prototype );
  State.prototype.constructor = State;

  /**
   * Register a reaction function for a particular event.
   * @param {String} eventName The name of the event func is to react to.
   * @param {StateContext.reactionCallback} func The function to call when
   *  the state processes an event with the name eventName.  The function is
   *  bound to this object so that this refers to this state object when it
   *  is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.reaction = function reaction (eventName, func) {
    if (!eventName) { throw new Error('No event name for reaction'); }
    if (!func) { throw new Error(("No reaction function for reaction " + eventName)); }

    this.log(("Adding reaction to " + (this) + " for event " + eventName));

    if (this.impl.reactions[eventName]) {
      this.log(("Replacing reaction " + (this.impl.reactions[eventName]) + " with " + func));
    }
    this.impl.reactions[eventName] = func.bind(this);
    return this;
  };

  /**
   * Create an entryPoint for this state.
   * @param {String} entryPointName The name of the entryPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is entered via this entryPoint
   * @returns {State} This state object.
   * @public
   */
  State.prototype.entryPoint = function entryPoint (entryPointName, func) {
    if (!entryPointName) { throw new Error('No entry point name for entry point'); }
    if (!func) { throw new Error(("No reaction function for entry point " + entryPointName)); }

    this.log(("Adding entryPoint " + entryPointName + " to " + (this)));

    if (this.impl.entryPoints[entryPointName]) {
      this.log(("EntryPoint " + entryPointName + " already exists in " + (this)));
      return this;
    }

    this.impl.entryPoints[entryPointName] = new EntryPoint({
      state: this,
      entryPointName: entryPointName,
      func: func,
    });

    return this;
  };

  /**
   * Create an exitPoint for this state.
   * @param {String} exitPointName The name of the exitPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is exited via this exitPoint.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.exitPoint = function exitPoint (exitPointName, func) {
    if (!exitPointName) { throw new Error('No exit point name for entry point'); }
    if (!func) { throw new Error(("No reaction function for exit point " + exitPointName)); }

    this.log(("Adding exitPoint " + exitPointName + " to " + (this)));

    if (this.impl.exitPoints[exitPointName]) {
      this.log(("ExitPoint " + exitPointName + " already exists in  " + (this)));
      return this;
    }

    this.impl.exitPoints[exitPointName] = new ExitPoint({
      state: this,
      exitPointName: exitPointName,
      func: func,
    });

    return this;
  };

  /**
   * @param {String} entryPointName The name of the entry point to be
   *      transitioned to.
   * @returns { StateContext } The state context to transition to when
   *      entering via the state's entryPoint named entryPointName.
   * @protected
   */
  State.prototype.getEntryPointDestState = function getEntryPointDestState (entryPointName) {
    if (this.impl.entryPoints[entryPointName] === undefined) {
      this.log(((this) + ": EntryPoint " + entryPointName + " does not exist."));
      return this;
    }

    return this.impl.entryPoints[entryPointName].getDestState();
  };

  /**
   * @param {String} exitPointName The name of the exit point to be
   *      transitioned to.
   * @returns {StateContext} The state context to transition to when
   *      exiting via the state's exitPoint named exitPointName.
   * @protected
   */
  State.prototype.getExitPointDestState = function getExitPointDestState (exitPointName) {
    if (this.impl.exitPoints[exitPointName] === undefined) {
      this.log(((this) + ": ExitPoint " + exitPointName + " does not exist."));
      return this;
    }

    return this.impl.exitPoints[exitPointName].getDestState();
  };

  /**
   * Register a function to be called when the state is entered.
   * @param {function} func The function to call when the state is entered.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.entry = function entry (func) {
    if (this.impl.appEntryFunc) {
      this.log(("Replacing entry function " + (this.impl.appEntryFunc) + " with " + func));
    }
    this.impl.appEntryFunc = func.bind(this);
    return this;
  };

  /**
   * Register a function to be called when the state is exited.
   * @param {function} func The function to call when the state is exited.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
  State.prototype.exit = function exit (func) {
    if (this.impl.appExitFunc) {
      this.log(("Replacing exit function " + (this.impl.appExitFunc) + " with " + func));
    }
    this.impl.appExitFunc = func.bind(this);
    return this;
  };

  /**
   * This is the same as [transitionTo]{@link StateContext#transitionTo},
   * except the outermost state is exited if the source state is within the
   * dest state or vice versa.  If one state is not within the other, this
   * is equivalent to [transitionTo]{@link StateContext#transitionTo}.
   * @param {State} state The state to transition to; if undefined, it is
   *      a self-transition.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as part
   *      of the transition, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition.
   */
  State.prototype.externalTransitionTo = function externalTransitionTo (state, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state,
      action: action,
      external:  true,
    });
  };

  /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named entryPoint created on state.  If the
   * named entryPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named entryPoint.
   * @param {String} entryPointName The name of the entryPoint of state.
   * @param {StateContext.actionCallback} action The action to perform as part of
   *      the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.transitionToEntryPoint = function transitionToEntryPoint (state, entryPointName, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state.getEntryPointDestState(entryPointName),
      action: action,
    });
  };

  /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named exitPoint created on state.  If the
   * named exitPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named exitPoint.
   * @param {String} exitPointName The name of the exitPoint of state.
   * @param {StateContext.actionCallback} [action] Optional The
   * action to perform as part of the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.transitionToExitPoint = function transitionToExitPoint (state, exitPointName, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state.getExitPointDestState(exitPointName),
      action: action,
    });
  };

  /**
   * If a reaction evaluates the guard conditions for the reaction and none
   * succeed, the eventUnhandled
   * [ReactionResult]{@link StateContext.ReactionResult} should be
   * returned.  This causes the FSM to continue looking for a reaction to
   * process the event.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.eventUnhandled = function eventUnhandled () {
    return new StateContext.ReactionResult({
      caller: this,
    });
  };

  /**
   * This [ReactionResult]{@link StateContext.ReactionResult} is used
   * when an event has been handled in a state and the transition is a local
   * transition back to itself.  Note that internal transitions never cause
   * state exits or entries -- if the internal transition is defined in an
   * outer state that contains the active state, then the behaviour is as if the
   * active state has inherited the internal transition from the outer state.
   * @param {?Function} action The action to perform in the transition.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.internalTransition = function internalTransition (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getCurrentState(),
      action: action,
    });
  };

  /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
  State.prototype.terminate = function terminate (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getFinalState(),
      action: action,
    });
  };


  /**
   * @returns {StateContext} The parent state context for this state, which
   *      could either be an outer state, or the state machine for top-level
   *      states.
   * @protected
   */
  State.prototype.getParent = function getParent () {
    return this.impl.parentContext;
  };

  /**
   * Called when a state is being entered.  Calls the app's registered entry
   * function, if any.
   * @protected
   */
  State.prototype.onEntry = function onEntry () {
    this.log(("Entering: " + (this)));
    if (this.impl.appEntryFunc) {
      this.impl.appEntryFunc();
    }
  };

  /**
   * Called when a state is being exited.  Calls the app's registered exit
   * function, if any.
   * @protected
   */
  State.prototype.onExit = function onExit () {
    this.log(("Exiting: " + (this)));
    if (this.impl.appExitFunc) {
      this.impl.appExitFunc();
    }
  };

  /**
   * Called when a state is to handle an event.
   * @param {FsmEvent} e The event to handle.
   * @returns {ReactionResult} The result of handling the event.
   * @protected
   */
  State.prototype.handleEvent = function handleEvent (e) {
    this.log(("Process: " + e));
    var reaction = this.impl.reactions[e.getName()];
    if (reaction) {
      var result = reaction(e);
      // All ReactionResults in which an event is considered handled
      // have a destState defined.
      if (!result) {
        this.log(("Reaction returned undefined: " + e + " in " + (this)));
      }
      if (result.destState) {
        this.log(("Handled: " + e));
        return result;
      }
      this.log(("Unhandled: " + e + " in " + (this)));
    } else {
      this.log(("No reaction: " + e + " in " + (this)));
    }

    return this.impl.handleUnhandledEvent(e);
  };

  return State;
}(StateContext));

module.exports.State = State;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;
/**
 * An enumeration of message consumer event names. A {@link solace.MessageConsumer} will emit
 * these events as part of its lifecycle.  Applications, having created a MessageConsumer can
 * choose to listen to all of the events described here, or any subset of these events. For Example:
 * <pre>
 *   <code>
 *     mc = solace.Session.createMessageConsumer(...);
 *     mc.on(solace.MessageConsumerEventName.CONNECT_FAILED_ERROR,
 *           function connectFailedErrorEventCb(error) {
 *             // details is an OperationError object
 *           });
 *   </code>
 * </pre>
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
var MessageConsumerEventName = {
  /**
   * The message consumer is established.
   * @event solace.MessageConsumerEventName#UP
   */
  UP:                   'MessageConsumerEventName_up',
  /**
   * The message consumer is successfully disconnected.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN
   */
  DOWN:                 'MessageConsumerEventName_down',
 /**
   * The message consumer has become active.
   *
   * @event solace.MessageConsumerEventName#ACTIVE
   */
  ACTIVE:               'MessageConsumerEventName_active',
  /**
   * The message consumer has become inactive.
   *
   * @event solace.MessageConsumerEventName#INACTIVE
   */
  INACTIVE:             'MessageConsumerEventName_inactive',
  /**
   * The message consumer was established and then disconnected by the router,
   * likely due to operator intervention. The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN_ERROR
   */
  DOWN_ERROR:           'MessageConsumerEventName_downError',
  /**
   * The message consumer attempted to connect but was unsuccessful.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
  CONNECT_FAILED_ERROR: 'MessageConsumerEventName_connectFailedError',
  /**
   * The message consumer will not connect because the current session is incompatible
   * with Guaranteed Messaging. The message consumer is disabled until a compatible session
   * is available.
   *
   * @event solace.MessageConsumerEventName#GM_DISABLED
   */
  GM_DISABLED:          'MessageConsumerEventName_GMDisabled',
  /**
   * The message consumer is being disposed. No further events will be emitted.
   *
   * @event solace.MessageConsumerEventName#DISPOSED
   */
  DISPOSED:             'MessageConsumerEventName_disposed',
  /**
   * A message was received on the message consumer.
   *
   * If the application throws an exception in this listener, and the consumer was configured
   * to automatically acknowledge messages
   * (see {@link solace.MessageConsumerProperties#acknowledgeMode}),
   * the API will not acknowledge the message, since it
   * may not have been successfully processed by the application. Such a message must be
   * acknowledged manually. If the application did not retain a reference to the message, it
   * may be redelivered by calling {@link solace.MessageConsumer#disconnect} followed by
   * {@link solace.MessageConsumer#connect} depending on the configuration of the queue.
   *
   * When there is no listener for <i>MESSAGE</i> on a MessageConsumer, messages are queued
   * internally until a listener is added.
   *
   * @event solace.MessageConsumerEventName#MESSAGE
   * @param {solace.Message} message The received message being delivered in this event.
   */
  MESSAGE:              'MessageConsumerEventName_message',
};

module.exports.MessageConsumerEventName = Enum.new(MessageConsumerEventName);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(193);
var MessagePublisher = ref.MessagePublisher;
var ref$1 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$1.MessagePublisherAcknowledgeMode;
var ref$2 = __webpack_require__(55);
var MessagePublisherEventName = ref$2.MessagePublisherEventName;
var ref$3 = __webpack_require__(102);
var MessagePublisherProperties = ref$3.MessagePublisherProperties;
var ref$4 = __webpack_require__(192);
var MessagePublisherPropertiesValidator = ref$4.MessagePublisherPropertiesValidator;
var ref$5 = __webpack_require__(57);
var PublisherFSMEvent = ref$5.PublisherFSMEvent;
var ref$6 = __webpack_require__(56);
var PublisherFSMEventNames = ref$6.PublisherFSMEventNames;

module.exports.MessagePublisherAcknowledgeMode = MessagePublisherAcknowledgeMode;
module.exports.MessagePublisher = MessagePublisher;
module.exports.MessagePublisherProperties = MessagePublisherProperties;
module.exports.PublisherFSMEvent = PublisherFSMEvent;
module.exports.PublisherFSMEventNames = PublisherFSMEventNames;
module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
module.exports.MessagePublisherEventName = MessagePublisherEventName;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SDTDataTypes = {
  Null:            0x00,
  Boolean:         0x01,
  Integer:         0x02,
  UnsignedInteger: 0x03,
  Float:           0x04,
  Char:            0x05,
  ByteArray:       0x06,
  String:          0x07,
  Destination:     0x08,
  SMFMessage:      0x09,
  Map:             0x0A,
  Stream:          0x0B,
};

module.exports.SDTDataTypes = Enum.new(SDTDataTypes);


/***/ }),
/* 31 */
/***/ (function(module, exports) {

/**
 * @constructor BaseMessage
 * @private
 */
var BaseMessage = function BaseMessage(header, params) {
  if ( header === void 0 ) header = null;
  if ( params === void 0 ) params = [];

  this._smfHeader = header;
  this._parameters = params;
};

var prototypeAccessors = { smfHeader: {} };

BaseMessage.prototype.addParameter = function addParameter (param) {
  this._parameters[param.getType()] = param;
};

BaseMessage.prototype.getParameter = function getParameter (paramType) {
  return this._parameters[paramType];
};

BaseMessage.prototype.getParameterArray = function getParameterArray () {
  return this._parameters;
};

prototypeAccessors.smfHeader.get = function () {
  return this._smfHeader;
};
prototypeAccessors.smfHeader.set = function (val) {
  this._smfHeader = val;
};

BaseMessage.prototype.getResponse = function getResponse () {
  var smf = this.smfHeader;
  if (!(smf && smf.pm_respcode && smf.pm_respstr)) {
    return null;
  }
  return {
    responseCode: smf.pm_respcode,
    responseString: smf.pm_respstr,
  };
};

Object.defineProperties( BaseMessage.prototype, prototypeAccessors );

module.exports.BaseMessage = BaseMessage;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * Control messages wrap an SMFHeader instance
 * @private
 */
var SMFHeader = function SMFHeader(protocol, ttl) {
  if ( protocol === void 0 ) protocol = 0;
  if ( ttl === void 0 ) ttl = 0;

  // header properties
  // header block
  // SMF parameters
  // payload
  this._parameters = [];

  // Common SMF header field values
  this.smf_version = 3;
  this.smf_uh = 0;
  this.smf_protocol = protocol;
  this.smf_priority = 0;
  this.smf_ttl = ttl;
  this.smf_msgLen = 0;
  this.smf_di = 0;
  this.smf_tqd = 0;
  this.smf_elidingEligible = 0;
  this.smf_dto = 0;
  this.smf_adf = 0;                // AD
  this.smf_deadMessageQueueEligible = 0; //DMQ Eligible

  // Common SMF protocol parameters
  this.pm_userdata = null;
  this.pm_respcode = 0;
  this.pm_respstr = null;
  this.pm_username = null;
  this.pm_password = null;
  this.pm_tr_topicname_bytes = null;
  this.pm_deliverymode = null;

  this.pm_ad_msgid = undefined;    // AD
  this.pm_ad_prevmsgid = undefined;// AD
  this.pm_ad_redelflag = 0;        // AD
  this.pm_ad_flowredelflag = 0;    // AD
  this.pm_ad_ttl = undefined;      // AD
  this.pm_ad_ackimm = undefined;   // AD
  this.pm_ad_flowid = 0;           // AD
  this.pm_ad_publisherid = 0;
  this.pm_ad_publishermsgid = 0;

  this.pm_content_summary = null;
  this.pm_corrtag = null;
  this.pm_topic_offset = 0;
  this.pm_topic_len = 0;
  this.pm_queue_offset = 0;
  this.pm_queue_len = 0;
  this.pm_msg_priority = null;      // {number}

  // housekeeping
  this.unknownProtoFlag = false;
  this.messageLength = 0;
  this.payloadLength = 0;
  this.headerLength = 0;
  this.payload = null;

  // This message is invalid, but the framing (messageLength) is fine.
  // set by the parser when UH==2 on an unknown parameter.
  // The SMF fsm can then discard and increment the stats.
  this.discardMessage = false;
};

SMFHeader.prototype.setMessageSizes = function setMessageSizes (headerLength, payloadLength) {
  this.headerLength = headerLength;
  this.payloadLength = payloadLength;
  this.messageLength = headerLength + payloadLength;
};

SMFHeader.prototype.setPayloadSize = function setPayloadSize (payloadLength) {
  this.payloadLength = payloadLength;
};

module.exports.SMFHeader = SMFHeader;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * An error thrown when an error occurs on the transport session.
 * <p>
 * Applications are not expected to instantiate this type.
 *
 * @memberof solace
 * @private
 */
var TransportError = (function (SolaceError) {
  function TransportError(message, subcode) {
    SolaceError.call(this, 'TransportError', message);
    this.subcode = subcode;
  }

  if ( SolaceError ) TransportError.__proto__ = SolaceError;
  TransportError.prototype = Object.create( SolaceError && SolaceError.prototype );
  TransportError.prototype.constructor = TransportError;

  TransportError.prototype.toString = function toString () {
    return ((SolaceError.prototype.toString.call(this)) + ", subcode=" + (this.subcode));
  };

  return TransportError;
}(SolaceError));

module.exports.TransportError = TransportError;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Transport session states, used by WebSocketTransportSession and HTTPTransportSession
 * @enum {number}
 * @private
 */
var TransportSessionState = {
  DOWN:                0,
  WAITING_FOR_CREATE:  1,
  SESSION_UP:          2,
  WAITING_FOR_DESTROY: 4,
  CONNECTION_FAILED:   5,
};

module.exports.TransportSessionState = Enum.new(TransportSessionState);


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(174);
var EventEmitter = ref.EventEmitter;
var ref$1 = __webpack_require__(175);
var Timer = ref$1.Timer;

module.exports = {
  EventEmitter: EventEmitter,
  Timer: Timer,
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(177);
var Flow = ref.Flow;
var ref$1 = __webpack_require__(94);
var FlowOperation = ref$1.FlowOperation;
var ref$2 = __webpack_require__(95);
var PrivateFlowEventName = ref$2.PrivateFlowEventName;

module.exports.Flow = Flow;
module.exports.FlowOperation = FlowOperation;
module.exports.PrivateFlowEventName = PrivateFlowEventName;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var OperationError = ref.OperationError;

/**
 * @classdesc
 * This is a base class for various FSM-related objects.
 * @private
 */
var FsmObject = function FsmObject(spec) {
  if (!spec) {
    throw new OperationError('No spec provided');
  }
  if (!spec.name) {
    throw new OperationError('No name provided for spec');
  }
  this.impl = {
    name: spec.name,
  };
};

/**
 * @returns {String} A string representation of the object.
 */
FsmObject.prototype.toString = function toString () {
  var extraStringInfo = this.getExtraStringInfo();
  if (extraStringInfo.length > 0) {
    extraStringInfo = "; " + extraStringInfo;
  }
  return ("{" + (this.constructor.name) + ": " + (this.getName()) + extraStringInfo + "}");
};

/**
 * This is overridden by classes wanting to add more data, typically in the
 * form of 'name: value; name: value'.
 * @returns {String} Extra string information to be included in the object's
 *    toString() output.
 */
FsmObject.prototype.getExtraStringInfo = function getExtraStringInfo () { // eslint-disable-line class-methods-use-this
  return '';
};

/**
 * @returns {?String} The name passed into the object specifier.
 */
FsmObject.prototype.getName = function getName () {
  return this.impl.name;
};

module.exports.FsmObject = FsmObject;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An enumeration of consumer acknowledgement modes. The corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#acknowledgeMode}
 * configures how acknowledgments are generated for received Guaranteed messages.
 *
 * When received messages are acknowledged they are removed from the Guaranteed
 * Message storage on the Solace Message Router. Message Consumer acknowledgements,
 * <b>only</b> remove messages from the Solace Message Router.
 *
 * In particular, withholding Message Consumer Acknowledgemnts does not stop
 * message delivery. For Message Consumer flow control see
 * {@link solace.MessageConsumer.stop}/{@link solace.MessageConsumer.start}. Message Consumer
 * flow control may also be imlpemented by removing the
 * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
var MessageConsumerAcknowledgeMode = {
  /**
   * The API automatically acknowledges any message that was delivered to all
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listeners with no exception thrown
   * on any of them.
   */
  AUTO:   'AUTO',
  /**
   * The API acknowledges a message only when the application calls
   * {@link solace.Message#acknowledge}.
   */
  CLIENT: 'CLIENT',
};

module.exports.MessageConsumerAcknowledgeMode = Enum.new(MessageConsumerAcknowledgeMode);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents authentication scheme enumeration.
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var MessagePublisherAcknowledgeMode = {
  /**
   * @description Applications receive an acknowledgement for every
   * message.
   * @type {String}
   */
  PER_MESSAGE: 'PER_MESSAGE',
  /**
   * @description Applications receive a windowed acknowledgement that
   * acknowledges the returned correlation identifier and every message sent prior.
   * @type {String}
   */
  WINDOWED:    'WINDOWED',
};

module.exports.MessagePublisherAcknowledgeMode = Enum.new(MessagePublisherAcknowledgeMode);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message dump formats. It controls
 * the output of {@link solace.Message#dump}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageDumpFlag = {
  /**
   * Display only the length of the binary attachment, XML content and user property maps.
   */
  MSGDUMP_BRIEF: 0,
  /**
   * Display the entire message contents.
   */
  MSGDUMP_FULL:  1,
};

module.exports.MessageDumpFlag = Enum.new(MessageDumpFlag);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;

/**
 * @classdesc
 * Defines a Structured Data Type (SDT) map container.
 * @memberof solace
 */
var SDTMapContainer = function SDTMapContainer() {
  this._map = []; // key-value mappings (keys are strings)
};

/**
 * Get the list of keys in this map, in unspecified order.
 * @returns {Array.<String>} Array of defined keys in the map.
 */
SDTMapContainer.prototype.getKeys = function getKeys () {
  return Object.keys(this._map);
};

/**
 * Return the SDTField with the given key.
 * @param {String} key The key to look up.
 * @returns {solace.SDTField} The field referenced by key.
 */
SDTMapContainer.prototype.getField = function getField (key) {
  return this._map[key];
};

/**
 * Delete an SDTField with the given key.
 * @param {String} key The field key to delete.
 */
SDTMapContainer.prototype.deleteField = function deleteField (key) {
  delete this._map[key];
};

/**
 * Adds a field to this map. If a key:value mapping already exists for this key, it is replaced.
 * <p>
 * @deprecated If <code>typeOrField</code> is a {@link solace.SDTField} instance,
 * it is added to the map.
 *
 * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
 * SDTField of this type using <code>value</code> before adding it to the map.
 *
 * @param {String} key The key by which to store the given value.
 * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
 * @param {*} [value] The value to wrap as an SDTField.
 * @throws {solace.OperationError} if value does not match type
 * @throws {solace.SDTUnsupportedValueError} if value is not in range
 *supported by the platform/runtime
 */
SDTMapContainer.prototype.addField = function addField (key, typeOrField, value) {
    if ( value === void 0 ) value = undefined;

  if (typeOrField instanceof SDTField) {
    this._map[key] = typeOrField;
    return;
  } else if (typeof value !== 'undefined') {
    this._map[key] = SDTField.create(typeOrField, value);
    return;
  }
  throw new OperationError('Invalid parameters to addField: expected SDTField, or type and value',
    ErrorSubcode.PARAMETER_CONFLICT);
};

module.exports.SDTMapContainer = SDTMapContainer;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var SDTFieldLib = __webpack_require__(12);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;

/**
 * @classdesc
 * Defines a Structured Data Type (SDT) stream container. A stream is an iterable collection of
 * {@link solace.SDTField}s.
 * @memberof solace
 */
var SDTStreamContainer = function SDTStreamContainer() {
  this._stream = [];
  this._writable = true;
  this._readPt = 0;
};

/**
 * Returns true if the stream has at least one more {@link solace.SDTField}
 * at the current position.
 * @returns {Boolean} true, if there is an available field at the read pointer; false, otherwise.
 */
SDTStreamContainer.prototype.hasNext = function hasNext () {
  return (this._stream.length > this._readPt);
};

/**
 * Returns the next field in the stream and advances the read pointer.
 * If the end of the stream is reached, it returns undefined.
 * @returns {solace.SDTField} The next field in the stream.
 */
SDTStreamContainer.prototype.getNext = function getNext () {
  return (this._readPt < this._stream.length) ? this._stream[this._readPt++] : undefined;
};

/**
 * Rewinds the read pointer to the beginning of the stream. Normally when {@link hasNext}
 * returns false, a client application must call rewind() to reiterate over the stream's fields.
 * @throws {solace.OperationError} if the stream cannot be rewound.
 */
SDTStreamContainer.prototype.rewind = function rewind () {
  this._readPt = 0;
};

/**
 * Appends a SDTField to the stream.
 * <p>
 * If <code>field</code> is a {@link solace.SDTField}, this field is appended to the stream.
 * <br>
 * If <code>field</code> is a {@link solace.SDTFieldType},
 * then the API will create a SDTField of this
 * type with a value of <code>optValue</code> and append this new SDTField to
 * the stream.
 *
 * @param {solace.SDTField|solace.SDTFieldType} field The field to append to the stream.
 * @param {*} [optValue] The value to wrap as an SDTField.
 */
/**
 * Appends a field to this stream.
 * <p>
 * @deprecated If <code>typeOrField</code> is a {@link solace.SDTField} instance,
 * it is appended to the stream.
 *
 * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
 * SDTField of this type using <code>value</code> and append this new SDTField
 * to the stream.
 *
 * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
 * @param {*} [value] The value to wrap as an SDTField.
 * @throws {solace.OperationError} if value does not match type
 * @throws {solace.SDTUnsupportedValueError} if value is not in range
 *supported by the platform/runtime
 */
SDTStreamContainer.prototype.addField = function addField (typeOrField, value) {
    if ( value === void 0 ) value = undefined;

  if (!this._writable) { return; }

  if (typeOrField instanceof SDTFieldLib.SDTField) {
    this._stream.push(typeOrField);
    return;
  }

  if (typeof value !== 'undefined') {
    this._stream.push(SDTFieldLib.SDTField.create(typeOrField, value));
    return;
  }

  throw new OperationError('Invalid parameters to addField: expected SDTField, or type and value',
    ErrorSubcode.PARAMETER_CONFLICT);
};

module.exports.SDTStreamContainer = SDTStreamContainer;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of peer capabilities.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CapabilityType = {
  /**
   * Peer's software load version. Type: string.
   */
  PEER_SOFTWARE_VERSION:        0,
  /**
   * Peer's software release date. Type: string.
   */
  PEER_SOFTWARE_DATE:           1,
  /**
   * Peer's platform. Type: string.
   */
  PEER_PLATFORM:                2,
  /**
   * Speed (in Mbps) of the port the client connects to. Type: number.
   */
  PEER_PORT_SPEED:              3,
  /**
   * Type of the port the client has connected to (currently 0: Ethernet). Type: number.
   */
  PEER_PORT_TYPE:               4,
  /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
  MAX_DIRECT_MSG_SIZE:          5,
  /**
   * Peer's router name. Type: string.
   *
   * This property is useful when sending SEMP requests to a peer's SEMP topic, which may be
   * constructed as `#P2P/routername/#client/SEMP`.
   */
  PEER_ROUTER_NAME:             6,
  /**
   * Peer supports message eliding. Type: boolean.
   */
  MESSAGE_ELIDING:              7,
  /**
   * Peer supports NoLocal option (client may avoid receiving messages published by itself).
   */
  NO_LOCAL:                     8,
  /**
   * Peer supports Guaranteed Message Consumer connections for receiving guaranteed messages.
   */
  GUARANTEED_MESSAGE_CONSUME:   9,
  /**
   * Peer supports temporary endpoints.
   */
  TEMPORARY_ENDPOINT:           10,
  /**
   * Peer supports Guaranteed Message Publisher connections for sedning guaranteed messages.
   */
  GUARANTEED_MESSAGE_PUBLISH:   11,
  /**
   * Peer supports Guaranteed Messages Browser connections for receiving guaranteed messages
   */
  GUARANTEED_MESSAGE_BROWSE:    12,
  /**
   * Peer supports creating/modify/disposing endpoints.
   */
  ENDPOINT_MGMT:                13,
  /**
   * Peer supports selectors on Guaranteed Message Consumers.
   */
  SELECTOR:                     14,
  /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
  MAX_GUARANTEED_MSG_SIZE:      15,
  /**
   * Peer supports Guaranteed Messaging Consumer state change updates. Type: boolean
   */
  ACTIVE_CONSUMER_INDICATION:   16,
  /**
   * Peer accepts compressed (DEFLATE) data. Type: boolean.
   */
  COMPRESSION:                  17,
  /**
   * Peer supports Guaranteed Messaging cut-through. Type: boolean
   */
  CUT_THROUGH:                  18,
  /**
   * Peer supports provisioned queue and topic-endpoint discard behavior. Type: boolean
   */
  ENDPOINT_DISCARD_BEHAVIOR:    19,
  /**
   * Peer supports Guaranteed Messaging message TTL and Dead-Message Queues. Type: boolean
   */
  ENDPOINT_MESSAGE_TTL:         20,
  /**
   * Peer accepts JNDI queries. Type: boolean.
   */
  JNDI:                         21,
  /**
   * Peer supports per topic sequence numbering for Guaranteed Messaging messages. Type: boolean
   */
  PER_TOPIC_SEQUENCE_NUMBERING: 22,
  /**
   * Peer supports QueueSubscriptionAdd for managing subscriptions on queue endpoints.
   * Type: boolean
   */
  QUEUE_SUBSCRIPTIONS:          23,
  /**
   * Peer supports add/remove subscriptions for a specified clientName. Type: boolean
   */
  SUBSCRIPTION_MANAGER:         24,
  /**
   * Peer supports transacted sessions. Type: boolean.
   */
  TRANSACTED_SESSION:           25,
};

module.exports.CapabilityType = Enum.new(CapabilityType);


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;


/**
 * @callback solace.SessionEventCodes.sessionEvent
 * @function
 * @this {solace.Session} The message consumer for the event
 * @param {solace.SessionEvent|solace.OperationError} event The event. If the event is an
 *  error, the event will be an instance of {@link solace.OperationError} but will also be
 *  interface-compatible with {@link solace.SessionEvent}.
 */


/**
 * An attribute of {@link SessionEvent}. This enumeration represents the
 * different events emitted by {@link Session} through the session event
 * callback.
 *
 * When a session is no longer in a usable state, the API tears down the underlying
 * connection and notifies the application with one of the following session events:
 *  * {@link solace.SessionEventCode#event:DOWN_ERROR}
 *  * {@link solace.SessionEventCode#event:CONNECT_FAILED_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SessionEventCode = {
  /**
   * The Session is ready to send/receive messages and perform control operations.
   *
   * At this point the transport session is up, the Session has logged in, and the
   * P2PInbox subscription is added.
   *
   * The session is established.
   * @event solace.SessionEventCode#UP_NOTICE
   */
  UP_NOTICE:                         0,
  /**
   * The session was established and then went down.
   * @event solace.SessionEventCode#DOWN_ERROR
   * @param {solace.OperationError} error The details related to the session failure.
   */
  DOWN_ERROR:                        1,
  /**
   * The session attempted to connect but was unsuccessful.
   * @event solace.SessionEventCode#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error The details related to the failed connection attempt.
   */
  CONNECT_FAILED_ERROR:              2,
  /**
   * The Solace Message Router rejected a published message.
   * @event solace.SessionEventCode#REJECTED_MESSAGE_ERROR
   * @param {solace.RequestError} error The details related to the rejected message.
   */
  REJECTED_MESSAGE_ERROR:            4,
  /**
   * The Solace Message Router rejected a subscription (add or remove).
   * @event solace.SessionEventCode#SUBSCRIPTION_ERROR
   * @param {solace.RequestError} error The details related to the failed subscription update.
   */
  SUBSCRIPTION_ERROR:                5,
  /**
   * The subscribe or unsubscribe operation succeeded.
   * @event solace.SessionEventCode#SUBSCRIPTION_OK
   * @param {solace.SessionEvent} event The details related to the successful subscription update.
   */
  SUBSCRIPTION_OK:                   6,
  /**
   * The Solace Message Router's Virtual Router Name changed during a reconnect operation.
   * @event solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
   * @param {solace.SessionEvent} event Information related to the event.
   */
  VIRTUALROUTER_NAME_CHANGED:        7,
  /**
   * @deprecated
   * A request was aborted because the session is being disconnected.
   * Use {@link solace.RequestFailEvent} instead.
   */
  REQUEST_ABORTED:                   8,
  /**
   * @deprecated
   * The event represents a timed-out request API call.
   * Use {@link solace.RequestFailEvent} instead.
   */
  REQUEST_TIMEOUT:                   9,
  /**
   * The event represents a successful update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_OK
   * @param {solace.SessionEvent} event Information related to the successful property update.
   */
  PROPERTY_UPDATE_OK:                10,
  /**
   * The event represents a failed update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_ERROR
   * @param {solace.RequestError} error The details related to the failed property update.
   */
  PROPERTY_UPDATE_ERROR:             11,
  /**
   * The session transport can accept data again.  This event will occur after an
   * {@link solace.OperationError} is thrown from an API call with a subcode of
   * {@link solace.ErrorSubcode.INSUFFICIENT_SPACE} to indicate the operation can be retried.
   * @event solace.SessionEventCode#CAN_ACCEPT_DATA
   */
  CAN_ACCEPT_DATA:                   13,
  /**
   * The session connect operation failed, or the session that was once up,
   * is now disconnected.
   * @event solace.SessionEventCode#DISCONNECTED
   */
  DISCONNECTED:                      14,
  /**
   * The session has gone down, and an automatic reconnection attempt is in progress.
   * @event solace.SessionEventCode#RECONNECTING_NOTICE
   * @param {solace.SessionEvent} event The details related to the cause of the connection
   *    interruption.
   */
  RECONNECTING_NOTICE:               22,
  /**
   * The automatic reconnect of the Session was successful, and the session is established again.
   * @event solace.SessionEventCode#RECONNECTED_NOTICE
   * @param {solace.SessionEvent} event The details related to the re-establishment of the
   *    connection.
   */
  RECONNECTED_NOTICE:                23,
  /**
   * The session has automatically recovered after the Guaranteed Message publisher
   * failed to reconnect.
   * Messages sent but not acknowledged are being renumbered and retransmitted.
   * Some messages may be duplicated in the system.
   * @event solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
   * @param {solace.SessionEvent} event The details related to the republishing of messages on the
   *    session.  {@link solace.SessionEvent#infoStr} will indicate the number of messages being
   *    republished, which is an upper bound on the number of messages that could be duplicated due
   *    to this action.
   */
  REPUBLISHING_UNACKED_MESSAGES:     24,
  /**
   * A message was acknowledged by the router.
   * @event solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
   * @param {solace.SessionEvent} event Allows the acknowledgement to be correlated to the sent
   *    message.
   */
  ACKNOWLEDGED_MESSAGE:              25,
  /**
   * Unsubscribing the topic from the Durable Topic Endpoint succeeded.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
   */
  UNSUBSCRIBE_TE_TOPIC_OK:           26,
  /**
   * Unsubscribing the topic from the Durable Topic Endpoint failed.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
   * @param {solace.OperationError} error The details related to the failed attempt to remove the
   *    subscription from a topic endpoint.
   */
  UNSUBSCRIBE_TE_TOPIC_ERROR:        27,
  /**
   * A Direct message was received on the session. This event code is only used
   * on the <b>EventEmitter</b> session interface.  If using the deprecated callback interface,
   * messages are received via the callback provided in {@link solace.MessageRxCBInfo}.
   * @event solace.SessionEventCode#MESSAGE
   * @param {solace.Message} message The message received on the session.
   */
  MESSAGE:                           28,
  /**
   * Guaranteed Messaging Publisher has been closed by the Solace
   * message router. This usually indicates an operator has disabled the
   * message spool.
   * @event solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
   * @param {solace.OperationError} error Information related to the error.
   */
  GUARANTEED_MESSAGE_PUBLISHER_DOWN: 29,
};

module.exports.SessionEventCode = Enum.new(SessionEventCode);


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Type maching SMF encoding value
 * @enum {number}
 * @memberof solace
 * @private
 */
var ContentSummaryType = {
  XML_META:          0,
  XML_PAYLOAD:       1,
  BINARY_ATTACHMENT: 2,
  CID_LIST:          3,
  BINARY_METADATA:   4,
};

module.exports.ContentSummaryType = Enum.new(ContentSummaryType);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(17);
var TransportReturnCode = ref$1.TransportReturnCode;

// Stubs don't use this
/* eslint-disable class-methods-use-this */
// Stubs declare all params
/* eslint-disable no-unused-vars */

/**
 *
 * Base class for various transports
 * @private
 */
var TransportBase = function TransportBase(url, eventCB, client, transportProps, interceptor) {
  if ( interceptor === void 0 ) interceptor = null;

  this._url = url;
  this._ssl = TransportBase.useSsl(url);
  this._client = client;
  this._eventCB = eventCB;
  this._props = transportProps;
  this.setInterceptor(interceptor);
};

/**
 * Establish underlying transport.
 * Returns transport return code, to be overridden in subclass
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.connect = function connect () { return TransportReturnCode.OK; };

/**
 * Destroy the underlying transport.
 * Returns transport return code, to be overridden in subclass
 * @param {Boolean} immediate Destroy gracefully if false.
 * @param {?String} msg The message associated with this operation, if any.
 * @param {?ErrorSubcode} subcode The subcode associated with this operation, if any.
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.destroy = function destroy (immediate, msg, subcode) { return TransportReturnCode.OK; };

TransportBase.prototype.flush = function flush (callback) {
  callback();
  return TransportReturnCode.OK;
};

/**
 * Send encoded SMF message
 * Returns transport return code, to be overridden in subclass
 * @param {String} message The encoded SMF message to send
 * @param {?Boolean} [forceAllowEnqueue=false] If true, do not fail due to transport buffer full
 * @returns {TransportReturnCode} The result of this operation
 */
TransportBase.prototype.send = function send (message, forceAllowEnqueue) {
  if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;
 return TransportReturnCode.OK; };

/**
 * @returns {TransportProtocol} Return transport protocol in use
 */
TransportBase.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._props.transportProtocol;
};

/**
 * @returns {?String} Return transport session information such as sessionId
 */
TransportBase.prototype.getInfoStr = function getInfoStr () { return null; };

/**
 * @returns {TransportClientStats} transport statistics
 */
TransportBase.prototype.getClientStats = function getClientStats () { return null; };

/**
 * Check whether or not the transport can be downgraded to the next protocol.
 * It is possible to downgrade the transport, the existing transport is destroyed and
 * the new transport connection initiated.
 * @param {String} msg The message associated with this operation
 * @param {ErrorSubcode} subcode The subcode associated with this operation
 * @returns {Boolean} Return true if downgrade is allowed and has been initiated; false otherwise
 */
TransportBase.prototype.beginDowngrade = function beginDowngrade (msg, subcode) { return false; };

/**
 * Sets the interceptor for this transport. This object has the chance
 * to intervene before bytes are sent or received.
 * @param {Object} [interceptor] If set, the interceptor is inserted into the
 *
 * @private
 */
TransportBase.prototype.setInterceptor = function setInterceptor (interceptor) {
  if (this._interceptor) {
    // Reset original callbacks
    if (this._interceptor.removed) { this._interceptor.removed(this); }
  }
  this._interceptor = interceptor;
  if (interceptor) {
    if (interceptor.installed) { interceptor.installed(this); }
  }
};

TransportBase.prototype.toString = function toString () {
  return ("" + (this.getTransportProtocol()) + (this._ssl ? ' (SSL)' : ''));
};

/**
 * @param {String} url The URL to check
 * @returns {Boolean} `true` if the URL requires SSL; `false` otherwise
 * @static
 */
TransportBase.useSsl = function useSsl (url) {
  var urlParts = (url || '').split('://');
  if (urlParts.length === 0 || TransportBase.validSchemes.indexOf(urlParts[0]) < 0) {
    throw new OperationError(("Invalid url \"" + url + "\": Only [" + (TransportBase.validSchemes.join(', ')) + "] URL schemes are supported"),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }

  var useSSL = (urlParts[0] === 'https' || urlParts[0] === 'wss' || urlParts[0] === 'tcps');
  return useSSL;
};

/**
 * @type {Array.<String>}
 */
TransportBase.validSchemes = ['http', 'https', 'ws', 'wss', 'tcp', 'tcps'];

module.exports.TransportBase = TransportBase;



/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(3);
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(24);
var TransportSessionEventCode = ref$2.TransportSessionEventCode;

var formatHexString = Hex.formatHexString;

/**
 * @classdesc
 * Defines a Transport Session Event
 *
 * @private
 */
var TransportSessionEvent = function TransportSessionEvent(tsEventCode, infoStr, responseCode, subcode, sessionId) {
  this._transportEventCode = tsEventCode;
  this._infoStr = infoStr;
  this._responseCode = responseCode;
  this._errorSubcode = subcode;
  this._sid = sessionId;
};

var prototypeAccessors = { transportEventCode: {},infoStr: {},responseCode: {},errorSubcode: {},sessionId: {} };

// TransportSessionEvent functions

TransportSessionEvent.prototype.getTransportEventCode = function getTransportEventCode () {
  return this._transportEventCode;
};

prototypeAccessors.transportEventCode.get = function () {
  return this._transportEventCode;
};

TransportSessionEvent.prototype.getInfoStr = function getInfoStr () {
  return this.infoStr;
};

prototypeAccessors.infoStr.get = function () {
  return this._infoStr;
};

TransportSessionEvent.prototype.getResponseCode = function getResponseCode () {
  return this.responseCode;
};

prototypeAccessors.responseCode.get = function () {
  return this._responseCode;
};

TransportSessionEvent.prototype.getSubcode = function getSubcode () {
  return this.errorSubcode;
};

prototypeAccessors.errorSubcode.get = function () {
  return this._errorSubcode;
};

TransportSessionEvent.prototype.getSessionId = function getSessionId () {
  return this.sessionId;
};

prototypeAccessors.sessionId.get = function () {
  return this._sid;
};

TransportSessionEvent.prototype[util.inspect.custom] = function () {
  return {
    'transportEventCode': TransportSessionEventCode.describe(this.transportEventCode),
    'infoStr':          this.infoStr,
    'responseCode':     this.responseCode,
    'errorSubcode':     ErrorSubcode.describe(this.errorSubcode),
    'sid':              this.sid && formatHexString(this.sid) || 'N/A',
  };
};

TransportSessionEvent.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( TransportSessionEvent.prototype, prototypeAccessors );

module.exports.TransportSessionEvent = TransportSessionEvent;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_INFO = ref.LOG_INFO;
var LOG_WARN = ref.LOG_WARN;
var ref$1 = __webpack_require__(4);
var Process = ref$1.Process;

/**
 * @classdesc
 * Base class for transports
 * @memberof solace
 * @private
 */
var TSHState = function TSHState(useSsl, tpProtocol, exitCallback, nextState) {
  this._ssl = !!useSsl;
  this._transportProtocol = tpProtocol;
  this._exitCallback = exitCallback;
  this._nextState = nextState;
  this._unsupportedRuntimeMessage =
    (this._transportProtocol) + " not supported by this runtime: " + (Process.userAgent);
};

TSHState.prototype.getNextState = function getNextState () {
  return this._nextState;
};

TSHState.prototype.setNextState = function setNextState (nextState) {
  this._nextState = nextState;
};

TSHState.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._transportProtocol;
};

TSHState.prototype.getUseSsl = function getUseSsl () {
  return this._ssl;
};

// Override me
TSHState.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
  return true;
};

TSHState.prototype.onEnter = function onEnter () {
  if (!this.validateLegal()) {
    if (this._nextState && this._exitCallback) {
      this._exitCallback(this._nextState, this._unsupportedRuntimeMessage);
    } else {
      LOG_WARN(((this._unsupportedRuntimeMessage) + ", no next state."));
    }
  }
};

TSHState.prototype.completeDowngrade = function completeDowngrade (err) {
  if (this._nextState && this._exitCallback) {
    LOG_INFO(("Connect failed (" + err + "), try next state."));
    this._exitCallback(this._nextState, 'Connect failed');
    return true;
  }
  LOG_WARN(("Connect failed (" + err + "), no next state."));
  return false;
};

TSHState.prototype.toString = function toString () {
  return this._transportProtocol + (this._ssl ? ' (SSL)' : '');
};

module.exports.TSHState = TSHState;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var HTTPLib = __webpack_require__(85);
var ref = __webpack_require__(146);
var WebSocketTransportSession = ref.WebSocketTransportSession;

var HTTPConnection = HTTPLib.HTTPConnection;

var WebTransportCapabilities = {
  webSocket: function webSocket() { return WebSocketTransportSession.browserSupportsBinaryWebSockets(); },
  xhrBinary: function xhrBinary() { return HTTPConnection.browserSupportsXhrBinary(); },
  streaming: function streaming() { return HTTPConnection.browserSupportsStreamingResponse(); },
};

module.exports.WebTransportCapabilities = WebTransportCapabilities;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(25);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(26);
var DestinationUtil = ref$1.DestinationUtil;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instances from
 * one of the following:</b>
 * * {@link solace.SolclientFactory.createTopicDestination}
 * * {@link solace.SolclientFactory.createDurableQueueDestination}
 * * {@link solace.MessageConsumer#getDestination}
 * * {@link solace.SDTField#getValue} when {@link solace.SDTField#getType} returns
 *   {@link solace.SDTFieldType.DESTINATION}.
 *
 * Represents a message destination.
 *
 * Publishers can send messages to topics or queues, to which subscribers can subscribe or
 * bind. A Destination specifies the target of such an operation.
 * @hideconstructor
 * @memberof solace
 */
var Destination = function Destination(spec, type) {
  if ( type === void 0 ) type = DestinationType.TOPIC;

  if (typeof spec === 'object') {
    this._name = spec.name;
    this._type = spec.type;
    this._bytes = spec.bytes;
    this._offset = spec.offset;
    if (spec.isValidated) {
      this._isValidated = true;
      this._isWildcarded = spec.isWildcarded;
    } else {
      this._isValidated = false;
    }
  } else {
    this._name = spec;
    this._type = type;

    // Don't validate encoding for deprecated construction path.
    // This path would have more restrictions now, and it allows
    // sdkperf a path for arbitrary topic construction.
    var result = DestinationUtil.encode(type, spec);
    this._bytes = result.bytes;
    this._offset = result.offset;
    this._isValidated = false;
  }
};

var prototypeAccessors = { name: {},type: {},bytes: {},offset: {} };

/**
 * @returns {String} The destination name specified at creation time.
 */
Destination.prototype.getName = function getName () {
  return this._name;
};

/**
 * @type {String}
 * @readonly
 */
prototypeAccessors.name.get = function () {
  return this.getName();
};

/**
 * @returns {solace.DestinationType} The destination type
 */
Destination.prototype.getType = function getType () {
  return this._type;
};

/**
 * @type {solace.DestinationType}
 * @readonly
 */
prototypeAccessors.type.get = function () {
  return this.getType();
};

/**
 * @returns {String} Returns the null-terminated UTF-8 encoded destination bytes.
 *
 * @private
 */
Destination.prototype.getBytes = function getBytes () {
  return this._bytes;
};
prototypeAccessors.bytes.get = function () {
  return this.getBytes();
};

Destination.prototype.getOffset = function getOffset () {
  return this._offset;
};
prototypeAccessors.offset.get = function () {
  return this.getOffset();
};

/**
 * This provides the legacy validation that was done post-creation and is used in some code paths
 * on use.It is preferred to use non-deprecated ways of creating destinations, which do
 * validation on create instead.
 * @throws OperationError if the destination is not valid.
 * @private
 */
Destination.prototype.validate = function validate () {
  if (this._isValidated) {
    if (this._error) { throw this._error; }
    return;
  }

  var ref =
    DestinationUtil.legacyValidate(this.type, this.bytes, this.name);
    var error = ref.error;
    var isWildcarded = ref.isWildcarded;
  this._isValidated = true;
  if (error) {
    this._error = error;
    throw error;
  }
  this._isWildcarded = isWildcarded;
};

/**
 * This is really only useful for topics.If a queue name contains a wildcarded construct, it is
 * up to the router what to do -- it would either reject it or treat the wildcard as literal.But
 * it is included here for all destination types since we have the info.
 * @returns {Boolean} True if the underlying name represents a wildcarded topic; false otherwise.
 * @throws {OperationError} If the destination is not valid.
 * @private
 */
Destination.prototype.isWildcarded = function isWildcarded () {
  this.validate();
  return this._isWildcarded;
};

/**
 * @returns {String} A generic description of the Destination.
 */
Destination.prototype.toString = function toString () {
  return util.inspect(this);
};

/**
 * @param {*} other The other object for comparison
 * @returns {Boolean} True if the passed destination is the same
 * @private
 */
Destination.prototype.equals = function equals (other) {
  if (!(other instanceof Destination)) {
    return false;
  }
  return (this.toString().valueOf() === other.toString().valueOf());
};

Object.defineProperties( Destination.prototype, prototypeAccessors );

module.exports.Destination = Destination;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Defines an error subcode enumeration which is returned as a property of
 * the errors/exceptions thrown by the API. The subcode provides more detailed
 * error information.
 *
 * The following subcodes can apply to error responses resulting from
 * any API method.
 * * {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}
 * * {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 * * {@link solace.ErrorSubcode.INTERNAL_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var ErrorSubcode = {
  /////////////
  // SESSION //
  /////////////
  /**
   * Errors that do not have a proper subcode.
   */
  UNKNOWN_ERROR:                                 0xFFFFFFFF,
  /**
   * No error is associated with this event.
   */
  NO_ERROR:                                      0,
  /**
   * The session is already connected.
   */
  // SESSION_ALREADY_CONNECTED: 1,
  /**
   * The session is not connected.
   */
  SESSION_NOT_CONNECTED:                         2,
  /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   * @deprecated Use {@link solace.ErrorSubCode.INVALID_OPERATION}
   */
  INVALID_SESSION_OPERATION:                     3,
  /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   */
  INVALID_OPERATION:                             3,
  /**
   * An API call failed due to a timeout.
   */
  TIMEOUT:                                       4,
  /////////////////
  // MESSAGE VPN //
  /////////////////
  /**
   * The Message VPN name configured for the session is not
   * configured to allow access for the session's username.
   *
   * Causes:
   *  * 403 Message VPN Not Allowed
   */
  MESSAGE_VPN_NOT_ALLOWED:                       5,
  /**
   * The Message VPN name set for the session (or the default VPN if none
   * was set) is currently shutdown on the router.
   *
   * Causes:
   *  * 503 Message VPN Unavailable
   */
  MESSAGE_VPN_UNAVAILABLE:                       6,
  ////////////
  // CLIENT //
  ////////////
  /**
   * The username for the client is administratively shutdown
   * on the router.
   *
   * Causes:
   *  * 403 Client Username Is Shutdown
   */
  CLIENT_USERNAME_IS_SHUTDOWN:                   7,
  /**
   * The username for the session has not been set and dynamic
   * clients are not allowed.
   *
   * Causes:
   *  * 403 Dynamic Clients Not Allowed
   */
  DYNAMIC_CLIENTS_NOT_ALLOWED:                   8,
  /**
   * The session is attempting to use a client name that is
   * in use by another client, and the router is configured to reject the
   * new session.
   * A client name cannot be used by multiple clients in the same Message
   * VPN.
   *
   * Causes:
   *  * 403 Client Name Already In Use
   */
  CLIENT_NAME_ALREADY_IN_USE:                    9,
  /**
   * The client name chosen has been rejected as invalid by the router.
   *
   * Causes:
   *  * 400 Client Name Parse Error
   */
  CLIENT_NAME_INVALID:                           10,
  /**
   * The client login is not currently possible because a previous
   * instance of same client was being deleted.
   *
   * Causes:
   *  * 503 Subscriber Delete In Progress
   */
  CLIENT_DELETE_IN_PROGRESS:                     11,
  /**
   * The client login is not currently possible because the maximum
   * number of active clients on router has already been reached.
   *
   * Causes:
   *  * 503 Too Many Clients
   *  * 503 Too Many Connections for VPN
   */
  TOO_MANY_CLIENTS:                              12,
  /**
   * The client could not log into the router.
   *
   * Causes:
   *  * 401 error codes
   *  * 404 error codes
   *  * Failed to send a session setup message in the transport.
   */
  LOGIN_FAILURE:                                 13,
  //////////
  // VRID //
  //////////
  /**
   * An attempt was made to connect to the wrong IP address on
   * the router (must use CVRID if configured), or the router CVRID has
   * changed and this was detected on reconnect.
   *
   * Causes:
   *  * 403 Invalid Virtual Router Address
   */
  INVALID_VIRTUAL_ADDRESS:                       14,
  /////////
  // ACL //
  /////////
  /**
   * The client login to the router was denied because the
   * IP address/netmask combination used for the client is designated in the
   * ACL (Access Control List) profile associated with that client.
   *
   * Causes:
   *  * 403 Forbidden
   */
  CLIENT_ACL_DENIED:                             15,
  /**
   * Adding a subscription was denied because it matched a
   * subscription that was defined as denied on the ACL (Access Control List)
   * profile associated with the client.
   *
   * Causes:
   *  * 403 Subscription ACL Denied
   */
  SUBSCRIPTION_ACL_DENIED:                       16,
  /**
   * A message could not be published because its topic matched
   * a topic defined as denied on the ACL (Access Control List) profile
   * associated with the client.
   *
   * Causes:
   *  * 403 Publish ACL Denied
   */
  PUBLISH_ACL_DENIED:                            17,
  ////////////////
  // VALIDATION //
  ////////////////
  /**
   * An API call was made with an out-of-range parameter.
   */
  PARAMETER_OUT_OF_RANGE:                        18,
  /**
   * An API call was made with a parameter combination
   * that is not valid.
   */
  PARAMETER_CONFLICT:                            19,
  /**
   * An API call was made with a parameter of incorrect type.
   */
  PARAMETER_INVALID_TYPE:                        20,
  //////////////////
  // FATAL ERRORS //
  //////////////////
  /**
   *  An API call had an internal error (not an application fault).
   */
  INTERNAL_ERROR:                                21,
  /**
   * An API call failed due to insufficient space in the transport
   * buffer to accept more data. After an insufficient space error, the
   * listeners on the {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}
   * event are notified when it is possible to retry the failed operation.
   */
  INSUFFICIENT_SPACE:                            22,
  /**
   * The message router has rejected the request. All available
   * resources of the requested type are in use.
   *
   * Causes:
   *  * 400 Not Enough Space
   */
  OUT_OF_RESOURCES:                              23,
  /**
   * An API call failed due to a protocol error with the router
   * (not an application fault).
   */
  PROTOCOL_ERROR:                                24,
  /**
   * An API call failed due to a communication error. This typically indicates the
   * transport connection to the message router has been unexpectedly closed.
   */
  COMMUNICATION_ERROR:                           25,
  ////////////////
  // KEEP ALIVE //
  ////////////////
  /**
   * The session keep-alive detected a failed session.
   */
  KEEP_ALIVE_FAILURE:                            26,
  /////////////////////
  // MESSAGE RELATED //
  /////////////////////
  /**
   * An attempt was made to use a topic which is longer
   * than the maximum that is supported.
   */
  // TOPIC_TOO_LARGE: 27,
  /**
   * A send call was made that did not have a topic in a mode
   * where one is required (for example, client mode).
   */
  TOPIC_MISSING:                                 28,
  /**
   *  An attempt was made to send a message with a total
   * size greater than that supported by the protocol. (???)
   */
  //  MAX_TOTAL_MSGSIZE_EXCEEDED: 29,
  /**
   * An attempt was made to send a message with user data larger
   * than the maximum that is supported.
   */
  // USER_DATA_TOO_LARGE: 30,
  /**
   * An attempt was made to use a topic which has a syntax that
   * is not supported.
   *
   * Causes:
   *  * 400 Topic Parse Error
   */
  INVALID_TOPIC_SYNTAX:                          31,
  /**
   * The client attempted to send a message larger than that
   * supported by the router.
   *
   * Causes:
   *  * 400 Document Is Too Large
   *  * 400 Message Too Long
   */
  MESSAGE_TOO_LARGE:                             32,
  /**
   * The router could not parse an XML message.
   *
   * Causes:
   *  * 400 XML Parse Error
   */
  XML_PARSE_ERROR:                               33,
  ///////////////////
  // SUBSCRIPTIONS //
  ///////////////////
  /**
   * The client attempted to add a subscription that already
   * exists. This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Already Exists)
   */
  SUBSCRIPTION_ALREADY_PRESENT:                  34,
  /**
   * The client attempted to remove a subscription which did not exist.
   * This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Not Found)
   */
  SUBSCRIPTION_NOT_FOUND:                        35,
  /**
   * The client attempted to add/remove a subscription that
   * is not valid.
   *
   * Causes:
   *  * 400 Subscription Parse Error
   */
  SUBSCRIPTION_INVALID:                          36,
  /**
   * The router rejected a subscription add or remove request
   * for a reason not separately enumerated.
   */
  SUBSCRIPTION_ERROR_OTHER:                      37,
  /**
   * The client attempted to add a subscription that
   * exceeded the maximum number allowed.
   *
   * Causes:
   *  * 400 Max Num Subscriptions Exceeded
   */
  SUBSCRIPTION_TOO_MANY:                         38,
  /**
   *  The client attempted to add a subscription which already
   * exists but it has different properties.
   *
   * Causes:
   *  * 400 Subscription Attributes Conflict With Existing Subscription
   */
  SUBSCRIPTION_ATTRIBUTES_CONFLICT:              39,
  /**
   * The client attempted to establish a session with No Local
   * enabled and the capability is not supported by the router.
   */
  NO_LOCAL_NOT_SUPPORTED:                        40,
  ////////////////////
  // UNKNOWN ERRORS //
  ////////////////////
  /**
   * The router rejected a control message for another reason
   * not separately enumerated.
   */
  // CONTROL_ERROR_OTHER: 41,
  /**
   * The router rejected a data message for a reason
   * not separately enumerated.
   */
  DATA_ERROR_OTHER:                              42,
  //////////////////////
  // TRANSPORT ERRORS //
  //////////////////////
  /**
   * Failed to create the HTTP connection.
   */
  CREATE_XHR_FAILED:                             43,
  /**
   * Failed to create the transport.
   */
  CONNECTION_ERROR:                              44,
  /**
   * Failed to decode the data.
   */
  DATA_DECODE_ERROR:                             45,
  /**
   * @deprecated
   * The session was inactive for too long.
   *
   * Causes:
   * * 400 Inactivity Timeout
   */
  INACTIVITY_TIMEOUT:                            46,
  /**
   * @deprecated
   * The router does not know this session's identifier.
   *
   * Causes:
   * * 400 Unknown Transport Session Identfier
   */
  UNKNOWN_TRANSPORT_SESSION_ID:                  47,
  /**
   * @deprecated This subcode is not used since 10.0.0.
   * Guaranteed Messages (with a delivery mode other than DIRECT) are not supported.
   */
  AD_MESSAGING_NOT_SUPPORTED:                    48,
  /**
   * @deprecated
   * Creating the WebSocket transport failed.
   */
  CREATE_WEBSOCKET_FAILED:                       49,
  /**
   * An attempt to perform an operation using a VPN that is configured to be
   * STANDBY for replication.
   *
   * Causes:
   * * 403 Replication Is Standby
   */
  REPLICATION_IS_STANDBY:                        50,
  ////////////////////
  // Authentication //
  ////////////////////
  /**
   * Basic authentication is administratively shut down on the
   * router.
   *
   * Causes:
   *  * 403 Basic Authentication is Shutdown
   */
  BASIC_AUTHENTICATION_IS_SHUTDOWN:              51,
  /**
   * Client certificate authentication is administratively
   * shut down on the router.
   *
   * Causes:
   *  * 403 Client Certificate Authentication Is Shutdown
   */
  CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN: 52,
  //////////////////////
  // Guaranteed Messaging //
  //////////////////////
  /**
   * Guaranteed Messaging services are not enabled on the router.
   *
   * Causes:
   *  * 503 Service Unavailable
   */
  GM_UNAVAILABLE:                                100,
  /**
   * The session attempted to connect to a Guaranteed Message Publisher
   * that does not exist on this router.
   * All unacked messages held by the API are renumbered and redelivered. This subCode
   * is handled internally and will not be seen by the application. After successfully
   * renumbereing and redelivering the messages, if any messages are resent, listeners
   * on the @{link solace.SessionEventCode#event:REPUBLISHING_UNACKED_MESSAGES} event are
   * invoked.
   *
   * Causes:
   * * 400 Unknown Flow Name
   * @private
   */
  UNKNOWN_FLOW_NAME:                             111,
  /**
   * Already bound to the Queue or not authorized to bind to the Queue.
   *
   * Causes:
   *  * 400 Already Bound
   */
  ALREADY_BOUND:                                 112,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint with an
   * invalid topic.
   *
   * Causes:
   *  * 400 Invalid Topic Name
   */
  INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT:         113,
  /**
   * An attempt was made to bind to an unknown Queue name (for example, not
   * configured on the router).
   *
   * Causes:
   *  * 503 Unknown Queue
   */
  UNKNOWN_QUEUE_NAME:                            114,
  /**
   * An attempt was made to perform an operation on an unknown Guaranteed Messaging
   * Topic Endpoint name (for example, not configured on router).
   *
   * Causes:
   *  * 503 Unknown Durable Topic Endpoint
   */
  UNKNOWN_TOPIC_ENDPOINT_NAME:                   115,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Queue that has already reached
   * its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for Queue
   */
  MAX_CLIENTS_FOR_QUEUE:                         116,
  /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint that has already
   * reached its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for durable Topic Endpoint
   */
  MAX_CLIENTS_FOR_TE:                            117,
  /**
   * An unexpected unbind response was received for a Guaranteed Messaging Queue or Topic
   * Endpoint (for example, the Queue or Topic Endpoint was deleted from the router).
   */
  UNEXPECTED_UNBIND:                             118,
  /**
   * The specified Guaranteed Messaging Queue was not found when publishing a message.
   *
   * Causes:
   *  * 400 Queue Not Found
   */
  QUEUE_NOT_FOUND:                               119,
  /**
   * Message was not delivered because the Guaranteed Message spool is over its
   * allotted space quota.
   *
   * Causes:
   *  * 503 Spool Over Quota
   */
  SPOOL_OVER_QUOTA:                              120,
  /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging queue.
   *
   * Causes:
   *  * 503 Queue Shutdown
   */
  QUEUE_SHUTDOWN:                                121,
  /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging Topic Endpoint.
   *
   * Causes:
   *  * 503 Durable Topic Endpoint Shutdown
   *  * 503 TE Shutdown
   *  * 503 Endpoint Shutdown
   */
  TOPIC_ENDPOINT_SHUTDOWN:                       122,
  /**
   * An attempt was made to bind to a non-durable Guaranteed Messaging Queue or Topic
   * Endpoint, and the router is out of resources.
   *
   * Causes:
   *  * 503 No More Non-Durable Queue or Topic Endpoint
   */
  NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT:   123,
  /**
   * An attempt was made to create a Queue or Topic Endpoint that already exists.
   * This subcode is only returned if
   * {@link solace.SessionProperties.ignoreProvisionEndpointExists} was not set for the current
   * session.
   *
   * Causes:
   *  * 400 Endpoint Already Exists
   */
  ENDPOINT_ALREADY_EXISTS:                       124,
  /**
   * An attempt was made to delete or create a Queue or Topic Endpoint when the
   * Session does not have authorization for the action. This subcode is also returned when an
   * attempt is made to remove a message from an endpoint when the Session does not have 'consume'
   * authorization, or when an attempt is made to add or remove a Topic subscription from a Queue
   * when the Session does not have 'modify-topic' authorization.
   *
   * Causes:
   *  * 403 Permission Not Allowed
   */
  PERMISSION_NOT_ALLOWED:                        125,
  /**
   * An attempt was made to bind to a Queue or Topic Endpoint with an invalid
   * selector.
   *
   * Causes:
   *  * 400 Invalid Selector
   */
  INVALID_SELECTOR:                              126,
  /**
   * Publishing the message was denied due to exceeding the maximum spooled message
   * count.
   *
   * Causes:
   *  * 503 Max message usage exceeded
   */
  MAX_MESSAGE_USAGE_EXCEEDED:                    127,
  /**
   * An attempt was made to create a dynamic durable endpoint, and it was found to
   * exist with different properties.
   *
   * Causes:
   *  * 400 Endpoint Property Mismatch
   */
  ENDPOINT_PROPERTY_MISMATCH:                    128,
  /**
   * The client attempted to publish an Guaranteed Messaging message to a topic that
   * did not have any guaranteed subscription matches, or only matched a replicated topic.
   *
   * Causes:
   *  * 503 No Subscription Match
   */
  NO_SUBSCRIPTION_MATCH:                         129,
  /**
   * The application attempted to acknowledge a message that arrived via a delivery
   * mode that does not allow acknowledgements.
   */
  MESSAGE_DELIVERY_MODE_MISMATCH:                130,
  /**
   * The message was already acknowledged.
   */
  MESSAGE_ALREADY_ACKNOWLEDGED:                  131,

  /**
   * The API-supplied subscription did not match when attempting to bind to a
   * non-exclusive durable topic endoint.
   *
   * Causes:
   *  * 403 Subscription Does Not Match
   */
  SUBSCRIPTION_DOES_NOT_MATCH:           133,
  /**
   * The API-supplied selector did not match when attempting to bind to a
   * non-exclusive durable topic endpoint.
   *
   * Causes:
   *  * 403 Selector Does Not Match
   */
  SELECTOR_DOES_NOT_MATCH:               134,
  /**
   * The subscriber has provided an incorrectly formatted durable topic endpoint name.
   *
   * Causes:
   *  * 400 Invalid Durable Topic Endpoint Name
   */
  INVALID_DTE_NAME:                      135,
  /**
   * The unsubscribe request was denied by the router because the durable topic endpoint
   * had one or more clients bound.
   *
   * Causes:
   *  * 400 Unsubscribe Not Allowed, Client(s) Bound To DTE
   */
  UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND: 136,
  /**
   * An application callback threw an error back to the API. The reason property describes
   * the error that occurred.
   */
  CALLBACK_ERROR:                        137,
  /**
   * A published message was discarded by the router because it will not be published
   * anywhere based on the NoLocal properties. This can be considered normal.
   *
   * Causes:
   * * 400 Nolocal Discard
   */
  NOLOCAL_DISCARD:                       138,
  /**
   * The operation is delayed because Guaranteed Messaging is not ready on the router.
   *
   * Causes:
   * 507 Ad Not Ready
   */
  GM_NOT_READY:                          140,
  /**
   * The message was rejected because one or more matching endpoints'
   * reject-low-priority-msg-limit was exceeded.
   *
   * Causes:
   * * 503 Low Priority Msg Congestion
   */
  LOW_PRIORITY_MSG_CONGESTION:           141,
  /**
   * The specified endpoint quota was out of range.
   *
   * Causes:
   * 400 Quota Out Of Range
   */
  QUOTA_OUT_OF_RANGE:                    142,
  /**
   * Unable to load the certificate from the TrustStore for a SSL
   * secured session.
   */
  FAILED_LOADING_TRUSTSTORE:             143,
  /**
   * The client failed to load certificate and/or private key files.
   */
  FAILED_LOADING_CERTIFICATE_AND_KEY:    144,
  /**
   * DNS resolution failed for all hostnames.
   */
  UNRESOLVED_HOSTS:                      145,
};

module.exports.ErrorSubcode = Enum.new(ErrorSubcode);


/***/ }),
/* 52 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * The base class for all errors thrown by the API.
 * @hideconstructor
 * @extends {Error}
 *
 * @memberof solace
 */
var SolaceError = (function (Error) {
  function SolaceError(type, message, constructor) {
    Error.call(this, message || '');
    /**
     * Error Message.
     * @name solace.SolaceError#message
     * @type {String}
     */
    this.message = message; // force set
    /**
     * The name of the error.
     * @name solace.SolaceError#name
     * @type {String}
     */
    this.name = type;

    // ES6 error semantics are disappointing
    // Cleaner stack capture for V8-based VMs
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, constructor);
    } else {
      this.stack = new Error().stack;
    }
  }

  if ( Error ) SolaceError.__proto__ = Error;
  SolaceError.prototype = Object.create( Error && Error.prototype );
  SolaceError.prototype.constructor = SolaceError;

  return SolaceError;
}(Error));

module.exports.SolaceError = SolaceError;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * Events on the Consumer FSM
 * @enum {string}
 ********************************************************************************/
var ConsumerFSMEventNames = {
  SESSION_UP:                 'SESSION_UP',
  SESSION_UP_NO_AD:           'SESSION_UP_NO_AD',
  SESSION_DOWN:               'SESSION_DOWN',
  SESSION_DISCONNECT:         'SESSION_DISCONNECT',
  FLOW_FAILED:                'FLOW_FAILED',
  FLOW_UP:                    'FLOW_UP',
  FLOW_ACTIVE_IND:            'FLOW_ACTIVE_IND',
  FLOW_CLOSE:                 'FLOW_CLOSE',
  FLOW_OPEN:                  'FLOW_OPEN',
  FLOW_UNBOUND:               'FLOW_UNBOUND',
  ACK:                        'ACK',
  ACK_TIMEOUT:                'ACK_TIMEOUT',
  BIND_TIMEOUT:               'BIND_TIMEOUT',
  UNBIND_TIMEOUT:             'UNBIND_TIMEOUT',
  CAN_SEND:                   'CAN_SEND',
  TRANSPORT_ERROR:            'TRANSPORT_ERROR',
  DISPOSE:                    'DISPOSE',
  VIRTUALROUTER_NAME_CHANGED: 'VIRTUALROUTER_NAME_CHANGED',
};

module.exports.ConsumerFSMEventNames = Enum.new(ConsumerFSMEventNames);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(15);
var FsmEvent = ref.FsmEvent;

/**
 *
 * ConsumerFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the Subscriber FSM.  This extension provides members to carry information specfic to
 * the Subscriber FSM transitions.
 *
 * @extends FsmEvent
 * @private
 */
var ConsumerFSMEvent = (function (FsmEvent) {
  function ConsumerFSMEvent(spec, details) {
    FsmEvent.call(this, spec);
    this.details = details;
  }

  if ( FsmEvent ) ConsumerFSMEvent.__proto__ = FsmEvent;
  ConsumerFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  ConsumerFSMEvent.prototype.constructor = ConsumerFSMEvent;

  return ConsumerFSMEvent;
}(FsmEvent));

module.exports.ConsumerFSMEvent = ConsumerFSMEvent;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * The publisher currently isn't exposed, and its events are dispatched
 * via the Session. These events are therefore private. They should
 * be moved to MessageConsumerEventName when they are made public.
 * @private
 */
var MessagePublisherEventName = Enum.new({
  ACKNOWLEDGED_MESSAGE:      'MessagePublisherEventName_acknowledgedMessage',
  CONNECT_FAILED_ERROR:      'MessagePublisherEventName_connectFailedError',
  CAN_SEND:                  'MessagePublisherEventName_canSend',
  DISPOSED:                  'MessagePublisherEventName_disposed',
  DOWN:                      'MessagePublisherEventName_down',
  FLOW_NAME_CHANGED:         'MessagePublisherEventName_flowNameChanged',
  GUARANTEED_MESSAGING_DOWN: 'MessagePublisherEventName_guaranteedMessagingDown',
  REJECTED_MESSAGE:          'MessagePublisherEventName_rejectedMessage',
  DISCONNECT_FAILED_ERROR:   'MessagePublisherEventName_disconnectFailedError',
  UP:                        'MessagePublisherEventName_up',
  TRANSPORT_FULL:            'MessagePublisherEventName_transportFull',
});

module.exports.MessagePublisherEventName = MessagePublisherEventName;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * Events on the Publisher FSM
 * @enum {string}
 ********************************************************************************/
var PublisherFSMEventNames = {
  SESSION_UP:       'PublisherSessionUp',
  SESSION_UP_NO_AD: 'PublisherSessionUpNoAD',
  SESSION_DOWN:     'PublisherSessionDown',
  FLOW_FAILED:      'MessagePublisherFailed',
  FLOW_UP:          'MessagePublisherUp',
  FLOW_CLOSE:       'MessagePublisherClose',
  FLOW_UNBOUND:     'MessagePublisherUnbound',
  TRANSPORT_FULL:   'PublisherTransportFull',
  ACK:              'PublisherAck',
  ACK_TIMEOUT:      'PublisherAckTimeout',
  BIND_TIMEOUT:     'PublisherBindTimeout',
  UNBIND_TIMEOUT:   'PublisherUnbindTimeout',
  CAN_SEND:         'PublisherCanSend',
  TRANSPORT_ERROR:  'PublisherTransportError',
  RESEND_COMPLETE:  'PublisherResendComplete',
  DISPOSE:          'PublisherDispose',
};

module.exports.PublisherFSMEventNames = Enum.new(PublisherFSMEventNames);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(15);
var FsmEvent = ref.FsmEvent;

/**
 *
 * PublisherFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends {FsmEvent}
 * @private
 */
var PublisherFSMEvent = (function (FsmEvent) {
  function PublisherFSMEvent(spec, details, smfmessage) {
    FsmEvent.call(this, spec);
    Object.assign(this, details);
    Object.assign(this, smfmessage);
  }

  if ( FsmEvent ) PublisherFSMEvent.__proto__ = FsmEvent;
  PublisherFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  PublisherFSMEvent.prototype.constructor = PublisherFSMEvent;
  PublisherFSMEvent.prototype.getEventText = function getEventText () {
    return this._eventText;
  };

  return PublisherFSMEvent;
}(FsmEvent));

module.exports.PublisherFSMEvent = PublisherFSMEvent;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An attribue of a {@link solace.Message}. Applications receive messages due to subscriptions on
 * topics, or consumers connected to durable objects.  The MessageCacheStatus of such messages is:
 * {@link solace.MessageCacheStatus.LIVE}.
 *
 * Message are also delivered to an application
 * as a result of a cache request (see {@link solace.CacheSession#sendCacheRequest}) which
 * have a MessageCacheStatus that is {@link solace.MessageCacheStatus.CACHED} or
 * {@link solace.MessageCacheStatus.SUSPECT}.
 *
 * The MessageCacheStatus is retrieved with {@link solace.Message#getCacheStatus}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageCacheStatus = {
  /**
   * The message is live.
   * @type {Number}
   */
  LIVE:    0,
  /**
   * The message was retrieveed from a solCache Instance.
   * @type {Number}
   */
  CACHED:  1,
  /**
   * The message was retrieved from a suspect solCache Instance.
   * @type {Number}
   */
  SUSPECT: 2,

};

module.exports.MessageCacheStatus = Enum.new(MessageCacheStatus);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message delivery modes.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageDeliveryModeType = {
  /**
   * This mode provides at-most-once message delivery. Direct messages have
   * the following characteristics:
   *   * They are not retained for clients that are not connected to a Solace Message Router.
   *   * They can be discarded when congestion or system failures are encountered.
   *   * They can be reordered in the event of network topology changes.
   *
   * Direct messages are most appropriate for messaging applications that require very
   * high-rate or very low-latency message transmission. Direct Messaging enables
   * applications to efficiently publish messages to a large number of clients
   * with matching subscriptions.
   */
  DIRECT:         0,
  /**
   * A Persistent delivery mode is used for Guaranteed Messaging, and this delivery mode
   * is most appropriate for applications that require persistent storage of the messages
   * they send or intend to receive. Persistent messages have the following characteristics:
   *
   *  * They cannot be discarded or lost (once they are acknowledged by the Solace Message Router).
   *  * They cannot be reordered in the event of network topology changes.
   *  * They cannot be delivered more than once to a single client (unless the redelivered
   *    message flag is applied).
   *  * When they match subscriptions on durable endpoints, they are retained for a client
   *    when that client is not connected.
   *
   * Persistent messages are most appropriate for applications that require persistent storage
   * of the messages they send or intend to receive.
   */
  PERSISTENT:     1,
  /**
   * This mode is functionally the same as Persistent. It exists to facilitate interaction
   * with JMS applications. In most situations where you want to use Guaranteed Messaging,
   * it is recommended that you use {@link solace.MessageDeliveryModeType.PERSISTENT}.
   */
  NON_PERSISTENT: 2,
};

module.exports.MessageDeliveryModeType = Enum.new(MessageDeliveryModeType);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var MessageDumpStandardProviderLib = __webpack_require__(103);
var ref = __webpack_require__(10);
var SDTFieldType = ref.SDTFieldType;
var SDTMapContainer = ref.SDTMapContainer;
var SDTStreamContainer = ref.SDTStreamContainer;
var SDTUnsupportedValueError = ref.SDTUnsupportedValueError;
var SDTValueErrorSubcode = ref.SDTValueErrorSubcode;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var OperationError = ref$2.OperationError;
var ref$3 = __webpack_require__(40);
var MessageDumpFlag = ref$3.MessageDumpFlag;
var ref$4 = __webpack_require__(4);
var StringBuffer = ref$4.StringBuffer;
var StringUtils = ref$4.StringUtils;

var MessageDumpState = {
  get dumpProviders() {
    var providers = MessageDumpStandardProviderLib.MessageDumpStandardProvider;
    return Object.keys(providers).map(function (k) { return providers[k]; });
  },
};

var MessageDumpUtil = {
  getOutOfRangeValue: function getOutOfRangeValue(rawData) {
    return ("<out of range>\n" + (DebugLib.Debug.formatDumpBytes(rawData)));
  },

  getValue: function getValue(sdtField) {
    var value = null;
    try {
      value = sdtField.getValue();
      return value;
    } catch (e) {
      if (e instanceof SDTUnsupportedValueError) {
        if (e.getSubcode() === SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE) {
          return this.getOutOfRangeValue(e.getSourceData());
        }
      } else if (e instanceof OperationError && e.subcode === ErrorSubcode.PARAMETER_INVALID_TYPE) {
        return '<invalid type>';
      }
      throw e;
    }
  },

  printMap: function printMap(sdtMap, indent) {
    var this$1 = this;

    if (Check.nothing(sdtMap) || !(sdtMap instanceof SDTMapContainer)) {
      return null;
    }
    var lines = [];
    var strIndent = StringUtils.padRight('', indent, ' ');
    var keys = sdtMap.getKeys().sort();
    keys.forEach(function (key) {
      var sdtFieldValue = sdtMap.getField(key);
      var type = sdtFieldValue.getType();
      var value = this$1.getValue(sdtFieldValue);
      var strValue;
      switch (type) {
        case SDTFieldType.MAP:
          strValue = "\n" + (this$1.printMap(value, indent + 2));
          break;
        case SDTFieldType.STREAM:
          strValue = "\n" + (this$1.printStream(value, indent + 2));
          break;
        case SDTFieldType.BYTEARRAY:
          strValue = DebugLib.Debug.formatDumpBytes(value, false, 0);
          if (strValue !== null && strValue.substr(-1) === '\n') {
            strValue = strValue.substring(0, strValue.length - 1);
          }
          break;
        default:
          strValue = (value !== null) ? value.toString() : null;
      }
      lines.push((strIndent + "Key '" + key + "' (" + (SDTFieldType.nameOf(type)) + "): " + strValue));
    });
    return lines.join('\n');
  },

  printStream: function printStream(sdtStream, indent) {
    var this$1 = this;

    if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
      return null;
    }
    sdtStream.rewind();
    var lines = [];
    var strIndent = StringUtils.padRight('', indent, ' ');
    while (sdtStream.hasNext()) {
      var sdtFieldValue = sdtStream.getNext();
      var type = sdtFieldValue.getType();
      var value = this$1.getValue(sdtFieldValue);

      var strValue = (void 0);
      switch (type) {
        case SDTFieldType.MAP:
          strValue = "\n" + (this$1.printMap(value, indent + 2));
          break;
        case SDTFieldType.STREAM:
          strValue = "\n" + (this$1.printStream(value, indent + 2));
          break;
        case SDTFieldType.BYTEARRAY:
          strValue = DebugLib.Debug.formatDumpBytes(value, false, 0);
          if (strValue !== null && strValue.substr(-1) === '\n') {
            strValue = strValue.substring(0, strValue.length - 1);
          }
          break;
        case SDTFieldType.DESTINATION:
          strValue = value.toString();
          break;
        default:
          strValue = (value !== null) ? value.toString() : null;
      }
      lines.push((strIndent + "(" + (SDTFieldType.nameOf(type)) + "): " + strValue));
    }
    sdtStream.rewind();
    return lines.join('\n');
  },

  countItems: function countItems(sdtStream) {
    if (Check.nothing(sdtStream) || (!(sdtStream instanceof SDTStreamContainer))) {
      return 0;
    }
    sdtStream.rewind();
    var count = 0;
    while (sdtStream.hasNext()) {
      sdtStream.getNext();
      count++;
    }
    sdtStream.rewind();
    return count;
  },

  formatDate: function formatDate(timeStamp) {
    return new Date(timeStamp).toString();
  },

  dump: function dump(message, flags, separator, colPadding) {
    var sb = new StringBuffer();
    var theSeparator = '\n';
    var needSeparator = false;
    var theColPadding = 40;
    if (separator !== undefined && separator !== null && typeof separator === 'string') {
      theSeparator = separator;
    }
    if (colPadding !== undefined && colPadding !== null && typeof colPadding === 'number') {
      theColPadding = colPadding;
    }

    MessageDumpState.dumpProviders.forEach(function (provider, index) {
      var ref = provider(message, flags);
      var key = ref[0];
      var isPresent = ref[1];
      var value = ref[2];
      var detailValue = ref[3];
      if (!isPresent) {
        return;
      }
      if (needSeparator) {
        sb.append(theSeparator);
      }

      if (value === null || value.length === 0) {
        // If we have no VALUE field, this is probably a boolean flag
        // and we just end up displaying the key and a newline.
        sb.append(key);
      } else {
        sb.append(StringUtils.padRight((key + ":"), theColPadding, ' '));
        sb.append(value);
      }

      if (detailValue !== null && (flags & MessageDumpFlag.MSGDUMP_FULL)) {
        sb.append('\n');
        if (detailValue.indexOf('  ') !== 0) {
          sb.append('  ');
        }
        sb.append(detailValue);
        if (detailValue.substr(-1) !== '\n' && index < (MessageDumpState.dumpProviders.length - 1)) {
          sb.append('\n');
        }
      }
      needSeparator = true;
    });
    return sb.toString();
  },
};

module.exports.MessageDumpUtil = MessageDumpUtil;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of user Class of Service (COS) levels. The COS is set
 * on a Message with {@link solace.Message#setUserCos}
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.  {@link solace.MessageUserCosType.COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageUserCosType = {
  /**
   * Direct Messages: Lowest priority, use Solace Message Router client D-1 queues for delivery.
   *
   * Guaranteed Messages: Messages can be rejected if the message would cause any
   * queue or topic-endpoint to exceed it's configured <i>low-prioriity-max-msg-count</i>.
   * @type {Number}
   */
  COS1: 0,
  /**
   * Direct Messages: Medium priority, use Solace Message Router client D-2 queues for delivery.
   *
   * Guaranteed Messages: N/A (same as COS3)
   * @type {Number}
   */
  COS2: 1,
  /**
   * Direct Messages: Highest priority, use Solace Message Router client D-3 queues for delivery.
   *
   * Guaranteed Messages: Messages are not rejected for exceeding <i>low-priority-max-msg-count</i>.
   * Messages may still be rejected for other reasons such as Queue 'Spool Over Quota'.
   * @type {Number}
   */
  COS3: 2,
};

module.exports.MessageUserCosType = Enum.new(MessageUserCosType);


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents the possible endpoint access types. The corresponding endpoint property is
 * {@link solace.QueueProperties#accessType}.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueAccessType = {
  /**
   * @description An exclusive endpoint. The first client to bind
   * receives the stored messages on the Endpoint.
   * @type {String}
   */
  EXCLUSIVE:    'EXCLUSIVE',
  /**
   * @description A non-exclusive (shared) Queue. Each client to bind
   * receives messages in a round robin fashion.
   * @type {String}
   */
  NONEXCLUSIVE: 'NONEXCLUSIVE',
};

module.exports.QueueAccessType = Enum.new(QueueAccessType);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumerates the behavior options when a message cannot be added to an endpoint
 * (for example, the maximum quota {@link solace.QueueProperties#quotaMB} was exceeded).
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueDiscardBehavior = {
  /**
   * @description Send the publisher a message reject notification.
   * @type {String}
   */
  NOTIFY_SENDER_ON:  'NOTIFY_SENDER_ON',
  /**
   * @description Discard the message and acknowledge it.
   * @type {String}
   */
  NOTIFY_SENDER_OFF: 'NOTIFY_SENDER_OFF',
};

module.exports.QueueDiscardBehavior = Enum.new(QueueDiscardBehavior);


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents the permissions applicable to a queue.
 *
 * The corresponding endpoint property is
 * {@link solace.QueueProperties#permissions}.
 *
 * The access controls:
 *  * the permissions for all other users of the queue, this only applies to
 *  non-durable queues {@link solace.QueueProperties#permissions};
 *  * for the current Message Consumer  on a queue or endpoint,
 *    {@link solace.MessageConsumer.permissions}
 *
 * For example, creating a temporary topic endpoint with MODIFY_TOPIC will allow
 * other users to modify the topic subscribed to that endpoint.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueuePermissions = {
  /**
   * @description No client other than the queue's owner may access the endpoint.
   */
  NONE:         'NONE',
  /**
   * @description Client may read messages but not consume them.
   * @type {String}
   */
  READ_ONLY:    'READ_ONLY',
  /**
   * @description  Client may read and consume messages.
   * @type {String}
   */
  CONSUME:      'CONSUME',
  /**
   * @description Client may read and consume messages, and modify topic(s) associated with the
   * queue.
   * @type {String}
   */
  MODIFY_TOPIC: 'MODIFY_TOPIC',
  /**
   * @description Client may read and consume messages, modify topic(s) associated with the
   * queue, and delete the queue.
   * @type {String}
   */
  DELETE:       'DELETE',
};

module.exports.QueuePermissions = Enum.new(QueuePermissions);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Specifies the type of remote resource to which an
 * {@link solace.AbstractQueueDescriptor} refers.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
var QueueType = {
  /**
   * @description The queue descriptor refers to a queue endpoint.
   * @type {String}
   */
  QUEUE:          'QUEUE',
  /**
   * @description The queue descriptor refers to a topic endpoint.
   * @type {String}
   */
  TOPIC_ENDPOINT: 'TOPIC_ENDPOINT',
};

module.exports.QueueType = Enum.new(QueueType);


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(107);
var EncodeHeader = ref$1.EncodeHeader;
var ref$2 = __webpack_require__(201);
var EncodeInteger = ref$2.EncodeInteger;
var ref$3 = __webpack_require__(202);
var EncodeMap = ref$3.EncodeMap;
var ref$4 = __webpack_require__(203);
var EncodeStream = ref$4.EncodeStream;
var ref$5 = __webpack_require__(67);
var IEEE754LIB = ref$5.IEEE754LIB;
var ref$6 = __webpack_require__(30);
var SDTDataTypes = ref$6.SDTDataTypes;
var ref$7 = __webpack_require__(70);
var SDTDestType = ref$7.SDTDestType;
var ref$8 = __webpack_require__(12);
var SDTField = ref$8.SDTField;
var ref$9 = __webpack_require__(11);
var SDTFieldType = ref$9.SDTFieldType;
var ref$10 = __webpack_require__(4);
var StringUtils = ref$10.StringUtils;

var encodeHeader = EncodeHeader.encodeHeader;
var int48ToStr = EncodeInteger.int48ToStr;
var encodeMap = EncodeMap.encodeMap;
var encodeStream = EncodeStream.encodeStream;

var nullTerminate = StringUtils.nullTerminate;

var C_2_48 = Math.pow(2, 48);

// UCS-2 --> UTF-8 conversion
function strencode(data) {
  return unescape(encodeURIComponent(data));
}

// Encode an SDTField into provided buffer buf
function encodeSingleElementToBuf(sdtfield, buf) {
  if (!(sdtfield instanceof SDTField)) {
    return false;
  }
  // we write the header at the end, once we know the size
  var value = sdtfield.getValue();
  var fieldVal = null;
  var tag = 0; // SMF TAG
  switch (sdtfield.getType()) {
    case SDTFieldType.BOOL:
      tag = SDTDataTypes.Boolean;
      fieldVal = Convert.int8ToStr(value ? 1 : 0);
      break;
    case SDTFieldType.UINT8:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int8ToStr(value);
      break;
    case SDTFieldType.INT8:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int8ToStr(value);
      break;
    case SDTFieldType.UINT16:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int16ToStr(value);
      break;
    case SDTFieldType.INT16:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int16ToStr(value);
      break;
    case SDTFieldType.UINT32:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = Convert.int32ToStr(value);
      break;
    case SDTFieldType.INT32:
      tag = SDTDataTypes.Integer;
      fieldVal = Convert.int32ToStr(value);
      break;
    case SDTFieldType.UINT64:
      tag = SDTDataTypes.UnsignedInteger;
      fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
      break;
    case SDTFieldType.INT64:
      tag = SDTDataTypes.Integer;
      if (value >= 0) {
        fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
      } else {
        fieldVal = (String.fromCharCode(0xFF) +
                    String.fromCharCode(0xFF) +
                    int48ToStr(C_2_48 + value));
      }
      break;
    case SDTFieldType.WCHAR:
      tag = SDTDataTypes.Char;
      fieldVal = Convert.int16ToStr(value.charCodeAt(0));
      break;
    case SDTFieldType.STRING:
      tag = SDTDataTypes.String;
      fieldVal = nullTerminate(strencode(value));
      break;
    case SDTFieldType.BYTEARRAY:
      tag = SDTDataTypes.ByteArray;
      fieldVal = value;
      break;
    case SDTFieldType.FLOATTYPE:
      tag = SDTDataTypes.Float;
      fieldVal = IEEE754LIB.toIEEE754Single(value);
      break;
    case SDTFieldType.DOUBLETYPE:
      tag = SDTDataTypes.Float;
      fieldVal = IEEE754LIB.toIEEE754Double(value);
      break;
    case SDTFieldType.MAP:
      tag = SDTDataTypes.Map;
      fieldVal = encodeMap(value);
      break;
    case SDTFieldType.STREAM:
      tag = SDTDataTypes.Stream;
      fieldVal = encodeStream(value);
      break;
    case SDTFieldType.DESTINATION:
      tag = SDTDataTypes.Destination;
      if (value instanceof DestinationLib.Destination) {
        fieldVal = Convert.int8ToStr(SDTDestType[value.getType()])
          + value.getBytes();
      }
      break;
    case SDTFieldType.NULLTYPE:
      tag = SDTDataTypes.Null;
      fieldVal = '';
      break;
    case SDTFieldType.UNKNOWN:
      fieldVal = null;
      break;
    default:
  }
  if (fieldVal !== null) {
    var hdr = encodeHeader(tag, fieldVal.length);
    buf.push(hdr);
    buf.push(fieldVal);
    return true;
  }

  return false;
}

function encodeSingleElement(sdtfield) {
  var buf = [];
  encodeSingleElementToBuf(sdtfield, buf);
  return buf.join('');
}

var EncodeSingleElement = {
  encodeSingleElement: encodeSingleElement,
  encodeSingleElementToBuf: encodeSingleElementToBuf,
};

module.exports.EncodeSingleElement = EncodeSingleElement;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

var IEEE754LIB = {
  /**
   * @preserve
   * The MIT License
   *
   * Copyright (c) 2010 Alan Gutierrez
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  toIEEE754: function toIEEE754(vIn, ebits, fbits) {
    var v = vIn;
    var bias = (1 << (ebits - 1)) - 1;

    // Compute sign, exponent, fraction
    var s;
    var e;
    var f;
    if (isNaN(v)) {
      e = (1 << bias) - 1;
      f = 1;
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << bias) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = Math.abs(v);

      if (v >= Math.pow(2, 1 - bias)) {
        var ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
        e = ln + bias;
        f = (v * Math.pow(2, fbits - ln)) - Math.pow(2, fbits);
      } else {
        e = 0;
        f = v / Math.pow(2, 1 - bias - fbits);
      }
    }

    // Pack sign, exponent, fraction
    var bits = [];
    for (var i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = Math.floor(f / 2);
    }
    for (var i$1 = ebits; i$1; i$1 -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    var str = bits.join('');

    // Bits to bytes
    var bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  },

  fromIEEE754: function fromIEEE754(bytes, ebits, fbits) {
    // Bytes to bits
    var bits = [];
    for (var i = bytes.length; i; i -= 1) {
      var byteI = bytes[i - 1];
      for (var j = 8; j; j -= 1) {
        bits.push(byteI % 2 ? 1 : 0);
        byteI >>= 1;
      }
    }
    bits.reverse();
    var str = bits.join('');

    // Unpack sign, exponent, fraction
    var bias = (1 << (ebits - 1)) - 1;
    var s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    var e = parseInt(str.substring(1, 1 + ebits), 2);
    var f = parseInt(str.substring(1 + ebits), 2);

    // Produce number
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    }
    if (e > 0) {
      return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
    }
    if (f !== 0) {
      return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
    }
    return 0;
  },
  strToByteArr: function strToByteArr(str) {
    var bytes = [];
    for (var i = 0; i < str.length; i++) { bytes.push(str.charCodeAt(i) & 0xFF); }
    return bytes;
  },
  byteArrToStr: function byteArrToStr(bytes) {
    var str = [];
    for (var i = 0; i < bytes.length; i++) { str.push(String.fromCharCode(bytes[i] & 0xFF)); }
    return str.join('');
  },
  fromIEEE754Double: function fromIEEE754Double(b) { return this.fromIEEE754(this.strToByteArr(b), 11, 52); },
  toIEEE754Double: function toIEEE754Double(v) { return this.byteArrToStr(this.toIEEE754(v, 11, 52)); },
  fromIEEE754Single: function fromIEEE754Single(b) { return this.fromIEEE754(this.strToByteArr(b), 8, 23); },
  toIEEE754Single: function toIEEE754Single(v) { return this.byteArrToStr(this.toIEEE754(v, 8, 23)); },
};

module.exports.IEEE754LIB = IEEE754LIB;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(108);
var ParseInteger = ref$1.ParseInteger;

var autoDecodeVarLengthNumber = ParseInteger.autoDecodeVarLengthNumber;

var ParseFieldHeader = {
  // Parse the header part of an SDT field.
  // Returns [TYPE, DECLARED_LENGTH, VALUE_DATA_LENGTH, CONSUMED_BYTES]
  parseFieldHeader: function parseFieldHeader(data, offset) {
    var pos = offset;
    var onebyte = Convert.strToInt8(data.substr(pos, 1));
    var elemType = (onebyte & 0xFC) >> 2;
    var lenBytes = (onebyte & 0x03) + 1;
    pos++;
    var elemLen = autoDecodeVarLengthNumber(data.substr(pos, lenBytes));
    pos += lenBytes;
    var elemValLen = elemLen - (1 + lenBytes);
    return [elemType, elemLen, elemValLen, pos - offset];
  },
};

module.exports.ParseFieldHeader = ParseFieldHeader;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(204);
var ParseDestination = ref$2.ParseDestination;
var ref$3 = __webpack_require__(68);
var ParseFieldHeader = ref$3.ParseFieldHeader;
var ref$4 = __webpack_require__(205);
var ParseFloat = ref$4.ParseFloat;
var ref$5 = __webpack_require__(108);
var ParseInteger = ref$5.ParseInteger;
var ref$6 = __webpack_require__(206);
var ParseMap = ref$6.ParseMap;
var ref$7 = __webpack_require__(207);
var ParseStream = ref$7.ParseStream;
var ref$8 = __webpack_require__(30);
var SDTDataTypes = ref$8.SDTDataTypes;
var ref$9 = __webpack_require__(12);
var SDTField = ref$9.SDTField;
var ref$10 = __webpack_require__(11);
var SDTFieldType = ref$10.SDTFieldType;

var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var utf8ToUcs2 = Convert.utf8ToUcs2;
var parseFieldHeader = ParseFieldHeader.parseFieldHeader;
var parseFloatField = ParseFloat.parseFloatField;
var parseIntegerField = ParseInteger.parseIntegerField;
var parseMapAt = ParseMap.parseMapAt;
var parseStreamAt = ParseStream.parseStreamAt;
var parseDestination = ParseDestination.parseDestination;

var ParseSingleElement = {
  // Parse single SDT element, returns SDTField
  parseSingleElement: function parseSingleElement(data, offset) {
    var fieldHeader = parseFieldHeader(data, offset);
    if (!fieldHeader) {
      /* #stripped LOG_DEBUG(`parseSingleElement return false, fieldHeader=${fieldHeader}`) */

      return null;
    }

    var pos = offset + fieldHeader[3];

    // For use inside switch
    var elemValLen = fieldHeader[2];

    switch (fieldHeader[0]) {
      case SDTDataTypes.Null:
        return SDTField.create(SDTFieldType.NULLTYPE, null);
      case SDTDataTypes.Boolean:
        return SDTField.create(SDTFieldType.BOOL, strToInt8(data.substr(pos, 1)) !== 0);
      case SDTDataTypes.Integer:
        return parseIntegerField(true, data.substr(pos, elemValLen));
      case SDTDataTypes.UnsignedInteger:
        return parseIntegerField(false, data.substr(pos, elemValLen));
      case SDTDataTypes.Float:
        return parseFloatField(data.substr(pos, elemValLen));
      case SDTDataTypes.Char:
        return SDTField.create(SDTFieldType.WCHAR,
                               String.fromCharCode(strToInt16(data.substr(pos, 2))));
      case SDTDataTypes.ByteArray:
        return SDTField.create(SDTFieldType.BYTEARRAY, data.substr(pos, elemValLen));
      case SDTDataTypes.String:
        // strip last byte (null-terminator)
        return SDTField.create(SDTFieldType.STRING, utf8ToUcs2(data.substr(pos, elemValLen - 1)));
      case SDTDataTypes.Destination:
        return parseDestination(data.substr(pos, elemValLen));
      case SDTDataTypes.SMFMessage:
        return SDTField.create(SDTFieldType.SMF_MESSAGE, data.substr(pos, elemValLen));
      case SDTDataTypes.Map:
        return parseMapAt(data, pos, elemValLen);
      case SDTDataTypes.Stream:
        return parseStreamAt(data, pos, elemValLen);
      default:
        return SDTField.create(SDTFieldType.UNKNOWN, data.substr(pos, elemValLen));

    }
  },
};

module.exports.ParseSingleElement = ParseSingleElement;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(5);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(0);
var Enum = ref$1.Enum;

/**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 * @private
 */
var SDTDestType = {};
SDTDestType[DestinationType.TOPIC] = 0x00;
SDTDestType[DestinationType.QUEUE] = 0x01;
SDTDestType[DestinationType.TEMPORARY_QUEUE] = 0x01;

module.exports.SDTDestType = Enum.new(SDTDestType);


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents authentication schemes that can be used. The corresponding session
 * property is {@link solace.SessionProperties#authenticationScheme}.
 *
 * @readonly
 * @enum {String}
 * @memberof solace
 * @namespace
 */
var AuthenticationScheme = {
  /**
   * @description Username/Password based authentication scheme.
   * @type {String}
   */
  BASIC:                       'AuthenticationScheme_basic',
  /**
   * @name solace.AuthenticationScheme.CLIENT_CERTIFICATE
   * @default AuthenticationScheme_clientCertificate
   * @description Client-side certificate based authentication scheme.
   * @see {@link solace.SessionProperties#sslPfx}
   * @see {@link solace.SessionProperties#sslPfxPassword}
   * @see {@link solace.SessionProperties#sslPrivateKey}
   * @see {@link solace.SessionProperties#sslPrivateKeyPassword}
   * @see {@link solace.SessionProperties#sslCertificate}
   * @type {String}
   * @target node
   */
  /**
   * @description Client-side certificate based authentication scheme.  The certificate and
   *   private key are provided by the browser.
   * @type {String}
   * @target browser
   */
  CLIENT_CERTIFICATE:          'AuthenticationScheme_clientCertificate',
  /**
   * @deprecated Use {@link solace.AuthenticationScheme.BASIC} instead.
   * @type {String}
   */
  AUTHENTICATION_SCHEME_BASIC: 'AuthenticationScheme_basic',

  /**
   * @deprecated Use {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} instead.
   * @type {String}
   */
  AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: 'AuthenticationScheme_clientCertificate',
};

module.exports.AuthenticationScheme = Enum.new(AuthenticationScheme);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionEventName = {
  CONNECT:                       'SessionConnect',
  DISCONNECT:                    'SessionDisconnect',
  DISPOSE:                       'SessionDispose',
  CONNECT_TIMEOUT:               'SessionConnectTimeout',
  CONNECT_WAIT_TIMEOUT:          'SessionConnectWaitTimeout',
  DOWNGRADE_TIMEOUT:             'SessionDowngradeTimeout',
  TRANSPORT_UP:                  'SessionTransportUp',
  TRANSPORT_DESTROYED:           'SessionTransportDestroyed',
  TRANSPORT_CAN_ACCEPT_DATA:     'SessionTransportCanAcceptData',
  TRANSPORT_PARSE_ERROR:         'SessionTransportParseError',
  TRANSPORT_PROTOCOL_SMP:        'SessionSMPMessage',
  TRANSPORT_PROTOCOL_CLIENTCTRL: 'SessionClientCtrlMessage',
  EXCEPTION:                     'SessionException',
  SUBSCRIBE_TIMEOUT:             'SessionSubscribeTimeout',
  CREATE_SUBSCRIBER:             'SessionCreateSubscriber',
  FLOW_UP:                       'SessionFlowUp',
  FLOW_FAILED:                   'SessionFlowFailed',
  SEND_ERROR:                    'SessionSendError',
  FLOWS_DISCONNECTED:            'SessionFlowsDisconnected',
  TRANSPORT_FLUSHED:             'SessionTransportFlushed',
  DNS_RESOLUTION_COMPLETE:       'SessionDNSResolutionComplete',
};

module.exports.SessionEventName = Enum.new(SessionEventName);


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var RequestError = ref.RequestError;
var RequestEventCode = ref.RequestEventCode;
var ref$1 = __webpack_require__(44);
var SessionEventCode = ref$1.SessionEventCode;

function buildType(Superclass) {
  /**
   * @classdesc
   * Represents a session event; events are passed to the application-provided
   * event handling callback provided when creating the session.
   * @memberof solace
   */
  var SessionEvent = (function (Superclass) {
    function SessionEvent(superclassArgs,
                sessionEventCode,
                infoStr,
                responseCode,
                errorSubcode,
                correlationKey,
                reason) {
      if ( responseCode === void 0 ) responseCode = undefined;
      if ( errorSubcode === void 0 ) errorSubcode = 0;
      if ( correlationKey === void 0 ) correlationKey = undefined;
      if ( reason === void 0 ) reason = undefined;

      Superclass.apply(this, superclassArgs);
      this._sessionEventCode = sessionEventCode;
      this._infoStr = infoStr;
      this._responseCode = responseCode;
      this._errorSubcode = errorSubcode;
      this._correlationKey = correlationKey; // optional
      this._reason = reason; // optional
    }

    if ( Superclass ) SessionEvent.__proto__ = Superclass;
    SessionEvent.prototype = Object.create( Superclass && Superclass.prototype );
    SessionEvent.prototype.constructor = SessionEvent;

    var prototypeAccessors = { sessionEventCode: {},infoStr: {},responseCode: {},errorSubcode: {},errorSubCode: {},correlationKey: {},reason: {} };

    /**
     * @type {solace.SessionEventCode}
     * @description Further qualifies the session event.
     */
    prototypeAccessors.sessionEventCode.get = function () {
      return this._sessionEventCode;
    };

    /**
     * @type {String}
     * @description if applicable, an information string returned by the Solace Message Router.
     */
    prototypeAccessors.infoStr.get = function () {
      return this._infoStr;
    };

    /**
     * @type {?Number}
     * @description if applicable, a response code returned by the Solace Message Router.
     */
    prototypeAccessors.responseCode.get = function () {
      return this._responseCode;
    };

    /**
     * @type {?solace.ErrorSubcode}
     * @description if applicable, an error subcode. Defined in {@link solace.ErrorSubcode}
     */
    prototypeAccessors.errorSubcode.get = function () {
      // eslint-disable-next-line quote-property
      return this.subcode || this._errorSubcode;
    };

    /**
     * @deprecated Use {@link solace.SessionEvent#errorSubcode} instead.
     * @readonly
     */
    prototypeAccessors.errorSubCode.get = function () {
      return this.errorSubcode;
    };

    /**
     * @type {?Object}
     * @description A user-specified object
     * made available in the response or confirmation event by including it as a
     * parameter in the orignal API call.  If the user did not specify a
     * correlationKey, it will be <code>null</code>.
     */
    prototypeAccessors.correlationKey.get = function () {
      return this._correlationKey;
    };

    /**
     * @type {?String}
     * @description Additional information if it is applicable.
     */
    prototypeAccessors.reason.get = function () {
      return this._reason;
    };
    /**
     * @param {Object} value The reason info object
     * @internal
     */
    prototypeAccessors.reason.set = function (value) {
      this._reason = value;
    };

    SessionEvent.prototype[util.inspect.custom] = function () {
      return Object.assign(Superclass.prototype[util.inspect.custom] || {}, {
        'sessionEventCode': SessionEventCode.describe(this.sessionEventCode),
        'infoStr':          this.infoStr,
        'responseCode':     this.responseCode,
        'errorSubcode':     ErrorSubcode.describe(this.errorSubcode),
        'correlationKey':   this.correlationKey ? this.correlationKey.toString() : null,
      });
    };

    SessionEvent.prototype.toString = function toString () {
      return util.inspect(this);
    };

    Object.defineProperties( SessionEvent.prototype, prototypeAccessors );

    return SessionEvent;
  }(Superclass));

  return SessionEvent;
}

var SUPERCLASS_FOR_SESSION_EVENT = {};
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.CONNECT_FAILED_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.DOWN_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.PROPERTY_UPDATE_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.REJECTED_MESSAGE_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.SUBSCRIPTION_ERROR] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR] = OperationError;
SUPERCLASS_FOR_SESSION_EVENT[RequestEventCode.REQUEST_ABORTED] = RequestError;
SUPERCLASS_FOR_SESSION_EVENT[RequestEventCode.REQUEST_TIMEOUT] = RequestError;

var SUPERCLASS_ARGS = new Map()
  .set(Object, function () { return []; })
  .set(OperationError, function (sec, infoStr, rc, subcode, ck, reason) { return [infoStr, subcode, reason]; })
  .set(RequestError, function (sec, infoStr, rc, subcode, ck, reason) { return [infoStr, sec, ck, reason]; });

var TYPE_CACHE = new Map();

function build(sessionEventCode,
               infoStr,
               responseCode,
               errorSubcode,
               correlationKey,
               reason) {
  if ( responseCode === void 0 ) responseCode = undefined;
  if ( errorSubcode === void 0 ) errorSubcode = 0;
  if ( correlationKey === void 0 ) correlationKey = undefined;
  if ( reason === void 0 ) reason = undefined;

  var Superclass = SUPERCLASS_FOR_SESSION_EVENT[sessionEventCode] || Object;
  var SessionEvent = (function () {
    var result = TYPE_CACHE.get(Superclass);
    if (result) { return result; }
    result = buildType(Superclass);
    TYPE_CACHE.set(Superclass, result);
    return result;
  })();
  var superclassArgsBuilder = (SUPERCLASS_ARGS.get(Superclass) || (function () { return []; }));
  var superclassArgs = superclassArgsBuilder(sessionEventCode,
                                               infoStr,
                                               responseCode,
                                               errorSubcode,
                                               correlationKey,
                                               reason);
  return new SessionEvent(superclassArgs,
                          sessionEventCode,
                          infoStr,
                          responseCode,
                          errorSubcode,
                          correlationKey,
                          reason);
}

// Expose a type
var SessionEvent = buildType(Object);
SessionEvent.build = build;

module.exports.SessionEvent = SessionEvent;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var NodeSslConstants = __webpack_require__(267);
var PublisherLib = __webpack_require__(29);
var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(71);
var AuthenticationScheme = ref$1.AuthenticationScheme;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;

function makeDefaults() {
  // Defer binding. Publisher constructor may rely on profile.
  var MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
  return {
    _vpnNameInUse:        '',
    _virtualRouterName:   '',
    _p2pInboxInUse:       '',
    _p2pInboxBase:        '',
    _userIdentification:  '',
    _tpProtocolInUse:     null,
    _tpContentType:       'text/plain',
    _publisherProperties: new MessagePublisherProperties(),
  };
}

var DEFAULT_CIPHER_SUITES =  true ? [
  'ECDHE-RSA-AES256-GCM-SHA384',
  'ECDHE-RSA-AES256-SHA384',
  'ECDHE-RSA-AES256-SHA',
  'AES256-GCM-SHA384',
  'AES256-SHA256',
  'AES256-SHA',
  'ECDHE-RSA-DES-CBC3-SHA',
  'DES-CBC3-SHA',
  'ECDHE-RSA-AES128-GCM-SHA256',
  'ECDHE-RSA-AES128-SHA256',
  'ECDHE-RSA-AES128-SHA',
  'AES128-GCM-SHA256',
  'AES128-SHA256',
  'AES128-SHA' ].join(',') : null;

var SUPPORTED_CIPHER_SUITES =  true ? [
  'AES128-GCM-SHA256',
  'AES128-SHA',
  'AES128-SHA256',
  'AES256-GCM-SHA384',
  'AES256-SHA',
  'AES256-SHA256',
  'DES-CBC3-SHA',
  'ECDHE-RSA-AES128-GCM-SHA256',
  'ECDHE-RSA-AES128-SHA',
  'ECDHE-RSA-AES128-SHA256',
  'ECDHE-RSA-AES256-GCM-SHA384',
  'ECDHE-RSA-AES256-SHA',
  'ECDHE-RSA-AES256-SHA384',
  'ECDHE-RSA-DES-CBC3-SHA' ] : null;

var SUPPORTED_SSL_PROTOCOLS =  true
? [
  'tlsv1',
  'tlsv1.1',
  'tlsv1.2' ]
: null;

/**
 * @lends SessionProperties
 *
 */
var SessionPropertiesBrowser = (function (APIProperties) {
  function SessionPropertiesBrowser () {
    APIProperties.apply(this, arguments);
  }

  if ( APIProperties ) SessionPropertiesBrowser.__proto__ = APIProperties;
  SessionPropertiesBrowser.prototype = Object.create( APIProperties && APIProperties.prototype );
  SessionPropertiesBrowser.prototype.constructor = SessionPropertiesBrowser;

  var prototypeAccessors = { transportProtocol: {},transportDowngradeTimeoutInMsecs: {},webTransportProtocolList: {},bufferedAmountQueryIntervalInMsecs: {},transportProtocolInUse: {},webTransportProtocolInUse: {},transportContentType: {} };

  prototypeAccessors.transportProtocol.get = function () {
    return Check.nothing(this._tpProtocol) ? null : this._tpProtocol;
  };
  prototypeAccessors.transportProtocol.set = function (newValue) {
    this._tpProtocol = newValue;
  };


  /**
   * @name solace.SessionProperties#transportDowngradeTimeoutInMsecs
   * @type {Number}
   * @description The timeout, in milliseconds, that must elapse before the session will abandon a
   * connection attempt with the current transport protocol if no response is received, and begin
   * a new connection attempt with a downgraded transport protocol. If no remaining downgrades
   * exist, the session will continue the current connection attempt until the connection timeout
   * expires. Note that the WS_BINARY transport will also attempt a downgrade if the underlying
   * WebSocket fails to connect before this period elapses.
   *  * The valid range is > 0.
   * @default 3000
   * @target browser
   */
  prototypeAccessors.transportDowngradeTimeoutInMsecs.get = function () {
    return Check.nothing(this._tpDowngradeTimeout) ? 3000 : this._tpDowngradeTimeout;
  };
  prototypeAccessors.transportDowngradeTimeoutInMsecs.set = function (newValue) {
    this._tpDowngradeTimeout = newValue;
  };

  /**
   * @name solace.SessionProperties#webTransportProtocolList
   * @type {Array.<solace.TransportProtocol>}
   * @description The user provided web transport protocol list indicating the intial protocol
   * to be used by the session for its connection attempt, and the protocols to try
   * subsequently if the attempt fails.
   *  * Mutually exclusive to property transportProtocol
   * @default null
   * @target browser
   */
  prototypeAccessors.webTransportProtocolList.get = function () {
    return Check.nothing(this._transportProtocolList)
             ? null
             : this._transportProtocolList;
  };
  prototypeAccessors.webTransportProtocolList.set = function (newValue) {
    this._transportProtocolList = newValue;
  };

  /**
   * @private
   * @name SessionProperties#bufferedAmountQueryIntervalInMsecs
   * @type {Number}
   * @description When WebSocket transport protocol is used, SolClient uses this property
   * and {@link solace.SessionProperties.maxWebPayload} to throttle the publishing rate in order to
   * avoid network saturation.
   *  * The valid range is >=4.
   * @default 100
   */
  prototypeAccessors.bufferedAmountQueryIntervalInMsecs.get = function () {
    return Check.nothing(this._bufferedAmountQueryInterval)
    ? 100
    : this._bufferedAmountQueryInterval;
  };
  prototypeAccessors.bufferedAmountQueryIntervalInMsecs.set = function (newValue) {
    this._bufferedAmountQueryInterval = newValue;
  };


  /**
   *
   * @name solace.SessionProperties#transportProtocolInUse
   * @type {String}
   * @description This property is deprecated.
   * Use {@link solace.SessionProperties#webTransportProtocolInUse} instead.
   * @readonly
   * @target browser
   * @deprecated
   */
  prototypeAccessors.transportProtocolInUse.get = function () {
    return this._tpProtocolInUse || null;
  };
  SessionPropertiesBrowser.prototype._setTransportProtocolInUse = function _setTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   *
   * @name solace.SessionProperties#webTransportProtocolInUse
   * @type {String}
   * @description A read-only property about the web transport protocol that is currently being
   * used by the session for its current connection or connection attempt. To determine which
   * web transport protocol was successfully used by the API, interrogate this property after the
   * session event UP_NOTICE is dispatched.
   * @readonly
   * @target browser
   */
  prototypeAccessors.webTransportProtocolInUse.get = function () {
    return this._tpProtocolInUse || null;
  };
  SessionPropertiesBrowser.prototype._setWebTransportProtocolInUse = function _setWebTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   *
   * @name solace.SessionProperties#transportContentType
   * @type {String}
   * @description Transport content-type override for HTTP transports
   * @default 'text/plain'
   * @internal
   */
  prototypeAccessors.transportContentType.get = function () {
    return this._tpContentType || 'text/plain';
  };
  prototypeAccessors.transportContentType.set = function (newValue) {
    this._tpContentType = newValue;
  };

  SessionPropertiesBrowser.prototype._lendsInspect = function _lendsInspect () {
    return {
      'bufferedAmountQueryIntervalInMsecs': this.bufferedAmountQueryIntervalInMsecs,
      'transportContentType':               this.transportContentType,
      'transportDowngradeTimeoutInMsecs':   this.transportDowngradeTimeoutInMsecs,
      'transportProtocol':                  this.transportProtocol,
      'transportProtocolInUse':             this.transportProtocolInUse,
      'webTransportProtocolList':           this.webTransportProtocolList,
    };
  };

  Object.defineProperties( SessionPropertiesBrowser.prototype, prototypeAccessors );

  return SessionPropertiesBrowser;
}(APIProperties));

var SessionPropertiesNode = (function (APIProperties) {
  function SessionPropertiesNode () {
    APIProperties.apply(this, arguments);
  }

  if ( APIProperties ) SessionPropertiesNode.__proto__ = APIProperties;
  SessionPropertiesNode.prototype = Object.create( APIProperties && APIProperties.prototype );
  SessionPropertiesNode.prototype.constructor = SessionPropertiesNode;

  var prototypeAccessors$1 = { transportProtocol: {},webTransportProtocolList: {},transportDowngradeTimeoutInMsecs: {},transportProtocolInUse: {},webTransportProtocolInUse: {},transportContentType: {},sslExcludedProtocols: {},sslCipherSuites: {},sslValidateCertificate: {},sslTrustStores: {},sslTrustedCommonNameList: {},sslPfx: {},sslPfxPassword: {},sslPrivateKey: {},sslPrivateKeyPassword: {},sslCertificate: {},sslProtocol: {} };

  prototypeAccessors$1.transportProtocol.get = function () {
    return this._tpProtocol;
  };
  prototypeAccessors$1.transportProtocol.set = function (value) {
    this._tpProtocol = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.webTransportProtocolList.get = function () {
    return this._transportProtocolList;
  };
  prototypeAccessors$1.webTransportProtocolList.set = function (value) {
    this._transportProtocolList = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.transportDowngradeTimeoutInMsecs.get = function () {
    return this._tpDowngradeTimeout || 86400000; // All day
  };
  prototypeAccessors$1.transportDowngradeTimeoutInMsecs.set = function (value) {
    this._tpDowngradeTimeout = value;
  };

  /**
   * @internal
   * @deprecated
   */
  prototypeAccessors$1.transportProtocolInUse.get = function () {
    return this._tpProtocolInUse;
  };
  SessionPropertiesNode.prototype._setTransportProtocolInUse = function _setTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.webTransportProtocolInUse.get = function () {
    return this._tpProtocolInUse;
  };
  SessionPropertiesNode.prototype._setWebTransportProtocolInUse = function _setWebTransportProtocolInUse (value) {
    this._tpProtocolInUse = value;
  };

  /**
   * @internal
   */
  prototypeAccessors$1.transportContentType.get = function () {
    return this._tpContentType;
  };
  prototypeAccessors$1.transportContentType.set = function (value) {
    this._tpContentType = value;
  };

  // TLS connection options

  /**
   * @name solace.SessionProperties#sslExcludedProtocols
   * @type {Array.<String>}
   * @description An array of TLS protocols to be excluded when negotiating which protocol
   * to use.
   *  * Allowed values are: TLSv1, TLSv1.1, TLSv1.2
   *  * Note: when a protocol version is excluded without excluding all of its
   *    previous protocol versions, the effect is to also exclude all subsequent
   *    protocol versions.
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslExcludedProtocols.get = function () {
    return Check.nothing(this._sslExcludedProtocols)
      ? null
      : this._sslExcludedProtocols;
  };
  prototypeAccessors$1.sslExcludedProtocols.set = function (newValue) {
    this._sslExcludedProtocols = newValue;
  };

  /**
   * @name solace.SessionProperties#sslCipherSuites
   * @type {String}
   * @description A comma separated list of cipher suites in order of preference used for TLS
   * connections.
   *  * Allowed values:
   *     * AES128-GCM-SHA256
   *     * AES128-SHA
   *     * AES128-SHA256
   *     * AES256-GCM-SHA384
   *     * AES256-SHA
   *     * AES256-SHA256
   *     * DES-CBC3-SHA
   *     * ECDHE-RSA-AES128-GCM-SHA256
   *     * ECDHE-RSA-AES128-SHA
   *     * ECDHE-RSA-AES128-SHA256
   *     * ECDHE-RSA-AES256-GCM-SHA384
   *     * ECDHE-RSA-AES256-SHA
   *     * ECDHE-RSA-AES256-SHA384
   *     * ECDHE-RSA-DES-CBC3-SHA
   *     * RC4-SHA
   *     * RC4-MD5
   * @default {@link solace.SessionProperties.DEFAULT_CIPHER_SUITES}
   * @target node
   */
  prototypeAccessors$1.sslCipherSuites.get = function () {
    return Check.nothing(this._sslCipherSuites)
      ? DEFAULT_CIPHER_SUITES
      : this._sslCipherSuites;
  };
  prototypeAccessors$1.sslCipherSuites.set = function (newValue) {
    this._sslCipherSuites = newValue;
  };

  /**
   *
   * @name solace.SessionProperties#sslValidateCertificate
   * @type {Boolean}
   * @description Whether the server certificate shall be verified against the list of
   * certificates in the trust stores. If set to false, all certificate validation is disabled,
   * including date, hostname and common name validation.
   * @default true
   * @target node
   */
  prototypeAccessors$1.sslValidateCertificate.get = function () {
    // if the value is undefined, then use environment variable
    if (this._sslValidateCert === undefined) { return (process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0'); }
    if (this._sslValidateCert === null) { return true; }
    return this._sslValidateCert;
  };
  prototypeAccessors$1.sslValidateCertificate.set = function (newValue) {
    this._sslValidateCert = newValue;
  };

  /**
   * @name solace.SessionProperties#sslTrustStores
   * @type {Array.<String>}
   * @description An array of file names of trusted certificates in PEM format.
   * If not set, and {@link solace.SessionProperties#sslValidateCertificate} is set to true,
   * the server certificate will be validated against well known "root" CAs.
   *    * Mutually exclusive to sslPfx property when
   *      {@link solace.SessionProperties#sslValidateCertificate} is set
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslTrustStores.get = function () {
    return Check.nothing(this._sslTrustStores)
      ? null
      : this._sslTrustStores;
  };
  prototypeAccessors$1.sslTrustStores.set = function (newValue) {
    this._sslTrustStores = newValue;
  };

  /**
   * @name solace.SessionProperties#sslTrustedCommonNameList
   * @type {Array.<String>}
   * @description An array of acceptable common names for matching with the server certificate.
   * If set to a non-empty array, the API will override the default hostname validation logic
   * provided by Node.js with its own implemenation; if set to empty array, no hostname
   * validation will be performed.
   *    * Only relevant when {@link solace.SessionProperties#sslValidateCertificate} is set
   *      to true
   *    * Note that leading and trailing whitespaces are considered to be part of the common
   *      names and are not ignored
   * @default null
   * @target node
   */
  prototypeAccessors$1.sslTrustedCommonNameList.get = function () {
    return Check.nothing(this._sslTrustedCNList)
      ? null
      : this._sslTrustedCNList;
  };
  prototypeAccessors$1.sslTrustedCommonNameList.set = function (newValue) {
    this._sslTrustedCNList = newValue;
  };

  // Client certificates related

  /**
   * @name solace.SessionProperties#sslPfx
   * @type {String}
   * @description The file name of a file containing private key, certificate and optional
   * CA certificates of the client in PFX or PKCS12 format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPrivateKey, sslCertificate and sslTrustStores properties
   * @default ""
   * @target node
   */
  prototypeAccessors$1.sslPfx.get = function () {
    return Check.nothing(this._sslPfx)
      ? ''
      : this._sslPfx;
  };
  prototypeAccessors$1.sslPfx.set = function (newValue) {
    this._sslPfx = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPfxPassword
   * @type {String}
   * @description A string containing password for the client pfx file.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPfxPassword.get = function () {
    return Check.nothing(this._sslPfxPasswd) ? '' : this._sslPfxPasswd;
  };
  prototypeAccessors$1.sslPfxPassword.set = function (newValue) {
    this._sslPfxPasswd = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPrivateKey
   * @type {String}
   * @description The file name of a file containing private key of the client in PEM format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPrivateKey.get = function () {
    return Check.nothing(this._sslPrivateKey) ? '' : this._sslPrivateKey;
  };
  prototypeAccessors$1.sslPrivateKey.set = function (newValue) {
    this._sslPrivateKey = newValue;
  };

  /**
   * @name solace.SessionProperties#sslPrivateKeyPassword
   * @type {String}
   * @description A string containg password for the client private key.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslPrivateKeyPassword.get = function () {
    return Check.nothing(this._sslPrivateKeyPasswd) ? '' : this._sslPrivateKeyPasswd;
  };
  prototypeAccessors$1.sslPrivateKeyPassword.set = function (newValue) {
    this._sslPrivateKeyPasswd = newValue;
  };

  /**
   * @name solace.SessionProperties#sslCertificate
   * @type {String}
   * @description The file name of a file containing certificate key of the client in PEM
   * format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
  prototypeAccessors$1.sslCertificate.get = function () {
    return Check.nothing(this._sslCertificate) ? '' : this._sslCertificate;
  };
  prototypeAccessors$1.sslCertificate.set = function (newValue) {
    this._sslCertificate = newValue;
  };

  // TLS connection options

  /**
   * @name SessionProperties#sslProtocol
   * @type {String}
   * @description The SSL protocols to use.
   *    * Allowed values are: SSLv3, TLSv1, TLSv1.1, TLSv1.2
   * @target node
   */
  prototypeAccessors$1.sslProtocol.get = function () {
    return this._sslProtocol;
  };
  prototypeAccessors$1.sslProtocol.set = function (newValue) {
    this._sslProtocol = newValue;
  };

  SessionPropertiesNode.prototype._lendsInspect = function _lendsInspect () {
    return {
      'sslExcludedProtocols':     this.sslExcludedProtocols,
      'sslCipherSuites':          this.sslCipherSuites,
      'sslValidateCertificate':   this.sslValidateCertificate,
      'sslTrustStores':           this.sslTrustStores,
      'sslTrustedCommonNameList': this.sslTrustedCommonNameList,
      'sslPfx':                   this.sslPfx,
      'sslPfxPassword':           this.sslPfxPassword ? '*****' : this.sslPfxPassword,
      'sslPrivateKey':            this.sslPrivateKey,
      'sslPrivateKeyPassword':    this.sslPrivateKeyPassword ? '*****' : this.sslPrivateKeyPassword,
      'sslCertificate':           this.sslCertificate,
      'sslProtocol':              this.sslProtocol,
    };
  };

  Object.defineProperties( SessionPropertiesNode.prototype, prototypeAccessors$1 );

  return SessionPropertiesNode;
}(APIProperties));

var SessionPropertiesBase =  true
  ? SessionPropertiesNode
  : SessionPropertiesBrowser;

/**
 * @classdesc
 * Represents a session properties object. Passed in to
 * {@link solace.SolclientFactory.createSession} when creating a {@link solace.Session} instance.
 * @memberof solace
 * @extends APIProperties
 */
var SessionProperties = (function (SessionPropertiesBase) {
  function SessionProperties(options) {
    SessionPropertiesBase.call(this, makeDefaults(), options);
  }

  if ( SessionPropertiesBase ) SessionProperties.__proto__ = SessionPropertiesBase;
  SessionProperties.prototype = Object.create( SessionPropertiesBase && SessionPropertiesBase.prototype );
  SessionProperties.prototype.constructor = SessionProperties;

  var prototypeAccessors$2 = { authenticationScheme: {},url: {},password: {},userName: {},clientName: {},applicationDescription: {},vpnName: {},vpnNameInUse: {},virtualRouterName: {},connectTimeoutInMsecs: {},defaultConnectTimeoutInMsecs: {},connectRetries: {},connectRetriesPerHost: {},reconnectRetryWaitInMsecs: {},reconnectRetries: {},generateSendTimestamps: {},generateReceiveTimestamps: {},includeSenderId: {},generateSequenceNumber: {},keepAliveIntervalInMsecs: {},keepAliveIntervalsLimit: {},p2pInboxInUse: {},p2pInboxBase: {},userIdentification: {},subscriberLocalPriority: {},subscriberNetworkPriority: {},ignoreDuplicateSubscriptionError: {},ignoreSubscriptionNotFoundError: {},reapplySubscriptions: {},publisherProperties: {},noLocal: {},readTimeoutInMsecs: {},sendBufferMaxSize: {},maxWebPayload: {},nonHTTPTransportPropsSet: {} };

  /**
   * The authentication scheme used when establishing the session.
   * @name solace.SessionProperties#authenticationScheme
   * @type {solace.AuthenticationScheme}
   * @default {@link solace.AuthenticationScheme.BASIC}
   */
  prototypeAccessors$2.authenticationScheme.get = function () {
    return Check.nothing(this._authScheme)
        ? AuthenticationScheme.BASIC
        : this._authScheme;
  };
  prototypeAccessors$2.authenticationScheme.set = function (newValue) {
    this._authScheme = newValue;
  };

  /**
   * The URL or URLs of the messaging service to connect to.  The URL is typically of the form
   * `<protocol>://<host[:port]>`, where:
   *  * `protocol` is one of `ws`, `wss`, `http`, `https`, `tcp` or `tcps`.
   *  (`tcp` and `tcps` supported in nodejs only.)
   *  * `host` is a hostname or IP address of the router to connect to.
   *  * `port` is the port on which the messaging service is listening. The default is the
   *    well-known port for the service associated with the given protocol, if any.
   *
   * Additionally, note:
   *  * When an Array is provided, each element is expected to be a string of the above format.
   *    The API will attempt to connect to these URLs in the specified order.
   *  * Cross-domain restrictions should be taken into consideration when deploying web
   *    applications with messaging capabilities. See the API User Guide for more
   *    information.
   * @name solace.SessionProperties#url
   * @type {String|Array.<String>}
   * @default ""
   */
  prototypeAccessors$2.url.get = function () {
    return Check.nothing(this._url) ? '' : this._url;
  };

  prototypeAccessors$2.url.set = function (newValue) {
    this._url = newValue;
  };

  //  ======================== Credentials  ========================

  /**
   * @name solace.SessionProperties#password
   * @type {String}
   * @description The password required for authentication.
   * @default ""
   */
  prototypeAccessors$2.password.get = function () {
    return Check.nothing(this._password) ? '' : this._password;
  };

  prototypeAccessors$2.password.set = function (newValue) {
    this._password = newValue;
  };

  /**
   * @name solace.SessionProperties#userName
   * @type {String}
   * @description  The client username required for authentication.
   * @default ""
   */
  prototypeAccessors$2.userName.get = function () {
    return Check.nothing(this._userName) ? '' : this._userName;
  };

  prototypeAccessors$2.userName.set = function (newValue) {
    this._userName = newValue;
  };

  /**
   * @name solace.SessionProperties#clientName
   * @type {String}
   * @default '' (automatically generated)
   * @description The client name that is used during login as a unique identifier for the session
   * on the Solace Message Router.
   *  * An empty string causes a unique client name to be generated
   *     automatically.
   *  * If specified, it must be a valid Topic name, and a maximum of 160 bytes in length.
   *  * This property is also used to uniquely identify the sender in
   *    a message's senderId field if {@link solace.SessionProperties.includeSenderId}
   *    is set.
   * @default ""
   */
  prototypeAccessors$2.clientName.get = function () {
    return Check.nothing(this._clientName) ? '' : this._clientName;
  };

  prototypeAccessors$2.clientName.set = function (newValue) {
    this._clientName = newValue;
  };

  /**
   * A string that uniquely describes the application instance.
   *  * If left blank, the API will generate a description string
   *    using the current user-agent string.
   * @default ""
   * @name solace.SessionProperties#applicationDescription
   * @type {String}
   */
  prototypeAccessors$2.applicationDescription.get = function () {
    return Check.nothing(this._appDesc) ? '' : this._appDesc;
  };
  prototypeAccessors$2.applicationDescription.set = function (newValue) {
    this._appDesc = newValue;
  };

  /**
   * The Message VPN name that the client is requesting for this session.
   * @default ""
   * @name solace.SessionProperties#vpnName
   * @type {String}
   */
  prototypeAccessors$2.vpnName.get = function () {
    return Check.nothing(this._vpnName) ? '' : this._vpnName;
  };
  prototypeAccessors$2.vpnName.set = function (newValue) {
    this._vpnName = newValue;
  };

  /**
   * A read-only session property that indicates which Message
   * VPN the session is connected to. When not connected, or when not in client mode,
   * an empty string is returned.
   * @default ""
   * @name solace.SessionProperties#vpnNameInUse
   * @type {String}
   * @readonly
   */
  prototypeAccessors$2.vpnNameInUse.get = function () {
    return Check.nothing(this._vpnNameInUse) ? '' : this._vpnNameInUse;
  };
  /**
   * @private
   * @param {String} value The vpn name currently being used.
   */
  SessionProperties.prototype._setVpnNameInUse = function _setVpnNameInUse (value) {
    this._vpnNameInUse = value;
  };

  /**
   * @name solace.SessionProperties#virtualRouterName
   * @type {String}
   * @description A read-only property that indicates the connected Solace Message Router's
   * virtual router name.
   * @default ""
   * @readonly
   */
  prototypeAccessors$2.virtualRouterName.get = function () {
    return Check.nothing(this._virtualRouterName) ? '' : this._virtualRouterName;
  };
  /**
   * @private
   * @param {String} value The current virtual router name.
   */
  SessionProperties.prototype._setVirtualRouterName = function _setVirtualRouterName (value) {
    this._virtualRouterName = value;
  };

  //  ======================== Connection Strategies ========================
  /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is 8000.
   *   * The valid range is > 0.
   * @default 8000
   * @target node
   */
  /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is calculated as shown below.
   *   * The valid range is > 0.
   * @default max(8000, 1000 + webTransportProtocolList.length * transportDowngradeTimeoutInMsecs)
   * @target browser
   */
  prototypeAccessors$2.connectTimeoutInMsecs.get = function () {
    if (Check.nothing(this._connectTimeout)) {
      return this.defaultConnectTimeoutInMsecs;
    }
    return this._connectTimeout;
  };
  prototypeAccessors$2.connectTimeoutInMsecs.set = function (newValue) {
    this._connectTimeout = newValue;
  };

  /**
   * @internal
   */
  prototypeAccessors$2.defaultConnectTimeoutInMsecs.get = function () {
    var minTimeout = 8000;
    var ref = this;
    var webTransportProtocolList = ref.webTransportProtocolList;
    var transportDowngradeTimeoutInMsecs = ref.transportDowngradeTimeoutInMsecs;
    var transportCount = webTransportProtocolList ? webTransportProtocolList.length : 1;
    var margin = transportCount > 1 ? 1000 : 0;
    var connectDowngradeDefault = transportCount * transportDowngradeTimeoutInMsecs + margin;
    return Math.max(minTimeout, connectDowngradeDefault);
  };

  /**
   * @name solace.SessionProperties#connectRetries
   * @type {Number}
   * @description The number of times to retry connecting during initial connection setup.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `connectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next connection attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   * If an established connection fails, the reconnection is attempted with
   * {@link solace.SessionProperties#reconnectRetries} retries instead.
   *
   *  * The valid range is connectRetries >= -1.
   *  * -1 means try to connect forever.
   *  * 0 means no automatic connection retries; the API will try once and then give up.
   *  * connectRetries >= 1 means reattempt connection n times.
   * @default 20
   */
  prototypeAccessors$2.connectRetries.get = function () {
    return Check.nothing(this._connectRetries) ? 20 : this._connectRetries;
  };
  prototypeAccessors$2.connectRetries.set = function (newValue) {
    this._connectRetries = newValue;
  };

  /**
   * @name solace.SessionProperties#connectRetriesPerHost
   * @type {Number}
   * @description When using a host list, this property defines how many times to
   * try to connect to a single host before moving to the next host in the list.
   *
   *  * The valid range is connectRetriesPerHost >= -1.
   *  * -1 means attempt an infinite number of connection retries. The API will only
   *    attempt to connect to the first host in the list.
   *  * 0 means make a single connection attempt per host, with no retries.
   * @default 0
   */
  prototypeAccessors$2.connectRetriesPerHost.get = function () {
    return Check.nothing(this._connectRetriesPerHost) ? 0 : this._connectRetriesPerHost;
  };
  prototypeAccessors$2.connectRetriesPerHost.set = function (newValue) {
    this._connectRetriesPerHost = newValue;
  };

  /**
   * @name solace.SessionProperties#reconnectRetryWaitInMsecs
   * @type {Number}
   * @description How much time to wait (in ms) between each attempt to connect to
   * a host.
   * If a connect attempt is not successful, the API waits for the amount of time
   * specified, and then makes another attempt to connect.
   * {@link solace.SessionProperties#connectRetriesPerHost} sets how many connection
   * attempts will be made before moving on to the next host in the list.
   * The valid range is >= 0 and <= 60000.
   * @default 3000
   */
  prototypeAccessors$2.reconnectRetryWaitInMsecs.get = function () {
    return Check.nothing(this._reconnectRetryWaitInMsecs) ? 3000 : this._reconnectRetryWaitInMsecs;
  };
  prototypeAccessors$2.reconnectRetryWaitInMsecs.set = function (newValue) {
    this._reconnectRetryWaitInMsecs = newValue;
  };

  /**
   * @name solace.SessionProperties#reconnectRetries
   * @type {Number}
   * @description The number of times to retry connecting after a connected session goes down.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `reconnectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next reconnect attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   *  * The valid range is reconnectRetries >= -1.
   *  * -1 means try to reconnect forever.
   *  * 0 means no automatic reconnect retries; the API will try once and then give up.
   *  * reconnectRetries >= 1 means reattempt reconnect n times.
   * @default 20
   */
  prototypeAccessors$2.reconnectRetries.get = function () {
    return Check.nothing(this._reconnectRetries) ? 20 : this._reconnectRetries;
  };
  prototypeAccessors$2.reconnectRetries.set = function (newValue) {
    this._reconnectRetries = newValue;
  };

  //  ======================== message properties ========================
  /**
   * @name solace.SessionProperties#generateSendTimestamps
   * @type {Boolean}
   * @description When enabled, a send timestamp is automatically included
   * (if not already present) in the Solace-defined fields for
   * each message sent.
   * @default  false
   */
  prototypeAccessors$2.generateSendTimestamps.get = function () {
    return Check.nothing(this._genSendTimestamps) ? false : this._genSendTimestamps;
  };
  prototypeAccessors$2.generateSendTimestamps.set = function (newValue) {
    this._genSendTimestamps = newValue;
  };

  /**
   * @name solace.SessionProperties#generateReceiveTimestamps
   * @type {Boolean}
   * @description When enabled, a receive timestamp is recorded for
   * each message and passed to the session's message callback receive handler.
   * @default  false
   */
  prototypeAccessors$2.generateReceiveTimestamps.get = function () {
    return Check.nothing(this._genReceiveTimestamps) ? false : this._genReceiveTimestamps;
  };
  prototypeAccessors$2.generateReceiveTimestamps.set = function (newValue) {
    this._genReceiveTimestamps = newValue;
  };

  /**
   * @name solace.SessionProperties#includeSenderId
   * @type {Boolean}
   * @description When enabled, a sender ID is automatically included
   * (if not already present) in the Solace-defined fields for each message
   * sent.
   * @default  false
   */
  prototypeAccessors$2.includeSenderId.get = function () {
    return Check.nothing(this._includeSenderId) ? false : this._includeSenderId;
  };
  prototypeAccessors$2.includeSenderId.set = function (newValue) {
    this._includeSenderId = newValue;
  };

  /**
   * @name solace.SessionProperties#generateSequenceNumber
   * @type {Boolean}
   * @description When enabled, a sequence number is automatically
   * included (if not already present) in the Solace-defined fields
   * for each message sent.
   * @default  false
   */
  prototypeAccessors$2.generateSequenceNumber.get = function () {
    return Check.nothing(this._genSequenceNumber) ? false : this._genSequenceNumber;
  };
  prototypeAccessors$2.generateSequenceNumber.set = function (newValue) {
    this._genSequenceNumber = newValue;
  };

  //  ======================== Keep Alive ========================
  /**
   * @name solace.SessionProperties#keepAliveIntervalInMsecs
   * @type {Number}
   * @description The amount of time (in milliseconds) to wait between sending
   * out keep-alive messages to the Solace Message Router.
   *  * The valid range is > 0.
   * @default  3000
   */
  prototypeAccessors$2.keepAliveIntervalInMsecs.get = function () {
    return Check.nothing(this._kaInterval) ? 3000 : this._kaInterval;
  };
  prototypeAccessors$2.keepAliveIntervalInMsecs.set = function (newValue) {
    this._kaInterval = newValue;
  };

  /**
   * @name solace.SessionProperties#keepAliveIntervalsLimit
   * @type {Number}
   * @description The maximum number of consecutive Keep-Alive messages that
   * can be sent without receiving a response before the session is declared down
   * and the connection is closed by the API.
   *  * The valid range is >= 3.
   * @default 3
   */
  prototypeAccessors$2.keepAliveIntervalsLimit.get = function () {
    return Check.nothing(this._kaIntervalsLimit) ? 3 : this._kaIntervalsLimit;
  };
  prototypeAccessors$2.keepAliveIntervalsLimit.set = function (newValue) {
    this._kaIntervalsLimit = newValue;
  };

  // ======================== P2P Inbox ========================

  /**
   * @name solace.SessionProperties#p2pInboxInUse
   * @type {String}
   * @description A read-only string that indicates the default
   * reply-to destination used for any request messages sent from this session.
   * See {@link solace.Session#sendRequest}.
   * This parameter is only valid when the session is connected.
   * @default ""
   * @readonly
   */
  prototypeAccessors$2.p2pInboxInUse.get = function () {
    return Check.nothing(this._p2pInboxInUse) ? '' : this._p2pInboxInUse;
  };
  /**
   * @private
   * @param {String} value The current P2P subscription.
   */
  SessionProperties.prototype._setP2pInboxInUse = function _setP2pInboxInUse (value) {
    this._p2pInboxInUse = value;
  };

  /**
   * @private
   *
   * @name solace.SessionProperties#p2pInboxBase
   * @description A read-only information string that stores the P2P topic subscription
   * obtained from the Solace Message Router.
   * This parameter is only valid when the session is connected.
   * @default  ""
   * @readonly
   */
  prototypeAccessors$2.p2pInboxBase.get = function () {
    return Check.nothing(this._p2pInboxBase) ? '' : this._p2pInboxBase;
  };
  /**
   * @private
   * @param {String} value The current P2P inbox root subscription. The subscription on the router
   *   additionally contains '/>', so extra topic levels can be added to this root and messages to
   *   those topics will be attracted with the subscription.
   */
  SessionProperties.prototype._setP2pInboxBase = function _setP2pInboxBase (value) {
    this._p2pInboxBase = value;
  };

  /**
   * @name solace.SessionProperties#userIdentification
   * @type {String}
   * @description A read-only string providing information
   * about the application, such as the name of operating system
   * that is running the application.
   * @default  ""
   * @readonly
   */
  prototypeAccessors$2.userIdentification.get = function () {
    return Check.nothing(this._userIdentification) ? '' : this._userIdentification;
  };
  /**
   * @private
   * @param {String} value The current userId
   */
  SessionProperties.prototype._setUserIdentification = function _setUserIdentification (value) {
    this._userIdentification = value;
  };

  // ================== Subscriptions ========================
  /**
   *
   * @name solace.SessionProperties#subscriberLocalPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority. Subscribers have two priorities; this
   * priority is for messages published locally.
   *  * The valid range is 1..4
   * @default 1
   */
  prototypeAccessors$2.subscriberLocalPriority.get = function () {
    return Check.nothing(this._subLocalPriority) ? 1 : this._subLocalPriority;
  };
  prototypeAccessors$2.subscriberLocalPriority.set = function (newValue) {
    this._subLocalPriority = newValue;
  };

  /**
   * @name solace.SessionProperties#subscriberNetworkPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority.
   *
   * Subscribers have two priorities; this priority is for messages published on Solace Message
   * Routers other than the one that the client is connected to.
   *  * The valid range is 1..4
   * @default  1
   */
  prototypeAccessors$2.subscriberNetworkPriority.get = function () {
    return Check.nothing(this._subNetworkPriority) ? 1 : this._subNetworkPriority;
  };
  prototypeAccessors$2.subscriberNetworkPriority.set = function (newValue) {
    this._subNetworkPriority = newValue;
  };

  /**
   * @name solace.SessionProperties#ignoreDuplicateSubscriptionError
   * @type {Boolean}
   * @description Used to ignore duplicate subscription errors on subscribe.
   * @default  true
   */
  prototypeAccessors$2.ignoreDuplicateSubscriptionError.get = function () {
    return Check.nothing(this._ignoreDupSubError) ? true : this._ignoreDupSubError;
  };
  prototypeAccessors$2.ignoreDuplicateSubscriptionError.set = function (newValue) {
    this._ignoreDupSubError = newValue;
  };

  /**
   * @name solace.SessionProperties#ignoreSubscriptionNotFoundError
   * @type {Boolean}
   * @description Used to ignore subscription not found errors on unsubscribe.
   * @default  true
   */
  prototypeAccessors$2.ignoreSubscriptionNotFoundError.get = function () {
    return Check.nothing(this._ignoreSubNotFoundError) ? true : this._ignoreSubNotFoundError;
  };
  prototypeAccessors$2.ignoreSubscriptionNotFoundError.set = function (newValue) {
    this._ignoreSubNotFoundError = newValue;
  };

  /**
   *
   * @name solace.SessionProperties#reapplySubscriptions
   * @type {Boolean}
   * @description Set to 'true' to have the API remember subscriptions and reapply them upon
   * calling {@link solace.Session#connect} on a disconnected session.
   * @default  false
   */
  prototypeAccessors$2.reapplySubscriptions.get = function () {
    return Check.nothing(this._reapplySubcriptions) ? false : this._reapplySubcriptions;
  };
  prototypeAccessors$2.reapplySubscriptions.set = function (newValue) {
    this._reapplySubcriptions = newValue;
  };

  // ================== AD configuration ========================
  /**
   * Sets the guaranteed messaging publisher properties for the session.
   * If the supplied value is not a {@link solace.MessagePublisherProperties},
   * one will be constructed using the supplied value as an argument.
   *
   * @name solace.SessionProperties#publisherProperties
   * @type {solace.MessagePublisherProperties}
   */
  prototypeAccessors$2.publisherProperties.get = function () {
    return this._publisherProperties;
  };
  prototypeAccessors$2.publisherProperties.set = function (val) {
    var MessagePublisherProperties = PublisherLib.MessagePublisherProperties;
    this._publisherProperties = val instanceof MessagePublisherProperties
      ? val
      : new MessagePublisherProperties(val);
  };

  // ================== Transport configuration ========================

  /**
   *
   * @name solace.SessionProperties#noLocal
   * @type {Boolean}
   * @description Set to 'true' to signal the Solace Message Router that messages published on the
   * session should not be received on the same session even if the client has a subscription that
   * matches the published topic. If this restriction is requested, and the Solace Message Router
   * does not have No Local support, the session connect will fail.
   * @default  false
   */
  prototypeAccessors$2.noLocal.get = function () {
    return Check.nothing(this._noLocal) ? false : this._noLocal;
  };
  prototypeAccessors$2.noLocal.set = function (newValue) {
    this._noLocal = newValue;
  };

  /**
   * @name solace.SessionProperties#readTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a reply to
   * come back from the Solace Message Router. This timeout serves as the default
   * request timeout for {@link solace.Session#subscribe},
   * {@link solace.Session#unsubscribe}, {@link solace.Session#updateProperty}.
   *  * The valid range is >= 0.
   * @default 10000
   */
  prototypeAccessors$2.readTimeoutInMsecs.get = function () {
    return Check.nothing(this._readTimeout) ? 10000 : this._readTimeout;
  };
  prototypeAccessors$2.readTimeoutInMsecs.set = function (newValue) {
    this._readTimeout = newValue;
  };

  /**
   * @name solace.SessionProperties#sendBufferMaxSize
   * @type {Number}
   * @description The maximum buffer size for the transport session. This size must be bigger
   * than the largest message an application intends to send on the session.
   *
   * The session buffer size configured using the sendBufferMaxSize
   * session property controls SolClient buffering of transmit messages. When
   * sending small messages, the session buffer size should be set to multiple times
   * the typical message size to improve the performance. Regardless of the buffer
   * size, SolClient always accepts at least one message to transmit. So even if a
   * single message exceeds sendBufferMaxSize, it is accepted and
   * transmitted as long as the current buffered data is zero. However, no more
   * messages are accepted until the amount of data buffered is reduced
   * enough to allow room below sendBufferMaxSize.
   *  * The valid range is > 0.
   *
   * @default 65536 (64KB)
   */
  prototypeAccessors$2.sendBufferMaxSize.get = function () {
    return Check.nothing(this._sendBufferMaxSize) ? (64 * 1024) : this._sendBufferMaxSize;
  };
  prototypeAccessors$2.sendBufferMaxSize.set = function (newValue) {
    this._sendBufferMaxSize = newValue;
  };

  /**
   * @name solace.SessionProperties#maxWebPayload
   * @type {Number}
   * @description The maximum payload size (in bytes) when sending data using the Web transport
   * protocol.  Large messages may fail to be sent to the Solace Message Router when the maximum web
   * payload is set to a small value. To avoid this, use a large maximum web payload.
   *  * The valid range is >= 100.
   * @default 1048576 (1MB)
   */
  prototypeAccessors$2.maxWebPayload.get = function () {
    return Check.nothing(this._maxWebPayload) ? (1024 * 1024) : this._maxWebPayload;
  };
  prototypeAccessors$2.maxWebPayload.set = function (newValue) {
    this._maxWebPayload = newValue;
  };


  /**
   * @private
   */
  prototypeAccessors$2.nonHTTPTransportPropsSet.get = function () {
    var this$1 = this;

      // Calculate on demand based on presence of properties.
      // Currently not tracking this so no property names listed.
    return [].filter(function (k) { return Check.something(this$1[k]); });
  };

  /**
   * @returns {String} A brief description of this object
   * @private
   */
  SessionProperties.prototype[util.inspect.custom] = function () {
    return Object.assign(this._lendsInspect(), {
      'authenticationScheme':             AuthenticationScheme.describe(this.authenticationScheme),
      'url':                              this.url,
      'password':                         this.password ? '*****' : this.password,
      'userName':                         this.userName,
      'clientName':                       this.clientName,
      'applicationDescription':           this.applicationDescription,
      'vpnName':                          this.vpnName,
      'vpnNameInUse':                     this.vpnNameInUse,
      'virtualRouterName':                this.virtualRouterName,
      'connectTimeoutInMsecs':            this.connectTimeoutInMsecs,
      'connectRetries':                   this.connectRetries,
      'connectRetriesPerHost':            this.connectRetriesPerHost,
      'reconnectRetryWaitInMsecs':        this.reconnectRetryWaitInMsecs,
      'reconnectRetries':                 this.reconnectRetries,
      'generateSendTimestamps':           this.generateSendTimestamps,
      'generateReceiveTimestamps':        this.generateReceiveTimestamps,
      'includeSenderId':                  this.includeSenderId,
      'generateSequenceNumber':           this.generateSequenceNumber,
      'keepAliveIntervalInMsecs':         this.keepAliveIntervalInMsecs,
      'keepAliveIntervalsLimit':          this.keepAliveIntervalsLimit,
      'p2pInboxInUse':                    this.p2pInboxInUse,
      'p2pInboxBase':                     this.p2pInboxBase,
      'userIdentification':               this.userIdentification,
      'subscriberLocalPriority':          this.subscriberLocalPriority,
      'subscriberNetworkPriority':        this.subscriberNetworkPriority,
      'ignoreDuplicateSubscriptionError': this.ignoreDuplicateSubscriptionError,
      'reapplySubscriptions':             this.reapplySubscriptions,
      'publisherProperties':              this.publisherProperties,
      'noLocal':                          this.noLocal,
      'readTimeoutInMsecs':               this.readTimeoutInMsecs,
      'sendBufferMaxSize':                this.sendBufferMaxSize,
      'maxWebPayload':                    this.maxWebPayload,
    });
  };

  /**
   * @name solace.SessionProperties#toString
   * @description Returns a human-readable representation of this Session, subject to change.
   * @returns {String} A brief description of this object
   */
  SessionProperties.prototype.toString = function toString () {
    return SessionPropertiesBase.prototype.toString.call(this); // only here for the docs
  };

  Object.defineProperties( SessionProperties.prototype, prototypeAccessors$2 );

  return SessionProperties;
}(SessionPropertiesBase));

// Don't try to evaluate these constants in browser mode
if (true) {
  /**
   * @description The default comma separated list of cipher suites in
   * order of preference used for SSL connections.
   * @constant
   * @type {String}
   */
  SessionProperties.DEFAULT_CIPHER_SUITES = DEFAULT_CIPHER_SUITES;

  /**
   * A list of cipher suites supported by the API when using SSL connections
   * @constant
   * @type {string[]}
   * @private
   */
  SessionProperties.SUPPORTED_CIPHER_SUITES = SUPPORTED_CIPHER_SUITES;

  /**
   * SSL protocols supported by the API when using SSL connections
   * @type {string[]}
   * @private
   */
  SessionProperties.SUPPORTED_SSL_PROTOCOLS = SUPPORTED_SSL_PROTOCOLS;

  /* eslint-disable */ // don't mangle import
  SessionProperties.SslProtocolExcludeConstantMap = ( obj = {}, obj['sslv2'] = NodeSslConstants['SSL_OP_NO_SSLv2'] || 0, obj['sslv3'] = NodeSslConstants['SSL_OP_NO_SSLv3'] || 0, obj['tlsv1'] = NodeSslConstants['SSL_OP_NO_TLSv1'] || 0, obj['tlsv1.1'] = NodeSslConstants['SSL_OP_NO_TLSv1_1'] || 0, obj['tlsv1.2'] = NodeSslConstants['SSL_OP_NO_TLSv1_2'] || 0, obj );
  var obj;
  /* eslint-enable */ // don't mangle import
}


module.exports.SessionProperties = SessionProperties;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionRequestType = {
  ADD_SUBSCRIPTION:        0,
  REMOVE_SUBSCRIPTION:     1,
  ADD_P2PINBOX:            2,
  REMOVE_P2PINBOX:         3,
  REMOVE_DTE_SUBSCRIPTION: 100,
};

module.exports.SessionRequestType = Enum.new(SessionRequestType);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(0);
var BidiMap = ref.BidiMap;
var Lazy = ref.Lazy;
var ref$1 = __webpack_require__(3);
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(120);
var ContentSummaryElement = ref$2.ContentSummaryElement;
var ref$3 = __webpack_require__(45);
var ContentSummaryType = ref$3.ContentSummaryType;
var ref$4 = __webpack_require__(1);
var LOG_ERROR = ref$4.LOG_ERROR;
var ref$5 = __webpack_require__(13);
var SMFUH = ref$5.SMFUH;

var lazyValue = Lazy.lazyValue;
var int8ToStr = Convert.int8ToStr;
var int16ToStr = Convert.int16ToStr;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var strToInt24 = Convert.strToInt24;
var strToInt32 = Convert.strToInt32;

var delModeEnumBidiMap = lazyValue(
  function () {
    // Single bidirectional map for lookups. Note that the forward
    // keys are converted to strings.
    var source = [
      [0x00, MessageLib.MessageDeliveryModeType.NON_PERSISTENT],
      [0x01, MessageLib.MessageDeliveryModeType.PERSISTENT],
      [0x02, MessageLib.MessageDeliveryModeType.DIRECT] ].map(function (el) { return [el[0], el[1]]; });
    return new (Function.prototype.bind.apply( BidiMap, [ null ].concat( source) ));
  });
var lutDelModeToEnum = lazyValue(function () { return delModeEnumBidiMap.value.forward; });
var lutEnumToDelMode = lazyValue(function () { return delModeEnumBidiMap.value.reverse; });

/**
 * SMF TLV Param LUT
 * utTypeMap[uh][paramtype] is the binary prefix for a regular (not LW) TLV
 * parameter with uh and paramtype values as accessed in the array.
 *
 * @private
 */
var uhTypeMap = (function () {
  var result = [];
  var paramTypeBits = 5;
  var paramTypeCount = Math.pow(2, paramTypeBits);
  SMFUH.values.forEach(function (uh) {
    result[uh] = [];
    for (var i = 0; i < paramTypeCount; ++i) {
      var byte1 = 0;
      byte1 = Bits.set(byte1, uh, 6, 2);
      byte1 = Bits.set(byte1, i, 0, paramTypeBits);
      result[uh][i] = int8ToStr(byte1);
    }
  });
  return result;
})();

/**
 * SMF TLV length map LUT
 *
 * lenMap[x] === String.fromCharCode(x)
 *
 * @private
 */
var lenMap = (new Array(256).fill(null).map(function (_, idx) { return int8ToStr(idx); }));

/**
 * SMF Lightweight Param LUT
 *
 * lightMap[uh][paramtype][len] is the prefix for an SMF LWP
 * with uh, paramtype and len values as accessed in the array.
 *
 * @private
 */
var lightMap = (function () {
  var result = [];
  var paramTypeBits = 3;
  var paramTypeCount = Math.pow(2, paramTypeBits);
  var lenBits = 2;
  var lenCount = Math.pow(2, lenBits);
  SMFUH.values.forEach(function (uh) {
    result[uh] = [];
    for (var i = 0; i < paramTypeCount; ++i) {
      result[uh][i] = [];
      for (var j = 0; j < lenCount; ++j) {
        var byte1 = 0;
        byte1 = Bits.set(byte1, uh, 6, 2);
        byte1 = Bits.set(byte1, 1, 5, 1);
        byte1 = Bits.set(byte1, i, 2, 3);
        byte1 = Bits.set(byte1, j, 0, 2);
        result[uh][i][j] = int8ToStr(byte1);
      }
    }
  });
  return result;
})();

var ContentSummaryDecodeMap = [
  ContentSummaryType.XML_META,
  ContentSummaryType.XML_PAYLOAD,
  ContentSummaryType.BINARY_ATTACHMENT,
  ContentSummaryType.CID_LIST,
  ContentSummaryType.BINARY_METADATA ];

var ParamParse = {

  parseTopicQueueOffsets: function parseTopicQueueOffsets(data, offset) {
    var result = [];
    result[0] = strToInt8(data.substr(offset, 1));
    result[1] = strToInt8(data.substr(offset + 1, 1));
    return result;
  },

  parseResponseParam: function parseResponseParam(data, offset, paramLen) {
    var result = [];
    result[0] = strToInt32(data.substr(offset, 4));
    var respStrLen = paramLen - 4;
    if (respStrLen > 0) {
      result[1] = data.substr(offset + 4, respStrLen);
    } else {
      result[1] = '';
    }
    return result;
  },

  parseDeliveryMode: function parseDeliveryMode(data, offset) {
    var delmode = strToInt8(data.substr(offset, 1));
    var lookup = lutDelModeToEnum.value.get(delmode);
    return lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT;
  },

  encDeliveryMode: function encDeliveryMode(delmode) {
    var lut = lutEnumToDelMode.value;
    var lookup = lut.get(delmode);
    return int8ToStr(lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT);
  },

  parseContentSummary: function parseContentSummary(data, offset, length) {
    var elements = [];
    var cumulativeSize = 0;
    var pos = offset;

    while (pos < offset + length) {
      var byte1 = strToInt8(data.charAt(pos));
      var elementType = Bits.get(byte1, 4, 4);
      var elementDeclaredLength = Bits.get(byte1, 0, 4);
      var elementSize = 0;
      switch (elementDeclaredLength) {
        case 2:
          elementSize = strToInt8(data.substr(pos + 1, 1));
          break;
        case 3:
          elementSize = strToInt16(data.substr(pos + 1, 2));
          break;
        case 4:
          elementSize = strToInt24(data.substr(pos + 1, 3));
          break;
        case 5:
          elementSize = strToInt32(data.substr(pos + 1, 4));
          break;
        default:
          // Allow 1 and continue;
          break;
      }

      if (elementDeclaredLength === 0) {
        LOG_ERROR('Invalid content summary parameter - pos not advancing');
        return null;
      }
      pos += elementDeclaredLength;

      var cst = ContentSummaryDecodeMap[elementType];
      if (cst === undefined) {
        LOG_ERROR(("Unhandled element type " + elementType));
      }
      var currentElement = new ContentSummaryElement(cst, cumulativeSize, elementSize);
      elements.push(currentElement);
      cumulativeSize += elementSize;
    } // end while loop
    return elements;
  },

  encContentSummary: function encContentSummary(contentSummaryArr) {
    var messageElementDescriptions = [];
    for (var i = 0, n = contentSummaryArr.length; i < n; ++i) {
      // a ContentSummaryElement
      var currentContentSummary = contentSummaryArr[i];
      var currentSizeStr = '';
      var firstByte = Bits.set(0, currentContentSummary.type, 4, 4);
      if (currentContentSummary.length <= 255) {
        // element length: 2
        firstByte = Bits.set(firstByte, 2, 0, 4);
        currentSizeStr = int8ToStr(currentContentSummary.length);
      } else if (currentContentSummary.length <= 65535) {
        firstByte = Bits.set(firstByte, 3, 0, 4);
        currentSizeStr = int16ToStr(currentContentSummary.length);
      } else if (currentContentSummary.length <= 16777215) {
        firstByte = Bits.set(firstByte, 4, 0, 4);
        currentSizeStr = int24ToStr(currentContentSummary.length);
      } else {
        firstByte = Bits.set(firstByte, 5, 0, 4);
        currentSizeStr = int32ToStr(currentContentSummary.length);
      }
      messageElementDescriptions.push(int8ToStr(firstByte));
      messageElementDescriptions.push(currentSizeStr);
    }
    return messageElementDescriptions.join('');
  },

  encodeSMFParam: function encodeSMFParam(uh, paramtype, value) {
    if (value === undefined) {
      return uhTypeMap[uh][paramtype] + lenMap[2];
    }
    var len = value.length;
    if (len <= 253) {
      return uhTypeMap[uh][paramtype] + lenMap[len + 2] + value;
    }
    return uhTypeMap[uh][paramtype] + lenMap[0] + int32ToStr(len + 6) + value;
  },

  encLightSMFParam: function encLightSMFParam(uh, paramtype, value) {
    return lightMap[uh][paramtype][value.length] + value;
  },

};

module.exports.ParamParse = ParamParse;


/***/ }),
/* 77 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * A representation of an SMF parameter
 *
 * @private
 */
var SMFParameter = function SMFParameter(uh, type, value) {
  this._type = type;
  this._value = value;
  this._uh = uh;
};
SMFParameter.prototype.getType = function getType () {
  return this._type;
};
SMFParameter.prototype.getValue = function getValue () {
  return this._value;
};
SMFParameter.prototype.getUh = function getUh () {
  return this._uh;
};
SMFParameter.prototype.toString = function toString () {
  return ((this._uh) + ":0x" + (this._type.toString(16)) + " = " + (this._value));
};

module.exports.SMFParameter = SMFParameter;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFParameterType = {
  // SMF parameter type
  PADDING:                  0x00,
  PUBLISHER_ID:             0x01,
  PUBLISHER_MSGID:          0x02,
  MESSAGEPRIORITY:          0x03,
  USERDATA:                 0x04,
  USERNAME:                 0x06,
  PASSWORD:                 0x07,
  RESPONSE:                 0x08,
  SUB_ID_LIST:              0x0A,
  GENERIC_ATTACHMENT:       0x0B,
  BINARY_ATTACHMENT:        0x0C,
  DELIVERY_MODE:            0x10,
  ASSURED_MESSAGE_ID:       0x11,
  ASSURED_PREVMESSAGE_ID:   0x12,
  ASSURED_REDELIVERED_FLAG: 0x13,
  MESSAGE_CONTENT_SUMMARY:  0x16,
  ASSURED_FLOWID:           0x17,
  TR_TOPICNAME:             0x18,
  AD_FLOWREDELIVERED_FLAG:  0x19,
  AD_TIMETOLIVE:            0x1C,
  AD_TOPICSEQUENCE_NUMBER:  0x1e,

  LIGHT_CORRELATION:       0x00,
  LIGHT_TOPIC_NAME_OFFSET: 0x01,
  LIGHT_QUEUE_NAME_OFFSET: 0x02,
  LIGHT_ACK_IMMEDIATELY:   0x03,
};

module.exports.SMFParameterType = Enum.new(SMFParameterType);


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFSMPMessageType = {
  ADDSUBSCRIPTION:              0x00,
  REMSUBSCRIPTION:              0x01,
  ADDQUEUESUBSCRIPTION:         0x02,
  REMQUEUESUBSCRIPTION:         0x03,
  ADDSUBSCRIPTIONFORCLIENTNAME: 0x04,
  REMSUBSCRIPTIONFORCLIENTNAME: 0x05,
};

module.exports.SMFSMPMessageType = Enum.new(SMFSMPMessageType);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(132);
var CacheCBInfo = ref.CacheCBInfo;
var ref$1 = __webpack_require__(81);
var CacheContext = ref$1.CacheContext;
var ref$2 = __webpack_require__(133);
var CacheLiveDataAction = ref$2.CacheLiveDataAction;
var ref$3 = __webpack_require__(135);
var CacheRequest = ref$3.CacheRequest;
var ref$4 = __webpack_require__(134);
var CacheRequestResult = ref$4.CacheRequestResult;
var ref$5 = __webpack_require__(136);
var CacheReturnCode = ref$5.CacheReturnCode;
var ref$6 = __webpack_require__(137);
var CacheReturnSubcode = ref$6.CacheReturnSubcode;
var ref$7 = __webpack_require__(233);
var CacheSession = ref$7.CacheSession;
var ref$8 = __webpack_require__(138);
var CacheSessionProperties = ref$8.CacheSessionProperties;

module.exports.CacheCBInfo = CacheCBInfo;
module.exports.CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
module.exports.CacheLiveDataAction = CacheLiveDataAction;
module.exports.CacheRequestResult = CacheRequestResult;
module.exports.CacheReturnCode = CacheReturnCode;
module.exports.CacheReturnSubcode = CacheReturnSubcode;
module.exports.CacheRequest = CacheRequest;
module.exports.CacheSession = CacheSession;
module.exports.CacheSessionProperties = CacheSessionProperties;



/***/ }),
/* 81 */
/***/ (function(module, exports) {

/**
 * @private
 * @static
 */
var CacheContext = {
  /**
   * A prefix appearing on the request IDs of all requests associated with a Solcache session.
   * @type {String}
   * @private
   */
  CACHE_REQUEST_PREFIX: '#CRQ',

  /**
   * A global counter generating unique correlation IDs for cache requests.
   * @private
   */
  cacheRequestCorrelationId: 0,
};

module.exports.CacheContext = CacheContext;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Statistics for sent/received messages and control operations.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var StatType = {

  // ------- SMF and Direct Messaging

  /**
   * Count of bytes sent as part of data messages.
   */
  TX_TOTAL_DATA_BYTES:            0,
  /**
   * Count of data messages sent.
   */
  TX_TOTAL_DATA_MSGS:             1,
  /**
   * Count of bytes sent as part of direct data messages.
   */
  TX_DIRECT_BYTES:                2,
  /**
   * Count of direct data messages sent.
   */
  TX_DIRECT_MSGS:                 3,
  /**
   * Count of bytes sent as part of control messages.
   */
  TX_CONTROL_BYTES:               4,
  /**
   * Count of control messages sent.
   */
  TX_CONTROL_MSGS:                5,
  /**
   * Count of request messages sent.
   */
  TX_REQUEST_SENT:                6,
  /**
   * Count of request timeouts that occurred.
   */
  TX_REQUEST_TIMEOUT:             7,
  /**
   * Count of bytes received as part of data messages.
   */
  RX_TOTAL_DATA_BYTES:            8,
  /**
   * Count of data messages received.
   */
  RX_TOTAL_DATA_MSGS:             9,
  /**
   * Count of bytes received as part of direct data messages.
   */
  RX_DIRECT_BYTES:                10,
  /**
   * Count of direct data messages received.
   */
  RX_DIRECT_MSGS:                 11,
  /**
   * Count of bytes received as part of control messages.
   */
  RX_CONTROL_BYTES:               12,
  /**
   * Count of control messages received.
   */
  RX_CONTROL_MSGS:                13,
  /**
   * Count discard message indications received on incoming messages.
   */
  RX_DISCARD_MSG_INDICATION:      14,
  /**
   * Count of reply messaged received.
   */
  RX_REPLY_MSG_RECVED:            15,
  /**
   * Count of received reply messages that were discarded.
   */
  RX_REPLY_MSG_DISCARD:           16,
  /**
   * @description
   * Count of messages discarded due to the presence of an unknown element or
   * unknown protocol in the SMF header.
   */
  RX_DISCARD_SMF_UNKNOWN_ELEMENT: 17,

  // ------- SolCache Session

  /**
   * @description
   * Count of cache requests sent. One conceptual request (i.e. one API call)
   * may involve many requests and replies.
   */
  CACHE_REQUEST_SENT:                     18,
  /**
   * @description
   * Count of OK responses to cache requests.
   */
  CACHE_REQUEST_OK_RESPONSE:              19,
  /**
   * @description
   * Count of cache requests that returned a failure response.
   */
  CACHE_REQUEST_FAIL_RESPONSE:            20,
  /**
   * @description
   * Count of cache replies discarded because a request has been fulfilled.
   */
  CACHE_REQUEST_FULFILL_DISCARD_RESPONSE: 21,
  /**
   * @description
   * Count of cached messages delivered to the application.
   */
  RX_CACHE_MSG:                           22,
  /**
   * @description
   * Count of cache requests that were incomplete.
   */
  CACHE_REQUEST_INCOMPLETE_RESPONSE:      23,
  /**
   * @description
   * The cache session operation completed when live data arrived on the requested topic.
   */
  CACHE_REQUEST_LIVE_DATA_FULFILL:        24,

  // ------ Guaranteed Messaging

  /**
   * Count of bytes sent as part of persistent data messages.
   */
  TX_PERSISTENT_BYTES:                25,
  /**
   * Count of persistent data messages sent.
   */
  TX_PERSISTENT_MSGS:                 26,
  /**
   * Count of non-persistent data bytes sent.
   */
  TX_NONPERSISTENT_BYTES:             27,
  /**
   * Count of non-persistent data messages sent.
   */
  TX_NONPERSISTENT_MSGS:              28,
  /**
   * The number of bytes redelivered in Persistent messages.
   */
  TX_PERSISTENT_BYTES_REDELIVERED:    29,
  /**
   * The number of Persistent messages redelivered.
   */
  TX_PERSISTENT_REDELIVERED:          30,
  /**
   * The number of bytes redelivered in Non-Persistent messages.
   */
  TX_NONPERSISTENT_BYTES_REDELIVERED: 31,
  /**
   * The number of Non-Persistent messages redelivered.
   */
  TX_NONPERSISTENT_REDELIVERED:       32,
  /**
   * The number of acknowledgments received.
   */
  TX_ACKS_RXED:                       33,
  /**
   * The number of times the transmit window closed.
   */
  TX_WINDOW_CLOSE:                    34,
  /**
   * The number of times the acknowledgment timer expired.
   */
  TX_ACK_TIMEOUT:                     35,
  /**
   * Count of bytes received as part of persistent data messages.
   */
  RX_PERSISTENT_BYTES:                36,
  /**
   * Count of persistent data messages received.
   */
  RX_PERSISTENT_MSGS:                 37,
  /**
   * Count of bytes received as part of non-persistent data messages.
   */
  RX_NONPERSISTENT_BYTES:             38,
  /**
   * Count of non-persistent data messages received.
   */
  RX_NONPERSISTENT_MSGS:              39,
  /**
   * Count of acknowledgements sent to the Solace Message Router
   * for guaranteed messages received by the API.
   */
  RX_ACKED:                           40,
  /**
   * Count of guaranteed messages discarded for being duplicates.
   */
  RX_DISCARD_DUPLICATE:               41,
  /**
   * Count of guaranteed messages discarded due to no match message consumer for the message.
   */
  RX_DISCARD_NO_MATCHING_CONSUMER:    42,
  /**
   * Count of guaranteed messages discarded for being received out of order.
   */
  RX_DISCARD_OUT_OF_ORDER:            43,
};

module.exports.StatType = Enum.new(StatType);


/***/ }),
/* 83 */
/***/ (function(module, exports) {

var BaseSMFClient = function BaseSMFClient(rxSmfCB, rxMessageErrorCB, session) {
  this.reset();
  this._rxSmfCB = rxSmfCB; // callback for parsed msg
  this._rxMessageErrorCB = rxMessageErrorCB; // invalid UH, etc.
  this._session = session;
};

BaseSMFClient.prototype.reset = function reset () {
  this._correlationCounter = 0;
};

BaseSMFClient.prototype.nextCorrelationTag = function nextCorrelationTag () {
  // Login uses the max value as a sentinel, so wrap around early
  if (++this._correlationCounter >= BaseSMFClient.SMF_MAX_CORRELATION) {
    this._correlationCounter = 1;
  }
  return this._correlationCounter;
};

BaseSMFClient.SMF_MAX_CORRELATION = 0xFFFFFF;


module.exports.BaseSMFClient = BaseSMFClient;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var HTTPLib = __webpack_require__(85);
var ref = __webpack_require__(246);
var StateBase64 = ref.StateBase64;
var ref$1 = __webpack_require__(247);
var StateBinary = ref$1.StateBinary;
var ref$2 = __webpack_require__(248);
var StateStreamingAndBinary = ref$2.StateStreamingAndBinary;
var ref$3 = __webpack_require__(249);
var StateWebSocketBinary = ref$3.StateWebSocketBinary;
var ref$4 = __webpack_require__(252);
var WebTransport = ref$4.WebTransport;
var ref$5 = __webpack_require__(49);
var WebTransportCapabilities = ref$5.WebTransportCapabilities;

var ref$6 = __webpack_require__(9);
var SolclientFactory = ref$6.SolclientFactory;

SolclientFactory.addInitializer(function factoryInitializer() {
  // eslint-disable-next-line global-require
  var https = __webpack_require__(287);
  if (true) {
    // WebSocket transport:
    // use custom agent for client certificate and SSL session resume support
    this.wsSslAgent = new https.Agent({
      keepAlive: false,
    });
  }
});

var HTTPConnection = HTTPLib.HTTPConnection;
var HTTPTransportSession = HTTPLib.HTTPTransportSession;

module.exports.HTTPConnection = HTTPConnection;
module.exports.HTTPTransportSession = HTTPTransportSession;
module.exports.StateBase64 = StateBase64;
module.exports.StateBinary = StateBinary;
module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
module.exports.StateWebSocketBinary = StateWebSocketBinary;
module.exports.WebTransport = WebTransport;
module.exports.WebTransportCapabilities = WebTransportCapabilities;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(142);
var HTTPConnection = ref.HTTPConnection;
var ref$1 = __webpack_require__(244);
var HTTPTransportSession = ref$1.HTTPTransportSession;

if (false) {
  module.exports.HTTPConnection = HTTPConnection;
  module.exports.HTTPTransportSession = HTTPTransportSession;
}


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationUtilLib = __webpack_require__(26);
var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(50);
var Destination = ref$1.Destination;
var ref$2 = __webpack_require__(25);
var DestinationType = ref$2.DestinationType;

/**
 * @classdesc
 * Represents a Queue, which is a type of {@link solace.Destination}.
 *
 * Instances should be acquired through
 * {@link solace.SolclientFactory.createDurableQueueDestination} or by calling
 * {@link solace.MessageConsumer#getDestination} on a consumer bound to a temporary queue.
 *
 * @extends solace.Destination
 * @memberof solace
 * @private
 */
var Queue = (function (Destination) {
  function Queue(spec) {
    assert(spec.name, 'Queue name not supplied');
    assert(spec.type === DestinationType.QUEUE
           || spec.type === DestinationType.TEMPORARY_QUEUE, 'Queue spec.type is invalid');
    assert(spec.bytes, 'Queue spec missing bytes');
    assert(spec.offset !== undefined, 'Queue spec missing offset');
    Destination.call(this, spec);
  }

  if ( Destination ) Queue.__proto__ = Destination;
  Queue.prototype = Object.create( Destination && Destination.prototype );
  Queue.prototype.constructor = Queue;

  var prototypeAccessors = { offset: {} };

  Queue.prototype.getOffset = function getOffset () {
    return this._offset;
  };
  prototypeAccessors.offset.get = function () {
    return this.getOffset();
  };

  Queue.prototype[util.inspect.custom] = function () {
    return ("[Queue " + (this.getName()) + "]");
  };

  /**
   * @static
   * @param {String} queueName The name of the queue (no prefix)
   * @returns {Queue} a Queue
   * @private
   */
  Queue.createFromLocalName = function createFromLocalName (queueName) {
    var encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(
      DestinationType.QUEUE, queueName);
    if (encoding.error) {
      throw encoding.error;
    }
    return new Queue({
      name:         queueName,
      type:         DestinationType.QUEUE,
      isValidated:  true,
      bytes:        encoding.bytes,
      offset:       encoding.offset,
      isWildcarded: encoding.isWildcarded,
    });
  };

  Object.defineProperties( Queue.prototype, prototypeAccessors );

  return Queue;
}(Destination));

module.exports.Queue = Queue;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationUtilLib = __webpack_require__(26);
var util = __webpack_require__(6);
var ref = __webpack_require__(50);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(25);
var DestinationType = ref$1.DestinationType;

/**
 * @classdesc
 * Represents a Topic, which is a type of {@link solace.Destination}.
 *
 * @extends solace.Destination
 * @memberof solace
 * @deprecated since 10.0 Applications should not directly refer to this type.
 *  {@link solace.Destination} provides the full interface available to topic, and it can be
 *  determined whether the destination represents a topic if {@link solace.Destination#getType}
 *  returns {@link solace.DestinationType.TOPIC}.
 */
var Topic = (function (Destination) {
  function Topic(spec) {
    if (typeof spec === 'object') {
      Destination.call(this, {
        type:         DestinationType.TOPIC,
        name:         spec.name,
        bytes:        spec.bytes,
        offset:       spec.offset,
        isValidated:  spec.isValidated,
        isWildcarded: spec.isWildcarded,
      });
    } else {
      // Deprecated path -- super will do topic encode
      Destination.call(this, spec, DestinationType.TOPIC);
    }
  }

  if ( Destination ) Topic.__proto__ = Destination;
  Topic.prototype = Object.create( Destination && Destination.prototype );
  Topic.prototype.constructor = Topic;

  Topic.prototype[util.inspect.custom] = function () {
    return ("[Topic " + (this.getName()) + "]");
  };

  /**
   * @static
   * @param {String} topicName The name for the topic
   * @returns {Topic} the Topic
   * @private
   */
  Topic.createFromName = function createFromName (topicName) {
    var encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(
      DestinationType.TOPIC, topicName);
    if (encoding.error) {
      throw encoding.error;
    }
    return new Topic({
      name:         topicName,
      isValidated:  true,
      bytes:        encoding.bytes,
      offset:       encoding.offset,
      isWildcarded: encoding.isWildcarded,
    });
  };

  return Topic;
}(Destination));

module.exports.Topic = Topic;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(52);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown by the API when an operational error is encountered.
 * @memberof solace
 * @extends {solace.SolaceError}
 * @hideconstructor
 */
var OperationError = (function (SolaceError) {
  function OperationError(message, subcode, reason) {
    /**
     * The name of the error.
     * @name solace.OperationError#name
     * @type {Constant}
     * @description 'OperationError'
     */
    SolaceError.call(this, 'OperationError', message, OperationError);
    /**
     * The subcode for the error. @see {@link solace.ErrorSubcode}
     * @name solace.OperationError#subcode
     * @type {solace.ErrorSubcode}
     */
    this.subcode = subcode;
    /**
     * The reason for the error: an embedded error object or exception.
     * @name solace.OperationError#reason
     * @type {Object}
     */
    this.reason = reason;
  }

  if ( SolaceError ) OperationError.__proto__ = SolaceError;
  OperationError.prototype = Object.create( SolaceError && SolaceError.prototype );
  OperationError.prototype.constructor = OperationError;

  return OperationError;
}(SolaceError));

module.exports.OperationError = OperationError;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * An attribute of {@link solace.RequestError}. This enumeration represents the
 * different errors emitted by
 * {@link solace.Session.requestFailedCallback}
 * when a {@link solace.Sesssion#sendRequest} fails.
 *
 * The client application receives a request error with event code
 * {@link solace.RequestEventCode.REQUEST_ABORTED}
 * when the underlying connection is successfully closed, or closed as a result
 * of a communication error.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var RequestEventCode = {
  /**
   * A request was aborted because the session is disconnected.
   */
  REQUEST_ABORTED: 8,
  /**
   * The event represents a timed-out request API call.
   */
  REQUEST_TIMEOUT: 9,
};

module.exports.RequestEventCode = Enum.new(RequestEventCode);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

var DEFAULT_PROPERTY_OPTIONS = {
  enumerable: true,
};

function setPropertyValue(target, key, value, options) {
  if ( options === void 0 ) options = null;

  Object.defineProperty(
          target,
          key,
          Object.assign({ value: value }, DEFAULT_PROPERTY_OPTIONS, options));
}


function lazyProperty(target, key, evalFn) {
  Object.defineProperty(
    target,
    key,
    Object.assign({
      configurable: true, // Allow replacing this property with resolved value.
      get:          function () {
        // The getter evaluates the function provided.
        // It replaces itself with the value it resolves.
        var result = evalFn(target, key);
        setPropertyValue(target, key, result);
        return result;
      },
      set: function (value) {
        setPropertyValue(target, key, value);
      },
    }, DEFAULT_PROPERTY_OPTIONS));
  return target;
}

function lazyProperties(target, obj) {
  Object.keys(obj).forEach(function (k) {
    lazyProperty(target, k, obj[k]);
  });
  return obj;
}

function lazyValue(evalFn) {
  return lazyProperty({}, 'value', evalFn);
}

var Lazy = {
  lazyProperties: lazyProperties,
  lazyProperty: lazyProperty,
  lazyValue: lazyValue,
};

module.exports.Lazy = Lazy;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var OperationError = ref.OperationError;

var binding = null;

var ProfileBinding = {
  get value() {
    if (binding === null) {
      throw new OperationError('Profile binding not initialized. Call solace.SolclientFactory.init');
    }
    return binding;
  },
  set value(value) {
    // private, so we'll allow it for testing
    binding = value;
  },
};

module.exports.ProfileBinding = ProfileBinding;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);

// Preferred configuration for the profile system:

// End user:
//  opaque profiles, property-style access
// API implementation:
//  inherited properties, property-style access
// A root, forward compatible profile
// A legacy, backwards compatible profile
// Feature/milestone profiles that inherit from one of these two configurations

// The lowest-friction way of doing this is using prototype inheritance.
// Also considered:
//  getProperty() with child->parent pointers -- mixes string
//    and property access
//  ES6 proxies -- not universal and not shimmable

// Necessary to abuse prototype inheritance for static property inheritance:
/* eslint-disable class-methods-use-this */

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactoryProfiles}.</b>
 *
 * A factory profile determines the default functionality of the API. Profiles are predefined
 * combinations of capabilities that represent a mutually-consistent, valid configuration state
 * for API features.
 *
 * The factory may be initialized exactly once, with a single factory profile.
 *
 * Changing which factory profile is used by {@link solace.SolclientFactory.init} may result in
 * different default property values, validation, function signatures and implementations.
 *
 * Changing the factory profile will not change relationships between API methods. That is,
 * assuming all properties and arguments are explicitly set, an application may call the
 * API with the same values as before to cause the same result, unless explicitly noted.
 *
 * If no profile is specified, the default will provide equivalent functionality to
 * SolclientJS version 7.x. New applications are encouraged to use the
 * {@link solace.SolclientFactoryProfiles.version10} profile for the best compatibility with
 * other APIs (excluding 7.x JavaScript APIs).
 *
 * @memberof solace
 * @private
 */
var FactoryProfile = function FactoryProfile () {};

var prototypeAccessors = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

prototypeAccessors.guaranteedMessagingEnabled.get = function () { return undefined; };

/**
 * Returns whether the API will allow Comet (long-held HTTP request) transports
 * to be used. If this is `true`, transport protocols may fall back to HTTP
 * if a connection cannot be established with a preferred protocol.
 *
 ** NOTE: Guaranteed Messaging cannot be enabled if Comet is enabled.
 *
 * @type {Boolean}
 * @readonly
 * @target browser
 */
prototypeAccessors.cometEnabled.get = function () { return undefined; };

/**
 * Returns whether the API performs UTF-8 encoding on user strings where the SMF
 * spec requires it.
 ** When this is `true`, the API will correctly interoperate with other Solace APIs that send
 *  UTF-8 encoded topics.
 ** When this is `false`, the API will interoperate correctly with 7.x and earlier JavaScript
 *  APIs, that used an arbitrary encoding for such strings.
 *
 * @readonly
 */
prototypeAccessors.topicUtf8Encode.get = function () { return undefined; };

FactoryProfile.prototype[util.inspect.custom] = function () {
  return {
    'guaranteedMessagingEnabled': this.guaranteedMessagingEnabled,
    'cometEnabled':             this.cometEnabled,
    'topicUtf8Encode':          this.topicUtf8Encode,
  };
};

FactoryProfile.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( FactoryProfile.prototype, prototypeAccessors );

/**
 * The Version 7 profile for SolclientJS. This profile sets factory and session default values
 * that provide SolclientJS 7.x behaviour, and interoperability with SolclientJS 7.x clients.
 *
 * @namespace
 * @type {solace.FactoryProfile}
 * @name version7
 * @memberof solace.SolclientFactoryProfiles
 */
var Version7Profile = (function (FactoryProfile) {
  function Version7Profile () {
    FactoryProfile.apply(this, arguments);
  }

  if ( FactoryProfile ) Version7Profile.__proto__ = FactoryProfile;
  Version7Profile.prototype = Object.create( FactoryProfile && FactoryProfile.prototype );
  Version7Profile.prototype.constructor = Version7Profile;

  var prototypeAccessors$1 = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

  prototypeAccessors$1.guaranteedMessagingEnabled.get = function () { return !!true; };

  /**
   * Returns true: Comet HTTP transports are enabled for the API. The API user may, by default,
   * select Comet HTTP transport protocol, and the API may fall back to these protocols during a
   * connection attempt.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
  /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
  prototypeAccessors$1.cometEnabled.get = function () { return !!false; };
  /**
   * Returns false: topic UTF-8 encoding is disabled for the API. The network encoding of topics is
   * compatible with other SolclientJS 7.x clients, and may not be interoperable with other
   * Solace Messaging APIs.
   *
   * @name solace.SolclientFactoryProfiles.version7.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
  prototypeAccessors$1.topicUtf8Encode.get = function () { return false; };

  Object.defineProperties( Version7Profile.prototype, prototypeAccessors$1 );

  return Version7Profile;
}(FactoryProfile));
var legacyInstance = new Version7Profile();

/**
 * The Version 10 profile for SolclientJS. This profile sets factory and session default values
 * that provide the full capability of the API as of version 10.0, including interoperability with
 * other Solace Messaging products.
 *
 * @namespace
 * @name version10
 * @memberof solace.SolclientFactoryProfiles
 */
var Version10Profile = (function (FactoryProfile) {
  function Version10Profile () {
    FactoryProfile.apply(this, arguments);
  }

  if ( FactoryProfile ) Version10Profile.__proto__ = FactoryProfile;
  Version10Profile.prototype = Object.create( FactoryProfile && FactoryProfile.prototype );
  Version10Profile.prototype.constructor = Version10Profile;

  var prototypeAccessors$2 = { guaranteedMessagingEnabled: {},cometEnabled: {},topicUtf8Encode: {} };

  prototypeAccessors$2.guaranteedMessagingEnabled.get = function () {
    return true;
  };
  /**
   * Returns `false`: Comet HTTP transports are disabled for the API. The API will not select or
   * fall back to HTTP Comet transport protocols, which are mutually exclusive of Guaranteed
   * Messaging features.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
  /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
  prototypeAccessors$2.cometEnabled.get = function () {
    return false;
  };
  /**
   * Returns `true`: the API will encode topics for interoperability with other Solace Messaging
   * products. SolclientJS 7.x clients may fail to correctly decode when topic names that include
   * multi-byte UTF-8 code points.
   *
   * @name solace.SolclientFactoryProfiles.version10.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
  prototypeAccessors$2.topicUtf8Encode.get = function () {
    return true;
  };

  Object.defineProperties( Version10Profile.prototype, prototypeAccessors$2 );

  return Version10Profile;
}(FactoryProfile));
var forwardInstance = new Version10Profile();

/**
 * The collection of predefined factory profiles available for application use.
 *
 * See each member for a description of its configuration.
 *
 * @namespace
 * @memberof solace
 */
var SolclientFactoryProfiles = {
  _legacy:  legacyInstance,
  _forward: forwardInstance,
  _default: legacyInstance,

  /**
   * The version 7 profile for browsers. {@link solace.SolclientFactoryProfiles.version7}
   *
   * The version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @type {solace.FactoryProfile}
   * @target browser
   */
  /**
   * The version 7 profile for Node.JS. {@link solace.SolclientFactoryProfiles.version7}
   *
   * A version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @type {solace.FactoryProfile}
   * @target node
   */
  version7: legacyInstance,

  /**
   * The version 10 profile for browsers.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @type {solace.FactoryProfile}
   * @target browser
   */
  /**
   * The version 10 profile for Node.JS.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @type {solace.FactoryProfile}
   * @target node
   */
  version10: forwardInstance,

  toString: function toString() {
    return util.inspect(this);
  },
};
SolclientFactoryProfiles[util.inspect.custom] = function () {
    return {
      'version7':  this.version7,
      'version10': this.version10,
    };
  };

module.exports.FactoryProfile = FactoryProfile;
module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;

function getDefaultLogLevel() {
  // break dependency loop
  // eslint-disable-next-line global-require
  var ref = __webpack_require__(1);
  var LogLevel = ref.LogLevel;
  return LogLevel.INFO;
}

/**
 * @classdesc
 * Properties used during initialization of {@link solace.SolclientFactory}.
 *
 * @memberof solace
 */
var SolclientFactoryProperties = (function (APIProperties) {
  function SolclientFactoryProperties(options) {
    APIProperties.call(this, {
      logLevel: getDefaultLogLevel(),
      logger:   null,
    }, options);
  }

  if ( APIProperties ) SolclientFactoryProperties.__proto__ = APIProperties;
  SolclientFactoryProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  SolclientFactoryProperties.prototype.constructor = SolclientFactoryProperties;

  var prototypeAccessors = { profile: {},logLevel: {},logger: {} };

  /**
   * The factory profile to use. The following factory profiles are available:
   * * {@link solace.SolclientFactoryProfiles.version7}, a backwards-compatible profile
   *      for existing solClientJS 7.x applications
   * * {@link solace.SolclientFactoryProfiles.version10}, the recommended profile
   *      for new applications
   *
   * @type {solace.FactoryProfiles}
   */
  prototypeAccessors.profile.get = function () {
    return this._profile;
  };
  prototypeAccessors.profile.set = function (profile) {
    this._profile = profile;
  };

  /**
   * The logging level to use for filtering log events. Messages with a level of lesser importance
   * than this will be filtered out and not logged.
   * @type {solace.LogLevel}
   */
  prototypeAccessors.logLevel.get = function () {
    return Check.number(this._logLevel) ? this._logLevel : getDefaultLogLevel();
  };
  prototypeAccessors.logLevel.set = function (val) {
    this._logLevel = val;
  };

  /**
   * The logging implementation to use. In the debug API, the log implementation will be called
   * for every log statement not filtered out by the log level. If no implementation is supplied,
   * the default implementation will be used, which logs to the global console object.
   * @type {solace.LogImpl}
   */
  prototypeAccessors.logger.get = function () {
    return this._logger || null;
  };
  prototypeAccessors.logger.set = function (val) {
    this._logger = val;
  };

  SolclientFactoryProperties.prototype[util.inspect.custom] = function () {
    // break dependency loop
    // eslint-disable-next-line global-require
    var ref = __webpack_require__(1);
    var LogLevel = ref.LogLevel;
    return {
      'logLevel': LogLevel.describe(this._logLevel),
      'profile':  this._profile,
    };
  };

  SolclientFactoryProperties.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( SolclientFactoryProperties.prototype, prototypeAccessors );

  return SolclientFactoryProperties;
}(APIProperties));

module.exports.SolclientFactoryProperties = SolclientFactoryProperties;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var FlowOperation = {
  CONNECT:         'FlowOperation_CONNECT',
  DISCONNECT:      'FlowOperation_DISCONNECT',
  START:           'FlowOperation_START',
  STOP:            'FlowOperation_STOP',
  DISPOSE:         'FlowOperation_DESTROY',
  GET_STATS:       'FlowOperation_GET_STATS',
  RESET_STATS:     'FlowOperation_RESET_STATS',
  GET_PROPERTIES:  'FlowOperation_GET_PROPERTIES',
  GET_DESTINATION: 'FlowOperation_GET_DESTINATION',
};

module.exports.FlowOperation = Enum.new(FlowOperation);


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var PrivateFlowEventName = {
  BIND_WAITING: 'PrivateFlowEventName_bindWaiting',
};

module.exports.PrivateFlowEventName = Enum.new(PrivateFlowEventName);


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;
var ref$1 = __webpack_require__(0);
var Iterator = ref$1.Iterator;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;

var makeIterator = Iterator.makeIterator;

/**
 * React to an event.
 * @callback StateContext.reactionCallback
 * @param {FsmEvent} event The event to react to.
 * @returns {StateContext.ReactionResult} One of the many possible
 *      reaction results that can be created by one of the following methods:
 *          - {@link StateContext#transitionTo}
 *          - {@link FsmState#internalTransition}
 *          - {@link FsmState#externalTransitionTo}
 *          - {@link FsmState#terminate}
 *          - {@link FsmState#eventUnhandled}
 */


/**
 * @classdesc
 * This abstract class can host one or more states.  Concrete examples would
 * be a state, which can host one or more inner states, or a state machine,
 * which would typically have multiple top-level states.  It also serves as a
 * context in which transitions can occur.
 * @memberof solace
 * @private
 */
var StateContext = (function (FsmObject) {
  function StateContext(spec) {
    FsmObject.call(this, spec);
    this.impl = this.impl || {};
    this.impl.logPadding = '';
  }

  if ( FsmObject ) StateContext.__proto__ = FsmObject;
  StateContext.prototype = Object.create( FsmObject && FsmObject.prototype );
  StateContext.prototype.constructor = StateContext;

  /**
   * Gets the state-machine that hosts this state context.
   * @returns {StateMachine} The FSM that hosts this context.
   */
  StateContext.prototype.getStateMachine = function getStateMachine () {
    return this.impl.ancestorList[0];
  };

  /**
   * Sets the initial reaction for the state context.
   * @param {StateContext.reactionCallback} func The reaction callback to be
   *      called after the state is entered as the deepest state of a
   *      transition, or for a state machine when it is started.
   * @returns {StateContext} The object this function was called on
   */
  StateContext.prototype.initial = function initial (func) {
    if (this.impl.initialReaction) {
      this.log(("Replacing " + (this) + " initialReaction " + (this.impl.initialReaction) + " with " + func));
    }
    this.impl.initialReaction = func.bind(this);
    return this;
  };

  /**
   * This is used for 'local' transitions.  However, we extend the formal
   * definition of local transitions here.  The formal definition is that
   * the dest state is within the src state, and the src state is not
   * exited.  We extend this definition to include states where the src
   * state is within dest. In this case, a local transition means that dest
   * will not be exited and entered and the transition will occur in the
   * context of dest before executing dest's initial transition.  Note that
   * this definition of local transition matches that of
   * {@link https://en.wikipedia.org/wiki/UML_state_machine#Local_versus_external_transitions|Wikipedia}.
   * But it does not match figure 14.34 or section 14.5.12 of the
   * {@link http://www.omg.org/spec/UML/2.5/PDF/|Formal UML Specification v2.5}.
   * Nevertheless, it does seem helpful to be able to express a transition
   * that does leave the destination state vs. a transition that does not.
   *
   * If neither the source nor the dest states are within the other, the
   * behaviour is the same as an external transition -- src is always exited
   * and dest is always entered.
   *
   * This is included in the StateContext instead of within the State itself
   * since this can be used by the initial reaction for a state machine.
   *
   * @param {State} state The state to transition to.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as
   *      part of the transition, if desired.
   * @returns {StateContext.ReactionResult} the result object used
   *      internally for further processing of the event.
   */
  StateContext.prototype.transitionTo = function transitionTo (state, action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: state,
      action: action,
    });
  };

  /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The reaction result for the termination.
   */
  StateContext.prototype.terminate = function terminate (action) {
    return new StateContext.ReactionResult({
      caller:    this,
      destState: this.getStateMachine().getFinalState(),
      action: action,
    });
  };

  /**
   * A callback to execute an action as part of a transition in the
   * appropriate context.
   *
   * To be used only by the FSM infrastructure or unit tests.
   *
   * @callback StateContext.actionCallback
   * @param {StateContext} context The context within which the action is
   *      executed.  When the active state changes, this is done after
   *      states are exited and before states are entered.  It is the
   *      deepest context that contains the last exited and first entered
   *      state as part of the transition.
   * @param {FsmEvent} event The event that triggered the transition.
   * @returns {Array.<StateContext>} The context's ancestor list.
   * @protected
   */
  StateContext.prototype.getAncestorList = function getAncestorList () {
    return this.impl.ancestorList;
  };

  /**
   * Perform a debug log with appropriate padding for the context.  The padding
   * helps to visualize the level within the hierarchical state machine.
   * @protected
   */
  StateContext.prototype.log = function log () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    /* #stripped LOG_TRACE(this.impl.logPadding, ...args) */

  };

  /**
   * Called when the initial transition for the context needs to be taken.
   * @param {FsmEvent} [event] The event causing this transition; undefined for the
   *      FSM's initial transition.
   * @returns {StateContext.ReactionResult} the result to be processed by
   *      the FSM infrastructure.
   * @protected
   */
  StateContext.prototype.onInitial = function onInitial (event) {
    var result;

    if (this.impl.initialReaction) {
      this.log(("Initial: for " + (this)));
      result = this.impl.initialReaction(event);
      if (result.external) {
        throw new Error(("Initial reaction for " + (this) + " returned external transitions"));
      }
      return result;
    }

    if (!(this instanceof (StateLib.State))) {
      throw new Error(("Missing initial reaction for " + (this)));
    }

    // If there is no initial reaction, then we just enter this state.
    // Technically this is a malformed FSM if there are inner states and
    // this state has no initial reaction.  We won't police this since it
    // isn't easily done with the data we are otherwise maintaining (we only
    // know about parent states, not children), and such a problem would be
    // easily caught by testing of the FSM.
    return this.transitionTo(this);
  };

  /**
   * After a reaction function has been called, this function processes the
   * returned {@link StateContext.ReactionResult}.
   * @param {StateContext.ReactionResult} result The result of a reaction.
   * @param {FsmEvent|undefined} e The event that triggered the reaction;
   *      undefined if this was due to the initial reaction.
   * @returns {State} The active state of the FSM after the ReactionResult was
   *      processed.
   * @protected
   */
  StateContext.prototype.processReactionResult = function processReactionResult (result, e) {
    var curContext = this;

    if (!result.destState) {
      return this;
    }

    var destStateIter = this.lowestCommonAncestor(result);

    // exit states until we get to the LCA
    while (curContext !== destStateIter.deref()) {
      curContext.onExit();
      curContext = curContext.getParent();
    }

    // perform the transition
    if (result.action) {
      result.action(curContext, e);
    }

    curContext.log(("Action: transition to " + (result.destState) + " in context " + curContext));

    // Start by incrementing the iterator so we don't enter the
    // context, which we are already in.  Then enter remaining states
    // in the list.
    for (destStateIter.incr(); !destStateIter.end(); destStateIter.incr()) {
      curContext = destStateIter.deref();
      curContext.onEntry();
    }

    // execute the initial transition in the destState.
    var destInitial = curContext.onInitial(e);
    if (destInitial.destState !== curContext) {
      return curContext.processReactionResult(destInitial, e);
    }
    return curContext;
  };

  /**
   * For a given reactionResult, this function returns an iterator to the
   * context in which to process a transition from 'self' to
   * 'reactionResult.destState'.  Advancing the iterator provides the states
   * that need to be entered after the transition is processed.
   * @param {ReactionResult} reactionResult An object created with one of the
   *                                        reaction result methods defined in
   *                                        either a state context or a state.
   * @returns {Iterator} The iterator where the first element is the
   * context in which to execute the transaction, and subsequent elements are
   * to be entered after executing the transaction.
   * @protected
   */
  StateContext.prototype.lowestCommonAncestor = function lowestCommonAncestor (reactionResult) {
    var ancestorList = this.impl.ancestorList;
    var destAncestorList = reactionResult.destState.getAncestorList();
    var i;

    // Make sure the states belong to the same state machine
    if (ancestorList[0] !== destAncestorList[0]) {
      throw new Error(("No common ancestor between (" + (this) + " in " + (ancestorList[0]) + ") and (" + (reactionResult.destState) + " in " + (destAncestorList[0]) + ")"));
    }

    // Optimize case where the two states are the same.  This would be the
    // case for internal and self-transitions.
    if (this === reactionResult.destState) {
      i = ancestorList.length;
      if (reactionResult.external) {
        // self-transition, must exit then re-enter state.  Therefore,
        // the context is our parent.
        --i;
      }
    } else {
      for (i = 1; i < ancestorList.length; ++i) {
        if (ancestorList[i] !== destAncestorList[i]) {
          break;
        }
      }

      // Check if one state is within the other state.
      if ((i === ancestorList.length) || (i === destAncestorList.length)) {
        // One state within the other. Check whether this is a local
        // or an external transition.
        if (reactionResult.external) {
          --i;    // Need to exit/re-enter the outermost state
        }
      }
    }

    // Here 'i' points to the first state to be entered after executing the
    // transition.  We make the iterator with 'i-1' so that the first element
    // is the context within which to execute the transition.
    return makeIterator(destAncestorList, i - 1);
  };

  StateContext.prototype.setLogPadding = function setLogPadding (padding) {
    this.impl.logPadding = padding;
  };

  return StateContext;
}(FsmObject));

/**
 * @classdesc
 * A ReactionResult is suitable as a return value from a reaction function
 * or an initial reaction.
 * @private
 */
StateContext.ReactionResult = (function () {
  function undefined(spec) {
    if (!spec || !spec.caller || !(spec.caller instanceof StateContext)) {
      throw new Error('spec.caller is required to be a StateContext');
    }

    if (!spec.caller.getStateMachine().isRunning()) {
      throw new Error('ReactionResult objects can only be created while processing events');
    }
    if (spec.destState) {
      if (!(spec.destState instanceof StateLib.State)) {
        throw new Error('destState must be a State object');
      }
      if (spec.action && (typeof (spec.action) !== 'function')) {
        throw new Error('action must be a function');
      }
      this.destState = spec.destState;
      this.action = spec.action;
      this.external = spec.external;
    }
  }

  return undefined;
}());

module.exports.StateContext = StateContext;


/***/ }),
/* 97 */
/***/ (function(module, exports) {

/* eslint-disable class-methods-use-this */ // declare prototype stubs

/**
 * A logging callback. It must accept any valid number of arguments of any type. It must not throw.
 *
 * @callback
 * @function
 * @name solace.LogImpl.loggingCallback
 * @param {...*} args The arguments to log. Typically this is a mixture of strings and
 *  objects to be inspected. A simple implementation might call .toString() on each
 *  argument.
 */

/**
 * @classdesc
 * A class that provides a binding to a log implementation. Applications that need to
 * control API logging must construct a LogImpl
 * instance, a log implementation that can be set in
 * {@link solace.SolclientFactoryProperties#logger}.
 * The binding will call the supplied log methods with the
 * parameters supplied to each.
 * @memberof solace
 */
var LogImpl = function LogImpl(trace, debug, info, warn, error, fatal) {
  Object.assign(this, {
    trace: trace,
    debug: debug,
    info: info,
    warn: warn,
    error: error,
    fatal: fatal,
  });
};

LogImpl.prototype.trace = function trace () {};
LogImpl.prototype.debug = function debug () {};
LogImpl.prototype.info = function info () {};
LogImpl.prototype.warn = function warn () {};
LogImpl.prototype.error = function error () {};
LogImpl.prototype.fatal = function fatal () {};

module.exports.LogImpl = LogImpl;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents a log level enumeration.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var LogLevel = {
  /**
   * Fatal. Rserved for unrecoverable errors.
   * @type {Number}
   */
  FATAL: 0,
  /**
   * Error. An internal error to the API or Solace Message Router.
   * @type {Number}
   */
  ERROR: 1,
  /**
   * Warn. An external error which may be caused by the application passing invalid
   * arguments or objects to the API. Often accompanied by an thrown exception.
   * @type {Number}
   */
  WARN:  2,
  /**
   * Info. An unexpected event or occurrence that does not affect the sane
   * operation of the SDK or application.
   * @type {Number}
   */
  INFO:  3,
  /**
   * Debug. The highest (least) level of debug logs. Debug logs provide an overview of
   * the API operation.
   * @type {Number}
   */
  DEBUG: 4,
  /**
   * Trace. The loweest (most verbose) level of debug logs.
   * @type {Number}
   */
  TRACE: 5,
};

module.exports.LogLevel = Enum.new(LogLevel);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(185);
var ConsumerFlows = ref.ConsumerFlows;
var ref$1 = __webpack_require__(54);
var ConsumerFSMEvent = ref$1.ConsumerFSMEvent;
var ref$2 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$2.ConsumerFSMEventNames;
var ref$3 = __webpack_require__(101);
var MessageConsumer = ref$3.MessageConsumer;
var ref$4 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$4.MessageConsumerAcknowledgeMode;
var ref$5 = __webpack_require__(28);
var MessageConsumerEventName = ref$5.MessageConsumerEventName;
var ref$6 = __webpack_require__(100);
var MessageConsumerProperties = ref$6.MessageConsumerProperties;

module.exports.ConsumerFlows = ConsumerFlows;
module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
module.exports.ConsumerFSMEventNames = ConsumerFSMEventNames;
module.exports.MessageConsumer = MessageConsumer;
module.exports.MessageConsumerAcknowledgeMode = MessageConsumerAcknowledgeMode;
module.exports.MessageConsumerEventName = MessageConsumerEventName;
module.exports.MessageConsumerProperties = MessageConsumerProperties;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var QueueLib = __webpack_require__(18);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$2.MessageConsumerAcknowledgeMode;
var ref$3 = __webpack_require__(5);
var Topic = ref$3.Topic;

var DEFAULTS = {
  queueDescriptor:           undefined,
  queueProperties:           undefined,
  connectTimeoutInMsecs:     10000,
  connectAttempts:           3,
  topicEndpointSubscription: undefined,
  // selector: undefined,
  acknowledgeMode:           MessageConsumerAcknowledgeMode.AUTO,
  acknowledgeTimeoutInMsecs: 1000,
  acknowledgeThreshold:      60,
  activeIndicationEnabled:   false,
  noLocal:                   false,
  windowSize:                255,
};

/**
 * @classdesc
 * Defines the properties for a {@link solace.MessageConsumer}.
 *
 * @memberof solace
 */
var MessageConsumerProperties = (function (APIProperties) {
  function MessageConsumerProperties(options) {
    APIProperties.call(this, DEFAULTS, options);
  }

  if ( APIProperties ) MessageConsumerProperties.__proto__ = APIProperties;
  MessageConsumerProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  MessageConsumerProperties.prototype.constructor = MessageConsumerProperties;

  var prototypeAccessors = { queueDescriptor: {},queueProperties: {},connectTimeoutInMsecs: {},connectAttempts: {},topicEndpointSubscription: {},acknowledgeMode: {},acknowledgeTimeoutInMsecs: {},acknowledgeThreshold: {},activeIndicationEnabled: {},noLocal: {},windowSize: {} };

  /**
   * Defines the queue from which to consume.
   *  * For durable queues and durable topic endpoints, this must be a
   *    {@link solace.QueueDescriptor}.
   *  * When an {@link solace.AbstractQueueDescriptor} is used, the name is generated when
   *    the {@link solace.MessageConsumer} is connected. The generated descriptor can be queried
   *    from the consumer after it has successfully connected by calling
   *    {@link solace.MessageConsumer#getQueueDescriptor}.
   * @type {solace.QueueDescriptor}
   */
  prototypeAccessors.queueDescriptor.get = function () {
    return Check.something(this._queueDescriptor)
      ? this._queueDescriptor
      : DEFAULTS.queueDescriptor;
  };
  prototypeAccessors.queueDescriptor.set = function (value) {
    if (value instanceof QueueLib.AbstractQueueDescriptor) {
      this._queueDescriptor = value;
    } else if (value) {
      this._queueDescriptor = value.name
        ? new QueueLib.QueueDescriptor(value)
        : new QueueLib.AbstractQueueDescriptor(value);
    } else {
      this._queueDescriptor = value;
    }
  };

  /**
   * Gets the properties of the remote queue.
   *  * For temporary queues and temporary topic endpoints, these properties define the queue that
   *    is created.
   *  * For durable queues, these must be unset on consumer creation. The values will be populated
   *    after the queue is connected and can be retrieved by calling
   *    {@link solace.MessageConsumer.#getQueueProperties}.
   * @type {solace.QueueProperties}
   */
  prototypeAccessors.queueProperties.get = function () {
    return Check.something(this._queueProperties)
      ? this._queueProperties
      : DEFAULTS.queueProperties;
  };
  prototypeAccessors.queueProperties.set = function (value) {
    if (value) {
      this._queueProperties = new QueueLib.QueueProperties(value);
    } else {
      this._queueProperties = value;
    }
  };

  // ------------ Properties controlling connection of the consumer ----------------
  /**
   * The bind timeout in milliseconds when creating a connection to the Solace Message Router.
   *  * The valid range is >= 50.
   * @type {Number}
   * @default 10000
   */
  prototypeAccessors.connectTimeoutInMsecs.get = function () {
    return Check.something(this._bindTimeoutInMsecs)
      ? this._bindTimeoutInMsecs
      : DEFAULTS.connectTimeoutInMsecs;
  };
  prototypeAccessors.connectTimeoutInMsecs.set = function (value) {
    this._bindTimeoutInMsecs = value;
  };

  /**
   * Gets and sets the maximum number of bind attempts when creating a connection to the
   * Solace Message Router.
   *  * The valid range is >= 1.
   * @type {Number}
   * @default 3
   */
  prototypeAccessors.connectAttempts.get = function () {
    return Check.something(this._connectAttempts)
      ? this._connectAttempts
      : DEFAULTS.connectAttempts;
  };
  prototypeAccessors.connectAttempts.set = function (val) {
    this._connectAttempts = val;
  };

  // ------------ Properties applied to the queue when connecting ----------------

  /**
   * This must be undefined if
   * {@link solace.MessageConsumerProperties#queueDescriptor#type} is not
   * {solace.QueueType.TOPIC_ENDPOINT}.
   *
   * If {@link solace.MessageConsumerProperties#queueDescriptor#durable} is
   * false, this may be left undefined to generate the topic endpoint's
   * destination. When generated, the destination can be obtained from
   * the {solace.MessageConsumer} after it is connected by calling
   * {@link solace.MessageConsumer#getDestination}.
   *
   * @type {solace.Destination}
   * @default undefined
   */
  prototypeAccessors.topicEndpointSubscription.get = function () {
    return this._topicEndpointSubscription;
  };
  prototypeAccessors.topicEndpointSubscription.set = function (val) {
    // Avoid instanceof check failing on Node 4?
    if (typeof val === 'string') {
      this._topicEndpointSubscription = Topic.createFromName(val);
    } else {
      this._topicEndpointSubscription = val;
    }
  };

  // ----------- Properties controlling an established connection to a queue --------------

  /**
   * The Application Acknowledgement mode for the Message Consumer.
   *
   * When the acknowledgement mode is {@link solace.MessageConsumerAcknowledgeMode.CLIENT},
   * a message is Application Acknowledged when the application calls
   * {@link solace.Message#acknowledge} on that message.
   *
   * When the acknowledge mode is {@link solace.MessageConsumerAcknowledgeMode.AUTO}, a message is
   * Application Acknowledged by the API after all
   * {@link solace.MessageConsumerEventName#event:MESSAGE}
   * listeners are called and none throw an exception. If a message handler throws, the message
   * can still be acknowledged by calling {@link solace.Message#acknowledge}, but this would not be
   * a recommended practice.
   *
   * When received messages are Application Acknowledged they are removed from the Guaranteed
   * Message storage on the Solace Message Router. Message Consumer Application Acknowledged,
   * <b>only</b> remove messages from the Solace Message Router.
   *
   * In particular, withholding Message Consumer Acknowledgemnts does not stop
   * message delivery. For Message Consumer flow control (aka transport acknowledgemeent) see
   * {@link solace.MessageConsumer.stop}/{@link solace.MessageConsumer.start}. Message Consumer
   * flow control may also be imlpemented by removing the
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
   *
   * Flow control and transport acknowledgements characteristics are defined by
   * {@link solace.MessageConsumerProperties.acknowledgeThreshold} and
   * {@link solace.MessageConsumerProperties.acknowledgeTimeoutInMsecs}
   *
   * @type {solace.MessageConsumerAcknowledgeMode}
   * @default solace.MessageConsumerAcknowledgeMode.AUTO
   */
  prototypeAccessors.acknowledgeMode.get = function () {
    return Check.something(this._acknowledgeMode)
      ? this._acknowledgeMode
      : DEFAULTS.acknowledgeMode;
  };
  prototypeAccessors.acknowledgeMode.set = function (value) {
    this._acknowledgeMode = value;
  };

  /**
   * The transport acknowledgement timeout for guaranteed messaging.
   * When the {@link solace.MessageConsumerProperties.acknowledgeThreshold} is not exceeded,
   * acknowledgements will be returned to the router at intervals not less than
   * this value.
   *   * The valid range is 20 <= acknowledgeTimeoutInMsecs <= 1500.
   * @type {Number}
   * @default 1000
   */
  prototypeAccessors.acknowledgeTimeoutInMsecs.get = function () {
    return Check.something(this._acknowledgeTimeoutInMsecs)
      ? this._acknowledgeTimeoutInMsecs
      : DEFAULTS.acknowledgeTimeoutInMsecs;
  };
  prototypeAccessors.acknowledgeTimeoutInMsecs.set = function (val) {
    this._acknowledgeTimeoutInMsecs = val;
  };

  /**
   * The threshold for sending an acknowledgement, as a percentage.
   * The API sends a transport acknowledgment every
   * N messages where N is calculated as this percentage of the transport
   * window size if the endpoint's max-delivered-unacked-msgs-per-flow
   * setting at bind time is greater than or equal to the transport
   * window size. Otherwise, N is calculated as this percentage of the
   * endpoint's max-delivered-unacked-msgs-per-flow setting at bind time.
   * * The valid range is 1 <= acknowledgeThreshold <= 75.
   * @type {Number}
   * @default 60
   */
  prototypeAccessors.acknowledgeThreshold.get = function () {
    return Check.something(this._acknowledgeThreshold)
      ? this._acknowledgeThreshold
      : DEFAULTS.acknowledgeThreshold;
  };
  prototypeAccessors.acknowledgeThreshold.set = function (value) {
    this._acknowledgeThreshold = value;
  };

  /**
   * @description When enabled, a Guaranteed Messaging Consumer requests Active and Inactive
   * events from the router and emits them to interested listeners.
   * @type {Boolean}
   * @default false
   * @see {solace.MessageConsumerEvent.ACTIVE}
   * @see {solace.MessageConsumerEvent.INACTIVE}
   */
  prototypeAccessors.activeIndicationEnabled.get = function () {
    return Check.something(this._activeIndicationEnabled)
      ? this._activeIndicationEnabled
      : DEFAULTS.activeIndicationEnabled;
  };
  prototypeAccessors.activeIndicationEnabled.set = function (newValue) {
    this._activeIndicationEnabled = newValue;
  };

  /**
   * When enabled, a Guaranteed Messaging Consumer does not receive messages published
   * in the same Session, even if the endpoint contains a subscription that matches the published
   * message.
   * @type {Boolean}
   * @default false
   */
  prototypeAccessors.noLocal.get = function () {
    return Check.something(this._noLocal)
      ? this._noLocal
      : DEFAULTS.noLocal;
  };
  prototypeAccessors.noLocal.set = function (newValue) {
    this._noLocal = newValue;
  };

  /**
   * The window size for Guaranteed Message delivery.  This is the maximum number of messages that
   * will be prefetched from the Solace Messaging Router and queued internally by the API while
   * waiting for the application to accept delivery of the messages.
   *   * The valid range is 1 <= windowSize <= 255.
   * @type {Number}
   * @default 255
   */
  prototypeAccessors.windowSize.get = function () {
    return Check.something(this._windowSize)
      ? this._windowSize :
      DEFAULTS.windowSize;
  };
  prototypeAccessors.windowSize.set = function (val) {
    this._windowSize = val;
  };

  Object.defineProperties( MessageConsumerProperties.prototype, prototypeAccessors );

  return MessageConsumerProperties;
}(APIProperties));

module.exports.MessageConsumerProperties = MessageConsumerProperties;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var util = __webpack_require__(6);
var ref = __webpack_require__(21);
var CapabilityType = ref.CapabilityType;
var ref$1 = __webpack_require__(186);
var ConsumerFSM = ref$1.ConsumerFSM;
var ref$2 = __webpack_require__(54);
var ConsumerFSMEvent = ref$2.ConsumerFSMEvent;
var ref$3 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$3.ConsumerFSMEventNames;
var ref$4 = __webpack_require__(36);
var Flow = ref$4.Flow;
var FlowOperation = ref$4.FlowOperation;
var ref$5 = __webpack_require__(28);
var MessageConsumerEventName = ref$5.MessageConsumerEventName;
var ref$6 = __webpack_require__(100);
var MessageConsumerProperties = ref$6.MessageConsumerProperties;
var ref$7 = __webpack_require__(188);
var MessageConsumerPropertiesValidator = ref$7.MessageConsumerPropertiesValidator;
var ref$8 = __webpack_require__(2);
var OperationError = ref$8.OperationError;
var ErrorSubcode = ref$8.ErrorSubcode;
var ref$9 = __webpack_require__(5);
var Queue = ref$9.Queue;
var Topic = ref$9.Topic;
var ref$10 = __webpack_require__(18);
var QueueAccessType = ref$10.QueueAccessType;
var QueuePermissions = ref$10.QueuePermissions;
var QueueDiscardBehavior = ref$10.QueueDiscardBehavior;


function formatEventName(eventName) {
  return ("MessageConsumerEventName." + (MessageConsumerEventName.describe(eventName)));
}

var localCounter = 0;
function getConsumerLocalName() {
  return ("ConsumerFSM " + (localCounter++));
}

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * A Message Consumer is created by calling {@link solace.Session#createMessageConsumer}.
 *
 * A MessageConsumer controls Guaranteed Message delivery to this client.
 *
 * Consumer characteristics and behavior are defined by {@link solace.MessageConsumerProperties}.
 * The properties can also be supplied as a simple key-value {Object}. The queue descriptor,
 * {@link solace.MessageConsumerProperties#queueDescriptor} must be specified to identify the
 * Guaranteed Message Queue or Guaranteed Message Topic Endpoint on the Solace Message Router.
 *
 * The MessageConsumer object is an EventEmitter, and will emit events to which the
 * application may choose to subscribe, such as the connection to the Solace Message Router
 * going up or down.
 *
 * If a registered listener for an emitted event throws an exception, this is caught and emitted as
 * an 'error'.
 *
 * @fires solace.MessageConsumerEventName#ACTIVE
 * @fires solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
 * @fires solace.MessageConsumerEventName#DISPOSED
 * @fires solace.MessageConsumerEventName#DOWN
 * @fires solace.MessageConsumerEventName#DOWN_ERROR
 * @fires solace.MessageConsumerEventName#GM_DISABLED
 * @fires solace.MessageConsumerEventName#INACTIVE
 * @fires solace.MessageConsumerEventName#MESSAGE
 * @fires solace.MessageConsumerEventName#UP
 *
 *
 *
 * @extends solace.Flow
 * @memberof solace
 */
var MessageConsumer = (function (Flow) {
  function MessageConsumer(ref) {
    var this$1 = this;
    if ( ref === void 0 ) ref = {};
    var properties = ref.properties;
    var sessionInterfaceFactory = ref.sessionInterfaceFactory;

    var applyProperties = new MessageConsumerProperties(properties);
    MessageConsumerPropertiesValidator.validate(applyProperties);
    Flow.call(this, applyProperties, sessionInterfaceFactory, {
      direct: MessageConsumerEventName.MESSAGE,
      emits:  MessageConsumerEventName.values,
      formatEventName: formatEventName,
    });

    var superFormatter = this.logger.formatter;
    this.logger.formatter = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return superFormatter.apply(void 0, [ '[message-consumer]' ].concat( args ));
    };

    this._active = undefined;
    this._fsm = this._makeFSM();

    this._on(MessageConsumerEventName.ACTIVE, function () { return this$1._onFlowActive(true); });
    this._on(MessageConsumerEventName.INACTIVE, function () { return this$1._onFlowActive(false); });
    this._on(MessageConsumerEventName.DOWN_ERROR, this._onFlowDisconnected.bind(this));
    this._on(MessageConsumerEventName.UP, this._onFlowUp.bind(this));
    this._fsm.start(); // Subscriber flows self-manage, so they start immediately
  }

  if ( Flow ) MessageConsumer.__proto__ = Flow;
  MessageConsumer.prototype = Object.create( Flow && Flow.prototype );
  MessageConsumer.prototype.constructor = MessageConsumer;

  var prototypeAccessors = { accessType: {},active: {},queueDiscardBehavior: {},respectsTTL: {},flowId: {},permissions: {} };

  MessageConsumer.prototype._makeFSM = function _makeFSM () {
    var properties = this._properties;
    var name = "" + (getConsumerLocalName());
    return new ConsumerFSM({
      name: name,
      consumer:         this,
      sessionInterface: this._sessionInterface,
      properties: properties,
    });
  };

  /**
   * Begins delivery of messages to this consumer. This method opens the protocol window
   * to the Solace Message Router so further messages can be received.
   *
   * A newly created consumer is in started state.
   *
   * If the consumer was already started, this method has no effect.
   *
   * A consumer is stopped by calling {@link solace.MessageConsumer.stop}
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disposed.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.start = function start () {
    this._operationCheck(FlowOperation.START);
    this._fsm.requestStartDispatchUser();
  };

  /**
   * Stops messages from being delivered to this consumer from the Solace Message Router.
   * Messages may continue to be prefetched by the API and queued internally
   * until {@link solace.MessageConsumer#start} is called.
   *
   * If the consumer was already stopped, this method has no effect.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.stop = function stop () {
    this._operationCheck(FlowOperation.STOP);
    this._fsm.requestStopDispatchUser();
  };

  /**
   * Connects the consumer immediately. The application should add event listeners (see
   * {@link solace.MessageConsumerEventName}). If there is no listener added for
   * {@link solace.MessageConsumerEventName#event:MESSAGE} then up to a window
   * {@link solace.MessageConsumerProperties.windowSize} of messages can be queued internally.
   * to the {@link solace.MessageConsumer} before calling this method.
   *
   * @throws {solace.OperationError}
   *  * if consumer is not supported by router for this client.
   *  subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   *
   */
  MessageConsumer.prototype.connect = function connect () {
    if ((this._sessionInterface.getCapability(CapabilityType.GUARANTEED_MESSAGE_CONSUME)
        !== null) &&
        (!this._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME))) {
      throw new OperationError('Consumer is not supported by router for this client',
              ErrorSubcode.INVALID_OPERATION, null);
    }
    Flow.prototype.connect.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_OPEN }));
  };

  /**
   * Initiates an orderly disconnection of the Message Consumer. The API will send any pending
   * client acknowledgements on the Message Consumer, then send an unbind request.
   * Any messages subsequently
   * received are discarded silently. When the unbind message is acknowledged, the application
   * receives a {@link solace.MessageConsumerEventName#event:DOWN} event if it has set a listener
   * for that event.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  MessageConsumer.prototype.disconnect = function disconnect () {
    Flow.prototype.disconnect.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_CLOSE }));
  };

  /**
   * Returns the destination that should be used to publish messages that this consumer
   * will receive.
   * * For topic endpoints, this is the topic to which the topic endpoint is subscribed.
   * * For queues, this is the associated queue destination.
   *
   * The destination returned can
   * be used to set the ReplyTo field in a message, or otherwise communicated
   * to partners that need to send messages to this Message Consumer. This is especially useful
   * for temporary endpoints (Queues and Topic Endpoints), as the destination
   * is unknown before the endpoint is created.
   *
   * This method will succeed after {@link MessageConsumerEventName#event:UP} for temporaries
   * with generated destinations.
   *
   * @throws {solace.OperationError}
   * * if the {@link solace.MessageConsumer} is disconnected and the destination is temporary.
   *
   * @returns {solace.Destination} The publishing destination that delivers to this consumer.
   */
  MessageConsumer.prototype.getDestination = function getDestination () {
    var destination = this._fsm.getDestination();
    if (destination instanceof Queue) {
      return new Queue(destination);
    }
    return new Topic(destination);
  };

  // Application has disconnected the session, we must continue to orderly shut down
  // unbinding Message Consumers,
  // but Message Consumers that are up merely treat this as a 'down' event and
  // transition to awaitingSessionUp
  MessageConsumer.prototype._disconnectSession = function _disconnectSession () {
    Flow.prototype._disconnectSession.call(this);
    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.SESSION_DISCONNECT }));
  };

  MessageConsumer.prototype._operationCheck = function _operationCheck (operation) {
    Flow.prototype._operationCheck.call(this, operation);
    switch (operation) {
      case FlowOperation.GET_DESTINATION:
        if (this._isDisconnected()) {
          throw new OperationError('Cannot get destination of a disconnected flow',
                                   ErrorSubcode.INVALID_OPERATION);
        }
        break;
      default:
    }
  };

  // ----

  /**
   * @param {any} messageId The message ID to ack
   * @internal
   */
  MessageConsumer.prototype.applicationAck = function applicationAck (messageId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE(`Adding application ack for ${messageId}`) */

    this._fsm.applicationAck(messageId);
  };

  MessageConsumer.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    return MessageConsumerEventName.DISPOSED;
  };

  /**
   * @param {solace.Message} message The data message to handle
   * @internal
   */
  MessageConsumer.prototype.handleDataMessage = function handleDataMessage (message) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE('Handling data message') */

    message.setMessageConsumer(this);
    this._fsm.acceptMessage(message);
  };

  /**
   * @override
   * @param {solace.AdProtocolMessage} message The control message to handle
   * @internal
   */
  MessageConsumer.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Handling uncorrelated control message') */

    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.UNBIND:
        this.processFSMEvent(new ConsumerFSMEvent({
          name: ConsumerFSMEventNames.FLOW_UNBOUND,
        }));
        break;
      case SMFAdProtocolMessageType.FLOWCHANGEUPDATE:
        this.processFSMEvent(new ConsumerFSMEvent({
          name: ConsumerFSMEventNames.FLOW_ACTIVE_IND,
        }, {
          active: message.getActiveFlow(),
        }));
        break;
      default:
        /* #stripped LOG_DEBUG('Dropping unhandled AD control message: ',
                  SMFAdProtocolMessageType.describe(msgType)) */

    }
  };

  /**
   * Creates and returns copy of the properties for this MessageConsumer.
   *
   * If the object was constructed using an {@link solace.AbstractQueueDescriptor},
   * and the queue descriptor was subsequently connected to an endpoint, the
   * `MessageConsumerProperties` returned will include a {@link solace.QueueDescriptor}
   * that contains the resolved name.
   *
   * A new copy of the properties object is returned each time this property is accessed.
   * The returned object cannot be polled for mutations such as the one described above.
   *
   * @returns {solace.MessageConsumerProperties} The properties associated with this object.
   */
  MessageConsumer.prototype.getProperties = function getProperties () {
    return Flow.prototype.getProperties.call(this);
  };

  /**
   * Resets the router state contained in the consumer, e.g. on VRN change
   *
   * @memberof MessageConsumer
   * @internal
   */
  MessageConsumer.prototype.onVRNChanged = function onVRNChanged () {
    this.processFSMEvent(new ConsumerFSMEvent({
      name: ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED,
    }));
  };

  /**
   * After the MessageConsumer has connected to an endpoint
   * ({@link solace.MessageConsumerEventName#UP}), accesstype represents
   *  the access type for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.accessType
   * @type {solace.QueueAccessType}
   */
  prototypeAccessors.accessType.get = function () {
    return this._accessType;
  };
  /**
   * @param {solace.QueueAccessType} value The value to set
   * @internal
   */
  prototypeAccessors.accessType.set = function (value) {
    this._accessType = value;
  };

  /**
   * Whether the consumer is active. If active indications for the consumer are not
   * enabled, this will return undefined.
   * @type {?Boolean}
   * @internal
   */
  prototypeAccessors.active.get = function () {
    return this._active;
  };
  /**
   * @param {Boolean} value The value to set
   * @internal
   */
  prototypeAccessors.active.set = function (value) {
    if (value !== this._active) {
      this._emit(value ? MessageConsumerEventName.ACTIVE : MessageConsumerEventName.INACTIVE);
    }
    this._active = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, queueDiscardBehavior represents
   * the discard behavior flags for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.queueDiscardBehaviour
   * @type {solace.QueueDiscardBehavior}
   */
  prototypeAccessors.queueDiscardBehavior.get = function () {
    return this._queueDiscardBehavior;
  };
  /**
   * @param {solace.QueueDiscardBehavior} value The value to set
   * @internal
   */
  prototypeAccessors.queueDiscardBehavior.set = function (value) {
    this._queueDiscardBehavior = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}
   * respectsTTL is `true` when the endpoint respects Time To Live on messages
   * and 'false' otherwise.
   * @name solace.MessageConsumer.respectsTTL
   * @type {Boolean}
   */
  prototypeAccessors.respectsTTL.get = function () {
    return this._respectsTTL;
  };
  /**
   * @param {Boolean} value The value to set
   * @internal
   */
  prototypeAccessors.respectsTTL.set = function (value) {
    this._respectsTTL = value;
  };

  /**
   * Gets the flow ID for this consumer. This number will change between reconnects
   * and is purely informational.
   * @type {Long}
   * @internal
   */
  prototypeAccessors.flowId.get = function () {
    return this._flowId;
  };
  /**
   * @param {Long} value The value to set
   * @internal
   */
  prototypeAccessors.flowId.set = function (value) {
    this._flowId = value;
  };

  /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, this property represents
   * permissions granted by the router to this user on this Message Consumer
   * @name solace.MessageConsumer.permissions
   * @type {solace.QueuePermissions}
   */
  prototypeAccessors.permissions.get = function () {
    return this._permissions || 0;
  };
  /**
   * @param {Number} value The value to set
   * @internal
   */
  prototypeAccessors.permissions.set = function (value) {
    this._permissions = value;
  };

  MessageConsumer.prototype._onFlowActive = function _onFlowActive (isActive) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG(`Flow (flowId = ${this._flowId}) became ${isActive ? 'active' : 'inactive'}`) */

    this._active = isActive;
  };

  MessageConsumer.prototype._onFlowDisconnected = function _onFlowDisconnected () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG(`${this} disconnected`) */

  };

  MessageConsumer.prototype._disposeFSM = function _disposeFSM () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Disposing FSM') */

    this.processFSMEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.DISPOSE }));
  };

  MessageConsumer.prototype._onFlowUp = function _onFlowUp () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG(`Flow is up: flowId = ${this._flowId}`) */

  };

  MessageConsumer.prototype[util.inspect.custom] = function () {
    return Object.assign(Flow.prototype[util.inspect.custom].call(this), {
      'destination':          this._destination,
      'accessType':           QueueAccessType.describe(this.accessType),
      'permissions':          QueuePermissions.describe(this.permissions),
      'respectsTTL':          this.respectsTTL,
      'active':               this.wantFlowChangeNotify ? this.active : '(indications disabled)',
      'wantFlowChangeNotify': this.wantFlowChangeNotify,
      'queueDiscardBehavior': QueueDiscardBehavior.describe(this.queueDiscardBehavior),
      'maxWindowSize':        this._fsm.maxWindowSize,
    });
  };

  MessageConsumer.prototype.toString = function toString () {
    return util.inspect(this);
  };

  MessageConsumer.prototype._isDisconnected = function _isDisconnected () {
    return this._fsm.isDisconnected();
  };

  Object.defineProperties( MessageConsumer.prototype, prototypeAccessors );

  return MessageConsumer;
}(Flow));

module.exports.MessageConsumer = MessageConsumer;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$2.MessagePublisherAcknowledgeMode;
var ref$3 = __webpack_require__(23);
var TransportCapabilities = ref$3.TransportCapabilities;

function defaultEnablePublisher() {
  var ProfileBinding = SolclientFactoryLib.ProfileBinding;
  var binding = ProfileBinding.value;
  var globallyEnabled = binding.guaranteedMessagingEnabled;
  var webSocketAvailable = TransportCapabilities.web.webSocket();
  return globallyEnabled && webSocketAvailable;
}

function getDefaults() {
  return {
    enabled:                   defaultEnablePublisher(),
    windowSize:                50,
    acknowledgeTimeoutInMsecs: 2000,
    acknowledgeMode:           MessagePublisherAcknowledgeMode.PER_MESSAGE,
    connectRetryCount:         3,
    connectTimeoutInMsecs:     5000,
  };
}

/**
 * @classdesc
 * Properties that define the configuration for a guaranteed message publisher.
 *
 * @memberof solace
 */
var MessagePublisherProperties = (function (APIProperties) {
  function MessagePublisherProperties(options) {
    APIProperties.call(this, getDefaults(), options || {});
  }

  if ( APIProperties ) MessagePublisherProperties.__proto__ = APIProperties;
  MessagePublisherProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  MessagePublisherProperties.prototype.constructor = MessagePublisherProperties;

  var prototypeAccessors = { enabled: {},windowSize: {},acknowledgeTimeoutInMsecs: {},acknowledgeMode: {},connectRetryCount: {},connectTimeoutInMsecs: {} };
  /**
   * @name solace.MessagePublisherProperties#enabled
   * @type {Boolean}
   * @description When enabled, a Guaranteed Messaging Publisher
   * is automatically created when a session is connected.
   *
   * The default value is the same as the value provided to
   * {@link solace.SolclientFactory.init},
   * in the profile, {@link solace.SolclientFactoryProperties#profile},
   * in the field {@link solace.FactoryProfile#guaranteedMessagingEnabled}.
   */
  prototypeAccessors.enabled.get = function () {
    return this._enabled;
  };
  prototypeAccessors.enabled.set = function (newValue) {
    this._enabled = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#windowSize
   * @default 50
   * @type {Number}
   * @description  Maximum number of messages that can be published
   * without acknowledgment.
   *  * The valid range is 1 <= value <= 255
   */
  prototypeAccessors.windowSize.get = function () {
    return Check.defined(this._windowSize)
      ? this._windowSize
      : getDefaults().windowSize;
  };
  prototypeAccessors.windowSize.set = function (newValue) {
    this._windowSize = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#acknowledgeTimeoutInMsecs
   * @type {Number}
   * @default 2000
   * @description  The time to wait for an acknowledgement,
   * in milliseconds, before retransmitting unacknowledged
   * messages.
   *  * The valid range is 20 <= value <= 60000.
   */
  prototypeAccessors.acknowledgeTimeoutInMsecs.get = function () {
    return Check.defined(this._acknowledgeTimeoutInMsecs)
      ? this._acknowledgeTimeoutInMsecs
      : getDefaults().acknowledgeTimeoutInMsecs;
  };
  prototypeAccessors.acknowledgeTimeoutInMsecs.set = function (newValue) {
    this._acknowledgeTimeoutInMsecs = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#acknowledgeMode
   * @type {solace.MessagePublisherAcknowledgeMode}
   * @default {@link solace.MessagePublisherAcknowledgeMode.PER_MESSAGE}
   * @description  The message-router sends windowed acknowledgements
   * which the API converts to per-message acknowledgement by default. If
   * acknowledgeMode is Windowed, then the API will simply pass through
   * the message-router acknowledgements.
   */
  prototypeAccessors.acknowledgeMode.get = function () {
    return this._acknowledgeMode || MessagePublisherAcknowledgeMode.PER_MESSAGE;
  };
  prototypeAccessors.acknowledgeMode.set = function (newValue) {
    this._acknowledgeMode = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#connectRetryCount
   * @type {Number}
   * @default 3
   * @description The number of times to retry a bind (aka open-flow) request
   * before deciding the the Guaranteed Message Publisher cannot be started.
   *  * The valid range 0 <= value.
   * @private
   */
  prototypeAccessors.connectRetryCount.get = function () {
    return Check.defined(this._connectRetryCount)
      ? this._connectRetryCount
      : getDefaults().connectRetryCount;
  };
  prototypeAccessors.connectRetryCount.set = function (newValue) {
    this._connectRetryCount = newValue;
  };
  /**
   * @name solace.MessagePublisherProperties#connectTimeoutInMsecs
   * @type {Number}
   * @default 5000
   * @description  The time to wait for an bind response,
   * in milliseconds, before retransmitting the bind request.
   *  * The valid range is 50 <= value</li>
   * @private
   */
  prototypeAccessors.connectTimeoutInMsecs.get = function () {
    return Check.defined(this._connectTimeoutInMsecs)
      ? this._connectTimeoutInMsecs
      : getDefaults().connectTimeoutInMsecs;
  };
  prototypeAccessors.connectTimeoutInMsecs.set = function (newValue) {
    this._connectTimeoutInMsecs = newValue;
  };

  MessagePublisherProperties.prototype[util.inspect.custom] = function () {
    return {
      enabled:                   this.enabled,
      windowSize:                this.windowSize,
      acknowledgeTimeoutInMsecs: this.acknowledgeTimeoutInMsecs,
      acknowledgeMode:           MessagePublisherAcknowledgeMode.describe(this.acknowledgeMode),
      connectRetryCount:         this.connectRetryCount,
      connectTimeoutInMsecs:     this.connectTimeoutInMsecs,
    };
  };

  Object.defineProperties( MessagePublisherProperties.prototype, prototypeAccessors );

  return MessagePublisherProperties;
}(APIProperties));

module.exports.MessagePublisherProperties = MessagePublisherProperties;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var MessageDumpUtilLib = __webpack_require__(60);
var ref = __webpack_require__(5);
var Destination = ref.Destination;
var ref$1 = __webpack_require__(1);
var LOG_ERROR = ref$1.LOG_ERROR;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;
var ref$3 = __webpack_require__(58);
var MessageCacheStatus = ref$3.MessageCacheStatus;
var ref$4 = __webpack_require__(59);
var MessageDeliveryModeType = ref$4.MessageDeliveryModeType;
var ref$5 = __webpack_require__(40);
var MessageDumpFlag = ref$5.MessageDumpFlag;
var ref$6 = __webpack_require__(61);
var MessageUserCosType = ref$6.MessageUserCosType;
var ref$7 = __webpack_require__(10);
var SDTMapContainer = ref$7.SDTMapContainer;
var SDTFieldType = ref$7.SDTFieldType;
var ref$8 = __webpack_require__(4);
var StringUtils = ref$8.StringUtils;


var MessageDumpStandardProvider = {

  fpDestination: function fpDestination(message/* , flags*/) {
    var dest = message.getDestination();
    if (dest !== null && dest instanceof Destination) {
      return ['Destination', true, dest.toString(), null];
    }
    return ['Destination', false, '', null];
  },

  fpSenderId: function fpSenderId(message/* , flags*/) {
    return ['SenderId', (message.getSenderId() !== undefined && message.getSenderId() !== null), message.getSenderId(), null];
  },

  fpAppmsgType: function fpAppmsgType(message/* , flags*/) {
    return ['AppMessageType', (message.getApplicationMessageType() !== undefined && message.getApplicationMessageType() !== null),
      message.getApplicationMessageType(), null];
  },

  fpAppMsgId: function fpAppMsgId(message/* , flags*/) {
    return ['AppMessageID', (message.getApplicationMessageId() !== undefined && message.getApplicationMessageId() !== null),
      message.getApplicationMessageId(), null];
  },

  fpSequenceNumber: function fpSequenceNumber(message/* , flags*/) {
    var sequenceNum = message.getSequenceNumber();
    if (typeof sequenceNum === 'number') {
      return ['SequenceNumber', true, sequenceNum, null];
    }
    return ['SequenceNumber', false, '', null];
  },

  fpTopicSequenceNumber: function fpTopicSequenceNumber(message/*, flags */) {
    var topicSeqNo = message.getTopicSequenceNumber();
    if (Long.isLong(topicSeqNo)) {
      return ['TopicSequenceNumber', true, topicSeqNo.toString(), null];
    }
    return ['TopicequenceNumber', false, '', null];
  },

  fpCorrelationId: function fpCorrelationId(message/* , flags*/) {
    return ['CorrelationId', (message.getCorrelationId() !== undefined && message.getCorrelationId() !== null),
      message.getCorrelationId(), null];
  },

  fpHttpContentType: function fpHttpContentType(/*message*/ /*, flags*/) {
    // TODO:
    // HTTP Content Type is not supported
    // const strValue = message.getHTTPContentType();
    // return ['HTTP Content Type', (strValue !== undefined && strValue !== null), strValue, null];
    return ['HTTP Content Type', false, undefined, null];
  },

  fpHttpContentEncoding: function fpHttpContentEncoding(/*message*/ /*, flags*/) {
    // TODO:
    // HTTP Content Encoding is not supported
    // const strValue = message.getHTTPContentType();
    // return ['HTTP Content Encoding', (strValue !== undefined && strValue !== null), strValue,
    //         null];
    return ['HTTP Content Encoding', false, undefined, null];
  },

  fpSendTimestamp: function fpSendTimestamp(message/* , flags*/) {
    var timestamp = message.getSenderTimestamp();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['SendTimestamp', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['SendTimestamp', false, '', null];
  },

  fpRcvTimestamp: function fpRcvTimestamp(message/* , flags*/) {
    var timestamp = message.getReceiverTimestamp();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['RcvTimestamp', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['RcvTimestamp', false, '', null];
  },

  fpClassOfService: function fpClassOfService(message/* , flags*/) {
    var cos = message.getUserCos();
    if (typeof cos === 'number') {
      return ['Class Of Service', true, MessageUserCosType.nameOf(message.getUserCos()), null];
    }
    return ['Class Of Service', false, '', null];
  },

//  fpPriority(message/* , flags*/) {
//    const prio = message.getPriority() !== undefined ? message.getPriority() : 'undefined';
//    return ['Message Priority', true, prio, null];
//  },

  fpDeliveryMode: function fpDeliveryMode(message/* , flags*/) {
    var mode = message.getDeliveryMode();
    if (typeof mode === 'number') {
      return ['DeliveryMode', true, MessageDeliveryModeType.nameOf(message.getDeliveryMode()), null];
    }
    return ['DeliveryMode', false, '', null];
  },

  fpGuaranteedMsgId: function fpGuaranteedMsgId(message/*, flags*/) {
    var msgId = message.getGuaranteedMessageId();
    if (Long.isLong(msgId)) {
      return ['Message Id', true, msgId.toString(10), null];
    }
    return ['Message Id', false, '', null];
  },

  fpTimeToLive: function fpTimeToLive(message/* , flags */) {
    var timeToLive = message.getTimeToLive();
    if (typeof timeToLive === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      var d = new Date();
      return ['TimeToLive', true,
        (timeToLive + " (" + (mdu.formatDate(d.getTime() + timeToLive)) + ")"), null];
    }
    return ['TimeToLive', false, '', null];
  },

  fpExpiration: function fpExpiration(message/*, flags*/) {
    var timestamp = message.getGMExpiration();
    if (typeof timestamp === 'number') {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      return ['Expiration', true,
        (timestamp + " (" + (mdu.formatDate(timestamp)) + ")"), null];
    }
    return ['Expiration', false, '', null];
  },

  fpMessageDMQEligible: function fpMessageDMQEligible(message/* , flags*/) {
    return ['DMQ Eligible', message.isDMQEligible(), '', null];
  },

  fpMessageRedelivered: function fpMessageRedelivered(message/* , flags*/) {
    return ['Message Re-delivered', message.isRedelivered(), '', null];
  },

  fpDiscardIndication: function fpDiscardIndication(message/* , flags*/) {
    return ['Discard Indication', message.isDiscardIndication(), '', null];
  },

  fpAckImmediately: function fpAckImmediately(message/* , flags*/) {
    return ['ACK Immediately', message.isAcknowledgeImmediately(), '', null];
  },

  fpElidingEligible: function fpElidingEligible(message/* , flags*/) {
    return ['Eliding Eligible', message.isElidingEligible(), '', null];
  },

  fpReplyMessage: function fpReplyMessage(message/* , flags*/) {
    return ['Reply Message', message.isReplyMessage(), '', null];
  },

  fpReplyTo: function fpReplyTo(message/* , flags*/) {
    var replyTo = message.getReplyTo();
    if (replyTo !== null && replyTo instanceof Destination) {
      return ['ReplyTo', true, replyTo.toString(), null];
    }
    return ['ReplyTo', false, '', null];
  },

  fpDeliverToOne: function fpDeliverToOne(message/* , flags*/) {
    return ['Deliver To One', message.isDeliverToOne(), '', null];
  },

  fpCacheMessage: function fpCacheMessage(message/* , flags*/) {
    return ['Message from cache', message.getCacheStatus() !== MessageCacheStatus.LIVE, '', null];
  },

  fpCacheRequestId: function fpCacheRequestId(message/*, flags */) {
    var cacheRequestId = message.getCacheRequestId();
    if (Long.isLong(cacheRequestId)) {
      return ['Cache Request Id', true, cacheRequestId.toString, null];
    }
    return ['Cache Request Id', false, '', null];
  },

  fpUserPropertyMap: function fpUserPropertyMap(message, flags) {
    var propMap = message.getUserPropertyMap();
    if (propMap !== null && propMap instanceof SDTMapContainer) {
      var value = (propMap.getKeys().length) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          var mdu = MessageDumpUtilLib.MessageDumpUtil;
          detailValue = mdu.printMap(propMap, 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['User Property Map', true, value, detailValue];
    }
    return ['User Property Map', false, '', null];
  },

  fpCorrelationTag: function fpCorrelationTag(message/*, flags*/) {
    var strValue = message.getCorrelationKey();
    return ['Correlation Tag Pointer', (strValue !== undefined && strValue !== null),
      strValue, null];
  },

  fpUserData: function fpUserData(message/* , flags*/) {
    if (StringUtils.notEmpty(message.getUserData())) {
      return ['User Data', true, ("len=" + (message.getUserData().length)),
        DebugLib.Debug.formatDumpBytes(message.getUserData(), true, 2)];
    }
    return ['User Data', false, '', null];
  },

  fpSdtStream: function fpSdtStream(message, flags) {
    var sdtFieldValue = message.getSdtContainer();
    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.STREAM) {
      var mdu = MessageDumpUtilLib.MessageDumpUtil;
      var value = (mdu.countItems(sdtFieldValue.getValue())) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          detailValue = mdu.printStream(sdtFieldValue.getValue(), 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['SDT Stream', true, value, detailValue];
    }
    return ['SDT Stream', false, '', null];
  },

  fpSdtMap: function fpSdtMap(message, flags) {
    var sdtFieldValue = message.getSdtContainer();
    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.MAP) {
      var value = (sdtFieldValue.getValue().getKeys().length) + " entries";
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        try {
          var mdu = MessageDumpUtilLib.MessageDumpUtil;
          detailValue = mdu.printMap(sdtFieldValue.getValue(), 2);
        } catch (e) {
          LOG_ERROR(e.message, e.stack);
          detailValue = 'Error';
        }
      }
      return ['SDT Map', true, value, detailValue];
    }
    return ['SDT Map', false, '', null];
  },

  fpBinaryAttachment: function fpBinaryAttachment(message, flags) {
    var att = message.getBinaryAttachment();
    if (StringUtils.notEmpty(att)) {
      var value = "len=" + (att.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(att, true, 2);
      }
      return ['Binary Attachment', true, value, detailValue];
    }
    return ['Binary Attachment', false, '', null];
  },

  fpXmlContent: function fpXmlContent(message, flags) {
    var xml = message.getXmlContent();
    if (StringUtils.notEmpty(xml)) {
      var value = "len=" + (xml.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(xml, true, 2);
      }
      return ['XML', true, value, detailValue];
    }
    return ['XML', false, '', null];
  },

  fpXmlMetadata: function fpXmlMetadata(message, flags) {
    var xmlMetadata = message.getXmlMetadata();
    if (StringUtils.notEmpty(xmlMetadata)) {
      var value = "len=" + (xmlMetadata.length);
      var detailValue = null;
      if (flags === MessageDumpFlag.MSGDUMP_FULL) {
        detailValue = DebugLib.Debug.formatDumpBytes(xmlMetadata, true, 2);
      }
      return ['XML Metadata', true, value, detailValue];
    }
    return ['XML Metadata', false, '', null];
  },
};

module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of message payload types
 * (see {@link solace.Message#getBinaryAttachment})
 *
 * A message may contain unstructured byte data, or a structured container.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MessageType = {
  /**
   * Binary message (unstructured bytes stored in the binary attachment message part).
   * @type {Number}
   */
  BINARY: 0,
  /**
   * Structured map message.
   * @type {Number}
   */
  MAP:    1,
  /**
   * Structured stream message.
   * @type {Number}
   */
  STREAM: 2,
  /**
   * Structured text message.
   * @type {Number}
   */
  TEXT:   3,
};

module.exports.MessageType = Enum.new(MessageType);


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(5);
var DestinationType = ref$1.DestinationType;
var ref$2 = __webpack_require__(2);
var OperationError = ref$2.OperationError;
var ErrorSubcode = ref$2.ErrorSubcode;
var ref$3 = __webpack_require__(65);
var QueueType = ref$3.QueueType;

var DEFAULTS = {
  durable: true,
  type:    undefined,
};

var TYPE_DESCRIPTION = {};
TYPE_DESCRIPTION[QueueType.QUEUE] = 'queue';
TYPE_DESCRIPTION[QueueType.TOPIC_ENDPOINT] = 'topic endpoint';

var DESINATION_TYPE_TO_DESCRIPTOR_TYPE = {};
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.TOPIC] = null;
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.QUEUE] = QueueType.QUEUE;
DESINATION_TYPE_TO_DESCRIPTOR_TYPE[DestinationType.TEMPORARY_QUEUE] = QueueType.QUEUE;

function maybeAdaptFromDestination(spec) {
  if (spec && spec.name && spec.type && DestinationType.values.includes(spec.type)) {
    var targetType = DESINATION_TYPE_TO_DESCRIPTOR_TYPE[spec.type];
    if (!targetType) {
      throw new OperationError(("Cannot create a descriptor from a " + (DestinationType.describe(spec.type)) + " destination"),
                               ErrorSubcode.PARAMETER_CONFLICT);
    }
    return {
      name:    spec.name,
      type:    QueueType.QUEUE,
      durable: spec.type !== DestinationType.TEMPORARY_QUEUE,
    };
  }
  return spec;
}


/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * <p>
 * This is a base class for {@link solace.QueueDescriptor}. API users should access the
 * methods described here through a {@link solace.QueueDescriptor}.
 * @memberof solace
 * @hideconstructor
 */
var AbstractQueueDescriptor = (function (APIProperties) {
  function AbstractQueueDescriptor(queueSpec) { // eslint-disable-line no-useless-constructor
    APIProperties.call(this, DEFAULTS, maybeAdaptFromDestination(queueSpec));
  }

  if ( APIProperties ) AbstractQueueDescriptor.__proto__ = APIProperties;
  AbstractQueueDescriptor.prototype = Object.create( APIProperties && APIProperties.prototype );
  AbstractQueueDescriptor.prototype.constructor = AbstractQueueDescriptor;

  var prototypeAccessors = { type: {},durable: {} };

  /**
   * Gets the queue type to which this descriptor refers.
   * @returns {solace.QueueType} The queue type that this object describes
   */
  AbstractQueueDescriptor.prototype.getType = function getType () {
    return this._type;
  };

  /**
   * @type {solace.QueueType}
   * @description The Queue Type.
   */
  prototypeAccessors.type.get = function () {
    return this.getType();
  };
  prototypeAccessors.type.set = function (value) {
    this._type = value;
  };

  /**
   * Gets whether this descriptor refers to a durable queue.
   *
   * @returns {Boolean} `true` if this describes a durable queue
   */
  AbstractQueueDescriptor.prototype.isDurable = function isDurable () { // eslint-disable-line class-methods-use-this
    return this._durable;
  };
  /**
   * @type {Boolean}
   * @description True if this descriptor refers to a Durabble Queue.
   */
  prototypeAccessors.durable.get = function () {
    return this.isDurable();
  };
  prototypeAccessors.durable.set = function (value) {
    this._durable = value;
  };

  AbstractQueueDescriptor.prototype[util.inspect.custom] = function () {
    return {
      'type':    this.type,
      'durable': this.durable,
    };
  };

  /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
  AbstractQueueDescriptor.prototype.toString = function toString () {
    return (!this.isDurable() ? 'non' : '') + "-durable " +
           "" + (TYPE_DESCRIPTION[this.getType()]);
  };

  Object.defineProperties( AbstractQueueDescriptor.prototype, prototypeAccessors );

  return AbstractQueueDescriptor;
}(APIProperties));

module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(105);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var ref$1 = __webpack_require__(5);
var Destination = ref$1.Destination;

var DEFAULTS = {
  name:    undefined,
  durable: true,
};

/**
 * This class identifies a queue or topic endpoint on the message router.
 *
 * Operations that make use of queue descriptors include
 *  * {@link solace.Session#createMessageConsumer}
 *  * {@link solace.Session#dteUnsubscribe}
 *
 * @classdesc QueueDescriptor
 * @extends {AbstractQueueDescriptor}
 * @memberof solace
 */
var QueueDescriptor = (function (AbstractQueueDescriptor) {
  function QueueDescriptor(queueSpec) {
    AbstractQueueDescriptor.call(this, queueSpec instanceof Destination
            ? { name: queueSpec.name, type: queueSpec.type } // synthesize durable later
            : Object.assign({ }, DEFAULTS, queueSpec));
  }

  if ( AbstractQueueDescriptor ) QueueDescriptor.__proto__ = AbstractQueueDescriptor;
  QueueDescriptor.prototype = Object.create( AbstractQueueDescriptor && AbstractQueueDescriptor.prototype );
  QueueDescriptor.prototype.constructor = QueueDescriptor;

  var prototypeAccessors = { name: {} };

  /**
   * Gets/sets the remote name to which this descriptor refers.
   * @returns {String} The name of the queue.
   */
  QueueDescriptor.prototype.getName = function getName () {
    return this._name;
  };
  prototypeAccessors.name.get = function () {
    return this.getName();
  };
  prototypeAccessors.name.set = function (value) {
    this._name = value;
  };

  QueueDescriptor.prototype[util.inspect.custom] = function () {
    return {
      'name':    this.name,
      'type':    this.type,
      'durable': this.durable,
    };
  };

  /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
  QueueDescriptor.prototype.toString = function toString () {
    return ((AbstractQueueDescriptor.prototype.toString.call(this)) + " '" + (this.getName()) + "'");
  };

  /**
   * @static
   * @param {any} spec The descriptor spec
   * @returns {QueueDescriptor|AbstractQueueDescriptor} A new descriptor for the spec
   * @private
   */
  QueueDescriptor.createFromSpec = function createFromSpec (spec) {
    if (spec.name) { return new QueueDescriptor(spec); }
    return AbstractQueueDescriptor(spec);
  };

  Object.defineProperties( QueueDescriptor.prototype, prototypeAccessors );

  return QueueDescriptor;
}(AbstractQueueDescriptor));

module.exports.QueueDescriptor = QueueDescriptor;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(30);
var SDTDataTypes = ref$1.SDTDataTypes;

var EncodeHeader = {
  encodeHeader: function encodeHeader(tag, valueLen) {
    // Tag in first 6 bits, then (lenbytes-1) in 2 bits
    var byte0 = (tag << 2) & 0xFF;
    var strSdtLen = null;

    if (tag === SDTDataTypes.Map || tag === SDTDataTypes.Stream) {
        // force 4 bytes
      strSdtLen = Convert.int32ToStr(valueLen + 5);
      byte0 |= 3; // 4 length bytes
    } else if (valueLen + 2 <= 255) {
      strSdtLen = Convert.int8ToStr(valueLen + 2);
      byte0 |= 0; // 1 length byte
    } else if (valueLen + 3 <= 65535) {
      strSdtLen = Convert.int16ToStr(valueLen + 3);
      byte0 |= 1; // 2 length bytes
    } else {
      strSdtLen = Convert.int32ToStr(valueLen + 5);
      byte0 |= 3; // 4 length bytes
    }
    var ret = Convert.int8ToStr(byte0) + strSdtLen;
    return ret;
  },
};

module.exports.EncodeHeader = EncodeHeader;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Convert = ref.Convert;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;
var ref$3 = __webpack_require__(109);
var SDTUnsupportedValueError = ref$3.SDTUnsupportedValueError;
var ref$4 = __webpack_require__(110);
var SDTValueErrorSubcode = ref$4.SDTValueErrorSubcode;

var createField = SDTField.create;

var C_2_48 = Math.pow(2, 48);

function getBinaryString(strBytes) {
  var bits = [];
  for (var i = strBytes.length - 1; i >= 0; --i) {
    var byteI = strBytes.charCodeAt(i) & 0xFF;
    for (var j = 0; j < 8; ++j) {
      bits.push(byteI % 2 ? 1 : 0);
      byteI >>= 1;
    }
  }
  bits.reverse();
  return bits.join('');
}

var ParseInteger = {

  // Util: decode 1, 2, 3, 4 byte UINT.
  autoDecodeVarLengthNumber: function autoDecodeVarLengthNumber(dataStr) {
    switch (dataStr.length) {
      case 1:
        return Convert.strToInt8(dataStr);
      case 2:
        return Convert.strToInt16(dataStr);
      case 3:
        return Convert.strToInt24(dataStr);
      case 4:
        return Convert.strToInt32(dataStr);
      default:
        return false;
    }
  },

    // Parse an integer SDT Field: [U]INT 8, 16, 32, 64.
  parseIntegerField: function parseIntegerField(isSigned, datastr) {
    var sign = false;
    var val = 0;
    var unsafeBits;

    switch (datastr.length) {
      case 1:
        val = Convert.strToInt8(datastr);
        if (!isSigned) {
          return createField(SDTFieldType.UINT8, val);
        }
        sign = (val & 0x80) !== 0;
        if (sign) {
          val -= 256;
        }
        return createField(SDTFieldType.INT8, val);

      case 2:
        val = Convert.strToInt16(datastr);
        if (!isSigned) {
          return createField(SDTFieldType.UINT16, val);
        }
        sign = (val & 0x8000) !== 0;
        if (sign) {
          val -= 65536;
        }
        return createField(SDTFieldType.INT16, val);

      case 4:
        val = Convert.strToInt32(datastr);
        if (isSigned) {
          // raw read using strToInt32 (it reads 2's complement)
          return createField(SDTFieldType.INT32, val);
        }

        // conversion error with strToInt32! (we can't read back a 32bit uint)
        // Solution is to convert byte positions ourselves without using bitwise shifts
        // Because the UINT is guaranteed to be < 2^53 this should work.
        val = (datastr.charCodeAt(0) * 16777216) +
              (datastr.charCodeAt(1) * 65536) +
              (datastr.charCodeAt(2) * 256) +
              (datastr.charCodeAt(3));
        return createField(SDTFieldType.UINT32, val);

      case 8:
        {
          var error = null;

          // we handle 48-bit ints safely
          val = getBinaryString(datastr.substr(0, 8));
          sign = isSigned && val.substr(0, 1) === '1';

          // If these bits change the representation, we can't
          // compute a valid representation.
          unsafeBits = parseInt(val.substr(1, 15), 2);

          // If the number is not signed, enforce bits 1-15 === 0.
          // If the number is signed and negative, enforce bits 1-15 === 1.
          if ((!sign && (unsafeBits !== 0)) ||
            (sign && (unsafeBits !== 0x7FFF))) {
            error = new SDTUnsupportedValueError('Value is not supported',
                        SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE,
                        datastr);
          }

          val = parseInt(val.substr(16, 48), 2);
          if (sign) {
            // negative (two's complement) number
            val -= C_2_48;
          }

          var field = createField(isSigned ? SDTFieldType.INT64 : SDTFieldType.UINT64, val);
          if (error) {
            field.setError(error);
          }

          return field;
        }

      default:
        return null;
    }
  },
};

module.exports.ParseInteger = ParseInteger;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var ref = __webpack_require__(2);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT unsupported value error.  An SDT field was assigned a value that is within
 * the type range for the given SDT type, but is not supported on this platform/runtime.
 * This occurs when a received {@link solace.SDTContainerMap} or {@link solace.SDTContainerStream}
 * contains a field with a value that can not represented in the local architecture.
 * Possible causes include:
 * * receive 64 bit integer that cannot be represented accurately in a javaScript number. JavaScript
 *   numbers are floats and can only hold a 48 bit integer without loss of precission. Any integer
 *   greater than 281474976710655 or less than -281474976710655 will cause this exception.
 * @extends solace.SolaceError
 * @memberof solace
 */
var SDTUnsupportedValueError = (function (SolaceError) {
  function SDTUnsupportedValueError(message, subcode, sourceData) {
    /**
     * The name of the error.
     * @name solace.SDTUnsupportedValueError#name
     * @type {Constant}
     * @description 'SDTUnsupportedValue'
     */
    SolaceError.call(this, 'SDTUnsupportedValue', message);
    /**
     * The subcode for the error. see {@link solace.SDTValueErrorSubcode}
     * @name solace.SDTUnsupportedValueError#subcode
     * @type {solace.SDTValueErrorSubcode}
     */
    this.subcode = subcode;
    this.sourceData = sourceData || '';
  }

  if ( SolaceError ) SDTUnsupportedValueError.__proto__ = SolaceError;
  SDTUnsupportedValueError.prototype = Object.create( SolaceError && SolaceError.prototype );
  SDTUnsupportedValueError.prototype.constructor = SDTUnsupportedValueError;

  SDTUnsupportedValueError.prototype.inspect = function inspect () {
    return SolaceError.prototype.inspect.call(this, {
      subcode:    null,
      sourceData: function (v) { return DebugLib.Debug.formatDumpBytes(v, false, 0); },
    });
  };

  SDTUnsupportedValueError.prototype.getSubcode = function getSubcode () {
    return this.subcode;
  };

  SDTUnsupportedValueError.prototype.getSourceData = function getSourceData () {
    return this.sourceData;
  };

  return SDTUnsupportedValueError;
}(SolaceError));


module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of {@link solace.SDTUnsuportedValueError} causes.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var SDTValueErrorSubcode = {
  /**
   * @type {Number}
   * @description
   * The value for this field may be valid on other platforms, but is outside the
   * range that is supported on this platform for the given type.
   */
  VALUE_OUTSIDE_SUPPORTED_RANGE: 1,
};

module.exports.SDTValueErrorSubcode = Enum.new(SDTValueErrorSubcode);


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/**
 * @classdesc
 *
 * Encapsulates the session's message receive callback function and
 * an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.
 * Use <tt>sessionObject.on({@link solace.SessionEventCode.MESSAGE})</tt> instead.
 *
 * @memberof solace
 */
var MessageRxCBInfo = function MessageRxCBInfo(messageRxCBFunction, userObject) {
  /**
   * @type {function(Session, Message, Object)}
   * @description The prototype of this function is the
   * following: ({@link solace.Session}, {@link solace.Message}, userObject {Object})
   */
  this.messageRxCBFunction = messageRxCBFunction;

  /**
   * @type {Object}
   * @description user-specified object
   */
  this.userObject = userObject;
};

module.exports.MessageRxCBInfo = MessageRxCBInfo;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Represents an enumeration of session properties that can be modified by
 * {@link solace.Session.updateProperty} after the {@link solace.Session} is originally
 * created.
 *
 * These correspond to session properties in {@link solace.SessionProperties}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var MutableSessionProperty = {
  /**
   * Client name: {@link solace.SessionProperties#clientName}
   * @type {Number}
   */
  CLIENT_NAME:        1,
  /**
   * Application description: {@link solace.SessionProperties#applicationDescription}
   * @type {Number}
   */
  CLIENT_DESCRIPTION: 2,
};

module.exports.MutableSessionProperty = Enum.new(MutableSessionProperty);


/***/ }),
/* 113 */
/***/ (function(module, exports) {

var P2PUtil = {
  getP2PInboxTopic: function getP2PInboxTopic(base) {
    return ((base + "/#"));
  },
  getP2PTopicSubscription: function getP2PTopicSubscription(base) {
    return ((base + "/>"));
  },
};

module.exports.P2PUtil = P2PUtil;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * Encapsulates the session's event callback function and an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.  Register event handlers
 * against {@link solace.SessionEventCode} events instead.
 *
 * @memberof solace
 */

var SessionEventCBInfo = function SessionEventCBInfo(sessionEventCBFunction, userObject) {
  /**
   * @type {Object}
   * @description user-specified object
   */
  this.userObject = userObject;

  /**
   * @type {function}
   * @description The prototype of this function is the
   * following:
   * ({@link solace.Session}, {@link solace.SessionEvent},
   * userObject {Object}, RFUObject {Object})
   */
  this.sessionEventCBFunction = sessionEventCBFunction;
};

module.exports.SessionEventCBInfo = SessionEventCBInfo;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(15);
var FsmEvent = ref$1.FsmEvent;
var ref$2 = __webpack_require__(3);
var Hex = ref$2.Hex;

var formatHexString = Hex.formatHexString;
/**
 * SessionFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends FsmEvent
 * @private
 */
var SessionFSMEvent = (function (FsmEvent) {
  function SessionFSMEvent(spec, fields) {
    FsmEvent.call(this, spec);
    /**
     * @type {String}
     * @description Information String for the {SessionEvent}
     */
    this.eventText = null;
    /**
     * @type {ErrorSubcode}
     * @description The Solace ErrorSubcode for any generated {SessionEvent}
     */
    this.errorSubcode = null;
    /**
     * @type {String}
     * @description The reason string to be included in any generated {SessionEvent}
     */
    this.eventReason = null;
    /**
     * @type {TransportSMFMessage}
     * @description A decoded SMF message received from the transport. May be
     * either a {ClientCtrlMessage} or a {SMPMessage}
     */
    this.smfMsg = null;
    /**
     * @type {Object}
     * @description The Transport SessionId retrieved from a {TransportSessionEvent}
     */
    this.sessionId = null;
    /**
     * @type {Object}
     * @description The Publisher or Consumer object associated with a GM event.
     */
    this.guaranteedFlowObject = null;

    Object.assign(this, fields);
  }

  if ( FsmEvent ) SessionFSMEvent.__proto__ = FsmEvent;
  SessionFSMEvent.prototype = Object.create( FsmEvent && FsmEvent.prototype );
  SessionFSMEvent.prototype.constructor = SessionFSMEvent;

  SessionFSMEvent.prototype[util.inspect.custom] = function () {
    return {
      'eventText':    this.eventText,
      'eventReason':  this.eventReason,
      'errorSubcode': ErrorSubcode.describe(this.errorSubcode),
      'sessionId':    this.sessionId && formatHexString(this.sessionId) || 'N/A',
    };
  };

  SessionFSMEvent.prototype.getExtraStringInfo = function getExtraStringInfo () {
    return util.inspect(this);
  };

  return SessionFSMEvent;
}(FsmEvent));

module.exports.SessionFSMEvent = SessionFSMEvent;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Internal session state
 * @enum {string}
 * @memberof solace
 * @private
 */
var SessionStateName = {
  DISCONNECTED:                     'SessionDisconnected',
  CONNECTING:                       'SessionConnecting',
  WAITING_FOR_TRANSPORT:            'WaitingForTransport',
  WAITING_FOR_TRANSPORT_UP:         'WaitingForTransportUp',
  WAITING_FOR_LOGIN:                'WaitingForLogin',
  TRANSPORT_UP:                     'SessionTransportUp',
  FULLY_CONNECTED:                  'SessionFullyConnected',
  SESSION_ERROR:                    'SessionError',
  DISCONNECTING:                    'SessionDisconnecting',
  REAPPLYING_SUBSCRIPTIONS:         'ReapplyingSubscriptions',
  WAITING_FOR_PUBFLOW:              'WaitingForMessagePublisher',
  DISPOSED:                         'SessionDisposed',
  WAITING_FOR_SUBCONFIRM:           'WaitForSubConfirm',
  WAITING_FOR_CAN_ACCEPT_DATA:      'WaitForCanAcceptData',
  DISCONNECTING_FLOWS:              'DisconnectingFlows',
  FLUSHING_TRANSPORT:               'FlushingTransport',
  DESTROYING_TRANSPORT:             'DestroyingTransport',
  RECONNECTING:                     'Reconnecting',
  TRANSPORT_FAIL:                   'TransportFail',
  WAITING_FOR_INTERCONNECT_TIMEOUT: 'WaitingForInterconnectTimeout',
  WAITING_FOR_DNS:                  'WaitingForDNS',
};

module.exports.SessionStateName = Enum.new(SessionStateName);


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionState = {
  /**
   * The session is connecting.
   */
  CONNECTING:    1,
  /**
   * The session is connected.
   */
  CONNECTED:     2,
  /**
   * The session experienced an error.
   */
  SESSION_ERROR: 3,
  /**
   * The session is disconnecting.
   */
  DISCONNECTING: 4,
  /**
   * The session is disconnected.
   */
  DISCONNECTED:  5,

};

module.exports.SessionState = Enum.new(SessionState);


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(13);
var AdProtocolMessage = ref.AdProtocolMessage;
var SMFParameter = ref.SMFParameter;
var ref$1 = __webpack_require__(3);
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(1);
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_INFO = ref$2.LOG_INFO;
var LOG_ERROR = ref$2.LOG_ERROR;
// const { SMFAdProtocolParam } = require('solclient-smf');

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

function parseAdpAt(data, offset) {
  if ((offset + 3) > data.length) {
    //not enough data
    /* #stripped LOG_DEBUG('Not enough data to read an ADP message.') */

    return false;
  }
  var pos = offset;
  var onebyte = strToInt8(data.substr(pos, 1));
  pos++;

  // var msgRFU = bits(onebyte, 6, 2);
  var adpVersion = bits(onebyte, 0, 6);
  var msgLength;
  var msgType;
  if (adpVersion < 3) {
    var twobyte = strToInt16(data.substr(pos, 2));
    pos += 2;
    msgType = bits(twobyte, 12, 4);
    // length in 32 bit words is in the lower 12 bits
    msgLength = bits(twobyte, 0, 12);
    // convert length to number of bytes
    msgLength <<= 2;
  } else if (adpVersion === 3) {
    onebyte = strToInt8(data[pos]);
    pos++;
    msgType = bits(onebyte, 0, 8);
    msgLength = strToUInt32(data.substr(pos, 4));
    pos += 4;
  } else {
    LOG_ERROR('Found unsupported ADP Version', adpVersion);
    return false; //unsupported type
  }
  //
  // Verify that the ADP header length does not exceed the entire
  // contents of the SMF message.
  if (offset + msgLength > data.length) {
    LOG_ERROR(("Invalid Asssured Control Protocol length=" + msgLength + " exceeds remaining message buffer = " + (data.length - offset)));
    return false; // invalid message format
  }
  var adpMsg = new AdProtocolMessage(msgType, adpVersion);
  while (pos < (offset + msgLength)) {
    onebyte = strToInt8(data.substr(pos, 1));
    pos++;
    var paramUH = bits(onebyte, 6, 2);
    var paramType = bits(onebyte, 0, 6);

    // Look for and skip padding bytes
    if (paramType === 0) {
      continue;
    }
    if (pos >= (offset + msgLength)) {
      LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " at position =" + pos));
      return false; // Assured Control parsing fail
    }
    var paramLen = strToInt8(data.substr(pos, 1));
    var paramValueLen = (void 0);
    pos++;
    // If paramLen == 0, then this is an extended length format
    // and there is a 4 byte length following the '0'
    if (paramLen === 0) {
      // need at least 5 more bytes in the buffer
      if (pos + 5 > (offset + msgLength)) {
        LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " at position =" + pos));
        return false; // Assured Control parsing fail
      }
      paramLen = strToUInt32(data.substr(pos, 4));
      pos += 4;
      paramValueLen = paramLen - 5;
    } else {
      paramValueLen = paramLen - 2;
    }
    if (paramLen <= 0) {
      return false; // Assured Control parsing fail
    }
    //
    // make sure there is enough buffer for paramValueLen
    if (pos + paramValueLen > offset + msgLength) {
      LOG_ERROR(("Invalid Asssured Control Protocol parameter=" + paramType + " length =" + paramValueLen + " invalid at position =" + pos));
      return false; // Assured Control parsing fail
    }
    var paramValue = data.substr(pos, paramValueLen);
    adpMsg.addParameter(new SMFParameter(paramUH, paramType, paramValue));
    pos += paramValueLen;
  }
  return adpMsg;
}

function encAdp8Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(3)); // length
  data.push(Convert.int8ToStr(value));
  return data.join('');
}

function encAdp16Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(4)); // length
  data.push(Convert.int16ToStr(value));
  return data.join('');
}

function encAdp32Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(6)); // length
  data.push(Convert.int32ToStr(value));
  return data.join('');
}

function encAdp64Param(uh, paramtype, value) {
  var data = [];
  var byte1 = 0;

  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(10)); // length
  data.push(Convert.int64ToStr(value));
  return data.join('');
}

function encAdp64AckPairParam(uh, paramtype, min, max) {
  var data = [];
  var byte1 = 0;
  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));
  data.push(Convert.int8ToStr(18)); // length
  data.push(Convert.int64ToStr(min));
  data.push(Convert.int64ToStr(max));
  return data.join('');
}

function encAdpUTF8NTParam(uh, paramtype, value) {
  // value is already UTF8 encoded and null terminated.
  var data = [];
  var byte1 = 0;
  byte1 = Bits.set(byte1, uh, 6, 2);
  byte1 = Bits.set(byte1, paramtype, 0, 6);
  data.push(Convert.int8ToStr(byte1));

  var byte2 = 0;
  if (value.length <= 253) {
    byte2 = value.length + 2; // full length of param
    data.push(Convert.int8ToStr(byte2));
  } else {
    byte2 = 0; // extended-length
    data.push(Convert.int8ToStr(byte2));
    data.push(Convert.int32ToStr(value.length + 5));
  }
  data.push(value);
  return data.join('');
}

function encAdp(adpMsg) {
  var paramspace = [];
  var paramarray = adpMsg.getParameterArray();

  var p;
  var byte1 = 0;
  for (p = 0; p < paramarray.length; p++) {
    var param = paramarray[p];
    // It's not a flat array, we have gaps!
    if (param === undefined) {
      continue;
    }

    switch (param.getType()) {
      /*
       * 8 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.WINDOW:
      case SMFLib.SMFAdProtocolParam.EP_DURABLE:
      case SMFLib.SMFAdProtocolParam.ACCESSTYPE:
      case SMFLib.SMFAdProtocolParam.FLOWTYPE:
      case SMFLib.SMFAdProtocolParam.EP_RESPECTS_TTL:
      case SMFLib.SMFAdProtocolParam.TRANSACTION_CTRL_MESSAGE_TYPE:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_STATE:
      case SMFLib.SMFAdProtocolParam.ACTIVE_FLOW_INDICATION:
      case SMFLib.SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY:
      case SMFLib.SMFAdProtocolParam.MAX_REDELIVERY:
        paramspace.push(encAdp8Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 16 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.EP_BEHAVIOUR:
        paramspace.push(encAdp16Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 32 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.FLOWID:
      case SMFLib.SMFAdProtocolParam.TRANSPORT_WINDOW:
      case SMFLib.SMFAdProtocolParam.EP_ALLOTHER_PERMISSION:
      case SMFLib.SMFAdProtocolParam.EP_QUOTA:
      case SMFLib.SMFAdProtocolParam.EP_MAX_MSGSIZE:
      case SMFLib.SMFAdProtocolParam.GRANTED_PERMISSION:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_ID:
      case SMFLib.SMFAdProtocolParam.PUBLISHER_ID:
        paramspace.push(encAdp32Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * 64 bit parameters
       */
      case SMFLib.SMFAdProtocolParam.LASTMSGIDSENT:
      case SMFLib.SMFAdProtocolParam.LASTMSGIDACKED:
      case SMFLib.SMFAdProtocolParam.LASTMSGIDRECEIVED:
      case SMFLib.SMFAdProtocolParam.TRANSACTION_ID:
        paramspace.push(encAdp64Param(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * application ack
       */
      case SMFLib.SMFAdProtocolParam.APPLICATION_ACK:
        {
          // Unpack this to multiple parameters
          var ranges = param.getValue();
          var uh = param.getUh();
          var type = param.getType();
          for (var i = 0; i < ranges.length; ++i) {
            var range = ranges[i];
            paramspace.push(encAdp64AckPairParam(uh,
                                                 type,
                                                 range[0],
                                                 range[1]));
          }
          break;
        }
      /*
       * string and other variable length parameters
       */
      case SMFLib.SMFAdProtocolParam.QUEUENAME:
      case SMFLib.SMFAdProtocolParam.DTENAME:
      case SMFLib.SMFAdProtocolParam.TOPICNAME:
      case SMFLib.SMFAdProtocolParam.FLOWNAME:
      case SMFLib.SMFAdProtocolParam.SELECTOR:
      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_NAME:
        paramspace.push(encAdpUTF8NTParam(param.getUh(), param.getType(), param.getValue()));
        break;
      /*
       * Transaction Publisher Notify
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:
        // TODO:
        break;
      /*
       * Transaction Publisher Ack
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:
        // TODO:
        break;
      /*
       * Transaction Subscriber Ack
       */
      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:
        // TODO:
        break;
      /*
       * No Local Parameter has no data
       * Cut Through Parameter has no data
       */
      case SMFLib.SMFAdProtocolParam.NOLOCAL:
      case SMFLib.SMFAdProtocolParam.CUT_THROUGH:
        byte1 = setBits(byte1, param.getUh(), 6, 2);
        byte1 = setBits(byte1, param.getType(), 0, 6);
        paramspace.push(
          int8ToStr(byte1) + // uh, type
          int8ToStr(2)       // length
        );
        break;
      /*
       * Application Publisher Acknowledge
       */
      case SMFLib.SMFAdProtocolParam.APPLICATION_PUB_ACK:
        // TODO:
        break;
      default:
        LOG_INFO('Unrecognized ADProtocol Parameter in Message');
        break;
    }
  }

  var paramdata = paramspace.join('');

  var data = [];
  if (adpMsg.version === 2) {
    var threebytes = 0;
    threebytes = setBits(threebytes, 0, 22, 2); // RFU
    threebytes = setBits(threebytes, adpMsg.version, 16, 6); // RFU
    threebytes = setBits(threebytes, adpMsg.msgType, 12, 4); // msgtype
    // length in 32 bit words means the real length must always be a multiple of 4, so pad as
    // necessary

    // 4 - how many bytes passed a 4 byte boundary
    var padBytes = 4 - ((3 + paramdata.length) & 0x3);
    // calculate the total length, 3 bytes header + params, in 32 bit words
    var length = (3 + paramdata.length + padBytes) >> 2;
    threebytes = setBits(threebytes, length, 0, 12);
    data.push(int24ToStr(threebytes)); // first 3B (RFU, version, msgtype, length)
    data.push(paramdata);

    if (padBytes === 4) { padBytes = 0; } // don't add 4 pad bytes
    while (padBytes > 0) {
      data.push(int8ToStr(0));
      padBytes--;
    }
  } else if (adpMsg.version === 3) {
    var twobytes = 0;
    twobytes = setBits(twobytes, 0, 14, 2); // RFU
    twobytes = setBits(twobytes, adpMsg.version, 8, 6); // version
    twobytes = setBits(twobytes, adpMsg.msgType, 0, 8); // msgtype
    data.push(int16ToStr(twobytes)); // first 2B (RFU, version, msgtype)
    data.push(int32ToStr(6 + paramdata.length)); //length: 6B header + params
    data.push(paramdata);
  } else {
    LOG_ERROR(("Invalid Version " + (adpMsg.version) + " found while encoding"));
  }

  return data.join('');
}

module.exports.parseAdpAt = parseAdpAt;
module.exports.encAdp = encAdp;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(13);
var ClientCtrlMessage = ref$1.ClientCtrlMessage;
var SMFParameter = ref$1.SMFParameter;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

function parseCCAt(data, offset, payloadLen) {
  var ccMsg = new ClientCtrlMessage();
  if (payloadLen < 6 || offset + 6 > data.length) {
      // not enough data! Return empty.
      // This is required because we can get an empty CC payload as a router response
    return ccMsg;
  }

  var pos = offset;
  var twobytes = strToInt16(data.substr(pos, 2));
  pos += 2;
    // var uh = bits(twobytes, 15, 1);
  var version = bits(twobytes, 8, 3);
  var msgType = bits(twobytes, 0, 8);
  var len = strToUInt32(data.substr(pos, 4));
  pos += 4;

    // Sanity check: we support ClientCtrl v1
  if (version !== 1) {
    LOG_ERROR(("Unsupported ClientCtrl version " + version));
    return false;
  }

  if (len <= 0 || (offset + len) > data.length) {
    return false;
  }

  ccMsg.msgType = msgType;
  ccMsg.version = version;
  while (pos < (offset + len)) {
    var onebyte = strToInt8(data.substr(pos, 1));
    pos++;
    var paramUh = bits(onebyte, 7, 1);
    var paramType = bits(onebyte, 0, 7);
    var paramLen = strToUInt32(data.substr(pos, 4));
    if (paramLen <= 0) {
      return false; // SMF parsing fail
    }

    pos += 4;
    var paramValueLen = paramLen - 5;
    var paramValue = data.substr(pos, paramValueLen);
    ccMsg.addParameter(new SMFParameter(paramUh, paramType, paramValue));
    pos += paramValueLen;
  }
  return ccMsg;
}

function encCC(ccMsg) {
  var paramSpace = [];
  var paramArray = ccMsg.getParameterArray();
    /*
    ClientCtrl Parameter formatting:
        1 byte uh/type
        4 bytes length
        N bytes value
     */
  for (var p = 0, n = paramArray.length; p < n; ++p) {
    var currentParam = paramArray[p];
      // It's not a flat array, we have gaps!
    if (currentParam === undefined) {
      continue;
    }
    var currentParamOneByte = 0;
    currentParamOneByte = setBits(currentParamOneByte, currentParam.getUh(), 7, 1);
    currentParamOneByte = setBits(currentParamOneByte, currentParam.getType(), 0, 7);
    paramSpace.push(int8ToStr(currentParamOneByte));
    paramSpace.push(int32ToStr(currentParam.getValue().length + 5));
    paramSpace.push(currentParam.getValue());
  }

  var paramData = paramSpace.join('');
  var twobytes = 0;
  twobytes = setBits(twobytes, 0, 15, 1); // uh
  twobytes = setBits(twobytes, 0, 11, 4); // RFU
  twobytes = setBits(twobytes, 1, 8, 3); // version
  twobytes = setBits(twobytes, ccMsg.msgType, 0, 8); // msgtype

  var data = [];
  data.push(int16ToStr(twobytes)); // first 2B (uh, version, msgtype)
  data.push(int32ToStr(6 + paramData.length)); // length: 6B header + params
  data.push(paramData);
  return data.join('');
}

module.exports.parseCCAt = parseCCAt;
module.exports.encCC = encCC;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

var ContentSummaryElement = function ContentSummaryElement(type, position, length) {
  if ( type === void 0 ) type = null;
  if ( position === void 0 ) position = 0;
  if ( length === void 0 ) length = 0;

  this.type = type;
  this.position = position;
  this.length = length;
};

module.exports.ContentSummaryElement = ContentSummaryElement;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_ERROR = ref.LOG_ERROR;
var LOG_INFO = ref.LOG_INFO;
var ref$1 = __webpack_require__(3);
var Base64 = ref$1.Base64;
var Bits = ref$1.Bits;
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(76);
var ParamParse = ref$2.ParamParse;
var ref$3 = __webpack_require__(13);
var SMFHeader = ref$3.SMFHeader;
var ref$4 = __webpack_require__(78);
var SMFParameterType = ref$4.SMFParameterType;

var base64Decode = Base64.decode;
var bits = Bits.get;
var strToInt8 = Convert.strToInt8;
var strToInt24 = Convert.strToInt24;
var strToInt32 = Convert.strToInt32;
var strToUInt32 = Convert.strToUInt32;
var strToUInt64 = Convert.strToUInt64;

function isSMFHeaderAvailable(data, offset) {
  var remaining = data.length - offset;
  if (remaining < 12) {
    return false;
  }

  return true;
}

function isSMFHeaderValid(data, offset) {
  if (!isSMFHeaderAvailable(data, offset)) {
    return false;
  }
  var version = strToInt8(data[offset]) & 0x7;
  if (version !== 3) {
    LOG_ERROR(("Invalid smf version in smf header, version=" + version));
    return false;
  }
  return true;
}

function isSMFAvailable(data, offset) {
  if (!isSMFHeaderValid(data, offset)) {
    return false;
  }
  var remaining = data.length - offset;
  var totalLen = strToUInt32(data.substr(offset + 8, 4));
  return (totalLen <= remaining);
}

/**
 * Parse SMF in the given data at the supplied offset.
 * @param {String} data The binary data to parse
 * @param {Number} offset The offset in the data to begin parsing
 * @param {Boolean} readHeaderOnly If true, stop parsing at end of header
 * @returns {SMFHeader|null} The SMF header, if possible
 * @private
 */
function parseSMFAt(data, offset, readHeaderOnly) {
  if ( readHeaderOnly === void 0 ) readHeaderOnly = false;

  if (!isSMFHeaderValid(data, offset)) {
    /* #stripped LOG_DEBUG('Valid SMF header not available') */

    return null;
  }
  var pos = offset;

    // Reading fixed header block (12 bytes)
  var word1 = strToInt32(data.substr(pos, 4));
  var headerLen = strToUInt32(data.substr(pos + 4, 4));
  var word3 = strToUInt32(data.substr(pos + 8, 4));

  var smfHeader = new SMFHeader();
  smfHeader.smf_di = bits(word1, 31, 1);
  smfHeader.smf_elidingEligible = bits(word1, 30, 1);
  smfHeader.smf_dto = bits(word1, 29, 1);
  smfHeader.smf_adf = bits(word1, 28, 1);
  smfHeader.smf_deadMessageQueueEligible = bits(word1, 27, 1);
  smfHeader.smf_version = bits(word1, 24, 3);
  smfHeader.smf_uh = bits(word1, 22, 2);
  smfHeader.smf_protocol = bits(word1, 16, 6);
  smfHeader.smf_priority = bits(word1, 12, 4);
  smfHeader.smf_ttl = bits(word1, 0, 8);

  var payloadLen = word3 - headerLen;
  if (payloadLen < 0) {
    LOG_ERROR('SMF parse error: lost framing');
    return null; // SMF parse error: lost framing
  }
  smfHeader.setMessageSizes(headerLen, payloadLen);
  if (readHeaderOnly) {
    return smfHeader;
  }
  pos += 12;

  // Reading variable-length params
  var end = offset + headerLen;
  while (pos < end) {
    var paramByte1 = data.charCodeAt(pos);
    ++pos;

    var prmUh = bits(paramByte1, 6, 2);
    var paramIsLightweight = (bits(paramByte1, 5, 1) !== 0);
    if (paramIsLightweight) {
      // LIGHTWEIGHT param
      var lwpType = bits(paramByte1, 2, 3);
      var lwpLen = bits(paramByte1, 0, 2) + 1;
      var lwpValueLen = lwpLen - 1;
      if (lwpLen <= 0) {
        LOG_ERROR('Invalid lightweight parameter length');
        return null; // Invalid parameter
      }

      switch (lwpType) {
        case SMFParameterType.LIGHT_CORRELATION:
          smfHeader.pm_corrtag = strToInt24(data.substr(pos, 3));
          break;
        case SMFParameterType.LIGHT_TOPIC_NAME_OFFSET:
          {
            var parsedQueueOffsets = ParamParse.parseTopicQueueOffsets(data, pos);
            smfHeader.pm_queue_offset = parsedQueueOffsets[0];
            smfHeader.pm_queue_len = parsedQueueOffsets[1];
            break;
          }
        case SMFParameterType.LIGHT_QUEUE_NAME_OFFSET:
          {
            var parsedTopicOffsets = ParamParse.parseTopicQueueOffsets(data, pos);
            smfHeader.pm_topic_offset = parsedTopicOffsets[0];
            smfHeader.pm_topic_len = parsedTopicOffsets[1];
            break;
          }
        case SMFParameterType.LIGHT_ACK_IMMEDIATELY:
          smfHeader.pm_ad_ackimm = !!data.charCodeAt(pos);
          break;
        default:
          if (prmUh === 0) {
            // Ignore, and silently discard the parameter.
            /* #stripped LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding parameter.`) */

          } else {
            // Ignore, and silently discard the entire message.
            /* #stripped LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding message.`) */

            smfHeader.discardMessage = true;
          }
          break;
      }
      pos += lwpValueLen;
    } else {
      // REGULAR encoded param
      var pStart = pos;
      var pType = bits(paramByte1, 0, 5);
      if (pType === 0) {
        break; // PADDING (break while: header finished)
      }

      var pLen = data.charCodeAt(pos);
      pos++;
      var pValueLen = (void 0);
      if (pLen === 0) {
        // extended-length parameter (32-bit)
        pLen = strToUInt32(data.substr(pos, 4));
        pos += 4;
        pValueLen = pLen - 6;
      } else {
        pValueLen = pLen - 2;
      }

      if (pLen <= 0) {
        LOG_ERROR(("Invalid regular parameter length " + pLen + "/" + pValueLen + " with suspect type " + (SMFParameterType.describe(pType)) + " at parameter at position " + pStart));
        return null; // Invalid parameter
      }

      switch (pType) {
        case SMFParameterType.PUBLISHER_ID:
          smfHeader.pm_ad_publisher_id = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.PUBLISHER_MSGID:
          smfHeader.pm_ad_publishermsgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.MESSAGEPRIORITY:
          smfHeader.pm_msg_priority = data.charCodeAt(pos);
          break;
        case SMFParameterType.USERDATA:
          smfHeader.pm_userdata = data.substr(pos, pValueLen);
          break;
        case SMFParameterType.USERNAME:
          // only useful on API -> router
          smfHeader.pm_username = base64Decode(data.substr(pos, pValueLen));
          break;
        case SMFParameterType.PASSWORD:
          // only useful on API -> router
          smfHeader.pm_password = base64Decode(data.substr(pos, pValueLen));
          break;
        case SMFParameterType.RESPONSE:
          {
            var parsedResponse = ParamParse.parseResponseParam(data, pos, pValueLen);
            smfHeader.pm_respcode = parsedResponse[0];
            smfHeader.pm_respstr = parsedResponse[1];
            break;
          }
        case SMFParameterType.SUB_ID_LIST:
        case SMFParameterType.GENERIC_ATTACHMENT:
        case SMFParameterType.BINARY_ATTACHMENT:
          LOG_INFO('Skipping deprecated parameter type');
          // deprecated
          break;
        case SMFParameterType.DELIVERY_MODE:
          // DeliveryMode is DIRECT unless the AD flag is set. The
          // deliveryMode parameter (and all other guaranteed messaging
          // parameters may be present in demoted messages reflecting how
          // the message was published.
          // IF ever solClientJS must support the horror that is cut-through
          // persistence, then we must defer setting deliveryMode back to
          // DIRECT until the session decides whether it is a true direct
          // message or a cut-through direct message.  But until that is
          // forced upon us, the cleanest place to set deliveryMode is always
          // here in the parser.
          if (smfHeader.smf_adf) {
            smfHeader.pm_deliverymode = ParamParse.parseDeliveryMode(data, pos);
          }
          break;
        case SMFParameterType.ASSURED_MESSAGE_ID:
          smfHeader.pm_ad_msgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.ASSURED_PREVMESSAGE_ID:
          smfHeader.pm_ad_prevmsgid = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.ASSURED_REDELIVERED_FLAG:
          smfHeader.pm_ad_redelflag = true;
          break;
        case SMFParameterType.AD_TIMETOLIVE:
          smfHeader.pm_ad_ttl = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.AD_TOPICSEQUENCE_NUMBER:
          smfHeader.pm_ad_topicSequenceNumber = strToUInt64(data.substr(pos, 8));
          break;
        case SMFParameterType.MESSAGE_CONTENT_SUMMARY:
          {
            var contentSummary = ParamParse.parseContentSummary(data, pos, pValueLen);
            if (!contentSummary) {
              LOG_ERROR(("Invalid message content summary at " + pos + ", len " + pValueLen));
              return false; // invalid message content summary parameter
            }
            smfHeader.pm_content_summary = contentSummary;
            break;
          }
        case SMFParameterType.ASSURED_FLOWID:
          smfHeader.pm_ad_flowid = strToUInt32(data.substr(pos, 4));
          break;
        case SMFParameterType.TR_TOPICNAME:
          // copy bytes. Don't strip null terminator
          smfHeader.pm_tr_topicname_bytes = data.substr(pos, pValueLen);
          break;
        case SMFParameterType.AD_FLOWREDELIVERED_FLAG:
          smfHeader.pm_ad_flowredelflag = true;
          break;
        default:
          if (prmUh === 0) {
            // Ignore, and silently discard the parameter.
            /* #stripped LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding parameter.`) */

          } else {
            // Ignore, and silently discard the entire message.
            /* #stripped LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding message.`) */

            smfHeader.discardMessage = true;
          }
          break;
      } // end param type switch block

      pos += pValueLen;
    } // end (regular param)
  } // end while

  return smfHeader;
}

var ParseSMF = {
  isSMFHeaderAvailable: isSMFHeaderAvailable,
  isSMFHeaderValid: isSMFHeaderValid,
  isSMFAvailable: isSMFAvailable,
  parseSMFAt: parseSMFAt,
};

module.exports.ParseSMF = ParseSMF;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(0);
var BidiMap = ref.BidiMap;

var PriorityUserCosMap = (function (BidiMap) {
  function PriorityUserCosMap() {
    BidiMap.call(this, [MessageLib.MessageUserCosType.COS1, 0],
          [MessageLib.MessageUserCosType.COS2, 1],
          [MessageLib.MessageUserCosType.COS3, 2]);
  }

  if ( BidiMap ) PriorityUserCosMap.__proto__ = BidiMap;
  PriorityUserCosMap.prototype = Object.create( BidiMap && BidiMap.prototype );
  PriorityUserCosMap.prototype.constructor = PriorityUserCosMap;

  return PriorityUserCosMap;
}(BidiMap));

module.exports.PriorityUserCosMap = PriorityUserCosMap;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(79);
var SMFSMPMessageType = ref$2.SMFSMPMessageType;
var ref$3 = __webpack_require__(13);
var SMPMessage = ref$3.SMPMessage;

var bits = Bits.get;
var setBits = Bits.set;

var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int32ToStr = Convert.int32ToStr;
var strToUInt32 = Convert.strToUInt32;

var SMP = {
  parseSMPAt: function parseSMPAt(data, offset) {
    if ((offset + 6) > data.length) {
                // not enough data
      /* #stripped LOG_DEBUG('Not enough data to read an SMP message.') */

      return false;
    }
    var pos = offset;
    var onebyte = strToInt8(data.substr(pos, 1));
    pos++;

            // var msgUh = bits(onebyte, 7, 1);
    var msgType = bits(onebyte, 0, 7);
    var smpMsg = new SMPMessage();

    if (!(msgType === SMFSMPMessageType.ADDSUBSCRIPTION ||
          msgType === SMFSMPMessageType.REMSUBSCRIPTION)) {
      /* #stripped LOG_DEBUG(`Found unsupported SMP messageType ${msgType}`) */

      return false; // unsupported type
    }

    var msgLength = strToUInt32(data.substr(pos, 4));
    pos += 4;
    if ((offset + msgLength) > data.length) {
                  // not enough data
      /* #stripped LOG_DEBUG(`Invalid declared length of ${msgLength}, unable to read SMP message.`) */

      return false;
    }
    var msgFlags = strToInt8(data.substr(pos, 1));
    pos++;

    smpMsg.msgType = msgType;
    smpMsg.smpFlags = msgFlags;
    smpMsg.encodedUtf8Subscription = data.substr(pos, msgLength - 6); // 6 is the base len
    return smpMsg;
  },

  encSmp: function encSmp(smpMsg) {
    if (!(smpMsg.msgType === SMFSMPMessageType.ADDSUBSCRIPTION ||
          smpMsg.msgType === SMFSMPMessageType.REMSUBSCRIPTION)) {
      /* #stripped LOG_DEBUG(`Unsupported SMP message for encoding: ${smpMsg}`) */

      return false;
    }

    var data = [];
    var onebyte = 0;
    onebyte = setBits(onebyte, 1, 7, 1);
    onebyte = setBits(onebyte, smpMsg.msgType, 0, 7);
    data.push(int8ToStr(onebyte));
    data.push(int32ToStr(6 + smpMsg.encodedUtf8Subscription.length)); // length
    data.push(int8ToStr(smpMsg.smpFlags));
    data.push(smpMsg.encodedUtf8Subscription);
    return data.join('');
  },
};

module.exports.SMP = SMP;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(0);
var Lazy = ref$1.Lazy;
var ref$2 = __webpack_require__(1);
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(131);
var SMFTransportSessionMessageType = ref$3.SMFTransportSessionMessageType;
var ref$4 = __webpack_require__(13);
var TransportSMFMessage = ref$4.TransportSMFMessage;

var bits = Bits.get;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var int32ToStr = Convert.int32ToStr;
var lazyValue = Lazy.lazyValue;

// ========== TSSMF ==========
function remains(data, offset) {
  return data.length - offset;
}

function parseTsSmfHdrAt(data, offset, smfheader) {
  var pos = offset;
  if (remains(data, pos) < 10) {
    LOG_ERROR('TsSmf parse failed: not enough data, expected at least 10B');
    return false;
  }

  var transportSMFMessage = new TransportSMFMessage();
  transportSMFMessage.smfHeader = smfheader;
  var twobyte = strToInt16(data.substr(pos, 2));
  pos += 2;
  transportSMFMessage.uh = bits(twobyte, 15, 1);
  transportSMFMessage.messageType = bits(twobyte, 8, 7);
  var tsHdrLen = bits(twobyte, 0, 8);
  transportSMFMessage.tsHeaderLength = tsHdrLen;
  transportSMFMessage.sessionId = data.substr(pos, 8);
  pos += 8;

  if (transportSMFMessage.messageType ===
      SMFTransportSessionMessageType.CREATE_RESP) {
    // parse extra chunk: routerTag
    var rtrTagLen = strToInt8(data.substr(pos, 1));
    pos++;
    if (remains(data, pos) < rtrTagLen) {
      LOG_ERROR(("TsSmf parse failed: not enough data for RouterTag, expected " + rtrTagLen + "B"));
      return false;
    }
    transportSMFMessage.routerTag = data.substr(pos, rtrTagLen);
    pos += rtrTagLen;
  }

  // FFWD any remaining TsSmf padding?
  pos = offset + tsHdrLen;

  // Length of encapsulated message payload:
  // the SMF msg payload length - bytes consumed in TsSmf

  if (smfheader.payloadLength === 0xffffffff) {
    // special "streaming" unknown-length header
    transportSMFMessage.payloadLength = smfheader.payloadLength;
  } else {
    transportSMFMessage.payloadLength = smfheader.payloadLength - tsHdrLen;
  }
  return transportSMFMessage; // Header with no payload field
}

// Generates an SMF header up to, but not including the the total length
// This is fixed for all client generated transport session messages
var tsHeaderPreLength = lazyValue(function () { return (
  int32ToStr(0x03140001) +  // SMF version, TransportSession, TTL
  int32ToStr(12)            // Header length
); });

var tsDestroyHeaderPreSid = lazyValue(function () { return (
  tsHeaderPreLength.value + // Header up to the message length field
  int32ToStr(22) +          // Total length
  int16ToStr(0x820a)        // msgType(destroy), length
); });

var tsCreateHeader = lazyValue(function () { return (
  tsHeaderPreLength.value + // Header up to the message length field
  int32ToStr(22) +          // Total length
  int16ToStr(0x800a) +      // msgType(create), length
  int32ToStr(0) +           // Session ID (first half)
  int32ToStr(0)             // Session ID (second half)
); });

var tsDataTokenPreSid = lazyValue(function () { return (
  int32ToStr(0x03940001) +
  int32ToStr(12) +
  int32ToStr(22) +
  int16ToStr(0x850a)
); });

var tsDataStreamTokenPreSid = lazyValue(function () { return (
  int32ToStr(0x03940001) +
  int32ToStr(12) +
  int32ToStr(24) +
  int16ToStr(0x860c)
); });

// Generate a full Transport Session Create header
function genTsCreateHeader() {
  return tsCreateHeader.value;
}

// Generate a full Transport Session Destroy header
function genTsDestroyHeader(sid) {
  return (
    tsDestroyHeaderPreSid.value +
    sid                       // Session ID
  );
}

// Generate a data token message
function genTsDataTokenMsg(sid) {
  return (
    tsDataTokenPreSid.value +
    sid
  );
}

// Generate a STREAMING data token message
function genTsDataStreamTokenMsg(sid, paddingBytes) {
  return (
    tsDataStreamTokenPreSid.value +
    sid +
    ((paddingBytes && paddingBytes > 0) ? int16ToStr(paddingBytes) : int16ToStr(0x0000))
  );
}

function genTsDataMsgHeaderParts(sid) {
  return [
    (int32ToStr(0x03940001) + int32ToStr(12)),
    (int16ToStr(0x840a) + sid) ];
}

function parseTsSmfMsgAt(data, offset, smfheader) {
  var transportSMFMessage = parseTsSmfHdrAt(data, offset, smfheader);
  if (!transportSMFMessage) {
    return null;
  }

    // need to FF to pos
  var pos = offset + transportSMFMessage.tsHeaderLength;

    // Length of encapsulated message payload:
    // the SMF msg payload length - bytes consumed in TsSmf
  if (remains(data, pos) < transportSMFMessage.payloadLength) {
    LOG_ERROR(("Couldn't read full encapsulated TsSmf payload, expected " + (transportSMFMessage.payloadLength) + "B"));
    return null;
  }

  transportSMFMessage.payload = data.substr(pos, transportSMFMessage.payloadLength); // router tag
  return transportSMFMessage;
}

var Transport = {
  genTsCreateHeader: genTsCreateHeader,
  genTsDestroyHeader: genTsDestroyHeader,
  genTsDataTokenMsg: genTsDataTokenMsg,
  genTsDataStreamTokenMsg: genTsDataStreamTokenMsg,
  genTsDataMsgHeaderParts: genTsDataMsgHeaderParts,
  parseTsSmfHdrAt: parseTsSmfHdrAt,
  parseTsSmfMsgAt: parseTsSmfMsgAt,
};

module.exports.Transport = Transport;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var SMFUH = {
  IGNORE: 0x0,
  REJECT: 0x2,
};

module.exports.SMFUH = Enum.new(SMFUH);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFAdProtocolMessageType = {
  OPENPUBFLOW:      0x00,
  // INTERROUTERACK:          0x01,
  // INTERROUTERHANDSHAKEACK: 0x02,
  CLIENTACK:        0x03,
  BIND:             0x04,
  UNBIND:           0x05,
  UNSUBSCRIBE:      0x06,
  CLOSEPUBFLOW:     0x07,
  CREATE:           0x08,
  DELETE:           0x09,
  // FLOWRECOVER:  0x0a,
  TRANSACTIONCTRL:  0x0b,
  FLOWCHANGEUPDATE: 0x0c,
  // EXTERNALACK:      0x0d,
  XACTRL:           0x0e,
  CLIENTNACK:       0x0f,
  // TXNCTRL:          0x10,
};

module.exports.SMFAdProtocolMessageType = Enum.new(SMFAdProtocolMessageType);


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFAdProtocolParam = {
  LASTMSGIDSENT:                           0x01,
  LASTMSGIDACKED:                          0x02,
  WINDOW:                                  0x03,
  TRANSPORT_PRIORITY:                      0x04,
  APPLICATION_ACK:                         0x05,
  FLOWID:                                  0x06,
  QUEUENAME:                               0x07,
  DTENAME:                                 0x08,
  TOPICNAME:                               0x09,
  FLOWNAME:                                0x0a,
  EP_DURABLE:                              0x0b,
  ACCESSTYPE:                              0x0c,
  SELECTOR:                                0x0d,
  TRANSPORT_WINDOW:                        0x0e,
  LINGER_OPTION:                           0x0f,
  LASTMSGIDRECEIVED:                       0x10,
  EP_ALLOTHER_PERMISSION:                  0x11,
  FLOWTYPE:                                0x12,
  EP_QUOTA:                                0x13,
  EP_MAX_MSGSIZE:                          0x14,
  GRANTED_PERMISSIONS:                     0x15,
  EP_RESPECTS_TTL:                         0x16,
  TRANSACTION_CTRL_MESSAGE_TYPE:           0x17,
  TRANSACTED_SESSION_ID:                   0x18,
  TRANSACTED_SESSION_NAME:                 0x19,
  TRANSACTION_ID:                          0x1a,
  TRANSACTED_SESSION_STATE:                0x1b,
  TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:  0x1c,
  TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:     0x1d,
  TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:     0x1e,
  NOLOCAL:                                 0x1f,
  ACTIVE_FLOW_INDICATION:                  0x20,
  WANT_FLOW_CHANGE_NOTIFY:                 0x21,
  EP_BEHAVIOUR:                            0x22,
  PUBLISHER_ID:                            0x23,
  APPLICATION_PUB_ACK:                     0x24,
  NUM_MESSAGES_SPOOLED:                    0x25,
  CUT_THROUGH:                             0x26,
  PUBLISHER_FLAGS:                         0x27,
  APP_MSG_ID_TYPE:                         0x28,
  QUEUE_ENDPOINT_HASH:                     0x29,
  MAX_REDELIVERY:                          0x2a,
  PAYLOAD:                                 0x2b,
  ENDPOINT_ID:                             0x2c,
  ACK_SEQUENCE_NUMBER:                     0x2d,
  ACK_RECONCILE_REQUEST:                   0x2e,
  START_OF_ACK_RECONCILE:                  0x2f,
  TIMESTAMP:                               0x30,
  MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW: 0x31,
};

module.exports.SMFAdProtocolParam = Enum.new(SMFAdProtocolParam);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFClientCtrlMessageType = {
  LOGIN:  0x00,
  UPDATE: 0x01,
};

module.exports.SMFClientCtrlMessageType = Enum.new(SMFClientCtrlMessageType);


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFClientCtrlParam = {
  SOFTWAREVERSION:              0x00,
  SOFTWAREDATE:                 0x01,
  PLATFORM:                     0x02,
  USERID:                       0x03,
  CLIENTDESC:                   0x04,
  CLIENTNAME:                   0x05,
  MSGVPNNAME:                   0x06,
  DELIVERTOONEPRIORITY:         0x07,
  P2PTOPIC:                     0x08,
  ROUTER_CAPABILITIES:          0x09,
  VRIDNAME:                     0x0a,
  PHYSICALROUTERNAME:           0x0c,
  BRIDGE_MSG_VPN_NAME:          0x0d,
  BRIDGE_ROUTER_NAME:           0x0e,
  NO_LOCAL:                     0x0f,
  BRIDGE_VERSION:               0x10,
  AUTHENTICATION_SCHEME:        0x11,
  CONNECTION_TYPE:              0x12,
  ROUTER_CAPABILITIES_EXTENDED: 0x13,
};

module.exports.SMFClientCtrlParam = Enum.new(SMFClientCtrlParam);


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFSMPMessageTypeFlags = {
  FLAG_FILTER:                1,
  FLAG_PERSIST:               2,
  SMF_SMP_FLAG_TOPIC:         4,
  SMF_SMP_FLAG_RESPREQUIRED:  8,
  SMF_SMP_FLAG_DELIVERALWAYS: 16,
};

module.exports.SMFSMPMessageTypeFlags = Enum.new(SMFSMPMessageTypeFlags);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SMFTransportSessionMessageType = {
  CREATE:            0,
  CREATE_RESP:       1,
  DESTROY:           2,
  DESTROY_RESP:      3,
  DATA:              4,
  DATA_TOKEN:        5,
  DATA_STREAM_TOKEN: 6,
};

module.exports.SMFTransportSessionMessageType = Enum.new(SMFTransportSessionMessageType);


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/**
 * This callback is called by a cache session when a cache request
 * completes.
 *
 * @callback solace.CacheCBInfo.cacheRequestCallback
 * @function
 * @param {Number} requestID The ID of the request on which the event is notified.
 * @param {solace.CacheRequestResult} result The result of the cache request.
 * @param {Object} userObject The user object provided.
 */


/**
 * @classdesc
 * Encapsulates a {@link solace.CacheSession}'s request listener callback function and
 * optional application-specified context object.
 *
 * Instances of this class are required as a parameter to
 * {@link solace.CacheSession#sendCacheRequest} when creating a CacheSession request.
 *
 * @memberof solace
 */
var CacheCBInfo = function CacheCBInfo(cacheCBFunction, userObject) {
  /**
   * The function that will be called by the cache session when a request
   * completes.
   * @type {solace.CacheCBInfo.cacheRequestCallback}
   */
  this.cacheCBFunction = cacheCBFunction;

  /**
   * The user context object that will be supplied to the callback function
   * when the cache request completes.
   * @type {object}
   */
  this.userObject = userObject;
};

/**
 * @returns {solace.CacheCBInfo.cacheRequestCallback} The callback function
 * @private
 */
CacheCBInfo.prototype.getCallback = function getCallback () {
  return this.cacheCBFunction;
};

/**
 * @returns {*} The user context object, if any
 * @private
 */
CacheCBInfo.prototype.getUserObject = function getUserObject () {
  return this.userObject;
};

module.exports.CacheCBInfo = CacheCBInfo;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * solace.CacheLiveDataAction
 * Enumeration of CacheLiveDataAction values, specifying how the CacheSession should handle
 * live data associated with a cache request in progress.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheLiveDataAction = {
  /**
   * @type {Number}
   * @description End the cache request when live data arrives that matches the topic.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
  FULFILL:   1,
  /**
   * @type {Number}
   * @description Queue arriving live data that matches the topic, until the cache request
   * completes. Note that wildcard cache requests must always be {@link
   * solace.CacheLiveDataAction.FLOW_THRU}.
   */
  QUEUE:     2,
  /**
   * @type {Number}
   * @description Continue the outstanding cache request while allowing live data to flow through to
   * the application.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
  FLOW_THRU: 3,
};

module.exports.CacheLiveDataAction = Enum.new(CacheLiveDataAction);


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. A CacheRequestResult object is
 * provided on the callback (see {@link solace.CacheCBInfo.cacheRequestCallback} when a cache
 * request completes.</b>
 *
 * An object that indicates the termination of a cache request, and provides details how it
 * concluded.
 * @memberof solace
 * @hideconstructor
 */
var CacheRequestResult = function CacheRequestResult(rc, subcode, topic, error) {
  this._returnCode = rc;
  this._subcode = subcode;
  this._topic = topic;
  this._error = error;
};

/**
 * Gets the return code from the cache request result.
 *
 * @returns {solace.CacheReturnCode} The return code associated with the result of
 * the request.
 */
CacheRequestResult.prototype.getReturnCode = function getReturnCode () {
  return this._returnCode;
};

/**
 * Gets the return subcode from the cache request result.
 *
 * @returns {solace.CacheReturnSubcode} A subcode that gives more detail than
 * {@link CacheRequestResult#getReturnCode} about the result of the request.
 */
CacheRequestResult.prototype.getReturnSubcode = function getReturnSubcode () {
  return this._subcode;
};

/**
 * Gets the topic object associated with the cache request.
 *
 * @returns {solace.Destination} The topic destination supplied for the cache request.
 */
CacheRequestResult.prototype.getTopic = function getTopic () {
  return this._topic;
};


/**
 * Gets the error, if any, associated with the returned result.
 *
 * @returns {String} The error associated with the returned result.
 */
CacheRequestResult.prototype.getError = function getError () {
  return this._error;
};

module.exports.CacheRequestResult = CacheRequestResult;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(81);
var CacheContext = ref.CacheContext;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;

var CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;

/**
 * @private
 */
var CacheRequest = function CacheRequest(cacheSession, cacheMessageType, requestID, cbInfo, liveDataAction, topic, cacheName) {
  this.cacheSession = cacheSession;
  this.cacheMessageType = cacheMessageType;
  this.requestID = requestID;
  this.cbInfo = cbInfo;
  this.liveDataAction = liveDataAction;
  this.topic = topic;
  this.cacheName = cacheName;

  this.subscriptionWaiting = null;
  this.replyReceived = false;
  this.dataReceived = false;
  this.isSuspect = false;

  this.correlationID = "" + CACHE_REQUEST_PREFIX + (CacheContext.cacheRequestCorrelationId++);

  this.childRequests = [];
  this.parentRequest = null;

  this.queuedLiveData = [];
  this.liveDataFulfilled = false;

  this.timeoutHandle = null;
};

/**
 * @returns {CacheRequest} The root cache request in the current request tree
 * @private
 */
CacheRequest.prototype.getRootRequest = function getRootRequest () {
  if (!this.parentRequest) {
    return this;
  }
  return this.parentRequest.getRootRequest();
};

/**
 * @param {CacheRequest} childIn A request to make a descendant of this node in the request tree
 * @private
 */
CacheRequest.prototype.addChild = function addChild (childIn) {
  if (!(childIn instanceof CacheRequest)) {
    throw new Error(("Invalid child " + childIn));
  }
  if (childIn === this) {
    throw new Error('Constructing circular child reference');
  }
  var child = childIn;
  child.parentRequest = this;
  this.childRequests.push(child);
};

/**
 * @param {CacheRequest} childIn A request to remove as a descendant of this node
 * @private
 */
CacheRequest.prototype.removeChild = function removeChild (childIn) {
  if (childIn === this) {
    throw new Error('Attempting to deconstruct invalid circular child reference');
  }
  var child = childIn;
  var childIndex = this.childRequests.indexOf(child);
  if (childIndex === -1) {
    /* #stripped LOG_DEBUG(`Child ${child} not found in ${this}`) */

  }
  this.childRequests.splice(childIndex, 1);
  child.parentRequest = null;
};

/**
 * @private
 */
CacheRequest.prototype.collapse = function collapse () {
  var parentRequest = this.parentRequest;
  parentRequest.isSuspect = parentRequest.isSuspect || this.isSuspect;
  parentRequest.dataReceived = parentRequest.dataReceived || this.dataReceived;
  parentRequest.removeChild(this);
};

/**
 * @private
 */
CacheRequest.prototype.cancel = function cancel () {
    var this$1 = this;

  if (this.parentRequest) {
    this.collapse();
  }

  while (this.childRequests.length) {
    var child = this$1.childRequests.shift();
    if (child.childRequests) {
      child.cancel();
    }
    this$1.removeChild(child);
  }

  this.clearRequestTimeout();
};

/**
 * @returns {Number} The ID of this request
 * @private
 */
CacheRequest.prototype.getRequestID = function getRequestID () {
  return this.requestID;
};


/**
 * @returns {CacheCBInfo} The callback object for this request
 * @private
 */
CacheRequest.prototype.getCBInfo = function getCBInfo () {
  return this.cbInfo;
};

/**
 * @returns {Topic} The topic for this request
 * @private
 */
CacheRequest.prototype.getTopic = function getTopic () {
  return this.topic;
};


/**
 * @returns {CacheLiveDataAction} The live data action for this request
 * @private
 */
CacheRequest.prototype.getLiveDataAction = function getLiveDataAction () {
  return this.liveDataAction;
};

/**
 * @param {function({solace.CacheRequest})} cacheSessionTimeoutCB Callback to notify on timeout
 * @param {Number} timeoutMsec Timeout in milliseconds
 * @private
 */
CacheRequest.prototype.startRequestTimeout = function startRequestTimeout (cacheSessionTimeoutCB, timeoutMsec) {
    var this$1 = this;

  this.timeoutHandle = setTimeout(function () {
    cacheSessionTimeoutCB(this$1);
  }, timeoutMsec);
};

/**
 * @private
 */
CacheRequest.prototype.clearRequestTimeout = function clearRequestTimeout () {
  if (this.timeoutHandle === null || this.timeoutHandle === undefined) {
    return;
  }

  /* #stripped LOG_DEBUG(`Clearing timeout for ${this}`) */

  clearTimeout(this.timeoutHandle);
  this.timeoutHandle = null;
};

/**
 * Returns a string representing the request.
 * @returns {String} A brief description of this object
 */
CacheRequest.prototype.toString = function toString () {
  return ("CacheRequest[correlationID=" + (this.correlationID) + ",requestID=" + (this.requestID) + ",cacheName=" + (this.cacheName) + ",topic=" + (this.topic.getName()) + "]");
};

/**
 * @private
 */
CacheRequest.VERSION = 1;

/**
 * @private
 */
CacheRequest.DEFAULT_REPLY_SIZE_LIMIT = 1000000;

/**
 * @private
 */
CacheRequest.REPLY_SIZE_LIMIT = CacheRequest.DEFAULT_REPLY_SIZE_LIMIT;

module.exports.CacheRequest = CacheRequest;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of CacheReturnCode types.  The method {@link solace.CacheRequestResult#getReturnCode}
 * returns on of these basic results of a cache request.  More details are available in the
 * associated {@link solace.CacheReturnSubcode}, retrieved by
 * {@link solace.CacheRequestResult#getReturnSubcode}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheReturnCode = {
  /**
   * @type {Number}
   * @description The cache request succeeded.  See the subcode for more information.
   */
  OK:         1,
  /**
   * @type {Number}
   * @description The cache request was not processed.  See the subcode for more information.
   */
  FAIL:       2,
  /**
   * @type {Number}
   * @description The cache request was processed but could not be completed.  See the subcode for
   * more information.
   */
  INCOMPLETE: 3,
};

module.exports.CacheReturnCode = Enum.new(CacheReturnCode);


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of CacheReturnSubcode types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
var CacheReturnSubcode = {
  /**
   * @type {Number}
   * @description
   * The cache request completed successfully.
   */
  REQUEST_COMPLETE:            0,
  /**
   * @type {Number}
   * @description
   * The cache request completed when live data arrived on the topic requested.
   */
  LIVE_DATA_FULFILL:           1,
  /**
   * @type {Number}
   * @description
   * The cache instance or session returned an error response to the cache request.
   */
  ERROR_RESPONSE:              2,
  /**
   * @type {Number}
   * @description
   * The cache request failed because the {@link Session} used to construct it has been
   * disposed.
   */
  INVALID_SESSION:             3,
  /**
   * @type {Number}
   * @description
   * The cache request failed because the request timeout expired.
   */
  REQUEST_TIMEOUT:             4,
  /**
   * @type {Number}
   * @description
   * The cache request was made on the same topic as an existing request, and
   * {@link CacheLiveDataAction.FLOW_THRU} was not set.
   */
  REQUEST_ALREADY_IN_PROGRESS: 5,
  /**
   * @type {Number}
   * @description
   * The cache reply returned no data.
   */
  NO_DATA:                     6,
  /**
   * @type {Number}
   * @description
   * The cache reply returned suspect data.
   */
  SUSPECT_DATA:                7,
  /**
   * @type {Number}
   * @description
   * The request was terminated because the cache session was disposed.
   */
  CACHE_SESSION_DISPOSED:      8,
  /**
   * @type {Number}
   * @description
   * The request was terminated because the subscription request for the specified topic failed.
   */
  SUBSCRIPTION_ERROR:          9,
};

module.exports.CacheReturnSubcode = Enum.new(CacheReturnSubcode);


/***/ }),
/* 138 */
/***/ (function(module, exports) {

/**
 * @classdesc
 *
 * Encapsulates the properties of a cache session.
 *
 * @memberof solace
 *
 */
var CacheSessionProperties = function CacheSessionProperties(cacheName, maxAgeSec, maxMessages, timeoutMsec) {
  /**
   * @type {String}
   *
   * @description A property that specifies the cache name to which CacheSession operations should
   * be sent.
   */
  this.cacheName = cacheName;

  /**
   * @type {Number}
   *
   * @description The maximum allowable message age in seconds to deliver in response to cache
   * requests.0 means no restriction on age.
   *
   * @default 0
   */
  this.maxAgeSec = maxAgeSec || 0;

  /**
   * @type {Number}
   *
   * @description The maximum number of messages per Topic to deliver in response to cache
   * requests.0 means no restriction on the number of messages.
   *
   * @default 1
   */
  this.maxMessages = (maxMessages === null || maxMessages === undefined) ? 1 : maxMessages;

  /**
   * @type {Number}
   *
   * @description The timeout for a cache request, in milliseconds.The valid range for this
   * property is >= 3000.
   *
   * @default 10000
   */
  this.timeoutMsec = timeoutMsec || 10000;

  /**
   * @private
   * @type {Boolean}
   * @description Whether to include other clusters in the request.
   * @default true
   */
  this.includeOtherClusters = true;

  /**
   * @private
   */
  this.cachePrefix = '#P2P/CACHEINST/';
};

/**
 * Gets the cache name to which {@link solace.CacheSession} requests should be sent, for
 * sessions constructed using these properties.
 *
 * @returns {String} The cache name.
 */
CacheSessionProperties.prototype.getCacheName = function getCacheName () {
  return this.cacheName;
};

/**
 * Sets the cache name to which requests should be sent. Cannot be null or blank.
 * @param {String} value The cache name to which requests should be sent.
 */
CacheSessionProperties.prototype.setCacheName = function setCacheName (value) {
  this.cacheName = value;
};

/**
 * Gets the maximum allowable message age for messages to be delivered in response to a request
 * made on a {@link solace.CacheSession} that was constructed using these properties.0 means no
 * restriction on age.
 *
 * @returns {Number} The maximum allowable message age to be returned by an associated {@link
 * solace.CacheSession}, or 0 for no restriction.
 */
CacheSessionProperties.prototype.getMaxMessageAgeSec = function getMaxMessageAgeSec () {
  return this.maxAgeSec;
};

/**
 * Sets the maximum allowable message age. 0 means no restriction on age.
 *
 * @param {Number} value The maximum allowable message age, or 0 for no restriction.
 */
CacheSessionProperties.prototype.setMaxMessageAgeSec = function setMaxMessageAgeSec (value) {
  this.maxAgeSec = value;
};

/**
 * Gets the maximum count of messages to be delivered, per {@link solace.Destination}, in
 * response to a request issued on a {@link solace.CacheSession} constructed using these
 * properties.0 means no restriction on the number of messages.
 *
 * @returns {Number} The maximum number of messages per Topic to deliver, or 0 for no restriction.
 */
CacheSessionProperties.prototype.getMaxMessages = function getMaxMessages () {
  return this.maxMessages;
};

/**
 * Sets the maximum count of messages to be delivered per {@link solace.Destination} in response
 * to a cache request. 0 means no restriction.
 *
 * @param {Number} value The maximum count of messages to deliver, or 0 for no restriction.
 */
CacheSessionProperties.prototype.setMaxMessages = function setMaxMessages (value) {
  this.maxMessages = value;
};

/**
 * Gets the timeout for requests issued on a {@link solace.CacheSession} constructed
 * using these properties.
 ** The valid range is >= 3000.
 *
 * @returns {Number} The timeout, in milliseconds, for cache session requests.
 */
CacheSessionProperties.prototype.getTimeoutMsec = function getTimeoutMsec () {
  return this.timeoutMsec;
};

/**
 * Sets the timeout for requests.
 ** The valid range is >= 3000.
 * @param {Number} value The timeout for requests.
 */
CacheSessionProperties.prototype.setTimeoutMsec = function setTimeoutMsec (value) {
  this.timeoutMsec = value;
};

module.exports.CacheSessionProperties = CacheSessionProperties;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(286);
var SolclientSessionLib = __webpack_require__(21);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_WARN = ref$1.LOG_WARN;

/**
 * Node TLS socket option generation factored out from WS transport, shared with Tcp transport.
 * Internal mixin class, not intended to be publicly visible.
 * @private
 */

var NodeTLSOptsMixin = function NodeTLSOptsMixin () {};

NodeTLSOptsMixin.prototype.checkCertificateCNs = function checkCertificateCNs (host, cert) {
  if (this._props.sslTrustedCommonNameList && this._props.sslTrustedCommonNameList.length > 0) {
    // no Closure Compiler externs for certificates
    /* #stripped LOG_DEBUG('server cert:', cert) */

    var subject = cert['subject']; // eslint-disable-line dot-notation
    var valid = false;
    if (subject) {
      var cn = subject['CN']; // eslint-disable-line dot-notation
      valid = this._props.sslTrustedCommonNameList.some(function (name) { return name.toLowerCase() === cn.toLowerCase(); }
      );
    }
    if (!valid) {
      var error = new Error('Server certificate not trusted - no common name match');
      error.reason = 'Server certificate not trusted - no common name match';
      error.host = host;
      error.cert = cert;
      return error;
    }
  }
  return undefined;
};

/**
 * Create the TLS options object used in wss:// and tcps:// connection establishment.
 * The same options are needed by the ws and tls socket constructors.
 * @returns {Object} WebSocket/TLSSocket options object
 * @private
 */
NodeTLSOptsMixin.prototype.createTLSOptions = function createTLSOptions () {
  /* eslint-disable dot-notation */
  var props = this._props;
  var options = {};
  var useClientCert = (
    props.authenticationScheme === SolclientSessionLib.AuthenticationScheme.CLIENT_CERTIFICATE
  );

  // available tls options:
  //pfx, key, passphrase, cert, ca, ciphers, rejectUnauthorized,
  //secureProtocol, secureOptions, checkServerIdentity

  // default to allow all version of SSL during negotiation but exclude SSLv2 and SSLv3
  options['secureProtocol'] = 'SSLv23_method';
  var constMap = SolclientSessionLib.SessionProperties.SslProtocolExcludeConstantMap;
  options['secureOptions'] = constMap['sslv2'] | constMap['sslv3'];
  (props.sslExcludedProtocols || []).forEach(function (protocol) {
    options['secureOptions'] |= constMap[protocol.toLowerCase()];
  });

  if (props.sslCipherSuites) {
    var ciphers = props.sslCipherSuites.split(',');
    var trimmed = ciphers.map(function (cipher) { return cipher.trim(); });
    options['ciphers'] = trimmed.join(':');
  } else {
    options['ciphers'] = props.sslCipherSuites;
  }

  options['rejectUnauthorized'] = props.sslValidateCertificate;

  // only set checkServerIdentity callback if rejectUnauthorized
  if (options['rejectUnauthorized'] && Array.isArray(props.sslTrustedCommonNameList)) {
    options['checkServerIdentity'] = this.checkCertificateCNs.bind(this);
  }

  // only set trust stores and and checkServerIdentity callback
  // if rejectUnauthorized is true or authClientCert
  if ((options['rejectUnauthorized'] || useClientCert) &&
    props.sslTrustStores && props.sslTrustStores.length) {
    var tsContents = [];
    props.sslTrustStores.forEach(function (tsFile) {
      try {
        tsContents.push(fs.readFileSync(tsFile));
      } catch (e) {
        LOG_WARN(("Failed to load trust store " + tsFile), e.message);
        /* #stripped LOG_TRACE('Error details:', e.stack || e) */

        throw new OperationError(("Failed to load trust store " + tsFile),
          ErrorSubcode.FAILED_LOADING_TRUSTSTORE,
          e);
      }
    });
    options['ca'] = tsContents;
  }


  if (useClientCert) {
    if (props.sslPfx) {
      try {
        options['pfx'] = fs.readFileSync(props.sslPfx);
        options['passphrase'] = props.sslPfxPassword;
      } catch (e) {
        LOG_WARN(("Failed to load pfx file " + (props.sslPfx)), e.message);
        /* #stripped LOG_TRACE('Error details:', e.stack || e) */

        throw new OperationError(("Failed to load pfx " + (props.sslPfx)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
    if (props.sslPrivateKey) {
      try {
        options['key'] = fs.readFileSync(props.sslPrivateKey);
        options['passphrase'] = props.sslPrivateKeyPassword;
      } catch (e) {
        LOG_WARN(("Failed to load private key " + (props.sslPrivateKey)), e.message);
        /* #stripped LOG_TRACE('Error details:', e.stack || e) */

        throw new OperationError(("Failed to load private key " + (props.sslPrivateKey)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
    if (props.sslCertificate) {
      try {
        options['cert'] = fs.readFileSync(props.sslCertificate);
      } catch (e) {
        LOG_WARN(("Failed to load certificate file " + (props.sslCertificate)), e.message);
        /* #stripped LOG_TRACE('Error details:', e.stack || e) */

        throw new OperationError(("Failed to load certificate " + (props.sslCertificate)),
          ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
      }
    }
  }
  return options;
  /* eslint-enable dot-notation */
};

module.exports.NodeTLSOptsMixin = NodeTLSOptsMixin;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;

var SMFClient = (function () {
  if (typeof navigator !== 'undefined') {
    /* eslint-env browser */
    if (navigator.appVersion.indexOf('MSIE 9.') !== -1) {
      return __webpack_require__(238).StringSMFClient;
    }
  }
  /* eslint-env shared-browser-node */
  return __webpack_require__(237).BufferSMFClient;
})();

SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG = BaseSMFClient.SMF_MAX_CORRELATION;

module.exports.SMFClient = SMFClient;


/***/ }),
/* 141 */
/***/ (function(module, exports) {

/**
 * @private
 * @constructor
 */
var TransportClientStats = function TransportClientStats() {
  this.bytesWritten = 0;
  this.msgWritten = 0;
};

module.exports.TransportClientStats = TransportClientStats;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var ref = __webpack_require__(3);
var Convert = ref.Convert;
var Base64 = ref.Base64;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var LOG_WARN = ref$1.LOG_WARN;
var LOG_ERROR = ref$1.LOG_ERROR;
var ref$2 = __webpack_require__(245);
var sendXhrBinary = ref$2.sendXhrBinary;
var sendXhrText = ref$2.sendXhrText;
var ref$3 = __webpack_require__(4);
var StringBuffer = ref$3.StringBuffer;
var TimingBucket = ref$3.TimingBucket;
var ref$4 = __webpack_require__(17);
var TransportReturnCode = ref$4.TransportReturnCode;
var ref$5 = __webpack_require__(143);
var XHRFactory = ref$5.XHRFactory;

var arrayBufferToString = Convert.arrayBufferToString;

var SOL_CONNECTION_DEBUG = false;

/**
 * A URI starting with a "/" is a "path-absolute" URI, and those aren't
 * allowed to have a query component (starting with "?").
 *
 * If an origin isn't defined in the url, tack on the one from the page.
 *
 * @param {URL} url The URL to connect to
 * @returns {URL} Adjusted URL if incoming URL was relative
 * @private
 */
function prependOrigin(url) {
  if (!url.match(/^(http|ws)(s?):/i) && window.location && window.location.origin) {
    return window.location.origin + ((url.charAt(0) !== '/') ? '/' : '') + url;
  }
  return url;
}

function getTs() {
  return new Date().getTime();
}

var Stats = function Stats() {
  this.WaitedToken = new TimingBucket('WaitedToken', 100);
  this.HadToken = new TimingBucket('HadToken', 100);
  this.ReturnedToken = new TimingBucket('ReturnedToken', 100);
};
Stats.prototype.toString = function toString () {
  var s = '';
  [this.WaitedToken, this.HadToken, this.ReturnedToken].forEach(function (b) {
    if (b && b.bucketCount() > 0) {
      s += (b.name) + " >> " + b + "\n";
    }
  });
  return s;
};

/**
 * @classdesc
 * This class contains all state for a single HTTP connection (XHR).
 *
 * @private
 */
var HTTPConnection = function HTTPConnection(url, base64Enc, streamProgressEvents, rxDataCb,
            connectionErrorCb, contentType, connectionClose) {
  this.Options = {
    url: prependOrigin(url),
    contentType: contentType,
    base64Enc: base64Enc,
    streamProgressEvents: streamProgressEvents,
    connectionClose: connectionClose,
  };

  this._streamProgressBytes = 0;
  this._xhr = null;
  this._rxDataCb = rxDataCb;
  this._connErrorCb = connectionErrorCb;
  this._reqActive = false;
  this._REQCOUNTER = 0;
  this._REQBASE = Math.floor(Math.random() * 1000);

  this._xhr = XHRFactory.create();
  // older browser ie9
  this._handleAbortedReq = !HTTPConnection.browserSupportsXhrBinary();

  this.stats = new Stats();
};

HTTPConnection.prototype.recStat = function recStat (s) {
  if (!SOL_CONNECTION_DEBUG) {
    return;
  }
  var stats = this.stats;
  if (s === 'GotToken') {
    stats.LastGotToken = getTs();
    if (stats.LastSendMsg) {
      var waitedTok = stats.LastGotToken - stats.LastSendMsg;
      stats.WaitedToken.log(waitedTok);
      if (waitedTok > 100) {
        LOG_WARN(("Abnormally long waitToken, last request: " + (this._REQBASE) + "_" + (this._REQCOUNTER)));
      }
    }
  }
  if (s === 'SendMsg') {
    stats.LastSendMsg = getTs();
    var hadToken = stats.LastSendMsg - stats.LastGotToken;
    stats.HadToken.log(hadToken);
  }
  if (s === 'GotData') {
    stats.LastGotData = getTs();
  }
  if (s === 'ReturnToken') {
    stats.LastReturnToken = getTs();
    if (stats.LastGotData) {
      var returnedToken = stats.LastReturnToken - stats.LastGotData;
      stats.ReturnedToken.log(returnedToken);
    }
  }
};

/*
 * Send data over the connection - this requires a send token
 */
HTTPConnection.prototype.send = function send (data, attempt, maxRetry) {
    var this$1 = this;
    if ( attempt === void 0 ) attempt = 0;
    if ( maxRetry === void 0 ) maxRetry = 1;

  if (attempt > 0) {
    this._xhr.abort();
    this._xhr = XHRFactory.create();
  }
  this._xhr.open('POST', this.Options.url, true);

  this._streamProgressBytes = 0;
  // We pass the write data to the CB so we can retry when it mysteriously fails.
  this._xhr.onreadystatechange = function () { return this$1.xhrStateChange(data, attempt, maxRetry); };

  this._reqActive = true;

  if (SOL_CONNECTION_DEBUG) {
    this._REQCOUNTER++;
    this._xhr.setRequestHeader('sol-request-track', ((this._REQBASE) + "_" + (this._REQCOUNTER)));
  }
  if (this.Options.base64Enc) {
    sendXhrText(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
  } else {
    sendXhrBinary(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
  }
  this.recStat('SendMsg');
};


// XmlHTTPRequest Callback
HTTPConnection.prototype.xhrStateChange = function xhrStateChange (sentdata, attempt, maxRetry) {
  var readyState = this._xhr.readyState;
  var RS_LOADING = this._xhr.LOADING;
  var RS_DONE = this._xhr.DONE;

  if (!((this.Options.streamProgressEvents && readyState === RS_LOADING)
        || readyState === RS_DONE)) {
    // we proceed with notifications if we're LOADING and we requested streaming events,
    // or we're DONE.
    return;
  }

  if (!this._reqActive) {
        // request aborted, DO NOT propagate event
    return;
  }

  var status = null;
  if (this._handleAbortedReq) {
    // To avoid the following IE9 error when request is aborted by server or client and
    // application tries to access any property in the XHR other than readyState whose value is
    // 4 (XMLHTTPRequest.DONE):
    // - The data necessary to complete this operation is not yet available
    // See https://groups.google.com/forum/#!topic/websync/ysBEvtvMyb0 for details
    // _requestActive is used to handle client initiated abort, but it does not handle
    // the case when the request is aborted on the server side or proxy server
    try {
      status = this._xhr.status;
    } catch (e) {
      LOG_INFO(("Error trying to access status in XHR due to request aborted: " + (e.message)));
      return;
    }
  } else {
    status = this._xhr.status;
  }

  if (status === 200 || status === 304) {
    // Success status code
    var data = null;
    if (this._xhr.responseType && this._xhr.responseType === 'arraybuffer') {
      data = arrayBufferToString(this._xhr.response);
    } else {
      data = this._xhr.responseText;
    }
    data = data.substring(this._streamProgressBytes, data.length);
    this._streamProgressBytes += data.length;

    if (data.length === 0 && readyState === RS_LOADING) {
      // we are streaming LOADING events but have no data
      return;
    }

    if (this.Options.base64Enc) {
      try {
        data = Base64.decode(data);
      } catch (e) {
        // Failed the decode - call the error callback
        LOG_ERROR(("Data decode error on: " + data));
        LOG_ERROR(("Data decode error is: " + (e.message)));
        this._rxDataCb(TransportReturnCode.DATA_DECODE_ERROR, data);
        return;
      }
    } else {
      // take lower-8 bits
      var decodedData = [];
      var dataLength = data.length;
      for (var i = 0; i < dataLength; i++) {
        decodedData.push(String.fromCharCode(data.charCodeAt(i) & 0xFF));
      }
      data = decodedData.join('');
    }
    if (readyState === RS_DONE) {
      // MUST do this BEFORE the callback invocation, because the callback can trigger a new send.
      this._reqActive = false;
    }
    this._rxDataCb(TransportReturnCode.OK, data);
    if (readyState === RS_DONE && data.length > 0) {
      this._rxDataCb(TransportReturnCode.OK, ''); // indicate end of stream
    }

    return;
  }

  // Failure status code.
  var statusText = this._xhr.statusText;
  var responseText = '';
  if (this._xhr.responseType && this._xhr.responseType === 'arraybuffer') {
    responseText = arrayBufferToString(this._xhr.response);
  } else {
    responseText = this._xhr.responseText || '';
  }

  var responseTextLen = responseText.length;
  var requestUrl = this.Options.url;
  var sentdataLen = sentdata ? sentdata.length : 0;
  var ref = DebugLib.Debug;
    var formatDumpBytes = ref.formatDumpBytes;
  var responseTextDump = formatDumpBytes(
    responseText.substr(0, Math.min(responseTextLen, 64)), true, 0);
  var sentTextDump = formatDumpBytes(
    (sentdata || '').substr(0, Math.min(sentdataLen, 256)), true, 0);
  if (false) {
    var stmt = new StringBuffer(
      ("Http request failed.  url=" + requestUrl + ", status=" + status + ", statusText=" + statusText + ", "),
      ("responseText length=" + responseTextLen + ", "),
      'responseText (first 64 bytes or fewer)=\n',
      (responseTextDump + ", "),
      ("XHR errorCode=" + (this._xhr._error ? this._xhr._error.code : '') + ", "),
      ("attempt=" + attempt + ", reqActive=" + (this._reqActive) + ", readyState=" + readyState + ", "),
      ("sent data length=" + sentdataLen + ", "),
      'sent data (first 256 bytes or fewer)=\n',
      ("" + sentTextDump)).toString();
    /* #stripped LOG_DEBUG(stmt) */

  }

  var nextMaxRetry = maxRetry;
  if (this._reqActive
        && status !== 400
        && responseText.length === 0
        && (attempt === 0 || attempt < nextMaxRetry)) {
    /* #stripped LOG_DEBUG(`XHR failed while request active, will retry send, retry=${attempt + 1}`) */

      // RETRY (could be a transient browser connection problem)
    this.send(sentdata, attempt + 1, nextMaxRetry);
  } else {
    this._reqActive = false;
    this._connErrorCb(
        status,
        new StringBuffer(
          ("HTTP request failed(status=" + status + " statusText=" + statusText + ", "),
          ("responseText length=" + responseTextLen + ", responseText[0..64]=\n"),
          responseTextDump,
          ("XHR errorCode=" + (this._xhr._error ? this._xhr._error.code : '') + ")")).toString());
  }
};

HTTPConnection.prototype.isUsingBase64 = function isUsingBase64 () {
  return this.Options.base64Enc;
};

// This function will abort the current xhr request if it is active
HTTPConnection.prototype.abort = function abort () {
    // mark request as inactive, so we won't process statechange events
  this._reqActive = false;
  if (this._xhr && this._xhr.abort) {
    this._xhr.abort();
  }
};

/**
 * Check if we can try binary XHR on this browser.
 * @returns {Boolean} `true` if XHR binary should work; `false` otherwise
 * @static
 */
HTTPConnection.browserSupportsXhrBinary = function browserSupportsXhrBinary () {
  return sendXhrBinary !== sendXhrText;
};

/**
 * Check if browser supports streaming responses (progressive reading of XHR).
 * @returns {Boolean} `true` if feature was detected, `false` otherwise
 * @static
 */
HTTPConnection.browserSupportsStreamingResponse = function browserSupportsStreamingResponse () {
  var xhr = XHRFactory.create();
  // A conforming XHR2 implementation must include progress events.
  // Can we assume that the event property will be null instead of undefined?
  // A conforming XHR2 implementation must also include withCredentials.
  var check = xhr && xhr.onprogress === null; // xhr.withCredentials === false;
  /* #stripped LOG_DEBUG(`http browserStreamingCheck - if XMLHTTPRequest supported and XMLHTTPRequest support onprogress: ${check}`) */

  return check;
};

module.exports.HTTPConnection = HTTPConnection;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(33);
var TransportError = ref$1.TransportError;

/* eslint-env browser */
var XHRFactory = {
  /**
   * Creates an XHR object.
   *
   * @param {Boolean} [allowFail=false] If `true`, return null on failure; otherwise throw.
   * @throws {TransportError}
   * @returns {XMLHttpRequest} The new XHR object
   */
  create: function create(allowFail) {
    if ( allowFail === void 0 ) allowFail = false;

    var xhr = typeof XMLHttpRequest !== 'undefined' ? new XMLHttpRequest() : null;
    if (!allowFail && !xhr) {
      throw new TransportError('Failed to create an XMLHTTPRequest',
                                 ErrorSubcode.CREATE_XHR_FAILED);
    }
    return xhr;
  },
};

module.exports.XHRFactory = XHRFactory;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * Enumeration of Web Transport events.
 * @enum {string}
 * @namespace
 * @memberof solace
 * @private
 */
var WebTransportEvent = {
  /**
   * The Session Layer has issued a connect request
   */
  CONNECT:          'Connect',
  /**
   * The Session Layer has issued a destroy request
   */
  DESTROY:          'Destroy',
  /**
   * A downgrade request has been received from an FSM.
   */
  DOWNGRADE:        'Downgrade',
  /**
   * The underlying transport has been destroyed. Seen in
   * response to calling destroy() and in some cases when
   * the transport is destroyed by the peer.
   */
  DESTROYED_NOTICE: 'DestroyedNotice',
  /**
   * The underlying transport timed out in its connection attempt.
   * The managing component should abort this connection attempt
   * and begin a downgrade if available.
   */
  CONNECT_TIMEOUT:  'ConnectTimeout',
  /**
   * The underlying transport is active and ready for traffic.
   */
  UP_NOTICE:        'UpNotice',
  /**
   * The transport encountered an error sending data.
   */
  SEND_ERROR:       'SendError',
};

module.exports.WebTransportEvent = Enum.new(WebTransportEvent);


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_TRACE = ref.LOG_TRACE;
var ref$1 = __webpack_require__(46);
var TransportBase = ref$1.TransportBase;
var ref$2 = __webpack_require__(141);
var TransportClientStats = ref$2.TransportClientStats;
var ref$3 = __webpack_require__(17);
var TransportReturnCode = ref$3.TransportReturnCode;
var ref$4 = __webpack_require__(34);
var TransportSessionState = ref$4.TransportSessionState;

var MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS = 4000;

/**
 * Base class for web related transports
 * @extends TransportBase
 * @private
 */
var WebTransportSessionBase = (function (TransportBase) {
  function WebTransportSessionBase(url, eventCB, client, props) {
    // instanitate instance properties defined in TransportBase
    TransportBase.call(this, url, eventCB, client, props);

    /**
     * @type {Number}
     */
    this._connectTimeout = props.transportDowngradeTimeoutInMsecs;

    /**
     * @type {?number}
     */
    this._connectTimer = null;

    /**
     * @type {TransportClientStats}
     */
    this._clientstats = new TransportClientStats();

    /**
     * Maximum amount of send data than can be queued
     * @type {Number}
     */
    this._sendBufferMaxSize = props.sendBufferMaxSize;

    /**
     * Maximum payload chunk size in web transport
     * @type {Number}
     */
    this._maxPayloadBytes = props.maxWebPayload;

    /**
     * Queue to hold data to be sent to the Solace Message Router when we get back a
     * data token
     * @type {array}
     */
    this._queuedData = [];

    /**
     * Number of bytes of queued data
     * @type {Number}
     */
    this._queuedDataSize = 0;

    /**
     * Remember if we have to send an event when there is room in the queue
     * @type {Boolean}
     */
    this._canSendNeeded = false;

    /**
     * @type {TransportSessionState}
     */
    this._state = TransportSessionState.DOWN;

    /**
     * Any connection error that needs to be propagated up
     * @type {?Error}
     */
    this._connError = null;
  }

  if ( TransportBase ) WebTransportSessionBase.__proto__ = TransportBase;
  WebTransportSessionBase.prototype = Object.create( TransportBase && TransportBase.prototype );
  WebTransportSessionBase.prototype.constructor = WebTransportSessionBase;

  // override
  WebTransportSessionBase.prototype.getClientStats = function getClientStats () {
    return this._clientstats;
  };

  WebTransportSessionBase.prototype.createConnectTimeout = function createConnectTimeout () {
    var this$1 = this;

    if (this._connectTimeout > 0) {
      this._connectTimer = setTimeout(function () {
        this$1.connectTimerExpiry();
      }, this._connectTimeout);
    }
  };

  WebTransportSessionBase.prototype.cancelConnectTimeout = function cancelConnectTimeout () {
    if (this._connectTimer) {
      clearTimeout(this._connectTimer);
      this._connectTimer = null;
    }
  };

  /* override me */
  WebTransportSessionBase.prototype.connectTimerExpiry = function connectTimerExpiry () { // eslint-disable-line class-methods-use-this
    return undefined;
  };

  WebTransportSessionBase.prototype.allowEnqueue = function allowEnqueue (datalen) {
      // Bug 32006: if there's no queued data, we always accept at least one message, even if it
      // exceeds the sendBufferMaxSize.
      // If we reject enqueueing something too large because we already have queued data,
      // that guarantees when the data is flushed we will emit the alertOnDequeue event.
    return (this._queuedDataSize === 0 ||
            ((datalen + this._queuedDataSize) <= this._sendBufferMaxSize));
  };

  WebTransportSessionBase.prototype.enqueueFailNoSpace = function enqueueFailNoSpace () {
    this._canSendNeeded = true;
    return TransportReturnCode.NO_SPACE;
  };

  /* override me */
  WebTransportSessionBase.prototype.flush = function flush (callback) { // eslint-disable-line class-methods-use-this
    callback();
  };

  WebTransportSessionBase.prototype.getQueuedDataToSend = function getQueuedDataToSend () {
    var this$1 = this;

    // Track messages dequeued.
    var data = '';

    // Start by trying to fill a complete payload.
    var bytesAllowed = this._maxPayloadBytes;
    /* #stripped LOG_TRACE(`getQueuedDataToSend: bytesAllowed=${bytesAllowed}, bufferedAmount=${this.getBufferedAmount ? this.getBufferedAmount() : 'undefined'}`) */

    if (this.getBufferedAmount) {
      bytesAllowed = this._maxPayloadBytes - this.getBufferedAmount();
      if (bytesAllowed <= 0) {
        /* #stripped LOG_DEBUG(`$$ bytesAllowed=${bytesAllowed}, maxPayloadBytes=${this._maxPayloadBytes
                  }, bufferedAmount=${this.getBufferedAmount()}`) */

        if (false) {
          this._bufferedAmountQueryIntervalDelayMultiplier *= 2;
        }
        return data;
      }
      if (false) {
        this._bufferedAmountQueryIntervalDelayMultiplier = 1;
      }
    }

    if (this._queuedDataSize > bytesAllowed) {
      var payloadSize = bytesAllowed;
      // Slow path: dequeue and append until we fill the payload.
      while (payloadSize && this._queuedDataSize) {
        // Is this element larger than the payload?
        var elem = this$1._queuedData[0];
        var elemLength = elem.length;
        if (elemLength > payloadSize) {
          // This element is larger than the payload.
          data += elem.substr(0, payloadSize);
          this$1._queuedData[0] = elem.substr(payloadSize);

          // The rest of the payload space was consumed.
          this$1._queuedDataSize -= payloadSize;
          payloadSize = 0;
        } else {
          data += this$1._queuedData.shift();
          payloadSize -= elemLength;
          this$1._queuedDataSize -= elemLength;
          this$1._clientstats.msgWritten++;
        }
      }
    } else {
      // Shortcut: use the whole buffer, increase the message sent count by the length of the size
      // queue, and reset the buffer.
      data = this._queuedData.join('');
      this._clientstats.msgWritten += this._queuedData.length;

      this._queuedData = [];
      this._queuedDataSize = 0;
    }

    /* #stripped LOG_DEBUG(`Sending ${data.length} bytes from queued data`) */

    return data;
  };

  return WebTransportSessionBase;
}(TransportBase));

module.exports.WebTransportSessionBase = WebTransportSessionBase;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var SolclientFactoryLib = __webpack_require__(9);
var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var LOG_DEBUG = ref.LOG_DEBUG;
var LOG_WARN = ref.LOG_WARN;
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(4);
var ArrayUtils = ref$1.ArrayUtils;
var ref$2 = __webpack_require__(3);
var Convert = ref$2.Convert;
var Hex = ref$2.Hex;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var ref$4 = __webpack_require__(0);
var mixin = ref$4.mixin;
var ref$5 = __webpack_require__(33);
var TransportError = ref$5.TransportError;
var ref$6 = __webpack_require__(17);
var TransportReturnCode = ref$6.TransportReturnCode;
var ref$7 = __webpack_require__(47);
var TransportSessionEvent = ref$7.TransportSessionEvent;
var ref$8 = __webpack_require__(24);
var TransportSessionEventCode = ref$8.TransportSessionEventCode;
var ref$9 = __webpack_require__(34);
var TransportSessionState = ref$9.TransportSessionState;
var ref$10 = __webpack_require__(253);
var WebSocketCloseCodes = ref$10.WebSocketCloseCodes;
var ref$11 = __webpack_require__(145);
var WebTransportSessionBase = ref$11.WebTransportSessionBase;

var stringToArrayBuffer = Convert.stringToArrayBuffer;
var formatHexString = Hex.formatHexString;
var includes = ArrayUtils.includes;

/* eslint-env browser */
// closure mangles window.WebSocket
var globalContext = (typeof window === 'undefined' ? global : window);
var MyWebSocket = globalContext.WebSocket;
if (true) {
  /* eslint-disable no-global-assign */
  /* eslint-disable global-require */
  MyWebSocket = /** @type {WebSocket} */ (__webpack_require__(292));
  /* eslint-enable no-global-assign */
  /* eslint-enable global-require */
}
/* eslint-env shared-browser-node */

function adaptURL(url) {
  var v = url.match(/(ws|http)(s?:\/\/.+)/);
  return ("ws" + (v[2]));
}


/**
 * @classdesc
 * @private
 * @memberof solace
 */
var WebSocketTransportSession = (function (WebTransportSessionBase) {
  function WebSocketTransportSession(url, eventCB, client, props) {
    WebTransportSessionBase.call(this, url, eventCB, client, props);
    /**
     * @type {String}
     */
    this._url = adaptURL(url);

    /**
     * @type {?WebSocket}
     */
    this._socket = null;

    /**
     * @type {?string}
     */
    this._sessionId = new Date().getTime();

    if (false) {
      /**
       * @type {Number}
       */
      this._bufferedAmountQueryIntervalInMsecs = props.bufferedAmountQueryIntervalInMsecs;
      /**
       * @type {?number}
       */
      this._bufferedAmountQueryTimer = null;
      /**
       * @type {Number}
       */
      this._bufferedAmountQueryIntervalDelayMultiplier = 1;
    }
  }

  if ( WebTransportSessionBase ) WebSocketTransportSession.__proto__ = WebTransportSessionBase;
  WebSocketTransportSession.prototype = Object.create( WebTransportSessionBase && WebTransportSessionBase.prototype );
  WebSocketTransportSession.prototype.constructor = WebSocketTransportSession;


  /**
   * @private
   */
  WebSocketTransportSession.prototype.onOpen = function onOpen () {
    this.cancelConnectTimeout();
    this._state = TransportSessionState.SESSION_UP;
      // Send the event to the application letting it know that the session is up
    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.UP_NOTICE,
              'Connected',
              0,
              null,
              this._sessionId));
  };

  /**
   * @param {Event} event The websocket event causing the close
   * @private
   */
  WebSocketTransportSession.prototype.onClose = function onClose (event) {
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_TRACE('WebSocket transport is being destroyed, ignore error') */

      return;
    }
    var msgBuf = [];
    var code = WebSocketCloseCodes[event.code] || WebSocketCloseCodes[0];
    msgBuf.push(((event.code) + " " + (code.name) + " (" + (code.description) + ")"));
    if (event.wasClean !== undefined) {
      msgBuf.push(("clean closure: " + (event.wasClean)));
    }
    if (event.reason) {
      msgBuf.push(("reason: " + (event.reason)));
    }
    var msg = msgBuf.join(', ');
    /* #stripped LOG_DEBUG(`WebSocket transport connection is closed ${msg}`) */

    /* #stripped LOG_TRACE(`Event { type: ${event.type} wasClean: ${event.wasClean} code: ${event.code} reason: ${event.reason} }`) */

    this._state = TransportSessionState.CONNECTION_FAILED;
    this.destroy(("Connection closed: " + msg), ErrorSubcode.COMMUNICATION_ERROR);
  };

  WebSocketTransportSession.prototype.onDrain = function onDrain () {
    /* #stripped LOG_TRACE('Drained socket') */

    this.maybeEmitCanSend();
    this.maybeEmitFlush();
  };

  WebSocketTransportSession.prototype.onBufferedAmountPoll = function onBufferedAmountPoll () {
    if (this.getBufferedAmount() === 0) {
      this.onDrain();
    } else if (this.scheduleQuery) {
      this.scheduleQuery();
    }
  };

  /**
   * @param {TransportSessionEvent} event The event causing the error
   * @private
   */
  WebSocketTransportSession.prototype.onError = function onError (event) {
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_DEBUG('WebSocket transport is being destroyed, ignore error') */

      return;
    }
    var msg = (event.message) ? ((": " + (event.message))) : '';
    /* #stripped LOG_DEBUG(`WebSocket transport connection error ${msg}`) */

    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.SEND_ERROR,
              ("Connection error" + msg),
              null,
              ErrorSubcode.CONNECTION_ERROR, null));
  };

  /**
   * @param {TransportSessionEvent} event The data event
   * @private
   */
  WebSocketTransportSession.prototype.onMessage = function onMessage (event) {
    if (this._client) {
      this._client.rxDataArrayBuffer(event.data);
    }
  };

  /**
   * @override
   * @private
   */
  WebSocketTransportSession.prototype.connectTimerExpiry = function connectTimerExpiry () {
    /* #stripped LOG_DEBUG('WebSocket transport connect timeout') */

    this.state = TransportSessionState.CONNECTION_FAILED;
    this._eventCB(new TransportSessionEvent(
      TransportSessionEventCode.CONNECT_TIMEOUT,
      'Connection timed out',
      null,
      ErrorSubcode.TIMEOUT
    ));
  };

  /**
   * @override
   * @private
   */
  WebSocketTransportSession.prototype.connect = function connect () {
    if (this._state !== TransportSessionState.DOWN) {
      LOG_ERROR(("Invalid state for operation: " + (TransportSessionState.nameOf(this._state))));
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (!this._url) {
      LOG_WARN('Cannot connect to null URL');
      return TransportReturnCode.CONNECTION_ERROR;
    }
    if (this._socket) {
      this.onError('Socket already connected');
    }

    /* #stripped LOG_DEBUG('Establishing WebSocket transport session') */

    try {
      this.createConnectTimeout();
      this._state = TransportSessionState.WAITING_FOR_CREATE;
      if (true && !this._socketOptions) {
        /* #stripped LOG_DEBUG('Creating Node websocket options') */

        this._socketOptions = this.createWebSocketOptions();
      }
      /* #stripped LOG_DEBUG('Constructing socket') */

      if (false) {
        /**
         * @type {WebSocket}
         */
        this._socket = new MyWebSocket(this._url, 'smf.solacesystems.com');
      } else {
        this._socket = new MyWebSocket(this._url, 'smf.solacesystems.com', this._socketOptions);
        this._socket.ondrain = this.onDrain.bind(this);
      }
      // Closure is generally faster than bind
      /* #stripped LOG_TRACE('Assigning properties to socket') */

      // Closure using Browser profile to avoid mangling this
      this._socket.binaryType = 'arraybuffer';
      this._socket.onopen = this.onOpen.bind(this);
      this._socket.onmessage = this.onMessage.bind(this);
      this._socket.onclose = this.onClose.bind(this);
      this._socket.onerror = this.onError.bind(this);
      /* #stripped LOG_TRACE('Prepared socket') */

    } catch (error) {
      /* #stripped LOG_DEBUG(`Error connecting: ${error.message}`) */

      /* #stripped LOG_TRACE('Error details', error.stack || error) */

      this._state = TransportSessionState.CONNECTION_FAILED;
      this.cancelConnectTimeout();
      if (error instanceof TransportError) {
        this._connError = error;
      } else {
        throw new TransportError(("Could not create WebSocket: " + (error.message)),
                                 error.subcode || ErrorSubcode.CONNECTION_ERROR);
      }
      return TransportReturnCode.CONNECTION_ERROR;
    }

    /* #stripped LOG_DEBUG('WebSocket is connecting') */

    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @param {String} data The binary string data to send.
   * @param {Boolean} [force=false] If true, send even if buffer is full.
   */
  WebSocketTransportSession.prototype.send = function send (data, force) {
    var this$1 = this;
    if ( force === void 0 ) force = false;

    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    var dataLen = data.length;
    var bufferAllow = (this._sendBufferMaxSize - this.getBufferedAmount()) >= 0;
    // LOG_DEBUG('Websocket send:', dataLen, force, bufferAllow);
    if (!(force || bufferAllow)) {
      this._canSendNeeded = true;
      if (this.scheduleQuery) { this.scheduleQuery(); }
      return TransportReturnCode.NO_SPACE;
    }

    // LOG_TRACE(`websocket.send: len=${data.length}`);
    // Slice messages per maxPayloadBytes
    var maxPayloadBytes = this._maxPayloadBytes;
    var ab = stringToArrayBuffer(data);
    if (dataLen > maxPayloadBytes) {
      for (var i = 0; i < dataLen; i += maxPayloadBytes) {
        this$1._socket.send(ab.slice(i, i + maxPayloadBytes));
      }
    } else {
      this._socket.send(ab);
    }
    // LOG_TRACE(`websocket.send: after send getBufferedAmount=${this.getBufferedAmount()}`);
    this._clientstats.bytesWritten += dataLen;
    ++this._clientstats.msgWritten;
    return TransportReturnCode.OK;
  };

  /**
   * @returns {Number} The number of already buffered bytes in this transport.
   * @private
   */
  WebSocketTransportSession.prototype.getBufferedAmount = function getBufferedAmount () {
    // Access as string property because this is a defineProperty on node websocket,
    // meaning it is not mangled by Closure Compiler
    return this._socket ? this._socket['bufferedAmount'] : 0; // eslint-disable-line dot-notation
  };

  /**
   * @override
   */
  WebSocketTransportSession.prototype.flush = function flush (callback) {
    this._flushCallback = callback;
    this.maybeEmitFlush();
  };

  WebSocketTransportSession.prototype.maybeEmitCanSend = function maybeEmitCanSend () {
    if (this._canSendNeeded && this.getBufferedAmount() < this._sendBufferMaxSize) {
      /* #stripped LOG_TRACE('Transport emitting CAN_ACCEPT_DATA') */

      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '', null, 0, this._sessionId));
    }
  };

  WebSocketTransportSession.prototype.maybeEmitFlush = function maybeEmitFlush () {
    if (!this._flushCallback) { return; }
    if (false) {
      // Ensure we have a query scheduled, but don't interrupt a query in progress
      if (!this._bufferedAmountQueryTimer) {
        this.scheduleQuery();
      }
      return;
    }

    // Node is automatically flushed by socket.end(), which is called in non-error cases
    /* #stripped LOG_DEBUG('Transport emitting FLUSH') */

    var cb = this._flushCallback;
    this._flushCallback = null;
    cb();
  };

  /**
   * @override
   */
  WebSocketTransportSession.prototype.destroy = function destroy (message, subcode) {
    // We can destroy (and get a notice) even if the socket is freshly created.
    // But this will only work once.
    if (this._state !== TransportSessionState.DOWN) {
      /* #stripped LOG_DEBUG(`Destroy WebSocket transport: ${message}`) */


      // Set state for connection teardown.
      this._state = TransportSessionState.WAITING_FOR_DESTROY;

      if (this._socket) {
        this._socket.close();
        this._socket.onopen = null;
        this._socket.onmessage = null;
        this._socket.onclose = null;
        this._socket.onerror = function onerrorStub() { }; // Prevent unhandled errors
        this._socket = null;
      }

      if (this._connectTimer) {
        clearTimeout(this._connectTimer);
        this._connectTimer = undefined;
      }

      if (false) {
        this.cancelQuery();
        this._bufferedAmountQueryIntervalDelayMultiplier = 1;
      }

      this._canSendNeeded = false;

      this._state = TransportSessionState.DOWN;

      this._client = null; // Don't accept data.
    }
    // always send a DESTROYED_NOTICE in response to a destroy() even
    // if we think the transport is already destroyed
    if (this._eventCB) {
      // Fire this *almost* instantly, but follow the HTTP
      // transport pattern by guaranteeing an async callback.
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                              message || 'Session is destroyed',
                                              null,
                                              subcode || 0,
                                              this._sessionId));
      // Release references to other components
      this._eventCB = null;
    }

    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @returns {String} A description of this object.
   */
  WebSocketTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "WebSocketTransportSession; sid=" + (formatHexString(this._sessionId));
    return str;
  };

  WebSocketTransportSession.browserSupportsBinaryWebSockets = function browserSupportsBinaryWebSockets () {
    /* #stripped LOG_DEBUG('websocket browserSupportBinaryCheck - ' +
              'if WebSocket, ArrayBuffer and Uint8Array are supported') */


    var exists = ['function', 'object'];
    if (!includes(exists, typeof MyWebSocket) ||
        !includes(exists, typeof ArrayBuffer) ||
        !includes(exists, typeof Uint8Array)) {
      /* #stripped LOG_DEBUG('websocket browserSupportBinaryCheck: false - some required classes not supported') */

      return false;
    }

    /* #stripped LOG_DEBUG('websocket browserSupportBinaryCheck - if WebSocket supports binaryType') */

    if ('binaryType' in MyWebSocket.prototype) {
      /* #stripped LOG_DEBUG('websocket browserSupportBinaryCheck: true - WebSocket supports binaryType') */

      return true;
    }

    /* #stripped LOG_DEBUG('websocket browserSupportBinaryCheck: false - WebSocket does not support binaryType') */

    return false;
  };

  return WebSocketTransportSession;
}(WebTransportSessionBase));

if (false) {
  mixin(WebSocketTransportSession, (function () {
    function WebSocketTransportSessionBrowser () {}

    WebSocketTransportSessionBrowser.prototype.scheduleQuery = function scheduleQuery () {
      var this$1 = this;

      var bufferedAmount = this.getBufferedAmount();
      if (bufferedAmount > 0 && this._bufferedAmountQueryIntervalInMsecs > 0) {
        this.cancelQuery();
        if (this._bufferedAmountQueryIntervalDelayMultiplier > 1) {
          /* #stripped LOG_DEBUG(`$$ schedule bufferedAmount query timer in ${
                    this._bufferedAmountQueryIntervalInMsecs *
                    this._bufferedAmountQueryIntervalDelayMultiplier} ms`) */

        }
        var timeout = this._bufferedAmountQueryIntervalInMsecs *
                        this._bufferedAmountQueryIntervalDelayMultiplier;
        this._bufferedAmountQueryTimer = setTimeout(function () {
          this$1.cancelQuery();
          try {
            this$1.onBufferedAmountPoll();
          } catch (e) {
            LOG_ERROR(("Error occurred in onBufferedAmountPoll: " + (e.message)));
            /* #stripped LOG_TRACE('Error details:', e.stack || e) */

          }
        }, timeout);
      }
    };

    WebSocketTransportSessionBrowser.prototype.cancelQuery = function cancelQuery () {
      if (this._bufferedAmountQueryTimer) {
        clearTimeout(this._bufferedAmountQueryTimer);
        this._bufferedAmountQueryTimer = null;
      }
    };

    return WebSocketTransportSessionBrowser;
  }()));
} else {
  // Node TLS socket options formulation shared with TCP transport
  // eslint-disable-next-line global-require
  var ref$12 = __webpack_require__(139);
  var NodeTLSOptsMixin = ref$12.NodeTLSOptsMixin;
  mixin(WebTransportSessionBase, NodeTLSOptsMixin);
  // Node-specific methods of this class go here
  mixin(WebTransportSessionBase, (function () {
    function WebTransportSessionBaseNode () {}

    WebTransportSessionBaseNode.prototype.createWebSocketOptions = function createWebSocketOptions () {
      if (this._ssl) {
        var options = this.createTLSOptions();
        // use custom agent for client certificate support, ssl resume session support
        // eslint-disable-next-line dot-notation
        options['agent'] = SolclientFactoryLib.SolclientFactory.wsSslAgent;
        /* #stripped LOG_DEBUG('WebSocket options', options) */

        return options;
      }
      return {};
    };

    return WebTransportSessionBaseNode;
  }()));
}

module.exports.WebSocketTransportSession = WebSocketTransportSession;


/***/ }),
/* 147 */
/***/ (function(module, exports) {

/**
 * This class is used to efficiently concatenate strings.
 * @private
 */
var StringBuffer = function StringBuffer() {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  this.clear();
  (ref = this).append.apply(ref, args);
  var ref;
};

/**
 * Appends the given strings to the buffer
 *
 * @param {...*} args Objects to add to the buffer. These are immediately
 *                  coerced to strings.
 * @returns {StringBuffer} this
 */
StringBuffer.prototype.append = function append () {
    var this$1 = this;
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  [].concat( args ).forEach(function (arg) {
    this$1.buffer[this$1.index++] = String(arg);
  });
  return this;
};

/**
 * Resets the buffer.
 */
StringBuffer.prototype.clear = function clear () {
  this.buffer = [];
  this.index = 0;
};

/**
 * Returns the buffer as a string. Additional concatenations and renderings
 * can be performed.
 * @returns {String} The buffer's contents concatenated to a string.
 */
StringBuffer.prototype.toString = function toString () {
  return this.buffer.join('');
};

module.exports.StringBuffer = StringBuffer;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(263);
var BaseChecks = ref.BaseChecks;

/**
 *
 * Generates a then closure.
 *
 * @param {Boolean} doOp Whether the returned then function should call its argument.
 * @returns {Object} An object { then(fn, elseFn=undefined) }. If doOp was true, then(fn) will
 *                      call fn. If not, elseFn will be called if supplied.
 * @private
 */
function thenGen(doOp) {
  return {
    then: doOp ? function (f) { return f(); } : function (_, elseFn) { return elseFn(); },
  };
}

/**
 *
 * none, anything, boolean, ... @returns {Boolean}
 * when(condition) @returns then(fn, elseFn) => if condition fn() else elseFn && elseFn()
 * unless(condition, else) @returns then(fn, elseFn) => if !condition fn() else elseFn && elseFn
 * whenNone, whenAnything, whenBoolean, ... @returns {function} then(fn, elseFn)
 * unlessNone, unlessAnything, unlessBoolean ... @returns {function} unless(fn, elseFn)
 * @private
 */
var Check = (function () {
  var result = Object.assign({}, BaseChecks);
  result.when = function (condition) { return thenGen(condition); };
  result.unless = function (condition) { return thenGen(!condition); };
  return result;
})();

module.exports.Check = Check;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = require("clone");

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = require("long");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * <h1> Overview </h1>
 *
 * This is the Solace Corporation Messaging API for JavaScript. Concepts defined in this API are
 * similar to those defined in other Solace Messaging APIs for Java, C, and .NET.
 *
 * <h1> Concepts </h1>
 *
 * Some general concepts:
 *
 * <li> All function calls are non-blocking; confirmation, if requested, is returned to the calling
 * client application in the form of callbacks. </li>
 *
 */

/* eslint-disable sort-requires/sort-requires */

// ----------------------------- Polyfills -----------------------------------
// Include compatibility entry points here. These are expected to modify the
// global environment.
if (false ||
    global && global.process && global.process.version < 'v6.0') {
  /* eslint-disable global-require */
  // Select es6 shims required by the API for older browsers and Node
  __webpack_require__(268);
  __webpack_require__(269);
  __webpack_require__(270);
  __webpack_require__(271);
  __webpack_require__(272);
  __webpack_require__(273);
  __webpack_require__(274);
  __webpack_require__(275);
  __webpack_require__(276);
  __webpack_require__(277);
  __webpack_require__(278);
  __webpack_require__(279);
  __webpack_require__(280);
  __webpack_require__(281);

  __webpack_require__(158);
  /* eslint-enable global-require */
}
__webpack_require__(282);
__webpack_require__(283);
// ---------------------------------------------------------------------------

// -------------------------- Solclient Factory ------------------------------
// Load me before the rest of the API as a plug-in point for modules
var FactoryLib = __webpack_require__(9);
// ---------------------------------------------------------------------------

var SolclientFactory = FactoryLib.SolclientFactory;
var SolclientFactoryProfiles = FactoryLib.SolclientFactoryProfiles;
var SolclientFactoryProperties = FactoryLib.SolclientFactoryProperties;

var ref = __webpack_require__(3);
var Long = ref.Long;
var ref$1 = __webpack_require__(5);
var Destination = ref$1.Destination;
var DestinationType = ref$1.DestinationType;
var Topic = ref$1.Topic;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var NotImplementedError = ref$2.NotImplementedError;
var OperationError = ref$2.OperationError;
var RequestError = ref$2.RequestError;
var RequestEventCode = ref$2.RequestEventCode;
var ref$3 = __webpack_require__(0);
var makeIterator = ref$3.makeIterator;
var ref$4 = __webpack_require__(1);
var ConsoleLogImpl = ref$4.ConsoleLogImpl;
var LogImpl = ref$4.LogImpl;
var LogLevel = ref$4.LogLevel;
var ref$5 = __webpack_require__(16);
var Message = ref$5.Message;
var MessageCacheStatus = ref$5.MessageCacheStatus;
var MessageDeliveryModeType = ref$5.MessageDeliveryModeType;
var MessageDumpFlag = ref$5.MessageDumpFlag;
var MessageType = ref$5.MessageType;
var MessageUserCosType = ref$5.MessageUserCosType;
var ref$6 = __webpack_require__(99);
var MessageConsumer = ref$6.MessageConsumer;
var MessageConsumerAcknowledgeMode = ref$6.MessageConsumerAcknowledgeMode;
var MessageConsumerEventName = ref$6.MessageConsumerEventName;
var MessageConsumerProperties = ref$6.MessageConsumerProperties;
var ref$7 = __webpack_require__(29);
var MessagePublisherAcknowledgeMode = ref$7.MessagePublisherAcknowledgeMode;
var MessagePublisherProperties = ref$7.MessagePublisherProperties;
var ref$8 = __webpack_require__(18);
var AbstractQueueDescriptor = ref$8.AbstractQueueDescriptor;
var QueueAccessType = ref$8.QueueAccessType;
var QueueDescriptor = ref$8.QueueDescriptor;
var QueueDiscardBehavior = ref$8.QueueDiscardBehavior;
var QueuePermissions = ref$8.QueuePermissions;
var QueueProperties = ref$8.QueueProperties;
var QueueType = ref$8.QueueType;
var ref$9 = __webpack_require__(10);
var SDTField = ref$9.SDTField;
var SDTFieldType = ref$9.SDTFieldType;
var SDTMapContainer = ref$9.SDTMapContainer;
var SDTStreamContainer = ref$9.SDTStreamContainer;
var SDTUnsupportedValueError = ref$9.SDTUnsupportedValueError;
var SDTValueErrorSubcode = ref$9.SDTValueErrorSubcode;
var ref$10 = __webpack_require__(21);
var AuthenticationScheme = ref$10.AuthenticationScheme;
var CapabilityType = ref$10.CapabilityType;
var MessageRxCBInfo = ref$10.MessageRxCBInfo;
var MutableSessionProperty = ref$10.MutableSessionProperty;
var Session = ref$10.Session;
var SessionEvent = ref$10.SessionEvent;
var SessionEventCBInfo = ref$10.SessionEventCBInfo;
var SessionEventCode = ref$10.SessionEventCode;
var SessionProperties = ref$10.SessionProperties;
var SessionState = ref$10.SessionState;
var ref$11 = __webpack_require__(80);
var CacheCBInfo = ref$11.CacheCBInfo;
var CacheLiveDataAction = ref$11.CacheLiveDataAction;
var CacheRequestResult = ref$11.CacheRequestResult;
var CacheReturnCode = ref$11.CacheReturnCode;
var CacheReturnSubcode = ref$11.CacheReturnSubcode;
var CacheSession = ref$11.CacheSession;
var CacheSessionProperties = ref$11.CacheSessionProperties;
var ref$12 = __webpack_require__(19);
var StatType = ref$12.StatType;
var ref$13 = __webpack_require__(23);
var TransportError = ref$13.TransportError;
var TransportProtocol = ref$13.TransportProtocol;
var ref$14 = __webpack_require__(4);
var Version = ref$14.Version;

// --------------------------- Internal API -- do not use --------------------
// Load me last. I disappear in production mode
var _internal = __webpack_require__(157);
// ---------------------------------------------------------------------------


/**
 * @namespace
 * @public
 */
var solace = {
  AbstractQueueDescriptor: AbstractQueueDescriptor,
  AuthenticationScheme: AuthenticationScheme,
  CacheCBInfo: CacheCBInfo,
  CacheLiveDataAction: CacheLiveDataAction,
  CacheRequestResult: CacheRequestResult,
  CacheReturnCode: CacheReturnCode,
  CacheReturnSubcode: CacheReturnSubcode,
  CacheSession: CacheSession,
  CacheSessionProperties: CacheSessionProperties,
  CapabilityType: CapabilityType,
  ConsoleLogImpl: ConsoleLogImpl,
  Destination: Destination,
  DestinationType: DestinationType,
  ErrorSubcode: ErrorSubcode,
  LogImpl: LogImpl,
  LogLevel: LogLevel,
  Long: Long,
  Message: Message,
  MessageCacheStatus: MessageCacheStatus,
  MessageConsumer: MessageConsumer,
  MessageConsumerAcknowledgeMode: MessageConsumerAcknowledgeMode,
  MessageConsumerEventName: MessageConsumerEventName,
  MessageConsumerProperties: MessageConsumerProperties,
  MessageDeliveryModeType: MessageDeliveryModeType,
  MessageDumpFlag: MessageDumpFlag,
  MessagePublisherAcknowledgeMode: MessagePublisherAcknowledgeMode,
  MessagePublisherProperties: MessagePublisherProperties,
  MessageRxCBInfo: MessageRxCBInfo,
  MessageType: MessageType,
  MessageUserCosType: MessageUserCosType,
  MutableSessionProperty: MutableSessionProperty,
  NotImplementedError: NotImplementedError,
  OperationError: OperationError,
  QueueAccessType: QueueAccessType,
  QueueDescriptor: QueueDescriptor,
  QueueDiscardBehavior: QueueDiscardBehavior,
  QueuePermissions: QueuePermissions,
  QueueProperties: QueueProperties,
  QueueType: QueueType,
  RequestError: RequestError,
  RequestEventCode: RequestEventCode,
  SDTField: SDTField,
  SDTFieldType: SDTFieldType,
  SDTMapContainer: SDTMapContainer,
  SDTStreamContainer: SDTStreamContainer,
  SDTUnsupportedValueError: SDTUnsupportedValueError,
  SDTValueErrorSubcode: SDTValueErrorSubcode,
  Session: Session,
  SessionEvent: SessionEvent,
  SessionEventCBInfo: SessionEventCBInfo,
  SessionEventCode: SessionEventCode,
  SessionProperties: SessionProperties,
  SessionState: SessionState,
  SolclientFactory: SolclientFactory,
  SolclientFactoryProfiles: SolclientFactoryProfiles,
  SolclientFactoryProperties: SolclientFactoryProperties,
  StatType: StatType,
  Topic: Topic,
  TransportError: TransportError,
  TransportProtocol: TransportProtocol,
  Version: Version,

  makeIterator: makeIterator,

  _internal: _internal, //
};

Object.assign(module.exports, solace);


/***/ }),
/* 152 */
/***/ (function(module, exports) {

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

// It has been modified by me (Edward Funnekotter) to improve its
// efficiency

// It has been modified by me (Justin Bowes) to avoid using it whenever
// possible in favour of browser or buffer implementations.

var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var ENC_LUT = [
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, 99, -1, -1, 99, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  99, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, 62, -1, -1, -1, 63,
  52, 53, 54, 55, 56, 57, 58, 59,
  60, 61, -1, -1, -1, 64, -1, -1,

    // 64
  -1, 0, 1, 2, 3, 4, 5, 6,
  7, 8, 9, 10, 11, 12, 13, 14,
  15, 16, 17, 18, 19, 20, 21, 22,
  23, 24, 25, -1, -1, -1, -1, -1,
  -1, 26, 27, 28, 29, 30, 31, 32,
  33, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 45, 46, 47, 48,
  49, 50, 51, -1, -1, -1, -1, -1,

    // 128
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,

    // 192
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1];

var DecodeError = (function (Error) {
  function DecodeError () {
    Error.apply(this, arguments);
  }if ( Error ) DecodeError.__proto__ = Error;
  DecodeError.prototype = Object.create( Error && Error.prototype );
  DecodeError.prototype.constructor = DecodeError;

  

  return DecodeError;
}(Error));

var LegacyEncoder = {
  /**
   * Encodes a string in base64
   * @param {String} input The string to encode in base64.
   * @returns {String} base64 encoded input
   * @private
   */
  base64_encode: function base64_encode(input) {
    var output = '';
    var i = 0;
    do {
      var chr1 = input.charCodeAt(i++);
      var chr2 = input.charCodeAt(i++);
      var chr3 = input.charCodeAt(i++);

      var enc1 = chr1 >> 2;
      var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
      var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
      var enc4 = chr3 & 63;

      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }

      output += KEY_STR.charAt(enc1);
      output += KEY_STR.charAt(enc2);
      output += KEY_STR.charAt(enc3);
      output += KEY_STR.charAt(enc4);
    } while (i < input.length);

    return output;
  },

  /**
   * Decodes a base64 string.
   * @param {String} input The base64 string to decode.
   * @returns {String} binary output
   * @private
   */
  base64_decode: function base64_decode(input) {
    var output = '';
    var i = 0;

    do {
      while (ENC_LUT[input.charCodeAt(i)] > 64) {
        i++;
      }
      var enc1 = ENC_LUT[input.charCodeAt(i++)];
      var enc2 = ENC_LUT[input.charCodeAt(i++)];
      var enc3 = ENC_LUT[input.charCodeAt(i++)];
      var enc4 = ENC_LUT[input.charCodeAt(i++)];

      if (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0) {
        // Invalid character in base64 text
        // alert("enc at " + i + ": " + enc1 + ", " + enc2 + ", " + enc3 + ", " + enc4);
        throw new DecodeError('Invalid base64 character');
      }

      var chr1 = (enc1 << 2) | (enc2 >> 4);
      var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      var chr3 = ((enc3 & 3) << 6) | enc4;

      output += String.fromCharCode(chr1);

      if (enc3 !== 64) {
        output += String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output += String.fromCharCode(chr3);
      }
    } while (i < input.length - 3);

    return output;
  },
};

var isNode = typeof window === 'undefined'; // !node
var hasBuffer = typeof Buffer !== 'undefined';
var hasBlob = typeof Blob !== 'undefined'; // !node, !ie9
var BufferEncoder = (hasBuffer && (hasBlob || isNode))
  ? {
    base64_encode: function (str) { return Buffer.from(str, 'binary').toString('base64'); },
    base64_decode: function (str) { return Buffer.from(str, 'base64').toString('binary'); },
  }
  : {};
/* eslint-env browser */
/* eslint-disable dot-notation */
var WindowEncoder = (typeof window !== 'undefined')
  ? {
    base64_encode: window['btoa'] ? function (b) { return window['btoa'](b); } : null,
    base64_decode: window['atob'] ? function (a) { return window['atob'](a); } : null,
  }
  : {};
/* eslint-enable dot-notation */

var Base64 = {
  encode: (WindowEncoder.base64_encode ||
           BufferEncoder.base64_encode ||
           LegacyEncoder.base64_encode),
  decode: (WindowEncoder.base64_decode ||
           BufferEncoder.base64_decode ||
           LegacyEncoder.base64_decode),
};

module.exports.Base64 = Base64;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

var Bits = {
  get: function get(val, shift, numBits) {
    return (val >>> shift) & ((0x01 << numBits) - 1);
  },

  set: function set(dataIn, val, shift, numBits) {
    var curMask = (1 << numBits) - 1;
    var shiftedVal = (val & curMask) << shift;
    var data = dataIn & ~(curMask << shift);
    return (data | shiftedVal);
  },
};

module.exports.Bits = Bits;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Long = __webpack_require__(150);

/**
 * @module
 * ===========================================================================
 * Convert
 *
 * This collection of functions performs all required string to number and number to string
 * conversions
 * ============================================================================
 * @private
 */

var TWO_ZEROES_STR = String.fromCharCode(0, 0);
var THREE_ZEROES_STR = String.fromCharCode(0, 0, 0);
var FOUR_ZEROES_STR = String.fromCharCode(0, 0, 0, 0);

var BYTEARRAY_CONVERT_CHUNK = 8192;
var UNSIGNED_LSHIFT_24 = (256 * 256 * 256);

var ARRAY_BUFFER_CONVERT_CHUNK = 32768;

function stringToUint8Array(data) {
  var dataLength = data.length;
  var arrayBuf = new ArrayBuffer(dataLength);
  var uint8Array = new Uint8Array(arrayBuf, 0, dataLength);
  for (var i = 0; i < dataLength; i++) {
    uint8Array[i] = data.charCodeAt(i);
  }
  return uint8Array;
}

function arrayBufferToString(ab) {
  if (!ab) { return ''; }
  var len = ab.byteLength;
  var u8 = new Uint8Array(ab);
  if (len < ARRAY_BUFFER_CONVERT_CHUNK) {
    return String.fromCharCode.apply(null, u8);
  }

  var k = 0;
  var r = '';
  while (k < len) {
    // slice is clamped, inclusive of startIndex, exclusive of lastIndex
    r += String.fromCharCode.apply(null, u8.subarray(k, k + ARRAY_BUFFER_CONVERT_CHUNK));
    k += ARRAY_BUFFER_CONVERT_CHUNK;
  }
  return r;
}

function stringToArrayBuffer(str) {
  return stringToUint8Array(str).buffer;
}

function int8ToStr(int8) {
  return String.fromCharCode(int8 & 0xff);
}

function int16ToStr(int16) {
  return (
      String.fromCharCode((int16 >> 8) & 0xff) +
      String.fromCharCode(int16 & 0xff)
  );
}

function int24ToStr(int24) {
  return (
      String.fromCharCode((int24 >> 16) & 0xff) +
      String.fromCharCode((int24 >> 8) & 0xff) +
      String.fromCharCode(int24 & 0xff)
  );
}

function int32ToStr(int32) {
  // It is expected that there are a lot of small numbers
  // being converted, so it is worth doing a few checks for
  // efficiency (on firefox it is about 3 times quicker for small numbers
  // to do the check - it is 2 times quicker for chrome)

  if (int32 === 0) { return FOUR_ZEROES_STR; }
  if (int32 > 0) {
    if (int32 < 256) {
      return THREE_ZEROES_STR + String.fromCharCode(int32);
    }
    if (int32 < 65536) {
      return TWO_ZEROES_STR + String.fromCharCode(int32 >> 8) + String.fromCharCode(int32 & 0xff);
    }
  }

  return (
      String.fromCharCode((int32 >> 24) & 0xff) +
      String.fromCharCode((int32 >> 16) & 0xff) +
      String.fromCharCode((int32 >> 8) & 0xff) +
      String.fromCharCode(int32 & 0xff)
  );
}

function int64ToStr(int64) {
  if (typeof int64 !== 'number') {
    return int32ToStr(int64.high) + int32ToStr(int64.low);
  }

  // It is expected that there are a lot of small numbers
  // being converted, so it is worth doing a few checks for
  // efficiency (on firefox it is about 3 times quicker for small numbers
  // to do the check - it is 2 times quicker for chrome)
  if (int64 >= 0) {
    if (int64 < 256) {
      return FOUR_ZEROES_STR + THREE_ZEROES_STR + String.fromCharCode(int64);
    }
    if (int64 < 65536) {
      return FOUR_ZEROES_STR + TWO_ZEROES_STR +
        String.fromCharCode(int64 >> 8) + String.fromCharCode(int64 & 0xff);
    }
    if (int64 < 4294967296) {
      return FOUR_ZEROES_STR + (String.fromCharCode((int64 >> 24) & 0xff) +
        String.fromCharCode((int64 >> 16) & 0xff) +
        String.fromCharCode((int64 >> 8) & 0xff) +
        String.fromCharCode(int64 & 0xff));
    }
  }
  return String.fromCharCode((int64 >> 56) & 0xFF) +
        String.fromCharCode((int64 >> 48) & 0xFF) +
        String.fromCharCode((int64 >> 40) & 0xFF) +
        String.fromCharCode((int64 >> 32) & 0xFF) +
        String.fromCharCode((int64 >> 24) & 0xff) +
        String.fromCharCode((int64 >> 16) & 0xff) +
        String.fromCharCode((int64 >> 8) & 0xff) +
        String.fromCharCode(int64 & 0xff);
}

function byteArrayToStr(byteArray) {
  var len = byteArray.length;
  if (len < BYTEARRAY_CONVERT_CHUNK) {
    return String.fromCharCode.apply(null, byteArray);
  }

  var k = 0;
  var r = '';

  while (k < len) {
    // slice is clamped, inclusive of startIndex, exclusive of lastIndex
    r += String.fromCharCode.apply(null, byteArray.slice(k, k + BYTEARRAY_CONVERT_CHUNK));
    k += BYTEARRAY_CONVERT_CHUNK;
  }

  return r;
}

function strToByteArray(str) {
  var result = [];
  var i;
  for (i = 0; i < str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}

function strToHexArray(str) {
  function toHex(c) {
    return c.charCodeAt(0).toString(16);
  }
  return Array.prototype.map.call(str.split(''), toHex);
}

function strToInt8(data) {
  return data.charCodeAt(0) & 0xff;
}

function strToInt16(data) {
  return (
      (data.charCodeAt(0) << 8) +
      (data.charCodeAt(1))
  );
}

function strToInt24(data) {
  return (
      (data.charCodeAt(0) << 16) +
      (data.charCodeAt(1) << 8) +
      (data.charCodeAt(2))
  );
}

function strToInt32(data) {
    // SIGNED integer
  return (
      (data.charCodeAt(0) << 24) +
      (data.charCodeAt(1) << 16) +
      (data.charCodeAt(2) << 8) +
      (data.charCodeAt(3))
  );
}

function strToUInt32(data) {
  // WARNING: you cannot use a << 24 to shift a byte into
  // a 32-bit string, because all shifts in JS are signed
  return (
      (data.charCodeAt(0) * UNSIGNED_LSHIFT_24) +
      (data.charCodeAt(1) << 16) +
      (data.charCodeAt(2) << 8) +
      (data.charCodeAt(3))
  );
}

function strToUInt64(data) {
  return Long.fromBits(strToUInt32(data.substr(4, 4)),
                       strToUInt32(data.substr(0, 4)),
                       true);
}

function ucs2ToUtf8(ucs2) {
  return unescape(encodeURIComponent(ucs2));
}

function utf8ToUcs2(utf8) {
  return decodeURIComponent(escape(utf8));
}

var Convert = {
  arrayBufferToString: arrayBufferToString,
  stringToArrayBuffer: stringToArrayBuffer,
  stringToUint8Array: stringToUint8Array,

  int8ToStr: int8ToStr,
  strToInt8: strToInt8,

  int16ToStr: int16ToStr,
  strToInt16: strToInt16,

  int24ToStr: int24ToStr,
  strToInt24: strToInt24,

  int32ToStr: int32ToStr,
  strToInt32: strToInt32,
  strToUInt32: strToUInt32,

  int64ToStr: int64ToStr,
  strToUInt64: strToUInt64,

  byteArrayToStr: byteArrayToStr,
  strToByteArray: strToByteArray,

  strToHexArray: strToHexArray,

  ucs2ToUtf8: ucs2ToUtf8,
  utf8ToUcs2: utf8ToUcs2,
};

module.exports.Convert = Convert;


/***/ }),
/* 155 */
/***/ (function(module, exports) {

function numToHex(n) {
  if (typeof n !== 'number') {
    return '';
  }
  var s = n.toString(16);
  return (s.length < 2) ? ("0" + s) : s;
}


function formatHexString(obj) {
  if (typeof obj === 'number') {
    return ("0x" + (numToHex(obj)));
  }

  if (typeof obj === 'object' && Array.isArray(obj)) {
    return obj.map(numToHex).join();
  }

  if (typeof obj === 'string') {
    return Array.prototype.map.call(obj, function (_, i) { return numToHex(obj.charCodeAt(i)); }).join('');
  }

  return null;
}

var Hex = {
  formatHexString: formatHexString,
};

module.exports.Hex = Hex;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

module.exports.Long = __webpack_require__(150);


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * SolclientJS internal API for white-box integration testing
 * @private
 */

/* eslint-disable sort-requires/sort-requires */

var Convert = __webpack_require__(3);
var Debug = __webpack_require__(14);
var Destination = __webpack_require__(5);
var Error = __webpack_require__(2);
var ESKit = __webpack_require__(0);
var Factory = __webpack_require__(9);
var FSM = __webpack_require__(15);
var Log = __webpack_require__(1);
var Message = __webpack_require__(16);
var Publisher = __webpack_require__(29);
var SDT = __webpack_require__(10);
var Session = __webpack_require__(21);
var SMF = __webpack_require__(8);
var SolcacheSession = __webpack_require__(80);
var TestEnv = __webpack_require__(161);
var Transport = __webpack_require__(23);
var Util = __webpack_require__(4);
var Validate = __webpack_require__(7);

module.exports = {
  Convert: Convert,
  Debug: Debug,
  Destination: Destination,
  Error: Error,
  ESKit: ESKit,
  Factory: Factory,
  FSM: FSM,
  Log: Log,
  Message: Message,
  Publisher: Publisher,
  SDT: SDT,
  Session: Session,
  SMF: SMF,
  SolcacheSession: SolcacheSession,
  TestEnv: TestEnv,
  Transport: Transport,
  Util: Util,
  Validate: Validate,
};


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

// Modify the Node (or emulated Node) environment so that
// we can use non-deprecated syntax.

var util = __webpack_require__(6);

if (util.inspect.custom === undefined) {
  // Inspect will use customInspect (deprecated) or a method with this name.
  // We can just define the name to be equal to 'inspect' for compatibility
  // if there is no such symbol.
  util.inspect.custom = 'inspect';
}


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
// Do late binding for these debug utilities to break cyclic dependencies.

var PRINTABLE_LUT = (function () {
  var tmp = [];
  for (var c = 0; c < 256; ++c) {
    tmp[c] = (c < 33 || c > 126) ? '.' : String.fromCharCode(c);
  }
  return tmp;
})();

var SPACER = '   ';
var UNPRINTABLE = '.';


function formatDumpBytes(data, showDecode, leftPadding) {
  var ref = __webpack_require__(4);
  var StringBuffer = ref.StringBuffer;
  var StringUtils = ref.StringUtils;
  var isEmpty = StringUtils.isEmpty;
  var padLeft = StringUtils.padLeft;
  var padRight = StringUtils.padRight;

  if (isEmpty(data)) {
    return null;
  }
  var output = new StringBuffer();
  var ascii = new StringBuffer();
  var line = new StringBuffer();
  var lineBytes = 0;
  var asciiOffset = 54;

  for (var i = 0, dataLen = data.length; i < dataLen; ++i) {
    var ccode = data.charCodeAt(i);
    line.append(padLeft(ccode.toString(16), 2, '0'), ' ');
    ascii.append(PRINTABLE_LUT[ccode] || UNPRINTABLE);
    lineBytes++;

    if (lineBytes === 8) {
      line.append(SPACER);
    }

    if (lineBytes === 16 || i === data.length - 1) {
      if (leftPadding > 0) {
        output.append(padRight('', leftPadding, ' '));
      }

      output.append(padRight(line.toString(), asciiOffset, ' '));

      if (showDecode) {
        output.append(ascii);
      }

      output.append('\n');
      line.clear();
      ascii.clear();
      lineBytes = 0;
    }
  }

  return output.toString();
}

function parseSMFStream(data) {
  var ref = __webpack_require__(8);
  var decodeCompoundMessage = ref.Codec.Decode.decodeCompoundMessage;
  var ref$1 = __webpack_require__(1);
  var LOG_WARN = ref$1.LOG_WARN;
  var LOG_ERROR = ref$1.LOG_ERROR;

  if (data === null) {
    LOG_ERROR('data null in debugParseSmfStream');
    return;
  }
  var pos = 0;
  LOG_WARN(("parseSMFStream(): Starting parse, length " + (data.length)));
  while (pos < data.length) {
    var incomingMsg = decodeCompoundMessage(data, pos);
    var smf = incomingMsg ? incomingMsg.smfHeader : null;
    if (!(incomingMsg && smf)) {
      // couldn't decode! Lost SMF framing.
      LOG_WARN("parseSMFStream(): couldn't decode message.");
      LOG_WARN(("Position: " + pos + " length: " + (data.length)));
      return;
    }

    LOG_WARN((">> Pos(" + pos + ") Protocol " + (smf.smf_protocol) + ", Length: " + (smf.messageLength)));
    pos += smf.messageLength;
  }
}

var Debug = {
  formatDumpBytes: formatDumpBytes,
  parseSMFStream: parseSMFStream,
};

module.exports.Debug = Debug;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(25);
var DestinationType = ref.DestinationType;
var ref$1 = __webpack_require__(26);
var DestinationUtil = ref$1.DestinationUtil;
var ref$2 = __webpack_require__(86);
var Queue = ref$2.Queue;
var ref$3 = __webpack_require__(87);
var Topic = ref$3.Topic;

var QUEUE_PREFIX = '#P2P/QUE/';
var QUEUE_PREFIX_LEN = QUEUE_PREFIX.length;
var TEMPORARY_QUEUE_PREFIX = '#P2P/QTMP/';

function createDestinationFromName(networkTopicName, networkTopicBytes) {
  if ( networkTopicBytes === void 0 ) networkTopicBytes = undefined;

  if (networkTopicName === null || networkTopicName.length === 0) {
    return null;
  }

  var spec = {
    name:  networkTopicName,
    bytes: networkTopicBytes || DestinationUtil.encodeBytes(networkTopicName),
  };
  if (networkTopicName[0] === '#') {
    if (networkTopicName.startsWith(QUEUE_PREFIX)) {
      var offset = QUEUE_PREFIX_LEN;
      spec.name = networkTopicName.substr(offset);
      spec.type = DestinationType.QUEUE;
      spec.offset = offset;
      return new Queue(spec);
    } else if (networkTopicName.startsWith(TEMPORARY_QUEUE_PREFIX)) {
      spec.name = networkTopicName;
      spec.type = DestinationType.TEMPORARY_QUEUE;
      spec.offset = 0;
      return new Queue(spec);
    }
  }
  return new Topic(spec);
}

function createDestinationFromBytes(networkTopicBytes) {
  if (networkTopicBytes === null || networkTopicBytes.length === 0) {
    return null;
  }

  var networkTopicName = DestinationUtil.decodeBytes(networkTopicBytes);
  return createDestinationFromName(networkTopicName, networkTopicBytes);
}

var DestinationFromNetwork = {
  createDestinationFromBytes: createDestinationFromBytes,
  createDestinationFromName: createDestinationFromName,
};

module.exports.DestinationFromNetwork = DestinationFromNetwork;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

function apiEnv(envObject) {
  if (true) {
    throw new Error('Test environment will not override build environment');
  }
  global.BUILD_ENV = Object.assign({}, envObject, { TEST: true });
  return global.BUILD_ENV;
}

if (true) {
  apiEnv.target = function () { return apiEnv(); };
} else {
  var configs = {
    node: {
      TARGET_NAME: 'node',
      TARGET_NODE: true,
    },
    browser: {
      TARGET_NAME:    'browser',
      TARGET_BROWSER: true,
    },
    debug: {
      MODE_NAME:    'debug',
      MODE_DEBUG:   true,
      MODE_RELEASE: false,
    },
    release: {
      MODE_NAME:    'release',
      MODE_DEBUG:   false,
      MODE_RELEASE: true,
    },
  };

  apiEnv.target = function named() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var objects = args.map(function (arg) {
      if (typeof arg === 'string') {
        var obj = configs[arg];
        if (!obj) {
          throw new Error(("Environment " + arg + " is not defined; use " + (Object.keys(configs).join(', '))));
        }
        return obj;
      } else if (arg && typeof arg === 'object') {
        return arg;
      }

      throw new Error(("Unrecognized argument " + arg));
    });
    return apiEnv(Object.assign.apply(Object, objects));
  };
}
module.exports = apiEnv;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(51);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(0);
var makeMap = ref$1.makeMap;

/* eslint-disable max-len */

var SC = ErrorSubcode;

var ROOT_MAPPING = makeMap(
  400, makeMap(
    'client name parse error', SC.CLIENT_NAME_INVALID,
    'document is too large', SC.MESSAGE_TOO_LARGE,
    'inactivity timeout', SC.INACTIVITY_TIMEOUT,
    'max num subscriptions exceeded', SC.SUBSCRIPTION_TOO_MANY,
    'message too long', SC.MESSAGE_TOO_LARGE,
    'nolocal discard', SC.NOLOCAL_DISCARD,
    'not enough space', SC.OUT_OF_RESOURCES,
    'subscription already exists', SC.SUBSCRIPTION_ALREADY_PRESENT,
    'subscription attributes conflict with existing subscription', SC.SUBSCRIPTION_ATTRIBUTES_CONFLICT,
    'subscription not found', SC.SUBSCRIPTION_NOT_FOUND,
    'subscription parse error', SC.SUBSCRIPTION_INVALID,
    'topic parse error', SC.INVALID_TOPIC_SYNTAX,
    'unknown transport session identifier', SC.UNKNOWN_TRANSPORT_SESSION_ID,
    'xml parse error', SC.XML_PARSE_ERROR
  ),
  401, makeMap(
    '', SC.LOGIN_FAILURE
  ),
  403, makeMap(
    'basic authentication is shutdown', SC.BASIC_AUTHENTICATION_IS_SHUTDOWN,
    'client certificate authentication is shutdown', SC.CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN,
    'client name already in use', SC.CLIENT_NAME_ALREADY_IN_USE,
    'client username is shutdown', SC.CLIENT_USERNAME_IS_SHUTDOWN,
    'dynamic clients not allowed', SC.DYNAMIC_CLIENTS_NOT_ALLOWED,
    'invalid virtual router address', SC.INVALID_VIRTUAL_ADDRESS,
    'forbidden', SC.CLIENT_ACL_DENIED,
    'message vpn not allowed', SC.MESSAGE_VPN_NOT_ALLOWED,
    'publish acl denied', SC.PUBLISH_ACL_DENIED,
    'replication is standby', SC.REPLICATION_IS_STANDBY,
    'selector does not match', SC.SELECTOR_DOES_NOT_MATCH,
    'subscription acl denied', SC.SUBSCRIPTION_ACL_DENIED,
    'subscription does not match', SC.SUBSCRIPTION_DOES_NOT_MATCH
  ),
  404, makeMap(
    '', SC.LOGIN_FAILURE
  ),
  503, makeMap(
    'low priority msg congestion', SC.LOW_PRIORITY_MSG_CONGESTION,
    'message vpn unavailable', SC.MESSAGE_VPN_UNAVAILABLE,
    'replication is standby', SC.REPLICATION_IS_STANDBY,
    'service unavailable', SC.GM_UNAVAILABLE,
    'spool over quota', SC.SPOOL_OVER_QUOTA,
    'subscriber delete in progress', SC.CLIENT_DELETE_IN_PROGRESS,
    'too many clients', SC.TOO_MANY_CLIENTS,
    'too many connections for vpn', SC.TOO_MANY_CLIENTS,
    'max message usage exceeded', SC.MAX_MESSAGE_USAGE_EXCEEDED
  ),
  507, makeMap(
    'ad not ready', SC.GM_NOT_READY
  )
);

var AD_MAPPING = makeMap(
  'PARENT', ROOT_MAPPING,
  400, makeMap(
    'already bound', SC.ALREADY_BOUND,
    'endpoint already exists', SC.ENDPOINT_ALREADY_EXISTS,
    'endpoint property mismatch', SC.ENDPOINT_PROPERTY_MISMATCH,
    'invalid durable topic endpoint name', SC.INVALID_DTE_NAME,
    'invalid selector', SC.INVALID_SELECTOR,
    'invalid topic name', SC.INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT,
    'queue not found', SC.QUEUE_NOT_FOUND,
    'quota out of range', SC.QUOTA_OUT_OF_RANGE,
    'unknown flow name', SC.UNKNOWN_FLOW_NAME,
    'unsubscribe not allowed', SC.UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND
  ),
  403, makeMap(
    'permission not allowed', SC.PERMISSION_NOT_ALLOWED
  ),
  503, makeMap(
    'durable topic endpoint shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'endpoint shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'max clients exceeded for durable topic endpoint', SC.MAX_CLIENTS_FOR_TE,
    'max clients exceeded for queue', SC.MAX_CLIENTS_FOR_QUEUE,
    'no more non-durable queue or topic endpoint', SC.NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT,
    'no subscription match', SC.NO_SUBSCRIPTION_MATCH,
    'queue shutdown', SC.QUEUE_SHUTDOWN,
    'te shutdown', SC.TOPIC_ENDPOINT_SHUTDOWN,
    'unknown durable topic endpoint', SC.UNKNOWN_TOPIC_ENDPOINT_NAME,
    'unknown queue', SC.UNKNOWN_QUEUE_NAME
  )
);

function getSubcodeMappingInner(root, respErrorCode, respStr) {
  if (respErrorCode === 200) {
    // success response, error subcode is 0 -  transport session use 0 as OK
    return 0;
  }
  var codeMap = root[respErrorCode] || {};
  var searchKey = (respStr || '').toLowerCase();
  var foundKey = Object.keys(codeMap)
    .find(function (mapKey) { return mapKey === searchKey || searchKey.indexOf(mapKey) >= 0; });

  if (foundKey) {
    return codeMap[foundKey];
  }

  if (codeMap['']) {
    return codeMap[''];
  }

  /* eslint-disable dot-notation */
  // Don't access string keys via dot properties
  if (root['PARENT']) {
    return getSubcodeMappingInner(root['PARENT'], respErrorCode, respStr);
  }
  /* eslint-enable dot-notation */

  return undefined;
}

function getSubcodeMapping(root, respErrorCode, respStr) {
  var result = getSubcodeMappingInner(root, respErrorCode, respStr);
  if (result === undefined) {
    return SC.UNKNOWN_ERROR;
  }
  return result;
}

/**
 * @classdesc
 * Return {ErrorSubcode} based on response code and response string
 * from the router.
 * @private
 */
var ErrorResponseSubcodeMapper = {
  /**
   * @param {Number} respErrorCode The response code (an HTTP-like integer) to use in the lookup.
   * @param {String} respStr The response string to use in the lookup.
   * @returns {solace.ErrorSubcode} The subcode found, or ErrorSubcode.UNKNOWN_ERROR if not found.
   * @static
   * @private
   */
  getErrorSubcode: function getErrorSubcode(respErrorCode, respStr) {
    return getSubcodeMapping(ROOT_MAPPING, respErrorCode, respStr);
  },

  getADErrorSubcode: function getADErrorSubcode(respErrorCode, respStr) {
    return getSubcodeMapping(AD_MAPPING, respErrorCode, respStr);
  },
};

module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(52);
var SolaceError = ref.SolaceError;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown when calling an API that has not been implemented.
 * @hideconstructor
 * @extends {solace.SolaceError}
 *
 * @memberof solace
 */
var NotImplementedError = (function (SolaceError) {
  function NotImplementedError(message) {
    SolaceError.call(this, 'NotImplementedError', message || '', NotImplementedError);
  }

  if ( SolaceError ) NotImplementedError.__proto__ = SolaceError;
  NotImplementedError.prototype = Object.create( SolaceError && SolaceError.prototype );
  NotImplementedError.prototype.constructor = NotImplementedError;

  return NotImplementedError;
}(SolaceError));

module.exports.NotImplementedError = NotImplementedError;



/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(51);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(88);
var OperationError = ref$1.OperationError;
var ref$2 = __webpack_require__(89);
var RequestEventCode = ref$2.RequestEventCode;


var SUBCODE_FROM_EC = {};
SUBCODE_FROM_EC[RequestEventCode.REQUEST_ABORTED] = ErrorSubcode.SESSION_NOT_CONNECTED;
SUBCODE_FROM_EC[RequestEventCode.REQUEST_TIMEOUT] = ErrorSubcode.TIMEOUT;

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a request failure event; request failure events are passed to the application
 * event handling callback provided when sending the request {@link solace.Session#sendRequest}
 * @memberof solace
 * @extends solace.OperationError
 * @hideconstructor
 */
var RequestError = (function (OperationError) {
  function RequestError(message, eventCode, correlationKey, reason) {
    OperationError.call(this, message, SUBCODE_FROM_EC[eventCode], reason);
    /**
     * The name of the error.
     * @name solace.RequestError#name
     * @type {Constant}
     * @description 'RequestError'
     */
    this.name = 'RequestError';
    this._eventCode = eventCode;
    this._correlationKey = correlationKey;
  }

  if ( OperationError ) RequestError.__proto__ = OperationError;
  RequestError.prototype = Object.create( OperationError && OperationError.prototype );
  RequestError.prototype.constructor = RequestError;

  var prototypeAccessors = { requestEventCode: {},errorSubcode: {} };

  /**
   * @type {solace.SessionEventCode}
   * @name solace.RequestError#requestEventCode
   * @description A code that provides more information about the error event.
   */
  prototypeAccessors.requestEventCode.get = function () {
    return this._requestEventCode;
  };

  /**
   * @deprecated Use {@link solace.RequestError#subcode}
   * @type {?solace.ErrorSubcode}
   * @description if applicable, an error subcode. Defined in {@link ErrorSubcode}
   */
  prototypeAccessors.errorSubcode.get = function () {
    return OperationError.prototype.subcode;
  };

  RequestError.prototype[util.inspect.custom] = function () {
    var superObj = OperationError.prototype[util.inspect.custom] ? OperationError.prototype[util.inspect.custom].call(this) : {};
    return Object.assign(superObj, {
      'requestEventCode': RequestEventCode.describe(this.requestEventCode),
      'infoStr':          this.infoStr,
      'correlationKey':   this.correlationKey,
    });
  };

  RequestError.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( RequestError.prototype, prototypeAccessors );

  return RequestError;
}(OperationError));

module.exports.RequestError = RequestError;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

/* eslint-disable no-nested-ternary */

function defaultComparator(a, b) {
  var astr = String(a);
  var bstr = String(b);
  return astr > bstr ? 1 : (astr < bstr ? -1 : 0);
}

function insertOrdered(array, element, comparator) {
  if ( comparator === void 0 ) comparator = defaultComparator;

  var result = [].concat( array );
  return this.inplaceInsertOrdered(result, element, comparator);
}

function inplaceInsertOrdered(array, element, comparator) {
  if ( comparator === void 0 ) comparator = defaultComparator;

  var index = 0;
  var min = 0;
  var max = array.length;
  // Optimize for empty array
  if (max > 0) {
    // Optimize for append
    if (comparator(element, array[max - 1]) > 0) {
      index = max;
    } else {
      // Binary search
      index = (min + max) >> 1; // math.floor((min + max) / 2)
      while (max > min) {
        if (comparator(element, array[index]) < 0) {
          max = index;
        } else {
          min = index + 1;
        }
        index = (min + max) >> 1; // math.floor((min + max) / 2)
      }
    }
  }
  array.splice(index, 0, element);
}

module.exports = {
  ArrayOperations: {
    defaultComparator: defaultComparator,
    insertOrdered: insertOrdered,
    inplaceInsertOrdered: inplaceInsertOrdered,
  },
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var assert;

/**
 * Browsers and Node share a common console.assert interface, console.assert(assertion, ...);
 * In Node, console.assert throws AssertionError if its assertion is falsy.
 * In browsers, they print to the console.
 * Extend browser behaviour to also throw.
 */

if (false) {
  var internalAssert;
  if (BUILD_ENV.TARGET_NODE) {
    // eslint-disable-next-line no-console
    internalAssert = console.assert;
  } else {
    internalAssert = function browserAssert(assertion) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      if (!assertion) {
        throw new Error(("Assertion error: " + (typeof assertion) + " " + assertion + " (" + (args.join(' ')) + ")"));
      }
    };
  }
  // Now, wrap the assert in a catch and rethrow to give us a single place
  // to set assert breakpoints.
  assert = function outerAssert() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    try {
      internalAssert.apply(void 0, args);
    } catch (e) {
      // if (BUILD_ENV.MODE_DEBUG) debugger;
      throw (e);
    }
  };
} else {
  // In production mode, asserts are generally disabled.
  assert = function () {};
}

module.exports.assert = assert;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

/**
 * @private
 */
var BidiMap = function BidiMap() {
  var this$1 = this;
  var pairs = [], len = arguments.length;
  while ( len-- ) pairs[ len ] = arguments[ len ];

  this.forward = new Map();
  this.reverse = new Map();
  pairs.forEach(function (p) {
    this$1.setValues(p[0], p[1]);
  });
};

/**
 * Sets the key => value and value => key relationships for the supplied parameters.
 *
 * Method name is #set, not #put, for alignment with ES map method names.
 * @param {*} key The key for the forward mapping (value in the reverse mapping)
 * @param {*} value The value for the forward mapping (key in the reverse mapping)
 */
BidiMap.prototype.setValues = function setValues (key, value) {
  this.forward.set(key, value);
  this.reverse.set(value, key);
};

module.exports.BidiMap = BidiMap;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

function enumName(instance, keys, value) {
  var matches = keys.filter(function (k) { return instance[k] === value; });
  return matches.length ? matches[0] : null;
}

function enumValues(instance, keys) {
  return Array.from(new Set(keys.map(function (k) { return instance[k]; })));
}

/**
 * The base for all enumerated types. Provides common functionality such as
 * collections of keys and values, reverse mapping, and readable descriptions. Also
 * supports overriding the canonical key-value mapping to maintain readability in
 * minified environments.
 *
 * @mixin
 * @memberof solace
 */
var Enum = function Enum(values) {
  Object.defineProperties(this, {
    _canonical: {
      value:      null,
      enumerable: false,
      writable:   true,
      configurable: true,
    },
  });
  this._setCanonical(values);
};

var prototypeAccessors = { names: {},values: {},isEnum: {} };

/**
 * Resets the canonical key value mapping for the enumeration. Using this method,
 * you add additional sets of keys that map to the same values, and specify that
 * these new keys take precedence for reverse mapping. Any older set of keys is made
 * non-canonical and non-enumerable.
 *
 * @example
 * const c = new Enum({ HELLO: 'world' });
 * c._setCanonical({ MAD: 'world' });
 * c.nameOf('world') === 'MAD'; // true
 *
 * @param {Object} values The new key-value mapping to add to the object and set as canonical.
 * @param {Boolean} final Whether this enumeration should accept further reconfiguration.
 * @private
 */
Enum.prototype._setCanonical = function _setCanonical (values, final) {
    var this$1 = this;
    if ( final === void 0 ) final = false;

  this._canonical = Object.assign({}, values);
  Object.keys(this).forEach(function (key) {
    var descriptor = Object.getOwnPropertyDescriptor(this$1, key);
    if (descriptor.value !== undefined) {
      Object.defineProperty(this$1, key, {
        enumerable: false,
        writable:   true,
        configurable: true,
        value:      descriptor.value,
      });
    }
  });
  Object.keys(values).forEach(function (key) {
    Object.defineProperty(this$1, key, {
      enumerable: true,
      writable:   !final,
      configurable: !final,
      value:      values[key],
    });
  });
};

/**
 * Create a human-readable string describing the given enumeration value. This
 * result is informational and may vary between SDK versions.
 *
 * Currently, it either returns the value provided (if the associated key is
 * the same), or a string of the form `key (value)`.
 *
 * @example
 * console.log(new Enum({ ANSWER: 42 }).describe(42)); // ANSWER (42)
 * console.log(new Enum({ ECHO: 'ECHO' })).describe('ECHO'); // ECHO
 *
 * @param {any} enumValue The value on which to perform reverse mapping.
 * @param {String} [noneValue=''] The string to return if the enumeration value is
 *  undefined or null.
 * @param {String} [unknownValue='<unknown>'] The string to return if the enumeration
 *  value was not found in any of the canonical keys.
 * @returns {String} A human-readable description of the reverse mapping for the value.
 */
Enum.prototype.describe = function describe (enumValue, noneValue, unknownValue) {
    if ( noneValue === void 0 ) noneValue = '<none>';
    if ( unknownValue === void 0 ) unknownValue = '<unknown>';

  if (enumValue === null || enumValue === undefined) { return noneValue; }
  var name = enumName(this._canonical,
                        Object.keys(this._canonical || {}),
                        enumValue)
               || unknownValue;
  return name === enumValue ? name : (name + " (" + enumValue + ")");
};

/**
 * Returns the canonical name in this enumeration for the given value. This function is
 * designed to facilitate reflection, whereas for display
 *
 * @param {any} enumValue The value for which to get the enumeration key.
 * @returns {String} The name for the given value.
 */
Enum.prototype.nameOf = function nameOf (enumValue) {
  return enumName(this._canonical, Object.keys(this._canonical || {}), enumValue);
};

/**
 * Returns all canonical names/keys in this enumeration.
 *
 * @readonly
 * @returns {Array.<String>} All canonical names in this enumeration.
 */
prototypeAccessors.names.get = function () {
  return Object.keys(this._canonical || {});
};

/**
 * Returns all values assigned to canonical keys in this enumeration.
 *
 * @readonly
 * @returns {Array} All values defined for enumeration keys.
 */
prototypeAccessors.values.get = function () {
  return enumValues(this._canonical, Object.keys(this._canonical || {}));
};

/**
 * A property returning true to faciliate duck-typing with {solace.Enum} objects.
 *
 * @readonly
 * @returns {Boolean} true This is an enumeration.
 */
prototypeAccessors.isEnum.get = function () { // eslint-disable-line class-methods-use-this
  return true;
};

/**
 * Returns the name of an enuerated value given the
 * enumeration and the value.
 *
 * @param {Object} instance The enumeration instance.
 * @param {*} value The value for which to return the key name.
 * @returns {String} The key name for the given enumeration value.
 */
Enum.nameOf = function nameOf (instance, value) {
  return instance.nameOf(value);
};

/**
 * Returns values defined on this enumeration for the given keys. To get the enumeration keys,
 * use {@link Object#keys}.
 * @param {Object} instance The enumeration on which to return values.
 * @returns {Array} The values defined on the given enumeration.
 **/
Enum.values = function values (instance) {
  return instance.values();
};

/**
 * Alternate construction method for enumerations.
 *
 * @static
 * @param {Object} values Initial key-value mapping
 * @returns {solace.Enum} A new enumeration instance
 * @private
 */
Enum.new = function new$1 (values) {
  return new Enum(values);
};

/**
 * Constructs a private enumeration in which the values are equal to the keys.
 *
 * @static
 * @param {Array.<String>} strings Key names. The values will be equal to the keys.
 * @returns {solace.Enum} An enumeration instance of the given strings
 * @private
 */
Enum.ofStrings = function ofStrings (strings) {
  var map = {};
  strings.forEach(function (s) {
    map[s] = s;
  });
  return Enum.new(map);
};

/**
 * Constructs an enumeration in which each key is assigned a distinct integer value.
 * Enums created this way are subject to renumbering if keys are reordered.
 *
 * @static
 * @param {Array.<String>} keys Key names. The values will be sequential from zero.
 * @returns {solace.Enum} An enumeration instance of the given values
 * @private
 */
Enum.ofNumbers = function ofNumbers (keys) {
  var map = {};
  keys.forEach(function (key, index) {
    map[key] = index;
  });
  return Enum.new(map);
};

Object.defineProperties( Enum.prototype, prototypeAccessors );

module.exports.Enum = Enum;


/***/ }),
/* 169 */
/***/ (function(module, exports) {

/**
 * An object managing a traversal of an Array-like object.
 *
 * @memberof solace
 * @property {function} deref Returns the value the iterator is
 *      referencing.
 * @property {function} incr Increments the iterator's reference in the
 *      iterator's data set.
 * @property {function} end Tests whether the iterator is at the end of
 *      the data set.  This MUST return false when calling deref() or
 *      incr().
 * @private
 */
var Iterator = function Iterator(arr, start, end) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = arr.length;

  /**
   * The array being iterated.
   * @type {Array}
   * @private
   */
  this._arr = arr;
  /**
   * The current index of the enumeration.
   * @private
   * @type {Number}
   */
  this._index = start;
  /**
   * The exclusive end index, or the length, of the array.
   * @type {Number}
   */
  this._end = end;
};

/**
 * Returns the element at the iterator's position.
 * @returns {Object} The array element at the current position.
 */
Iterator.prototype.deref = function deref () {
  return this._arr[this._index];
};

/**
 * Increments the iterator.
 * @returns {Number} The new position of the iterator.
 */
Iterator.prototype.incr = function incr () {
  return ++this._index;
};

/**
 * Reports whether the iterator has completed its iteration.
 * @returns {Boolean} True if the iterator has reached the end of the iteration.
 */
Iterator.prototype.end = function end () {
  return this._index >= this._end;
};

/**
 * Creates an iterator to forward iterate over a specific contiguous
 * section of an array, specifically in the range [start, end)
 *
 * @param {Array} arr The array to iterate over
 * @param {Number} [start=0] The first item the iterator should
 *dereference
 * @param {Number} [end=arr.length] One beyond the last item in the array
 *that the iterator should dereference.
 * @returns {solace.Iterator} An iterator to the specified set of data.
 */
Iterator.makeIterator = function makeIterator (arr, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = arr.length;

  return new Iterator(arr, start, end);
};

// Expose both the static constructor function and the class.
module.exports.Iterator = Iterator;


/***/ }),
/* 170 */
/***/ (function(module, exports) {


// Avoid closure compiler nonsense
module.exports.makeMap = function makeMap() {
  var keyValuePairs = [], len = arguments.length;
  while ( len-- ) keyValuePairs[ len ] = arguments[ len ];

  var result = {};
  for (var i = 0; i < keyValuePairs.length; i += 2) {
    result[keyValuePairs[i]] = keyValuePairs[i + 1];
  }
  return result;
};


/***/ }),
/* 171 */
/***/ (function(module, exports) {

var Mixin = {
  /**
   * @param  {Object} target The class to augment
   * @param  {Object} add The class to mix in.
   * @returns {Object} The augmented class
   */
  mixin: function mixin(target, add) {
    var targetProto = target.prototype;
    var addProto = add.prototype;
    Object.getOwnPropertyNames(addProto).forEach(function (name) {
      if (name === 'constructor') { return; }
      Object.defineProperty(targetProto, name, Object.getOwnPropertyDescriptor(addProto, name));
    });
    return target;
  },
};

module.exports.Mixin = Mixin;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(90);
var Lazy = ref.Lazy;

var lazyProperty = Lazy.lazyProperty;

function traversePath(commonSource, keySource, pathArr) {
  return pathArr.reduce(function (source, value) {
    if (typeof value === 'string') {
      return source[value];
    }
    return value;
  }, keySource);
}

/**
 * @classdesc
 * Deferred resolution for imports. A heavyweight method of breaking circular dependencies.
 * Each specified key (see below) is resolved once by a function that lazily evaluates a
 * path.
 * <pre>
 * const resolved = new Resolver({
 *  foo: [FooLib, 'fooContainer'],        // Resolves foo from FooLib.fooContainer.foo lazily
 *  bar: ['foo'],                         // Resolves bar from previously defined foo lazily
 *  'baz,quux': [FooLib, 'bazsAndQuuxes'] // baz = FooLib.bazsAndQuuxes.baz,
 *                                        // quux = FooLib.bazsAndQuuxes.quux
 * });
 * </pre>
 * In most cases this is equivalent to using FooLib.fooContainer.foo, et cetera, directly.
 * Prefer that approach unless the dependencies are deeply hierarchical. Prefer the Resolver
 * when one-time evaluation and aliasing a path makes the code more DRY and readable.
 * @private
 */
var Resolver = function Resolver(options, source) {
  var this$1 = this;

  // For every key...
  Object.keys(options).forEach(function (compoundKey) {
    // Split out key names if multiple were provided
    compoundKey.split(',').map(function (k) { return k.trim(); }).forEach(function (key) {
      // Build a path array. The key name is the implicit last element.
      var rawPath = options[compoundKey];
      var path = typeof rawPath === 'string' ? rawPath.split('.') : rawPath;
      var pathArr = (Array.isArray(path) ? path : [path]).concat(key);
      // Create a defer for this key.
      lazyProperty(this$1, key, function () { return traversePath(source, this$1, pathArr); });
    });
  });
};

Resolver.resolve = function resolve (options, source) {
  return new Resolver(options, source);
};


module.exports.Resolver = Resolver;


/***/ }),
/* 173 */
/***/ (function(module, exports) {

/* eslint-disable no-restricted-syntax */

function isSuperset(set, subset) {
  return Array.from(subset).every(function (elem) { return set.has(elem); });
}

function inplaceUnion(setA, setB) {
  setB.forEach(function (elem) {
    setA.add(elem);
  });
  return setA;
}

function union(setA, setB) {
  return inplaceUnion(new Set(setA), setB);
}

function inplaceIntersection(setA, setB) {
  setA.forEach(function (elem) {
    if (!setB.has(elem)) {
      setA.delete(elem);
    }
  });
  return setA;
}

function intersection(setA, setB) {
  return new Set(Array.from(setA).filter(function (elem) { return setB.has(elem); }));
}

function inplaceDifference(setA, setB) {
  setB.forEach(function (elem) {
    setA.delete(elem);
  });
  return setA;
}

function difference(setA, setB) {
  return new Set(Array.from(setA).filter(function (elem) { return !setB.has(elem); }));
}

module.exports = {
  SetOperations: {
    inplaceDifference: inplaceDifference,
    inplaceIntersection: inplaceIntersection,
    inplaceUnion: inplaceUnion,
    isSuperset: isSuperset,
    difference: difference,
    intersection: intersection,
    union: union,
  },
}
;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var NodeEventEmitter = __webpack_require__(285).EventEmitter;
var ref = __webpack_require__(4);
var ArrayUtils = ref.ArrayUtils;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;
var ref$2 = __webpack_require__(1);
var LOG_WARN = ref$2.LOG_WARN;

var flatten = ArrayUtils.flatten;
var includes = ArrayUtils.includes;
var NODE_DEFAULT_EVENTS = ['error', 'newListener', 'removeListener'];
var BLACKLIST_DIRECT = ['newListener', 'removeListener'];

function buildFilter(emits) {
  if (typeof emits === 'function') { return function (k) { return includes(NODE_DEFAULT_EVENTS, k) || emits(k); }; }
  if (!Array.isArray(emits)) { return null; }
  var emitSet = new Set(flatten(emits));
  NODE_DEFAULT_EVENTS.forEach(function (el) { return emitSet.add(el); });
  var emitArray = Array.from(emitSet);
  return function (k) { return includes(emitArray, k); };
}

var DISABLED_ACTIONS = {
  ignore: function ignore() {},
  fail: function fail() {
    throw new Error('Emitter disabled');
  },
};

var EventEmitter = (function (NodeEventEmitter) {
  function EventEmitter(options) {
    NodeEventEmitter.call(this);
    var ref = options || {};
    var direct = ref.direct;
    var emits = ref.emits;
    var unsafe = ref.unsafe;
    var formatEventName = ref.formatEventName;
    this.formatEventName = formatEventName || (function (name) { return name; });

    // Direct mode path:
    //  emit --> (direct emit || bareEmit).
    var bareEmit = this.emit.bind(this);
    this._installDirectFilter(direct, bareEmit);

    // Indirect mode path:
    //  verifier -> error handlers -> emit --> bareEmit
    this._installErrorHandlers(unsafe);
    this._installEmitVerifier();

    this._listenerVerificationFilter = buildFilter(emits);
    this._emits = emits;
  }

  if ( NodeEventEmitter ) EventEmitter.__proto__ = NodeEventEmitter;
  EventEmitter.prototype = Object.create( NodeEventEmitter && NodeEventEmitter.prototype );
  EventEmitter.prototype.constructor = EventEmitter;

  var prototypeAccessors = { isDirect: {} };

  EventEmitter.prototype._installDirectFilter = function _installDirectFilter (direct, bareEmit) {
    var this$1 = this;

    if (!direct) { return; }
      // Direct mode class instance modifications

    if (includes(BLACKLIST_DIRECT, direct)) {
      throw new OperationError(
        ("Cannot configure listener collection events [" + (BLACKLIST_DIRECT.join(', ')) + "] as direct"),
        ErrorSubcode.INTERNAL_ERROR);
    }

    // The default direct emitter is the base emitter. Skip any overrides we installed.
    this._defaultEmitDirect = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return bareEmit.apply(void 0, [ direct ].concat( args ));
    };

    // Initally not direct for 0 listeners
    this.emitDirect = this._defaultEmitDirect;
    this._directEventName = direct;

    this.on = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.on.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, true, listener);
      return ret;
    };

    this.addListener = function (eventName, listener) { return this$1.on(eventName, listener); };

    this.once = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.once.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, false);
      return ret;
    };

    this.prependListener = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.prependListener.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, true, listener);
      return ret;
    };

    this.prependOnceListener = function (eventName, listener) {
      this$1._verifyListenerEvent(eventName);
      var ret = NodeEventEmitter.prototype.prependOnceListener.call(this$1, eventName, listener);
      this$1._setEmitDirect(eventName, false);
      return ret;
    };

    this.removeAllListeners = function (eventName) {
      var ret = NodeEventEmitter.prototype.removeAllListeners.call(this$1, eventName);
      if ((eventName === this$1._directEventName) || (eventName === undefined)) {
        this$1.emitDirect = this$1._defaultEmitDirect;
      }
      return ret;
    };

    this.removeListener = function (eventName, listener) {
      var ret = NodeEventEmitter.prototype.removeListener.call(this$1, eventName, listener);
      if ((eventName === this$1._directEventName) && (this$1.listenerCount(eventName) === 0)) {
        this$1.emitDirect = this$1._defaultEmitDirect;
      }
      return ret;
    };

    this.directListenerCount = function () { return this$1.listenerCount(this$1._directEventName); };

    this.setOnFirstDirectListener = function (firstDirect) {
      this$1._onFirstDirectListener = firstDirect;
    };
  };

  EventEmitter.prototype._setEmitDirect = function _setEmitDirect (eventName, onListener, listener) {
    if (eventName !== this._directEventName) {
      return;
    }

    if (onListener && (this.directListenerCount() === 1)) {
      this.emitDirect = listener;
    } else {
      this.emitDirect = this._defaultEmitDirect;
    }

    if ((this.directListenerCount() === 1) && (this._onFirstDirectListener !== undefined)) {
      this._onFirstDirectListener();
    }
  };

  EventEmitter.prototype._verifyListenerEvent = function _verifyListenerEvent (event) {
    if (!this._listenerVerificationFilter) { return; }

    if (event === undefined || event === null) {
      this.throwInternal(
          new OperationError(("Emitter rejects listener for no-name event: " + event),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE));
    }
    if (!this._listenerVerificationFilter(event)) {
      this.throwInternal(
        new OperationError(("Emitter rejects listeners for " + event + ", emits " + (this._emits)),
                            ErrorSubcode.PARAMETER_OUT_OF_RANGE));
    }
  };

  EventEmitter.prototype._installEmitVerifier = function _installEmitVerifier () {
    var this$1 = this;

    if (false) {
      // Debug mode: always add assert for empty event name
      var emitBase = this.emit.bind(this);
      this.emit = function (name) {
        var args = [], len = arguments.length - 1;
        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

        if (name === undefined || name === null) {
          this$1.throwInternal(new OperationError(("Emitter rejects no-name event: " + name)));
        }
        emitBase.apply(void 0, [ name ].concat( args ));
      };
    }
  };

  EventEmitter.prototype._installErrorHandlers = function _installErrorHandlers (unsafe) {
    var this$1 = this;

    if (unsafe) {
      // If unsafe, there's no try/catch/emit so throwInternal just throws
      this.throwInternal = function (err) { throw err; };
      return;
    }

    // Install try/catch/emit-as-event if not unsafe mode.
    // Introduces throwInternal, which sets the _internalError flag restore
    // orignal throw-to-emitter functionality in case of internal error

    var emitBase = this.emit.bind(this);

    this.throwInternal = function throwInternal(err) {
      this._internalError = true;
      throw err;
    };

    this.emit = function (name) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      try {
        emitBase.apply(void 0, [ name ].concat( args ));
      } catch (ex) {
        if (this$1._internalError) {
          this$1._internalError = undefined;
          throw ex; // rethrow
        }

        var err = (ref = this$1).formatErrorEvent.apply(ref, [ ex, name ].concat( args ));
        try {
          LOG_WARN(("Listener for '" + (err.info.event.formattedName) + "' threw exception, dispatching to 'error'"));
          emitBase('error', err);
        } catch (innerEx) {
          LOG_WARN("Listener for 'error' threw exception:", innerEx, '\nOriginal exception:', ex);
        }
      }
      var ref;
    };
  };

  prototypeAccessors.isDirect.get = function () {
    return this.emitDirect && (this.emitDirect !== this._defaultEmitDirect);
  };

  EventEmitter.prototype.formatErrorEvent = function formatErrorEvent (ex, name) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

    var formattedName = this.formatEventName(name);
    return Object.assign(new OperationError(
      ("Unhandled error in event handler for '" + formattedName + "'"),
      ErrorSubcode.CALLBACK_ERROR,
      ("On event: " + ([name ].concat( args)) + " " + ex)
    ), {
      stack: ex.stack,
      info:  {
        event: { name: name, formattedName: formattedName, args: args },
        error: ex,
      },
    });
  };

  EventEmitter.prototype.disableEmitter = function disableEmitter () {
    this._defaultEmitDirect = DISABLED_ACTIONS.ignore;
    // If this is a direct-enabled emitter, this will also cause emitDirect to be set to
    // _defaultEmitDirect, which is now DISALBED_ACTIONS.ignore.
    this.removeAllListeners();
    this.emit = DISABLED_ACTIONS.ignore;
    // Freeze listeners by first disabling remove, then add.
    this.addListener('removeListener', DISABLED_ACTIONS.fail);
    this.addListener('newListener', DISABLED_ACTIONS.fail);
  };

  Object.defineProperties( EventEmitter.prototype, prototypeAccessors );

  return EventEmitter;
}(NodeEventEmitter));

module.exports.EventEmitter = EventEmitter;


/***/ }),
/* 175 */
/***/ (function(module, exports) {

/**
 * @private
 */
var Timer = function Timer(cancel) {
  var this$1 = this;

  this.cancel = function () {
    this$1.cancel = function () {}; // change to no-op
    cancel();
  };
};

/**
 * @static
 * @param {Number} interval The interval for the timer, in milliseconds.
 * @param {function} onInterval The function to invoke on expiration.
 * @param {any} [args] Any arguments to pass to the onExpire callback.
 * @returns {Timer} A new timer object.
 */
Timer.newInterval = function newInterval (interval, onInterval) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

  var timerRef = setInterval.apply(void 0, [ onInterval, interval ].concat( args ));
  return new Timer(function () { return clearInterval(timerRef); });
};

/**
 * @static
 * @param {Number} timeout The timeout for the timer, in milliseconds.
 * @param {function} onExpire The function to invoke on expiration.
 * @param {any} [args] Any arguments to pass to the onExpire callback.
 * @returns {Timer} A new timer object.
 */
Timer.newTimeout = function newTimeout (timeout, onExpire) {
    var args = [], len = arguments.length - 2;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];

  var timerRef = setTimeout.apply(void 0, [ onExpire, timeout ].concat( args ));
  return new Timer(function () { return clearTimeout(timerRef); });
};

module.exports.Timer = Timer;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(92);
var FactoryProfile = ref$1.FactoryProfile;
var SolclientFactoryProfiles = ref$1.SolclientFactoryProfiles;
var ref$2 = __webpack_require__(7);
var Parameter = ref$2.Parameter;
var ref$3 = __webpack_require__(91);
var ProfileBinding = ref$3.ProfileBinding;
var ref$4 = __webpack_require__(93);
var SolclientFactoryProperties = ref$4.SolclientFactoryProperties;

var factoryState = {
  initializeCount: 0,
  initializers:    [],
};
/**
 * @global
 * @name solClientJS
 * @description
 * <b>solClientJS</b> is a full functioned Solace Messaging API written entirely in JavaScript.
 * Applications using the <i>solClientJS</i> API can access all the features of a
 * Solace Message Router.
 *
 * The API is intended for use by applications written in JavaScript, targetting
 * either <b>NODE</b> or a traditional web browser.
 *
 * All classes, objects, methods of the API are encapsulated in the {@link solace} namespace.
 * The starting point for all applications is {@link solace.SolclientFactory}. This factory object
 * generates the {@link solace.Session} for connecting to the Solace Message Router.
 * {@link solace.SolclientFactory} also generates the {@link solace.Message} object
 * which enncapsulates the messages and {@link solace.Destination} the application will use
 * to send and receive data.
 * @summary The Solace Message Router Messaging API for Javascript.
 */

/**
 * A singleton used as the main factory for the messaging APIs. The very first operation by
 * any application must be to initialize the API:
 * * @link solace.SolclientFactory#init}
 *
 * <i>SolclientFactory</i> provides methods to construct:
 * * {@link solace.Session}
 * * {@link solace.Message}
 * * {@link solace.Destination}
 *
 * Additionally <i>SolclientFactory</i> manages the
 * logging level in the API.
 * @namespace
 * @public
 * @memberof solace
 */
var SolclientFactory = {

  /**
   * Adds a function to be called on factory initialization
   * @param {function(factoryProps, factoryState)} func initializer function to be called
   * @internal
   */
  addInitializer: function addInitializer(func) {
    factoryState.initializers.push(func);
  },

  /**
   * @param {function} func function to wrap
   * @returns {function} new factory method
   * @internal
   */
  createFactory: function createFactory(func) {
    return function factoryMethod() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (factoryState.initializeCount === 0) {
        throw new OperationError('SolclientFactory not initialized', ErrorSubcode.INVALID_OPERATION);
      }
      return func.apply(void 0, args);
    };
  },

  /**
   * Initialize global properties. This function must be called before any other API call is made.
   *
   * Note: After the first call to this method, subsequent calls have no effect.
   *
   * @param {solace.SolclientFactoryProperties} [factoryProps] The initialization properties for
   *  the factory, if required.
   * @param {solace.LogImpl} [factoryProps.logger] A logging implementation
   * @param {solace.LogLevel}[factoryProps.logLevel] The logging level to use
   *  for filtering log events.
   * @param {solace.SolclientFactoryProfiles}
   *  [factoryProps.profile=solace.SolclientFactoryProfiles.version7]
   *     The factory profile. This class cannot be created by an API user; choose one of the static
   *     instances from {@link solace.SolclientFactoryProfiles}.
   * @throws {solace.OperationError} Invalid logger implementation
   * @returns {solace.SolclientFactory} For method chaining
   */
  init: function init(factoryProps) {
    var this$1 = this;

    if (factoryState.initializeCount > 0) {
      return this;
    }

    var props = new SolclientFactoryProperties(factoryProps);
    var profile = factoryProps && factoryProps.profile || SolclientFactoryProfiles.version7;
    Parameter.isInstanceOf('factoryProps.profile', profile, FactoryProfile);
    ProfileBinding.value = profile;

    factoryState.initializers.forEach(function (initializer) {
      initializer.call(this$1, props, factoryState);
    });
    ++factoryState.initializeCount;

    if ((factoryProps !== undefined) && (factoryProps !== null)) {
      // Factory should not depend on other packages at file scope
      // eslint-disable-next-line global-require
      var ref = __webpack_require__(1);
      var LOG_DEBUG = ref.LOG_DEBUG;
      /* #stripped LOG_DEBUG('Factory properties:\n', factoryProps) */

    }
    return this;
  },

  /**
   * @private
   */
  reset: function reset() {
    factoryState.initializeCount = 0;
  },


  /**
   * @returns {Number} Count of factory initializations.
   *    Nonzero means cannot be initialized again.
   * @internal
   */
  _getInitializeCount: function _getInitializeCount() {
    return factoryState.initializeCount;
  },

  /**
   * @private
   * @name solace.SolclientFactory.profiles
   * @type {solace.SolclientFactoryProfiles}
   * @readonly
   * @description The collection of {@link solace.FactoryProfile}. See a description of
   * each in {@link solace.SolclientFactoryProfiles}.
   */
  get profiles() {
    return SolclientFactoryProfiles;
  },
};

module.exports.SolclientFactory = SolclientFactory;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var NotImplementedError = ref.NotImplementedError;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(35);
var EventEmitter = ref$1.EventEmitter;
var ref$2 = __webpack_require__(94);
var FlowOperation = ref$2.FlowOperation;
var ref$3 = __webpack_require__(1);
var LogFormatter = ref$3.LogFormatter;
var ref$4 = __webpack_require__(95);
var PrivateFlowEventName = ref$4.PrivateFlowEventName;
var ref$5 = __webpack_require__(19);
var Stats = ref$5.Stats;

// Unless flow is disposed, these operations are always allowed
var ALWAYS_OPS = [
  FlowOperation.DISPOSE,
  FlowOperation.GET_STATS,
  FlowOperation.GET_PROPERTIES,
  FlowOperation.RESET_STATS ];


/**
 * @classdesc Flow
 * * <b>This class is not exposed for construction by API users.</b>
 * A Flow is an abstract base class. A Flow represents a guaranteed message connection to the
 * Solace Message Router. There may be many Guaranteed Message
 * Consumers on a {@link solace.Session}, each
 * instantiated as a {@link solace.MessageConsumer}.
 * @memberof solace
 * @extends {solace.EventEmitter}
 * @private
 */
var Flow = (function (EventEmitter) {
  function Flow(flowProperties, sessionInterfaceFactory, emitterOptions) {
    var emitterOptionsFull = Object.assign({}, emitterOptions);
    emitterOptionsFull.emits = (emitterOptionsFull.emits || []).concat(
      PrivateFlowEventName.values
    );
    EventEmitter.call(this, emitterOptionsFull);
    var sessionInterface = sessionInterfaceFactory(this);
    var self = this;
    this.logger = new LogFormatter(function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return [("[session=" + (sessionInterface.sessionIdHex) + "]"), ("[flow=" + (self.flowIdDec) + "]") ].concat( args);
    });
    this.log = this.logger.wrap(this.log, this);
    this._disposed = false;
    this._userDisconnected = true;
    this._properties = flowProperties;
    this._sessionInterface = sessionInterface;
    this._stats = new Stats(sessionInterface);
    this._privateEventEmitter = new EventEmitter(emitterOptionsFull);
  }

  if ( EventEmitter ) Flow.__proto__ = EventEmitter;
  Flow.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Flow.prototype.constructor = Flow;

  var prototypeAccessors = { canAck: {},disposed: {},flowIdDec: {},flowId: {},session: {},userDisconnected: {} };

  // Private event emitter functions, hidden from the public interface.
  Flow.prototype._emit = function _emit (type) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    (ref = this._privateEventEmitter).emit.apply(ref, [ type ].concat( args ));
    (ref$1 = this).emit.apply(ref$1, [ type ].concat( args ));
    var ref;
    var ref$1;
  };
  Flow.prototype._on = function _on (type, listener) {
    this._privateEventEmitter.on(type, listener);
  };
  Flow.prototype._once = function _once (type, listener) {
    this._privateEventEmitter.once(type, listener);
  };
  Flow.prototype._removeListener = function _removeListener (type, listener) {
    this._privateEventEmitter.removeListener(type, listener);
  };

  /**
   * Clears all statistics for this Guaranteed Message Connection. All previous Guaranteed
   * Message Connection statistics are lost
   * when this is called.
   * @throws {solace.OperationError}
   *  * if the Message Consumer is disposed. subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  Flow.prototype.clearStats = function clearStats () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE('Clearing stats') */

    this._operationCheck(FlowOperation.RESET_STATS);
    this._stats.resetStats();
  };

  /**
   * Establish a Guaranteed Messaging connection.
   * The Messge Consumer may immediately begin emitting events. The application is expected to
   * add listeners for events on this Message Consumer before calling this method.
   */
  Flow.prototype.connect = function connect () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Connecting') */

    this.userDisconnected = false;
    this._operationCheck(FlowOperation.CONNECT);
  };

  /**
   * Disposes the Guaranteed Message connection, removing all listeners and releasing references.
   */
  Flow.prototype.dispose = function dispose () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;
    // The session may dispose the publisher or consumer, so be tolerant of
    // multiple attempts to do so.
    if (this._disposed) {
      /* #stripped LOG_TRACE('Ignoring #dispose on disposed Guaranteed Message connection') */

      return;
    }
    /* #stripped LOG_TRACE('Disposing') */


    this._operationCheck(FlowOperation.DISPOSE);

    this._properties = null;
    this._userDisconnected = true;
    this._disposed = true;
    var terminate = function () {
      this$1._emit(this$1.getDisposedEvent());
      this$1.disableEmitter();
      this$1._privateEventEmitter.disableEmitter();
      /* #stripped LOG_DEBUG('Disposed') */

    };
    if (this._fsm.isRunning()) {
      // Guard this in a timeout
      var terminateWithRunningFSM = function () {
        this$1._fsm.terminateFsm();
        terminate();
      };
      try {
        // Attempt to terminate synchronously
        // May throw if called from an event dispatch
        terminateWithRunningFSM();
      } catch (e) {
        // Terminate asynchronously
        setImmediate(function () { return terminateWithRunningFSM(); });
      }
    } else {
      terminate();
    }
  };

  /**
   * Disconnects the Message Consumer in such a way that it can be reconnected.
   */
  Flow.prototype.disconnect = function disconnect () {
    this._operationCheck(FlowOperation.DISCONNECT);
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Disconnecting') */

    this.userDisconnected = true;
  };

  /**
   *
   * Begins a disconnect that is not user-initiated.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
  Flow.prototype._disconnectSession = function _disconnectSession () {
    this._operationCheck(FlowOperation.DISCONNECT);
  };

  /**
   * Gets the event to be returned when the Consumer or Publisher is disposed.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
  Flow.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Abstract method');
  };

  /**
   * Creates and returns copy of the properties for this object.
   * @returns {?} The properties object
   * @internal
   */
  Flow.prototype.getProperties = function getProperties () {
    this._operationCheck(FlowOperation.GET_PROPERTIES);
    return this._properties.clone();
  };

  /**
   * Returns a statistic for this Guaranteed Message connection.
   *
   * @param {solace.StatType} statType The statistic to return.
   * @returns {Number} The value for the statistic.
   */
  Flow.prototype.getStat = function getStat (statType) {
    this._operationCheck(FlowOperation.GET_STATS);
    return this._stats.getStat(statType);
  };

  /**
   * @param {AdMessage} message The message to be handled by this Consumer or Publisher
   * @private
   */
  Flow.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Guaranteed Message Connection does not implement a control message handler', message);
  };

  /**
   * @param {StatType} statType The stat to increment
   * @param {Number} [value] The value to add to the statistic.
   * @private
   */
  Flow.prototype.incStat = function incStat (statType, value) {
    this._stats.incStat(statType, value);
  };

  /**
   * @param {any} event The event to be handled by this objects's FSM
   * @private
   */
  Flow.prototype.processFSMEvent = function processFSMEvent (event) {
    this._fsm.processEvent(event);
  };

  /**
   * @returns {String} An inspection of this object's properties
   * @private
   */
  Flow.prototype[util.inspect.custom] = function () {
    return {
      'flowId': this.flowIdDec,
    };
  };

  /**
   * @returns {String} A description of this Guaranteed Message Connection
   */
  Flow.prototype.toString = function toString () {
    return this.inspect();
  };

  /**
   * @returns {Boolean} Whether this Publisher or Consumer can be connected.
   * @readonly
   * @private
   */
  prototypeAccessors.canAck.get = function () {
    return !this.disposed;
  };

  /**
   * Returns true if this Guaranteed Message Consumer was disposed.
   */
  prototypeAccessors.disposed.get = function () {
    return this._disposed;
  };

  prototypeAccessors.flowIdDec.get = function () {
    return this.flowId || '(N/A)';
  };

  /**
   * @returns {Number} The ID for this flow
   * @readonly
   * @private
   */
  prototypeAccessors.flowId.get = function () { // eslint-disable-line class-methods-use-this
    return new NotImplementedError('Flow does not implement ID accessor');
  };

  /**
   * @returns {solace.Session} The owning session for this MessageConsumer.
   * @readonly
   */
  prototypeAccessors.session.get = function () {
    return this._session;
  };

  prototypeAccessors.userDisconnected.get = function () {
    return this._userDisconnecte;
  };
  prototypeAccessors.userDisconnected.set = function (value) {
    this._userDisconnected = value;
  };

  /**
   * @param {FlowOperation} operation The operation to check
   * @returns {Boolean} `true` if the operation is allowed.
   * @throws {@link solace.OperationError} if the operation is not allowed.
   * @private
   */
  Flow.prototype._operationCheck = function _operationCheck (operation) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE(`Checking operation ${FlowOperation.describe(operation)}`) */

    if (this._disposed) {
      throw new OperationError('Operation is invalid for Message Consumer in disposed state',
                               ErrorSubcode.INVALID_OPERATION);
    }

    // Any read-only operation is always valid unless the object was disposed
    // (which purges properties)
    if (ALWAYS_OPS.some(function (v) { return v === operation; })) { return true; }

    if (operation === FlowOperation.DISCONNECT && this._isDisconnected()) {
      throw new OperationError(
        'Operation is invalid for Message Consumer in disconnected state',
        ErrorSubcode.INVALID_OPERATION
      );
    }

    // TODO: additional validation
    // const fsmState = this._fsm.getCurrentState().getName();
    return undefined;
  };

  Flow.prototype._isDisconnected = function _isDisconnected () { // eslint-disable-line class-methods-use-this
    throw new NotImplementedError('Flow#_isDisconnected not implemented');
  };

  Object.defineProperties( Flow.prototype, prototypeAccessors );

  return Flow;
}(EventEmitter));

module.exports.Flow = Flow;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

/**
 * @classdesc
 * This object type represents an entryPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the entryPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @extends FsmObject
 * @private
 */
var EntryPoint = (function (FsmObject) {
  function EntryPoint(spec) {
    FsmObject.call(this, { name: spec.entryPointName });

    var innerState;
    this.impl = this.impl || {};
    // The outer portion of the entryPoint accepts incoming transitions before
    // entering the entryPoint's state.  Then the entryPoint's state is
    // entered through the use of the outerEntryPoint's initial transition.
    this.impl.outerState = new StateLib.State({
      name:          ((spec.state.getName()) + " outerEntryPoint: " + (spec.entryPointName)),
      parentContext: spec.state.getParent(),
    }).initial(function () { return spec.state.transitionTo(innerState); });

    // The job of the inner portion of the entryPoint is to follow a
    // transition as specified by the application's reaction function.
    innerState = new StateLib.State({
      name:          ((spec.state.getName()) + " innerEntryPoint: " + (spec.entryPointName)),
      parentContext: spec.state,
    }).initial(spec.func);
  }

  if ( FsmObject ) EntryPoint.__proto__ = FsmObject;
  EntryPoint.prototype = Object.create( FsmObject && FsmObject.prototype );
  EntryPoint.prototype.constructor = EntryPoint;

  /**
   * @returns {fsm.State} The destination state for a transition to the
   *      EntryPoint.
   */
  EntryPoint.prototype.getDestState = function getDestState () {
    return this.impl.outerState;
  };

  return EntryPoint;
}(FsmObject));

module.exports.EntryPoint = EntryPoint;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

var FsmEvent = (function (FsmObject) {
	function FsmEvent () {
		FsmObject.apply(this, arguments);
	}if ( FsmObject ) FsmEvent.__proto__ = FsmObject;
	FsmEvent.prototype = Object.create( FsmObject && FsmObject.prototype );
	FsmEvent.prototype.constructor = FsmEvent;

	

	return FsmEvent;
}(FsmObject));

module.exports.FsmEvent = FsmEvent;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var StateLib = __webpack_require__(27);
var ref = __webpack_require__(37);
var FsmObject = ref.FsmObject;

/**
 * @classdesc
 * This object type represents an exitPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the exitPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @private
 */
var ExitPoint = (function (FsmObject) {
  function ExitPoint(spec) {
    FsmObject.call(this, { name: spec.exitPointName });

    var outerState;
    // The inner portion of the exitPoint accepts incoming transitions before
    // exiting the exitPoint's state.  Then the exitPoint's state is exited
    // through the use of the innerExitPoint's initial transition.
    this.impl.innerState = new StateLib.State({
      name:          ((spec.state.getName()) + " innerExitPoint: " + (spec.exitPointName)),
      parentContext: spec.state,
    }).initial(function () { return spec.state.transitionTo(outerState); });

        // The job of the outer portion of the exitPoint is to follow a
        // transition as specified by the application's reaction function.
    outerState = new StateLib.State({
      name:          ((spec.state.getName()) + " outerExitPoint: " + (spec.exitPointName)),
      parentContext: spec.state.getParent(),
    }).initial(spec.func);
  }

  if ( FsmObject ) ExitPoint.__proto__ = FsmObject;
  ExitPoint.prototype = Object.create( FsmObject && FsmObject.prototype );
  ExitPoint.prototype.constructor = ExitPoint;

  ExitPoint.prototype.getDestState = function getDestState () {
    return this.impl.innerState;
  };

  return ExitPoint;
}(FsmObject));

module.exports.ExitPoint = ExitPoint;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(27);
var State = ref$1.State;
var ref$2 = __webpack_require__(96);
var StateContext = ref$2.StateContext;

/**
 * @classdesc
 * This is a state machine that can host states.  States themselves can also
 * host inner states in a hierarchical manner.  This class also provides the
 * basic interface for manipulating the current state via processing of
 * events, and querying the current state through 'getActiveState' methods.
 *
 * @private
 * @memberof solace
 */
var StateMachine = (function (StateContext) {
  function StateMachine(spec) {
    var this$1 = this;

    if (spec.parentContext) {
      throw new Error(("State machine cannot have parent state: " + (spec.parentContext)));
    }
    StateContext.call(this, spec);
    this.impl.ancestorList = [this];
    this.impl.eventQueue = [];
    this.impl.finalState = new State({ name: 'impl.final', parentContext: this });
    this.impl.handleUncaughtException = function (ev, exc) {
      LOG_ERROR(("Uncaught exception in " + (this$1) + " while processing " + ev + ": " + (exc.stack)));
      return this$1.terminate();
    };
  }

  if ( StateContext ) StateMachine.__proto__ = StateContext;
  StateMachine.prototype = Object.create( StateContext && StateContext.prototype );
  StateMachine.prototype.constructor = StateMachine;

  /**
   * This method enqueues the given function, and begins execution of queued functions if
   * they aren't already executing.
   * @param {Function} func The function to enqueue and execute.
   * @returns {Boolean} `true` if the supplied function has completed; false if it was deferred.
   */
  StateMachine.prototype.process = function process (func) {
    var this$1 = this;

    var ref = this;
    var impl = ref.impl;
    var eventQueue = impl.eventQueue;

    eventQueue.push(func);
    if (impl.processingEvents) {
      return false;
    }
    impl.processingEvents = true;

    while (eventQueue.length) {
      var evt = eventQueue.shift();
      evt.apply(this$1);
    }

    impl.processingEvents = false;
    this._onEventCompletion();
    return true;
  };

  /**
   * This method starts a state machine after it has been created and states
   * have been associated and configured any time getCurrentState() returns
   * undefined.  This would be after initial creation and after the state
   * machine has terminated (i.e. transitioned to the final state).
   */
  StateMachine.prototype.start = function start () {
    var this$1 = this;

    if (this.getCurrentState()) {
      throw new Error(("Cannot start " + (this.getName()) + "; it is already started."));
    }

    this.process(function () {
      var result = this$1.onInitial();

      // A state machine's onInitial must specify a destState, the state
      // cannot be the state machine itself, and the state must have the
      // state machine as the top ancestor.
      if (result.destState === undefined) {
        throw new Error(("Missing destination state from initial transition for " + (this$1)));
      }

      if (result.destState === this$1) {
        throw new Error(("Destination state for initial transition for " + (this$1) + " cannot be the FSM."));
      }

      var destAncestorList = result.destState.getAncestorList();
      if (destAncestorList[0] !== this$1) {
        throw new Error(("Invalid destination state (" + (result.destState) + ") from initial transition for state machine (" + (this$1) + "); destState ancestor (" + (destAncestorList[0]) + ")"));
      }

      this$1.impl.currentState = this$1.processReactionResult(result);
    });
  };

  /**
   * Used to query whether the state machine is currently running
   * @returns {Boolean} `true` if the state machine is processing events; false otherwise.
   */
  StateMachine.prototype.isRunning = function isRunning () {
    return this.impl.processingEvents;
  };

  /**
   * This is the main function to invoke an FSM with an event.
   * @param {FsmEvent} evt The event to be processed by the FSM.
   */
  StateMachine.prototype.processEvent = function processEvent (evt) {
    var this$1 = this;

    var ref = this;
    var impl = ref.impl;
    if (!this.process(function () {
      this$1.log(("Processing event " + evt));
      var result;
      if (impl.currentState) {
        try {
          result = impl.currentState.handleEvent(evt);
          impl.currentState = impl.currentState.processReactionResult(result, evt);
        } catch (exc) {
          this$1.log(("Caught exception " + exc + ", continuing"));
          result = impl.handleUncaughtException.call(impl.currentState,
                                                     evt,
                                                     exc);
          impl.currentState = impl.currentState.processReactionResult(result, evt);
        }
      }
    })) {
      // Didn't run immediately
      this.log(("Deferring event " + evt));
    }
  };

  /**
   * Terminates the FSM by transitioning the FSM to its final state. After
   * this returns, the FSM may be started again with @link start.  This method
   * should only be called externally from the FSM, not from within a reaction.
   * To terminate the FSM within a reaction, use the
   * {@link StateContext.ReactionResult} returned by {@link State#terminate}.
   */
  StateMachine.prototype.terminateFsm = function terminateFsm () {
    var this$1 = this;

    var curState = this.getCurrentState();
    if (!curState) {
      return;
    }
    if (this.impl.processingEvents) {
      throw new Error('Cannot terminate state machine while FSM is processing ' +
            'events. To terminate the FSM from within a reaction, return ' +
            'State~terminate() from a reaction.');
    }
    this.process(function () {
      var result = curState.terminate();
      this$1.impl.currentState = curState.processReactionResult(result);
    });
  };

  /**
   * This should only be called from within the context of a reaction
   * function, which is to say a function called by the FSM infrastructure
   * that returns {@link StateContext~ReactionResult}.  The purpose of this
   * function is to set a function to be called after the currently
   * executing event is completely handled, which includes the execution of
   * any events that have been or will be queued as a result of processing
   * the current event.
   *
   * Typical uses of this would be to set a function that does one of:
   * 1. Throws an exception to the caller.
   * 2. Calls an application callback.
   * @param {Function} postEventAction function to call when the FSM has finished
   *  processing events.  The context (i.e. 'this') will be the FSM when it
   *  is called.
   */
  StateMachine.prototype.setPostEventAction = function setPostEventAction (postEventAction) {
    if (!this.impl.processingEvents) {
      throw new Error('Cannot set post event hook unless FSM is processing events.');
    }
    if (!postEventAction || typeof postEventAction !== 'function') {
      // TBD: Do we need to allow clearing of the hook?  Not that
      // I'm aware of for the known use cases.  If we want to allow
      // it, I propose adding a 'clearPostEventAction' rather than
      // allowing null or undefined as the argument.
      throw new Error(("postEventAction must be a function; got (" + postEventAction + ")"));
    }
    this.impl.postEventAction = postEventAction.bind(this);
  };

  /**
   * Called by the FSM when it finishes processing events.  If a
   * postEventAction had been set, it will be called, then cleared.
   * @private
   */
  StateMachine.prototype._onEventCompletion = function _onEventCompletion () {
    var action = this.impl.postEventAction;
    if (action) {
      this.impl.postEventAction = undefined;
      this.log('Running post event action');
      action.apply(this);
    }
  };

  /**
   * Returns the innermost active state.
   *
   * If regions were implemented, this would return an iterator to innermost
   * active states.
   *
   * @returns {StateContext} The innermost active state.
   */
  StateMachine.prototype.getCurrentState = function getCurrentState () {
    return this.impl.currentState;
  };

  /**
   * Gets an active state by name.  Returns undefined if the named state is
   * not currently active.
   *
   * Note the returned state may not be the innermost state as returned by
   * {@link StateMachine#getCurrentState}.  If the innermost active state is not
   * returned, the returned state is guaranteed to contain the innermost active
   * state.
   *
   * @param {String} name The name of the state to be retrieved.
   * @returns {?StateContext} The state with the specified name, if the
   *      state is active; undefined otherwise.  Note the returned state may not
   *      be the innermost active state.
   */
  StateMachine.prototype.getActiveState = function getActiveState (name) {
    var activeStates = this.impl.currentState.getAncestorList();
    // Don't include the first ancestor in the loop since it is the state
    // machine itself, not a state.
    for (var i = 1; i < activeStates.length; ++i) {
      if (activeStates[i].getName() === name) {
        return activeStates[i];
      }
    }
    return undefined;
  };

  /**
   * Checks if the named state is currently active.
   * @param {String} name The name of the state to be queried.
   * @returns {Boolean} Whether or not the named state is active.
   */
  StateMachine.prototype.isStateActive = function isStateActive (name) {
    return this.getActiveState(name) !== undefined;
  };

  /**
   * Allows a reaction to be registered for unhandled events in the FSM.  The
   * default reaction is to log the unhandled event at debug and remain in the
   * current state with no other side effects.
   * @param {StateContext.reactionCallback} r The reaction to be invoked when an
   *      event is unhandled by the FSM.
   * @returns {StateMachine} This StateMachine object.
   */
  StateMachine.prototype.unhandledEventReaction = function unhandledEventReaction (r) {
    if (typeof r !== 'function') {
      throw new Error(("In " + (this) + ": unhandled event reaction must be a function; got " + r));
    }
    this.impl.handleUnhandledEvent = r.bind(this);
    return this;
  };

  /**
   * This allows a reaction to be registered for uncaught exceptions while
   * processing events.  Generally, it is preferred to catch exceptions from
   * within reaction functions.  However, this is a good way to safeguard
   * against missed exceptions.  Usually an error should be logged here,
   * which is the default behaviour.
   *
   * Also note that this is only called for either:
   * - an exception thrown from an event reaction;
   * - an exception thrown from a transition action
   * If exceptions are thrown from within state entry, exit, initials, etc,
   * this function is not invoked.  These functions may end up getting
   * invoked from the transition taken as a result of the exception in the
   * first place.  The generate another exception would be difficult to
   * handle in a sensible way.  Users of this infrastructure must always
   * catch exceptions from these functions.
   *
   * @param {fsm.StateContext.reactionCallback} r The reaction to be
   *      invoked when an exception has not been caught by another of the
   *      FSM's reactionCallbacks.  When this function is invoked, 'this'
   *      will be the FSM's current state.
   * @returns {StateMachine} `this`, for method chaining.
   */
  StateMachine.prototype.uncaughtExceptionReaction = function uncaughtExceptionReaction (r) {
    if (typeof r !== 'function') {
      throw new Error(("In " + (this) + ": Uncaught exception reaction must be a function; got " + r));
    }
    this.impl.handleUncaughtException = r;
    return this;
  };

  /**
   * Used by the implementation to get the final state.  This should never be
   * used by applications.  Their only need to reference this state should be
   * indirectly via the {@link State#terminate} function.
   * @returns {State} The FSM's final state, which is a hidden implementation
   *      detail of the FSM.
   * @protected
   */
  StateMachine.prototype.getFinalState = function getFinalState () {
    return this.impl.finalState;
  };

  return StateMachine;
}(StateContext));

module.exports.StateMachine = StateMachine;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(97);
var LogImpl = ref.LogImpl;

var STUB = function () { return undefined; };

function generateLogHeader(levelStr) {
  var date = new Date();
  var levelStrPadding = ' '.repeat(6 - levelStr.length);
  var YY = String(date.getFullYear());
  var MM = String(date.getMonth() + 1);
  var DD = String(date.getDate());
  var hh = String(date.getHours());
  var mm = String(date.getMinutes());
  var ss = String(date.getSeconds());
  var ms = String(date.getMilliseconds());

  YY = '0'.repeat(4 - YY.length) + YY;
  MM = MM.length < 2 ? ("0" + MM) : MM;
  DD = DD.length < 2 ? ("0" + DD) : DD;
  hh = hh.length < 2 ? ("0" + hh) : hh;
  mm = mm.length < 2 ? ("0" + mm) : mm;
  ss = ss.length < 2 ? ("0" + ss) : ss;
  ms = ms.length < 3 ? ("0" + ms) : ms;
  ms = ms.length < 3 ? ("0" + ms) : ms; // twice: pad to 3

  return [(YY + "-" + MM + "-" + DD + " " + hh + ":" + mm + ":" + ss + "." + ms), ("" + levelStr + levelStrPadding)];
}

/**
 * @classdesc
 * A log implementation that uses the global or window console.
 *
 * This is the default log implementation used by the API if no logger was
 * supplied via {@link solace.SolclientFactoryProperties}.
 *
 * @memberof solace
 * @private
 */
var ConsoleLogImpl = (function (LogImpl) {
  function ConsoleLogImpl(consoleIn) {
    /**
     * Logs the given arguments at TRACE level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#trace
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _trace = STUB;

    /**
     * Logs the given arguments at DEBUG level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#debug
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _debug = STUB;

    /**
     * Logs the given arguments at INFO level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#info
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _info = STUB;

    /**
     * Logs the given arguments at WARN level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.warn
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#warn
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _warn = STUB;


    /**
     * Logs the given arguments at ERROR level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#error
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _error = STUB;

    /**
     * Logs the given arguments at FATAL level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#fatal
     * @method
     * @param {...*} args Arguments to be logged
     */
    var _fatal = STUB;

    var console = consoleIn || (
      typeof window === 'undefined'
        /* eslint-env node */ ? global
        /* eslint-env browser */ : window
      ).console;
    /* eslint-env shared-node-browser */

    if (console && (console.log || console.warn)) {
      /* eslint-disable no-console */
      // Where console.log is supported, it is preferred over console.debug
      // https://developer.mozilla.org/en-US/docs/DOM/console
      // console methods in IE9 are object, not function, unfortunately
      //
      // Also, console.trace outputs a stack trace on some platforms.  So we
      // use the same underlying logger as debug for trace to avoid the
      // excessive verbosity that would result.
      if (console.log && console.log !== undefined) {
        _trace = Function.prototype.bind.call(console.log, console);
        _debug = Function.prototype.bind.call(console.log, console);
      } else if (console.debug && typeof console.debug === 'function') {
        _trace = Function.prototype.bind.call(console.debug, console);
        _debug = Function.prototype.bind.call(console.debug, console);
      }

      // Where console.info exists, it is preferred. Otherwise, fall back to
      // console.log.
      if (console.info && console.info !== undefined) {
        _info = Function.prototype.bind.call(console.info, console);
      } else {
        _info = Function.prototype.bind.call(console.log, console);
      }

      // Where console.warn exists, it is preferred. Otherwise, fall back to
      // console.log.
      if (console.warn && console.warn !== undefined) {
        _warn = Function.prototype.bind.call(console.warn, console);
      } else {
        _warn = Function.prototype.bind.call(console.log, console);
      }

      // Where console.error exists, it is preferred. Otherwise, fall back to
      // console.log.
      //
      // console.fatal is not present in any known console implementation. Use
      // console.error or console.log.
      if (console.error && console.error !== undefined) {
        _error = Function.prototype.bind.call(console.error, console);
        _fatal = Function.prototype.bind.call(console.error, console);
      } else {
        _error = Function.prototype.bind.call(console.log, console);
        _fatal = Function.prototype.bind.call(console.log, console);
      }

      /* eslint-enable no-console */
    } // else no console implementation was found, so the default (stub) is used for each level.

    LogImpl.call(this, function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];
 _trace.apply(void 0, generateLogHeader('TRACE').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _debug.apply(void 0, generateLogHeader('DEBUG').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _info.apply(void 0, generateLogHeader('INFO').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _warn.apply(void 0, generateLogHeader('WARN').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _error.apply(void 0, generateLogHeader('ERROR').concat( args )); },
          function () {
          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
 _fatal.apply(void 0, generateLogHeader('FATAL').concat( args )); });
  }

  if ( LogImpl ) ConsoleLogImpl.__proto__ = LogImpl;
  ConsoleLogImpl.prototype = Object.create( LogImpl && LogImpl.prototype );
  ConsoleLogImpl.prototype.constructor = ConsoleLogImpl;

  return ConsoleLogImpl;
}(LogImpl));

module.exports.ConsoleLogImpl = ConsoleLogImpl;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(98);
var LogLevel = ref.LogLevel;

var state = {
  impl:  null,
  level: LogLevel.INFO,
};

var LogBinding = {
  getImpl: function getImpl() {
    return state.impl;
  },

  setImpl: function setImpl(impl) {
    state.impl = impl;
  },

  getLogLevel: function getLogLevel() {
    return state.level;
  },

  setLogLevel: function setLogLevel(level) {
    state.level = level;
  },
};

module.exports.GlobalBinding = LogBinding;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;
var assert = ref.assert;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;

/**
 * @private
 */
var ApplicationAckState = Enum.new({
  UNACKED:        'UNACKED',
  ACKED_NOT_SENT: 'ACKED_NOT_SENT',
  ACKED_SENT:     'ACKED_SENT',
});

// For the ring buffer update index, we have two key-value options:
//  Map() - generally faster where supported
//  Object - seems to automatically coerce keys to string, which is what we want in this case
// By using Map and explicly creating a .key attribute and using it whenever possible,
// we should get performance that is no worse than Object, which may have to perform that
// coercion more often.

/**
 * @private
 */
var ApplicationAck = function ApplicationAck(id, state) {
  if (id) {
    this.exists = true;
    this.id = id;
    this.key = id.toString();
    this.state = state || ApplicationAckState.UNACKED;
  } else {
    this.exists = false;
  }
};

ApplicationAck.prototype.set = function set (id, state) {
  this.exists = true;
  this.id = id;
  this.key = id.toString();
  this.state = state || ApplicationAckState.UNACKED;
};

ApplicationAck.prototype.clear = function clear () {
  this.exists = false;
  this.id = null;
  this.key = null;
  this.state = null;
};

/**
 * @private
 */
var ApplicationAckRingBuffer = function ApplicationAckRingBuffer(size) {
  /* #stripped LOG_DEBUG('Creating application ack ring buffer with size ', size, ' retained size', size - 1) */

  assert(size >= 2); // one always free doesn't work with < 2 elements
  this._size = size;
  this._insertIndex = 0;
  /**
   * @property {Array.<?ApplicationAck>}
   */
  this._buffer = Array(size).fill(null).map(function () { return new ApplicationAck(); });
  /**
   * @property {Map.<String, Number>}
   */
  this._index = new Map();
};

var prototypeAccessors = { length: {} };

/**
 * @param {Long} id The id of the new entry
 * @param {function(ApplicationAck)} beforeEvictCallback Call this before operation completes
 * @returns {any} Return value of beforeEvictCallback
 * @private
 */
ApplicationAckRingBuffer.prototype.insert = function insert (id, beforeEvictCallback) {
  assert(beforeEvictCallback);
  assert(id);

  var size = this._size;
  var buffer = this._buffer;
  var index = this._index;
  var insertIndex = this._insertIndex;

  /*
   * Because of the postprocessing step, we are not re-entrant safe. It is expected
   * that we are called from TCP -> Transport -> Session -> acceptMessage().
   * This assert verifies that the postprocess cleanup has happened.
   */
  assert(!buffer[insertIndex].exists, 'Invariant not enforced (before): insert index not empty');

  // First, insert.
  var inserting = buffer[insertIndex];
  inserting.set(id, ApplicationAckState.UNACKED);
  index.set(inserting.key, insertIndex);

  var evictingIndex = (insertIndex + 1) % size;
  var evicting = buffer[evictingIndex];
  var result;
  try {
    result = beforeEvictCallback(evicting.exists ? evicting : null);
  } finally {
    // Always clean up to keep the RB in a consistent state.
    // If inProgressCallback threw, this runs before the exception propagates.

    // Update insert index for next operation.
    this._insertIndex = (insertIndex + 1) % size;

    if (evicting.exists) {
      index.delete(evicting.key);
      evicting.clear();
    }
  }

  assert(!buffer[this._insertIndex].exists, 'Invariant not enforced (after): insert index not empty');
  return result;
};

/**
 * Returns the number of elements in this ringbuffer. Will increase to
 * one less than the size provided to the constructor as the buffer is used.
 *
 * @readonly
 * @memberof ApplicationAckRingBuffer
 */
prototypeAccessors.length.get = function () {
  return this._index.size;
};

/**
 * Returns the first element in the ring buffer.
 *
 * This could be called from the evict callback, so insert needs to be sure
 * that internal state is correct for that scenario.
 *
 * The expected case is that the first element is at insertIndex + 1, but if the
 * buffer has not been filled yet, we will iterate the buffer and skip nonexistent
 * elements to find it.
 *
 * This is a little inefficient until we have received this._size messages, but after
 * that it is more efficient than maintaining a read pointer.
 *
 * @returns {?ApplicationAck} The first ack in the buffer.
 */
ApplicationAckRingBuffer.prototype.front = function front () {
  if (this.length === 0) { return null; }

  var buffer = this._buffer;
  var insertIndex = this._insertIndex;
  var size = this._size;
  var firstIndex = (insertIndex + 1) % size;
  // Cannot assert invariant here: insert is usually in progress.

  // Buffer full case
  if (buffer[firstIndex].exists) { return buffer[firstIndex]; }

  // Not yet filled case
  // The last checked element for the iteration is the start point,
  //plus size, a full lap including the start index,
  //minus 1, to exclude the start
  //minus 1, to exclude the invariant null entry
  for (var rawIndex = firstIndex, lastIndex = firstIndex + size - 1;
       rawIndex <= lastIndex;
       ++rawIndex) {
    var readIndex = rawIndex % size;
    var element = buffer[readIndex];
    if (element.exists) {
      return element;
    }
  }

  // Buffer is completely empty
  assert(this._index.size === 0, '#front() failed so buffer must be empty');
  return null;
};

/**
 * Rather than implementing the iterator protocol, which requires Symbol support,
 * we'll implement a forEach that behaves as though this is an array.
 *
 * @param {function(ApplicationAppState, index, collection)} callback The iteration callback
 */
ApplicationAckRingBuffer.prototype.forEach = function forEach (callback) {
    var this$1 = this;

  if (this.length === 0) { return; }

  var buffer = this._buffer;
  var size = this._size;
  var index = 0;

  for (var rawIndex = this._insertIndex + 1, lastIndex = this._insertIndex + size;
       rawIndex <= lastIndex;
       ++rawIndex) {
    var readIndex = rawIndex % size;
    var element = buffer[readIndex];
    if (element.exists) {
      callback(element, index++, this$1);
    }
  }

  assert(index > 0, 'Not empty but did not dispatch');
};

/**
 * @param {Long} id The ID to update
 * @param {ApplicationAckState} state The new state for the ID
 * @private
 */
ApplicationAckRingBuffer.prototype.updateAckState = function updateAckState (id, state) {
  var key = id.toString(); assert(this._index.has(key), 'Ack key not found');
  var buffer = this._buffer;
  var updateIndex = this._index.get(key);
  var existing = buffer[updateIndex]; assert(existing, 'Ack key has no entry');
  existing.state = state;
};

/**
 * @param {Long} id The ID to look up
 * @returns {Boolean} `true` if this ID exists in the ringbuffer
 */
ApplicationAckRingBuffer.prototype.has = function has (id) {
  var key = id.toString();
  return this._index.has(key);
};

Object.defineProperties( ApplicationAckRingBuffer.prototype, prototypeAccessors );

Object.assign(module.exports, {
  ApplicationAckState: ApplicationAckState,
  ApplicationAck: ApplicationAck,
  ApplicationAckRingBuffer: ApplicationAckRingBuffer,
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(101);
var MessageConsumer = ref$1.MessageConsumer;
var ref$2 = __webpack_require__(28);
var MessageConsumerEventName = ref$2.MessageConsumerEventName;

var ConsumerFlows = function ConsumerFlows() {
  this._allFlows = new Set();
  // Flows by id (UP)
  this._flowsById = {};
};

var prototypeAccessors = { flows: {} };

ConsumerFlows.prototype.add = function add (flow) {
    var this$1 = this;

  assert(flow instanceof MessageConsumer, 'Flow was not a consumer');
  if (this._allFlows.has(flow)) {
    return flow;
  }

  var flowUp = function () {
    // Don't worry about flow collisions -- the router assigned the new flow to the same ID
    // so it won't address the old flow. Retain the old flow in _allFlows and make sure we
    // dispose the right flow.
    this$1._flowsById[flow.flowId] = flow;
  };
  var flowDisposed = function () {
    var flowId = flow.flowId;
    this$1._allFlows.delete(flow);
    var flowById = this$1._flowsById[flowId];
    // If this test fails, the router reassigned the flow ID, and we were only keeping the
    // _allFlows set reference for blanket cleanup.
    if (flowById === flow) {
      delete this$1._flowsById[flowId];
    }
    // Flow will be disposed and this will happen automatically
  };

  flow._on(MessageConsumerEventName.UP, flowUp);
  flow._on(MessageConsumerEventName.DISPOSED, flowDisposed);

  this._allFlows.add(flow);
  return flow;
};

prototypeAccessors.flows.get = function () {
  return Array.from(this._allFlows);
};

ConsumerFlows.prototype.getFlowById = function getFlowById (flowId) {
  return this._flowsById[flowId];
};

ConsumerFlows.prototype.disposeAll = function disposeAll () {
  this._allFlows.forEach(function (flow) { return flow.dispose(); });
};

Object.defineProperties( ConsumerFlows.prototype, prototypeAccessors );

module.exports.ConsumerFlows = ConsumerFlows;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(184);
var ApplicationAck = ref.ApplicationAck;
var ApplicationAckRingBuffer = ref.ApplicationAckRingBuffer;
var ApplicationAckState = ref.ApplicationAckState;
var ref$1 = __webpack_require__(0);
var assert = ref$1.assert;
var ref$2 = __webpack_require__(21);
var CapabilityType = ref$2.CapabilityType;
var ref$3 = __webpack_require__(54);
var ConsumerFSMEvent = ref$3.ConsumerFSMEvent;
var ref$4 = __webpack_require__(53);
var ConsumerFSMEventNames = ref$4.ConsumerFSMEventNames;
var ref$5 = __webpack_require__(187);
var ConsumerStateNames = ref$5.ConsumerStateNames;
var ref$6 = __webpack_require__(5);
var DestinationFromNetwork = ref$6.DestinationFromNetwork;
var DestinationType = ref$6.DestinationType;
var Queue = ref$6.Queue;
var Topic = ref$6.Topic;
var ref$7 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$7.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$7.ErrorSubcode;
var OperationError = ref$7.OperationError;
var ref$8 = __webpack_require__(1);
var LogFormatter = ref$8.LogFormatter;
var ref$9 = __webpack_require__(3);
var Long = ref$9.Long;
var ref$10 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$10.MessageConsumerAcknowledgeMode;
var ref$11 = __webpack_require__(28);
var MessageConsumerEventName = ref$11.MessageConsumerEventName;
var ref$12 = __webpack_require__(189);
var MessageDispatcher = ref$12.MessageDispatcher;
var ref$13 = __webpack_require__(36);
var PrivateFlowEventName = ref$13.PrivateFlowEventName;
var ref$14 = __webpack_require__(18);
var QueueAccessType = ref$14.QueueAccessType;
var QueueDescriptor = ref$14.QueueDescriptor;
var QueueType = ref$14.QueueType;
var ref$15 = __webpack_require__(15);
var State = ref$15.State;
var StateMachine = ref$15.StateMachine;
var ref$16 = __webpack_require__(19);
var Stats = ref$16.Stats;
var ref$17 = __webpack_require__(19);
var StatType = ref$17.StatType;
var ref$18 = __webpack_require__(35);
var Timer = ref$18.Timer;
var ref$19 = __webpack_require__(190);
var TransportAcks = ref$19.TransportAcks;
var TransportAckResult = ref$19.TransportAckResult;

var RING_BUFFER_SIZE = 512;
var ZERO_APP_ACK = new ApplicationAck(Long.UZERO, ApplicationAckState.ACKED_SENT);

var ConsumerFSM = (function (StateMachine) {
  function ConsumerFSM(ref) {
    var this$1 = this;
    if ( ref === void 0 ) ref = {};
    var name = ref.name;
    var consumer = ref.consumer;
    var sessionInterface = ref.sessionInterface;
    var properties = ref.properties;

    StateMachine.call(this, { name: name });

    var fsm = this;
    var formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        ("[session=" + (sessionInterface.sessionIdHex) + "]"),
        ("[message-consumer-fsm=" + (consumer.flowIdDec) + "]") ].concat( args );
    };
    var logger = this.logger = new LogFormatter(formatter);
    var LOG_TRACE = logger.LOG_TRACE;
    var LOG_DEBUG = logger.LOG_DEBUG;
    var LOG_INFO = logger.LOG_INFO;
    var LOG_WARN = logger.LOG_WARN;
    var LOG_ERROR = logger.LOG_ERROR;
    this.log = logger.wrap(this.log, this);

    var autoAck = properties.acknowledgeMode === MessageConsumerAcknowledgeMode.AUTO;

    this._consumer = consumer;
    this._sessionInterface = sessionInterface;

    this._acknowledgeTimeoutInMsecs = properties.acknowledgeTimeoutInMsecs;
    this._acknowledgeThreshold = properties.acknowledgeThreshold;

    this._bindTimeoutInMsecs = properties.connectTimeoutInMsecs;

    this._localPreferredWindowSize = properties.windowSize;
    this._localMaxWindowSize = properties.windowSize;

    this._messageDispatch = new MessageDispatcher({ emitter: consumer, autoAck: autoAck, logger: logger });

    this._stats = new Stats();

    this._resetRemoteConnectionState();
    this._resetLocalConnectionState();

    //**********************************************************************************************
    // A bit of infrastructure around post-event actions, which includes maintaining a queue of
    // pending actions, and some logic to pre-process the actions before performing them.

    // These should not be the same as any MessageConsumerEventName value or they will collide in
    // the actionLocations object during event pre-processing.
    var emitEventActionType = 'EMIT';
    var startDispatchActionType = 'DISPATCH';
    var stopDispatchActionType = 'NO_DISPATCH';

    var postEventActions = [];
    function preprocessPostEventActions(startIndex) {
      // first pre-process post event actions.  This isn't an exhaustive search of every possible
      // combination of event sequences, as many are practically impossible, and therefore
      // impossible to test.  We only handle sequences that are known to be possible.  If there
      // are other sequences that need to be considered, we can add processing for them when we
      // know they are possible.
      /* #stripped LOG_TRACE(`Pre-processing post event action list @${startIndex}`, postEventActions) */

      var actionLocations = {};
      postEventActions.forEach(function (action, i, arr) {
        function cancelAction(firstActionName, cancellingActionName) {
          if (actionLocations[firstActionName] === undefined) {
            return;
          }
          var firstLocation = actionLocations[firstActionName];
          /* #stripped LOG_TRACE(`Cancelling post event action ${firstActionName}@${firstLocation} with ${
            cancellingActionName}@${i}`) */

          actionLocations[firstActionName] = undefined;
          arr[firstLocation] = null;
          arr[i] = null;
        }
        if ((i < startIndex) || (!action)) {
          /* #stripped LOG_TRACE(`Skip n/a action@${i}, start: ${startIndex}, action:`, action) */

          return;
        }
        switch (action.type) {
          case emitEventActionType:
            switch (action.data) {
              case MessageConsumerEventName.UP:
              case MessageConsumerEventName.ACTIVE:
                actionLocations[action.data] = i;
                break;

              case MessageConsumerEventName.DOWN:
              case MessageConsumerEventName.DOWN_ERROR:
                cancelAction(MessageConsumerEventName.UP, action.data);
                break;

              case MessageConsumerEventName.INACTIVE:
                cancelAction(MessageConsumerEventName.ACTIVE, action.data);
                break;

              default:
                LOG_ERROR(("Unexpected event in post-event action: " + (action.data)));
                break;
            }
            break;

          case startDispatchActionType:
            actionLocations[action.type] = i;
            break;

          case stopDispatchActionType:
            cancelAction(startDispatchActionType, action.type);
            break;

          default:
            break;
        }
      });
    }

    function processPostEventActions() {
      var this$1 = this;

      var preprocessedActions = 0;
      var i;

      // Now we've pre-processed the list, execute any remaining non-null entries.  We don't use a
      // foreach loop since foreach won't include elements added after processing has started.  This
      // can occur if a callback causes more postEventActions to be added.
      /* #stripped LOG_TRACE('Executing post event action list', postEventActions) */

      for (i = 0; i < postEventActions.length; ++i) {
        if (preprocessedActions < postEventActions.length) {
          preprocessPostEventActions(i);
          preprocessedActions = postEventActions.length;
        }
        var action = postEventActions[i];
        /* #stripped LOG_TRACE(`Action ${i}:`, action) */

        if (!action) {
          continue;
        }
        switch (action.type) {
          case emitEventActionType:
            consumer._emit(action.data);
            break;

          case stopDispatchActionType:
            // We don't actually do the stop here -- it is always done when this is enqueued.
            // The reason for enqueuing this event is to that it can cencel a startDispatch, if
            // present.
            break;

          case startDispatchActionType:
            this$1.requestStartDispatchFSM();
            break;

          default:
            LOG_ERROR(("Unhandled post event action type: " + (action.type)));
            break;
        }
      }
      postEventActions = [];
    }

    function addPostEventAction(type, data) {
      var newEvent;
      if (data !== undefined) {
        newEvent = { type: type, data: data };
      } else {
        newEvent = { type: type };
      }
      postEventActions.push(newEvent);
      /* #stripped LOG_TRACE(`Added post event action ${postEventActions.length}:`, newEvent) */

      if (postEventActions.length === 1) {
        fsm.setPostEventAction(processPostEventActions);
      }
    }

    var addEventToEmit = function (event) {
      if (!properties.activeIndicationEnabled) {
        if ((event === MessageConsumerEventName.INACTIVE) ||
            (event === MessageConsumerEventName.ACTIVE)) {
          /* #stripped LOG_TRACE(`Skip emitting ${event} due to disabled flow active indications`) */

          return;
        }
      }
      addPostEventAction(emitEventActionType, event);
    };
    var requestStartDispatch = function () {
      addPostEventAction(startDispatchActionType);
    };
    var requestStopDispatch = function () {
      // We do the stop inline, then add a post-event action so that it can have the effect of
      // cancelling a previous start.  It will not execute the stop when processed however since we
      // have already done it here.
      this$1.requestStopDispatchFSM();
      addPostEventAction(stopDispatchActionType);
    };

    this._addEventToEmit = addEventToEmit;
    this._requestStartDispatch = requestStartDispatch;
    this._requestStopDispatch = requestStopDispatch;

    // End of post-event action infrastructure
    //**********************************************************************************************

    // FSM config
    this.unhandledEventReaction(function onUnhandledEvent(event) {
      switch (event.getName()) {
        case ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED:
          LOG_INFO('VirtualRouter name change: clearing all acknowledgement state');
          fsm._resetRemoteConnectionState();
          return this;
        case ConsumerFSMEventNames.FLOW_UNBOUND:
          LOG_INFO('Received unsolicited unbind. Flow may be manually reconnected.');
          return this.transitionToUnbound(MessageConsumerEventName.DOWN_ERROR);
        case ConsumerFSMEventNames.DISPOSE:
          fsm._dispose();
          return fsm.getCurrentState().terminate();
        default:
          /* #stripped LOG_TRACE(`Ignoring event ${event.getName()} in state ${this.getCurrentState().getName()}`) */

          return this;
      }
    });

    this.initial(function onInitial() {
      return this.transitionTo(fsm.Unbound, function (context) {
        /* #stripped LOG_DEBUG(`Starting ${context.getStateMachine().getName()}`) */

      });
    });

    /*
      We don't transition directly from Unbound to BindSent.
      We need the following events:
       * FLOW_OPEN
       * SESSION_UP
      (The session ensures we get SESSION_UP or SESSION_UP_NO_AD if we are created
      and there is a session already up.)
      The Unbound base state implements transitions to its wait state children:
       * FLOW_OPEN -> AwaitSessionUp
       * SESSION_UP -> AwaitFlowOpen
      It also has the following transitions that pull the FSM out of its children
      and back to itself:
       * FLOW_CLOSE
       * SESSION_DOWN
      The child states can override these with internal transitions.
     */
    this.Unbound = new State({
      name:          ConsumerStateNames.UNBOUND,
      parentContext: fsm,
    }, {
      emitDisabledEvent: function emitDisabledEvent() {
        consumer._emit(MessageConsumerEventName.GM_DISABLED);
      },
    })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSesssionDisconnect() {
        return this.transitionTo(this);
      })
      .reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp); // Enter child state
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
        var this$1 = this;

        if (fsm._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
          return this.transitionTo(fsm.Unbound.AwaitFlowOpen); // Enter child state
        }
        LOG_WARN(("Consumer is not supported by router for this client on sessionId 0x" + (fsm._sessionInterface.sessionIdHex)));
        // Act as if the child state handled this
        return this.internalTransition(function () { return this$1.emitDisabledEvent(); });
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP_NO_AD, function onSessionUpNoAD() {
        var this$1 = this;

        // Act as if the child state handled this
        return this.internalTransition(function () { return this$1.emitDisabledEvent(); });
      })
      .exit(function () {
        fsm.bindRetryCount = properties.bindRetryCount;
      });

    /*
      In this state, we have received FLOW_OPEN, but no SESSION_UP.
      SESSION_DOWN does not cancel this wait, so we must override the
      parent and explicitly do nothing.
    */
    this.Unbound.AwaitSessionUp = new State({
      name:          ConsumerStateNames.UNBOUND_AWAIT_SESSION_UP,
      parentContext: this.Unbound,
    }, {
      emitBindWaiting: function emitBindWaiting() {
        consumer._emit(PrivateFlowEventName.BIND_WAITING);
      },
    })
      .entry(function onEntry() {
        this.emitBindWaiting();
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.internalTransition(); // Don't exit; continue waiting
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        return this.internalTransition(); // Don't exit; continue waiting
      })
      .reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
        return this.transitionTo(fsm.BindSent); // OK to bind
      });

    /*
      In this state, we have received SESSION_UP but not FLOW_OPEN.
      If we get FLOW_OPEN, attempt to bind. Any other event is handled
      by the parent.
     */
    this.Unbound.AwaitFlowOpen = new State({
      name:          ConsumerStateNames.UNBOUND_AWAIT_FLOWOPEN,
      parentContext: this.Unbound,
    })
      .reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
        return this.transitionTo(fsm.BindSent); // OK to bind
      });

    this.BindSent = new State({
      name:          ConsumerStateNames.BIND_SENT,
      parentContext: fsm,
    }, {
      emitBindFailed: function emitBindFailed(error) {
        assert(error instanceof OperationError);
        consumer._emit(MessageConsumerEventName.CONNECT_FAILED_ERROR, error);
      },
      sendBindRequest: function sendBindRequest() {
        var correlationTag = sessionInterface.getCorrelationTag();
        var transportAcks = fsm._transportAcks;

        fsm._endpointEnsure();
        var endpoint = fsm._endpoint;
        var subscription = fsm._subscription;

        var message = SMFLib.AdProtocolMessage.getOpenMessageConsumer(
          properties.queueDescriptor,
          properties.queueProperties,
          endpoint,
          subscription,
          correlationTag,
          properties.windowSize,
          properties.noLocal,
          properties.activeIndicationEnabled,
          transportAcks.lastAcked,
          transportAcks.lastReceived);
        sessionInterface.sendControl(message);
        sessionInterface.enqueueRequest(correlationTag,
                                        this.handleBindTimeout.bind(this),
                                        fsm._bindTimeoutInMsecs,
                                        null,
                                        this.handleBindResponse.bind(this));
        /* #stripped LOG_TRACE('Sent consumer bind request with arguments', [
          properties.queueDescriptor,
          properties.queueProperties,
          endpoint,
          subscription,
          correlationTag,
          properties.windowSize,
          properties.noLocal,
          properties.activeIndicationEnabled,
          transportAcks.lastAcked,
          transportAcks.lastReceived]) */

      },
      cancelBindRequestTimer: function cancelBindRequestTimer() {
        this.bindRequestTimer.cancel();
      },
      handleBindTimeout: function handleBindTimeout() {
        LOG_INFO('Bind timeout');
        fsm.processEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.BIND_TIMEOUT }));
      },
      handleBindResponse: function handleBindResponse(msg) {
        if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.BIND) {
          // TODO: more useful action here?
          LOG_INFO(("Unexpected message type in bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))));
          return fsm.processEvent(
            new ConsumerFSMEvent(
              { name: ConsumerFSMEventNames.FLOW_FAILED },
              new OperationError(("Unexpected bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))),
                                 ErrorSubcode.PROTOTOCOL_ERROR)));
        }

        var header = msg.smfHeader;
        var responseCode = header.pm_respcode;

        if (responseCode === null) {
          // Drop message and increment stats. Flow will time out
          this._consumer.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          /* #stripped LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${
                    this._sessionInterface.sessionIdHex}`) */

          return undefined;
        }

        if (responseCode !== 200) {
          var description = header.pm_respstr;
          var errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode,
                                                                            description);
          /* #stripped LOG_DEBUG('Flow failed:', responseCode, description, ErrorSubcode.describe(errorSubcode)) */

          return fsm.processEvent(new ConsumerFSMEvent(
              { name: ConsumerFSMEventNames.FLOW_FAILED },
              new OperationError(description, errorSubcode, { responseCode: responseCode })));
        }

        var accessTypeOrDefault = function (x) { return (x === undefined ? QueueAccessType.EXCLUSIVE : x); };

        var attrs = {
          lastMsgIdAcked:       msg.getLastMsgIdAcked(),
          flowId:               msg.getFlowId(),
          accessType:           accessTypeOrDefault(msg.getAccessType()),
          topicEndpointBytes:   msg.getTopicEndpointBytes(),
          grantedPermissions:   msg.getGrantedPermissions(),
          respectsTTL:          msg.getRespectsTTL(),
          activeFlow:           msg.getActiveFlow(),
          wantFlowChangeNotify: msg.getWantFlowChangeNotify(),
          discardBehavior:      msg.getQueueDiscardBehavior(),
          endpointId:           msg.getEndpointId(),
          maxUnackedMessages:   msg.getMaxUnackedMessages(),
        };
        /* #stripped LOG_DEBUG('BIND response attributes:', attrs) */


        Object.assign(consumer, {
          accessType:           attrs.accessType,
          queueDiscardBehavior: attrs.discardBehavior,
          endpointId:           attrs.endpointId,
          respectsTTL:          attrs.respectsTTL,
          flowId:               attrs.flowId,
          permissions:          attrs.grantedPermissions,
          wantFlowChangeNotify: attrs.wantFlowChangeNotify,
        });

        if (attrs.topicEndpointBytes && attrs.topicEndpointBytes.length) {
          attrs.endpoint = DestinationFromNetwork.createDestinationFromBytes(
            attrs.topicEndpointBytes);
          /* #stripped LOG_DEBUG('Overwriting local endpoint:', fsm._endpoint, 'with remote:', attrs.endpoint) */

          fsm._endpoint = attrs.endpoint;
          var consumerProperties = fsm._consumer._properties;
          consumerProperties.queueDescriptor = new QueueDescriptor({
            name:    attrs.endpoint.name,
            type:    consumerProperties.queueDescriptor.type,
            durable: consumerProperties.queueDescriptor.durable,
          });
        }

        Object.assign(fsm, {
          _active:           attrs.activeFlow,
          _remoteWindowSize: attrs.maxUnackedMessages,
        });

        if (Long.UZERO.eq(fsm._transportAcks.lastAcked)) {
          fsm._transportAcks.lastAcked = attrs.lastMsgIdAcked || Long.UZERO;
        } else {
          /* #stripped LOG_DEBUG(`Retaining last acked/last received: ${fsm._transportAcks}`) */

        }

        return fsm.processEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_UP }));
      },
    })
      .entry(function onEntry() {
        this.sendBindRequest();
        this.bindRequestTimer = Timer.newTimeout(consumer._properties.connectTimeoutInMsecs,
                                                 this.handleBindTimeout);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp,
                                 function () { return fsm._addEventToEmit(MessageConsumerEventName.DOWN); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(fsm.UnbindSent);
      })
      .reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
        var this$1 = this;

        if (fsm.bindRetryCount) {
          return this.externalTransitionTo(fsm.BindSent, function () { return --fsm.bindRetryCount; });
        }
        return this.transitionTo(fsm.Unbound,
                                 function () { return this$1.emitBindFailed(
                                    new OperationError('Bind failed due to timeout',
                                                       ErrorSubcode.TIMEOUT)); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
        var this$1 = this;

        // Act like a newly created flow
        return this.transitionTo(fsm.Unbound, function () { return this$1.emitBindFailed(evt.details); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
        return this.transitionTo(fsm.FlowUp);
      })
      .exit(function onExit() {
        this.cancelBindRequestTimer();
      });

    var flowUpFSM = this.FlowUp = new State({
      name:          ConsumerStateNames.FLOW_UP,
      parentContext: fsm,
    })
      .initial(
        function onInitial() {
          return this.transitionTo(fsm._active === 0
            ? flowUpFSM.XferInactive
            : flowUpFSM.Xfer);
        }
      )
      .entry(function () {
        fsm._addEventToEmit(MessageConsumerEventName.UP);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
      })
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDisconnect() {
        return this.transitionTo(fsm.Unbound.AwaitSessionUp,
                                 function () { return fsm._addEventToEmit(MessageConsumerEventName.DOWN); });
      })
      .reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        // Acks will be sent by UnbindSent
        return this.transitionTo(fsm.UnbindSent);
      });

    flowUpFSM.Xfer = new State({
      name:          ConsumerStateNames.FLOW_UP_XFER,
      parentContext: flowUpFSM,
    })
      .entry(function () {
        fsm._addEventToEmit(MessageConsumerEventName.ACTIVE);
        fsm._sendAcks(true);
        fsm._requestStartDispatch();
      })
      .exit(function () {
        fsm._addEventToEmit(MessageConsumerEventName.INACTIVE);
        fsm._requestStopDispatch();
      })
      // Here we send acks on disconnect.  Acks for the FLOW_CLOSE event are coupled to the sending
      // of the unbind.
      .reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
        fsm._sendAcks(true);            // send acks, then...
        return this.eventUnhandled();   // let the parent state handle the remaining steps.
      });

    flowUpFSM.XferInactive = new State({
      name:          ConsumerStateNames.FLOW_UP_XFER_INACTIVE,
      parentContext: flowUpFSM,
    })
      .reaction(ConsumerFSMEventNames.FLOW_ACTIVE_IND, function onFlowActiveIndication() {
        return this.transitionTo(flowUpFSM.Xfer);
      });

    this.UnbindSent = new State({
      name:          ConsumerStateNames.UNBIND_SENT,
      parentContext: fsm,
    }, {

      sendUnbindRequest: function sendUnbindRequest() {
        var this$1 = this;

        // Don't do this on entry to UNBIND, do it when the user
        // wants to unbind
        fsm._endpointClear();

        var correlationTag = sessionInterface.getCorrelationTag();
        var message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(consumer.flowId,
                                                                         correlationTag);
        sessionInterface.sendControl(message);
        sessionInterface.enqueueRequest(
          correlationTag,
          function () { return this$1.handleUnbindTimeout(); },
          properties.connectTimeoutInMsecs,
          null,
          function (response) { return this$1.handleUnbindResponse(response); });
        /* #stripped LOG_DEBUG('Sent consumer unbind request with arguments',
                  {
                    flowId: consumer.flowId,
                    correlationTag,
                  }) */

      },

      handleUnbindTimeout: function handleUnbindTimeout() {
        LOG_INFO('Unbind timeout');
        return fsm.processEvent(
          new ConsumerFSMEvent({ name: ConsumerFSMEventNames.UNBIND_TIMEOUT })
        );
      },

      handleUnbindResponse: function handleUnbindResponse(msg) {
        if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.UNBIND) {
          LOG_INFO(("Unexpected message type in bind response: " + (SMFLib.SMFAdProtocolMessageType.describe(msg.msgType))));
        }
        return fsm.processEvent(
          new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_UNBOUND })
        );
      },

    })
      .entry(function onEntry() {
        this.sendUnbindRequest();
      })
      .reaction(ConsumerFSMEventNames.UNBIND_TIMEOUT, function onUnbindTimeout() {
        return this.externalTransitionTo(fsm.UnbindSent);
      })
      // The choice point will emit on this transition, not on exit, which is OK:
      // we don't want to repeatedly dispatch "unbound" when the unbinds are timing out
      .reaction(ConsumerFSMEventNames.FLOW_UNBOUND,
                function () { return fsm.transitionToUnbound(MessageConsumerEventName.DOWN); });
  }

  if ( StateMachine ) ConsumerFSM.__proto__ = StateMachine;
  ConsumerFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  ConsumerFSM.prototype.constructor = ConsumerFSM;

  var prototypeAccessors = { maxWindowSize: {},windowSize: {},maxPendingAcks: {} };

  /**
   *
   * @param {solace.Message} message The message being accepted by the flow.
   * @returns {Boolean} True if the message was accepted.
   * @private
   */
  ConsumerFSM.prototype.acceptMessage = function acceptMessage (message) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var messageID = message.getGuaranteedMessageId();
    var idstr = messageID.toString();
    var consumer = this._consumer;

    if (!this._fsmDispatch) {
      // We're disconnecting. Drop the message.
      /* #stripped LOG_TRACE('Dropping message because this flow cannot acknowledge it') */

      consumer.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
      return false;
    }

    var transportAcks = this._transportAcks;
    var ackResult = transportAcks.tryReceive(messageID,
                                               message.getGuaranteedPreviousMessageId());
    var transportAckRequired = transportAcks.acksPending > this.maxPendingAcks;
    switch (ackResult) {
      case TransportAckResult.OK:
        break; // carry on
      case TransportAckResult.DUPLICATE:
        consumer.incStat(StatType.RX_DISCARD_DUPLICATE);
        // Two options here: could check membership in the ringbuffer,
        // or could check whether the ID is less than ringbuffer.front().
        // Untested assumption: arithmetic comparison on boxed Long at front()
        // is more computationally expensive than native Map() lookup.
        if (!this._applicationAcks.has(messageID) &&
            !this._oldUnacked.has(idstr)) {
          /* #stripped LOG_TRACE('Will application ack unknown duplicate ID', idstr) */

          this._sendAck([[messageID, messageID]]);
        } else if (transportAckRequired) {
          this._sendAcks(transportAckRequired);
        } else {
          // if we are receiving dups we should make sure we send
          // and ack in case we don't receive any non duplicates
          // and we don't receive enough duplicates to exceed
          // maxPendingAcks.  Eventually we would but only after
          // the  router retransmitted many times.
          this._setTransportAckTimer();
        }
        return false;
      case TransportAckResult.OUT_OF_ORDER:
        consumer.incStat(StatType.RX_DISCARD_OUT_OF_ORDER);
        return false;
      default:
        assert(false, 'Unhandled transport ack result', ackResult);
        return false;
    }

    return this._applicationAcks.insert(messageID, function (evicting) {
      var applicationAckRequired = false;
      if (evicting) {
        switch (evicting.state) {
          case ApplicationAckState.UNACKED:
            this$1._oldUnacked.add(evicting.key);
            break;
          case ApplicationAckState.ACKED_NOT_SENT:
            applicationAckRequired = true;
            break;
          case ApplicationAckState.ACKED_SENT:
            // OK to evict
            break;
          default:
            assert(false,
                   'Unhandled application ack state',
                   ApplicationAckState.describe(evicting.state));
        }
      }

      this$1._messageDispatch.push(message);

      if (transportAckRequired || applicationAckRequired) {
        /* #stripped LOG_TRACE('Need to send acks:',
                  'transport', transportAckRequired,
                  'application', applicationAckRequired) */

        this$1._sendAcks(transportAckRequired);
      } else {
        this$1._setTransportAckTimer();
      }

      return true;
    });
  };

  ConsumerFSM.prototype.applicationAck = function applicationAck (messageId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    var idstr = messageId.toString();
    this._consumer.incStat(StatType.RX_ACKED);

    // Was the message old, and demoted to _oldUnacked?
    if (this._oldUnacked.delete(idstr)) { // True if idstr was member
      // It was old. Ack immediatesly.
      /* #stripped LOG_TRACE('Application acking old message immediately') */

      this._sendAck([[messageId, messageId]]);
      return;
    }

    // We can't regress the ack_state this way; message.acknowledge() throws if called
    // more than once.
    this._applicationAcks.updateAckState(messageId, ApplicationAckState.ACKED_NOT_SENT);
    this._setTransportAckTimer();
  };

  ConsumerFSM.prototype.getDestination = function getDestination () {
    this._endpointEnsure();
    return this._destination;
  };

  ConsumerFSM.prototype.isDisconnected = function isDisconnected () {
    if (!this.getCurrentState()) { return true; }
    return (
      this.getActiveState(ConsumerStateNames.UNBOUND) ||
      this.getActiveState(ConsumerStateNames.UNBOUND_AWAITING_FLOWOPEN)
    );
  };

  ConsumerFSM.prototype.requestStartDispatchUser = function requestStartDispatchUser () {
    this._userDispatch = true;
    this.applyStartDispatch();
  };

  ConsumerFSM.prototype.requestStartDispatchFSM = function requestStartDispatchFSM () {
    this._fsmDispatch = true;
    this.applyStartDispatch();
  };

  ConsumerFSM.prototype.applyStartDispatch = function applyStartDispatch () {
    if (this._userDispatch && this._fsmDispatch) {
      this.log(("Starting message dispatch (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
      this._messageDispatch.start();
      this._localMaxWindowSize = this._localPreferredWindowSize;
      this._sendAcks(true);
    } else {
      this.log(("Not starting message dispatch (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    }
  };

  ConsumerFSM.prototype.transitionToUnbound = function transitionToUnbound (eventName) {
    var this$1 = this;

    var consumer = this._consumer;
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    /* #stripped LOG_TRACE('Flow down, user disconnected?', consumer.userDisconnected) */


    return this.transitionTo(this.Unbound.AwaitFlowOpen, function () { return this$1._addEventToEmit(eventName); });
  };

  ConsumerFSM.prototype.requestStopDispatchUser = function requestStopDispatchUser () {
    this._userDispatch = false;
    this.log(("Stop dispatch user (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    this._messageDispatch.stop();
  };

  ConsumerFSM.prototype.requestStopDispatchFSM = function requestStopDispatchFSM () {
    this._fsmDispatch = false;
    this.log(("Stop dispatch FSM (fsm " + (this._fsmDispatch) + ", user " + (this._userDispatch) + ")"));
    this._sendAcks(true);
  };

  ConsumerFSM.prototype._clearTransportAckTimer = function _clearTransportAckTimer () {
    if (!this._transportAckTimer) { return; }

    clearTimeout(this._transportAckTimer);
    this._transportAckTimer = null;
  };

  ConsumerFSM.prototype._dispose = function _dispose () {
    this._clearTransportAckTimer();
    this._endpointClear();
    this._destination = undefined;
    this._unacked = null;
    this._messageDispatch = null;
    this._transportAcks = null;
    this._consumer = null;
    this._sessionInterface = null;
  };

  ConsumerFSM.prototype._endpointClear = function _endpointClear () {
    this._endpoint = undefined;
    this._subscription = undefined;
  };

  ConsumerFSM.prototype._endpointEnsure = function _endpointEnsure () {
    if (this._endpoint) {
      // The endpoint, destination and any possible topic subscription are generated
      // at the same time. Use the presence of the endpoint to determine whether
      // any of this has already been done.
      return;
    }

    var sessionInterface = this._sessionInterface;
    var properties = this._consumer._properties;
    var queueDescriptor = properties.queueDescriptor;

    var destination;
    var endpoint;
    var subscription;
    if (queueDescriptor.type === QueueType.QUEUE) {
      // The publish destination needs a prefix. Create a destination from
      // the descriptor, then derive the endpoint name from that.
      destination = sessionInterface.createDestinationFromDescriptor(queueDescriptor);

      // The bind target is the queue name encoded as though a topic -- no prefix
      // Use the offset information to build a bind target
      endpoint = new Queue({
        name:   destination.name,
        type:   DestinationType.QUEUE,
        offset: 0,
        bytes:  destination.bytes.substr(destination.offset),
      });

      subscription = undefined;
    } else {
      // QueueType.TOPIC_ENDPOINT
      endpoint = queueDescriptor.name
        ? sessionInterface.createDestinationFromDescriptor(queueDescriptor)
        : new Topic({ name: '\0?', offset: 0, bytes: '\0' });
      subscription = properties.topicEndpointSubscription ||
        sessionInterface.createTemporaryDestination(DestinationType.TOPIC);
      destination = subscription;
    }

    // Using Object.assign to enforce the invariant that these three properties are set together
    // or not at all.
    Object.assign(this, {
      _destination:  destination,
      _endpoint:     endpoint,
      _subscription: subscription,
    });

    // Update the properties object (if TTMP, we may modify it again)
    properties.queueDescriptor = new QueueDescriptor({
      name:    endpoint.name,
      type:    queueDescriptor.type,
      durable: queueDescriptor.durable,
    });
  };

  ConsumerFSM.prototype._resetLocalConnectionState = function _resetLocalConnectionState () {
    Object.assign(this, {
      _remoteWindowSize: 0,
      _active:           undefined,
      _fsmDispatch:      false,
      _userDispatch:     true, // User flow is initially started
    });
  };

  ConsumerFSM.prototype._resetRemoteConnectionState = function _resetRemoteConnectionState () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

    /* #stripped LOG_TRACE('Initializing transport acks') */

    this._transportAcks = new TransportAcks();

    /* #stripped LOG_TRACE('Initializing application acks') */

    this._applicationAcks = new ApplicationAckRingBuffer(RING_BUFFER_SIZE);
    this._oldUnacked = new Set();
  };

  /**
   * Sends a single ack.
   *
   * @param {Array.<ackpair>} applicationAcks The application ack ranges to send
   * @memberof ConsumerFSM
   * @private
   */
  ConsumerFSM.prototype._sendAck = function _sendAck (applicationAcks) {
    var transportAck = SMFLib.AdProtocolMessage.getAck(
      this._consumer.flowId,
      this._transportAcks.lastReceived,
      this.windowSize,
      applicationAcks);
    this._sessionInterface.sendControl(transportAck); // Must succeed or throw
  };

  /**
   * Adds the current ack ranges to an accumulator. Call this for each applicationAck.
   * When a range ends (we receive an unacked), or we are explictly flushing
   * (applicationAck === null), we convert the accumulator to acks, send them, update state,
   * and reset accumulators.
   *
   * This should be called at least once with the last invocation having ackRange = null.
   * This invokes the flush path, which is necessary if any ranges were in progress,
   * and this is the only path that repects the forceTransportAck flag.
   *
   * @param {Object} acksPendingState State associated with this activity
   * @param {ApplicationAck} applicationAck The ack to process for ack ranges.
   *    If `null`, any pending acks are flushed and a transport ack is sent, if
   *    required.
   * @private
   */
  ConsumerFSM.prototype._addAckToRanges = function _addAckToRanges (acksPendingState, applicationAck) {
    var this$1 = this;
    if ( applicationAck === void 0 ) applicationAck = null;

    var currentRange = acksPendingState.currentRange;
    var ackRanges = acksPendingState.ackRanges;

    if (applicationAck && applicationAck.state !== ApplicationAckState.UNACKED) {
      currentRange.push(applicationAck);
      return; // Wait for end of range or flush
    }

    // We received an UNACKED or a null ack (flush). Complete this range.
    if (currentRange.length) {
      ackRanges.push(currentRange);
    }

    // If we're flushing or we've hit the protocol limit for ranges in a single ack,
    // we send ack messages, update ack states and clear the accumulator.
    // This condition will be true at least once (must flush at the end).
    if (applicationAck === null ||
        ackRanges.length === SMFLib.AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
      // Reduce each range to a first and last ID.
      var bareRanges = ackRanges.map(function (range) { return [range[0].id, range[range.length - 1].id]; });

      if (bareRanges.length || acksPendingState.forceTransportAck) {
        // We send the ranges. This could throw.
        var ref = this.logger;
        var LOG_TRACE = ref.LOG_TRACE;
        this._sendAck(bareRanges);
        // Warning: this log statement reduces debug performance by 25%!
        /* #stripped LOG_TRACE(
          'Sent ack: ',
          `Transport ack: ${this._transportAcks.lastReceived}`,
          `Application acks: ${bareRanges.length
            ? bareRanges.map(g => `[${g[0]}..${g[1]}]`)
            : '[]'}`
        ) */

        // If the intent was to force a transport ack, that condition is fulfilled.
        this._transportAcks.setAcked();
        acksPendingState.forceTransportAck = false;
      }

      // Since the range send succeeded, update the ack states.
      ackRanges.forEach(function (ackRange) {
        ackRange.forEach(function (ack) {
          if (ack.state !== ApplicationAckState.ACKED_SENT) {
            this$1._applicationAcks.updateAckState(ack.id,
                                                 ApplicationAckState.ACKED_SENT);
          }
        });
      });

      // Clear the main accumulator since it has hit the wire.
      acksPendingState.ackRanges = [];
    }
    // Clear the accumulator for this range.
    acksPendingState.currentRange = [];
  };

  /**
   * Sends acknowledgements, along with a window update for this flow.
   *
   * @param {Boolean} forceTransportAck `true` sends transport ack even if no acks pending
   * @private
   */
  ConsumerFSM.prototype._sendAcks = function _sendAcks (forceTransportAck) {
    var this$1 = this;
    if ( forceTransportAck === void 0 ) forceTransportAck = false;

    this._clearTransportAckTimer();

    var applicationAcks = this._applicationAcks;
    var transportAcks = this._transportAcks;

    // This state is temporary and shared with the ack generating function.
    var acksPendingState = {
      forceTransportAck: forceTransportAck || (transportAcks.acksPending > 0),
      ackRanges:         [],
      currentRange:      [],
    };

    // If the first ringbuffer ack state is acked and there are no unacked before this,
    // we can create an ack range that includes zero.
    // If the first ringbuffer ack state is unacked, we can say nothing about the
    // range before the first acked ID in the ringbuffer.
    var front = this._applicationAcks.front();
    if (this._oldUnacked.size === 0 && front && front.state !== ApplicationAckState.UNACKED) {
      // State is acked_sent so we don't try to update the ring buffer.
      this._addAckToRanges(acksPendingState, ZERO_APP_ACK);
      // We know that front will be added to this range by the iteration.
    }

    // Build ack ranges using the accumulator
    applicationAcks.forEach(function (ack) { return this$1._addAckToRanges(acksPendingState, ack); });
    // Flush the last pending ack range.
    this._addAckToRanges(acksPendingState);

    // On successful exit, we've sent and cleared all accumulators, and we've sent
    // a transport ack if we were supposed to do that.
    assert(acksPendingState.forceTransportAck === false);
    assert(acksPendingState.currentRange.length === 0);
    assert(acksPendingState.ackRanges.length === 0);
  };

  ConsumerFSM.prototype._setTransportAckTimer = function _setTransportAckTimer () {
    var this$1 = this;

    if (this._transportAckTimer) { return; }
    if (this._consumer.disposed) { return; }
    this._transportAckTimer = setTimeout(
      function () { return this$1._sendAcks(true); },
      this._acknowledgeTimeoutInMsecs
    );
  };

  prototypeAccessors.maxWindowSize.get = function () {
    return Math.min(this._localMaxWindowSize,
                    this._remoteWindowSize || Number.POSITIVE_INFINITY);
  };

  prototypeAccessors.windowSize.get = function () {
    return this.maxWindowSize - this._messageDispatch.length;
  };

  prototypeAccessors.maxPendingAcks.get = function () {
    return this.windowSize * this._consumer._properties.acknowledgeThreshold / 100.0;
  };

  Object.defineProperties( ConsumerFSM.prototype, prototypeAccessors );

  return ConsumerFSM;
}(StateMachine));

module.exports.ConsumerFSM = ConsumerFSM;


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

var ConsumerStateNames = {
  UNBOUND:                  'UNBOUND',
  UNBOUND_AWAIT_SESSION_UP: 'UNBOUND_AWAIT_SESSION_UP',
  UNBOUND_AWAIT_FLOWOPEN:   'UNBOUND_AWAIT_FLOWOPEN',
  UNBOUND_AWAIT_ANY:        'UNBOUND_AWAIT_ANY',
  BIND_SENT:                'BIND_SENT',
  FLOW_UP:                  'FLOW_UP',
  FLOW_UP_XFER:             'FLOW_UP_XFER',
  FLOW_UP_XFER_INACTIVE:    'FLOW_UP_XFER_INACTIVE',
  UNBIND_SENT:              'UNBIND_SENT',
};

module.exports.ConsumerStateNames = Enum.new(ConsumerStateNames);


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(18);
var AbstractQueueDescriptor = ref.AbstractQueueDescriptor;
var QueueDescriptor = ref.QueueDescriptor;
var QueueDescriptorValidator = ref.QueueDescriptorValidator;
var QueueProperties = ref.QueueProperties;
var QueuePropertiesValidator = ref.QueuePropertiesValidator;
var QueueType = ref.QueueType;
var ref$1 = __webpack_require__(4);
var APIPropertiesValidators = ref$1.APIPropertiesValidators;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(38);
var MessageConsumerAcknowledgeMode = ref$3.MessageConsumerAcknowledgeMode;
var ref$4 = __webpack_require__(2);
var OperationError = ref$4.OperationError;
var ErrorSubcode = ref$4.ErrorSubcode;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valInstance = APIPropertiesValidators.valInstance;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;
var valTopicStringOrEmpty = APIPropertiesValidators.valTopicStringOrEmpty;

function valTopicEndpointSubscription(typeDesc, instance) {
  if (instance.queueDescriptor.getType() === QueueType.TOPIC_ENDPOINT) {
    if (instance.queueDescriptor.isDurable()) {
      if (!instance.topicEndpointSubscription) {
        throw new OperationError('topicEndpointSubscription must be set when queueDescriptor ' +
                                'refers to a durable topic endpoint',
                                ErrorSubcode.PARAMETER_CONFLICT);
      }
    }
  } else if (instance.topicEndpointSubscription) {
    // is QueueType.QUEUE
    throw new OperationError('topicEndpointSubscription is set, but queueDescriptor ' +
                              'refers to a queue that is not of type QueueType.TOPIC_ENDPOINT',
                              ErrorSubcode.PARAMETER_CONFLICT);
  }
}

var MessageConsumerPropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'MessageConsumerProperties', instance);
    if (!(instance.queueDescriptor instanceof AbstractQueueDescriptor ||
          instance.queueDescriptor instanceof QueueDescriptor)) {
      throw new OperationError('MessageConsumerProperties validation: queue descriptor must be ' +
                                'an AbstractQueueDescriptor or a QueueDescriptor',
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    QueueDescriptorValidator.validate(instance.queueDescriptor);

    if (instance.queueProperties) {
      if (instance.queueDescriptor.durable) {
        throw new OperationError('queueProperties cannot be set unless queueDescriptor refers to ' +
                                 'a temporary queue',
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
      v('queueProperties', [valInstance, QueueProperties, 'QueueProperties']);
      QueuePropertiesValidator.validate(instance.queueProperties);
      if (Check.something(instance.queueProperties.accessType)) {
        throw new OperationError('queueProperties cannot specify accessType in creation of a ' +
                                 'temporary queue',
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
    }

    // Validate TE subscription
    if (instance.queueDescriptor.type === QueueType.TOPIC_ENDPOINT) {
      // QueueType.TOPIC_ENDPOINT
      if (instance.queueDescriptor.durable && !instance.topicEndpointSubscription) {
        throw new OperationError('topicEndpointSubscription must be set for durable ' +
                                       'topic endpoints',
                                       ErrorSubcode.PARAMETER_CONFLICT);
      }
    } else if (instance.topicEndpointSubscription) {
      throw new OperationError('topicEndpointSubscription cannot be set unless ' +
                               'descriptor.type is TOPIC_ENDPOINT',
                               ErrorSubcode.PARAMETER_CONFLICT);
    }

    v('connectTimeoutInMsecs', [valNumber], [valRange, 50, Number.MAX_VALUE]);
    v('connectAttempts', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('topicEndpointSubscription', [valTopicEndpointSubscription], [valTopicStringOrEmpty]);

    v('acknowledgeMode', [valIsMember, MessageConsumerAcknowledgeMode, 'MessageConsumerAcknowledgeMode']);
    v('acknowledgeTimeoutInMsecs', [valNumber], [valRange, 20, 1500]);
    v('acknowledgeThreshold', [valNumber], [valRange, 1, 75]);
    v('activeIndicationEnabled', [valBoolean]);
    v('noLocal', [valBoolean]);
    v('windowSize', [valNumber], [valRange, 1, 255]);

    if (instance.activeIndicationEnabled &&
      instance.queueDescriptor.type !== QueueType.QUEUE) {
      throw new OperationError(
        'MessageConsumerProperties validation: activeIndicationEnabled may only be true for ' +
        'QUEUE destinations',
        ErrorSubcode.PARAMETER_CONFLICT
      );
    }
  },
};

module.exports.MessageConsumerPropertiesValidator = MessageConsumerPropertiesValidator;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(28);
var MessageConsumerEventName = ref.MessageConsumerEventName;

function formatEventName(x) {
  return ("MessageConsumerEventName." + (MessageConsumerEventName.describe(x)));
}

var MessageDispatcher = function MessageDispatcher(ref) {
  if ( ref === void 0 ) ref = {};
  var emitter = ref.emitter;
  var autoAck = ref.autoAck;
  var logger = ref.logger;

  Object.assign(this, {
    emitter: emitter,
    queue:  [],
    dispatch: true,
    formatEventName: formatEventName,
    logger: logger,
  });
  this._dispatchOne = autoAck ? this._dispatchOneAutoAck : this._dispatchOneBare;
  this.emitter.setOnFirstDirectListener(this._onFirstMessageListener.bind(this));
  // Although a listener may not be available, we set it to true so that we detect a transition to
  // false when we attempt to dispatch the first message, which will generate a log that
  // dispatching is stopped due to a missing listener.
  this._availableListener = true;
};

var prototypeAccessors = { length: {} };

MessageDispatcher.prototype.start = function start () {
  this.dispatch = true;
  this._flush();
};

MessageDispatcher.prototype.stop = function stop () {
  this.dispatch = false;
};

prototypeAccessors.length.get = function () {
  return this.queue.length;
};

MessageDispatcher.prototype.push = function push (message) {
  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
  this.queue.push(message);

  if (this.dispatch) {
    this._flush();
  } else {
    /* #stripped LOG_TRACE(`Dispatch disabled, message ${message.getGuaranteedMessageId()} queued locally`) */

  }
};

MessageDispatcher.prototype._onFirstMessageListener = function _onFirstMessageListener () {
  var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
  if (!this._availableListener) {
    /* #stripped LOG_DEBUG(`Message listener available for dispatcher, ${this.queue.length} messages queued`) */

    /* #stripped LOG_DEBUG(`Dispatcher started and connected: ${this.dispatch ? 'true' : 'false'}`) */

    this._availableListener = true;
  }
  this._flush();
};

MessageDispatcher.prototype._flush = function _flush () {
    var this$1 = this;

  var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
  // Check whether dispatch enabled for every element,
  // to handle when #stop is called from a message handler
  while (this.queue.length && this.dispatch && (this.emitter.directListenerCount() > 0)) {
    this$1._dispatchOne(this$1.queue.shift());
  }

  if (this.queue.length && this.dispatch &&
      (this.emitter.directListenerCount() === 0) && this._availableListener) {
    /* #stripped LOG_DEBUG('Message dispatching stopped: No message listener registered') */

    this._availableListener = false;
  }
};

MessageDispatcher.prototype._dispatchOneAutoAck = function _dispatchOneAutoAck (message) {
  var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
  // Set the current outbound message, dispatch it, and clear the current outbound message
  var caught = null;

  // Auto-ack unless the receiver throws.
  caught = this._dispatchOneBare(message);
  // Outside of exception block because we want to throw normally from message.acknowledge()
  if (caught) {
    LOG_WARN(("Suppressing message acknowledgement for message " + (message.getGuaranteedMessageId()) + " because client threw exception from listener"), caught);
  } else {
    // Did the user manually ack for some reason?
    if (message.isAcknowledged) {
      LOG_WARN(("Consumer configured to auto-acknowledge messages, but message " + (message.getGuaranteedMessageId()) + " was application acknowledged"));
      return;
    }
    message.acknowledge(); // No, so ack the message
  }
};

MessageDispatcher.prototype._dispatchOneBare = function _dispatchOneBare (message) {
  var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
  var caught;
  // Requires the emitter's direct option to be MessageConsumerEventName.MESSAGE
  if (this.listenerCount === 0) {
    LOG_WARN(("No listeners to dispatch message " + (message.getGuaranteedMessageId())));
  }
  // Since _dispatchOneBare uses emitDirect, this behaviour is not affected by the presence
  // of an 'error' handler.
  try {
    this.emitter.emitDirect(message);
  } catch (ex) {
    // User code threw an exception
    caught = this.emitter.formatErrorEvent(ex, MessageConsumerEventName.MESSAGE, message);
    // Also propagating to the common error handler
    this.emitter.emit('error', caught);
  }
  return caught;
};

Object.defineProperties( MessageDispatcher.prototype, prototypeAccessors );

module.exports = { MessageDispatcher: MessageDispatcher };


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var Enum = ref.Enum;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;

var TransportAckResult = Enum.new({
  OK:           0,
  DUPLICATE:    1,
  OUT_OF_ORDER: 2,
});

var TransportAcks = function TransportAcks(id) {
  if ( id === void 0 ) id = 0;

  var base = typeof id === 'number' ? Long.fromNumber(id, true) : Long.fromValue(id);
  this.lastAcked = base;
  this._acksPending = 0;
};

var prototypeAccessors = { acksPending: {},lastAcked: {},lastReceived: {} };

TransportAcks.prototype.tryReceive = function tryReceive (messageID, prevMessageID) {
  if (this._lastReceived.lt(prevMessageID)) {
    /* #stripped LOG_DEBUG(`Rejecting out of order message: ${prevMessageID} (last received: ${this._lastReceived})`) */

    return TransportAckResult.OUT_OF_ORDER;
  }
  if (this._lastReceived.gte(messageID)) {
    /* #stripped LOG_DEBUG(`Rejecting duplicate message: ${messageID} (last received: ${this._lastReceived})`) */

    // duplicate messages indicate the router is retransmitting because it expects a transport ack
    this._acksPending++;
    return TransportAckResult.DUPLICATE;
  }
  /* #stripped LOG_TRACE(`Accepting message: ${messageID}`) */

  this._lastReceived = messageID;
  this._acksPending++;
  return TransportAckResult.OK;
};

TransportAcks.prototype.setAcked = function setAcked () {
  this._lastAcked = Long.fromValue(this._lastReceived);
  this._acksPending = 0;
};

prototypeAccessors.acksPending.get = function () {
  return this._acksPending;
};

prototypeAccessors.lastAcked.get = function () {
  return this._lastAcked;
};

/**
 * Resets the beginning of the ack sequence to the given value.
 * @param {Long} value The value to set as last acknowledged ID.
 */
prototypeAccessors.lastAcked.set = function (value) {
  /* #stripped LOG_TRACE('Setting last acked:', value.toString()) */

  Object.assign(this, {
    _lastAcked:  Long.fromValue(value),
    _lastReceived: Long.fromValue(value),
  });
};

prototypeAccessors.lastReceived.get = function () {
  return this._lastReceived;
};

TransportAcks.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( TransportAcks.prototype, prototypeAccessors );

module.exports = {
  TransportAcks: TransportAcks,
  TransportAckResult: TransportAckResult,
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(3);
var Long = ref.Long;

var DEFAULTS = {
  _lastAcked: Long.fromNumber(0, true),
  _lastSent:  Long.fromNumber(0, true),
  _next:      Long.fromNumber(1, true),
};

var longToString = function (v) { return v.toString(10); };

var MessageIds = function MessageIds(attrs) {
  Object.assign(this, DEFAULTS, attrs);
};

var prototypeAccessors = { lastAcked: {},lastSent: {},next: {} };

prototypeAccessors.lastAcked.get = function () {
  return this._lastAcked;
};
prototypeAccessors.lastAcked.set = function (value) {
  this._lastAcked = Long.fromValue(value);
};

prototypeAccessors.lastSent.get = function () {
  return this._lastSent;
};
MessageIds.prototype.setLastSent = function setLastSent (id) {
  this._lastSent = Long.fromValue(id);
  this._next = this._lastSent.add(1);
};

prototypeAccessors.next.get = function () {
  return this._next;
};

MessageIds.prototype[util.inspect.custom] = function () {
  return {
    'lastAcked': longToString(this.lastAcked),
    'lastSent':longToString(this.lastSent),
    'next':    longToString(this.next),
  };
};

MessageIds.prototype.toString = function toString () {
  return util.inspect(this);
};

Object.defineProperties( MessageIds.prototype, prototypeAccessors );

module.exports.MessageIds = MessageIds;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$1.MessagePublisherAcknowledgeMode;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;


var MessagePublisherPropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'MessagePublisherProperties', instance);
    v('enabled', [valBoolean]);
    v('windowSize', [valNumber], [valRange, 1, 255]);
    v('acknowledgeTimeoutInMsecs', [valNumber], [valRange, 20, 60000]);
    v('acknowledgeMode', [valIsMember, MessagePublisherAcknowledgeMode, 'MessagePublisherAcknowledgeMode']);
    v('connectRetryCount', [valNumber], [valRange, 0, Number.MAX_VALUE]);
    v('connectTimeoutInMsecs', [valNumber], [valRange, 50, Number.MAX_VALUE]);
  },
};

module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var util = __webpack_require__(6);
var ref = __webpack_require__(36);
var Flow = ref.Flow;
var PrivateFlowEventName = ref.PrivateFlowEventName;
var ref$1 = __webpack_require__(1);
var LogFormatter = ref$1.LogFormatter;
var ref$2 = __webpack_require__(55);
var MessagePublisherEventName = ref$2.MessagePublisherEventName;
var ref$3 = __webpack_require__(102);
var MessagePublisherProperties = ref$3.MessagePublisherProperties;
var ref$4 = __webpack_require__(194);
var PublisherFSM = ref$4.PublisherFSM;
var ref$5 = __webpack_require__(57);
var PublisherFSMEvent = ref$5.PublisherFSMEvent;
var ref$6 = __webpack_require__(56);
var PublisherFSMEventNames = ref$6.PublisherFSMEventNames;

var ref$7 = new LogFormatter();
var LOG_WARN = ref$7.LOG_WARN;

var MessagePublisher = (function (Flow) {
  function MessagePublisher(ref) {
    if ( ref === void 0 ) ref = {};
    var properties = ref.properties;
    var sessionInterfaceFactory = ref.sessionInterfaceFactory;

    var applyProperties = new MessagePublisherProperties(properties);
    Flow.call(this, applyProperties, sessionInterfaceFactory, {
      direct: MessagePublisherEventName.ACKNOWLEDGED_MESSAGE,
      emits:  MessagePublisherEventName.values, // super adds MessageConsumerEventName
    });
    this._fsm = this._makeFSM();
    var logger = new LogFormatter();
    logger.formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        '[message-publisher]' ].concat( args );
    };
    this.log = logger.wrap(this.log, this);

    // Doesn't emit anything unless started; won't start unless bindWaiting
    this._bindWaiting = true;

    this.on(PrivateFlowEventName.BIND_WAITING, this._onBindWaiting.bind(this));
    this.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, this._onBindFailed.bind(this));
    this.on(MessagePublisherEventName.DOWN, this._onDown.bind(this));
    this.on(MessagePublisherEventName.UP, this._onUp.bind(this));
  }

  if ( Flow ) MessagePublisher.__proto__ = Flow;
  MessagePublisher.prototype = Object.create( Flow && Flow.prototype );
  MessagePublisher.prototype.constructor = MessagePublisher;

  var prototypeAccessors = { flowId: {},name: {},publisherId: {},properties: {} };

  MessagePublisher.prototype._onBindFailed = function _onBindFailed () {
    this._bindWaiting = false;
  };

  MessagePublisher.prototype._onBindWaiting = function _onBindWaiting () {
    this._bindWaiting = true;
  };

  MessagePublisher.prototype._onDown = function _onDown () {
    this._bindWaiting = false;
  };

  MessagePublisher.prototype._onUp = function _onUp () {
    this._bindWaiting = false;
  };

  /**
   * @override
   * @private
   */
  MessagePublisher.prototype._makeFSM = function _makeFSM () {
    return new PublisherFSM({
      publisher:        this,
      name:             'PublisherFSM',
      sessionInterface: this._sessionInterface,
      properties:       this._properties,
    });
  };

  /**
   * @returns {Long} The flow ID of this flow
   */
  prototypeAccessors.flowId.get = function () {
    return this._flowId;
  };
  /**
   * @param {Long} value The flow ID for this flow
   * @private
   */
  prototypeAccessors.flowId.set = function (value) {
    this._flowId = value;
  };

  /**
   * @returns {String} The publisher name set for this flow
   */
  prototypeAccessors.name.get = function () {
    return this._flowName;
  };
  /**
   * @param {String} value The name to set on this flow
   * @private
   */
  prototypeAccessors.name.set = function (value) {
    this._flowName = value;
  };

  /**
   * @returns {Number} The publisher ID set on this flow
   */
  prototypeAccessors.publisherId.get = function () {
    return this._publisherId;
  };
  /**
   * @param {Number} value The publisher ID to set on this flow
   */
  prototypeAccessors.publisherId.set = function (value) {
    this._publisherId = value;
  };

  /**
   * @readonly
   * @returns {solace.MessagePublisherProperties} A clone of the publisher's properties.
   */
  prototypeAccessors.properties.get = function () {
    return this._properties.clone();
  };

  /**
   *
   * @override
   * @memberof MessagePublisher
   */
  MessagePublisher.prototype.connect = function connect () {
    Flow.prototype.connect.call(this);
    if (!this._fsm.getCurrentState()) {
      this._fsm.start();
    }
  };

  /**
   * Application has disconnected the session, so
   * disconnects the Guaranteed Message Publisher.
   * @private
   */
  MessagePublisher.prototype._disconnectSession = function _disconnectSession () {
    Flow.prototype._disconnectSession.call(this);
    this.processFSMEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_CLOSE }));
  };

  /**
   * @returns {solace.MessagePublisherEventName} The name of the disposed event for this flow
   * @private
   */
  MessagePublisher.prototype.getDisposedEvent = function getDisposedEvent () { // eslint-disable-line class-methods-use-this
    return MessagePublisherEventName.DISPOSED;
  };

  /**
   * Handles an incoming ACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @private
   */
  MessagePublisher.prototype.handleAck = function handleAck (id) {
    this.processFSMEvent(new PublisherFSMEvent(
      { name: PublisherFSMEventNames.ACK },
      { ack: id }
    ));
  };

  /**
   * Handles an incoming NACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @param {AdCtrlMessage} ctrlMessage The NACK message
   * @private
   */
  MessagePublisher.prototype.handleNack = function handleNack (id, ctrlMessage) {
    this.processFSMEvent(new PublisherFSMEvent(
      { name: PublisherFSMEventNames.ACK },
      { nack: id, ctrlMessage: ctrlMessage }
    ));
  };

  /**
   * @override
   */
  MessagePublisher.prototype.handleUncorrelatedControlMessage = function handleUncorrelatedControlMessage (message) {
    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.CLIENTACK:
        {
          var id = message.getLastMsgIdAcked();
          if (message.smfHeader.pm_respcode > 299) {
            this.handleNack(id, message);
          } else {
            this.handleAck(id);
          }
          break;
        }
      case SMFAdProtocolMessageType.CLIENTNACK:
        {
          var id$1 = message.getLastMsgIdAcked();
          this.handleNack(id$1, message);
          break;
        }
      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
        this.processFSMEvent(new PublisherFSMEvent(
          { name: PublisherFSMEventNames.FLOW_UNBOUND })
        );
        break;
      default:
        LOG_WARN(("Dropping unhandled AD control message for " + (this)),
                 SMFAdProtocolMessageType.describe(msgType));
    }
  };

  /**
   * Prepares an AD message for publishing on this flow.
   * @param {Message} dataMsg The message to be prepared for publishing.
   * @returns {TransportReturnCode} transport level returnCode
   * @private
   */
  MessagePublisher.prototype.prepareAdMessageAndSend = function prepareAdMessageAndSend (dataMsg) {
    return this._fsm.prepareAdMessageAndSend(dataMsg);
  };

  MessagePublisher.prototype.isBindWaiting = function isBindWaiting () {
    return this._bindWaiting;
  };

  /**
   * @returns {String} Formatted inspector output
   * @private
   */
  MessagePublisher.prototype[util.inspect.custom] = function () {
    return Object.assign(Flow.prototype[util.inspect.custom].call(this), {
      'name':        this.name,
      'publisherId': this.publisherId,
    });
  };

  /**
   * @override
   */
  MessagePublisher.prototype.toString = function toString () {
    return util.inspect(this);
  };

  /**
   * Disposes the FSM associated with this flow.
   *
   * @private
   */
  MessagePublisher.prototype._disposeFSM = function _disposeFSM () {
    this.processFSMEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.DISPOSE }));
  };

  MessagePublisher.prototype._isDisconnected = function _isDisconnected () {
    return this._fsm.isDisconnected();
  };

  Object.defineProperties( MessagePublisher.prototype, prototypeAccessors );

  return MessagePublisher;
}(Flow));

module.exports.MessagePublisher = MessagePublisher;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LogFormatter = ref$1.LogFormatter;
var ref$2 = __webpack_require__(3);
var Long = ref$2.Long;
var ref$3 = __webpack_require__(191);
var MessageIds = ref$3.MessageIds;
var ref$4 = __webpack_require__(39);
var MessagePublisherAcknowledgeMode = ref$4.MessagePublisherAcknowledgeMode;
var ref$5 = __webpack_require__(55);
var MessagePublisherEventName = ref$5.MessagePublisherEventName;
var ref$6 = __webpack_require__(36);
var PrivateFlowEventName = ref$6.PrivateFlowEventName;
var ref$7 = __webpack_require__(57);
var PublisherFSMEvent = ref$7.PublisherFSMEvent;
var ref$8 = __webpack_require__(56);
var PublisherFSMEventNames = ref$8.PublisherFSMEventNames;
var ref$9 = __webpack_require__(195);
var PublisherStateNames = ref$9.PublisherStateNames;
var ref$10 = __webpack_require__(15);
var State = ref$10.State;
var StateMachine = ref$10.StateMachine;
var ref$11 = __webpack_require__(19);
var StatType = ref$11.StatType;
var ref$12 = __webpack_require__(23);
var TransportReturnCode = ref$12.TransportReturnCode;

var ConnectReason = {
  INIT:     0, // never connected: message renumbering required
  RESUME:   1, // connected before
  FAILOVER: 2, // after a DR failover: message renumbering and message republish event required
};

var PublisherFSM = (function (StateMachine) {
  function PublisherFSM(ref) {
    if ( ref === void 0 ) ref = {};
    var publisher = ref.publisher;
    var name = ref.name;
    var sessionInterface = ref.sessionInterface;
    var properties = ref.properties;

    StateMachine.call(this, { name: name });
    /** @type {MessagePublisher} */
    var fsm = this;
    var currentState = function () {
      var state = fsm.getCurrentState();
      return state ? state.getName() : '<not running>';
    };
    this.logger = new LogFormatter(function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
      ("[session=" + (sessionInterface.sessionIdHex) + "]"),
      ("[message-publisher-fsm=" + (publisher.flowIdDec) + "]"),
      ("[" + (currentState()) + "]") ].concat( args );
    });
    this.log = this.logger.wrap(this.log, this);
    var ref$1 = this.logger;
    var LOG_TRACE = ref$1.LOG_TRACE;
    var LOG_DEBUG = ref$1.LOG_DEBUG;
    var LOG_INFO = ref$1.LOG_INFO;

    Object.assign(this, {
      _publisher:                 publisher,
      _acknowledgeMode:           properties.acknowledgeMode,
      _acknowledgeTimeoutInMsecs: properties.acknowledgeTimeoutInMsecs,
      _sessionInterface:          sessionInterface,
      _windowSize:                properties.windowSize,
      _stateEvents:               [],
    });
    // The publisher is not even constructed when publisherProperties.enabled is false
    // so we could just set _guaranteedEnabled to true, but lets be thorough as at
    // some point we may want to have sendADMessage() be responsible for throwing all
    // errors. As it is, when publisher properties enabled is false, the session-fsm
    // throws an error and when the message-spool is shutdown (close-flow received) the
    // publisher-fsm thtows and error.
    this._guaranteedEnabled = properties.enabled;
    this._sendWindow = properties.windowSize;
    this._resetConnectedInfo();
    this._notifiedWindowClosed = false;
    // We need a boolean to track the transport flow
    // controlled state. prepareAdMessageAndSend is called by the
    // session to prepare a message for publish and we
    // need to return whether or not we are flow controlled
    // without invoking the FSM or calling methods on the
    // FSM.
    // We consider all down states and all resending states equal
    // to flow-controlled as in all states me must queue the message
    // to the unacked list and not attempt to send directly.
    // This is strictly a performance issue.
    this._transportFlowControlled = true;

    this.initial(function onInitial() {
      return this.transitionTo(fsm.PublisherUnbound,
                               function (context) {
                                 /* #stripped LOG_TRACE(`Starting ${context.getStateMachine().getName()}`) */

                               }
      );
    });

    fsm.unhandledEventReaction(function onUnhandledEvent(event) {
      switch (event.getName()) {
        case PublisherFSMEventNames.FLOW_UNBOUND:
          // the router has closed the flow, likely due to operator
          // shutdown on the message spool. Throw on any attempt
          // to publish
          this._guaranteedEnabled = false;
          this._publisher.emit(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN);
          return this.transitionTo(
            fsm.PublisherUnbound,
            function (context) {
              /* #stripped LOG_TRACE(`Received close publisher for ${context.getStateMachine().getName()}`) */

            });
        case PublisherFSMEventNames.DISPOSE:
          /* #stripped LOG_TRACE('Received dispose request') */

          break;
        case PublisherFSMEventNames.TRANSPORT_FULL:
          /* #stripped LOG_TRACE('Received TRANSPORT_FULL') */

          break;
        case PublisherFSMEventNames.CAN_SEND:
          // This is ok because the session just sends the publisher CAN_SEND whenever received
          // from transport, even if the publisher is not in use, or hasn't caused the flow control
          /* #stripped LOG_TRACE('Received CAN_SEND when not flow controlled') */

          break;
        default:
          /* #stripped LOG_TRACE(`Ignoring event ${event.getName()}`) */

      }
      return this;
    });

    fsm.PublisherUnbound = new State({
      name:          PublisherStateNames.UNBOUND,
      parentContext: fsm,
    }, {
      emitDownAndBindWaiting: function emitDownAndBindWaiting() {
        /* #stripped LOG_TRACE('Emit down and bind waiting') */

        publisher.emit(MessagePublisherEventName.DOWN);
        publisher.emit(PrivateFlowEventName.BIND_WAITING);
      },
    })
      .entry(function onEntry() {
        this.emitDownAndBindWaiting();
        fsm._bindRetryCount = properties.bindRetryCount;
      })
      .reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbind() {
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.SESSION_UP, function onSessionUp() {
        return this.transitionTo(fsm.PublisherOpenFlowSent);
      });

    fsm.PublisherOpenFlowSent = new State({
      name:          PublisherStateNames.OPENFLOWSENT,
      parentContext: fsm,
    }, {
      emitOpenFlowFailedError: function emitOpenFlowFailedError(details) {
        publisher.emit(MessagePublisherEventName.CONNECT_FAILED_ERROR, details);
      },
      /**
       * @param {AdProtocolMessage} adpMsg An OPENFLOW response.
       * @description Handle an incoming Guaranteed Messaging Protocol Message.
       * @returns {?} The result of processing an event, or null if no event was dispatched.
       * @private
       */
      handleOpenFlowResponse: function handleOpenFlowResponse(adpMsg) {
        var smfRespHeader = adpMsg.smfHeader;
        var respCode = smfRespHeader.pm_respcode;
        /*
         * Assured Control Protocol messages are received on publisher and consumer flows. The
         * message types for each are unique, so we can determine whether it is a publisher or
         * consumer by message type.  A specific publisher or consumer is found by the flowId, or
         * by the correlation tag in the case of OPEN-FLOW (publisher) or BIND (consumer) responses.
         */
        if (adpMsg.msgType !== SMFLib.SMFAdProtocolMessageType.OPENPUBFLOW) {
          return fsm.processEvent(new PublisherFSMEvent(
              { name: PublisherFSMEventNames.FLOW_FAILED },
              {
                returnCode:  respCode,
                description: ("Unexpected response: " + (SMFLib.SMFAdProtocolMessageType.describe(adpMsg.msgType))),
              }
          ));
        }

        /*
         * The response code will indicate whether we create a PUB_FLOW_UP (200 OK) event
         * or a PUB_FLOW_FAIL (any other response) event, or treat this as an invalid
         * message (received a OPEN-PUB-FLOW request).
         */

        if (respCode === null) {
          // Drop message and increment stats
          publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          /* #stripped LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${
                    sessionInterface.sessionIdHex}`) */

          return null;
        }

        if (respCode !== 200) {
          var respStr = smfRespHeader.pm_respstr;
          var mappedSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respStr);
          return fsm.processEvent(new PublisherFSMEvent(
            { name: PublisherFSMEventNames.FLOW_FAILED },
            {
              subcode:     mappedSubcode,
              returnCode:  respCode,
              description: respStr,
            })
          );
        }

        /* #stripped LOG_TRACE('Handling OPENPUBFLOW message') */


        // typical response: { lastmsgidacked window flowid flowname publisher_id }

        var lastMsgIDAcked = adpMsg.getLastMsgIdAcked();
        var window = adpMsg.getWindow();
        var flowId = adpMsg.getFlowId();
        var flowName = adpMsg.getFlowName();
        var publisherId = adpMsg.getPublisherId();

        /* #stripped LOG_DEBUG(`OPENPUBFLOW response attributes: lastMsgIDAcked=${lastMsgIDAcked} window=${window} flowId=${flowId} flowName=${flowName} publisherId=${publisherId}`) */


        /* #stripped LOG_TRACE(`Local before handling response: ${fsm._messageIds}`) */


        if (window === undefined) {
          return fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  { description: 'Window parameter not found' })
          );
        }
        if (window > this._windowSize) {
          return fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  { description: 'Invalid window negotiation' })
          );
        }
        // reduce sendWindow by the size of unAckedList but do not reduce below zero
        fsm._sendWindow = window - fsm._unackedList.length;
        if (fsm._sendWindow < 0) { fsm._sendWindow = 0; }

        // update publisher info before renumbering
        Object.assign(fsm._publisher, {
          name: flowName,
          flowId: flowId,
          publisherId: publisherId,
        });
        // we may have been disabled by a previous closeFlow messsage, now that
        // we know hte message spool is enabled again, set _guaranteedEnabled back
        // to true
        fsm._guaranteedEnabled = true;

        if ((fsm._connectReason === ConnectReason.INIT) ||
          (fsm._connectReason === ConnectReason.FAILOVER)) {
          // reset 'lastSent' before renumbering
          fsm._messageIds.setLastSent(lastMsgIDAcked);

          /* #stripped LOG_DEBUG(`Renumbering unacked/unsent messages: fsm._messageIds=${fsm._messageIds}, lastMsgIDAcked=${lastMsgIDAcked}, type=${fsm._connectReason}`) */

          if (fsm._connectReason === ConnectReason.FAILOVER) {
            publisher.emit(MessagePublisherEventName.FLOW_NAME_CHANGED, {
              messages: [].concat( fsm._unackedList ),
              count:    fsm._unackedList.length,
            });
          }
          fsm._connectReason = ConnectReason.RESUME;
          fsm._unackedList.forEach(function (message) {
            var oldId = message.getGuaranteedMessageId();
            fsm._renumber(message);
            /* #stripped LOG_TRACE(`Renumbering message ID: from ${oldId} to ${message.getGuaranteedMessageId()}`) */

            fsm._messageIds.setLastSent(message.getGuaranteedMessageId());
          });
        } else {
          // the flowId changes on every open Flow so set it properly in the unacked List
          // if the router has enabled 'Allow Unknown Publisher Flow' the publisherId can
          // change too.  It's quuestionable what we do here at all, but to be compatible with
          // other APIs, set the publisherID just in case.
          // TODO: revisit this code in the next release, we could have the getter for
          // publisherID retrieve it from the flow (as CCSMP does) at encoding time and
          // avoid this. In the minimum consider gathering these setters into a function
          // that is invoked both here and by 'renumber'
          fsm._unackedList.forEach(function (message) {
            message.setFlowId(flowId);
            message.setPublisherId(publisher.publisherId);
            /* #stripped LOG_TRACE(`Set FlowId to ${flowId} in msg# ${message.getGuaranteedMessageId()}`) */

          });
        }

        if (fsm._unackedList.length) {
          fsm._handleAck(lastMsgIDAcked, false, adpMsg, true);
          // the starting point for retransmitting.  If lastMsgIdAcked doesn't
          // ack anything this does not get updates, causing us to possible send
          // messages out of order, or not start sending at all
          fsm._firstUnackedToSend = fsm._unackedList[0];
        } else {
          fsm._messageIds.lastAcked = Long.fromValue(lastMsgIDAcked);
        }
        /* #stripped LOG_TRACE(`Local after applying lastMsgIDAcked: ${fsm._messageIds}`) */


        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_UP }));
      },
      /**
       * @returns {?} The result of processing an BIND_TIMEOUT event
       * @private
       */
      handleOpenFlowTimeout: function handleOpenFlowTimeout() {
        LOG_INFO('Open publisher connection timeout');
        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.BIND_TIMEOUT }));
      },
      handleUnknownFlowName: function handleUnknownFlowName() {
        LOG_INFO('Flow name unknown, republish required');
        // Don't send the FLOW_NAME_CHANGED message yet -- it specifically indicates
        // that duplicate messages should be expected. Wait until the flow is successfully
        // connected and messages are being renumbered.
        fsm._resetConnectedInfo(true);
        return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
      },
      /**
       * Send a Publisher Open Flow Request.
       * @private
       */
      sendOpenFlow: function sendOpenFlow() {
        var this$1 = this;

        var correlationTag = sessionInterface.getCorrelationTag();
        var openPubFlowMsg = SMFLib.AdProtocolMessage.getOpenMessagePublisher(
          fsm._messageIds.lastAcked,
          fsm._messageIds.lastSent,
          properties.windowSize,
          fsm._publisher._flowName,
          correlationTag
        );
        sessionInterface.sendControl(openPubFlowMsg);
        sessionInterface.enqueueRequest(correlationTag,
                                        function () { return this$1.handleOpenFlowTimeout(); },
                                        properties.connectTimeoutInMsecs,
                                        null,
                                        function (rxMsgObj) { return this$1.handleOpenFlowResponse(rxMsgObj); });
        /* #stripped LOG_TRACE('Sent open publisher connection') */

      },
    })
      .entry(function onEntry() {
        this.sendOpenFlow();
      })
      .reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
        return this.transitionTo(fsm.PublisherCloseFlowSent);
      })
      .reaction(PublisherFSMEventNames.FLOW_UP, function onFlowUp() {
        return this.transitionTo(fsm.PublisherUp);
      })
      .reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.BIND_TIMEOUT, function onOpenFlowTimeout() {
        if (fsm._bindRetryCount > 0) {
          fsm._bindRetryCount--;
          return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
        }
        this.emitOpenFlowFailedError({
          subcode:     ErrorSubcode.TIMEOUT,
          description: 'Open publisher connection failed due to timeout',
        });
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.FLOW_FAILED, function onFlowFailed(pEvent) {
        var subcode = pEvent.subcode;
        var returnCode = pEvent.returnCode;
        var description = pEvent.description;
        switch (pEvent.subcode) {
          case ErrorSubcode.UNKNOWN_FLOW_NAME:
            // DR or long HA failover
            return this.handleUnknownFlowName();
          // case ErrorSubcode.GM_NOT_READY: Fail the session
          default:
            this.emitOpenFlowFailedError({
              event: pEvent,
              subcode: subcode,
              returnCode: returnCode,
              description: description,
            });
            // Otherwise, the flow is invalid
            fsm._resetConnectedInfo();
        }
        return this.transitionTo(fsm.PublisherUnbound);
      });

    fsm.PublisherCloseFlowSent = new State({
      name:          PublisherStateNames.CLOSEFLOWSENT,
      parentContext: fsm,
    }, {
      handleCloseFlowResponse: function handleCloseFlowResponse(response) {
        var smfRespHeader = response.smfHeader;
        var respCode = smfRespHeader.pm_respcode;

        if (response.msgType !== SMFLib.SMFAdProtocolMessageType.CLOSEPUBFLOW) {
          return fsm.processEvent(new PublisherFSMEvent(
            { name: PublisherFSMEventNames.FLOW_FAILED },
            {
              returnCode:  respCode,
              description: ("Unexpected response: " + (SMFLib.SMFAdProtocolMessageType.describe(response.msgType))),
            }));
        }

        if (respCode === null) {
          // Drop message  and increment stats
          publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
          /* #stripped LOG_DEBUG(`Drop Close-Publisher-Flow Request message on sessionId 0x${
                    sessionInterface.sessionIdHex}`) */

          return null;
        }

        if (respCode !== 200) {
          fsm.processEvent(
            new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED },
                                  {
                                    returnCode:  respCode,
                                    description: smfRespHeader.pm_respstr,
                                  }));
        }

        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_UNBOUND }));
      },

      handleCloseFlowTimeout: function handleCloseFlowTimeout() {
        LOG_INFO('Close publisher connection timeout.');
        return fsm.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.UNBIND_TIMEOUT }));
      },

      sendCloseFlow: function sendCloseFlow() {
        var this$1 = this;

        var correlationTag = sessionInterface.getCorrelationTag();
        var closePubFlowMsg = SMFLib.AdProtocolMessage.getCloseMessagePublisher(
          fsm._publisher.flowId,
          correlationTag
        );
        sessionInterface.sendControl(closePubFlowMsg);
        sessionInterface.enqueueRequest(correlationTag,
                                        function () { return this$1.handleCloseFlowTimeout(); },
                                        properties.connectTimeoutInMsecs,
                                        null,
                                        function (rxMsgObj) { return this$1.handleCloseFlowResponse(rxMsgObj); });
        /* #stripped LOG_TRACE('Sent close publisher connection') */

      },
    })
      .entry(function onEntry() {
        this.sendCloseFlow();
        return this;
      })
      .reaction(PublisherFSMEventNames.ACK, function onAck(event) {
        fsm._handleAckEvent(event);
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbound() {
        return this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.FLOW_FAILED, function onCloseFlowFailed(/*pEvent*/) {
        this.transitionTo(fsm.PublisherUnbound);
      })
      .reaction(PublisherFSMEventNames.UNBIND_TIMEOUT, function onCloseFlowTimeout() {
        return this.transitionTo(fsm.PublisherCloseFlowSent);
      });

    fsm.PublisherUp = new State({
      name:          PublisherStateNames.UP,
      parentContext: fsm,
    }, {
      emitFlowUp: function emitFlowUp() {
        publisher.emit(MessagePublisherEventName.UP);
      },
    })
      .initial(function initial() {
        return this.transitionTo(
          fsm._unackedList.length
            ? fsm.PublisherRetransmitting
            : fsm.PublisherDataXfer
        );
      })
      .entry(function onEntry() {
        var this$1 = this;

        // The state isn't changed on entry, so don't emit yet.
        /* #stripped LOG_DEBUG('Flow is UP') */

        fsm._scheduleStateEvents(fsm.PublisherUp, function () { return this$1.emitFlowUp(); });
        return this;
      })
      .reaction(PublisherFSMEventNames.ACK, function onAck(event) {
        /* #stripped LOG_DEBUG('Ack received') */

        fsm._handleAckEvent(event);
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.ACK_TIMEOUT, function onAckTimeout() {
        // the starting point when we get the CAN_SEND
        fsm._firstUnackedToSend = fsm._unackedList[0];
        return this.transitionTo(fsm.PublisherRetransmitting);
      })
        .reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
          return this.transitionTo(fsm.PublisherCloseFlowSent);
        })
        .reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
          return this.transitionTo(fsm.PublisherUnbound);
        })
        .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onWindowClosed() {
          return this.internalTransition();
        });

    fsm.PublisherDataXfer = new State({
      name:          PublisherStateNames.DATA_XFER,
      parentContext: fsm.PublisherUp,
    })
      .entry(function () {
        // publisher is up and capable of sending GM messages directly from the application
        fsm._transportFlowControlled = false;
        // TODO: We don't need a CAN_SEND if we're going to emit a FLOW_UP,
        // but we need a better way to manage these deferred events.
        fsm._scheduleStateEvents(fsm.PublisherDataXfer, function () { return fsm._maybeEmitCanSend(); });
      })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        return this.transitionTo(fsm.PublisherFlowControlled);
      })
      .exit(function () {
        // publisher cannot send messages to transport and must queue in unAckedList until
        // re-entering PublisherDataXfer
        // set a FSM boolean that is checked in prepareADMessageAndSend() we
        // need to avoid FSM interactions on the fast path so resort to
        // this boolean.
        fsm._transportFlowControlled = true;
      });

    fsm.PublisherFlowControlled = new State({
      name:          PublisherStateNames.FLOW_CONTROLLED,
      parentContext: fsm.PublisherUp,
    })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        // Unusual event, as only the FSM can send messages when we're in flow-controlled state
        LOG_INFO('Attempt to send while flow controlled');
        // Fall out and do the action for PublisherUp
        return this.internalTransition();
      })
      .reaction(PublisherFSMEventNames.CAN_SEND, function onCanSend() {
        //
        // start sending from tune unAcked list.
        return this.transitionTo(fsm.PublisherRetransmitting);
      });

    fsm.PublisherRetransmitting = new State({
      name:          PublisherStateNames.RETRANSMITTING,
      parentContext: fsm.PublisherUp,
    }, {
      retransmit: function retransmit() {
        try {
          fsm._resendFromUnacked();
        } catch (ex) {
          // Resend failed:
          if (ex instanceof OperationError && ex.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
            /* #stripped LOG_DEBUG('Publisher resendFromUnacked blocked due to insufficient space, wait for CAN_SEND') */

            fsm.processEvent(
              new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
          } else {
            // send failed.  Fail the publisher
            LOG_INFO(("Publisher resendFromUnacked failed: " + ex));
            fsm.processEvent(
              new PublisherFSMEvent({ name: PublisherFSMEventNames.FLOW_FAILED }));
          }
        }
      },
    })
      .entry(function onEntry() {
        this.retransmit();
      })
      .reaction(PublisherFSMEventNames.RESEND_COMPLETE, function onResendComplete() {
        return this.transitionTo(fsm.PublisherDataXfer);
      })
      .reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
        // Transport flow controlled while resending/recovering from flow control. Go
        // to flow controlled state and wait for CAN_SEND
        /* #stripped LOG_DEBUG(`Transport full while retransmitting, unacked remaining: ${fsm._unackedList.length}`) */

        // Fall out and do the action for PublisherUp
        return this.transitionTo(fsm.PublisherFlowControlled);
      });
  }

  if ( StateMachine ) PublisherFSM.__proto__ = StateMachine;
  PublisherFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  PublisherFSM.prototype.constructor = PublisherFSM;

  PublisherFSM.prototype.isDisconnected = function isDisconnected () {
    if (!this.getCurrentState()) { return true; }
    return !!this.getActiveState(PublisherStateNames.UNBOUND);
  };

  /**

   * Prepare and send a Guaranteed Message. This method updates FSM variables including
   * lastSendMessage.
   *
   * @private
   * @param {Message} dataMsg The message to prepare
   * @returns {TransportReturnCode} return the status from the transport send
   */
  PublisherFSM.prototype.prepareAdMessageAndSend = function prepareAdMessageAndSend (dataMsg) {
    if (!this._guaranteedEnabled) {
      throw new OperationError('Session does not provide Guaranteed Message Publish capability',
        ErrorSubcode.GM_UNAVAILABLE,
        'close flow received from message-router');
    }
    if (this._sendWindow <= 0) {
      this._publisher.incStat(StatType.TX_WINDOW_CLOSED);
      this._notifiedWindowClosed = true;
      throw new OperationError(
        'Guaranteed Message Window Closed',
        ErrorSubcode.INSUFFICIENT_SPACE
      );
    }

    var unackedList = this._unackedList;
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;

    --this._sendWindow;

    this._renumber(dataMsg);
    var dupMsg = dataMsg.clone();
    unackedList.push(dupMsg);
    // Update the messgeIds, lastSend/next values only on a successful send or enqueue,
    // from this point on we will return OK from this send method.
    var msgId = dupMsg.getGuaranteedMessageId();
    this._messageIds.setLastSent(msgId);
    /* #stripped LOG_TRACE(`Prepare and send AD message ID = ${msgId}, 
      unackedListSize = ${unackedList.length}, sendWindow = ${this._sendWindow}`) */

    // Note that the transport sender can be flow controlled at the transport
    // level, which means the message should not be sent. So simply return
    // We also consider set-up/down-states as _transportFlowControlled. We must be up
    // and not retransmitting to
    // send directly from application space.
    if (this._transportFlowControlled) {
      // we may receive acknowledgements while transport flow controlled which can
      // cause our firstUnAckedToSend to become undefined, if this is the first message
      // queued in that case, set firstUnAckedToSend
      if (this._firstUnackedToSend === undefined) {
        this._firstUnackedToSend = dupMsg;
      }
      return TransportReturnCode.OK;
    }
    // We use the session sendToTransport directly which may throw or  otherwise
    // return an error. If so, catch the eror and remove the message from the unackedlist
    // before rethrowing the error.
    var returnCode;
    try {
      returnCode = this._sessionInterface.sendToTransport(dupMsg);
      if (returnCode !== TransportReturnCode.OK) {
        if (returnCode === TransportReturnCode.NO_SPACE) {
          returnCode = TransportReturnCode.OK;
          this._firstUnackedToSend = dupMsg;  // the starting point when we get the CAN_SEND
          this.processEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
        } else {
          //
          /* #stripped LOG_DEBUG(`prepareAdMessageAndSend: saw returnCode = ${returnCode}`) */

        }
      } else {
        // The message has successfully been sent once. Set the redelivered flag in case we need to
        // resend it later.
        dupMsg.setRedelivered(true);
      }
      // TBD: Should we start AckTimer when flow controlled?
      this._startAckTimer();
    } catch (ex) {
      if (ex instanceof OperationError) {
        /* #stripped LOG_DEBUG(`prepareAdMessageAndSend: caught OperationError: ${ErrorSubcode.describe(ex.subcode)} - ${ex.message}`) */

        // OperationErrors are encoding or other errors caused by the field contents the
        // application has set on the message.  So we throw the error back at the
        // application after undoing the queueing operations.
        unackedList.pop();
        this._messageIds.setLastSent(dupMsg.getGuaranteedPreviousMessageId());
        ++this._sendWindow;
        throw (ex);
      } else {
        /* #stripped LOG_DEBUG(`prepareAdMessageAndSend: caught ${ex.message}`) */

      }
    }
    return TransportReturnCode.OK;
  };

  PublisherFSM.prototype._handleAckEvent = function _handleAckEvent (event) {
    this._publisher.incStat(StatType.TX_ACKS_RXED);
    this._handleAck(event.ack || event.nack, !!event.nack, event.ctrlMessage);
  };

  PublisherFSM.prototype._handleAck = function _handleAck (id, nack, ctrlMessage, openFlow) {
    var this$1 = this;
    if ( ctrlMessage === void 0 ) ctrlMessage = undefined;
    if ( openFlow === void 0 ) openFlow = false;

    var ref = this;
    var messageIds = ref._messageIds;
    var unackedList = ref._unackedList;
    var ref$1 = this.logger;
    var LOG_DEBUG = ref$1.LOG_DEBUG;
    var LOG_INFO = ref$1.LOG_INFO;

    if (messageIds.lastAcked.gte(id)) {
      if (openFlow) {
        /* #stripped LOG_DEBUG(`Implicit acks up to date: remote ack for ${id}, local ids ${this._messageIds}`) */

      } else {
        LOG_INFO(("Dropping ack: remote ack for " + id + ", local ids " + (this._messageIds)));
      }
      return;
    }

    var reportAcked = [];

    // Assumption: the unacked message list is in increasing order of message ID.
    // The assured message ID should be automatically generated, immutable and
    // monotonically increasing.

    // While the acked ID is greater than an element at the beginning of the unacked list...
    while (unackedList.length &&
           id.gte(unackedList[0].getGuaranteedMessageId())) {
      // That unacked message is now acked. Shift it off and append to list of acked.
      reportAcked.push(unackedList.shift());
    }

    // if we have removed the firstUnacked, reset it to the beginning of the list
    if (unackedList.indexOf(this._firstUnackedToSend) === -1) {
      this._firstUnackedToSend = unackedList[0];
    }


    // Recover some window space from the acked IDs.
    this._sendWindow += reportAcked.length;
    /* #stripped LOG_DEBUG('Send window size is now', this._sendWindow) */



    // The last acked ID is now the one we received.
    // Don't let an exception in event dispatching prevent this from being set -- do it now.
    messageIds.lastAcked = id;

    // If we're NACKing, it's only the last message.
    var reportNacked = nack ? reportAcked.pop() : null;

    // Any ACKs?
    // reportAcked is constant from here on
    var numAcked = reportAcked.length;
    if (numAcked) {
      if (this._acknowledgeMode === MessagePublisherAcknowledgeMode.PER_MESSAGE) {
        /* #stripped LOG_DEBUG(`Ack received: lastAckedMsgId=${id}, numAckedMsgs=${numAcked}, numUnackedMsgs=${unackedList.length}`) */

        for (var i = 0; i < numAcked; ++i) {
          this$1._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, reportAcked[i]);
        }
      } else {
        var lastAckedMessage = reportAcked[numAcked - 1];
        /* #stripped LOG_DEBUG(`Acking single message with ID ${lastAckedMessage.getGuaranteedMessageId()} from router ack on ${id}`) */

        this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, lastAckedMessage);
      }
    }

    // Terminating NACK?
    if (reportNacked) {
      /* #stripped LOG_DEBUG(`Nacking single message with ID ${reportNacked.getGuaranteedMessageId()} from router ack on ${id}`) */

      this._publisher.emit(MessagePublisherEventName.REJECTED_MESSAGE, reportNacked, ctrlMessage);
    }

    /* #stripped LOG_DEBUG('Unacked messages remaining: ', unackedList.length) */


    if (unackedList.length) {
      // There are more messages to be acked. Reset the ack timer.
      this._resetAckTimer();
    } else {
      this._clearAckTimer();
    }
    //
    // send can-send to applicatino if necessary.
    this._maybeEmitCanSend();
  };

  PublisherFSM.prototype._maybeEmitCanSend = function _maybeEmitCanSend () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    if (!this._notifiedWindowClosed) { return; }
    if (this._sendWindow === 0) {
      // Should log this since it is called AFTER the state change
      /* #stripped LOG_TRACE('Suppressing CAN_SEND with zero window available') */

      return;
    }
    this._notifiedWindowClosed = false; // Set before emitting in case we re-enter
    this._publisher.emit(MessagePublisherEventName.CAN_SEND);
  };

  PublisherFSM.prototype._resendFromUnacked = function _resendFromUnacked () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    var LOG_DEBUG = ref.LOG_DEBUG;
    // We choose to start the ack timer after the message resend. The resend could
    // take longer than the ack timeout in poor conditions.
    //
    // If any message is successfully resent, we need to restart the ack timer,
    // even if we are throwing.
    var list = this._unackedList;
    var resendIndex = list.indexOf(this._firstUnackedToSend);
    if (resendIndex === -1) {
      // first Unacked may be null if all have been resent alreadygrunt -
      // in which case the list  should be empty
      if (this._firstUnackedToSend) {
        LOG_ERROR(("Could not find first Unacked Messages in unacked message list: msgId = " + (this._firstUnackedToSend.getGuaranteedMessageId)));
      }
      if (list.length === 0) {
        // Nothing to resend: return to DataXfer
        /* #stripped LOG_DEBUG(`Nothing to resend: ${this._messageIds.toString()}`) */

        this.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.RESEND_COMPLETE })
        );
      }
      return;
    }
    /* #stripped LOG_DEBUG(`Resending unacked messages from ${resendIndex} to ${list.length - 1}: `,
              list.map(m => m.getGuaranteedMessageId().toString())) */

    while (resendIndex < list.length) {
      if (list[resendIndex].getPublisherId() !== this$1._publisher.publisherId) {
        LOG_ERROR(("Resending on invalid publisherId '" + (list[resendIndex].getPublisherId()) + "'when it should be '" + (this$1._publisher.publisherId) + "'"));
      }
      var returnCode = this$1._sessionInterface.sendData(list[resendIndex]);
      if (returnCode === TransportReturnCode.NO_SPACE) {
        // the starting point when we get the CAN_SEND from the transport
        this$1._firstUnackedToSend = list[resendIndex];
        /* #stripped LOG_DEBUG('Publisher sendMessage blocked due to insufficient space, wait for CAN_SEND') */

        this$1.processEvent(
          new PublisherFSMEvent({ name: PublisherFSMEventNames.TRANSPORT_FULL }));
        return;
      }
      if (returnCode !== TransportReturnCode.OK) {
        // session-FSM is already processing the error
        return;
      }
      // The message has successfullly been sent once. Set the redelivered flag in case we need to
      // resend it later
      list[resendIndex].setRedelivered(true);
      resendIndex++;
      this$1._startAckTimer();
    }
    // Resend successful: return to DataXfer
    /* #stripped LOG_DEBUG(`Resend complete: ${this._messageIds.toString()}`) */

    this.processEvent(
      new PublisherFSMEvent({ name: PublisherFSMEventNames.RESEND_COMPLETE })
    );
  };

  PublisherFSM.prototype._resetConnectedInfo = function _resetConnectedInfo (failover) {
    if ( failover === void 0 ) failover = false;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Resetting connected flow info') */


    if (this._ackTimer) { this._clearAckTimer(); }

    Object.assign(this, {
      _messageIds: new MessageIds(),
    });

    Object.assign(this._publisher, {
      publisherId: undefined,
      flowId:      undefined,
      flowName:    null,
    });

    if (failover) {
      this._connectReason = ConnectReason.FAILOVER;
    } else {
      // Full reset
      this._unackedList = [];
      this._connectReason = ConnectReason.INIT;
    }
  };

  PublisherFSM.prototype._clearAckTimer = function _clearAckTimer () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE(`Clear ack timer ${this._ackTimer ? this._ackTimer : 'undefined or null or zero'}`) */

    if (!this._ackTimer) { return; }
    clearTimeout(this._ackTimer);
    this._ackTimer = null;
  };

  PublisherFSM.prototype._emitStateEvents = function _emitStateEvents () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE('Emitting deferred state events') */

    while (this._stateEvents.length) {
      var pair = this$1._stateEvents.shift();
      var state = pair[0];
      var event = pair[1];
      // If the state requesting this event is still active...
      if (this$1.getActiveState(state.getName())) {
        // then do its action
        event.apply(state);
      }
    }
  };

  /**
   * @private
   */
  PublisherFSM.prototype._handleAckTimeout = function _handleAckTimeout () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE('Ack Timeout') */

    this._ackTimer = null;
    this._publisher.incStat(StatType.TX_ACK_TIMEOUT);
    this.processEvent(new PublisherFSMEvent({ name: PublisherFSMEventNames.ACK_TIMEOUT }));
  };

  /**
   * If the remote flow changes, any remote state applied to the unacked messages needs to
   * be reapplied.
   *
   * @param {solace.Message} message The message to renumber.
   * @private
   */
  PublisherFSM.prototype._renumber = function _renumber (message) {
    var messageIds = this._messageIds;
    var current = messageIds.next;
    message.setGuaranteedPreviousMessageId(messageIds.lastSent);
    message.setGuaranteedMessageId(current);

    var publisher = this._publisher;
    message.setFlowId(publisher.flowId);
    message.setPublisherId(publisher.publisherId);
  };

  PublisherFSM.prototype._resetAckTimer = function _resetAckTimer () {
    this._clearAckTimer();
    this._startAckTimer();
  };

  PublisherFSM.prototype._scheduleStateEvents = function _scheduleStateEvents (state, event) {
    var this$1 = this;

    this._stateEvents.push([state, event]);
    this._setPostEventAction(function () { return this$1._emitStateEvents(); }, 'Emit state events');
  };

  PublisherFSM.prototype._setPostEventAction = function _setPostEventAction (action, desc) {
    var this$1 = this;
    if ( desc === void 0 ) desc = 'No action';

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;
    if (this._postEventAction && this._postEventAction.desc === desc) {
      /* #stripped LOG_DEBUG('Keeping same post event action') */

      return;
    }

    if (this._postEventAction && this._postEventAction.desc) {
      LOG_WARN(("Replacing post event action " + (this._postEventAction.desc) + " with " + desc));
    }
    this._postEventAction = { action: action || (function () {}), desc: desc };
    this.setPostEventAction(function () {
      this$1._postEventAction.action();
      this$1._postEventAction = null;
    });
  };

  /**
   * @private
   */
  PublisherFSM.prototype._startAckTimer = function _startAckTimer () {
    var this$1 = this;

    // const { LOG_TRACE } = this.logger;
    // LOG_TRACE(`Start ack timer ${this._ackTimer ? this._ackTimer : 'undefined or null or zero'
    //           }: ${this._acknowledgeTimeoutInMsecs} ms`);
    if (this._ackTimer) { return; }
    this._ackTimer = setTimeout(function () { return this$1._handleAckTimeout(); },
                                this._acknowledgeTimeoutInMsecs);
  };

  return PublisherFSM;
}(StateMachine));

module.exports.PublisherFSM = PublisherFSM;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/********************************************************************************
 * @private
 * @enum {string}
 * State names on the Publisher FSM
 ********************************************************************************/
var PublisherStateNames = {
  UNBOUND:         'PublisherUnbound',
  OPENFLOWSENT:    'PublisherOpenFlowSent',
  UP:              'PublisherUp',
  FAILED:          'PublisherFailed',
  CLOSEFLOWSENT:   'PublisherCloseFlowSent',
  DATA_XFER:       'PublisherDataXfer',
  FLOW_CONTROLLED: 'MessagePublisherFlowControlled',
  RETRANSMITTING:  'PublisherRetransmitting',
};

module.exports.PublisherStateNames = Enum.new(PublisherStateNames);


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var clone = __webpack_require__(149);
var ref = __webpack_require__(10);
var SDTCodec = ref.Codec;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var ref$2 = __webpack_require__(5);
var Destination = ref$2.Destination;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(1);
var LOG_DEBUG = ref$4.LOG_DEBUG;
var ref$5 = __webpack_require__(58);
var MessageCacheStatus = ref$5.MessageCacheStatus;
var ref$6 = __webpack_require__(59);
var MessageDeliveryModeType = ref$6.MessageDeliveryModeType;
var ref$7 = __webpack_require__(40);
var MessageDumpFlag = ref$7.MessageDumpFlag;
var ref$8 = __webpack_require__(60);
var MessageDumpUtil = ref$8.MessageDumpUtil;
var ref$9 = __webpack_require__(104);
var MessageType = ref$9.MessageType;
var ref$10 = __webpack_require__(61);
var MessageUserCosType = ref$10.MessageUserCosType;
var ref$11 = __webpack_require__(7);
var Parameter = ref$11.Parameter;
var ref$12 = __webpack_require__(10);
var SDTField = ref$12.SDTField;
var SDTFieldType = ref$12.SDTFieldType;
var SDTMapContainer = ref$12.SDTMapContainer;

var utf8ToUcs2 = Convert.utf8ToUcs2;
var isBoolean = Parameter.isBoolean;
var isEnumMember = Parameter.isEnumMember;
var isInstanceOf = Parameter.isInstanceOf;
var isInstanceOfOrNothing = Parameter.isInstanceOfOrNothing;
var isNumberOrNothing = Parameter.isNumberOrNothing;
var isStringOrNothing = Parameter.isStringOrNothing;

// When a message is cloned for sending,
// * We assume that it may NOT include circular references.
//   These are also unsupported in the encoder.
// * We assume that all properties to be cloned are enumerable.
//   This has significant (~10% AD send rate) performance impact.

var MESSAGE_CLONE_OPTIONS = { circular: false, includeNonEnumerable: false };

/**
 * Function called on construct/reset. Sets the initial values for fields that have them.
 * @param {Message} message The message to initialize
 * @internal
 */
function initMessage(message) {
  message._deliveryMode = MessageDeliveryModeType.DIRECT;
  message._userCos = MessageUserCosType.COS1;
  message._cacheStatus = MessageCacheStatus.LIVE;
  message._priority = undefined;
}

/**
 * Function called on reset only. Clears every field in the message. Call #initMessage
 * to set initial values.
 * @param {Message} message The message to clear
 * @internal
 */
function clearMessage(message) {
  var fields = Object.keys(message);
  fields.forEach(function (f) { return delete message[f]; });
}

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactory.createMessage}</b>
 * <p>
 * A message is a container that can be used to store and send messages to and from the
 * Solace Message Router.
 *
 * Applications manage the lifecycle of a message; a message is created by calling
 * {@link solace.SolclientFactory.createMessage} and is freed by dereferencing it.
 *
 * API operations that cache or mutate messages always take a copy. A message may
 * be created, mutated by the API user, and sent multiple times.
 *
 * The Message Object provides methods to manipulate the common Solace
 * message header fields that are optionally sent in the binary metadata
 * portion of the Solace message.
 *
 * Applications can also use the structured data API {@link solace.Message#setSdtContainer}
 * to add containers (maps or streams) and their fields to the binary payload or
 * to the User Property map contained within the binary metadata.
 *
 * This does not prevent applications from ignoring these
 * methods and sending payload in the binary payload as an opaque binary field for
 * end-to-end communications
 *
 * @memberof solace
 */
var Message = function Message() {
  initMessage(this);
};

var prototypeAccessors = { isAcknowledged: {},binaryMetadataChunk: {},smfHeader: {},hasAutoSequenceNumber: {},hasAutoSenderTimestamp: {} };

/**
 * Gets the payload type ({@link solace.MessageType}) of the message. A message has a
 * structured payload if one was attached via {@link solace.Message#setSdtContainer} otherwise
 * if the payload is attached via {@link Message@setBinaryAttachment} then it
 * is unstructured ((@link solace.MessageType#BINARY})
 *
 * @returns {solace.MessageType} The structured payload type.
 * @default {solace.MessageType.BINARY}
 */
Message.prototype.getType = function getType () {
  return this._messageType || MessageType.BINARY; // This is OK; BINARY === 0.
};

/**
 * Sets the application-provided message ID.
 * @param {?String} value The new value for the application-provided message ID.
 */
Message.prototype.setApplicationMessageId = function setApplicationMessageId (value) {
  this._applicationMessageId = isStringOrNothing('applicationMessageId', value);
};

/**
 * Gets the application-provided message ID.
 * @returns {?String} The application provided message ID.
 */
Message.prototype.getApplicationMessageId = function getApplicationMessageId () {
  return this._applicationMessageId;
};

/**
 * Sets the application message type. This value is used by applications
 * only, and is passed through the API and Solace Message Router untouched.
 * @param {?String} value The application message type.
 */
Message.prototype.setApplicationMessageType = function setApplicationMessageType (value) {
  this._applicationMessageType = isStringOrNothing('applicationMessageType', value);
};

/**
 * Gets the application message type. This value is used by applications
 * only, and is passed through the API and Solace Message Router untouched.
 * @returns {?String} The application message type.
 */
Message.prototype.getApplicationMessageType = function getApplicationMessageType () {
  return this._applicationMessageType;
};

/**
 * Gets the binary attachment part of the message. The binary attachment
 * is returned as a string, wherein each character has a code in the range
 * 0-255 representing the value of a single received byte at that position.
 *
 * @returns {?String} A string representing the binary attachment.
 */
Message.prototype.getBinaryAttachment = function getBinaryAttachment () {
  return this._binaryAttachment;
};

/**
 * Sets the binary attachment part of the message. The binary attachment
 * must be a string, wherein each character has a code in the range 0-255
 * representing exactly one byte in the attachment. When this method is
 * used, the message payload type is {@link solace.MessageType#BINARY}
 * See {solace.Message#getType}.
 *
 * Applications may set the binary attachment to NULL or undefined to
 * remove the binary attachment and create a message with no payload.
 *
 * @param {?String} value Sets the binary attachment part of the message.
 */
Message.prototype.setBinaryAttachment = function setBinaryAttachment (value) {
  this._setBinaryAttachment(isStringOrNothing('binaryAttachment', value));
  this._messageType = MessageType.BINARY;
};
Message.prototype._setBinaryAttachment = function _setBinaryAttachment (value) {
  this._binaryAttachment = value;
};

/**
 * Given a Message containing a cached message, return the cache Request Id that
 * the application set in the call to {@link solace.CacheSession#sendCacheRequest}.
 *
 * @returns {?Number} The request ID of the cache request associated with this message.
 */
Message.prototype.getCacheRequestId = function getCacheRequestId () {
  return this._cacheRequestId;
};

/**
 * @private
 * @param {Number} cacheRequestID The cache request ID associated with this message
 */
Message.prototype._setCacheRequestID = function _setCacheRequestID (cacheRequestID) {
  this._cacheRequestId = cacheRequestID;
};

/**
 * Gets the correlation ID.The message Correlation Id
 * is carried in the Solace message headers unmodified by the API and
 * the Solace Message Router. This field may be used for peer-to-peer
 * message synchronization and is commonly used for correlating
 * a request to a reply. See {@link solace.Session#sendRequest}.
 * @returns {?String} The correlation ID associated with the message.
 */
Message.prototype.getCorrelationId = function getCorrelationId () {
  return this._correlationId;
};

/**
 * Sets the correlation ID. The message Correlation Id
 * is carried in the Solace message headers unmodified by the API and
 * the Solace Message Router. This field may be used for peer-to-peer
 * message synchronization and is commonly used for correlating
 * a request to a reply. See {@link solace.session#sendRequest}.
 * @param {?String} value The correlation ID to associate with the message.
 */
Message.prototype.setCorrelationId = function setCorrelationId (value) {
  this._correlationId = isStringOrNothing('correlationId', value);
};

/**
 * Gets the correlation Key. A correlation key is used to correlate
 * a message with its acknowledgement or rejection. The correlation key is an object that is
 * passed back to the client during the router acknowledgement or rejection.
 *
 * The correlation key is a local reference
 * used by applications generating Guaranteed messages. Messages that are
 * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key.
 * @returns {?Object} The correlation Key associated with the message,
 * or <code>null</code>, if unset.
 */
Message.prototype.getCorrelationKey = function getCorrelationKey () {
  return this._correlationKey || null;
};

/**
 * Sets the correlation Key. A correlation key is used to correlate
 * a message with its acknowledgement or rejection. The correlation key is an object that is
 * passed back to the client during the router acknowledgement or rejection.
 *
 * The correlation key is a local reference
 * used by applications generating Guaranteed Messages. Messages that are
 * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key. If this
 * method is used, the correlation information is returned
 * when the {@link solace.SessionEventCode#event:ACKNOWLEDGED_MESSAGE} event
 * is later received for an acknowledged message or when the
 * {@link solace.SessionEventCode#event:REJECTED_MESSAGE_ERROR} is received for a rejected
 * message.
 *
 * The API only maintains a reference to the passed object.If the application requires the
 * contents are unmodified for proper correlation, then it is the application's responsibility
 * to ensure the contents of the object are not modified.
 *
 * Important: <b>The Correlation Key is not included in the
 * transmitted message and is only used with the local API</b>
 * @param {Object} value The correlation Key to associate with the message.
 */
Message.prototype.setCorrelationKey = function setCorrelationKey (value) {
  this._correlationKey = value;
};

/**
 * Gets whether the message is configured for delivering to one client only.
 * @returns {Boolean} indicates whether the message is configured for
 * delivering to one client only.
 */
Message.prototype.isDeliverToOne = function isDeliverToOne () {
  return this._deliverToOne || false;
};

/**
 * Sets whether the message is configured for delivering to one client only.
 * @param {Boolean} value whether the message is configured for delivering to one client only.
 */
Message.prototype.setDeliverToOne = function setDeliverToOne (value) {
  this._setDeliverToOne(this._deliverToOne = isBoolean('deliverToOne', value));
};
Message.prototype._setDeliverToOne = function _setDeliverToOne (value) {
  this._deliverToOne = value;
};

/**
 * Gets the delivery mode of the message.
 * @returns {solace.MessageDeliveryModeType} representing the delivery mode of the message.
 */
Message.prototype.getDeliveryMode = function getDeliveryMode () {
  return this._deliveryMode;
};

/**
 * Sets the delivery mode of the message.
 * @param {solace.MessageDeliveryModeType} value The message delivery mode.
 */
Message.prototype.setDeliveryMode = function setDeliveryMode (value) {
  this._setDeliveryMode(isEnumMember('deliveryMode', value, MessageDeliveryModeType));
};
Message.prototype._setDeliveryMode = function _setDeliveryMode (value) {
  this._deliveryMode = value;
};

/**
 * Gets the destination to which the message was published.
 * @returns {?Destination} The destination to which a message was published.
 */
Message.prototype.getDestination = function getDestination () {
  return this._destination;
};

/**
 * Sets the destination ({@link solace.DestinationType#topic} or
 * {@link solace.DestinationType#queue}) to publish the message to.
 * @param {Destination} value The destination to publish the message to.
 */
Message.prototype.setDestination = function setDestination (value) {
  this._setDestination(isInstanceOf('destination', value, Destination));
};
Message.prototype._setDestination = function _setDestination (value) {
  this._destination = value;
};

/**
 * Indicates whether one or more messages have been discarded prior
 * to the current message. This indicates congestion discards only and
 * is not affected by message eliding.
 * @returns {Boolean} Returns true if one or more messages have been
 * discarded prior to the current message; otherwise, it returns false.
 */
Message.prototype.isDiscardIndication = function isDiscardIndication () {
  return this._discardIndication || false;
};

/**
 * @private
 * @param {Boolean} value The new value for discard indication
 */
Message.prototype.setDiscardIndication = function setDiscardIndication (value) {
  this._setDiscardIndication(isBoolean('discardIndication', value));
};
Message.prototype._setDiscardIndication = function _setDiscardIndication (value) {
  this._discardIndication = value;
};

/**
 * Returns whether the message is eligible for eliding.
 * <p>
 * Message eliding enables filtering of data to avoid transmitting
 * every single update to a subscribing client.
 * <p>
 * This property does not indicate whether the message was elided.
 *
 * @returns {Boolean} indicates whether the message is eligible for eliding.
 */
Message.prototype.isElidingEligible = function isElidingEligible () {
  return this._elidingEligible || false;
};

/**
 * Sets whether the message is eligible for eliding.
 * <p>
 * Message eliding enables filtering of data to avoid transmitting
 * every single update to a subscribing client.
 * <p>
 * This property does not indicate whether the message was elided.
 *
 * @param {Boolean} value sets whether the message is eligible for eliding.
 */
Message.prototype.setElidingEligible = function setElidingEligible (value) {
  this._setElidingEligible(isBoolean('setElidingEligible', value));
};
Message.prototype._setElidingEligible = function _setElidingEligible (value) {
  this._elidingEligible = value;
};

/// ---------------------------------------------------------
// * Internal use only methods on the message, for fields set by the internal
// * publisher
/// ---------------------------------------------------------

/**
 * @returns {Number} The publisher ID
 * @private
 */
Message.prototype.getPublisherId = function getPublisherId () {
  return this._publisherId;
};
/**
 * @param {Number} valueThe publisher ID to set
 * @private
 */
Message.prototype.setPublisherId = function setPublisherId (value) {
  this._publisherId = value;
};

/**
 * @returns {Number} The publisher message ID
 * @private
 */
Message.prototype.getPublisherMessageId = function getPublisherMessageId () {
  return this._publisherMsgId;
};
/**
 * @param {Number} value The publisher message ID to set
 * @private
 */
Message.prototype.setPublisherMessageId = function setPublisherMessageId (value) {
  this._publisherMsgId = value;
};

/// -------------------------------------------------------------
// * User-settable properties for publishing
/// -------------------------------------------------------------

/**
 * @returns {Number} The Guaranteed Message TTL, in milliseconds.
 */
Message.prototype.getTimeToLive = function getTimeToLive () {
  return this._timeToLive;
};
/**
 * @param {Number} value The Guaranteed Message TTL to set, in milliseconds.
 *
 * The time to live is the number of milliseconds the message may be stored on the
 * Solace Message Router before the message is discarded or moved to a Dead Message
 * Queue. See {@link solace.Message.setDMQEligible}.
 *
 * Setting the Time To Live to zero disables TTL for the message.
 *
 * This property is only valid for Guaranteed messages (Persistent and Non-Persistent).
 * It has no effect when used in conjunction with other message types unless the message
 * is promoted by the appliance to a Guaranteed message.
 *
 * The maxium allowed time to live is 3.1536E11 (315360000000) which is
 * approximately 10 years.
 */
Message.prototype.setTimeToLive = function setTimeToLive (value) {
  var MAX_MESSAGE_TTL_MS = (10 * 365 * 24 * 60 * 60 * 1000); // approximately 10 years

  // Allow parser and initializer to set timeToLive to undefined
  if (value === null || value === undefined) {
    this._timeToLive = value;
    return;
  }
  if (typeof value !== 'number' || isNaN(value)) {
    throw new OperationError('Invalid type for time to live',
      ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (value < 0 || value > MAX_MESSAGE_TTL_MS) {
    throw new OperationError('Invalid time to live value',
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  this._timeToLive = value;
};

/**
 * @returns {?Number} The Guaranteed Message expiration value.
 * The expiration time is the UTC time
 * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
 * message is to expire.
 */
Message.prototype.getGMExpiration = function getGMExpiration () {
  return this._expiration;
};
/**
 * Set the expiration time field. The expiration time is the UTC time
 * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
 * message is to expire. The expiration time is carried in the message when set to
 * a non-zero value. Expiration time is not included when this value is set to zero or
 * undefined
 *
 * The message expiration time is carried to clients that receive the message
 * unmodified and does not effect the life cycle of the message. Use
 * {@link solace.Message#setTimeToLive} to enforce message expiry in the network.
 *
 * @param {?Number} value The new Guaranteed Message expiration value
 */
Message.prototype.setGMExpiration = function setGMExpiration (value) {
  this._expiration = isNumberOrNothing('GMExpiration', value);
};

/**
 * @returns {Boolean} Whether this message is Guaranteed Message DMQ eligible
 */
Message.prototype.isDMQEligible = function isDMQEligible () {
  return this._dmqEligible || false;
};
/**
 * @param {Boolean} value The new value for Guaranteed Message DMQ (Dead Message Queue) Eligible.
 * When this property is set, when the message expires in the network
 * the message is saved on a appliance dead message queue. Otherwise the expired message is
 * discarded. See {@link solace.Message#setTimeToLive}.
 */
Message.prototype.setDMQEligible = function setDMQEligible (value) {
  this._setDMQEligible(isBoolean('DMQEligible', value));
};
Message.prototype._setDMQEligible = function _setDMQEligible (value) {
  this._dmqEligible = value;
};

/// ---------------------------------------------------------
// * Internal use only methods on the message, for fields set by the consumer flow
/// ---------------------------------------------------------

/**
 * @returns {Long} The ID of the flow that received this message
 * @private
 */
Message.prototype.getFlowId = function getFlowId () {
  return this._flowId;
};
/**
 * @param {Long} value The flow ID that received this message
 * @private
 */
Message.prototype.setFlowId = function setFlowId (value) {
  this._flowId = value;
};

/**
 * @returns {Long} The Guaranteed Message prevMsgId
 * @private
 */
Message.prototype.getGuaranteedPreviousMessageId = function getGuaranteedPreviousMessageId () {
  return this._guaranteedPrevMsgId;
};
/**
 * @param {Long} value The Guaranteed Message prevMsgId to set
 * @private
 */
Message.prototype.setGuaranteedPreviousMessageId = function setGuaranteedPreviousMessageId (value) {
  this._guaranteedPrevMsgId = value;
};

/// ---------------------------------------------------------
// * Properties set by the Message Consumer
/// ---------------------------------------------------------

/**
 * @returns {?solace.MessageConsumer} The associated Message Consumer, if received by a consumer
 */
Message.prototype.getMessageConsumer = function getMessageConsumer () {
  return this._consumer;
};
/**
 * @param {solace.MessageConsumer} value The Message Consumer to associate with this message
 * @private
 */
Message.prototype.setMessageConsumer = function setMessageConsumer (value) {
  this._consumer = value;
};

/**
 * Returns the Guaranteed Message MessageID for this message.
 * @returns {?Long} The Guaranteed Message MessageID assigned to this message
 *by the router.
 */
Message.prototype.getGuaranteedMessageId = function getGuaranteedMessageId () {
  return this._guaranteedMsgId;
};
/**
 * @param {Long} value The Guaranteed Message msgId to set
 * @private
 */
Message.prototype.setGuaranteedMessageId = function setGuaranteedMessageId (value) {
  this._guaranteedMsgId = value;
};

/**
 * Returns the Topic Sequence Number.If there is no topic sequence number
 * undefined is returned.
 * @returns {?Long} The Topic Sequence number assigned to this message by the Message Router.
 */
Message.prototype.getTopicSequenceNumber = function getTopicSequenceNumber () {
  return this._topicSequenceNumber;
};

/**
 * @param {Long} topicSeqNo The Topic Sequence Number to set
 * @private
 */
Message.prototype.setTopicSequenceNumber = function setTopicSequenceNumber (topicSeqNo) {
  this._topicSequenceNumber = topicSeqNo;
};
/**
 * Acknowledges this message.
 *
 * If the {@link solace.MessageConsumer} on which this message was received is configured to use
 * {@link solace.MessageConsumerAckMode.CLIENT}, then when a message is received by an
 * application, the application must call this method to explicitly acknowledge reception of the
 * message. This frees local and router resources associated with an unacknowledged message.
 *
 * The API does not send acknowledgments immediately. It stores the state for
 * acknowledged messages internally and acknowledges messages, in bulk, when a
 * threshold or timer is reached.
 *
 * @throws {@link solace.OperationError}
 ** if this message was not received via Guaranteed Message;
 *  subcode: {@link solace.ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH}
 ** if the associated {@link solace.Session} is not connected;
 *  subcode: {@link solace.ErrorSubcode.SESSION_NOT_CONNECTED}
 ** if the associated {@link solace.MessageConsumer} is not connectedl
 *  subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
 */
Message.prototype.acknowledge = function acknowledge () {
  if (this._acked) {
    throw new OperationError('Message can only be acknowledged once',
      ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
  }
  if (this._deliveryMode === MessageDeliveryModeType.DIRECT) {
    throw new OperationError('Cannot acknowledge a DIRECT message',
      ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
  }
  if (!this._consumer) {
    throw new OperationError('Cannot acknowledge a locally-created message',
      ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
  }
  if (!this._consumer._sessionInterface.canAck) {
    throw new OperationError('Cannot acknowledge using associated session',
      ErrorSubcode.SESSION_NOT_CONNECTED);
  }
  if (!this._consumer.canAck) {
    throw new OperationError('Cannot acknowledge using associated Message Consumer',
      ErrorSubcode.INVALID_OPERATION);
  }
  this._consumer.applicationAck(this._guaranteedMsgId);
  this._acked = true;
};

/**
 * Returns whether acknowledge() has been called on this message.
 *
 * @readonly
 */
prototypeAccessors.isAcknowledged.get = function () {
  return this._acked || false;
};

/**
 * Test if the Acknowledge Immediately message property is set or not.
 * When the Acknowledge Immediately property is set to true on an outgoing
 * Guaranteed Message,
 * it indicates that the Solace Message Router should Acknowledge this message
 * immediately upon receipt.
 *
 * This property, when set by a publisher, may or may not be removed by the
 * Solace Message Router prior to delivery to a consumer, so message consumers
 * must not expect the property value indicates how the message was
 * originally published
 * @returns {Boolean} Whether this message was set to acknowledge immediately.
 */
Message.prototype.isAcknowledgeImmediately = function isAcknowledgeImmediately () {
  return this._ackImmediately || false;
};
/**
 * Set the optional Acknoweledge Immediately message property.
 * When the Acknowledge Immediately property is set to true on an outgoing Guaranteed Message,
 * it indicates that the Solace Message Router should acknoweledge this message
 * immediately upon receipt. By default the property is set to false on newly created messages.
 *
 * This property, when set by a publisher, may or may not be removed by the appliance
 * prior to delivery to a consumer, so message consumers must not expect the property value
 * indicates how the message was originally published. Therefore if a received message
 * is forwarded by the application, the Acknowledge Immediately property should be
 * explicitly set to the desired value (true or false).
 *
 * Setting this property on an outgoing direct message has no effect.
 *
 * @param {Boolean} value Whether to acknowledge this message immediately.
 */
Message.prototype.setAcknowledgeImmediately = function setAcknowledgeImmediately (value) {
  this._setAcknowledgeImmediately(isBoolean('acknowledgeImmediately', value));
};
Message.prototype._setAcknowledgeImmediately = function _setAcknowledgeImmediately (value) {
  this._ackImmediately = value;
};

/**
 * Gets the cache status of this message.
 *
 * @returns {?solace.MessageCacheStatus} The cache status of this message. The status
 * will be MessageCacheStatus.LIVE unless the message was returned in a
 * reply to a cache request.
 */
Message.prototype.getCacheStatus = function getCacheStatus () {
  return this._cacheStatus;
};

/**
 * @param {solace.MessageCacheStatus} cacheStatus The new cache status for this message
 * @private
 */
Message.prototype._setCacheStatus = function _setCacheStatus (cacheStatus) {
  this._cacheStatus = cacheStatus;
};

/**
 * Returns whether the message's reply field is set, indicating
 * that this message is a reply to a previous request. See {@link solace.Session#sendRequest}.
 * @returns {Boolean} Indicates the state of the reply field.
 */
Message.prototype.isReplyMessage = function isReplyMessage () {
  return this._replyMessage || false;
};

/**
 * Indicates whether the message has been marked as redelivered by the Solace Message Router.
 * @returns {Boolean} Indicates whether the redelivered flag is set.
 */
Message.prototype.isRedelivered = function isRedelivered () {
  return this._redelivered || false;
};
/**
 * @param {Boolean} value The redelivered flag
 * @private
 */
Message.prototype.setRedelivered = function setRedelivered (value) {
  this._redelivered = value;
};

/**
 * Sets the <i>reply</i> field of the message.
 * @param {Boolean} value Sets whether to flag the message as a reply.
 */
Message.prototype.setAsReplyMessage = function setAsReplyMessage (value) {
  this._replyMessage = isBoolean('asReplyMessage', value);
};

/**
 * Gets the receive timestamp (in milliseconds, from midnight, January 1, 1970 UTC).
 * @returns {?Number} The receive timestamp, if set.
 */
Message.prototype.getReceiverTimestamp = function getReceiverTimestamp () {
  return this._receiverTimestamp;
};

/**
 * Gets the replyTo destination
 * @returns {?solace.Destination} The value of the replyTo destination, if set.
 */
Message.prototype.getReplyTo = function getReplyTo () {
  return this._replyTo;
};

/**
 * Sets the replyTo destination
 * @param {solace.Destination} value The replyTo destination.
 */
Message.prototype.setReplyTo = function setReplyTo (value) {
  this._replyTo = isInstanceOfOrNothing('replyTo', value, Destination);
};

/**
 * Returns the Sender's ID.
 * @returns {?String} The Sender's ID, if set.
 */
Message.prototype.getSenderId = function getSenderId () {
  return this._senderId;
};

/**
 * Sets the Sender ID for the message
 * @param {String} value The Sender ID for the message.
 */
Message.prototype.setSenderId = function setSenderId (value) {
  this._senderId = isStringOrNothing('senderId', value);
};

/**
 * Gets the send timestamp (in milliseconds, from midnight, January 1,
 * 1970 UTC).
 * @returns {?Number} The send timestamp, if set.
 */
Message.prototype.getSenderTimestamp = function getSenderTimestamp () {
  return this._senderTimestamp;
};

/**
 * Sets the send timestamp (in milliseconds, from midnight, January 1,
 * 1970 UTC). This field can be generated automatically during message
 * publishing, but it will not be generated if previously set to a non-null value by this method.
 * See {@link solace.SessionProperties#generateSendTimestamps}.
 *
 * An application that publishes the same {@link solace.Messsage} multiple times and
 * also wants generted timestamps on each messages, should set the sender timestamp
 * to undefined after each call to {@link solace.Session#send}.
 * @param {?Number} value The value to set as the send timestamp.
 */
Message.prototype.setSenderTimestamp = function setSenderTimestamp (value) {
  this._senderTimestamp = isNumberOrNothing('senderTimestamp', value);
};

/**
 * Gets the sequence number.
 * <p>
 * This is an application-defined field,
 * see <code>{@link solace.Message#setSequenceNumber}()</code>.
 * @returns {?Number} The sequence number, if set
 */
Message.prototype.getSequenceNumber = function getSequenceNumber () {
  return this._sequenceNumber;
};

/**
 * Sets the application-defined sequence number. If the sequence number
 * is not set, or set to undefined, and {@link solace.SessionProperties#generateSequenceNumber}
 * is true, then a sequence number is automatically generated for each sent message.
 * @param {?Number} value The sequence number.
 */
Message.prototype.setSequenceNumber = function setSequenceNumber (value) {
  this._sequenceNumber = isNumberOrNothing('sequenceNumber', value);
  this._autoSequenceNumber = false;
};

/**
 * Gets the Class of Service (CoS) value for the message.
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.{@link solace.MessageUserCosType.COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @returns {solace.MessageUserCosType} The COS value.
 */
Message.prototype.getUserCos = function getUserCos () {
  return this._userCos;
};

/**
 * Gets the Message Priority Parameter (JMS Priority) value for the message.
 * Numerical values between 0 and 255 are valid return values,
 * undefined means the parameter is not present.
 *
 * If destination queues and topic endpoints for this message
 * are configured to respect message priority,
 * the values 0 through 9 can be used to affect the priority
 * of delivery to consumers of those queues or topic endpoints.
 * For the purposes of prioritized message delivery,
 * values larger than 9 are treated the same as 9.
 *
 * @returns {?Number} The Message Priority Parameter value.
 */
Message.prototype.getPriority = function getPriority () {
  return this._priority;
};

/**
 * Sets the Class of Service (CoS) value for the message.
 *
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.{@link solace.MessageUserCosType#COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType#COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @param {solace.MessageUserCosType} value The COS value.
 * @default {solace.MessageUserCosType#COS1}
 */
Message.prototype.setUserCos = function setUserCos (value) {
  this._setUserCos(isEnumMember('userCos', value, MessageUserCosType));
};
Message.prototype._setUserCos = function _setUserCos (value) {
  this._userCos = value;
};

/**
 * Sets the Message Priority Parameter (JMS Priority) value for the message.
 * Numerical values between 0 and 255 are accepted,
 * use undefined to unset.
 *
 * If destination queues and topic endpoints for this message
 * are configured to respect message priority,
 * the values 0 through 9 can be used to affect the priority
 * of delivery to consumers of those queues or topic endpoints.
 * For the purposes of prioritized message delivery, values larger than 9
 * are treated the same as 9.
 *
 * @param {?Number} value The priority value.
 */
Message.prototype.setPriority = function setPriority (value) {
  if (value === undefined || value === null) {
    this._setPriority(undefined);
    return;
  }
  if (typeof value !== 'number' || isNaN(value)) {
    throw new OperationError('Invalid type for message priority',
      ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (value < 0 || value > 255) {
    throw new OperationError('Invalid priority value',
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  this._setPriority(value);
};

Message.prototype._setPriority = function _setPriority (value) {
  this._priority = value;
};

/**
 * Gets the user data part of the message.
 * @returns {String} The user data part of the message, if set.
 */
Message.prototype.getUserData = function getUserData () {
  return this._userData;
};

/**
 * Sets the user data part of the message.
 * @param {String} value The user data part of the message.
 */
Message.prototype.setUserData = function setUserData (value) {
  this._setUserData(isStringOrNothing('userData', value));
};
Message.prototype._setUserData = function _setUserData (value) {
  this._userData = value;
};

/**
 * Gets the XML content part of the message.
 * Notice that the content is encoded as UTF-8 characters,
 * it needs to be decoded as JavaScript surrogate pair: decodeURIComponent(escape(value))
 * @returns {?String} The XML content part of the message, if set.
 */
Message.prototype.getXmlContent = function getXmlContent () {
  return this._xmlContent;
};

/**
 * Gets the XML content part of the message decoded from UTF-8 encoding of the characters.
 * @returns {?String} The XML content part of the message. Returns <code>null</code> if not
 * present.
 */
Message.prototype.getXmlContentDecoded = function getXmlContentDecoded () {
  return this._xmlContent ? utf8ToUcs2(this._xmlContent) : this._xmlContent;
};

/**
 * Sets the XML content part of the message.
 * The content is encoded by replacing each instance of certain characters
 * by one, two, three, or four escape sequences representing the
 * UTF-8 encoding of the character.
 * @param {String} value The XML content part of the message.
 */
Message.prototype.setXmlContent = function setXmlContent (value) {
  var setValue = isStringOrNothing('xmlContent', value);
  this._xmlContent = setValue ? unescape(encodeURIComponent(setValue)) : setValue;
};

/**
 * Internal set for the XML content part of the message.
 * @param {String} value The XML content part of the message.
 * @private
 */
Message.prototype._setXmlContentInternal = function _setXmlContentInternal (value) {
  this._xmlContent = isStringOrNothing('xmlContentInternal', value);
};

/**
 * Sets the message's XML metadata section.
 * @param {String} value The XML metadata.
 */
Message.prototype.setXmlMetadata = function setXmlMetadata (value) {
  this._setXmlMetadata(isStringOrNothing('xmlMetadata', value));
};
Message.prototype._setXmlMetadata = function _setXmlMetadata (value) {
  this._xmlMetadata = value;
};

/**
 * Gets the message's XML metadata section.
 * @returns {?String} The XML metadata, if set.
 */
Message.prototype.getXmlMetadata = function getXmlMetadata () {
  return this._xmlMetadata;
};

/**
 * @private
 */
prototypeAccessors.binaryMetadataChunk.get = function () {
  return this._binaryMetaChunk || null;
};
/**
 * @param {?String} meta The meta chunk to set
 * @private
 */
prototypeAccessors.binaryMetadataChunk.set = function (meta) {
  this._binaryMetaChunk = meta;
};

/**
 * @private
 */
prototypeAccessors.smfHeader.get = function () {
  return this._smfHeader;
};
/**
 * @param {SMFHeader} val The SMF header to set
 * @private
 */
prototypeAccessors.smfHeader.set = function (val) {
  this._smfHeader = val;
};

/**
 * @private
 */
prototypeAccessors.hasAutoSequenceNumber.get = function () {
  return this._autoSequenceNumber || false;
};
/**
 * @param {Boolean} value Value to set
 * @private
 */
prototypeAccessors.hasAutoSequenceNumber.set = function (value) {
  this._autoSequenceNumber = value;
};

/**
 * @private
 */
prototypeAccessors.hasAutoSenderTimestamp.get = function () {
  return this._autoSenderTimestamp || false;
};
/**
 * @param {Number} value Value to set
 * @private
 */
prototypeAccessors.hasAutoSenderTimestamp.set = function (value) {
  this._autoSenderTimestamp = value;
};

/**
 * Gets the user property map carried in the message binary metadata.
 *
 * @returns {?solace.SDTMapContainer} The user properties map, if set.
 */
Message.prototype.getUserPropertyMap = function getUserPropertyMap () {
  return this._userPropertyMap;
};

/**
 * Allows users to specify their own user properties to be carried
 * in the message binary metadata separate from the payload.
 * @param {?SDTMapContainer} value The user property map.
 */
Message.prototype.setUserPropertyMap = function setUserPropertyMap (value) {
  this._userPropertyMap = isInstanceOfOrNothing('userPropertyMap', value, SDTMapContainer);
};

/**
 * Makes this message a strutured data message by assigning it a
 * structured data type (SDT) container payload (such as a
 * {@link solace.SDTMapContainer}, {@link solace.SDTStreamContainer}
 * or a {@link solace.SDTFieldType.String}, which is transported in the binary attachment field.
 *
 * Assigning a SDT container updates the message's Type property to
 * the appropriate value.
 *
 * The container argument must be a {@link solace.SDTField} with a type
 * of {@link solace.SDTFieldType.MAP}, {@link solace.SDTFieldType.STREAM},
 * or {@link solace.SDTFieldType.STRING}.
 *
 * @param {?solace.SDTField} container The SDTField container to send in this message.
 */
Message.prototype.setSdtContainer = function setSdtContainer (container) {
  var structuredContainer = isInstanceOfOrNothing('sdtContainer', container, SDTField);
  if (structuredContainer === null || structuredContainer === undefined) {
    // clear
    this._structuredContainer = null;
    this.setBinaryAttachment(null);
    return;
  }

  this._setBinaryAttachment(null);
  var sdtType = structuredContainer.getType();
  switch (sdtType) {
    case SDTFieldType.MAP:
      this._messageType = MessageType.MAP;
      break;
    case SDTFieldType.STREAM:
      this._messageType = MessageType.STREAM;
      break;
    case SDTFieldType.STRING:
      this._messageType = MessageType.TEXT;
      break;
    default:
      throw new OperationError('Invalid parameter: expected SDTField Type of ' +
        'MAP, STREAM, or STRING.',
        ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  this._structuredContainer = structuredContainer;
};

/**
 * Gets the message's structured data container, if this is a structured data message.
 *
 * @returns {SDTField|null} A field with a payload of {String}, {@link SDTMapContainer},
 * or {@link SDTStreamContainer} if one was set in the message; otherwise, null.
 */
Message.prototype.getSdtContainer = function getSdtContainer () {
  var msgType = this.getType();
  var binaryAttachment = this.getBinaryAttachment();
  var binaryAttachmentLength = binaryAttachment ? binaryAttachment.length : 0;

  if (msgType === MessageType.BINARY) {
    /* #stripped LOG_DEBUG(`getSdtContainer returned null, reason: msgType=${msgType}`) */

    return null;
  }

  // MAP, STREAM or TEXT
  // Use cached structured container if available
  if (typeof this._structuredContainer !== 'undefined') {
    return this._structuredContainer;
  }

  if (binaryAttachmentLength === 0) {
    /* #stripped LOG_DEBUG(`getSdtContainer returned null, reason: len=${binaryAttachmentLength}`) */

    this._structuredContainer = null;
  } else {
    // Last resort: Decode binary attachment.
    // Cache structured container for later access
    this._structuredContainer = SDTCodec.parseSingleElement(binaryAttachment, 0);
  }


  return this._structuredContainer;
};

/**
 * Produces a human-readable dump of the message's properties and
 * contents. Applications must not parse the output, as its format is
 * not a defined part of the API and subject to change.
 *
 * <p>
 * Output can be controlled by the <code>flags</code> parameter. The values are:
 * <ul>
 * <li>{@link MessageDumpFlag.MSGDUMP_BRIEF} Display only the length of the
 *                        binary attachment, xml attachment, and user property map
 * <li>{@link MessageDumpFlag.MSGDUMP_FULL} Display the entire message.
 * </ul>
 * </p>
 *
 * @param {Number} [flags]Optional flags controlling the output, such as whether
 *                        to include verbose (binary dump) information
 * @returns {String} A string representation of the message.
 */
Message.prototype.dump = function dump (flags) {
    if ( flags === void 0 ) flags = MessageDumpFlag.MSGDUMP_FULL;

  var validFlags = isEnumMember('flags', flags, MessageDumpFlag);
  return MessageDumpUtil.dump(this, validFlags);
};

/**
 * Clones the message
 * @returns {Message} A clone of this message
 * @private
 */
Message.prototype.clone = function clone$1 () {
  return clone(this, MESSAGE_CLONE_OPTIONS);
};

/**
 * Releases all memory associated with this message. All values are reinitialized
 * to defaults. The message is no longer associated with any session or consumer.
 */
Message.prototype.reset = function reset () {
  clearMessage(this);
  initMessage(this);
};

Object.defineProperties( Message.prototype, prototypeAccessors );

module.exports.Message = Message;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(106);
var QueueDescriptor = ref$1.QueueDescriptor;
var ref$2 = __webpack_require__(65);
var QueueType = ref$2.QueueType;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valTopicString = APIPropertiesValidators.valTopicString;


var QueueDescriptorValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'QueueDescriptor', instance);
    if (instance instanceof QueueDescriptor) {
      v('name', [valTopicString]);
    } // else is abstract; don't check name
    v('type', [valIsMember, QueueType, 'QueueType']);
    v('durable', [valBoolean]);
  },
};

module.exports.QueueDescriptorValidator = QueueDescriptorValidator;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var ref$1 = __webpack_require__(62);
var QueueAccessType = ref$1.QueueAccessType;
var ref$2 = __webpack_require__(63);
var QueueDiscardBehavior = ref$2.QueueDiscardBehavior;
var ref$3 = __webpack_require__(64);
var QueuePermissions = ref$3.QueuePermissions;

var validateInstance = APIPropertiesValidators.validateInstance;
var valBoolean = APIPropertiesValidators.valBoolean;
var valIsMember = APIPropertiesValidators.valIsMember;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;


var QueuePropertiesValidator = {
  validate: function validate(instance) {
    var v = validateInstance.bind(null, 'QueueProperties', instance);
    // TODO: refactor to better code to handle optional parameters
    if (instance.permissions) {
      v('permissions', [valIsMember, QueuePermissions, 'QueuePermissions']);
    }
    if (instance.accessType) {
      v('accessType', [valIsMember, QueueAccessType, 'QueueAccessType']);
    }
    if (instance.quotaMB) {
      v('quotaMB', [valNumber], [valRange, 0, Number.POSITIVE_INFINITY]);
    }
    if (instance.maxMessageSize) {
      v('maxMessageSize', [valNumber], [valRange, 0, Number.POSITIVE_INFINITY]);
    }
    v('respectsTTL', [valBoolean]);
    if (instance.discardBehavior) {
      v('discardBehavior', [valIsMember, QueueDiscardBehavior, 'QueueDiscardBehavior']);
    }
    if (instance.maxMessageRedelivery) {
      v('maxMessageRedelivery', [valNumber], [valRange, 0, 255]);
    }
  },
};

module.exports.QueuePropertiesValidator = QueuePropertiesValidator;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(6);
var ref = __webpack_require__(4);
var APIProperties = ref.APIProperties;
var ref$1 = __webpack_require__(7);
var Check = ref$1.Check;
var ref$2 = __webpack_require__(62);
var QueueAccessType = ref$2.QueueAccessType;
var ref$3 = __webpack_require__(63);
var QueueDiscardBehavior = ref$3.QueueDiscardBehavior;
var ref$4 = __webpack_require__(64);
var QueuePermissions = ref$4.QueuePermissions;

var DEFAULTS = {
  permissions:          undefined,
  accessType:           undefined,
  quotaMB:              undefined,
  maxMessageSize:       undefined,
  respectsTTL:          false,
  discardBehavior:      undefined,
  maxMessageRedelivery: undefined,
};

/**
 * @classdesc
 * Represents a queue properties object. May be passed in to
 * {@link solace.Session#createMessageConsumer} when creating a
 * {@link solace.MessageConsumer} object.  Upon creation of a queue, undefined queue
 * properties are set to default values chosen by the router.
 *
 * @memberof solace
 */
var QueueProperties = (function (APIProperties) {
  function QueueProperties(options) {
    APIProperties.call(this, DEFAULTS, options);
  }

  if ( APIProperties ) QueueProperties.__proto__ = APIProperties;
  QueueProperties.prototype = Object.create( APIProperties && APIProperties.prototype );
  QueueProperties.prototype.constructor = QueueProperties;

  var prototypeAccessors = { permissions: {},accessType: {},quotaMB: {},maxMessageSize: {},respectsTTL: {},discardBehavior: {},maxMessageRedelivery: {} };

  /**
   * Gets/sets permissions for this queue.
   *
   * When creating a temporary queue, these are the permissions that apply
   * to all other users; the user creating the temporary queue is always
   * granted DELETE permissions.
   *
   * @type {solace.QueuePermissions}
   * @default undefined
   */
  prototypeAccessors.permissions.get = function () {
    return this._permissions;
  };
  prototypeAccessors.permissions.set = function (newValue) {
    this._permissions = newValue;
  };

  /**
   * Gets/sets the access type for this queue.
   *
   * This parameter must NOT be set when creating a temporary queue via
   * {@link solace.Session#createMessageConsumer}. Such a queue has its
   * access type determined by the remote message router.
   *
   * @type {solace.QueueAccessType}
   * @default undefined
   */
  prototypeAccessors.accessType.get = function () {
    return this._accessType || DEFAULTS.accessType;
  };
  prototypeAccessors.accessType.set = function (newValue) {
    this._accessType = newValue;
  };

  /**
   * Gets/sets the quota, in megabytes, for this queue.
   *  * The allowed values are (0 <= quotaMB) || undefined.
   *  * A value of 0 configures the queue to act as a Last-Value-Queue (LVQ), where the router
   *    enforces a Queue depth of one, and only the most current message is spooled by the
   *    queue. When a new message is received, the current queued message is first
   *    automatically deleted from the queue, then the new message is spooled.
   * @type {?Number}
   * @default undefined
   */
  prototypeAccessors.quotaMB.get = function () {
    return this._quotaMB;
  };
  prototypeAccessors.quotaMB.set = function (newValue) {
    this._quotaMB = newValue;
  };

  /**
   * Gets/sets the maximum message size, in bytes, for any single message spooled on this queue.
   * @type {Number}
   * @default undefined
   */
  prototypeAccessors.maxMessageSize.get = function () {
    return this._maxMessageSize;
  };
  prototypeAccessors.maxMessageSize.set = function (newValue) {
    this._maxMessageSize = newValue;
  };

  /**
   * Gets/sets whether this queue respects Time To Live on messages.
   * @type {Boolean}
   * @default false
   */
  prototypeAccessors.respectsTTL.get = function () {
    return Check.boolean(this._respectsTTL) ? this._respectsTTL : DEFAULTS.respectsTTL;
  };
  prototypeAccessors.respectsTTL.set = function (newValue) {
    this._respectsTTL = newValue;
  };

  /**
   * Gets/sets the discard behavior for this queue.
   * @type {solace.QueueDiscardBehavior}
   * @default {solace.QueueDiscardBehavior.NOTIFY_SENDER_OFF}
   */
  prototypeAccessors.discardBehavior.get = function () {
    return this._discardBehavior || QueueDiscardBehavior.NOTIFY_SENDER_OFF;
  };
  prototypeAccessors.discardBehavior.set = function (newValue) {
    this._discardBehavior = newValue;
  };

  /**
   * Gets/sets the maximum number of times to attempt message redelivery for this queue.
   *  * The valid range is 0 <= maxMessageRedelivery <= 255
   *  * A value of 0 means retry forever.
   * @type {Number}
   * @default undefined
   */
  prototypeAccessors.maxMessageRedelivery.get = function () {
    return this._maxMessageRedelivery;
  };
  prototypeAccessors.maxMessageRedelivery.set = function (newValue) {
    this._maxMessageRedelivery = newValue;
  };

  QueueProperties.prototype[util.inspect.custom] = function () {
    return {
      'permissions':     QueuePermissions.describe(this.permissions),
      'accessType':      QueueAccessType.describe(this.accessType),
      'quotaMB':         this.quotaMB,
      'maxMessageSize':  this.maxMessageSize,
      'respectsTTL':     this.respectsTTL,
      'discardBehavior': this.discardBehaviour
                            ? QueueDiscardBehavior.describe(this.discardBehavior)
                            : 'undefined',
      'maxMessageRedelivery': this.maxMessageRedelivery,
    };
  };

  QueueProperties.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( QueueProperties.prototype, prototypeAccessors );

  return QueueProperties;
}(APIProperties));

module.exports.QueueProperties = QueueProperties;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(66);
var EncodeSingleElement = ref.EncodeSingleElement;
var ref$1 = __webpack_require__(67);
var IEEE754LIB = ref$1.IEEE754LIB;
var ref$2 = __webpack_require__(69);
var ParseSingleElement = ref$2.ParseSingleElement;

var encodeSingleElement = EncodeSingleElement.encodeSingleElement;
var parseSingleElement = ParseSingleElement.parseSingleElement;

var Codec = {
  encodeSingleElement: encodeSingleElement,
  parseSingleElement: parseSingleElement,
  IEEE754LIB: IEEE754LIB,
};

module.exports.Codec = Codec;


/***/ }),
/* 201 */
/***/ (function(module, exports) {


var EncodeInteger = {

  int48ToStr: function int48ToStr(vIn) {
    var v = vIn;
    var bytes = [];
    for (var i = 0; i < 6; i++) {
      var byteI = (v % 256);
      v = Math.floor(v / 256);
      bytes.push(String.fromCharCode(byteI));
    }
    bytes.reverse();
    return bytes.join('');
  },

};

module.exports.EncodeInteger = EncodeInteger;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var EncodeSingleElementLib = __webpack_require__(66);
var UtilLib = __webpack_require__(4);
var ref = __webpack_require__(107);
var EncodeHeader = ref.EncodeHeader;
var ref$1 = __webpack_require__(30);
var SDTDataTypes = ref$1.SDTDataTypes;
var ref$2 = __webpack_require__(41);
var SDTMapContainer = ref$2.SDTMapContainer;

var encodeHeader = EncodeHeader.encodeHeader;

var EncodeMap = {
  /**
   * Encodes an SDT map.
   * @param  {Object} sdtmap The map to parse
   * @returns {String}        The map in binary string format
   */
  encodeMap: function encodeMap(sdtmap) {
    var buf = [];
    if (!(sdtmap instanceof SDTMapContainer)) {
      return null; // skip!
    }
    var keys = sdtmap.getKeys();
    var sdtfield = null;
    var strKeyField = null;
    var strKeyName = null;
    var i;
    for (i = 0; i < keys.length; i++) {
      sdtfield = sdtmap.getField(keys[i]);
      if (sdtfield) {
        // === KEY ===
        strKeyName = UtilLib.StringUtils.nullTerminate(keys[i]);
        strKeyField = encodeHeader(SDTDataTypes.String, strKeyName.length);
        strKeyField += strKeyName;
        buf.push(strKeyField);

        // === VALUE ===
        EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
      }
    } // end iter over keys
    return buf.join('');
  },
};

module.exports.EncodeMap = EncodeMap;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var EncodeSingleElementLib = __webpack_require__(66);
var ref = __webpack_require__(42);
var SDTStreamContainer = ref.SDTStreamContainer;

var EncodeStream = {
  encodeStream: function encodeStream(sdtstream) {
    var buf = [];
    if (!(sdtstream instanceof SDTStreamContainer)) {
      return null; // skip!
    }
    var sdtfield = null;
    while (sdtstream.hasNext()) {
      sdtfield = sdtstream.getNext();
      if (sdtfield) {
        EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
      }
    } // end iter over stream entries
    return buf.join('');
  },
};

module.exports.EncodeStream = EncodeStream;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(5);
var DestinationFromNetwork = ref.DestinationFromNetwork;
var DestinationType = ref.DestinationType;
var Queue = ref.Queue;
var ref$1 = __webpack_require__(1);
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var ref$2 = __webpack_require__(70);
var SDTDestType = ref$2.SDTDestType;
var ref$3 = __webpack_require__(12);
var SDTField = ref$3.SDTField;
var ref$4 = __webpack_require__(11);
var SDTFieldType = ref$4.SDTFieldType;
var ref$5 = __webpack_require__(5);
var Topic = ref$5.Topic;

var ParseDestination = {
  parseDestination: function parseDestination(data) {
    var destType = data.charCodeAt(0);
    var destBytes = data.substr(1);
    // first try to create a destination from the string, this handles strings with
    // the preamble ('#P2P/QUE' or '#P2P/TQUE').
    var destination = DestinationFromNetwork.createDestinationFromBytes(destBytes);
    if (SDTDestType[destination.type] !== destType) {
      // SDT destination type does not match the string format. This means either:
      //    * that the string contains a queue preamble and the type is topic,
      //      so just make it a topic
      //    * that the type is queue and the string does not have the preamble, which means we
      //      should construct a queue.
      if (SDTDestType[DestinationType.QUEUE] === destType) {
        destination = Queue.createFromLocalName(destBytes);
      } else if (SDTDestType[DestinationType.TOPIC] === destType) {
        /* #stripped LOG_DEBUG(`Found and allowed SDT field with  destination type ${destType} when decoding ${destBytes} to ${destination.type}`) */

        //
        // override the format and set destType as specified in the SMF (i.e. TOPIC)
        destination = new Topic(destBytes);
      } else {
        LOG_INFO(("Drop SDT field with invalid destination type " + destType + " when decoding " + destBytes + " to " + (destination.type)));
        return null;
      }
    }
    return SDTField.create(SDTFieldType.DESTINATION, destination);
  },
};

module.exports.ParseDestination = ParseDestination;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(67);
var IEEE754LIB = ref.IEEE754LIB;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;

var ParseFloat = {
  parseFloatField: function parseFloatField(bytes) {
    switch (bytes.length) {
      case 4:
        return SDTField.create(SDTFieldType.FLOATTYPE, IEEE754LIB.fromIEEE754Single(bytes));
      case 8:
        return SDTField.create(SDTFieldType.DOUBLETYPE, IEEE754LIB.fromIEEE754Double(bytes));
      default:
        return SDTField.create(SDTFieldType.UNKNOWN, bytes);
    }
  },
};

module.exports.ParseFloat = ParseFloat;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var ParseSingleElementLib = __webpack_require__(69);
var ref = __webpack_require__(1);
var LOG_ERROR = ref.LOG_ERROR;
var ref$1 = __webpack_require__(68);
var ParseFieldHeader = ref$1.ParseFieldHeader;
var ref$2 = __webpack_require__(30);
var SDTDataTypes = ref$2.SDTDataTypes;
var ref$3 = __webpack_require__(12);
var SDTField = ref$3.SDTField;
var ref$4 = __webpack_require__(11);
var SDTFieldType = ref$4.SDTFieldType;
var ref$5 = __webpack_require__(41);
var SDTMapContainer = ref$5.SDTMapContainer;

var ParseMap = {
  parseMapAt: function parseMapAt(data, offset, datalen) {
    var mapObj = new SDTMapContainer();
    var pos = offset;
    while (pos < offset + datalen) {
      // === key field ===
      var keyFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      pos += keyFieldHeader[3]; // consumed bytes
      // pos now points to start of string
      if (keyFieldHeader[0] !== SDTDataTypes.String) {
        // Fail!
        LOG_ERROR("Error parsing SDTMAP, expected to find a string field as map key, and didn't");
        return SDTField.create(SDTFieldType.MAP, null);
      }
      var keyString = data.substr(pos, keyFieldHeader[2] - 1);
      pos += keyFieldHeader[2];

      // === value field ===
      // pos now points to start of next value
      var valueFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      var valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(data, pos);
      pos += valueFieldHeader[1]; // declared field length
      if (valueField) {
        mapObj.addField(keyString, valueField);
      }
    }
    return SDTField.create(SDTFieldType.MAP, mapObj);
  },
};

module.exports.ParseMap = ParseMap;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var ParseSingleElementLib = __webpack_require__(69);
var ref = __webpack_require__(68);
var ParseFieldHeader = ref.ParseFieldHeader;
var ref$1 = __webpack_require__(12);
var SDTField = ref$1.SDTField;
var ref$2 = __webpack_require__(11);
var SDTFieldType = ref$2.SDTFieldType;
var ref$3 = __webpack_require__(42);
var SDTStreamContainer = ref$3.SDTStreamContainer;

var ParseStream = {
  parseStreamAt: function parseStreamAt(data, offset, datalen) {
    var streamObj = new SDTStreamContainer();
    var pos = offset;
    while (pos < offset + datalen) {
      var valueFieldHeader = ParseFieldHeader.parseFieldHeader(data, pos);
      var valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(data, pos);
      pos += valueFieldHeader[1]; // declared field length
      if (valueField) {
        streamObj.addField(valueField);
      }
    }
    return SDTField.create(SDTFieldType.STREAM, streamObj);
  },
};

module.exports.ParseStream = ParseStream;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var SDTMapContainerLib = __webpack_require__(41);
var SDTStreamContainerLib = __webpack_require__(42);
var ValidateLib = __webpack_require__(7);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(11);
var SDTFieldType = ref$1.SDTFieldType;

var baseTypes = (function () {
  var result = [];
  result[SDTFieldType.BOOL] = 'boolean';
  result[SDTFieldType.UINT8] = 'number';
  result[SDTFieldType.INT8] = 'number';
  result[SDTFieldType.UINT16] = 'number';
  result[SDTFieldType.INT16] = 'number';
  result[SDTFieldType.UINT32] = 'number';
  result[SDTFieldType.INT32] = 'number';
  result[SDTFieldType.UINT64] = 'number';
  result[SDTFieldType.INT64] = 'number';
  result[SDTFieldType.WCHAR] = 'string';
  result[SDTFieldType.STRING] = 'string';
  result[SDTFieldType.BYTEARRAY] = 'string';
  result[SDTFieldType.FLOATTYPE] = 'number';
  result[SDTFieldType.DOUBLETYPE] = 'number';
  return result;
})();

function failInvalidParameter(valueType) {
  return new OperationError(
            ("Invalid SDT type:value combination, expected value type " + valueType),
            ErrorSubcode.PARAMETER_INVALID_TYPE);
}

function validateSdtField(type, value) {
  if (baseTypes[type]) {
    if ((baseTypes[type] === 'boolean' && typeof value !== 'boolean') ||
            (baseTypes[type] === 'number' && typeof value !== 'number') ||
            (baseTypes[type] === 'string' && typeof value !== 'string')) {
      return failInvalidParameter(baseTypes[type]);
    }
  }
  if (type === SDTFieldType.MAP &&
      !ValidateLib.Check.instanceOf(value, SDTMapContainerLib.SDTMapContainer)) {
    return failInvalidParameter('SDTMapContainer');
  }
  if (type === SDTFieldType.STREAM &&
      !ValidateLib.Check.instanceOf(value, SDTStreamContainerLib.SDTStreamContainer)) {
    return failInvalidParameter('SDTStreamContainer');
  }
  if (type === SDTFieldType.DESTINATION &&
      !ValidateLib.Check.instanceOf(value, DestinationLib.Destination)) {
    return failInvalidParameter('Destination');
  }
  return null;
}

module.exports.validateSdtField = validateSdtField;


/***/ }),
/* 209 */
/***/ (function(module, exports) {

var CorrelatedRequest = function CorrelatedRequest(correlationTag, timer, correlationKey, respRecvdCallback) {
  this.correlationTag = correlationTag;
  this.timer = timer;
  this.correlationKey = correlationKey;
  this.respRecvdCallback = respRecvdCallback;
};

module.exports.CorrelatedRequest = CorrelatedRequest;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(43);
var CapabilityType = ref.CapabilityType;

module.exports.DefaultCapabilities = {
  createDefaultCapabilities: function createDefaultCapabilities() {
    var defaultCapabilities = {};
    defaultCapabilities[CapabilityType.GUARANTEED_MESSAGE_CONSUME] = true;
    defaultCapabilities[CapabilityType.GUARANTEED_MESSAGE_PUBLISH] = true;
    return defaultCapabilities;
  },
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(4);
var Process = ref.Process;

var C_2_32 = Math.pow(2, 32);

function leftPad(str, len) {
  return '0'.repeat(len - str.length) + str;
}

function generateRandomId() {
  var rand = (Math.random() * C_2_32).toFixed(0);
  return leftPad(rand.toString(), 10);
}

/**
 * @private
 */
var GlobalContext = {

  sessionCounter: 0,
  idCounter:      0,

  RandId: generateRandomId(),

  NextSessionCounter: function NextSessionCounter() {
    var count = ++this.sessionCounter;
    return leftPad(count.toString(), 4);
  },

  NextId: function NextId() {
    return ++this.idCounter;
  },

  GenerateClientName: function GenerateClientName() {
    var product = Process.product;
    var platform = Process.platform;
    var result = product + "/" + platform + "/" + (this.RandId) + "/" + (this.NextSessionCounter());
    return result;
  },

  GenerateUserIdentification: function GenerateUserIdentification() {
    var product = Process.product;
    var platform = Process.platform;
    return (product + "/" + platform + "/" + (this.RandId));
  },

  GenerateClientDescription: function GenerateClientDescription() {
    return ("solclientjs/" + (Process.description)).substring(0, 254);
  },
};

module.exports.GlobalContext = GlobalContext;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(1);
var LOG_TRACE = ref.LOG_TRACE;
var ref$1 = __webpack_require__(4);
var parseURL = ref$1.parseURL;

var hostListDNSFilter;
if (true) {
  /* eslint-env node */
  /* eslint-disable global-require */
  var dns = __webpack_require__(284);
  /* eslint-enable global-require */

  // util.promisify is Node 8. This converts an (err, result) callback to a promise.
  // The purpose is to allow us to use Promise.all, which deals with waiting until
  // all promises are resolved, and returning the results in correctly ordered array.
  var dnsLookupPromise = function (url, options) { return new Promise(function (resolve) {
    var host = parseURL(url).hostname;
    /* #stripped LOG_TRACE('looking up', url, '=>', host) */

    dns.lookup(host, options, function (error, result) {
      /* #stripped LOG_TRACE('DNS result', error, result) */

      return error === null
        ? resolve({ url: url, host: host, address: result, resolved: true })
        : resolve(
          { url: url,
            host: host,
            resolved: true,
            error:    {
              code:     error['code'], // eslint-disable-line dot-notation
              errno:    error['errno'], // eslint-disable-line dot-notation
              hostname: error['hostname'], // eslint-disable-line dot-notation
              syscall:  error['syscall'], // eslint-disable-line dot-notation
            },
          });
    });
  }); };

  /**
   * Resolution calls back with an array of the following:
   * `{ url: 'http://example.com/foo', host: 'example.com', address: '10.0.0.1', resolved: true }`
   * or, on error
   * `{ url: 'http://example.com/foo', host: 'example.com', resolved: true, error: {
   *    code: 'ENOTFOUND', errno: 'ENOTFOUND', syscall: 'getaddrinfo'
   *  } }`
   *
   * If resolution could not be performed, because of platform limitations, the callback receives
   * the following:
   * `{ url: 'http://example.com/foo', host: 'example.com', address: 'example.com', resolved: false }`
   *
   * Even if no DNS lookup is performed, the function can still fail if an invalid URL is provided.
   *
   * The function always calls back asynchronously.
   *
   * @param {Array.<String>} urls Array of URLs to resolve
   * @param {function} cb A function called back with results as described above
   * @private
   */
  hostListDNSFilter = function hostListDNSFilterNode(urls, cb) {
    var promises = urls.map(function (url) { return dnsLookupPromise(
      url,
      { 'verbatim': true }
    ); });
    // Call back (null, [{host:, address:}, ...]) if all successful
    // Call back (err, undefined) fast if any error
    Promise.all(promises).then(function (resolved) { return cb(null, resolved); }).catch(function (err) { return cb(err); });
  };
} else {
  /* eslint-env browser */
  // Create an always-async callback that allows all hosts.
  hostListDNSFilter = function (urls, cb) { return setImmediate(function () {
    try {
      var result = urls.map(function (url) {
        var host = parseURL(url).host;
        return { url: url, host: host, address: host, resolved: false };
      });
      return cb(null, result);
    } catch (e) {
      return cb(e);
    }
  }); };
}

module.exports.hostListDNSFilter = hostListDNSFilter;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(212);
var hostListDNSFilter = ref$1.hostListDNSFilter;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;
var ref$3 = __webpack_require__(4);
var parseURL = ref$3.parseURL;

function parseURLs(rawURLs) {
  if (Array.isArray(rawURLs)) {
    return rawURLs.map(function (rawURL) { return parseURL(rawURL); });
  }
  return parseURLs(rawURLs.split(/[,;]/));
}

/*
 *   "When using a host list, each time the API works through the host list without establishing
 *    a connection is considered an connect retry."
 *   SESSION_CONNECT_RETRIES: "When using a host list, this property defines how many times to
 *    try to connect or reconnect to a single host before moving to the next host in the list."
 *   Details: http://docs.solace.com/Solace-Messaging-APIs/Configuring-Connection-T.htm
*/

// In general:
// * set initial state to invalid so that we begin needing a transition.
// * preincrement all try counts on transition.
// Specifics:
// * Select try count for entire list based on whether we were connected.
// * Try count per host is the same for both connect and reconnect.
// * When the host changes, the waitTime is 0.
// * Overriding the above, when the host pointer wraps to 0, the waitTime is nonzero.

var HostInfo = function HostInfo(props) {
  if ( props === void 0 ) props = { url: null, waitTime: 0 };

  Object.assign(this, props);
};

/**
 * @private
 */
var HostList = function HostList(ref) {
  if ( ref === void 0 ) ref = {};
  var url = ref.url;
  var connectRetries = ref.connectRetries;
  var reconnectRetries = ref.reconnectRetries;
  var connectRetriesPerHost = ref.connectRetriesPerHost;
  var reconnectRetryWaitInMsecs = ref.reconnectRetryWaitInMsecs;

  Object.assign(this, {
    hosts: parseURLs(url).map(function (e) { return e.href; }),

    // How many times will we traverse the host list without success?
    // Try to connect one more than the 'retryCount' because we always try once.
    connectTryCount: (connectRetries === -1
      ? Number.POSITIVE_INFINITY
      : connectRetries + 1
    ),

    // How many times will we traverse the host list after success?
    reconnectTryCount: (reconnectRetries === -1
      ? Number.POSITIVE_INFINITY
      : reconnectRetries
    ),

    // A value of 1 in the next assignements means retry forever - "null" will mean that
    // try to connect one more than the 'retryCount' because we always try once.
    connectTryCountPerHost: (connectRetriesPerHost === -1
      ? Number.POSITIVE_INFINITY
      : connectRetriesPerHost + 1
    ),

    // How long do we wait before reattempting the same host or wrapping around the list?
    reconnectRetryWaitInMsecs: reconnectRetryWaitInMsecs,

    // Mutating operations affect only this.
    _mutableState: {},

    logger: new LogFormatter('[host-list]'),
  });

  assert(this.hosts.length >= 1);
  assert(this.connectTryCount >= 1);
  assert(this.reconnectTryCount >= 0);
  assert(this.connectTryCountPerHost >= 1);
};

var prototypeAccessors = { connectWaitTimeInMsecs: {} };

/**
 * Call before first getNextHost() to validate that at least one URL contains a reachable
 * hostname.
 * @param {function(Error)} callback The callback to invoke when DNS resolution completes
 */
HostList.prototype.resolveHosts = function resolveHosts (callback) {
    var this$1 = this;

  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_WARN = ref.LOG_WARN;
  hostListDNSFilter(this.hosts, function (err, resolved) {
    // Exit immediately if the filter threw.
    if (err) { return callback(err); }
    assert(resolved.length === this$1.hosts.length, 'Resolve did not return a result for all hosts');

    /* #stripped LOG_TRACE('Resolve result', resolved) */

    var succeeded = 0;
    resolved.forEach(function (result) {
      if (result.address) {
        ++succeeded;
      }
      if (!result.resolved) {
        // Only log if the lookup was actually performed
        return;
      }
      if (result.address) {
        /* #stripped LOG_TRACE('DNS resolve OK:  ', result.address, 'for', result.url) */

      } else {
        LOG_WARN('DNS resolve FAILED:', result.error.code,
                 ((result.error.syscall) + "('" + (result.error.hostname) + "')"), 'for', result.url);
      }
    });
    return callback(succeeded === 0 ? 'All hosts failed DNS resolution' : null);
  });
};

/**
 * @param {Object} state Properties for host selection logic
 * @memberof HostList
 */
HostList.prototype.reset = function reset (state) {
    if ( state === void 0 ) state = { wasConnected: false, disconnected: false };

  // On reset, we always return to the beginning of the host list.
  // This facilitates DR recovery by returning to the primary router.
  // Set an invalid initial state that will trigger our first try.
  Object.assign(this._mutableState, {
    wasConnected: state.wasConnected,
    disconnected: state.disconnected,
    hostPointer:0,
    hostTries:  0,
    listTries:  1,
    exhausted:  false,
    lastHostInfo: new HostInfo(),
  });
};

/**
 * !returns {HostInfo} Connection information for the next host.
 * @returns {String} The URL for the next host
 * @memberof HostList
 */
HostList.prototype.getNextHost = function getNextHost () {
  var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;

  var state = this._mutableState;
  var wasConnected = state.wasConnected;
  var lastHostInfo = state.lastHostInfo;

  assert(lastHostInfo, 'Next host request with no prior host info -- did you call reset()?');
  // Using a try/finally as a "goto end" to always log final state. Exceptions not expected
  // here, although if an assertion fails, the finally log should be helpful.
  try {
    // If this was passed into reset, the session is telling us to enforce no more hosts.
    if (state.disconnected) {
      /* #stripped LOG_TRACE('Host list set to disconnected, providing null next host') */

      return null;
    }

    // If exhausted, this function has returned a null url already.
    assert(!state.exhausted, 'Next host request after host list exhausted');

    // Pull immutable properties from the instance
    var properties = Object.assign({
      hosts:      this.hosts,
      hostTriesMax: this.connectTryCountPerHost,
      listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount,
    });

    /* #stripped LOG_TRACE('Getting next host\n', 'properties', properties, '\nstate', state) */

    /* #stripped LOG_TRACE('Last host', lastHostInfo) */


    // Initial state was valid. This is a host try. Increment.
    ++state.hostTries;
    if (state.hostTries > properties.hostTriesMax) {
      // Increment host pointer, possibly putting it out of bounds.
      /* #stripped LOG_TRACE(`Exhausted ${state.hostTries} host tries for host ${lastHostInfo.url}.`) */

      ++state.hostPointer;
      // If the host pointer is out of bounds, we are beginning a new list try.
      // It was either set out of bounds deliberately by reset() or it was
      // incremented out of bounds above.
      if (state.hostPointer >= properties.hosts.length) {
        // This is a new list try.
        ++state.listTries;
        if (state.listTries > properties.listTriesMax) {
          // Beginning this list try has exceeded our inclusive max. The host list is
          // exhausted.
          /* #stripped LOG_TRACE(`Exhausted host list at ${properties.listTriesMax} traversals.`) */

          state.exhausted = true;
        } else {
          // Resetting the host pointer to begin this list try.
          /* #stripped LOG_TRACE(`Host list try (${state.listTries}/${properties.listTriesMax})`) */

          state.hostPointer = 0;
          state.hostTries = 1; // this is the first try for this host
        }
      } else {
        state.hostTries = 1; // this is the first try for this host
      }
    } else {
      // Continue with this host.
      /* #stripped LOG_TRACE(`Host try (${state.hostTries}/${properties.hostTriesMax})`) */

    }

    if (state.exhausted) {
      /* #stripped LOG_TRACE('All hosts exhausted') */

      return null;
    }

    // Beyond this point, expect a valid host to be returned.

    var url = properties.hosts[state.hostPointer];
    assert(url, ("No host at the host pointer! " + (properties.hosts) + "[" + (state.hostPointer) + "]"));

    // Wait time conditions:
    // 1. On a new list (invalid lastHostInfo), zero waitTime.
    var isNewList = lastHostInfo.url === null;
    // 2a. On a new host, zero waitTime...
    var isNewHost = lastHostInfo.url !== url;
    // 2b. ...unless we are just restarting the list.
    var didJustFinishList = lastHostInfo.url !== url && state.hostPointer === 0;
    // (2b negates 2a for a new list)

    var waitTime = (isNewList || (isNewHost && !didJustFinishList))
      ? 0
      : this.reconnectRetryWaitInMsecs;

    // Session FSM was intended to use all of these, but handles its own events presently
    // and expects waitTime to be a property of the list that mutates per host, so that is
    // what is done.
    var hostInfo = new HostInfo({
      url: url,
      waitTime: waitTime,
    });

    // Set last host for next time, and return
    /* #stripped LOG_TRACE('Returning host from', hostInfo) */

    state.lastHostInfo = hostInfo;
    return hostInfo.url;
  } finally {
    /* #stripped LOG_TRACE('Final list state\n', state) */

  }
};

prototypeAccessors.connectWaitTimeInMsecs.get = function () {
  assert(this._mutableState.lastHostInfo.url, 'Getting connectWaitTimeInMsecs having never called getNextHostInfo');
  return this._mutableState.lastHostInfo.waitTime;
};

HostList.prototype.currentHostToString = function currentHostToString () {
  var state = this._mutableState;
  var wasConnected = state.wasConnected;
  // Pull immutable properties from the instance
  var properties = Object.assign({
    hosts:      this.hosts,
    hostTriesMax: this.connectTryCountPerHost,
    listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount,
  });
  // host pointer is zero based index into the host list
  // so translate it to a human readable index
  var hostNumber = state.hostPointer + 1;
  return ("host '" + (state.lastHostInfo.url) + "' (host " + hostNumber + " of " + (properties.hosts.length) + ")(host connection attempt " + (state.hostTries) + " of " + (properties.hostTriesMax) + ")(total " + (wasConnected ? 'reconnection' : 'connection') + " attempt " + (state.listTries) + " of " + (properties.listTriesMax) + ")");
};

Object.defineProperties( HostList.prototype, prototypeAccessors );

module.exports.HostList = HostList;


/***/ }),
/* 214 */
/***/ (function(module, exports) {

/**
 * @private
 */
var OutstandingDataRequest = function OutstandingDataRequest(correlationId, timer, replyReceivedCBFunction, reqFailedCBFunction, userObject) {
  this.correlationId = correlationId;
  this.timer = timer;
  this.replyReceivedCBFunction = replyReceivedCBFunction;
  this.reqFailedCBFunction = reqFailedCBFunction;
  this.userObject = userObject;
};

module.exports.OutstandingDataRequest = OutstandingDataRequest;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var ConsumerLib = __webpack_require__(99);
var PublisherLib = __webpack_require__(29);
var SMFLib = __webpack_require__(8);
var SolclientFactoryLib = __webpack_require__(9);
var TransportLib = __webpack_require__(23);

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(43);
var CapabilityType = ref$1.CapabilityType;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(209);
var CorrelatedRequest = ref$3.CorrelatedRequest;
var ref$4 = __webpack_require__(5);
var Destination = ref$4.Destination;
var ref$5 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$5.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$5.ErrorSubcode;
var OperationError = ref$5.OperationError;
var ref$6 = __webpack_require__(15);
var FsmEvent = ref$6.FsmEvent;
var State = ref$6.State;
var StateMachine = ref$6.StateMachine;
var ref$7 = __webpack_require__(3);
var Hex = ref$7.Hex;
var ref$8 = __webpack_require__(1);
var LogFormatter = ref$8.LogFormatter;
var ref$9 = __webpack_require__(16);
var Message = ref$9.Message;
var MessageDeliveryModeType = ref$9.MessageDeliveryModeType;
var ref$10 = __webpack_require__(113);
var P2PUtil = ref$10.P2PUtil;
var ref$11 = __webpack_require__(73);
var SessionEvent = ref$11.SessionEvent;
var ref$12 = __webpack_require__(44);
var SessionEventCode = ref$12.SessionEventCode;
var ref$13 = __webpack_require__(72);
var SessionEventName = ref$13.SessionEventName;
var ref$14 = __webpack_require__(115);
var SessionFSMEvent = ref$14.SessionFSMEvent;
var ref$15 = __webpack_require__(75);
var SessionRequestType = ref$15.SessionRequestType;
var ref$16 = __webpack_require__(116);
var SessionStateName = ref$16.SessionStateName;
var ref$17 = __webpack_require__(19);
var StatType = ref$17.StatType;
var StatsByMode = ref$17.StatsByMode;
var ref$18 = __webpack_require__(4);
var StringUtils = ref$18.StringUtils;
var ref$19 = __webpack_require__(219);
var SubscriptionUpdateTimeoutMessages = ref$19.SubscriptionUpdateTimeoutMessages;

var formatHexString = Hex.formatHexString;
var stripNullTerminate = StringUtils.stripNullTerminate;
var STAT_TX_BYMODE_BYTES = StatsByMode.STAT_TX_BYMODE_BYTES;
var STAT_TX_BYMODE_MSGS = StatsByMode.STAT_TX_BYMODE_MSGS;
var STAT_RX_BYMODE_BYTES = StatsByMode.STAT_RX_BYMODE_BYTES;
var STAT_RX_BYMODE_MSGS = StatsByMode.STAT_RX_BYMODE_MSGS;
var STAT_TX_BYMODE_REDELIVERED = StatsByMode.STAT_TX_BYMODE_REDELIVERED;
var STAT_TX_BYMODE_BYTES_REDELIVERED = StatsByMode.STAT_TX_BYMODE_BYTES_REDELIVERED;

/**
 * @param {SessionProperties} sessionProperties The shared reference to the properties of the
 *  owning session
 * @param {Session} session The session owning this FSM
 * @extends StateMachine
 * @private
 */
var SessionFSM = (function (StateMachine) {
  function SessionFSM(sessionProperties, session, stats, hosts) {
    var this$1 = this;

    StateMachine.call(this, { name: 'SessionFSM' });
    var fsm = this;
    var logFormatter = function logFormatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [
        ("[session-fsm=" + (fsm.sessionIdHex || '(N/A)') + "]"),
        ("[" + (fsm.getCurrentStateName()) + "]") ].concat( args );
    };
    var logger = this.logger = new LogFormatter(logFormatter);
    var LOG_TRACE = logger.LOG_TRACE;
    var LOG_DEBUG = logger.LOG_DEBUG;
    var LOG_INFO = logger.LOG_INFO;
    this.log = logger.wrap(this.log, this);
    this._sessionProperties = sessionProperties;
    this._session = session;
    this._sessionStatistics = stats;
    this._hosts = hosts;
    this._consumers = new ConsumerLib.ConsumerFlows();
    // This is a function that generates this interface. It takes the flow as a construction
    // parameter, and for some methods, produces a partial application using that flow.
    this._flowInterfaceFactory = function (flow) { return ({
      getCorrelationTag:               this$1.getCorrelationTag.bind(this$1),
      incStat:                         this$1.incStat.bind(this$1),
      sendData:                        function (message) { return this$1.send(message, flow, false); },
      sendToTransport:                 function (message) { return this$1.sendToTransport(message, flow, false); },
      sendControl:                     function (message) { return this$1.send(message, flow, true); },
      enqueueRequest:                  this$1.enqueueOutstandingCorrelatedReq.bind(this$1),
      createDestinationFromDescriptor: session.createDestinationFromDescriptor.bind(session),
      createTemporaryDestination:      session.createTemporaryDestination.bind(session),
      isCapable:                       session.isCapable.bind(session),
      getCapability:                   session.getCapability.bind(session),

      get sessionIdHex() {
        return fsm.sessionIdHex;
      },
      get canAck() {
        return session.canAck;
      },
    }); };

    this.clearCurrentError();

    this.initial(function onInitial() {
      return this.transitionTo(fsm.SessionDisconnected,
                               function (context) { return context.getStateMachine().reset(); });
    });

    /**
     * Handles events in the unhandledEventHandler callback
     * @param {SessionFSMEvent} sEvent
     * @private
     */
    this.unhandledEventReaction(function onUnhandledEvent(sEvent) {
      var curState = fsm.getCurrentState();
      switch (sEvent.getName()) {
        case SessionEventName.CREATE_SUBSCRIBER:
          // CREATE_SUBSCRIBER is only handled in CONNECTED state.
          // In all other states we just add the consumer to our
          // list of unbound consumers that need to be bound when
          // the session up occurs.
          assert(fsm._consumers, 'collection has lifetime of FSM instance');
          fsm._consumers.add(sEvent.guaranteedFlowObject);
          return this;
        case SessionEventName.DISPOSE:
          /* #stripped LOG_DEBUG('Handling DISPOSE') */

          return curState.terminate(function () { return fsm.disposeInternal(); });
        case SessionEventName.FLOW_UP:
          /* #stripped LOG_DEBUG(`Ignoring FLOW_UP event from ${sEvent.guaranteedFlowObject}`) */

          return this;
        default:
          /* #stripped LOG_TRACE(`Ignoring event ${sEvent.getName()} in state ${fsm.getCurrentStateName()}`) */

          return this;
      }
    });

    this.SessionConnecting = new State({
      name:          SessionStateName.CONNECTING,
      parentContext: fsm,
    }, {
      //
      //  handleTransportDestroyed is called in response to TRANSPORT_DESTROYED
      //  event and if transport create throws an exception. In both case there is
      //  no underlying transport and the FSM must move on to the next host.
      handleTransportDestroyed: function handleTransportDestroyed() {
        fsm._currentHost = fsm._hosts.getNextHost();
        if (fsm._currentHost === null) {
          return this.transitionToExitPoint(fsm.SessionConnecting, 'ErrorExit');
        }

        var ref = fsm._hosts;
        var connectWaitTimeInMsecs = ref.connectWaitTimeInMsecs;
        /* #stripped LOG_TRACE(`Wait time for this host is ${connectWaitTimeInMsecs}`) */

        if (connectWaitTimeInMsecs > 0) {
          fsm._connectWaitTimer = setTimeout(function () {
            fsm.processEvent(new SessionFSMEvent({ name: SessionEventName.CONNECT_WAIT_TIMEOUT }));
          }, connectWaitTimeInMsecs);
          return this.transitionTo(fsm.WaitingForInterConnectTimeout);
        }
        return this.transitionTo(fsm.WaitingForTransport);
      },
    })
      .entry(function () {
        fsm.setConnectTimer();
      })
      .entryPoint('DisconnectTransport', function onDisconnectTransport() {
        fsm._hosts.reset({ wasConnected: undefined, disconnected: true });
        //
        // Set the error event, as we have reset the
        // host list with disconnected:true, we always take the
        // errorExit path to DISCONNECTED state after this entryPoint.
        //
        fsm._connectFailEvent = SessionEventCode.DISCONNECTED;
        fsm._connectSuccessEvent = SessionEventCode.DISCONNECTED;
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .entryPoint('ReconnectTransport', function onReconnectTransport() {
        //
        // Set the error event, this is only used
        // if we take the errorExit path
        //
        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
        fsm._connectSuccessEvent = SessionEventCode.RECONNECTED_NOTICE;
        // Should we try to reconnect?
        var disconnected = fsm._sessionProperties._reconnectRetries === 0;
        fsm._hosts.reset({ wasConnected: true, disconnected: disconnected });
        if (!disconnected) {
          // workaround to make sure session state is changed to connecting when
          // application gets the session event
          // positional parameters for SessionEvent constructor
          // make sure we get the args and err setup now as by the time
          // the postEventAction runs currentError will be reset.
          var err = fsm._currentError || {};
          var args = [err.eventText,    // infoString
            err.responseCode,             // responseCode
            err.errorSubcode,             // errorSubcode
            undefined,                    // correlationKey ... N/A
            err.eventReason];             // eventReason
          fsm.setPostEventAction(function () {
            fsm.setConnectTimer();
            fsm.emitSessionEvent(SessionEvent.build.apply(SessionEvent, [ SessionEventCode.RECONNECTING_NOTICE ].concat( args )));
          });
        }
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .initial(function () {
        fsm.clearCurrentError();
        //
        // Set the error event this is only used
        // if we take the errorExit path
        //
        fsm._connectFailEvent = SessionEventCode.CONNECT_FAILED_ERROR;
        fsm._connectSuccessEvent = SessionEventCode.UP_NOTICE;

        // Perform host resolution (guaranteed async; replaces a postEventAction)
        // Do not perform host list operations until this completes (moved to callback)
        fsm._hosts.resolveHosts(function (err) {
          if (!fsm._hosts) {
            /* #stripped LOG_TRACE('Ignoring host filter fail because session was disposed') */

            return null;
          }
          if (err) {
            /* #stripped LOG_TRACE('DNS filter failed:', err) */

            fsm.setCurrentError({
              errorSubcode: ErrorSubcode.UNRESOLVED_HOSTS,
              eventText:    err,
            });
            fsm._hosts.reset({ disconnected: true });
            return this$1.processEvent(new SessionFSMEvent({ name: SessionEventName.EXCEPTION }));
          }

          // Now that the host list has been scanned, we can reset and get next host
          fsm._hosts.reset({ wasConnected: false });
          fsm._currentHost = fsm._hosts.getNextHost();
          return this$1.processEvent(new SessionFSMEvent(
            { name: SessionEventName.DNS_RESOLUTION_COMPLETE }
          ));
        });
        return this$1.transitionTo(fsm.WaitingForDNS);
      })
      .reaction(SessionEventName.DNS_RESOLUTION_COMPLETE, function onDNSComplete() {
        return this.transitionTo(fsm.WaitingForTransport);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* event */) {
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      })
      .reaction(SessionEventName.CONNECT_TIMEOUT, function onConnectTimeout(/* event */) {
        fsm.setCurrentError({
          errorSubcode: ErrorSubcode.TIMEOUT,
          eventText:    'Connect timeout',
        });
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
        // TODO: I think EXCEPTION events never carry extra error information
        // as setCurrentError is already called.
        fsm.setCurrentError(errEvent);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        /* #stripped LOG_DEBUG('TRANSPORT_DESTROYED event') */

        return this.transitionTo(fsm.DestroyingTransport);
      })
      .exit(function () {
        fsm.clearConnectTimer();
        if (fsm._connectWaitTimer) {
          clearTimeout(fsm._connectWaitTimer);
          fsm._connectWaitTimer = null;
        }
      })
      .exitPoint('ConnectedExit', function (/* event */) {
        // Normal exit to TransportUp.
        // We need to notify the application they are connected. Use postEventAction to make sure
        // session state has already changed to TransportUp when application gets the callback.
        // Use _connectSuccessEvent to send RECONNECTED vs UP depending on entry point.
        // TODO: what text to include with event, currently text is different for
        // connect vs reconnect. We should store with as part of _connectSuccessEvent in
        // the entry point.
        fsm.setPostEventAction(function () {
          fsm.emitSessionEvent(SessionEvent.build(fsm._connectSuccessEvent,
                                                  ("'" + (fsm._hosts.currentHostToString()) + "'"),
                                                  200, 0, null, null));
        });
        // Clear current error as we have successfully connected or
        // reconnected.
        fsm.clearCurrentError();
        return this$1.transitionTo(fsm.SessionTransportUp);
      })
      .exitPoint('ErrorExit', function onExit(/* event */) {
        // Notify the application they are disconnected. Use postEventAction to make sure session
        // state has already changed to disconnected when application gets the callback.
        fsm.setPostEventAction(function () {
          var err = fsm._currentError || {};
          // positional parameters for SessionEvent constructor
          var args = [err.eventText,    // infoString
            err.responseCode,             // responseCode
            err.errorSubcode,             // errorSubcode
            undefined,                    // correlationKey ... N/A
            err.eventReason];             // eventReason
          fsm.emitSessionEvent(SessionEvent.build.apply(SessionEvent, [ fsm._connectFailEvent ].concat( args )));
        });
        return this.transitionTo(fsm.SessionDisconnected);
      });

    this.WaitingForDNS = new State({
      name:          SessionStateName.WAITING_FOR_DNS,
      parentContext: fsm.SessionConnecting,
    });

    this.DestroyingTransport = new State({
      name:          SessionStateName.DESTROYING_TRANSPORT,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        /* #stripped LOG_DEBUG('Connecting, disposing transport') */

        // TODO: is there a string or subCode that can be captured here
        fsm.destroyTransportSession('Disconnecting session', 0);
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
        fsm.setCurrentError(sessionEvent);
        return fsm.SessionConnecting.handleTransportDestroyed.call(this);
      });

    this.WaitingForInterConnectTimeout = new State({
      name:          SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT,
      parentContext: fsm.SessionConnecting,
    })
      .reaction(SessionEventName.CONNECT_WAIT_TIMEOUT, function onConnectWaitTimeout(/*event*/) {
        return this.transitionTo(fsm.WaitingForTransport);
      });

    this.WaitingForTransport = new State({
      name:          SessionStateName.WAITING_FOR_TRANSPORT,
      parentContext: fsm.SessionConnecting,
    })
      .initial(function () {
        var errorMessage = 'Cannot establish transport session: creation failed';
        fsm.setConnectTimer();
        fsm.clearCurrentError();
        try {
          fsm.initTransport();
        } catch (e) {
          this$1.setCurrentError({
            eventText:    e.message === errorMessage ? errorMessage : (errorMessage + ": " + (e.message)),
            errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
            eventReason:  e });
            // TODO:  how do we handle a transition in an entry point
            // and should we reference fsm.SessionConnecting directly or via
            // parentContext? or by var set in parentContext
          return fsm.SessionConnecting.handleTransportDestroyed.call(this$1);
        }
        return this$1.transitionTo(fsm.WaitingForTransportUp);
      });

    this.WaitingForTransportUp = new State({
      name:          SessionStateName.WAITING_FOR_TRANSPORT_UP,
      parentContext: this.WaitingForTransport,
    })
      .initial(function () {
        var errorMessage = 'Cannot establish transport session: connection failed';
        try {
          var returnCode = fsm._transport.connect();
          if (returnCode !== TransportLib.TransportReturnCode.OK) {
            throw new OperationError(
              errorMessage,
              ErrorSubcode.CONNECTION_ERROR,
              TransportLib.TransportReturnCode.describe(returnCode)
            );
          }
          /* #stripped LOG_DEBUG(`Attempting to connect session '${fsm.sessionId}' to ${fsm._hosts.currentHostToString()}`) */

        } catch (e) {
          this$1.setCurrentError({
            eventText:    e.message === errorMessage ? errorMessage : (errorMessage + ": " + (e.message)),
            errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
            eventReason:  e });
          // TODO:  how do we handle a transition in an entry point
          // and should we reference fsm.SessionConnecting directly or via
          // parentContext? or by var set in parentContext
          return fsm.SessionConnecting.handleTransportDestroyed.call(this$1);
        }
        return this$1;
      })
      .reaction(SessionEventName.TRANSPORT_UP, function onTransportUp(sEvent) {
        fsm.sessionId = sEvent.sessionId || '';
        var returnCode = fsm.sendClientCtrlLogin();
        if (returnCode === TransportLib.TransportReturnCode.OK) {
          return this.transitionTo(fsm.WaitingForLogin);
        }
        // TODO: capture a subCode from the transport
        var err = {
          eventText:    'Failed to send Client Control Login',
          errorSubcode: ErrorSubcode.LOGIN_FAILURE,
          responseCode: 400,
        };
        fsm.setCurrentError(err);
        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.WaitingForLogin = new State({
      name:          SessionStateName.WAITING_FOR_LOGIN,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        fsm.setClientCtrlTimer();
      })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL, function onClientCtrl(sEvent) {
        var clientCtrlMsg = sEvent.smfMsg;
        var response = clientCtrlMsg.getResponse();
        var respCode = response.responseCode;
        var err = {
          responseCode: respCode,
        };
        fsm._responseCode = respCode;
        if (respCode === 200) {
          if (fsm.checkNoLocal(clientCtrlMsg)) {
            fsm.updateReadonlySessionProps(clientCtrlMsg);
            return this.transitionTo(fsm.ReapplyingSubscriptions);
          }
          Object.assign(err, {
            eventText:    'No Local is not supported by the Solace Message Router',
            errorSubcode: ErrorSubcode.NO_LOCAL_NOT_SUPPORTED,
          });
        } else {
          Object.assign(err, {
            eventText:    response.responseString,
            errorSubcode: ErrorResponseSubcodeMapper.getErrorSubcode(respCode,
                                                                     response.responseString),
          });
        }
        /* #stripped LOG_TRACE('ClientCtrl error', err) */

        fsm.setCurrentError(err);
        return this.transitionTo(fsm.DestroyingTransport);
      })
      .reaction(SessionEventName.DOWNGRADE_TIMEOUT, function onDowngradeTimeout(/* event */) {
        if (fsm._transport.requestDowngrade('ClientCtrl timeout', ErrorSubcode.TIMEOUT) === false) {
          fsm.setCurrentError({
            eventText:    'ClientCtrl timeout',
            errorSubcode: ErrorSubcode.TIMEOUT,
          });
          return this.transitionTo(fsm.DestroyingTransport);
        }
        // Don't recreate the transport, just try to connect it
        /* #stripped LOG_TRACE('Downgrade accepted, returning to WaitingForTransportUp') */

        return this.transitionTo(fsm.WaitingForTransportUp);
      })
      .exit(function () {
        fsm.clearClientCtrlTimer();
      });

    this.ReapplyingSubscriptions = new State({
      name:          SessionStateName.REAPPLYING_SUBSCRIPTIONS,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        /* #stripped LOG_DEBUG('ReapplyingSubscriptions: entry') */

        fsm.copySubscriptionCacheKeys();
      })
      .initial(function onInitial() {
        if (fsm.reapplySubscriptions() === true) {
          // all subscriptions applied and waiting for a subscription confirm
          return this.transitionTo(fsm.WaitForSubConfirm);
        }
        // flow controlled while reapplying
        return this.transitionTo(fsm.WaitForCanAcceptData);
      })
      .reaction(SessionEventName.SUBSCRIBE_TIMEOUT, function onSubscribeTimeout() {
        var respText = 'Subscription timeout while reapplying';
        var subcode = ErrorSubcode.TIMEOUT;
        fsm.setCurrentError({
          eventText:    respText,
          errorSubcode: subcode,
        });
        return this.transition(fsm.DestroyingTransport);
      })
      .exit(function onExit() {
        fsm.clearSubscriptionCacheKeys();
        return this;
      });

    this.WaitForSubConfirm = new State({
      name:          SessionStateName.WAITING_FOR_SUBCONFIRM,
      parentContext: fsm.ReapplyingSubscriptions,
    })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        // process rxMsgObj
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;
        if (respCode !== 200) {
          var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
          /* #stripped LOG_DEBUG(`Waiting for subscription confirmation, got ${respCode} (${errorSubcode}) ` +
                    `'${respText}' on subscription ${subscriptionStr}`) */

          fsm.setCurrentError({
            eventText:    respText,
            responseCode: respCode,
            errorSubcode: errorSubcode,
          });
          return this.transitionTo(fsm.DestroyTransport);
        }

        if (fsm._session.canConnectPublisher &&
            fsm._defaultPublisher &&
            fsm._defaultPublisher.isBindWaiting()) {
          return this.transitionTo(fsm.WaitingForMessagePublisher);
        }
        return this.transitionToExitPoint(fsm.SessionConnecting, 'ConnectedExit');
      });

    this.WaitForCanAcceptData = new State({
      name:          SessionStateName.WAITING_FOR_CAN_ACCEPT_DATA,
      parentContext: fsm.ReapplyingSubscriptions,
    })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        // process rxMsgObj
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;
        // We are not expecting a SMP response as we have not sent a request-confirm
        // so this is almost assuredly an error response to a subscription add
        // check respCode anyway.  if its '200 OK' just ignore it.
        if (respCode !== 200) {
          var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
          /* #stripped LOG_DEBUG(`Waiting for can accept data, got ${respCode} (subcode ${errorSubcode}) ` +
            `'${respText}' on subscription ${subscriptionStr}`) */

          fsm.setCurrentError({
            eventText:    respText,
            responseCode: respCode,
            errorSubcode: errorSubcode,
          });
          return this.transitionTo(fsm.DestroyingTransport);
        }
        // unexpected 200 OK repsonse, log it and continue
        LOG_INFO(("Unexpected 200 OK response to subscription add for " + subscriptionStr));
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onTransportCanAcceptData() {
        if (fsm.reapplySubscriptions() === true) {
          // all subscriptions applied and waiting for a subscription confirm
          return this.transitionTo(fsm.WaitForSubConfirm);
        }
        // flow controlled while reapplying
        return this.internalTransition(null);
      });

    this.WaitingForMessagePublisher = new State({
      name:          SessionStateName.WAITING_FOR_PUBFLOW,
      parentContext: fsm.SessionConnecting,
    })
      .entry(function () {
        // Inform the publisher that the session is up and the flow establishment can begin.
        fsm._defaultPublisher.connect();
        fsm.sendPublisherSessionUpEvent(fsm._defaultPublisher);
      })
      .reaction(SessionEventName.FLOW_UP, function onEvent() {
        /* #stripped LOG_TRACE(`Flow up ${this}`) */

        if (!fsm._defaultPublisher.isBindWaiting()) {
          /* #stripped LOG_TRACE('Publisher up') */

          return this.transitionToExitPoint(fsm.SessionConnecting, 'ConnectedExit');
        }
        /* #stripped LOG_TRACE('Waiting for more publishers') */

        return this.internalTransition(null);
      })
      .reaction(SessionEventName.FLOW_FAILED, function onEvent(sEvent) {
        // TODO: LOGIN_FAILURE for flow failed? Credentials disallow GM publishing?
        fsm.setCurrentError({
          eventText:    ("Guaranteed Message Publisher Failed: " + (sEvent.eventText)),
          errorSubcode: ErrorSubcode.LOGIN_FAILURE,
        });
        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.SessionTransportUp = new State({
      name:          SessionStateName.TRANSPORT_UP,
      parentContext: fsm,
    })
      .entry(function onEntry() {
        return this;
      })
      .initial(function onInitial() {
        if (fsm._session.canConnectConsumer) {
          // Inform the subscribers that the session is up and the flow establishment can begin.
          fsm._consumers.flows.forEach(function (consumer) { return fsm.sendConsumerSessionUpEvent(consumer); });
        }
        return this.transitionTo(fsm.FullyConnected);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        return this.transitionTo(fsm.SessionDisconnecting);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(sEvent) {
        fsm.setCurrentError(sEvent);
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
        fsm.setCurrentError(sEvent);
        fsm.cleanupSession();
        /* #stripped LOG_TRACE('Reconnecting transport after SEND_ERROR (not fully connected)') */

        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sEvent) {
        fsm.setCurrentError(sEvent);
        /* #stripped LOG_DEBUG('Received unsolicited TRANSPORT_DESTROYED event while transport is up') */

        /* #stripped LOG_TRACE(`TRANSPORT_DESTROYED details: ${sEvent}`) */

        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'ReconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
        var smfRespHeader = sEvent.smfMsg.smfHeader;
        var subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
        var respCode = smfRespHeader.pm_respcode;
        var respText = smfRespHeader.pm_respstr;

        fsm.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, undefined, false);
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onCanAcceptData(sEvent) {
        // Notify client for republishing
        var sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA,
                                                '', null, 0, null, sEvent.toString());
        fsm.emitSessionEvent(sessionEvent);
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.CREATE_SUBSCRIBER, function onCreateSubscriber(sEvent) {
        // Inform the consumer that the session is up and the flow establishment can begin.
        var consumer = fsm._consumers.add(sEvent.guaranteedFlowObject);
        fsm.sendConsumerSessionUpEvent(consumer);
        return this;
      })
      .exit(function onExit() {
        fsm.clearKeepAlive();
        return this;
      });

    this.FullyConnected = new State({
      name:          SessionStateName.FULLY_CONNECTED,
      parentContext: fsm.SessionTransportUp,
    })
      .entry(function () {
        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
        fsm.scheduleKeepAlive();
      })
      .reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
        fsm.setCurrentError(sEvent);
        /* #stripped LOG_TRACE('Disconnecting transport after SEND_ERROR when fully connected') */

        return this.transitionTo(fsm.DestroyingTransport);
      });

    this.SessionDisconnected = new State({
      name:          SessionStateName.DISCONNECTED,
      parentContext: fsm,
    })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        fsm.setPostEventAction(function () {
          fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.DISCONNECTED));
        });

        return this.internalTransition(null);
      })
      .reaction(SessionEventName.CONNECT, function onConnect(/* sEvent */) {
        return this.transitionTo(fsm.SessionConnecting);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(/* sEvent */) {
        // do nothing
        return this.internalTransition(null);
      });
    this.SessionDisconnecting = new State({
      name:          SessionStateName.DISCONNECTING,
      parentContext: fsm,
    })
      .initial(function () {
        /* #stripped LOG_DEBUG(`Disconnecting session ${fsm}`) */

        return this$1.transitionTo(fsm.DisconnectingFlows);
      })
      .reaction(SessionEventName.DISCONNECT, function onDisconnect(/* sEvent */) {
        return this.internalTransition(null);
      })
      .reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
        //
        // As we are in disconnecting state we have initiated the
        // disconnect and need to preserve the error subcode that
        // we set before destroying the transport. The transport, having
        // no error, will usually return a subcode of zero here.
        //
        // This only changes the eventCode, not the subcode. Other properties
        // are preserved.
        //
        fsm.setCurrentError({ errEvent: errEvent });
        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      })
      .reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(/* sEvent */) {
        /* #stripped LOG_DEBUG('Received unsolicited TRANSPORT_DESTROYED while disconnecting transport') */

        fsm.cleanupSession();
        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      });

    this.DisconnectingFlows = new State({
      name:          SessionStateName.DISCONNECTING_FLOWS,
      parentContext: fsm.SessionDisconnecting,
    }, {
      // Get all flows to disconnect. This will need to be called at least once.
      gatherPendingFlows: function gatherPendingFlows() {
        var this$1 = this;

        var MessageConsumerEventName = ConsumerLib.MessageConsumerEventName;
        var MessagePublisherEventName = PublisherLib.MessagePublisherEventName;

        // Don't re-enter synchronously to look for new flows.
        // Flows disconnect synchronously when they are already disconnected.
        // If this is the case, they throw; they do not emit an event.
        // If a consumer flow is up, it will immediately emit a BIND_WAITING event and we
        // handle that.
        // Since we know that flow#_disconnectSession neither creates a new flow
        // nor calls a user callback that could do so, we need not look for new
        // flows that were created.
        assert(!this.isGathering);
        this.isGathering = true;

        var adaptedListenForDestroy = function (flow, installfn, downEvents) {
          assert(flow, 'Trying to listen to undefined flow');
          // If we already know about this flow, skip it.
          if (this$1.known.has(flow)) { return; }
          /* #stripped LOG_TRACE(`Adding pending flow ${flow}`) */

          this$1.known.add(flow);
          this$1.pending.add(flow);
          var onFlowDown = function () {
            /* #stripped LOG_TRACE(`Removing flow from pending ${flow}`) */

            downEvents.forEach(function (event) { return flow._removeListener(event, onFlowDown); });
            this$1.pending.delete(flow);
            if (!this$1.isGathering) { this$1.checkPendingFlows(); }
          };
          downEvents.forEach(function (event) { return installfn.call(flow, event, onFlowDown); });
          try {
            flow._disconnectSession(); // Session has been disconnected by user
          } catch (ex) {
             // Synchronously down
            /* #stripped LOG_TRACE('Flow disconnect threw') */

            onFlowDown();
          }
        };

        if (fsm._defaultPublisher) {
          adaptedListenForDestroy(fsm._defaultPublisher,
                                  fsm._defaultPublisher.once,
                                  [MessagePublisherEventName.DOWN]);
        }
        if (fsm._consumers) {
          fsm._consumers.flows.forEach(function (flow) {
            adaptedListenForDestroy(flow,
                                    flow._once,
                                    [
                                      MessageConsumerEventName.DOWN,
                                      MessageConsumerEventName.DOWN_ERROR ]);
          });
        }

        this.isGathering = false;
      },
      // This function is called whenever a flow comes down, whether sync or async.
      // The body is wrapped in a basic debounce: if we are re-entering (synchronously),
      // no new flows will be added.
      checkPendingFlows: function checkPendingFlows() {
        /* #stripped LOG_TRACE('Waiting for disconnects on', this.pending) */

        if (this.pending.size === 0) {
          // We are out of pending flows, but look for new flows that were just added
          this.gatherPendingFlows();
          // Were any flows just added?
          if (this.pending.size === 0) {
            this.proceed();
          }
        }
      },
      proceed: function proceed() {
        // All done!
        // Clear flow sets so they can be disposed
        this.known = null;
        this.pending = null;
        /* #stripped LOG_DEBUG('All flows disconnected') */

        fsm.processEvent(new FsmEvent({ name: SessionEventName.FLOWS_DISCONNECTED }));
      },
    })
      .entry(function onEntry() {
        this.known = new Set();
        this.pending = new Set();
        this.checkPendingFlows();
      })
      .reaction(SessionEventName.FLOWS_DISCONNECTED, function onFlowsDisconnected() {
        return this.transitionTo(fsm.FlushingTransport);
      });

    this.FlushingTransport = new State({
      name:          SessionStateName.FLUSHING_TRANSPORT,
      parentContext: fsm.SessionDisconnecting,
    }, {
      flushTransport: function flushTransport() {
        var this$1 = this;

        fsm.cleanupSession();
        fsm.flushTransportSession(function () { return this$1.onTransportFlushed(); });
        this.sessionId = null;
      },
      onTransportFlushed: function onTransportFlushed() {
        fsm.processEvent(new FsmEvent({ name: SessionEventName.TRANSPORT_FLUSHED }));
      },
    })
      .entry(function onEntry() {
        /* #stripped LOG_DEBUG('Flushing transport') */

        this.flushTransport();
      })
      .reaction(SessionEventName.TRANSPORT_FLUSHED, function onTransportFlushed() {
        /* #stripped LOG_DEBUG('Handle Transport Flushed') */

        return this.transitionToEntryPoint(fsm.SessionConnecting, 'DisconnectTransport');
      });
  }

  if ( StateMachine ) SessionFSM.__proto__ = StateMachine;
  SessionFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  SessionFSM.prototype.constructor = SessionFSM;

  var prototypeAccessors = { sessionIdHex: {} };

  /**
   * @param {Destination} destination The topic to add
   * @private
   */
  SessionFSM.prototype.addToSubscriptionCache = function addToSubscriptionCache (destination) {
    if (Check.nothing(destination) || !this._subscriptionCache) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var key = destination.name;
    if (this._subscriptionCache[key] === null ||
        this._subscriptionCache[key] === undefined) {
      /* #stripped LOG_DEBUG(`Cache subscription ${key}`) */

      this._subscriptionCache[key] = destination;
      /* #stripped LOG_DEBUG('Increment cache count') */

      this._subscriptionCacheCount++;
    } else {
      /* #stripped LOG_DEBUG(`Cache subscription ${key}`) */

      this._subscriptionCache[key] = destination;
    }
  };

  /**
   * @param {String} correlationTag The tag of the request to cancel
   * @returns {CorrelatedRequest} The cancelled request
   * @private
   */
  SessionFSM.prototype.cancelOutstandingCorrelatedReq = function cancelOutstandingCorrelatedReq (correlationTag) {
    if (Check.nothing(correlationTag) || !this._correlatedReqs) {
      return null;
    }
    var req = this._correlatedReqs[correlationTag];
    if (req === null || req === undefined) {
      return null;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    /* #stripped LOG_DEBUG(`Cancel outstanding ctrl request correlationTag=${correlationTag
      }`) */

    if (req.timer) {
      clearTimeout(req.timer);
      req.timer = null;
    }
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag), e);
    }
    return req;
  };


  /**
   * @private
   */
  SessionFSM.prototype.cleanupSession = function cleanupSession () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Clean up session') */


    var ConsumerFSMEvent = ConsumerLib.ConsumerFSMEvent;
    var ConsumerFSMEventNames = ConsumerLib.ConsumerFSMEventNames;

    if (this._correlatedReqs) {
      Object.keys(this._correlatedReqs).forEach(function (key) { return this$1.cancelOutstandingCorrelatedReq(key); });
    }

    this.clearConnectTimer();
    this.clearClientCtrlTimer();
    this.clearKeepAlive();
    this._consumers.flows.forEach(function (consumer) {
      consumer.processFSMEvent(
        new ConsumerFSMEvent({ name: ConsumerFSMEventNames.SESSION_DOWN })
      );
    });
    if (this._defaultPublisher) {
      this._defaultPublisher.processFSMEvent(
        new PublisherLib.PublisherFSMEvent({
          name: PublisherLib.PublisherFSMEventNames.SESSION_DOWN,
        })
      );
    }
    this._session.cleanupSession();
  };

  /**
   * @private
   */
  SessionFSM.prototype.clearClientCtrlTimer = function clearClientCtrlTimer () {
    if (!this._clientCtrlTimer) {
      return;
    }

    clearTimeout(this._clientCtrlTimer);
    this._clientCtrlTimer = null;
  };


  /**
   * @private
   */
  SessionFSM.prototype.clearConnectTimer = function clearConnectTimer () {
    if (!this._connectTimer) {
      return;
    }

    clearTimeout(this._connectTimer);
    this._connectTimer = undefined;
  };

  /**
   * Cancel keep alive task
   * @private
   */
  SessionFSM.prototype.clearKeepAlive = function clearKeepAlive () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;

    if (this._keepAliveTimer) {
      /* #stripped LOG_DEBUG('Cancel keepalive timer') */

      clearInterval(this._keepAliveTimer);
      this._keepAliveTimer = null;
    }

    this.resetKeepAliveCounter();
  };


  /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to parse
   * @returns {Boolean} true if No Local is supported by the router
   * @private
   */
  SessionFSM.prototype.checkNoLocal = function checkNoLocal (clientCtrlMsg) {
    var noLocalSupported = true;
    if (this._sessionProperties.noLocal === true) {
      var caps = clientCtrlMsg.getRouterCapabilities();
      if (!caps) {
        noLocalSupported = false;
      } else {
        // Guard for undefined OR non-boolean capability
        noLocalSupported = (typeof caps[CapabilityType.NO_LOCAL] === 'boolean') ? caps[CapabilityType.NO_LOCAL] : false;
      }
    }
    return noLocalSupported;
  };

  /**
   * Clears the current error exit information for the FSM.
   */
  SessionFSM.prototype.clearCurrentError = function clearCurrentError () {
    this._currentError = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.clearSubscriptionCacheKeys = function clearSubscriptionCacheKeys () {
    this._subscriptionCacheKeys = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.copySubscriptionCacheKeys = function copySubscriptionCacheKeys () {
    // reapply subscriptions if applicable
    this.clearSubscriptionCacheKeys();
    this._subscriptionCacheKeys = Object.keys(this._subscriptionCache || {});

    // Add the P2P Inbox subscription, so the subscriptionCache always has
    // at least one subscription.
    var p2pTopic = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
    this._subscriptionCacheKeys.push(p2pTopic);
  };

  SessionFSM.prototype.createMessagePublisher = function createMessagePublisher () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    if (!this._sessionProperties.publisherProperties.enabled) {
      /* #stripped LOG_DEBUG('Publisher is disabled') */

      return;
    }

    var MessagePublisher = PublisherLib.MessagePublisher;
    var MessagePublisherEventName = PublisherLib.MessagePublisherEventName;
    var publisher = new MessagePublisher({
      properties:              this._sessionProperties.publisherProperties,
      sessionInterfaceFactory: this._flowInterfaceFactory,
    });
    publisher.on(
      MessagePublisherEventName.UP,
      function () { return this$1.processEvent(new SessionFSMEvent(
        { name: SessionEventName.FLOW_UP },
        { guaranteedFlowObject: publisher })); });
    publisher.on(
      MessagePublisherEventName.CONNECT_FAILED_ERROR,
      function (event) { return this$1.processEvent(
        new SessionFSMEvent(
          { name: SessionEventName.FLOW_FAILED },
          {
            guaranteedFlowObject: publisher,
            event: event,
            eventText:            event.description,
          })); });

    publisher.on(MessagePublisherEventName.REJECTED_MESSAGE, function (message, ctrlMessage) {
      var header = ctrlMessage.smfHeader;
      var respCode = header.pm_respcode;
      var respText = header.pm_respstr;
      var errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respText);
      var event = SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR,
                                       respText,
                                       respCode,
                                       errorSubcode,
                                       message.getCorrelationKey());
      event['message'] = message; // eslint-disable-line dot-notation
      this$1.emitSessionEvent(event);
    });
    publisher.on(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, function (message) {
      var event = SessionEvent.build(SessionEventCode.ACKNOWLEDGED_MESSAGE,
                                       'Message(s) acknowledged',
                                       undefined,
                                       0,
                                       message.getCorrelationKey());
      event['message'] = message; // eslint-disable-line dot-notation
      this$1.emitSessionEvent(event);
    });
    publisher.on(MessagePublisherEventName.FLOW_NAME_CHANGED, function (data) {
      var messages = data.messages;
      var count = data.count;
      if (count > 0) {
        var event = SessionEvent.build(SessionEventCode.REPUBLISHING_UNACKED_MESSAGES,
                                         "Republishing " + count + " messages due to " +
          'Guaranteed Message Publisher failed to reconnect');
        event['messages'] = messages; // eslint-disable-line dot-notation
        event['count'] = count; // eslint-disable-line dot-notation
        this$1.emitSessionEvent(event);
      }
    });
    publisher.on(MessagePublisherEventName.CAN_SEND, function () {
      this$1.emitSessionEvent(
        SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA,
                           (publisher + " window is now open and can send")));
    });
    publisher.on(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN, function () {
      this$1.emitSessionEvent(
        SessionEvent.build(
          SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN,
          'Guaranteed Message Publishing shut down'));
    });
    this._defaultPublisher = publisher;
  };

  SessionFSM.prototype.sendConsumerSessionUpEvent = function sendConsumerSessionUpEvent (consumer) {
    var ConsumerFSMEvent = ConsumerLib.ConsumerFSMEvent;
    var ConsumerFSMEventNames = ConsumerLib.ConsumerFSMEventNames;
    var isAD = this._session.canConnectConsumer;
    var event = new ConsumerFSMEvent({
      name: isAD
        ? ConsumerFSMEventNames.SESSION_UP
        : ConsumerFSMEventNames.SESSION_UP_NO_AD,
    });
    event.guaranteedFlowObject = consumer;
    consumer.processFSMEvent(event);
  };

  SessionFSM.prototype.sendPublisherSessionUpEvent = function sendPublisherSessionUpEvent (publisher) {
    var isAD = this._session.canConnectPublisher;
    var event = new PublisherLib.PublisherFSMEvent({
      name: isAD
        ? PublisherLib.PublisherFSMEventNames.SESSION_UP
        : PublisherLib.PublisherFSMEventNames.SESSION_UP_NO_AD,
    });
    event.guaranteedFlowObject = publisher;
    publisher.processFSMEvent(event);
  };

  /**
   * Creates a Guaranteed Messaging Subscriber.
   *
   * @param {Object|MessageConsumerProperties} properties Properties for the flow.
   *  Expected fields: {@link solace.MessageConsumerProperties}
   * @returns {solace.MessageConsumer} The newly constructed consumer
   * @private
   */
  SessionFSM.prototype.createMessageConsumer = function createMessageConsumer (properties) {
    var MessageConsumer = ConsumerLib.MessageConsumer;
    var consumer = new MessageConsumer({
      properties: properties,
      sessionInterfaceFactory: this._flowInterfaceFactory,
    });
    var info = { guaranteedFlowObject: consumer };
    // Will be added to the guaranteed flow collection by dispatching
    this.processEvent(
      new SessionFSMEvent({ name: SessionEventName.CREATE_SUBSCRIBER }, info)
    );
    return consumer;
  };

  /**
   * @param {String} msg The status message for the operation
   * @param {Subcode} subcode The subcode reason for the operation
   * @private
   */
  SessionFSM.prototype.destroyTransportSession = function destroyTransportSession (msg, subcode) {
    if (Check.nothing(this._transport)) {
      // Just send the event
      this.processEvent(
        new SessionFSMEvent({ name: SessionEventName.TRANSPORT_DESTROYED })
      );
      return;
    }
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    /* #stripped LOG_DEBUG('Destroy transport session') */


    var returnCode = this._transport.destroy(msg, subcode);
    this._smfClient = null;

    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      LOG_ERROR(("Failed to destroy transport session, return code: " + (TransportLib.TransportReturnCode.describe(returnCode))));
    }
  };


  /**
   * Release all resources associated with the session.
   * @private
   */
  SessionFSM.prototype.disposeInternal = function disposeInternal () {
    var this$1 = this;

    if (this._disposed) {
      return;
    }

    var operations = {
      'transport': function () {
        this$1.destroyTransportSession('Disposing', 0);
        this$1._transport = null;
        this$1._smfClient = null;
      },
      'session': function () {
        this$1.cleanupSession();
        this$1._session = null;
        this$1._sessionProperties = null;
        this$1._correlatedReqs = null;
        this$1._flowInterfaceFactory = null;
      },
      'statistics': function () {
        if (this$1._sessionStatistics) {
          this$1._sessionStatistics.resetStats();
          this$1._sessionStatistics = null;
        }
        this$1._kaStats = null;
      },
      'subscription cache': function () {
        if (this$1._subscriptionCache) {
          Object.keys(this$1._subscriptionCache).forEach(
            function (key) { return this$1.removeFromSubscriptionCache(key); }
          );
          this$1._subscriptionCache = null;
        }
        this$1.clearSubscriptionCacheKeys();
        this$1._subscriptionCacheCount = 0;
      },
      'MessagePublishers': function () {
        if (this$1._defaultPublisher) {
          this$1._defaultPublisher.dispose();
          this$1._defaultPublisher = null;
        }
      },
      'MessageConsumers': function () {
        this$1._consumers.disposeAll();
        this$1._consumers = null;
      },
      'host list': function () {
        this$1._currentHost = null;
        this$1._hosts = null;
      },
    };

    Object.keys(operations).forEach(function (operationKey) {
      var ref = this$1.logger;
      var LOG_TRACE = ref.LOG_TRACE;
      var LOG_INFO = ref.LOG_INFO;
      var operation = operations[operationKey];
      try {
        /* #stripped LOG_TRACE(`Dispose: ${operationKey}`) */

        operation();
        /* #stripped LOG_TRACE(`Dispose: ${operationKey} succeeded`) */

      } catch (ex) {
        LOG_INFO(("Dispose: " + operationKey + " failed:"), ex, '...continuing');
      }
    });
    this._disposed = true;
  };

  SessionFSM.prototype.emitSessionEvent = function emitSessionEvent (event) {
    // Don't log here; callee does it
    this._session.sendEvent(event);
  };

  /**
   * @param {Number} correlationTag The correlation tag
   * @param {function} reqTimeoutCb The timeout callback
   * @param {Number} reqTimeout The timeout in milliseconds
   * @param {Object} correlationKey The correlation key
   * @param {function} respRecvCallback The success callback
   * @private
   */
  SessionFSM.prototype.enqueueOutstandingCorrelatedReq = function enqueueOutstandingCorrelatedReq (correlationTag,
                                  reqTimeoutCb,
                                  reqTimeout,
                                  correlationKey,
                                  respRecvCallback) {
    if (Check.nothing(correlationTag)) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG(`Enqueue outstanding ctrl request correlationTag=${correlationTag}`) */

    var timer = null;
    if (reqTimeoutCb) {
      timer = setTimeout(reqTimeoutCb, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
    }

    var outstandingReq = new CorrelatedRequest(correlationTag,
      timer,
      correlationKey,
      respRecvCallback);
    this._correlatedReqs[correlationTag] = outstandingReq;
  };

  /**
   * @param {String} errorEventText Description of the error
   * @param {ErrorSubcode} errorSubcode Subcode for the error
   * @param {String} [eventReason] The reason for the error
   * @returns {undefined}
   * @memberof SessionFSM
   * @private
   */
  SessionFSM.prototype.errorInFsm = function errorInFsm (errorEventText, errorSubcode, eventReason) {
    if ( eventReason === void 0 ) eventReason = null;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var sEvent = new SessionFSMEvent({ name: SessionEventName.EXCEPTION });
    /* #stripped LOG_DEBUG(`Handling error in FSM: ${errorEventText} ${eventReason && eventReason.stack}`) */

    this.setCurrentError({
      eventText: errorEventText,
      errorSubcode: errorSubcode,
      eventReason: eventReason,
    });
    return this.processEvent(sEvent);
  };

  SessionFSM.prototype.flushTransportSession = function flushTransportSession (callback) {
    if (this._transport) {
      this._transport.flush(callback);
    } else {
      callback();
    }
  };

  /**
   * TODO:  This should probably be a static method on smf not necessarily instantiated in every
   * smfClient.  Look into adding correlation tag when objects are create
   * (AdProtocolMsg, clientCtrlMsg) then retrieving it from those objects.
   * Re: tags created in messages; do we really want to decrease performance of message generation?
   * Those message types do not necessarily require correlation tags. Could generate when required
   * based on message object subtype (e.g. OPENFLOW).
   * @returns {Number} The next correlation tag
   * @private
   */
  SessionFSM.prototype.getCorrelationTag = function getCorrelationTag () {
    return this._smfClient.nextCorrelationTag();
  };

  /**
   * Get current state name
   * @returns {String} The name of the current state, or SessionStateName.DISPOSED if the
   *  FSM is terminated
   * @private
   */
  SessionFSM.prototype.getCurrentStateName = function getCurrentStateName () {
    var currentState = this.getCurrentState();

    if (!currentState) { return null; }
    if (currentState === this.getFinalState()) { return SessionStateName.DISPOSED; }
    return this.getCurrentState().getName();
  };

  /**
   * Returns the value of a given {@link StatType}.
   *
   * @param {StatType} statType The statistic to query.
   * @returns {?Number} The value for the given stat, if available
   * @private
   */
  SessionFSM.prototype.getStat = function getStat (statType) {
    if (this._sessionStatistics === undefined) {
      return undefined;
    }
    //
    // TX_TOTAL_DATA_MSGS and TX_TOTAL_DATA_BYTES are summary counters
    // These stats are calculated as the sum of DIRECT/PERSISTENT/NONPERSISTENT
    // counters.  This is by design since day one.  As such they do not include
    // the count of redelivered messages/bytes as TX_PERSISTENT_MSGS and TX_NONPERSISTENT_MSGS
    // only includes the counts of messages successfully delivered. This is not consistent
    // with receive stats but it is what it is. This definition is consistent with the other
    // existing APIs (CCSMP and JCSMP).
    //
    if (statType === StatType.TX_TOTAL_DATA_MSGS) {
      return this._sessionStatistics.getStat(StatType.TX_DIRECT_MSGS) +
        this._sessionStatistics.getStat(StatType.TX_PERSISTENT_MSGS) +
        this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_MSGS);
    } else if (statType === StatType.TX_TOTAL_DATA_BYTES) {
      return this._sessionStatistics.getStat(StatType.TX_DIRECT_BYTES) +
        this._sessionStatistics.getStat(StatType.TX_PERSISTENT_BYTES) +
        this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_BYTES);
    }
    return this._sessionStatistics.getStat(statType);
  };

  /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} The current status of the transport
   */
  SessionFSM.prototype.getTransportInfo = function getTransportInfo () {
    if (Check.nothing(this._transport)) {
      return 'Not connected.';
    }
    return this._transport.getInfoStr();
  };

  /**
   * Handle an AD CTRL message given the message, its header, and the previously-identified
   * candidate flow, which is used if the message has no correlation tag.
   *
   * @param {AdProtocolMessage} message The message to handle
   * @param {SMFHeader} header The header of the message
   * @returns {SessionFSM} This FSM.
   * @private
   */
  SessionFSM.prototype.handleADCtrlMessage = function handleADCtrlMessage (message, header) {
    var flowId = message.getFlowId();
    var respText = header.pm_respstr;
    var correlationTag = header.pm_corrtag;
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;

    if (correlationTag) {
      // Correlation tag is non-null
      // Session handles correlated request-reply
      this.updateRxStats(message);

      /* #stripped LOG_DEBUG(`Handle SMF response for correlationTag ${correlationTag}`) */

      // find matching correlationTag to cancel timer
      var cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
      if (Check.nothing(cancelledRequest)) {
        return this.errorInFsm(("Cannot find matching request for response: " + respText),
                               ErrorSubcode.INTERNAL_ERROR);
      }

      if (cancelledRequest.respRecvdCallback) {
        // call callback referenced by cancelledRequest
        // login or update property
        cancelledRequest.respRecvdCallback(message, cancelledRequest);
        return this;
      }

      /* #stripped LOG_DEBUG(`Dropping ADCTRL message due to mismatched correlation tag ${correlationTag}`) */

      this.incStat(StatType.RX_REPLY_MSG_DISCARD);
      return this;
    }

    // Unsolicited control message
    var flow;
    var msgType = message.msgType;
    var SMFAdProtocolMessageType = SMFLib.SMFAdProtocolMessageType;
    switch (msgType) {
      case SMFAdProtocolMessageType.CLIENTACK:
      case SMFAdProtocolMessageType.CLIENTNACK:
      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
        if (this._defaultPublisher.flowId === flowId) {
          flow = this._defaultPublisher;
        } // else drop.
        break;
      default:
        flow = this._consumers.getFlowById(flowId);
    }

    if (flow && !flow.disposed) {
      // Found a matching flow
      this.updateRxStats(message, flow);
      flow.handleUncorrelatedControlMessage(message);
      return this;
    }

    // No matching flow
    var response = message.getResponse();
    var rc = response ? ("\"" + (response.responseCode) + " " + (response.responseString) + "\" ") : '';
    LOG_WARN(
      ("Dropping ADCTRL." + (SMFLib.SMFAdProtocolMessageType.describe(message.msgType)) + " " + rc + "for unknown flow " + flowId)
    );
    this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);

    return this;
  };

  /**
   * @param {solace.Message} message The AD data message to handle
   * @param {SMFHeader} header The header for the message
   * @returns {MessageConsumer} The flow that handled the message, or `null`
   * @private
   */
  SessionFSM.prototype.handleADTrMessage = function handleADTrMessage (message, header) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var flowId = header.pm_ad_flowid;
    // Get a flow from that ID if possible.
    var flow = this._consumers.getFlowById(flowId);
    if (!flow || flow.disposed) {
      /* #stripped LOG_DEBUG('Dropped incoming AD message for ' +
                `${flow ? 'disposed' : 'unknown'} flow ID ${flowId}`) */

      this.updateRxStats(message, this._sessionStatistics);
      this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
      return null;
    }
    this.updateRxStats(message, flow);
    flow.handleDataMessage(message);
    return flow;
  };

  /**
   * @param {String} correlationTag The correlation tag for the timed out subscription request
   * @param {String} [timeoutMsg] The reason for the timeout
   * @private
   */
  SessionFSM.prototype.handleApiSubscriptionTimeout = function handleApiSubscriptionTimeout (correlationTag, timeoutMsg) {
    // remove request from queue
    if (this._correlatedReqs[correlationTag] === undefined ||
        this._correlatedReqs[correlationTag] === null) {
      return;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    /* #stripped LOG_DEBUG(`${timeoutMsg || 'Subscription timeout'} for correlationTag=${correlationTag}`) */

    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag + ", exception: " + (e.message)));
    }
  };

  /**
   * @param {ClientCtrlMessage} message The message to handle
   * @param {SMFHeader} header The header from the message
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleClientCtrlMessage = function handleClientCtrlMessage (message, header) {
    var correlationTag;
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    this.updateRxStats(message);
    if (message.msgType === SMFLib.SMFClientCtrlMessageType.LOGIN) {
      // Currently, login requests don't use a correlation tag.
      // Using here a fake internal one to match the request.
      correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
      /* #stripped LOG_DEBUG('Handle SMF response for ClientCTRL Login') */

    } else {
      correlationTag = header.pm_corrtag;
      /* #stripped LOG_DEBUG(`Handle SMF response for correlationTag ${correlationTag}`) */

    }
    // find matching correlationTag to cancel timer
    var cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
    if (Check.nothing(cancelledRequest)) {
      var respText = header.pm_respstr;
      return this.errorInFsm(("Cannot find matching request for response: " + respText),
                             ErrorSubcode.INTERNAL_ERROR);
    } else if (cancelledRequest.respRecvdCallback) {
      // call callback referenced by cancelledRequest
      // login or update property
      return cancelledRequest.respRecvdCallback(message);
    }

    /* #stripped LOG_DEBUG(`Dropping ClientCtrl message due to mismatched correlation tag ${correlationTag}`) */

    return this.incStat(StatType.RX_REPLY_MSG_DISCARD);
  };

  /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to handle
   * @private
   */
  SessionFSM.prototype.handleClientCtrlResponse = function handleClientCtrlResponse (clientCtrlMsg) {
    var sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL });
    sEvent.smfMsg = clientCtrlMsg;
    this.processEvent(sEvent);
  };

  /**
   * @private
   */
  SessionFSM.prototype.handleClientCtrlTimeout = function handleClientCtrlTimeout () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('ClientCtrl timeout for session') */

    var sEvent = new SessionFSMEvent({ name: SessionEventName.DOWNGRADE_TIMEOUT });
    this.processEvent(sEvent);
  };


  /**
   * @private
   */
  SessionFSM.prototype.handleConnectTimeout = function handleConnectTimeout () {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    /* #stripped LOG_DEBUG('Connection timeout. Disconnecting') */

    var sEvent = new SessionFSMEvent({ name: SessionEventName.CONNECT_TIMEOUT });
    this.processEvent(sEvent);
  };

  /**
   * Handle control request timeout
   * @param {String} correlationTag The correlation tag for the timed out operation
   * @param {String} timeoutMsg The message associated with the timeout
   * @private
   */
  SessionFSM.prototype.handleUpdatePropertyTimeout = function handleUpdatePropertyTimeout (correlationTag, timeoutMsg) {
    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    // remove request from queue
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag + ", exception: " + (e.message)));
    }

    // notify client
    var sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                            timeoutMsg,
                                            null,
                                            ErrorSubcode.TIMEOUT,
                                            null,
                                            null);
    this.sendEvent(sessionEvent);
  };

  /**
   * @param {SMFHeader} header The header from the rejected message
   * @private
   */
  SessionFSM.prototype.handleRejectedTrMessage = function handleRejectedTrMessage (header) {
    // It is trmsg response. For direct message, it must be a failure response
    var respCode = header.pm_respcode;
    var respText = header.pm_respstr;
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
    this.emitSessionEvent(SessionEvent.build(
      SessionEventCode.REJECTED_MESSAGE_ERROR,
      respText,
      respCode,
      errorSubcode)
    );
  };

  /**
   * @param {solace.Message} message The SMF message to handle
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleSMFMessage = function handleSMFMessage (message) {
    try {
      // Stats for this message might affect both the session and the flow. Need to
      // determine where the message is handled before handling stats.
      // Some ADCTRL messages have no flow ID but only a correlation tag.
      // These are OPENFLOW and we count them as handled by the session.

      var header = message.smfHeader;

      if (header.discardMessage) {
        // UH==2 on an unknown parameter
        if (this._sessionStatistics) {
          this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
        }
        // do nothing.
        return null;
      }

      // Each message type handler must call this.updateRxStats(message, target).
      // The direct/TRmsg path includes the call here in the switch.
      switch (header.smf_protocol) {
        case SMFLib.SMFProtocol.TRMSG:
          if (header.smf_adf) {
            return this.handleADTrMessage(message, header);
          }
          this.updateRxStats(message, this._sessionStatistics);
          return header.pm_respcode === 0
            ? this._session.handleDataMessage(message)
            : this.handleRejectedTrMessage(header);

        case SMFLib.SMFProtocol.ADCTRL:
          return this.handleADCtrlMessage(message, header);

        case SMFLib.SMFProtocol.CLIENTCTRL:
          return this.handleClientCtrlMessage(message, header);

        case SMFLib.SMFProtocol.SMP:
          return this.handleSMPMessage(message, header);

        case SMFLib.SMFProtocol.KEEPALIVE:
        case SMFLib.SMFProtocol.KEEPALIVEV2:
          // do nothing
          return null;

        default:
          return this.handleUnknownProtocolMessage(message, header);
      }
    } catch (e) {
      var ref = this.logger;
      var LOG_ERROR = ref.LOG_ERROR;
      LOG_ERROR(("Exception in handleSMFMessage, exception: " + (e.stack)));
      return this.errorInFsm(("Exception in handleSMFMessage: " + (e.message)),
                             e.subcode || ErrorSubcode.INTERNAL_ERROR,
                             e);
    }
  };

  /**
   * @param {TransportError} transportError The SMF parsing error passed from the transport
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleSMFParseError = function handleSMFParseError (transportError) {
    // fatal connection error

    // notify client
    return this.errorInFsm(transportError,
                           ErrorSubcode.PROTOCOL_ERROR); // TODO: should this be PARSE_FAILURE
  };

  SessionFSM.prototype.handleSMPMessage = function handleSMPMessage (message, header) {
    this.updateRxStats(message);

    // find matching correlationTag to cancel timer
    var cancelledRequest = this.cancelOutstandingCorrelatedReq(header.pm_corrtag || '');
    /*
     * If we find the correlationTag and it has a callback associated with it
     * then call that callback.  It is likely calling back straight to the application
     * due to a call to session.subscribe() or session.unsubscribe() or
     * session.updateProperty().
     * Otherwise just send a TRANSPORT_PROTOCOL_SMP event to the FSM.
     */
    if (Check.nothing(cancelledRequest) || Check.nothing(cancelledRequest.respRecvdCallback)) {
      /*
       * correlation tag not found, probably an error response to a subscription
       * request that did not request-confirm,  or it could be one of the
       * FSM generated subscriptions and the callback is the anonymous function
       * in state WaitingForSubConfirmm
       */
      var sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_PROTOCOL_SMP });
      sEvent.smfMsg = message;
      return this.processEvent(sEvent);
    }

    // calling through the callback, this should  be a callback in the _session for
    // applicated generated subscribe/unsubscribe/updateProperty(clientName)
    return cancelledRequest.respRecvdCallback(message, cancelledRequest);
  };

  /**
   * @param {Number} respCode The router response code
   * @param {String} respText The router response text
   * @param {String} subscriptionStr The subscription cache key
   * @param {CorrelatedRequest} request The associated request
   * @param {Boolean} confirm Whether the user wanted confirmation for the request
   * @private
   */
  SessionFSM.prototype.handleSubscriptionUpdateError = function handleSubscriptionUpdateError (respCode, respText, subscriptionStr, request, confirm) {
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);

    //
    // if it is a not-found or already-present error, it does not affect our subscription
    // cache, otherwise remove it from the cache.
    //
    if (!(errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT ||
      errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND)) {
      // remove from cache
      this.removeFromSubscriptionCache(subscriptionStr);
    }

    //
    // notify the client
    //
    this._session.handleSubscriptionUpdateError(respCode,
                                                respText,
                                                subscriptionStr,
                                                request,
                                                confirm);
  };

  /**
   * @param {String} correlationTag The correlation tag for the timed out request
   * @private
   */
  SessionFSM.prototype.handleSubscriptionTimeout = function handleSubscriptionTimeout (correlationTag) {
    // remove request from queue
    var ref = this.logger;
    var LOG_ERROR = ref.LOG_ERROR;
    try {
      var result = delete this._correlatedReqs[correlationTag];
      if (!result) {
        LOG_ERROR(("Cannot delete ctrl request " + correlationTag));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete ctrl request " + correlationTag), e);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.SUBSCRIBE_TIMEOUT });
    this.processEvent(sEvent);
  };

  /**
   * @param {TransportSessionEvent} transportEvent The event to handle
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleTransportEvent = function handleTransportEvent (transportEvent) {
    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_WARN = ref.LOG_WARN;
    var infoStr = transportEvent.getInfoStr() || '';
    /* #stripped LOG_DEBUG(`Receive transport event: ${transportEvent}`) */


    var sEvent;

    switch (transportEvent.getTransportEventCode()) {
      case TransportLib.TransportSessionEventCode.UP_NOTICE:
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_UP });
        sEvent.sessionId = transportEvent.getSessionId();
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.DESTROYED_NOTICE:
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_DESTROYED });
        sEvent.sessionId = transportEvent.getSessionId();
        sEvent.eventText = infoStr;
        sEvent.errorSubcode = transportEvent.getSubcode();
        sEvent.eventReason = transportEvent;
        this._smfClient = null; // calling reset does nothing useful here
        this._transport = null; // transport has been destroyed
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.CAN_ACCEPT_DATA:
        //
        // unblock the publisher too
        this.GuaranteedFlowControlledRelief();
        sEvent = new SessionFSMEvent({ name: SessionEventName.TRANSPORT_CAN_ACCEPT_DATA });
        sEvent.sessionId = transportEvent.getSessionId();
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.SEND_ERROR:
        sEvent = new SessionFSMEvent({ name: SessionEventName.SEND_ERROR });
        sEvent.sessionId = transportEvent.getSessionId();
        sEvent.eventText = transportEvent.getInfoStr();
        sEvent.errorSubcode = transportEvent.getSubcode();
        sEvent.eventReason = transportEvent;
        this.processEvent(sEvent);
        break;

      case TransportLib.TransportSessionEventCode.DATA_DECODE_ERROR:
      case TransportLib.TransportSessionEventCode.PARSE_FAILURE:
        // fatal connection error
        return this.errorInFsm(transportEvent.getInfoStr(),
                               transportEvent.getSubcode());
      default:
        LOG_WARN('Received unknown transport session event', transportEvent);
    }

    return true;
  };

  /**
   * @param {BaseMessage|Message} message The message to handle
   * @param {SMFHeader} [header] The SMF header from the message, if available
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.handleUnknownProtocolMessage = function handleUnknownProtocolMessage (message, header) {
    var ref = this.logger;
    var LOG_INFO = ref.LOG_INFO;
    var LOG_ERROR = ref.LOG_ERROR;
    // unknown protocol
    this.updateRxStats(message);
    if (header && header.smf_protocol === SMFLib.SMFProtocol.TSESSION) {
      // change state
      LOG_ERROR(("Received transport session message instead of SMF message, protocol 0x" + (formatHexString(header.smf_protocol))));
      LOG_ERROR(("Transport MessageType=" + (message.messageType) + ", target sessionId=" + (formatHexString(message.sessionId))));
      // notify client
      return this.errorInFsm('Received message with unknown protocol',
                             ErrorSubcode.PARSE_FAILURE);
    }

    // Drop message of unknown protocol and increment stats
    if (this._sessionStatistics) {
      this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
    }
    LOG_INFO(("Drop message with unknown protocol 0x" + (formatHexString(header.smf_protocol))));
    return null;
  };


  /**
   * Increments a session statistic
   *
   * @param {StatType} statType The key to increment
   * @param {?Number} value The amount to increment the value by
   * @returns {?Number} The new value for the statistic
   * @private
   */
  SessionFSM.prototype.incStat = function incStat (statType, value) {
    return this._sessionStatistics ? this._sessionStatistics.incStat(statType, value) : undefined;
  };

  /**
   * @private
   */
  SessionFSM.prototype.initTransport = function initTransport () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var host = this._currentHost;
    /* #stripped LOG_DEBUG(`Creating transport session ${host}`) */

    this._kaStats = { lastMsgWritten: 0, lastBytesWritten: 0 };

    this._smfClient = new TransportLib.SMFClient(
      function (rxData) { return this$1.handleSMFMessage(rxData); },
      function (rxError) { return this$1.handleSMFParseError(rxError); },
      this
    );

    this._transport = TransportLib.TransportFactory.createTransport(
      host,
      function (transportEvent) { return this$1.handleTransportEvent(transportEvent); },
      this._smfClient,
      this._sessionProperties.clone(),
      function () { return this$1.sessionIdHex; }
    );
    this.injectTransportInterceptor(this._transportInterceptor);
  };

  /**
   * Installs a transport interceptor for the current and any future transports.
   *
   * The object methods .installed(instance) and .removed(instance) will be called if present, with
   * the transport instance as a parameter.
   *
   * To stop using transport interceptors, supply a null interceptor argument.
   *
   * @param {Object} interceptor An object given access to the internals of the transport instance.
   * @private
   */
  SessionFSM.prototype.injectTransportInterceptor = function injectTransportInterceptor (interceptor) {
    this._transportInterceptor = interceptor;
    if (this._transport) {
      this._transport.setInterceptor(interceptor);
    }
  };

  /**
   * Call from keep alive scheduled task
   * @returns {undefined}
   * @private
   */
  SessionFSM.prototype.keepAliveTimeout = function keepAliveTimeout () {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_INFO = ref.LOG_INFO;
    /* #stripped LOG_TRACE('KeepAlive timeout') */


    // session is in connected state but hasn't received keep alive response
    // Less than or equal to because this is the number of *already sent* KAs
    if (this._keepAliveCounter >= this._sessionProperties.keepAliveIntervalsLimit) {
      LOG_INFO(("Exceed maximum keep alive intervals limit " + (this._sessionProperties.keepAliveIntervalsLimit)));
      // stop timers
      /* #stripped LOG_DEBUG('Stop keep alive timer') */

      if (this._keepAliveTimer) {
        clearInterval(this._keepAliveTimer);
      }

      // change session state
      return this.errorInFsm('Exceed maximum keep alive intervals limit',
                             ErrorSubcode.KEEP_ALIVE_FAILURE);
    }

    /* #stripped LOG_TRACE('About to send keep alive') */


    var clientStats = this._transport.getClientStats();
    var prestatMsgWritten = clientStats.msgWritten;
    var prestatBytesWritten = clientStats.bytesWritten;

    var kaMsg = new SMFLib.KeepAliveMessage();
    var returnCode = this.send(kaMsg, null, true);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      /*
       * TransportReturnCode.NO_SPACE is not possible.
       * Send is called with the forceAllowEnqueue parameter.
       * So whatever error is returned is fatal
       */
      return this.errorInFsm('Cannot send keep alive message',
                             ErrorSubcode.KEEP_ALIVE_FAILURE);
    }

    // We need to avoid incrementing the KA counter if we're in the process of
    // sending a huge message and we've had no opportunity to write a KA message.
    // Detection: last KA's snapshot of messages written is unchanged, but number of bytes
    // written has gone up.
    if (this._kaStats.lastMsgWritten === prestatMsgWritten &&
      this._kaStats.lastBytesWritten < prestatBytesWritten) {
      /* #stripped LOG_DEBUG('Keep alive sent',
                'Not incrementing keep alive counter due to large message send',
                `KA count = ${this._keepAliveCounter}`
      ) */

    } else {
      this._keepAliveCounter++;
      /* #stripped LOG_TRACE(`Last message written: ${this._kaStats.lastMsgWritten}`) */

      /* #stripped LOG_TRACE(`Last bytes written: ${this._kaStats.lastBytesWritten}`) */

      /* #stripped LOG_TRACE(`Keep alive sent, increment keep alive counter, keep alive count = ${
        this._keepAliveCounter}`) */

    }
    this._kaStats.lastBytesWritten = clientStats.bytesWritten;
    this._kaStats.lastMsgWritten = clientStats.msgWritten;

    return true;
  };

  /**
   * Prepares a message for sending and then invoke the transport
   * send method. For guaranteed messages, pass the transport send
   * method to the publisher so it can be invoked from there and errors
   * handled within the publisher FSM.
   * @param {BaseMessage} message The message to prepare.
   * @private
   */
  SessionFSM.prototype.prepareAndSendMessage = function prepareAndSendMessage (message) {
    if (message instanceof Message) {
      var returnCode;
      // Delegate message preparation where appropriate
      var deliveryMode = message.getDeliveryMode();
      switch (deliveryMode) {

        case MessageDeliveryModeType.DIRECT:
          if (!this._transport) { return; }
          returnCode = this.sendToTransport(message);
          break;

        case MessageDeliveryModeType.PERSISTENT:
        case MessageDeliveryModeType.NON_PERSISTENT:
          if (!this._defaultPublisher) {
            var reason = this._session.adLocallyDisabled
                ? 'locally disabled'
                : 'remotely unsupported';
            throw new OperationError('Session does not provide Guaranteed Message Publish capability',
                                       ErrorSubcode.GM_UNAVAILABLE,
                                       reason);
          } else {
            if (this._gmSendDisallowed) { this._gmSendDisallowed(); } // throws if present
            returnCode = this._defaultPublisher.prepareAdMessageAndSend(message);
          }
          break;

        default: {
          var ref = this.logger;
          var LOG_ERROR = ref.LOG_ERROR;
          LOG_ERROR('Unhandled message delivery mode', MessageDeliveryModeType.describe(deliveryMode));
        }
      }

      if (returnCode !== TransportLib.TransportReturnCode.OK) {
        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
          // Must be DIRECT message because the Publisher handles NO_SPACE returnCode
          // internally
          throw new OperationError('Cannot send message - no space in transport',
            ErrorSubcode.INSUFFICIENT_SPACE,
            TransportLib.TransportReturnCode.describe(returnCode));
        }

        // This is a fatal session error
        this.setCurrentError(new OperationError('Cannot send message',
            ErrorSubcode.INVALID_OPERATION,
            TransportLib.TransportReturnCode.describe(returnCode)));
        this.processEvent(new SessionFSMEvent({ name: SessionEventName.EXCEPTION }));
      }
    }
  };

  SessionFSM.prototype.GuaranteedFlowControlledRelief = function GuaranteedFlowControlledRelief () {
    if (this._defaultPublisher) {
      this._defaultPublisher.processFSMEvent(
        new PublisherLib.PublisherFSMEvent({
          name: PublisherLib.PublisherFSMEventNames.CAN_SEND }));
    }
  };
  /**
   * Reapply subscriptions.
   * @returns {Boolean} True if all subscriptions were reapplied. False if WOULD_BLOCK.
   * @private
   */
  SessionFSM.prototype.reapplySubscriptions = function reapplySubscriptions () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var createTopicDestination = SolclientFactoryLib.SolclientFactory.createTopicDestination;
    /* #stripped LOG_DEBUG(`Reapplying subscriptions, count=${this._subscriptionCacheKeys.length}`) */

    // add subscriptions and ask for confirm on last one

    if (!this._subscriptionCacheKeys) {
      // Nothing to do
      return true;
    }

    try {
      while (this._subscriptionCacheKeys.length) {
        //
        // The key is the the topic string (topic.getName()).
        // sendSubscribe() requires a destination, so we encode it here.
        //
        // on entry to reapplySubscriptions we added the P2P topic to
        // subscriptionCacheKeys but there is no corresponding entry in
        // _subscriptionCache so we no longer use the key to index that actual
        // cache.
        // If it becomes necesary to pass the Topic object to sendSubscribe in a
        // a future enhancement (perhaps to remember flags like request-confirm) then
        // this logic here needs to be revisisted.
        var key = this$1._subscriptionCacheKeys.shift();
        var requestConfirmation = this$1._subscriptionCacheKeys.length === 0;
        var topicDestination = createTopicDestination(key);
        var rc = this$1.sendSubscribe(topicDestination,
                                      requestConfirmation,
                                      null,
                                      this$1._sessionProperties.readTimeoutInMsecs,
                                      null);
        if (rc !== TransportLib.TransportReturnCode.OK) {
          this$1.errorInFsm(
            ("Error occurred sending subscription: " + (TransportLib.TransportReturnCode.describe(rc))),
            ErrorSubcode.INTERNAL_ERROR  // TODO: better subcode
          );
        }
      }
    } catch (e) {
      if (e instanceof OperationError && e.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
        /* #stripped LOG_DEBUG('Apply subscriptions blocked due to insufficient space, wait for can accept data event') */

        return false;
      }
      this.errorInFsm(("Unexpected expection occurred while reapplying subscriptions: " + e),
                      e.subcode || ErrorSubcode.INTERNAL_ERROR,
                      e);
    }
    return true;    // sent all subscriptions
  };


  /**
   * @param {Destination} topic The topic to remove from the subscription cache
   * @returns {?Destination} The value in the subscription cache at that key
   * @private
   */
  SessionFSM.prototype.removeFromSubscriptionCache = function removeFromSubscriptionCache (topic) {
    if (Check.nothing(topic) || !this._subscriptionCache) {
      return null;
    }

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    var key = (topic instanceof Destination) ? topic.name : topic;
    /* #stripped LOG_DEBUG(`Remove subscription ${key}`) */

    var sub = this._subscriptionCache[key];
    if (sub === undefined || sub === null) {
      return null;
    }

    try {
      var result = delete this._subscriptionCache[key];
      if (!result) {
        LOG_ERROR(("Cannot remove subscription " + key));
      } else {
        this._subscriptionCacheCount--;
      }
    } catch (e) {
      LOG_ERROR(("Cannot remove subscription " + key), e);
    }
    return sub;
  };


  /**
   * Reset the FSM state and release all objects. This method is called once from
   * SessionFSM.onInitial
   * @private
   */
  SessionFSM.prototype.reset = function reset () {
    this.resetStats();

    /**
     * The following fields are disposed when disconnect is called
     * and recreated when connect is called again.
     */
    this.sessionId = null;

    // Need to reschedule keepAliveTimer when some other write operation happens
    this._keepAliveTimer = null;
    this.resetKeepAliveCounter();
    this._correlatedReqs = {};

    this._disposed = false;

    this._smfClient = null;
    this._kaStats = { lastMsgWritten: 0, lastBytesWritten: 0 };

    /**
     * The following fields are destroyed when dispose is called
     * and cannot be reinitialized.
     */
    this._subscriptionCache = null;
    this._subscriptionCacheKeys = null;
    this._subscriptionCacheCount = 0;
    if (this._sessionProperties.reapplySubscriptions) {
      this._subscriptionCache = {};
    }

    // When negotiating the initial transport, we can fail and transparently reconnect.
    // this.resetTransportProtocolHandler();
    // this._lastKnownGoodTransport = null;

    // event and error information
    this._eventCode = null;
    this._responseCode = null;
    this.eventText = null;
    this.errorSubcode = null;
    this.eventReason = null;
  };

  /**
   * @private
   */
  SessionFSM.prototype.resetKeepAliveCounter = function resetKeepAliveCounter () {
    // Reset the KA counter. Called by the SMFClient on each SMF chunk received (whether full
    // message or not).
    this._keepAliveCounter = 0;
  };

  /**
   * @returns {?} The result of calling resetStats().
   * @private
   */
  SessionFSM.prototype.resetStats = function resetStats () {
    return this._sessionStatistics ? this._sessionStatistics.resetStats() : undefined;
  };


  /**
   * Schedule keep alive task
   * @private
   */
  SessionFSM.prototype.scheduleKeepAlive = function scheduleKeepAlive () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    var LOG_ERROR = ref.LOG_ERROR;
    var ref$1 = this._sessionProperties;
    var keepAliveIntervalInMsecs = ref$1.keepAliveIntervalInMsecs;
    if (keepAliveIntervalInMsecs === 0) {
      // Keepalives disabled
      return;
    }

    if (this._keepAliveTimer) {
      clearInterval(this._keepAliveTimer);
    }

    this._keepAliveTimer = setInterval(function () {
      try {
        this$1.keepAliveTimeout();
      } catch (e) {
        LOG_ERROR('Error occurred in keepAliveTimeout', e);
      }
    }, keepAliveIntervalInMsecs);

    /* #stripped LOG_DEBUG(`Create Keepalive timer ${this._keepAliveTimer}`) */

  };

  /**
   * Provide a method for the session object to use to send
   * messages to the transport.  This method is only used internally by
   * the FSM.  The session send() API should invoke sendToTransport() directly
   * so errors are thrown back to the application.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.send = function send (message, statTarget, forceAllowEnqueue) {
    if ( statTarget === void 0 ) statTarget = this._sessionStatistics;
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    try {
      return this.sendToTransport(message, statTarget, forceAllowEnqueue);
    } catch (ex) {
      var ref = this.logger;
      var LOG_TRACE = ref.LOG_TRACE;
      // The send operation threw (or we threw locally), which is always a SessionException.
      /* #stripped LOG_TRACE(`Error sending message: ${ex.message}: ${ex.stack}`) */

      this.errorInFsm(("Send operation failed: " + (ex.message)),
                      ex.subcode || ErrorSubcode.CONNECTION_ERROR);
    }
    return TransportLib.TransportReturnCode.CONNECTION_ERROR;
  };

  /**
   * Provide a method for the session object to use to send
   * messages to the transport.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendToTransport = function sendToTransport (message, statTarget, forceAllowEnqueue) {
    if ( statTarget === void 0 ) statTarget = this._sessionStatistics;
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var returnCode = TransportLib.TransportReturnCode.CONNECTION_ERROR;

    if (!this._transport) {
      throw new OperationError('Transport has been destroyed', ErrorSubcode.INTERNAL_ERROR);
    }
    var content = SMFLib.Codec.Encode.encodeCompoundMessage(message);
    returnCode = this._transport.send(content, forceAllowEnqueue);
    switch (returnCode) {
      case TransportLib.TransportReturnCode.OK:
        this.updateTxStats(message, statTarget);
        break;
      case TransportLib.TransportReturnCode.NO_SPACE:
        if (!forceAllowEnqueue) {
          // This is allowed.
          break;
        }
      // Else fall through
      default:
        throw new OperationError(("Transport returned " + (TransportLib.TransportReturnCode.describe(returnCode))),
          ErrorSubcode.INTERNAL_ERROR);
    }

    return returnCode;
  };


  /**
   * Initiates the ClientCtrl handshake, called from transportSessionEvent callback
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendClientCtrlLogin = function sendClientCtrlLogin () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;

    // Don't use the correlation tag. For Login only, the router won't return it.
    var clientCtrlMsg = SMFLib.ClientCtrlMessage.getLogin(this._sessionProperties);
    var returnCode = this.send(clientCtrlMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      this._responseCode = null;
      this.eventReason = null;
      // notify client
      if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
        this.eventText = 'Cannot send client control - no space in transport';
        this.errorSubcode = ErrorSubcode.INSUFFICIENT_SPACE;
      } else {
        /* #stripped LOG_DEBUG(`Cannot send client ctrl, return code ${TransportLib.TransportReturnCode.describe(returnCode)}`) */

        this.eventText = 'Cannot send client ctrl';
        this.errorSubcode = ErrorSubcode.INVALID_OPERATION;
      }
    } else {
      // enqueue outstanding request, use a fake correlation tag for Login only
      var correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
      /* #stripped LOG_DEBUG(`Using internally correlationTag=${correlationTag} for tracking ClientCTRL Login`) */

      this.enqueueOutstandingCorrelatedReq(correlationTag,
                                           null,
                                           null,
                                           null,
                                           function (rxMsgObj) { return this$1.handleClientCtrlResponse(rxMsgObj); });

      /* #stripped LOG_DEBUG('Sent client ctrl') */

    }
    return returnCode;
  };

  /**
   *
   * Internal method for sending subscriptions from SessionConnecting state (reapply or P2P-inbox)
   *
   * @param {Destination} topic The topic to subscribe
   * @param {Boolean} requestConfirmation If true, expect a reply on success also
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on reply received
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendSubscribe = function sendSubscribe (topic, requestConfirmation, correlationKey, requestTimeout, respRecvdCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_DEBUG = ref.LOG_DEBUG;
    assert(topic instanceof Destination, 'sendSubscribe requires a Destination, not a string');
    /* #stripped LOG_DEBUG('Sending subscribe: ', topic, requestConfirmation, correlationKey) */

    var correlationTag = this.getCorrelationTag();
    var smpMsg = SMFLib.SMPMessage.getSubscriptionMessage(correlationTag,
                                                            topic,
                                                            true, // set add == true
                                                            requestConfirmation);
    assert(smpMsg.encodedUtf8Subscription, 'Encoded SMP message was invalid');
    var returnCode = this.send(smpMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      /* #stripped LOG_DEBUG('Subscribe failed', TransportLib.TransportReturnCode.describe(returnCode)) */

      return returnCode;
    }
    if (requestConfirmation) {
      this.enqueueOutstandingCorrelatedReq(
        correlationTag,
        function () { return this$1.handleSubscriptionTimeout(correlationTag); },
        requestTimeout || this._sessionProperties.readTimeoutInMsecs,
        correlationKey,
        respRecvdCallback);
    }
    return returnCode;
  };

  /**
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to change
   * @param {?} newValue The new value for the property
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.sendUpdateProperty = function sendUpdateProperty (mutableSessionProperty,
                     newValue,
                     correlationKey,
                     requestTimeout,
                     respRecvdCallback) {
    var this$1 = this;

    var correlationTag = this._smfClient.nextCorrelationTag();
    var smpMsg = SMFLib.ClientCtrlMessage.getUpdate(mutableSessionProperty,
                                                      newValue,
                                                      correlationTag);

    var returnCode = this.send(smpMsg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      return returnCode;
    }

    this.enqueueOutstandingCorrelatedReq(
      correlationTag,
      function () { return this$1.handleUpdatePropertyTimeout(correlationTag); },
      requestTimeout || this._sessionProperties.readTimeoutInMsecs,
      correlationKey,
      respRecvdCallback);
    return returnCode;
  };

  /**
   * @private
   */
  SessionFSM.prototype.setClientCtrlTimer = function setClientCtrlTimer () {
    var this$1 = this;

    this.clearClientCtrlTimer();

    this._clientCtrlTimer = setTimeout(function () { return this$1.handleClientCtrlTimeout(); },
                                       this._sessionProperties.transportDowngradeTimeoutInMsecs);
  };

  /**
   * @private
   */
  SessionFSM.prototype.setConnectTimer = function setConnectTimer () {
    var this$1 = this;

    this.clearConnectTimer();
    // The hosts lists provides the wait time for inter-host timeouts.
    // This timeout is for the entire list.
    // TODO: connectTimeoutInMsecs was specifically described as the timeout for "a given host",
    // with a timeout of 8 seconds, which appears inappropriate given its use here.
    this._connectTimer = setTimeout(function () { return this$1.handleConnectTimeout(); },
                                    this._sessionProperties.connectTimeoutInMsecs);
  };

  /**
   * Sets the error exit information for the FSM.
   *
   * This applies key-value pairs from properties to the current error object,
   * but does not allow overwriting and does not allow assignment of null or undefined values.
   *
   * Only the following fields are relevant, any other fields transferred to currentError by this
   * method are eventually ignored:
   *    * eventText
   *    * responseCode
   *    * errorSubcode
   *    * eventReason
   *
   * See SessionConnecting exitPoint 'errorExit'. This is the only place the information in
   * currentError is extracted.
   *
   * Could be implemented as `
   * this._currentError = Object.assign({}, filter(properties), this._currentError)
   * `
   * where `filter` is a key-value filter that works as described above.
   *
   * @param {Object} source An object with properties to be applied
   */
  SessionFSM.prototype.setCurrentError = function setCurrentError (source) {
    var target = this._currentError || {};
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    Object.keys(source).forEach(function (key) {
      if (source[key] === null || source[key] === undefined) { return false; }
      if (target[key] !== null && target[key] !== undefined) {
        /* #stripped LOG_TRACE(`Attempt to overwrite property {key=${key}, current value=${target[key]}, incoming value=${source[key]}}`) */

        return false;
      }
      target[key] = source[key];
      return true;
    });
    this._currentError = target;
  };


  /**
   * Send a subscribe or unsubscribe request on behalf of the API.
   * @param {Destination} subject The target for the update
   * @param {Boolean} requestConfirmation Request a success message if true
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout in milliseconds
   * @param {SessionRequestType} requestType The request type
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
  SessionFSM.prototype.subscriptionUpdate = function subscriptionUpdate (subject,
                     requestConfirmation,
                     correlationKey,
                     requestTimeout,
                     requestType,
                     respRecvdCallback) {
    var this$1 = this;

    var timeoutMsg =
      SubscriptionUpdateTimeoutMessages[requestType] ||
      SubscriptionUpdateTimeoutMessages.default;
    var isSMP = (requestType !== SessionRequestType.REMOVE_DTE_SUBSCRIPTION);
    var add = (requestType === SessionRequestType.ADD_SUBSCRIPTION ||
      requestType === SessionRequestType.ADD_P2PINBOX);
    var correlationTag = this.getCorrelationTag();

    var generateMessage = isSMP
      ? SMFLib.SMPMessage.getSubscriptionMessage
      : SMFLib.AdProtocolMessage.getDTEUnsubscribeMessage;
    var msg = generateMessage(correlationTag,
                                subject,
                                add,
                                requestConfirmation);
    var returnCode = this.send(msg);
    if (returnCode !== TransportLib.TransportReturnCode.OK) {
      return returnCode;
    }

    if (requestConfirmation) {
      this.enqueueOutstandingCorrelatedReq(
        correlationTag,
        function () { return this$1.handleApiSubscriptionTimeout(correlationTag,
                                                timeoutMsg); },
        requestTimeout || this._sessionProperties.readTimeoutInMsecs,
        correlationKey,
        respRecvdCallback);
    }
    if (requestType === SessionRequestType.ADD_SUBSCRIPTION &&
      this._sessionProperties.reapplySubscriptions) {
      this.addToSubscriptionCache(subject);
    } else if (requestType === SessionRequestType.REMOVE_SUBSCRIPTION &&
      this._sessionProperties.reapplySubscriptions) {
      this.removeFromSubscriptionCache(subject);
    }
    return returnCode;
  };

  /**
   * @param {BaseMessage|Message} smfMessage The message received
   * @param {Stats} [target] The statistics target to update, default is session stats
   * @private
   */
  SessionFSM.prototype.updateRxStats = function updateRxStats (smfMessage, target) {
    if ( target === void 0 ) target = this._sessionStatistics;

    if (!target) {
      return;
    }
    var smfHeader = smfMessage.smfHeader;
    if (!smfHeader) {
      return;
    }
    var deliveryMode = smfHeader.pm_deliverymode || 0;
    var msgStatKey = STAT_RX_BYMODE_MSGS[deliveryMode];
    var bytesStatKey = STAT_RX_BYMODE_BYTES[deliveryMode];
    var msgLength = smfHeader.messageLength;

    switch (smfHeader.smf_protocol) {
      case SMFLib.SMFProtocol.TRMSG:
        if (smfHeader.pm_respcode === 0) {
          target.incStat(StatType.RX_TOTAL_DATA_MSGS);
          target.incStat(msgStatKey);
          target.incStat(StatType.RX_TOTAL_DATA_BYTES, msgLength);
          target.incStat(bytesStatKey, msgLength);
          if (smfHeader.smf_di) {
            target.incStat(StatType.RX_DISCARD_MSG_INDICATION);
          }
        }
        break;
      case SMFLib.SMFProtocol.CLIENTCTRL:
      case SMFLib.SMFProtocol.SMP:
      case SMFLib.SMFProtocol.KEEPALIVE:
      case SMFLib.SMFProtocol.KEEPALIVEV2:
      case SMFLib.SMFProtocol.ADCTRL:
        target.incStat(StatType.RX_CONTROL_MSGS);
        target.incStat(StatType.RX_CONTROL_BYTES, msgLength);
        break;
      default:
    }
  };

  /**
  * @param {BaseMessage|Message} smfMessage The message sent
  * @param {Stats} [target] The statistics target to update, default is session stats
  * @private
  */
  SessionFSM.prototype.updateTxStats = function updateTxStats (smfMessage, target) {
    if ( target === void 0 ) target = this._sessionStatistics;

    if (!target) {
      return;
    }
    if (smfMessage.getReplyTo !== undefined && smfMessage.getReplyTo()) {
      // update stats
      target.incStat(StatType.TX_REQUEST_SENT);
    }
// TODOD:  Why do we have to get SmfHeader? Can't we can smfMessage.getDeliveryMode();
    var smfHeader = smfMessage.smfHeader;
    if (!smfHeader) {
      return;
    }

    var deliveryMode = smfHeader.pm_deliverymode || 0;
    var msgStatKey = STAT_TX_BYMODE_MSGS[deliveryMode];
    var bytesStatKey = STAT_TX_BYMODE_BYTES[deliveryMode];
    //
    // If this is a Guaranteed Message we may need to further refine the stats by the redelivered
    // status
    if (deliveryMode !== MessageDeliveryModeType.DIRECT) {
      if (smfMessage.isRedelivered()) {
        msgStatKey = STAT_TX_BYMODE_REDELIVERED[deliveryMode];
        bytesStatKey = STAT_TX_BYMODE_BYTES_REDELIVERED[deliveryMode];
      }
    }
    var msgLength = smfHeader.messageLength;

    switch (smfHeader.smf_protocol) {
      case SMFLib.SMFProtocol.TRMSG:
        target.incStat(msgStatKey);
        target.incStat(bytesStatKey, msgLength);
        break;
      case SMFLib.SMFProtocol.CLIENTCTRL:
      case SMFLib.SMFProtocol.SMP:
      case SMFLib.SMFProtocol.KEEPALIVE:
      case SMFLib.SMFProtocol.KEEPALIVEV2:
      case SMFLib.SMFProtocol.ADCTRL:
        target.incStat(StatType.TX_CONTROL_MSGS);
        target.incStat(StatType.TX_CONTROL_BYTES, msgLength);
        break;
      default:
    }
  };

  /**
   * @param {ClientCtrlMessage} clientCtrlRespMsg The client control message with props
   * @private
   */
  SessionFSM.prototype.updateReadonlySessionProps = function updateReadonlySessionProps (clientCtrlRespMsg) {
    var props = this._sessionProperties; // Modify session properties in place

    props._setVpnNameInUse(clientCtrlRespMsg.getVpnNameInUseValue() || '');
    var oldVirtualRouterName = props.virtualRouterName;
    var newVirtualRouterName = clientCtrlRespMsg.getVridInUseValue() || '';
    props._setVirtualRouterName(newVirtualRouterName);
    if (oldVirtualRouterName !== '' && oldVirtualRouterName !== newVirtualRouterName) {
      this.handleVirtualRouterNameChange(oldVirtualRouterName, newVirtualRouterName);
    }

    // The Solace Message Router login response should always contain a P2P topic for this client
    // name. If it doesn't that's an error (and we store "").
    props._setP2pInboxBase(clientCtrlRespMsg.getP2PTopicValue() || '');
    props._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(props.p2pInboxBase));
    this._session.updateCapabilities(clientCtrlRespMsg.getRouterCapabilities());

    // Create and cache a guard for GM sending.
    var gmCap = this._session._getCapability(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
    this._gmSendDisallowed = (typeof gmCap === 'boolean' && !gmCap)
      ? function () {
        throw new OperationError(
        'Sending guaranteed message is not allowed by router for this client',
        ErrorSubcode.INVALID_OPERATION,
        null);
      }
      : null;
  };

  SessionFSM.prototype.handleVirtualRouterNameChange = function handleVirtualRouterNameChange (oldName, newName) {
    if (this._consumers) {
      this._consumers.flows.forEach(function (consumer) { return consumer.onVRNChanged(); });
    }
    this.emitSessionEvent(
      SessionEvent.build(SessionEventCode.VIRTUALROUTER_NAME_CHANGED,
                         ("Virtual router name is changed from " + oldName + " to " + newName),
                         null,
                         0,
                         null,
                         null));
  };

  /**
   * @returns {String} The session's ID in hexadecimal format
   * @private
   */
  prototypeAccessors.sessionIdHex.get = function () {
    return this.sessionId && formatHexString(this.sessionId) || 'N/A';
  };

  Object.defineProperties( SessionFSM.prototype, prototypeAccessors );

  return SessionFSM;
}(StateMachine));

module.exports.SessionFSM = SessionFSM;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var SessionOperation = {
  CONNECT:         'CONNECT',
  DISCONNECT:      'DISCONNECT',
  CTRL:            'CTRL',
  SEND:            'SEND',
  QUERY_OPERATION: 'QUERY_OPERATION',
};

module.exports.SessionOperation = Enum.new(SessionOperation);


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var PublisherLib = __webpack_require__(29);
var SessionPropertiesLib = __webpack_require__(74);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(4);
var APIPropertiesValidators = ref.APIPropertiesValidators;
var parseURL = ref.parseURL;
var ref$1 = __webpack_require__(71);
var AuthenticationScheme = ref$1.AuthenticationScheme;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(2);
var ErrorSubcode = ref$3.ErrorSubcode;
var OperationError = ref$3.OperationError;
var ref$4 = __webpack_require__(1);
var LOG_WARN = ref$4.LOG_WARN;
var ref$5 = __webpack_require__(23);
var TransportProtocol = ref$5.TransportProtocol;

var validateInstance = APIPropertiesValidators.validateInstance;
var valArrayIsMember = APIPropertiesValidators.valArrayIsMember;
var valArrayOfString = APIPropertiesValidators.valArrayOfString;
var valBoolean = APIPropertiesValidators.valBoolean;
var valLength = APIPropertiesValidators.valLength;
var valNotEmpty = APIPropertiesValidators.valNotEmpty;
var valNumber = APIPropertiesValidators.valNumber;
var valRange = APIPropertiesValidators.valRange;
var valString = APIPropertiesValidators.valString;
var valStringOrArray = APIPropertiesValidators.valStringOrArray;

var ALLOWED_PROTOCOLS = ['http:', 'https:', 'ws:', 'wss:', 'tcp:', 'tcps:'];

function valClientName(typeDesc, instance, name) {
  // valString and valLength(160) have already been called.
  var error =
    SMFLib.ClientCtrlMessage.validateClientName(
      instance[name],
      function (errorMessage) { return new OperationError((typeDesc + " validation: Property '" + name + "': " + errorMessage),
                           ErrorSubcode.PARAMETER_OUT_OF_RANGE); });
  if (error) {
    throw error;
  }
}

function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
  var val = instance[key];
  if (allowNull && val === null) { return; }
  if (typeof (val) !== 'undefined' && !enumInstance.values.some(function (v) { return v === val; })) {
    throw new OperationError((typeDesc + " validation: Property '" + key + "' must be a member of " + enumName),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
}

function valSslExcludedProtocols(typeDesc, instance, name) {
  var val = instance[name];
  if (Check.array(val)) {
    if (val.length > 0) {
      var supported = SessionPropertiesLib.SessionProperties.SUPPORTED_SSL_PROTOCOLS;
      val.forEach(function (protocol) {
        var prtcl = protocol.toLowerCase();
        if (supported.indexOf(prtcl) < 0) {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' contains unsupported protocol: " + protocol),
                                    ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      });
    }
  }
}

function valSslCipherSuites(typeDesc, instance, name) {
  var val = instance[name];
  if (val && Check.string(val) && !Check.empty(val)) {
    var ciphers = val.split(',');
    var supported = SessionPropertiesLib.SessionProperties.SUPPORTED_CIPHER_SUITES;
    ciphers.forEach(function (cipher) {
      if (supported.indexOf(cipher.trim()) < 0) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' contains unsupported cipher suite: '" + cipher + "'"),
                        ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
    });
  }
}

// maximum number of common names is 16
function valSslTrustedCommonNameList(typeDesc, instance, name) {
  var val = instance[name];
  if (Check.something(val) && Check.array(val) && val.length > 16) {
    throw new OperationError((typeDesc + " validation: Property '" + name + "' length exceeds limit of 16"),
                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
}

function valUrlList(typeDesc, instance, name) {
  var val = instance[name];
  var valArray = typeof val === 'string' ? val.split(',') : val;
  if (!Check.array(valArray)) {
    throw new OperationError((typeDesc + " validation: Property '" + name + "' not an array or comma-delimited string"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  valArray.forEach(function (el) {
    var url = null;
    try {
      url = parseURL(el);
    } catch (ex) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' contained an invalid URL: " + el),
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    if (!Check.included(url.protocol, ALLOWED_PROTOCOLS)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' contained a URL'" + (url.href) + "' with an invalid protocol: '" + (url.protocol) + "'"),
                                ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  });
}

function isHttpTransport(transportProtocol) {
  return (transportProtocol && (
          transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING ||
          transportProtocol === TransportProtocol.HTTP_BINARY ||
          transportProtocol === TransportProtocol.HTTP_BASE64));
}

function validatePropsSupportedByTransport(transportProtocol, nonHttpPropsSet) {
  if (nonHttpPropsSet.length > 0 && isHttpTransport(transportProtocol)) {
    var propNames = nonHttpPropsSet.length <= 5 ? nonHttpPropsSet : nonHttpPropsSet.slice(0, 5);
    throw new OperationError(("SessionProperties validation: properties that are not supported by transport protocol " + transportProtocol + " have been set: " + propNames), ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
}

function useSsl(instance, name) {
  var val = instance[name];
  if (val instanceof Array) {
    // host list is used, iterate to find at least one entry
    var arrayLength = val.length;
    for (var i = 0; i < arrayLength; i++) {
      var currententry = val[i];
      if (Check.string(currententry) && currententry.match(/^(https|wss|tcps):/i)) {
        return true;
      }
    }
    return false;
  }
  return (Check.string(val) && val.match(/^(https|wss|tcps):/i));
}

var SessionPropertiesValidator = {
  validate: function validate(props) {
    // Validation rules: same as JCSMP
    var v = validateInstance.bind(null, 'SessionProperties', props);
    v('url', [valNotEmpty], [valStringOrArray], [valUrlList]);
    v('userName', [valString], [valLength, 189]);
    v('password', [valString], [valLength, 128]);
    v('clientName', [valString], [valLength, 160], [valClientName]);
    v('applicationDescription', [valString], [valLength, 254]);
    v('vpnName', [valString], [valLength, 32]);
    v('connectTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('connectRetriesPerHost', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('connectRetries', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('reconnectRetries', [valNumber], [valRange, -1, Number.MAX_VALUE]);
    v('reconnectRetryWaitInMsecs', [valNumber], [valRange, 0, 60000]);
    v('readTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('sendBufferMaxSize', [valNumber], [valRange, 1, Number.MAX_VALUE]);
    v('maxWebPayload', [valNumber], [valRange, 100, Number.MAX_VALUE]);
    if (false) {
      v('bufferedAmountQueryIntervalInMsecs', [valNumber], [valRange, 4, Number.MAX_VALUE]);
    }
    v('generateSendTimestamps', [valBoolean]);
    v('generateReceiveTimestamps', [valBoolean]);
    v('includeSenderId', [valBoolean]);
    v('keepAliveIntervalInMsecs', [valNumber], [valRange, 0, Number.MAX_VALUE]);
    v('keepAliveIntervalsLimit', [valNumber], [valRange, 3, Number.MAX_VALUE]);
    v('generateSequenceNumber', [valBoolean]);
    v('subscriberLocalPriority', [valNumber], [valRange, 1, 4]);
    v('subscriberNetworkPriority', [valNumber], [valRange, 1, 4]);
    v('ignoreDuplicateSubscriptionError', [valBoolean]);
    v('ignoreSubscriptionNotFoundError', [valBoolean]);
    v('reapplySubscriptions', [valBoolean]);
    v('noLocal', [valBoolean]);
    v('transportDowngradeTimeoutInMsecs', [valNumber], [valRange, 1, Number.MAX_VALUE]);

    if (props.transportProtocol && props.webTransportProtocolList) {
      throw new OperationError("SessionProperties validation: Property 'transportProtocol' and " +
                               "'webTransportProtocolList' cannot be set at the same time",
                               ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    if (props.webTransportProtocolList !== null && props.webTransportProtocolList !== undefined) {
      if (!Array.isArray(props.webTransportProtocolList)) {
        throw new OperationError("Property 'webTransportProtocolList' must be an array if set",
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (props.webTransportProtocolList.length === 0) {
        throw new OperationError("Property 'webTransportProtocolList' must be non-empty if set",
                                 ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
    }

    v('authenticationScheme', [valIsMember, AuthenticationScheme, 'AuthenticationScheme', false]);
    var useClientCert = props.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
    if (!useSsl(props, 'url') && useClientCert) {
      throw new OperationError("SessionProperties validation: Property 'authenticationScheme' cannot be set to client certificate " +
                               'for unsecured sessions', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }

    if (true) {
      // should not happen since transportProtocol and webTransportProtocolList are not public
      if (Check.something(props.transportProtocol) &&
          props.transportProtocol !== TransportProtocol.WS_BINARY) {
        throw new OperationError("SessionProperties validation: properties 'transportProtocol' " +
                                 'can only be WS_BINARY',
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (Check.something(props.webTransportProtocolList)) {
        if (!Check.array(props.webTransportProtocolList)) {
          throw new OperationError('SessionProperties validation: Property ' +
                                   "'webTransportProtocolList' should be type Array",
                                   ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
        if (props.webTransportProtocolList.length !== 1 ||
            props.webTransportProtocolList[0] !== TransportProtocol.WS_BINARY) {
          throw new OperationError('SessionProperties validation: properties ' +
                                   "'webTransportProtocolList' can only contain element WS_BINARY",
                                   ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
      }

      v('sslExcludedProtocols', [valArrayOfString], [valSslExcludedProtocols]);
      v('sslCipherSuites', [valString], [valSslCipherSuites]);
      v('sslValidateCertificate', [valBoolean]);

      if (props.sslValidateCertificate || useClientCert) {
        v('sslTrustStores', [valArrayOfString]);
        v('sslTrustedCommonNameList', [valArrayOfString], [valSslTrustedCommonNameList]);
      }

      if (useClientCert) {
        v('sslPfx', [valString]);
        v('sslPfxPassword', [valString]);
        v('sslPrivateKey', [valString]);
        v('sslPrivateKeyPassword', [valString]);
        v('sslCertificate', [valString]);
        // either sslPfx or sslPrivateKey and sslCertificate must be specified,
        // but not at the same time
        var sslPfxSet = Check.something(props.sslPfx) && props.sslPfx.length;
        var sslPrivateKeySet = (
          Check.something(props.sslPrivateKey) &&
          props.sslPrivateKey.length
        );
        var sslCertSet = (
          Check.something(props.sslCertificate) &&
          props.sslCertificate.length
        );
        if (!sslPfxSet && !sslPrivateKeySet && !sslCertSet) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Either property 'sslPfx', or 'sslPrivateKey' and 'sslCertificate' " +
                                   'must be set when authenticationScheme is client certificate',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
        if (sslPfxSet && (sslPrivateKeySet || sslCertSet)) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Property 'sslPfx' can only be set when 'sslPrivateKey' and 'sslCertificate' " +
                                   'are not set',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
        if ((sslPrivateKeySet && !sslCertSet) || (!sslPrivateKeySet && sslCertSet)) {
          throw new OperationError('SessionProperties validation: ' +
                                   "Property 'sslPrivateKey' and 'sslCertificate' " +
                                   'must be set at the same time',
                                   ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      }
    }

    v('transportProtocol', [valIsMember, TransportProtocol, 'TransportProtocol', true]);
    v('webTransportProtocolList',
      [valArrayIsMember, TransportProtocol, 'TransportProtocol',
        true, false, false]);

    validatePropsSupportedByTransport(props.transportProtocol,
                                      props.nonHTTPTransportPropsSet);

    if (props.publisherProperties) {
      PublisherLib.MessagePublisherPropertiesValidator.validate(props.publisherProperties);
    }

    // Non-errors

    var recommendedMin = props.defaultConnectTimeoutInMsecs;
    var connectTimeout = props.connectTimeoutInMsecs;
    var transportCount = props.webTransportProtocolList
      ? props.webTransportProtocolList.length
      : 1;
    if (transportCount > 1 && connectTimeout < recommendedMin) {
      LOG_WARN(
        "Connect timeout of " + connectTimeout + " msecs is less than default and recommended " +
        "minimum of " + recommendedMin + " msecs for current transport selection. Transport " +
        'downgrades may not complete.');
    }
  },
};

module.exports.SessionPropertiesValidator = SessionPropertiesValidator;



/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

var DestinationLib = __webpack_require__(5);
var MessageLib = __webpack_require__(16);
var SolclientFactoryLib = __webpack_require__(9);
var util = __webpack_require__(6);
var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(80);
var CacheSession = ref$1.CacheSession;
var CACHE_REQUEST_PREFIX = ref$1.CACHE_REQUEST_PREFIX;
var ref$2 = __webpack_require__(43);
var CapabilityType = ref$2.CapabilityType;
var ref$3 = __webpack_require__(7);
var Check = ref$3.Check;
var Parameter = ref$3.Parameter;
var ref$4 = __webpack_require__(210);
var DefaultCapabilities = ref$4.DefaultCapabilities;
var ref$5 = __webpack_require__(2);
var ErrorResponseSubcodeMapper = ref$5.ErrorResponseSubcodeMapper;
var ErrorSubcode = ref$5.ErrorSubcode;
var OperationError = ref$5.OperationError;
var RequestEventCode = ref$5.RequestEventCode;
var ref$6 = __webpack_require__(35);
var EventEmitter = ref$6.EventEmitter;
var ref$7 = __webpack_require__(211);
var GlobalContext = ref$7.GlobalContext;
var ref$8 = __webpack_require__(213);
var HostList = ref$8.HostList;
var ref$9 = __webpack_require__(1);
var LogFormatter = ref$9.LogFormatter;
var ref$10 = __webpack_require__(111);
var MessageRxCBInfo = ref$10.MessageRxCBInfo;
var ref$11 = __webpack_require__(112);
var MutableSessionProperty = ref$11.MutableSessionProperty;
var ref$12 = __webpack_require__(214);
var OutstandingDataRequest = ref$12.OutstandingDataRequest;
var ref$13 = __webpack_require__(113);
var P2PUtil = ref$13.P2PUtil;
var ref$14 = __webpack_require__(18);
var QueueDescriptor = ref$14.QueueDescriptor;
var QueueType = ref$14.QueueType;
var ref$15 = __webpack_require__(10);
var SDTField = ref$15.SDTField;
var SDTFieldType = ref$15.SDTFieldType;
var ref$16 = __webpack_require__(73);
var SessionEvent = ref$16.SessionEvent;
var ref$17 = __webpack_require__(114);
var SessionEventCBInfo = ref$17.SessionEventCBInfo;
var ref$18 = __webpack_require__(44);
var SessionEventCode = ref$18.SessionEventCode;
var ref$19 = __webpack_require__(72);
var SessionEventName = ref$19.SessionEventName;
var ref$20 = __webpack_require__(215);
var SessionFSM = ref$20.SessionFSM;
var ref$21 = __webpack_require__(115);
var SessionFSMEvent = ref$21.SessionFSMEvent;
var ref$22 = __webpack_require__(216);
var SessionOperation = ref$22.SessionOperation;
var ref$23 = __webpack_require__(74);
var SessionProperties = ref$23.SessionProperties;
var ref$24 = __webpack_require__(217);
var SessionPropertiesValidator = ref$24.SessionPropertiesValidator;
var ref$25 = __webpack_require__(75);
var SessionRequestType = ref$25.SessionRequestType;
var ref$26 = __webpack_require__(117);
var SessionState = ref$26.SessionState;
var ref$27 = __webpack_require__(116);
var SessionStateName = ref$27.SessionStateName;
var ref$28 = __webpack_require__(19);
var Stats = ref$28.Stats;
var StatType = ref$28.StatType;
var ref$29 = __webpack_require__(4);
var StringUtils = ref$29.StringUtils;
var ref$30 = __webpack_require__(23);
var TransportCapabilities = ref$30.TransportCapabilities;
var TransportProtocol = ref$30.TransportProtocol;
var TransportReturnCode = ref$30.TransportReturnCode;

function transportProtocolDefaultList() {
  var ProfileBinding = SolclientFactoryLib.ProfileBinding;

  if (true) {
    return [TransportProtocol.WS_BINARY];
  }

  var result = [];
  if (TransportCapabilities.web.webSocket()) {
    result.push(TransportProtocol.WS_BINARY);
  }
  var profile = ProfileBinding.value;
  if (profile.cometEnabled) {
    if (TransportCapabilities.web.xhrBinary()) {
      if (TransportCapabilities.web.streaming()) {
        result.push(TransportProtocol.HTTP_BINARY_STREAMING);
      }
      result.push(TransportProtocol.HTTP_BINARY);
    }
    result.push(TransportProtocol.HTTP_BASE64);
  }
  return result;
}

function isValidADTransport(transportProtocol) {
  return (transportProtocol && (
          transportProtocol !== TransportProtocol.HTTP_BINARY_STREAMING &&
          transportProtocol !== TransportProtocol.HTTP_BINARY &&
          transportProtocol !== TransportProtocol.HTTP_BASE64));
}

function formatEventName(eventName) {
  return ("SessionEventCode." + (SessionEventCode.describe(eventName)));
}

/**
 * @private
 */
var SOLCLIENT_REQUEST_PREFIX = '#REQ';

/**
 * A callback that returns replies to requests sent via {@link solace.Session#sendRequest}.
 * The replyReceivedCallback <b>must</b> be provided to the API as the third argument of
 * {@link solace.Sesssion#sendRequest}.
 * @callback
 * @function
 * @name solace.Session.replyReceivedCallback
 * @param {solace.Session} session The session object that received the reply.
 * @param {solace.Message} message The reply message received.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */

/**
 * A callback that returns errors associated with requests sent via
 * {@link solace.Session#sendRequest}. The replyReceivedCallback <b>must</b> be
 * provided to the API as the fourth argument of
 * {@link solace.Sesssion#sendRequest}
 * @callback
 * @function
 * @name solace.Session.requestFailedCallback
 * @param {solace.Session} session The session object associated with the event.
 * @param {solace.RequestError} error The event associated with the failure.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * Applications must use {@link solace.SolclientFactory.createSession} to create a session.
 *
 * Represents a client Session.
 *
 * Session provides these major functions:
 *  * Subscriber control, such as updating subscriptions;
 *  * Publishes both Direct and Guaranteed Messages to the router;
 *  * Receives direct messages from the router.
 *
 * The Session object is an
 * {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}, and will emit
 * events with event names from {@link solace.SessionEventCode} when Session events occur.
 * Each session event can be subscribed using {@link solace.Session#on} with the corresponding
 * {@link solace.SessionEventCode}. If any of the registered event listeners throw an exception,
 * the exception will be emitted on the 'error' event.
 *
 * @fires solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
 * @fires solace.SessionEventCode#CAN_ACCEPT_DATA
 * @fires solace.SessionEventCode#CONNECT_FAILED_ERROR
 * @fires solace.SessionEventCode#DISCONNECTED
 * @fires solace.SessionEventCode#DOWN_ERROR
 * @fires solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
 * @fires solace.SessionEventCode#MESSAGE
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_ERROR
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_OK
 * @fires solace.SessionEventCode#RECONNECTED_NOTICE
 * @fires solace.SessionEventCode#RECONNECTING_NOTICE
 * @fires solace.SessionEventCode#REJECTED_MESSAGE_ERROR
 * @fires solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
 * @fires solace.SessionEventCode#SUBSCRIPTION_ERROR
 * @fires solace.SessionEventCode#SUBSCRIPTION_OK
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
 * @fires solace.SessionEventCode#UP_NOTICE
 * @fires solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
 *
 * @memberof solace
 */
var Session = (function (EventEmitter) {
  function Session(properties, messageCallback, eventCallback) {
    EventEmitter.call(this, {
      emits:  SessionEventCode.values,
      direct: SessionEventCode.MESSAGE,
      formatEventName: formatEventName,
    });
    var self = this;
    this.logger = new LogFormatter();
    this.logger.formatter = function formatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [("[session=" + (self._sessionFSM ? self._sessionFSM.sessionIdHex : '(N/A)') + "]") ].concat( args);
    };
    if ((properties !== undefined) && (properties !== null)) {
      var ref = this.logger;
      var LOG_DEBUG = ref.LOG_DEBUG;
      /* #stripped LOG_DEBUG('Session properties:\n', properties) */

    }

    var sessionProperties = new SessionProperties(properties);

    // Callbacks to client application.
    // Get/set for these is private, so they can only be changed in-API (e.g. by CacheSession)
    // The user-supplied one cannot be changed.
    // The configuration of the exceptions generated by these needs to match EventEmitter, so that
    // the handleGenericErrorEvent above can behave consistently
    this._messageCallbackInfo = this.wrapMessageCallback(messageCallback);
    this._eventCallbackInfo = this.wrapEventCallback(eventCallback);

    // client name generation is applicable
    if (Check.empty(sessionProperties.clientName)) {
      // Auto-gen clientName
      sessionProperties.clientName = GlobalContext.GenerateClientName();
    }

    // generate userIdentification
    sessionProperties._setUserIdentification(GlobalContext.GenerateUserIdentification());

    // client description generation is applicable
    if (Check.empty(sessionProperties.applicationDescription)) {
      // Auto-gen applicationDescription
      sessionProperties.applicationDescription = GlobalContext.GenerateClientDescription();
    }

    // Set webTransportProtocolList after validation so we're not basing it on an
    // invalid transport selection...so we're not checking transportProtocol/
    // webTransportProtocolList except for parameter conflict.

    // Now that we have touched up the properties as much as possible, validate
    // This also validates the subordinate MessagePublisherProperties
    SessionPropertiesValidator.validate(sessionProperties);

    // We want a protocol list, but historically we also accept a single protocol.
    // Create a web transport protocol list from the transport protocol
    // option if that is all that was set. (If both were set, we failed validation)
    if (Check.nothing(sessionProperties.webTransportProtocolList)) {
      // Create a fallback list that starts with the selected protocol.
      // If the selected protocol is not in the fallback list, it is not
      // a valid protocol for the platform so return an empty list.
      var selectedProtocol = sessionProperties.transportProtocol;
      var defaultList = transportProtocolDefaultList();
      var sliceIndex = selectedProtocol ? defaultList.indexOf(selectedProtocol) : 0;
      if (sliceIndex < 0) {
        // The user explicitly selected a protocol that wasn't valid
        throw new OperationError(("Selected transport protocol " + (TransportProtocol.describe(selectedProtocol)) + " is disabled or invalid for this platform"),
                                 ErrorSubcode.PARAMETER_CONFLICT);
      }
      // Slice index is valid
      sessionProperties.webTransportProtocolList = defaultList.slice(sliceIndex);

      if (sessionProperties.webTransportProtocolList.length === 0) {
        // Even before AD restrictions, no valid protocols.
        // User error.
        throw new OperationError(("No usable transport protocol or fallback from " + (TransportProtocol.describe(selectedProtocol))),
          ErrorSubcode.PARAMETER_CONFLICT);
      }

      // Check that the generated list is compatible with AD.
      var validForAD = sessionProperties.webTransportProtocolList.filter(function (x) { return isValidADTransport(x); });
      if (validForAD.length === 0) {
        this._adDisabledReason = 'Guaranteed messaging not compatible with any available ' +
          "transport protocol: " + (sessionProperties.webTransportProtocolList.map(function (k) { return TransportProtocol.describe(k); }).join(', '));
      }

      // Don't fold this into the check below -- for that one, every
      // protocol must be valid because the user explicitly requested all of them.
      // In this case, we ensure that at least one of our generated list is valid.
      if (sessionProperties.publisherProperties.enabled) {
        if (this._adDisabledReason) {
          throw new OperationError(
            'Invalid transport protocol(s) for session with Guaranteed Messaging Publisher',
            ErrorSubcode.PARAMETER_CONFLICT,
            this._adDisabledReason
          );
        }
        // AD was not disabled by having no protocols available
        sessionProperties.webTransportProtocolList = validForAD;
      }
      // A valid protocol list is ready to use.
    } else {
      // User provided transport protocol list
      // Check for parameter conflict between session and publisher
      // Already checked these for parameter conflict; only one will be set
      // Already checked that user list was not empty
      var transportProtocols = sessionProperties.webTransportProtocolList;
      var validForAD$1 = transportProtocols.every(isValidADTransport);
      if (!validForAD$1) {
        var invalid = transportProtocols.filter(function (x) { return !isValidADTransport(x); });
        this._adDisabledReason = "Guaranteed messaging incompatible with selected transport protocols: " + (invalid.map(function (k) { return TransportProtocol.describe(k); }).join(', '));
        if (sessionProperties.publisherProperties.enabled) {
          throw new OperationError(
            'Invalid transport protocol(s) for session with Guaranteed Messaging Publisher',
            ErrorSubcode.PARAMETER_CONFLICT,
            this._adDisabledReason
          );
        }
      }
    }


    // Assign the final properties and start the state machine.
    this._sessionProperties = sessionProperties;
    this._sessionStats = new Stats();
    this._hosts = new HostList(sessionProperties);
    this._sessionFSM = new SessionFSM(
      this._sessionProperties,
      this,
      this._sessionStats,
      this._hosts
    );
    this._sessionFSM.start();
    this._sessionFSM.createMessagePublisher();

    /**
     * The following fields are destroyed when disconnect is called
     * and recreated when connect is called again.
     * @private
     */
    this._outstandingDataReqs = {};
    this._capabilities = DefaultCapabilities.createDefaultCapabilities();
    this._seqNum = 1;
  }

  if ( EventEmitter ) Session.__proto__ = EventEmitter;
  Session.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Session.prototype.constructor = Session;

  var prototypeAccessors = { canAck: {},adLocallyDisabled: {},canConnectConsumer: {},canConnectPublisher: {},disposed: {} };

  /**
   * Connects the session to the Solace Message Router as configured in
   * the {@link solace.SessionProperties#url}.
   *
   * When the session is successfully connected to the Solace Message Router, the
   * {@link solace.SessionEventCode#UP_NOTICE} event is emitted if a listener has been registered.
   *
   * If {@link solace.SessionProperties#reapplySubscriptions} is set to true, this operation
   * re-registers previously registered subscriptions. The connected session event
   * ({@link solace.SessionEventCode#event:UP_NOTICE}) is emitted only when all the subscriptions
   * are successfully added to the router.
   *
   * If the API is unable to connect within {@link solace.SessionProperties#connectTimeoutInMsecs}
   * or due to login failures, the session's state transitions back to 'disconnected' and an event
   * is generated.
   *
   * **Note:** Before the session's state transitions to 'connected', a client
   * application cannot use the session; any attempt to call functions will throw
   * {@link solace.OperationError}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed, already connected or connecting.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the underlying transport cannot be established.
   *   Subcode: {@link solace.ErrorSubcode.CONNECTION_ERROR}.
   */
  Session.prototype.connect = function connect () {
    var result = this.allowOperation(SessionOperation.CONNECT);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.CONNECT });
    this._sessionFSM.processEvent(sEvent);
  };

  /**
   * @returns {Boolean} True if the session can be used to acknolwedge a message
   * @readonly
   * @private
   */
  prototypeAccessors.canAck.get = function () {
    var this$1 = this;

    /*
     * If the user wants to ack a message, it was received on a session (else ack will throw),
     * and so we know that the session was connected at some point.
     *
     * If the session is in any of the following states, we know it is either connecting or
     * connected.
     *
     * Since we know the session was previously connected, this implies the session is either
     * RECONNECTING or connected.
     *
     * We allow acks when the session is reconnecting or connected.
     *
     * TODO: Optimistically, we allow acks on a disconnecting session, on the theory that it
     * will be reconnectable.
     */
    var statesCanAck = [
      SessionStateName.CONNECTING,
      SessionStateName.TRANSPORT_UP,
      SessionStateName.DISCONNECTING ];
    // Allow ack if there is some acceptable state name such that getActiveState returns the state.
    return statesCanAck.some(function (stateName) { return !!this$1._sessionFSM.getActiveState(stateName); });
  };

  /**
   * Disconnects the session. The session attempts to disconnect cleanly, concluding all operations
   * in progress. The disconnected session event {@link solace.SessionEventCode#event:DISCONNECTED}
   * is emitted when these operations complete and the session has completely disconnected.
   *
   * @throws {solace.OperationError} if the session is disposed, or has never been connected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.disconnect = function disconnect () {
    var result = this.allowOperation(SessionOperation.DISCONNECT);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sEvent = new SessionFSMEvent({ name: SessionEventName.DISCONNECT });
    this._sessionFSM.processEvent(sEvent);
  };

  /**
   * Release all resources associated with the session.
   * It is recommended to call disconnect() first for proper handshake with the message-router.
   */
  Session.prototype.dispose = function dispose () {
    var this$1 = this;

    if (this._disposed) { return; }

    setImmediate(function () {
      this$1._sessionFSM.processEvent(
        new SessionFSMEvent({ name: SessionEventName.DISPOSE })
      ); // yield for disconnect if any
      this$1._sessionFSM.terminateFsm();
      this$1.disableEmitter();
      this$1._disposed = true;
    });
  };

  /**
   * Subscribe to a topic, optionally requesting a confirmation from the router.
   *
   * If requestConfirmation is set to true:
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is
   * added successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   * The returned string is in the format of "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to add.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object} correlationKey If specified, and if requestConfirmation is true, this value is
   *                                echoed in the session event within {@link SessionEvent}.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.subscribe = function subscribe (topic, requestConfirmation, correlationKey, requestTimeout) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('topic', topic, DestinationLib.Destination);
    topic.validate();
    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
      throw new OperationError(("Topic is required for subscribe; " + (DestinationLib.DestinationType.describe(topic.getType()))),
                               ErrorSubcode.INVALID_TOPIC_SYNTAX);
    }

    Parameter.isBooleanOrNothing('requestConfirmation', requestConfirmation);
    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    this._sessionFSM.subscriptionUpdate(
      topic,
      !!requestConfirmation,
      correlationKey,
      requestTimeout,
      SessionRequestType.ADD_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleSubscriptionUpdateResponse(rxMsgObj,
                                              cancelledRequest,
                                              requestConfirmation); });
  };

  /**
   * Unsubscribe from a topic, and optionally request a confirmation from the router.
   *
   * If requestConfirmation is set to true, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is removed
   * successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}. The returned
   * string is in the format "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to remove.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object} correlationKey If <code>null</code> or undefined, a Correlation Key is not set
   *                                in the confirmation session event.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.unsubscribe = function unsubscribe (topic, requestConfirmation, correlationKey, requestTimeout) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('topic', topic, DestinationLib.Destination);
    topic.validate();
    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
      throw new OperationError(("Topic is required for unsubscribe; " + (DestinationLib.DestinationType.describe(topic.getType()))),
                               ErrorSubcode.INVALID_TOPIC_SYNTAX);
    }

    Parameter.isBooleanOrNothing('requestConfirmation', requestConfirmation);
    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    this._sessionFSM.subscriptionUpdate(
      topic,
      !!requestConfirmation,
      correlationKey,
      requestTimeout,
      SessionRequestType.REMOVE_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleSubscriptionUpdateResponse(rxMsgObj,
                                              cancelledRequest,
                                              requestConfirmation); });
  };

  /**
   * Request that a Durable Topic Endpoint stop receiving data on a topic. Unsubscribe
   * requests are only allowed by the router when no clients are bound to the DTE.
   * If the unubscribe request is successful, the DTE will stop attracting messages,
   * and all messages spooled to the DTE will be deleted.
   *
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK} is generated when the
   * subscription is removed successfully; otherwise,
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR} is generated.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   *
   * @param {solace.AbstractQueueDescriptor|solace.QueueDescriptor} queueDescriptor A description
   *  of the queue to which the topic is subscribed.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.unsubscribeDurableTopicEndpoint = function unsubscribeDurableTopicEndpoint (queueDescriptor) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    // emulate subscription
    var destination = this.createDestinationFromDescriptor(
      QueueDescriptor.createFromSpec(queueDescriptor));
    var requestConfirmation = true;
    this._sessionFSM.subscriptionUpdate(
      destination,
      requestConfirmation,
      undefined,
      undefined,
      SessionRequestType.REMOVE_DTE_SUBSCRIPTION,
      function (rxMsgObj, cancelledRequest) { return this$1.handleDTEUnsubscribeResponse(rxMsgObj,
                                          cancelledRequest); });
  };


  /**
   * Modify a session property after creation of the session.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to modify.
   * @param {Object} newValue The new property value.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, it
   *                                overwrites readTimeoutInMsecs
   * @param {Object} correlationKey If specified, this value is echoed in the session event within
   *                                {@link SessionEvent} property in {@link SessionProperties}
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
  Session.prototype.updateProperty = function updateProperty (mutableSessionProperty, newValue, requestTimeout, correlationKey) {
    var this$1 = this;

    var result = this.allowOperation(SessionOperation.CTRL);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var Topic = DestinationLib.Topic;

    /* #stripped LOG_TRACE('Updating property ', mutableSessionProperty, newValue) */


    Parameter.isEnumMember('mutableSessionProperty', mutableSessionProperty, MutableSessionProperty);

    Parameter.isNumberOrNothing('requestTimeout', requestTimeout);
    Parameter.isRangeCompareOrNothing('requestTimeout', requestTimeout, '>', 0);

    var sessionEvent;
    /*
     Response CB to the CLIENTCTRL UPDATE response

     This is pretty complicated: we define the whole process in here
     using callbacks to preserve state such as the correlationKey of the user
     request.
     That is, this entire multi-step process executes under the context of that one call to
     updateProperty with a single correlationKey value.
     */
    var responseCallback = function (respMsg) {
      var response = respMsg.getResponse();
      if (response.responseCode === 200) {
        if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
          // update property and notify client
          this$1._sessionProperties.applicationDescription = newValue;
          sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                            response.responseString,
                                            response.responseCode,
                                            0,
                                            correlationKey,
                                            null);
          this$1.sendEvent(sessionEvent);
        } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
          // replace P2P subscription: REM and ADD
          var oldP2pTopicName = P2PUtil.getP2PTopicSubscription(
            this$1._sessionProperties.p2pInboxBase);
          var oldP2pTopic = Topic.createFromName(oldP2pTopicName);

          var newP2pTopicName = P2PUtil.getP2PTopicSubscription(
            respMsg.getP2PTopicValue());
          var newP2pTopic = Topic.createFromName(newP2pTopicName);

          var afterAddCallback = function (smpResp) {
            var resp = smpResp.getResponse();
            if (resp.responseCode === 200) {
              // notify client
              this$1._sessionProperties._setP2pInboxBase(respMsg.getP2PTopicValue() || '');
              this$1._sessionProperties._setP2pInboxInUse(
                P2PUtil.getP2PInboxTopic(this$1._sessionProperties.p2pInboxBase));
              this$1._sessionProperties.clientName = newValue;
              sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                                resp.responseString,
                                                resp.responseCode,
                                                0,
                                                correlationKey,
                                                null);
              this$1.sendEvent(sessionEvent);
            } else {
              var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode,
                                                                              resp.responseString);
              if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT &&
                              this$1._sessionProperties.ignoreDuplicateSubscriptionError) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  0,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_TOO_MANY) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  errorSubcode,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  ErrorSubcode.SUBSCRIPTION_ERROR_OTHER,
                                                  correlationKey,
                                                  null);
                this$1.sendEvent(sessionEvent);
              }
            }
          };

          var afterRemoveCallback = function (smpResp) {
            var resp = smpResp.getResponse();
            if (resp.responseCode === 200) {
              // second add new P2P
              this$1._sessionFSM.subscriptionUpdate(newP2pTopic,
                                                  true,       // request confirm
                                                  correlationKey,
                                                  this$1._sessionProperties.readTimeoutInMsecs,
                                                  SessionRequestType.ADD_P2PINBOX,
                                                  afterAddCallback);
            } else {
              var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode,
                                                                              resp.responseString);
              if (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND &&
                  this$1._sessionProperties.ignoreSubscriptionNotFoundError) {
                // add new P2P anyway: the error is simply the old P2P
                // was not found on remove.  It's notable though.
                this$1._sessionFSM.subscriptionUpdate(newP2pTopic,
                                                    true,       // request confirm
                                                    correlationKey,
                                                    this$1._sessionProperties.readTimeoutInMsecs,
                                                    SessionRequestType.ADD_P2PINBOX,
                                                    afterAddCallback);
              } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND ||
                         errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED) {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  errorSubcode,
                                                  null,
                                                  null);
                this$1.sendEvent(sessionEvent);
              } else {
                // notify client
                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                                  resp.responseString,
                                                  resp.responseCode,
                                                  ErrorSubcode.SUBSCRIPTION_ERROR_OTHER,
                                                  null,
                                                  null);
                this$1.sendEvent(sessionEvent);
              }
            }
          };

          // first remove old P2P
          this$1._sessionFSM.subscriptionUpdate(oldP2pTopic,
                                              true,       // request confirm
                                              correlationKey,
                                              this$1._sessionProperties.readTimeoutInMsecs,
                                              SessionRequestType.REMOVE_P2PINBOX,
                                              afterRemoveCallback);
        }
      } else {
        // notify client error
        var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(response.responseCode,
                                                                        response.responseString);
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          response.responseString,
                                          response.responseCode,
                                          errorSubcode,
                                          correlationKey,
                                          null);
        this$1.sendEvent(sessionEvent);
      }
    }; // end CB (response to UPDATE request)

    var returnCode = this._sessionFSM.sendUpdateProperty(mutableSessionProperty,
                                                           newValue,
                                                           correlationKey,
                                                           requestTimeout,
                                                           responseCallback);
    if (returnCode !== TransportReturnCode.OK) {
          // do not change session state

      if (returnCode === TransportReturnCode.NO_SPACE) {
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          'Property update failed - no space in transport',
                                          null,
                                          ErrorSubcode.INSUFFICIENT_SPACE,
                                          null,
                                          null);
      } else {
        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR,
                                          'Property update failed',
                                          null,
                                          ErrorSubcode.INVALID_OPERATION,
                                          null,
                                          null);
      }
      this.sendEvent(sessionEvent);
    }
  };

  /**
   * Publish (send) a message over the session. The message is sent to its set destination.
   *
   * This method is used for sending both direct and Guaranteed Messages.  If the message's
   * {@link solace.MessageDeliveryModeType} is {@link solace.MessageDeliveryModeType.DIRECT}, the
   * message is a direct message; otherwise, it is a guaranteed message.
   *
   * @param {solace.Message} message The message to send. It must have a destination set.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.send = function send (message) {
    var result = this.allowOperation(SessionOperation.SEND, message);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('message', message, MessageLib.Message);
    this.validateAndSendMessage(message);
  };

  /**
   * Sends a request using user-specified callback functions.
   * <br>
   * <strong>Note:</strong>
   * The API sets the correlationId and replyTo fields of the message being sent;
   * this overwrites any existing correlationId and replyTo values on the message.
   *
   * @param {solace.Message} message The request message to send.
   * @param {Number} [timeout] The timeout value (in milliseconds). The minimum value is 100 msecs.
   * @param {solace.Session.replyReceivedCallback} [replyReceivedCBFunction] The callback to notify
   *    when a reply is received.
   * @param {solace.Session.requestFailedCallback} [requestFailedCBFunction] The callback to notify
   *    when the request failed.
   * @param {Object} [userObject] An optional correlation object to use in the response callback.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.sendRequest = function sendRequest (message,
              timeout,
              replyReceivedCBFunction,
              requestFailedCBFunction,
              userObject
              ) {
    if ( timeout === void 0 ) timeout = undefined;
    if ( replyReceivedCBFunction === void 0 ) replyReceivedCBFunction = undefined;
    if ( requestFailedCBFunction === void 0 ) requestFailedCBFunction = undefined;
    if ( userObject === void 0 ) userObject = undefined;

    var result = this.allowOperation(SessionOperation.SEND, message);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isInstanceOf('message', message, MessageLib.Message);
    Parameter.isNumberOrNothing('timeout', timeout);
    Parameter.isRangeCompareOrNothing('timeout', timeout, '>=', 100);
    Parameter.isFunctionOrNothing('replyReceivedCBFunction', replyReceivedCBFunction);
    Parameter.isFunctionOrNothing('requestFailedCBFunction', requestFailedCBFunction);

    // set correlationId and replyTo fields if not set by the application
    var correlationId = message.getCorrelationId();
    if (correlationId === null || correlationId === undefined) {
      message.setCorrelationId(SOLCLIENT_REQUEST_PREFIX + GlobalContext.NextId());
    }
    var replyTo = message.getReplyTo();
    if (replyTo === null || replyTo === undefined) {
      var replyToTopic = DestinationLib.Topic.createFromName(
        this._sessionProperties.p2pInboxInUse);
      message.setReplyTo(replyToTopic);
    }

    this.validateAndSendMessage(message);

      // enqueue request
    this.enqueueOutstandingDataReq(message.getCorrelationId(),
                                   requestFailedCBFunction,
                                   timeout,
                                   replyReceivedCBFunction,
                                   userObject);
  };

  /**
   * Sends a reply message to the destination specified in messageToReplyTo.
   *
   * If `messageToReplyTo` is non-null:
   *  * {@link solace.Message#getReplyTo} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setDestination} on `replyMessage`, unless `replyTo` is null.
   *  * {@link solace.Message#setCorrelationId} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setCorrelationId} on `replyMessage`, unless `correlationId` is null.
   *
   * If `messageToReplyTo` is null, the application is responsible for setting
   * the `destination` and `correlationId` on the `replyMessage`.
   *
   * @param {solace.Message} messageToReplyTo The message to which a reply will be sent.
   * @param {solace.Message} replyMessage The reply to send.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   */
  Session.prototype.sendReply = function sendReply (messageToReplyTo, replyMessage) {
    var result = this.allowOperation(SessionOperation.SEND, replyMessage);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isInstanceOfOrNothing('messageToReplyTo', messageToReplyTo, MessageLib.Message);
    Parameter.isInstanceOf('replyMessage', replyMessage, MessageLib.Message);

    replyMessage.setAsReplyMessage(true);
    if (messageToReplyTo) {
      replyMessage.setCorrelationId(messageToReplyTo.getCorrelationId());
      var replyTo = messageToReplyTo.getReplyTo();
      if (replyTo === null || replyTo === undefined) {
        throw new OperationError('ReplyTo destination may not be null.',
                                 ErrorSubcode.PARAMETER_OUT_OF_RANGE);
      }
      replyMessage.setDestination(messageToReplyTo.getReplyTo());
    }
    this.validateAndSendMessage(replyMessage);
  };

  /**
   * Returns the value of a given {@link solace.StatType}.
   *
   * @param {solace.StatType} statType The statistic to query.
   * @returns {Number} The value of the requested statistic.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the StatType is invalid.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   */
  Session.prototype.getStat = function getStat (statType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isEnumMember('statType', statType, StatType);
    return this._sessionFSM.getStat(statType);
  };

  /**
   * Reset session statistics to initial values.
   *
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.resetStats = function resetStats () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    this._sessionFSM.resetStats();
  };

  /**
   * Returns a clone of the properties for this session.
   *
   * @returns {solace.SessionProperties} A clone of this session's properties.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
  Session.prototype.getSessionProperties = function getSessionProperties () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    var properties = this._sessionProperties.clone();
    var sessionState = this.getSessionState();
    if ((sessionState !== SessionStateName.DISCONNECTED) && this._sessionFSM._transport) {
      properties._setWebTransportProtocolInUse(this._sessionFSM._transport.getTransportProtocol());
    }

    return properties;
  };

  /**
   * Check the value of a boolean router capability.
   *
   * This function is a shortcut for {@link solace.Session#getCapability}. It performs the same
   * operation, but instead of returning a {@link solace.SDTField} wrapping a capability value, it
   * just returns the boolean value.
   *
   *  Attempting to query a non-boolean capability will return `null`.
   *
   * @param {solace.CapabilityType} capabilityType The capability to check.
   *
   * @returns {Boolean} the value of the capability queried.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
  Session.prototype.isCapable = function isCapable (capabilityType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    Parameter.isNumber('capabilityType', capabilityType);

    var caps = this._capabilities;
    if (!caps) {
      return false;
    }

    // Guard for undefined OR non-boolean capability
    return (typeof caps[capabilityType] === 'boolean') ? caps[capabilityType] : false;
  };

  /**
   * Get the value of an router capability, or null if unknown. This function must
   * be called after connecting the session.
   *
   * SDT Type conversions:
   *
   *  * {string} values are returned as {@link solace.SDTFieldType.STRING}.
   *  * {boolean} values are returned as {@link solace.SDTFieldType.BOOL}.
   *  * All numeric values are returned as {@link solace.SDTFieldType.INT64}.
   *
   * @param {solace.CapabilityType} capabilityType The router capability to query.
   * @returns {solace.SDTField} The result of the capability query.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed
   *    Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
  Session.prototype.getCapability = function getCapability (capabilityType) {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }

    Parameter.isNumber('capabilityType', capabilityType);

    var val = this._getCapability(capabilityType);
    if (typeof val === 'boolean') {
      return SDTField.create(SDTFieldType.BOOL, val);
    }
    if (typeof val === 'number') {
      return SDTField.create(SDTFieldType.INT64, val);
    }
    if (typeof val === 'string') {
      return SDTField.create(SDTFieldType.STRING, val);
    }

    return null;
  };

  Session.prototype._getCapability = function _getCapability (capabilityType) {
    var caps = this._capabilities;
    if (!caps) { return null; }

    var value = caps[capabilityType];
    return (value === undefined) ? null : value;
  };

  /**
   * Returns the session's state. This is a third-choice method to determine session
   * state; the first is notifications on FSM transitions, and the second choice is
   * the finer-grained states of the FSM that are used in this mapping.
   *
   * @returns {SessionState} The current state of the session.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * @internal
   */
  Session.prototype.getSessionState = function getSessionState () {
    var result = this.allowOperation(SessionOperation.QUERY_OPERATION);
    if (result) {
      throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
    }
    var sessionStateName = this.getFSMState();
    switch (sessionStateName) {
      case SessionStateName.FULLY_CONNECTED:
        return SessionState.CONNECTED;
      case SessionStateName.DISCONNECTING:
        return SessionState.DISCONNECTING;
      case SessionStateName.DISCONNECTED:
        return SessionState.DISCONNECTED;
      case SessionStateName.SESSION_ERROR:
        return SessionState.SESSION_ERROR;
      case SessionStateName.CONNECTING:
      case SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT:
      case SessionStateName.WAITING_FOR_DNS:
      case SessionStateName.WAITING_FOR_TRANSPORT_UP:
      case SessionStateName.WAITING_FOR_SESSION_UP:
      case SessionStateName.WAITING_FOR_LOGIN:
      case SessionStateName.WAITING_FOR_P2PINBOX_REG:
      case SessionStateName.WAITING_FOR_PUBFLOW:
      case SessionStateName.REAPPLYING_SUBSCRIPTIONS:
        return SessionState.CONNECTING;
      default:
        {
          // State names unaccounted for --
          // WAITING_FOR_SUBCONFIRM
          // WAITING_FOR_CAN_ACCEPT_DATA
          // DISCONNECTING_FLOWS
          // FLUSHING_TRANSPORT
          // DESTROYING_TRANSPORT
          // RECONNECTING
          // TRANSPORT_FAIL
          //
          // TODO: Adjust strategy. Use StateMachine#isStateActive on key parent states,
          // instead of having to enumerate all child states.ant
          var ref = this.logger;
          var LOG_INFO = ref.LOG_INFO;
          LOG_INFO(("Unmapped session state " + (SessionStateName.describe(sessionStateName))));
          return null;
        }
    }
  };

  /**
   * Gets the fine grained state name from the session FSM.
   * @returns {solace.SessionStateName} The FSM state name
   * @private
   */
  Session.prototype.getFSMState = function getFSMState () {
    return this._sessionFSM.getCurrentStateName();
  };

  /**
   * Creates a {@link solace.CacheSession} object that uses this Session to service its
   * cache requests.
   *
   * It should be disposed when the application no longer requires a CacheSession, by calling
   * {@link solace.CacheSession#dispose}.
   *
   * @param {solace.CacheSessionProperties} properties The properties for the cache session.
   *
   * @returns {solace.CacheSession} The newly created cache session.
   *
   * @throws {solace.OperationError} if a CacheSession is already associated with this Session.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
  Session.prototype.createCacheSession = function createCacheSession (properties) {
    return new CacheSession(properties, this, {
      // bind instead of arrow func for varargs
      // due to bubl transpiler bug
      incStat: this._sessionFSM.incStat.bind(this._sessionFSM),
    });
  };

  /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The following
   * must be true in order to create a MessageConsumer:
   *  * The transport protocol list does not contain any HTTP transport protocols. See
   *    {@link solace.SessionProperties#transportProtocol} and
   *    {@link solace.FactoryProfile#cometEnabled}
   *  * The Solace Messaging Router must support Guaranteed Messaging
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} when Guaranteed Message Consume is not
   *    supported on this session.
   * @target browser
   */
  /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The Solace
   * Messaging Router must support Guaranteed Messaging.
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} if Guaranteed Message Consume is not supported on this session.
   * @target node
   */
  Session.prototype.createMessageConsumer = function createMessageConsumer (consumerProperties) {
    if (this._adDisabledReason) {
      throw new OperationError('Session does not provide MessageConsumer capability',
                               ErrorSubcode.GM_UNAVAILABLE,
                               this._adDisabledReason);
    }
    if ((consumerProperties !== undefined) && (consumerProperties !== null)) {
      var ref = this.logger;
      var LOG_DEBUG = ref.LOG_DEBUG;
      /* #stripped LOG_DEBUG('createMessageConsumer - Consumer properties:\n', consumerProperties) */

    }
    return this._sessionFSM.createMessageConsumer(consumerProperties);
  };

  /**
   * Creates a publishing destination from a queue descriptor.
   *
   * A MessageConsumer is the only object that has any business
   * doing this, but it should not be concerned with the internals
   * which depend on the session.
   *
   * @param {AbstractQueueDescriptor|QueueDescriptor} queueDescriptor The consumer's descriptor
   * @returns {Destination} A destination that publishes to the descriptor.
   * @memberof Session
   * @private
   */
  Session.prototype.createDestinationFromDescriptor = function createDestinationFromDescriptor (queueDescriptor) {
    var DestinationType = DestinationLib.DestinationType;
    var Queue = DestinationLib.Queue;
    var Topic = DestinationLib.Topic;

    var destinationType = DestinationType.TOPIC;
    if (queueDescriptor.type === QueueType.QUEUE) {
      destinationType = queueDescriptor.durable
        ? DestinationType.QUEUE
        : DestinationType.TEMPORARY_QUEUE;
    }

    var name = queueDescriptor.name || null;

    if (queueDescriptor.durable) {
      assert(name, 'Durable endpoint with generated name is not a valid configuration');
      var factoryMethod = queueDescriptor.getType() === QueueType.QUEUE
        ? Queue.createFromLocalName
        : Topic.createFromName;
      return factoryMethod(name);
    }

    return this.createTemporaryDestination(destinationType, name);
  };

  /**
   * Creates a temporary destination.
   * @param {DestinationType} destinationType Type of destination
   * @param {String} [name] Name if any
   * @returns {Destination} Temporary destination
   * @private
   */
  Session.prototype.createTemporaryDestination = function createTemporaryDestination (destinationType, name) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var DestinationFromNetwork = DestinationLib.DestinationFromNetwork;
    var DestinationUtil = DestinationLib.DestinationUtil;
    // TRANSPORT_UP is chosen because this is when the session tells subscribers
    // that they may begin connecting
    var vrn = this.getSessionProperties().virtualRouterName;
    if (!this.isCapable(CapabilityType.TEMPORARY_ENDPOINT) ||
        vrn === null || vrn === undefined || vrn.length === 0) {
      throw new OperationError(
        'Attempt to generate temporary destination or endpoint without suitable session',
        ErrorSubcode.INVALID_OPERATION);
    }
    // Non-durable case; avoid re-prefixing
    var localName = name && name.startsWith('#P2P')
      ? name
      : DestinationUtil.createTemporaryName(destinationType, vrn, name);
    /* #stripped LOG_TRACE('Generated name:', localName) */

    return DestinationFromNetwork.createDestinationFromName(localName);
  };

  /**
   * @param {solace.SessionEvent} sessionEvent The event to send
   * @private
   */
  Session.prototype.sendEvent = function sendEvent (sessionEvent) {
    if (!sessionEvent) { return; }
    if (this._disposed) { return; }

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    /* #stripped LOG_TRACE(`Sending event ${sessionEvent}`) */

    this._eventCallbackInfo.sessionEventCBFunction(this,
                                                   sessionEvent,
                                                   this._eventCallbackInfo.userObject);
  };

  /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} A description of the current session's transport.
   */
  Session.prototype.getTransportInfo = function getTransportInfo () {
    return this._sessionFSM.getTransportInfo();
  };

  /**
   * @param {Object} interceptor The transport interceptor to set
   * @private
   */
  Session.prototype.injectTransportInterceptor = function injectTransportInterceptor (interceptor) {
    this._sessionFSM.injectTransportInterceptor(interceptor);
  };

  /**
   * @param {solace.SessionOperation} operationEnum the id of the operation
   * @param {solace.Message} message The message to send
   * @returns {?String} error message if not allowed; otherwise null
   * @private
   */
  Session.prototype.allowOperation = function allowOperation (operationEnum, message) {
    if (!this._sessionFSM) { return false; }
    var allow = true;
    var sessionStateName = this._sessionFSM.getCurrentStateName();

    if (sessionStateName === SessionStateName.DISPOSED) {
      allow = false;
    } else if (Check.anything(operationEnum)) {
      switch (operationEnum) {
        case SessionOperation.CONNECT:
          if (sessionStateName !== SessionStateName.NEW &&
              sessionStateName !== SessionStateName.DISCONNECTED) {
            allow = false;
          }
          break;
        case SessionOperation.DISCONNECT:
          if (sessionStateName === SessionStateName.NEW) {
            allow = false;
          }
          break;
        case SessionOperation.SEND:
        case SessionOperation.CTRL:
          allow =
            ((sessionStateName === SessionStateName.FULLY_CONNECTED) ||
            (message && (message.getDeliveryMode() !== MessageLib.MessageDeliveryModeType.DIRECT)));
          break;

        case SessionOperation.QUERY_OPERATION:
          allow = true;
          break;
        default:
          allow = false;
      }
    } else {
      allow = false;
    }

    if (allow) {
      return null;
    }

    return ("Cannot perform operation " + operationEnum + " while in state " + sessionStateName);
  };

  /**
   * @param {smf.ClientCtrlMessage} routerCapabilities The message containing the router caps
   * @private
   */
  Session.prototype.updateCapabilities = function updateCapabilities (routerCapabilities) {
    this._capabilities = routerCapabilities;
  };

  /**
   * @param {solace.Message} message The message to send
   * @private
   */
  Session.prototype.validateAndSendMessage = function validateAndSendMessage (message) {
    // Sanity checks on the message before attempting to send it
    //  * do we have a destination?
    var sendDest = message.getDestination();
    if (Check.nothing(sendDest) || Check.empty(sendDest.getName())) {
      throw new OperationError('Message must have a valid Destination', ErrorSubcode.TOPIC_MISSING);
    }

    var senderTimestamp = message.getSenderTimestamp();
    var noSenderTimestamp = senderTimestamp === null || senderTimestamp === undefined;
    if (this._sessionProperties.generateSendTimestamps &&
        (noSenderTimestamp || message.hasAutoSenderTimestamp)) {
      var now = new Date();
      message.setSenderTimestamp(now.getTime());
      message.hasAutoSenderTimestamp = true;
    }
    var sequenceNumber = message.getSequenceNumber();
    var noSequenceNumber = sequenceNumber === null || sequenceNumber === undefined;
    if (this._sessionProperties.generateSequenceNumber &&
        (noSequenceNumber || message.hasAutoSequenceNumber)) {
      message.setSequenceNumber(this._seqNum++);
      message.hasAutoSequenceNumber = true;
    }
    var senderId = message.getSenderId();
    var noSenderId = senderId === null || senderId === undefined;
    if (this._sessionProperties.includeSenderId && noSenderId) {
      message.setSenderId(this._sessionProperties.clientName);
    }

    // Allow the FSM and its delegates to prepare and send the message
    // This may mutate the delegates, so we need to validate first
    // this may throw if the message is guaranteed and the window is closed.
    // If this returns true, the message can be sent to the transport
    // (always true for direct messages whne there is a transport). If
    // this returns false, the message has been prepared and queued for
    // transport but may not be sent now.
    this._sessionFSM.prepareAndSendMessage(message);
  };

  /**
   * @param {String} correlationId The internal correlation ID for the message
   * @param {function(...[*])} reqFailedCb The callback on request failure
   * @param {Number} reqTimeout The request timeout in ms
   * @param {function(*)} replyRecvdCb The callback on reply received
   * @param {Object} userObject A user object to pass back to the callback (legacy)
   * @private
   */
  Session.prototype.enqueueOutstandingDataReq = function enqueueOutstandingDataReq (correlationId, reqFailedCb, reqTimeout, replyRecvdCb, userObject) {
    var this$1 = this;

    if (Check.none(correlationId)) {
      return;
    }
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_ERROR = ref.LOG_ERROR;

    // empty string is valid
    /* #stripped LOG_TRACE(`Enqueue outstanding data request correlationId=${correlationId}`) */

    var timer = setTimeout(function () {
      this$1._sessionFSM.incStat(StatType.TX_REQUEST_TIMEOUT);
                  // remove request from queue
      try {
        var result = delete this$1._outstandingDataReqs[correlationId];
        if (!result) {
          LOG_ERROR(("Cannot delete data request " + correlationId));
        }
      } catch (e) {
        LOG_ERROR(("Cannot delete data request " + correlationId), e);
      }

      if (Check.anything(reqFailedCb)) {
        var requestEvent = SessionEvent.build(RequestEventCode.REQUEST_TIMEOUT,
                                                'Request timeout',
                                                correlationId);

        reqFailedCb(this$1, requestEvent, userObject);
      }
    }, reqTimeout || this._sessionProperties.readTimeoutInMsecs);

    var outstandingReq = new OutstandingDataRequest(correlationId,
                                                      timer,
                                                      replyRecvdCb,
                                                      reqFailedCb,
                                                      userObject);
    this._outstandingDataReqs[correlationId] = outstandingReq;
  };

  /**
   * @param {String} correlationId The internal ID of the request to cancel
   * @returns {OutstandingDataRequest} The request that was cancelled, if any
   * @private
   */
  Session.prototype.cancelOutstandingDataReq = function cancelOutstandingDataReq (correlationId) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_ERROR = ref.LOG_ERROR;

    if (Check.none(correlationId) || !this._outstandingDataReqs) {
      return null;
    }

    var req = this._outstandingDataReqs[correlationId];
    if (req === undefined || req === null) {
      return null;
    }
    /* #stripped LOG_TRACE(`Cancel outstanding data request correlationId=${correlationId}`) */

    if (req.timer) {
      clearTimeout(req.timer);
      req.timer = null;
    }

    try {
      var result = delete this._outstandingDataReqs[correlationId];
      if (!result) {
        LOG_ERROR(("Cannot delete data request " + correlationId));
      }
    } catch (e) {
      LOG_ERROR(("Cannot delete data request " + correlationId), e);
    }
    return req;
  };

  /**
   * @private
   */
  Session.prototype.cleanupSession = function cleanupSession () {
    var this$1 = this;

    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    if (this._outstandingDataReqs) {
      /* #stripped LOG_TRACE('Cancel all outstanding data requests') */

      Object.keys(this._outstandingDataReqs).forEach(function (key) {
        var dataReq = this$1.cancelOutstandingDataReq(key);
        if (dataReq && dataReq.reqFailedCBFunction) {
          var requestEvent = SessionEvent.build(RequestEventCode.REQUEST_ABORTED,
                                                  'Request aborted',
                                                  key);
          dataReq.reqFailedCBFunction(this$1, requestEvent, dataReq.userObject);
        }
      });
    }
  };

  /**
   * @param {Message} dataMessageIn The received direct TRmsg
   * @private
   */
  Session.prototype.handleDataMessage = function handleDataMessage (dataMessageIn) {
    var ref = this.logger;
    var LOG_TRACE = ref.LOG_TRACE;
    var LOG_INFO = ref.LOG_INFO;
    var dataMessage = dataMessageIn;
    if (this._sessionProperties.generateReceiveTimestamps) {
      var now = new Date();
      dataMessage._receiverTimestamp = now.getTime();
    }

    if (dataMessage.isReplyMessage()) {
      var correlationId = dataMessage.getCorrelationId();
      if (Check.anything(correlationId)) {
        var dataReq = this.cancelOutstandingDataReq(correlationId);
        if (dataReq !== null) {
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_RECVED);
          /* #stripped LOG_TRACE('Calling application replyReceivedCallback') */

          dataReq.replyReceivedCBFunction(this, dataMessage, dataReq.userObject);
          /* #stripped LOG_TRACE('application replyReceivedCallback returns') */

          return;
        }

        if (correlationId.startsWith(SOLCLIENT_REQUEST_PREFIX)) {
            // if a reply message doesn't have outstanding request and correlationId
            // starts with #REQ it is assumed to be a delayed reply and has to be discarded
          LOG_INFO('DROP: Discard reply message due to missing outstanding request');
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
          return;
        }

        if (correlationId.startsWith(CACHE_REQUEST_PREFIX) &&
              !(CacheSession && this._messageCallbackInfo.userObject instanceof CacheSession)) {
          // If it's a cache message, only pass it along if the listener is a cache message
          // listener. The listener may drop it and increment the DISCARD stat if no
          // cache session recognizes the reply.
          LOG_INFO('DROP: Discard cache reply due to no cache session active');
          this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
          return;
        }
      }
    }

    // notify client message callback
    /* #stripped LOG_TRACE('Calling application messageCallback') */

    this._messageCallbackInfo.messageRxCBFunction(this,
                                                  dataMessage,
                                                  this._messageCallbackInfo.userObject);
    /* #stripped LOG_TRACE('application messageCallback returns') */

  };

  /**
   * Callback function for subscribe/unsubscribe response
   * @param {solace.SMPMessage} smpMsg The SMP response to the subscription request
   * @param {CorrelatedRequest} request The originating request object
   * @param {Boolean} requestConfirm Whether the user asked for confirmation on the request
   * @private
   */
  Session.prototype.handleSubscriptionUpdateResponse = function handleSubscriptionUpdateResponse (smpMsg, request, requestConfirm) {
    var response = smpMsg.getResponse();
    var responseCode = response.responseCode;
    var responseString = response.responseString;
    var correlationKey = request.correlationKey;
    // If we don't request confirmation, the router doesn't send one for the OK case,
    // so we don't need to guard for that.
    // The router always replies on SUBSCRIPTION_ERROR, so we track whether confirmation
    // was requested and suppress the reply in certain cases.
    if (responseCode === 200) {
      // notify client
      var sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK,
                                              responseString,
                                              responseCode,
                                              0,
                                              correlationKey,
                                              null);
      this.sendEvent(sessionEvent);
    } else {
      var subscriptionStr = StringUtils.stripNullTerminate(smpMsg.encodedUtf8Subscription);
      this.handleSubscriptionUpdateError(responseCode,
                                         responseString,
                                         subscriptionStr,
                                         correlationKey,
                                         requestConfirm);
    }
  };

  /**
   * Callback function for DTE unsubscribe response
   *
   * @param {solace.AdMessage} adCtrlMessage The Guaranteed Message Protocol
   *                           control response to the DTE unsub message
   * @param {CorrelatedRequest} request The originating request object
   * @private
   */
  Session.prototype.handleDTEUnsubscribeResponse = function handleDTEUnsubscribeResponse (adCtrlMessage, request) {
    var response = adCtrlMessage.getResponse();
    var responseCode = response.responseCode;
    var responseString = response.responseString;
    var correlationKey = request.correlationKey;
    var eventCode = responseCode === 200
      ? SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK
      : SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR;
    var subcode = responseCode === 200
      ? 0
      : ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode,
                                                     responseString);
    this.sendEvent(SessionEvent.build(eventCode,
                                      responseString,
                                      responseCode,
                                      subcode,
                                      correlationKey
    ));
  };

  /**
   * @param {Number} respCode The returned response code
   * @param {String} respText The returned response text
   * @param {String} subscriptionStr The requested topic name
   * @param {*} correlationKey The user-supplied correlation key
   * @param {Boolean} requestConfirm Whether confirmation was requested on subscription
   * @private
   */
  Session.prototype.handleSubscriptionUpdateError = function handleSubscriptionUpdateError (respCode,
                                respText,
                                subscriptionStr,
                                correlationKey,
                                requestConfirm) {
    var errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
    if ((errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT &&
         this._sessionProperties.ignoreDuplicateSubscriptionError) ||
        (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND &&
          this._sessionProperties.ignoreSubscriptionNotFoundError)) {
      if (requestConfirm) {
        // notify client
        var sessionEvent = SessionEvent.build(
          SessionEventCode.SUBSCRIPTION_OK,
          respText,
          respCode,
          0,
          correlationKey,
          null
        );
        this.sendEvent(sessionEvent);
      }
    } else {
      // notify client
      var sessionEvent$1 = SessionEvent.build(
        SessionEventCode.SUBSCRIPTION_ERROR,
        respText,
        respCode,
        errorSubcode,
        correlationKey,
        ("Topic: " + subscriptionStr)
      );
      this.sendEvent(sessionEvent$1);
    }
  };

  /**
   * @returns {SessionEventCBInfo} The session's event callback
   * @private
   */
  Session.prototype.getEventCBInfo = function getEventCBInfo () {
    return this._eventCallbackInfo;
  };

  /**
   * @param {SessionEventCBInfo} eventCBInfo The new event callback to set
   * @private
   */
  Session.prototype.setEventCBInfo = function setEventCBInfo (eventCBInfo) {
    this._eventCallbackInfo = eventCBInfo;
  };

  /**
   * @returns {MessageRxCBInfo} The session's message callback
   * @private
   */
  Session.prototype.getMessageCBInfo = function getMessageCBInfo () {
    return this._messageCallbackInfo;
  };

  /**
   * @param {MessageRxCBInfo} messageCBInfo The new message callback to set
   * @private
   */
  Session.prototype.setMessageCBInfo = function setMessageCBInfo (messageCBInfo) {
    this._messageCallbackInfo = messageCBInfo;
  };

  /**
   * @returns {String} The next correlation tag for this session.
   * @private
   */
  Session.prototype.getCorrelationTag = function getCorrelationTag () {
    return this._sessionFSM.getCorrelationTag();
  };

  /**
   * Wraps a SessionEventCBInfo or a bare function with an event emitting function.
   * @param {SessionEventCBInfo|function|undefined} eventCallback The callback to wrap
   * @returns {SessionEventCBInfo} A SessionEventCBInfo object that handles all callbacks.
   * @private
   */
  Session.prototype.wrapEventCallback = function wrapEventCallback (eventCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;
    var eventCallbackInfo = (function () {
      if (!eventCallback) { return null; }
      if (eventCallback.sessionEventCBFunction) { return eventCallback; }
      return new SessionEventCBInfo(eventCallback);
    })();
    return new SessionEventCBInfo(function (session, sessionEvent, obj, rfu) {
      var sessionEventCode = sessionEvent.sessionEventCode;
      if (eventCallbackInfo) {
        try {
          eventCallbackInfo.sessionEventCBFunction(session, sessionEvent, obj, rfu);
        } catch (ex) {
          var error = Object.assign(new OperationError(
            ("Unhandled error in SessionEventRxCBInfo callback on sessionEventCode " + (SessionEventCode.describe(sessionEventCode))),
              ErrorSubcode.CALLBACK_ERROR,
              ("On event: " + ([sessionEventCode, sessionEvent, obj, rfu]) + " " + ex)
            ), {
              stack: ex.stack,
              info:  {
                event: {
                  name:          sessionEventCode,
                  formattedName: ("SessionEventCode." + (SessionEventCode.describe(sessionEventCode))),
                  args:          [sessionEvent, obj, rfu],
                },
                error: ex,
              },
            }
          );
          LOG_WARN(error.toString(), error.info);
        }
      }
      this$1.emit(sessionEventCode, sessionEvent);
    });
  };

  /**
   * Wraps a CBInfo or a bare function with an event emitting function.
   * @param {MessageCBInfo|function|undefined} messageCallback The callback to wrap
   * @returns {MessageCBInfo} A MessageCBInfo object that handles all callbacks.
   * @private
   */
  Session.prototype.wrapMessageCallback = function wrapMessageCallback (messageCallback) {
    var this$1 = this;

    var ref = this.logger;
    var LOG_WARN = ref.LOG_WARN;

    var messageCallbackInfo = (function () {
      if (!messageCallback) { return null; }
      if (messageCallback.messageRxCBFunction) { return messageCallback; }
      return new MessageRxCBInfo(messageCallback);
    })();

    var formattedName = "SessionEventCode." + (SessionEventCode.describe(SessionEventCode.MESSAGE));
    var buildErrorEvent = function (ex, message, object) { return Object.assign(
      new OperationError(("Unhandled error in MessageRxCBInfo callback/handler for " + formattedName),
                         ErrorSubcode.CALLBACK_ERROR),
      {
        stack: ex.stack,
        info:  {
          event: {
            name: SessionEventCode.MESSAGE,
            formattedName: formattedName,
            args: [message, object],
          },
          error: ex,
        },
      }); };

    return new MessageRxCBInfo(function (session, message, object) {
      if (messageCallbackInfo) {
        try {
          messageCallbackInfo.messageRxCBFunction(session, message, object);
        } catch (ex) {
          var error = buildErrorEvent(ex, message, object).toString();
          LOG_WARN(error, error.info, ex);
        }
      }
      try {
        this$1.emitDirect(message);
      } catch (ex) {
        this$1.emit('error', buildErrorEvent(ex, message, object));
      }
    });
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.adLocallyDisabled.get = function () {
    return !!this._adDisabledReason;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.canConnectConsumer.get = function () {
    if (this.adLocallyDisabled) { return false; }
    if (this._capabilities) {
      return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME);
    }
    return undefined;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.canConnectPublisher.get = function () {
    if (this.adLocallyDisabled) { return false; }
    if (this._capabilities) {
      return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
    }
    return undefined;
  };

  /**
   * @readonly
   * @private
   */
  prototypeAccessors.disposed.get = function () {
    return this._disposed;
  };

  Session.prototype[util.inspect.custom] = function () {
    return {
      'sessionId': this._sessionFSM && this._sessionFSM.sessionIdHex || '(N/A)',
      'transport': this.getTransportInfo(),
      'state':     SessionState.describe(this.getSessionState()),
    };
  };

  Session.prototype.toString = function toString () {
    return util.inspect(this);
  };

  Object.defineProperties( Session.prototype, prototypeAccessors );

  return Session;
}(EventEmitter));

module.exports.Session = Session;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(75);
var SessionRequestType = ref.SessionRequestType;

module.exports = {
  SubscriptionUpdateTimeoutMessages: ( obj = {
    default:                                      'Request timeout',
  }, obj[SessionRequestType.ADD_SUBSCRIPTION] = 'Add subscription request timeout', obj[SessionRequestType.REMOVE_SUBSCRIPTION] = 'Remove subscription request timeout', obj[SessionRequestType.ADD_P2PINBOX] = 'Add P2P inbox subscription timeout', obj[SessionRequestType.REMOVE_P2PINBOX] = 'Remove P2P inbox subscription timeout', obj[SessionRequestType.REMOVE_DTE_SUBSCRIPTION] = 'Remove endpoint topic subscription', obj ),
};
var obj;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(45);
var ContentSummaryType = ref.ContentSummaryType;
var ref$1 = __webpack_require__(221);
var Decode = ref$1.Decode;
var ref$2 = __webpack_require__(222);
var Encode = ref$2.Encode;
var ref$3 = __webpack_require__(76);
var ParamParse = ref$3.ParamParse;
var ref$4 = __webpack_require__(121);
var ParseSMF = ref$4.ParseSMF;
var ref$5 = __webpack_require__(124);
var Transport = ref$5.Transport;

module.exports.ContentSummaryType = ContentSummaryType;
module.exports.Encode = Encode;
module.exports.Decode = Decode;
module.exports.ParamParse = ParamParse;
module.exports.ParseSMF = ParseSMF;
module.exports.Transport = Transport;



/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SolclientDestinationLib = __webpack_require__(5);
var SolclientMessageLib = __webpack_require__(16);
var SolclientSDTLib = __webpack_require__(10);
var ref = __webpack_require__(13);
var BinaryMetaBlock = ref.BinaryMetaBlock;
var KeepAliveMessage = ref.KeepAliveMessage;
var ref$1 = __webpack_require__(45);
var ContentSummaryType = ref$1.ContentSummaryType;
var ref$2 = __webpack_require__(3);
var Hex = ref$2.Hex;
var Long = ref$2.Long;
var ref$3 = __webpack_require__(0);
var Lazy = ref$3.Lazy;
var ref$4 = __webpack_require__(1);
var LogFormatter = ref$4.LogFormatter;
var ref$5 = __webpack_require__(118);
var parseAdpAt = ref$5.parseAdpAt;
var ref$6 = __webpack_require__(119);
var parseCCAt = ref$6.parseCCAt;
var ref$7 = __webpack_require__(121);
var ParseSMF = ref$7.ParseSMF;
var ref$8 = __webpack_require__(122);
var PriorityUserCosMap = ref$8.PriorityUserCosMap;
var ref$9 = __webpack_require__(22);
var SMFProtocol = ref$9.SMFProtocol;
var ref$10 = __webpack_require__(123);
var SMP = ref$10.SMP;
var ref$11 = __webpack_require__(124);
var Transport = ref$11.Transport;

var formatHexString = Hex.formatHexString;
var lazyValue = Lazy.lazyValue;
var parseSMFAt = ParseSMF.parseSMFAt;
var parseSMPAt = SMP.parseSMPAt;
var parseTsSmfMsgAt = Transport.parseTsSmfMsgAt;

var logger = new LogFormatter('[smf-decode]');
var LOG_TRACE = logger.LOG_TRACE;
var LOG_DEBUG = logger.LOG_DEBUG;
var LOG_ERROR = logger.LOG_ERROR;

var userCosForPriority = lazyValue(function () { return new PriorityUserCosMap().reverse; });

var BIN_STRUCTYPES = {
  0x0A: SolclientMessageLib.MessageType.MAP,
  0x0B: SolclientMessageLib.MessageType.STREAM,
  0x07: SolclientMessageLib.MessageType.TEXT,
};

function adaptBinaryMetaToMessage(binaryMeta, messageIn) {
  var message = messageIn;
  var messageSdt = SolclientSDTLib.Codec.parseSingleElement(binaryMeta.payload, 0);

  if (!(messageSdt && messageSdt.getType() === SolclientSDTLib.SDTFieldType.STREAM)) {
    return;
  }

  var sdtstream = messageSdt.getValue();
  var sdtfield = sdtstream.getNext();
  if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.BYTEARRAY) {
    // Preamble byte array is present
    var preambleByte0 = sdtfield.getValue().charCodeAt(0) & 0xFF;
    if ((preambleByte0 & 0x80) === 0) {
      // structured message: override default "BIN" message type
      message._messageType = (BIN_STRUCTYPES[preambleByte0 & 0x0F] ||
                              SolclientMessageLib.MessageType.BINARY);
    }
    if (sdtfield.getValue().length >= 1) {
      var preambleByte1 = sdtfield.getValue().charCodeAt(1) & 0xFF;
      message.setAsReplyMessage((preambleByte1 & 0x80) !== 0);
    }
  }

  sdtfield = sdtstream.getNext();
  if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.MAP) {
    var sdtMap = sdtfield.getValue();
    var p = sdtMap.getField('p');
    var h = sdtMap.getField('h');
    if (p) {
      message.setUserPropertyMap(p.getValue());
    }
    if (h) {
      var headerMap = h.getValue();
      var ci = headerMap.getField('ci');
      var mi = headerMap.getField('mi');
      var mt = headerMap.getField('mt');
      var rt = headerMap.getField('rt');
      var si = headerMap.getField('si');
      var sn = headerMap.getField('sn');
      var ts = headerMap.getField('ts');
      var ex = headerMap.getField('ex');
      if (ci) {
        message.setCorrelationId(ci.getValue());
      }
      if (mi) {
        message.setApplicationMessageId(mi.getValue());
      }
      if (mt) {
        message.setApplicationMessageType(mt.getValue());
      }
      if (rt) {
        message.setReplyTo(rt.getValue());
      }
      if (si) {
        message.setSenderId(si.getValue());
      }
      if (sn) {
        message.setSequenceNumber(sn.getValue());
      }
      if (ts) {
        message.setSenderTimestamp(ts.getValue());
      }
      if (ex) {
        message.setGMExpiration(ex.getValue());
      }
    }
  }
}


function adaptSmfToMessage(smfHeader, messageIn, stream, offset) {
  var message = messageIn;
  message._setDeliverToOne(!!smfHeader.smf_dto);
  message._setDeliveryMode(smfHeader.pm_deliverymode ||
                          SolclientMessageLib.MessageDeliveryModeType.DIRECT);
  if (smfHeader.pm_tr_topicname_bytes !== null) {
    message._setDestination(
      SolclientDestinationLib.DestinationFromNetwork.createDestinationFromBytes(
        smfHeader.pm_tr_topicname_bytes));
  }
  message._setDiscardIndication(!!smfHeader.smf_di);
  message._setElidingEligible(!!smfHeader.smf_elidingEligible);
  message._setDMQEligible(!!smfHeader.smf_deadMessageQueueEligible);
  message._setUserCos(userCosForPriority.value.get(smfHeader.smf_priority));
  message._setPriority(smfHeader.pm_msg_priority);
  if (smfHeader.pm_userdata) { message._setUserData(smfHeader.pm_userdata); }

  message.setRedelivered(!!smfHeader.pm_ad_redelflag || !!smfHeader.pm_ad_flowredelflag);

  message.setFlowId(smfHeader.pm_ad_flowid);
  message.setGuaranteedMessageId(smfHeader.pm_ad_msgid);
  message.setGuaranteedPreviousMessageId(smfHeader.pm_ad_prevmsgid);
  message.setPublisherId(smfHeader.pm_ad_publisherid);
  message.setPublisherMessageId(smfHeader.pm_ad_publishermsgid);
  message.setTopicSequenceNumber(smfHeader.pm_ad_topicSequenceNumber);

  if (Long.isLong(smfHeader.pm_ad_ttl)) {
    message.setTimeToLive(smfHeader.pm_ad_ttl.toNumber());
  } else {
    message.setTimeToLive(smfHeader.pm_ad_ttl);
  }

  // Copy content into fields (from input bytes)
  var payloadOffset = offset + smfHeader.headerLength;
  var cs = smfHeader.pm_content_summary;

  if (!(cs && cs.length)) {
    // No content-summary, assume binary attachment
    message._setBinaryAttachment(smfHeader.payloadLength > 0
                                ? stream.substr(payloadOffset, smfHeader.payloadLength)
                                : undefined);
    return;
  }

  for (var i = 0, n = cs.length; i < n; ++i) {
    var currentChunk = cs[i];
    var chunkData = stream.substr(payloadOffset + currentChunk.position, currentChunk.length);
    switch (currentChunk.type) {
      case ContentSummaryType.BINARY_ATTACHMENT:
        message._setBinaryAttachment(chunkData);
        break;
      case ContentSummaryType.BINARY_METADATA:
        {
          var binaryMeta = BinaryMetaBlock.fromEncodedSmf(chunkData);
          message.binaryMetadataChunk = binaryMeta;
          if (binaryMeta.type === 0) {
            // we have SDT JMS metadata
            adaptBinaryMetaToMessage(binaryMeta, message);
          }
          break;
        }
      case ContentSummaryType.XML_META:
        message._setXmlMetadata(chunkData);
        break;
      case ContentSummaryType.XML_PAYLOAD:
        message._setXmlContentInternal(chunkData);
        break;
      default:
        LOG_ERROR(("Unhandled ContentSummaryType: " + (ContentSummaryType.describe(currentChunk.type))));
    }
  }
}

function decodeCompoundMessage(data, pos) {
  var header = parseSMFAt(data, pos);
  if (!header) {
    /* #stripped LOG_DEBUG('decodeCompoundMessage: SMF parsing failed') */

    return null;
  }

  // the parser determined there was a full SMF message
  var payloadPosition = pos + header.headerLength;
  var payloadLen = header.payloadLength;
  var message;
  switch (header.smf_protocol) {
    case SMFProtocol.TSESSION:
      message = parseTsSmfMsgAt(data, payloadPosition, header);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.TRMSG:
      message = new SolclientMessageLib.Message();
      message._smfHeader = header;
      adaptSmfToMessage(header, message, data, pos);
      /* #stripped LOG_TRACE('Decoded SMF message') */

      return message;

    case SMFProtocol.ADCTRL:
      message = parseAdpAt(data, payloadPosition, payloadLen);
      if (!message) { break; }
      message.smfHeader = header;
      return message;

    case SMFProtocol.CLIENTCTRL:
      message = parseCCAt(data, payloadPosition, payloadLen);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.SMP:
      message = parseSMPAt(data, payloadPosition);
      if (!message) { break; }

      message.smfHeader = header;
      return message;

    case SMFProtocol.KEEPALIVE:
    case SMFProtocol.KEEPALIVEV2:
      message = new KeepAliveMessage();
      message.smfHeader = header;
      /* #stripped LOG_TRACE('Decoded keep alive response') */

      return message;

    default:
      LOG_ERROR("Unknown protocol: 0x" + (formatHexString(header.smf_protocol)) + ", " +
                "dump message content: \n" + (DebugLib.Debug.formatDumpBytes(data.substring(pos,
                                                              header.messageLength),
                                               true, 0)));
      break;
  }
  return null;
}

var Decode = {
  decodeCompoundMessage: decodeCompoundMessage,
};

module.exports.Decode = Decode;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var ref = __webpack_require__(3);
var Base64 = ref.Base64;
var Bits = ref.Bits;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(13);
var BinaryMetaBlock = ref$1.BinaryMetaBlock;
var SMFHeader = ref$1.SMFHeader;
var SMPMessage = ref$1.SMPMessage;
var ref$2 = __webpack_require__(7);
var Check = ref$2.Check;
var ref$3 = __webpack_require__(13);
var ClientCtrlMessage = ref$3.ClientCtrlMessage;
var KeepAliveMessage = ref$3.KeepAliveMessage;
var AdProtocolMessage = ref$3.AdProtocolMessage;
var ref$4 = __webpack_require__(10);
var SDTCodec = ref$4.Codec;
var ref$5 = __webpack_require__(120);
var ContentSummaryElement = ref$5.ContentSummaryElement;
var ref$6 = __webpack_require__(45);
var ContentSummaryType = ref$6.ContentSummaryType;
var ref$7 = __webpack_require__(5);
var DestinationType = ref$7.DestinationType;
var ref$8 = __webpack_require__(118);
var encAdp = ref$8.encAdp;
var ref$9 = __webpack_require__(119);
var encCC = ref$9.encCC;
var ref$10 = __webpack_require__(2);
var ErrorSubcode = ref$10.ErrorSubcode;
var OperationError = ref$10.OperationError;
var ref$11 = __webpack_require__(0);
var Lazy = ref$11.Lazy;
var ref$12 = __webpack_require__(1);
var LOG_TRACE = ref$12.LOG_TRACE;
var LOG_INFO = ref$12.LOG_INFO;
var ref$13 = __webpack_require__(76);
var ParamParse = ref$13.ParamParse;
var ref$14 = __webpack_require__(122);
var PriorityUserCosMap = ref$14.PriorityUserCosMap;
var ref$15 = __webpack_require__(10);
var SDTField = ref$15.SDTField;
var SDTFieldType = ref$15.SDTFieldType;
var SDTMapContainer = ref$15.SDTMapContainer;
var SDTStreamContainer = ref$15.SDTStreamContainer;
var ref$16 = __webpack_require__(78);
var SMFParameterType = ref$16.SMFParameterType;
var ref$17 = __webpack_require__(22);
var SMFProtocol = ref$17.SMFProtocol;
var ref$18 = __webpack_require__(123);
var SMP = ref$18.SMP;

var base64Encode = Base64.encode;
var setBits = Bits.set;
var int8ToStr = Convert.int8ToStr;
var int16ToStr = Convert.int16ToStr;
var int24ToStr = Convert.int24ToStr;
var int32ToStr = Convert.int32ToStr;
var int64ToStr = Convert.int64ToStr;
var lazyValue = Lazy.lazyValue;
var encContentSummary = ParamParse.encContentSummary;
var encDeliveryMode = ParamParse.encDeliveryMode;
var encLightSMFParam = ParamParse.encLightSMFParam;
var encodeSMFParam = ParamParse.encodeSMFParam;
var encodeSingleElement = SDTCodec.encodeSingleElement;
var encSmp = SMP.encSmp;

var priorityForUserCos = lazyValue(function () { return new PriorityUserCosMap().forward; });

function addContentElementToArrays(csumm, payloadArray, dataChunk, cstype) {
  if (Check.anything(dataChunk) && dataChunk.length > 0) {
    var cse = new ContentSummaryElement(cstype, NaN, dataChunk.length);
    csumm.push(cse);
    payloadArray.push(dataChunk);
  }
}

function addToMapIfPresent(headerMap, key, type, value) {
  if (Check.anything(value)) {
    headerMap.addField(key, SDTField.create(type, value));
  }
}

function adaptMessageToBinaryMeta(message) {
  // solace header map
  var headerMap = new SDTMapContainer();
  addToMapIfPresent(headerMap, 'ci', SDTFieldType.STRING, message.getCorrelationId());
  addToMapIfPresent(headerMap, 'mi', SDTFieldType.STRING, message.getApplicationMessageId());
  addToMapIfPresent(headerMap, 'mt', SDTFieldType.STRING, message.getApplicationMessageType());
  addToMapIfPresent(headerMap, 'rt', SDTFieldType.DESTINATION, message.getReplyTo());
  addToMapIfPresent(headerMap, 'si', SDTFieldType.STRING, message.getSenderId());
  addToMapIfPresent(headerMap, 'sn', SDTFieldType.INT64, message.getSequenceNumber());
  addToMapIfPresent(headerMap, 'ts', SDTFieldType.INT64, message.getSenderTimestamp());
  addToMapIfPresent(headerMap, 'ex', SDTFieldType.INT64, message.getGMExpiration());

  // container map: solace headers + user prop map
  var sdtMap = new SDTMapContainer();
  if (message.getUserPropertyMap()) {
    sdtMap.addField('p', SDTField.create(SDTFieldType.MAP, message.getUserPropertyMap()));
  }
  if (headerMap.getKeys().length > 0) {
    sdtMap.addField('h', SDTField.create(SDTFieldType.MAP, headerMap));
  }

  var encodedSdtPayload = null;
  var preambleByte0 = 0;
  switch (message.getType()) {
    case MessageLib.MessageType.BINARY:
      preambleByte0 |= 0x80;
      break;
    case MessageLib.MessageType.MAP:
      preambleByte0 |= 0x0A;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    case MessageLib.MessageType.STREAM:
      preambleByte0 |= 0x0B;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    case MessageLib.MessageType.TEXT:
      preambleByte0 |= 0x07;
      encodedSdtPayload = encodeSingleElement(message._structuredContainer);
      if (encodedSdtPayload) {
        message._setBinaryAttachment(encodedSdtPayload);
      }
      break;
    default:
      LOG_INFO(("Unhandled messageType: " + (message.getType())));
      break;
  }
  var preambleByte1 = message.isReplyMessage() ? 0x80 : 0;
  var sdtPreamble = SDTField.create(SDTFieldType.BYTEARRAY,
                                      String.fromCharCode(preambleByte0, preambleByte1));

  // Putting it all together: a stream with the preamble and map
  var sdtStreamContainer = new SDTStreamContainer();
  sdtStreamContainer.addField(sdtPreamble);
  sdtStreamContainer.addField(SDTField.create(SDTFieldType.MAP, sdtMap));

  var binaryMeta = new BinaryMetaBlock();
  binaryMeta.type = 0;
  binaryMeta.payload = encodeSingleElement(SDTField.create(SDTFieldType.STREAM,
                                                           sdtStreamContainer));
  message.binaryMetadataChunk = binaryMeta;
}


function adaptMessageToSmf(message, smfHeaderIn) {
  var smfHeader = smfHeaderIn;
  var deliveryMode = message.getDeliveryMode();

  smfHeader.smf_dto = message.isDeliverToOne();
  smfHeader.pm_deliverymode = deliveryMode;
  smfHeader.smf_adf = deliveryMode === MessageLib.MessageDeliveryModeType.DIRECT ? 0 : 1;
  smfHeader.smf_di = message.isDiscardIndication();
  smfHeader.smf_elidingEligible = message.isElidingEligible();
  smfHeader.smf_deadMessageQueueEligible = message.isDMQEligible();
  smfHeader.pm_ad_flowid = message.getFlowId();
  smfHeader.pm_ad_publisherid = message.getPublisherId();
  smfHeader.pm_ad_publishermsgId = message.getPublisherMessageId();
  smfHeader.pm_ad_msgid = message.getGuaranteedMessageId();
  smfHeader.pm_ad_prevmsgid = message.getGuaranteedPreviousMessageId();
  smfHeader.pm_ad_ttl = message.getTimeToLive();
  smfHeader.pm_ad_ackimm = message.isAcknowledgeImmediately();
  smfHeader.pm_ad_redelflag = message.isRedelivered();

  var dest = message.getDestination();
  if (dest) {
    smfHeader.pm_tr_topicname_bytes = dest.getBytes();
    if (dest.type === DestinationType.QUEUE ||
        dest.type === DestinationType.TEMPORARY_QUEUE) {
      var offset = dest.offset;
      smfHeader.pm_queue_len = smfHeader.pm_tr_topicname_bytes.length - offset;
      smfHeader.pm_queue_offset = offset;
    }
  }

  // Setup user properties, header properties, msgtype
  if (message.getCorrelationId() ||
      message.getApplicationMessageId() ||
      message.getApplicationMessageType() ||
      message.getReplyTo() ||
      message.getSenderId() ||
      message.getSequenceNumber() ||
      message.getSenderTimestamp() ||
      message.getUserPropertyMap() ||
      message.isReplyMessage() ||
      (message.getType() !== MessageLib.MessageType.BINARY)) {
    // add SDT binary metadata
    adaptMessageToBinaryMeta(message);
  }

  smfHeader.smf_priority = priorityForUserCos.value.get(message.getUserCos());

  if (message.getPriority() !== undefined
    && typeof message.getPriority() === 'number'
    && message.getPriority() <= 255
    && message.getPriority() >= 0) {
    smfHeader.pm_msg_priority = message.getPriority();
  } else {
    smfHeader.pm_msg_priority = null;
  }

  var userData = message.getUserData();
  smfHeader.pm_userdata = (userData === null || userData === undefined)
    ? null
    : message.getUserData();

  // Build array of ContentSummaryElements
  var csumm = [];
  var payload = [];
  addContentElementToArrays(csumm, payload,
                            message.getXmlMetadata(), ContentSummaryType.XML_META);
  addContentElementToArrays(csumm, payload,
                            message.getXmlContent(), ContentSummaryType.XML_PAYLOAD);
  addContentElementToArrays(csumm, payload,
                            message.getBinaryAttachment(), ContentSummaryType.BINARY_ATTACHMENT);

  var binaryMeta = message.binaryMetadataChunk;
  if (binaryMeta !== null) {
    var binaryMetaSMF = binaryMeta.asEncodedSmf();
    var MAX_24BITS = 16777215;
    if (binaryMetaSMF.length > MAX_24BITS) {
      /* #stripped LOG_TRACE(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`) */

      throw new OperationError(("binary-meta data (" + (binaryMetaSMF.length) + ") over the " + MAX_24BITS + " limit"), ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    } else {
      addContentElementToArrays(csumm, payload, binaryMetaSMF, ContentSummaryType.BINARY_METADATA);
    }
  }
  if (csumm.length === 0 ||
      (csumm.length === 1 && csumm[0].type === ContentSummaryType.BINARY_ATTACHMENT)) {
    // NULL or RAW payload (no content-summary)
    //  Was this here to invert the condition?
    // LOG_TRACE('NULL or RAW payload (no content-summary)');
  } else {
    smfHeader.pm_content_summary = csumm;
  }

  var payloadBytes = payload.join('');
  smfHeader.payload = payloadBytes;
}

/**
 * Creates an array of all values that fit in the given number of bits.
 * e.g. bitRange(1) => [0, 1], bitRange(2) => [0, 1, 2, 3]
 * @param {Number} bits The number of bits in the range
 * @returns {Number} All values that fit in that number of bits
 * @private
 */
var bitRange = function (bits) { return Array.from(Array(Math.pow(2, bits))).map(function (el, i) { return i; }); };
var maskValues = function (shift, bits) { return bitRange(bits).map(function (val) { return setBits(0, val, shift, bits); }); };
var DI_BIT = maskValues(31, 1);
var ELIDING_ELIGIBLE_BIT = maskValues(30, 1);
var DTO_BIT = maskValues(29, 1);
var ADF_BIT = maskValues(28, 1);
var DMQE_BIT = maskValues(27, 1);
var VERSION_BITS = maskValues(24, 3);
var UH_BITS = maskValues(22, 2);
var PROTOCOL_BITS = maskValues(16, 6);
var PRIORITY_BITS = maskValues(12, 4);
var TTL_BITS = maskValues(0, 8);
var QT_OFFSET_BYTES = maskValues(8, 8);
var QT_LEN_BYTES = maskValues(0, 8);

function encodeSMF(header) {
  // First 4 bytes: protocol, ttl, etc
  var w1 = 0;

  // PERF: single expression to make w1 const
  w1 |= DI_BIT[header.smf_di && 1 || 0];
  w1 |= ELIDING_ELIGIBLE_BIT[header.smf_elidingEligible && 1 || 0];
  w1 |= DTO_BIT[header.smf_dto && 1 || 0];
  w1 |= ADF_BIT[header.smf_adf && 1 || 0];
  w1 |= DMQE_BIT[header.smf_deadMessageQueueEligible && 1 || 0];
  w1 |= VERSION_BITS[header.smf_version || 0];
  w1 |= UH_BITS[header.smf_uh || 0];
  w1 |= PROTOCOL_BITS[header.smf_protocol || 0];
  w1 |= PRIORITY_BITS[header.smf_priority || 0];
  w1 |= TTL_BITS[header.smf_ttl || 0]; // PERF: or set w1 to ttl initially.

  var params = [];
  // Encode all standard SMF parameters
  // Topic name and queue/topic offsets are supposed to come first
  if (header.pm_tr_topicname_bytes) {
    params.push(encodeSMFParam(2, SMFParameterType.TR_TOPICNAME,
                               ("" + (header.pm_tr_topicname_bytes))));
  }
  if (header.pm_queue_len) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_QUEUE_NAME_OFFSET,
                                 int16ToStr(QT_OFFSET_BYTES[header.pm_queue_offset] |
                                            QT_LEN_BYTES[header.pm_queue_len])));
  }
  if (header.pm_topic_len) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_TOPIC_NAME_OFFSET,
                                 int16ToStr(QT_OFFSET_BYTES[header.pm_topic_offset] |
                                            QT_OFFSET_BYTES[header.pm_topic_len])));
  }

  if (header.pm_corrtag !== null && header.pm_corrtag !== undefined) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_CORRELATION,
                                 int24ToStr(header.pm_corrtag)));
  }
  if (header.pm_ad_ackimm) {
    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_ACK_IMMEDIATELY,
                                 ''));
  }

  if (header.pm_msg_priority !== null) {
    params.push(encodeSMFParam(0, SMFParameterType.MESSAGEPRIORITY,
                               int8ToStr(header.pm_msg_priority)));
  }
  if (header.pm_userdata !== null && header.pm_userdata !== '') {
    params.push(encodeSMFParam(0, SMFParameterType.USERDATA,
                               header.pm_userdata));
  }
  if (header.pm_username) {
    // do a sloppy base64 (no newlines)
    params.push(encodeSMFParam(0, SMFParameterType.USERNAME,
                               base64Encode(header.pm_username)));
  }
  if (header.pm_password) {
    // do a sloppy base64 (no newlines)
    params.push(encodeSMFParam(0, SMFParameterType.PASSWORD,
                               base64Encode(header.pm_password)));
  }
  if (header.pm_respcode) {
    // not useful API->router
    params.push(encodeSMFParam(0, SMFParameterType.RESPONSE,
                               int32ToStr(header.pm_respcode) + header.pm_respstr));
  }

  if (header.pm_deliverymode !== null) {
    params.push(encodeSMFParam(0, SMFParameterType.DELIVERY_MODE,
                               encDeliveryMode(header.pm_deliverymode)));
  }

  if (header.pm_ad_msgid !== undefined) {
    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_MESSAGE_ID,
                               int64ToStr(header.pm_ad_msgid)));
    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_PREVMESSAGE_ID,
                               int64ToStr(header.pm_ad_prevmsgid)));
  }

  if (header.pm_ad_flowid) {
    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_FLOWID,
                               int32ToStr(header.pm_ad_flowid)));
  }

  // header.pm_ad_redelflag
  // Ad redelivered
  if (header.pm_ad_redelflag) {
    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_REDELIVERED_FLAG, undefined));
  }
  // header.pm_ad_flowredelflag

  if (header.pm_ad_ttl !== undefined) {
    params.push(encodeSMFParam(0, SMFParameterType.AD_TIMETOLIVE,
                               int64ToStr(header.pm_ad_ttl)));
  }

  // sequence number?

  if (header.pm_ad_publisherid) {
    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_ID,
                               int32ToStr(header.pm_ad_publisherid)));
  }

  if (header.pm_ad_publisherMsgId) {
    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_MSGID,
                               int64ToStr(header.pm_ad_publisherMsgId)));
  }

  // transactions: ackmessageid, transactionid, transactionflags

  if (header.pm_content_summary) {
    params.push(encodeSMFParam(2, SMFParameterType.MESSAGE_CONTENT_SUMMARY,
                               encContentSummary(header.pm_content_summary)));
  }
  // done common SMF parameters!

  // compute header size and full message size
  var encodedParams = params.join('');
  var hdrlen = 12 + encodedParams.length;
  var msglen = hdrlen + header.payloadLength;

  // ? Already encoded. Why bother?
  header.setMessageSizes(hdrlen, header.payloadLength);

  return (
    int32ToStr(w1) +
    int32ToStr(hdrlen) +
    int32ToStr(msglen) +
    encodedParams
  );
}

function encodeCompoundMessage(msg) {
  var payload = '';
  if (msg instanceof MessageLib.Message) {
    if (!msg.smfHeader) {
      msg.smfHeader = new SMFHeader(SMFProtocol.TRMSG, 255);
    }
    adaptMessageToSmf(msg, msg._smfHeader);
    payload = msg._smfHeader.payload;
  } else if (msg instanceof ClientCtrlMessage) {
    payload = encCC(msg);
  } else if (msg instanceof SMPMessage) {
    payload = encSmp(msg);
  } else if (msg instanceof KeepAliveMessage) {
    /* #stripped LOG_TRACE('Skipping retrieve payload as there is none in a KeepAliveMessage') */

  } else if (msg instanceof AdProtocolMessage) {
    payload = encAdp(msg);
  }
  var header = msg.smfHeader;
  header.setPayloadSize(payload.length);
  var encodedHeader = encodeSMF(header);
  return encodedHeader + payload;
}

var Encode = {
  encodeCompoundMessage: encodeCompoundMessage,
  encodeSMF: encodeSMF,
};

module.exports.Encode = Encode;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Created by rpaulson on 06/02/2017.
 */
var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Long = ref$1.Long;
var ref$2 = __webpack_require__(5);
var DestinationType = ref$2.DestinationType;
var ref$3 = __webpack_require__(1);
var LOG_TRACE = ref$3.LOG_TRACE;
var ref$4 = __webpack_require__(2);
var OperationError = ref$4.OperationError;
var ref$5 = __webpack_require__(18);
var QueueAccessType = ref$5.QueueAccessType;
var QueueDiscardBehavior = ref$5.QueueDiscardBehavior;
var ref$6 = __webpack_require__(18);
var QueuePermissions = ref$6.QueuePermissions;
var ref$7 = __webpack_require__(126);
var SMFAdProtocolMessageType = ref$7.SMFAdProtocolMessageType;
var ref$8 = __webpack_require__(127);
var SMFAdProtocolParam = ref$8.SMFAdProtocolParam;
var ref$9 = __webpack_require__(32);
var SMFHeader = ref$9.SMFHeader;
var ref$10 = __webpack_require__(77);
var SMFParameter = ref$10.SMFParameter;
var ref$11 = __webpack_require__(22);
var SMFProtocol = ref$11.SMFProtocol;
var ref$12 = __webpack_require__(125);
var SMFUH = ref$12.SMFUH;
var ref$13 = __webpack_require__(4);
var StringUtils = ref$13.StringUtils;

var strToInt8 = Convert.strToInt8;
var strToInt16 = Convert.strToInt16;
var strToUInt32 = Convert.strToUInt32;
var strToUInt64 = Convert.strToUInt64;

var stripNullTerminate = StringUtils.stripNullTerminate;

// QUEUENAME/TOPICNAME
var EndpointTypeToParam = {};
EndpointTypeToParam[DestinationType.TOPIC] = SMFAdProtocolParam.DTENAME;
EndpointTypeToParam[DestinationType.QUEUE] = SMFAdProtocolParam.QUEUENAME;

var QUEUE_PERMISSIONS_TO_BITS = {};
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.NONE] = 0x0000;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.READ_ONLY] = 0x0001;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.CONSUME] = 0x0003;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.MODIFY_TOPIC] = 0x0007;
QUEUE_PERMISSIONS_TO_BITS[QueuePermissions.DELETE] = 0x000f;

var ACCESS_TYPE_INT_TO_ENUM = {
  0x01: QueueAccessType.EXCLUSIVE,
  0x02: QueueAccessType.NONEXCLUSIVE,
};

var DISCARD_ENUM_TO_VALUE = {};
DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF] = 0x01;
DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_ON] = 0x02;

/**
 * @internal
 */
var AdProtocolMessage = (function (BaseMessage) {
  function AdProtocolMessage(messageType, version) {
    if ( messageType === void 0 ) messageType = 0;
    if ( version === void 0 ) version = 3;

    BaseMessage.call(this, new SMFHeader(SMFProtocol.ADCTRL, 1));

    // Field: msgtype
    this.msgType = messageType;

    // Field: version
    this.version = version;
  }

  if ( BaseMessage ) AdProtocolMessage.__proto__ = BaseMessage;
  AdProtocolMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  AdProtocolMessage.prototype.constructor = AdProtocolMessage;

  AdProtocolMessage.prototype._readParameter = function _readParameter (paramtype, decoder) {
    if ( decoder === void 0 ) decoder = null;

    var param = this.getParameter(paramtype);
    if (param === undefined) { return undefined; }
    var value = param.getValue();
    return decoder ? decoder(value) : value;
  };

  /**
   * @returns {?QueueAccessType} The access type, if present
   */
  AdProtocolMessage.prototype.getAccessType = function getAccessType () {
    var param = this._readParameter(SMFAdProtocolParam.ACCESSTYPE, strToInt8);
    return ACCESS_TYPE_INT_TO_ENUM[param];
  };

  /**
   * @returns {?Boolean} The active flow indication, if present
   */
  AdProtocolMessage.prototype.getActiveFlow = function getActiveFlow () {
    return this._readParameter(SMFAdProtocolParam.ACTIVE_FLOW_INDICATION, strToInt8);
  };

  /**
   * @returns {?QueueDiscardBehavior} The discard behavior for the endpoint, if present
   */
  AdProtocolMessage.prototype.getQueueDiscardBehavior = function getQueueDiscardBehavior () {
    var param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16);
    // Get NotifySender flag
    var masked = (param & 0x3000) >> 12;
    if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF]) {
      return QueueDiscardBehavior.NOTIFY_SENDER_OFF;
    }
    return QueueDiscardBehavior.NOTIFY_SENDER_ON;
  };

  /**
   * @returns {?Number} The endpoint ID, if present
   */
  AdProtocolMessage.prototype.getEndpointId = function getEndpointId () {
    return this._readParameter(SMFAdProtocolParam.ENDPOINT_ID, strToUInt32);
  };

  /**
   * @returns {?Number} Whether endpoint respects TTL
   */
  AdProtocolMessage.prototype.getRespectsTTL = function getRespectsTTL () {
    return !!this._readParameter(SMFAdProtocolParam.EP_RESPECTS_TTL, strToInt8);
  };

  /**
   * @returns {?String} The router-assigned flow name, if present
   */
  AdProtocolMessage.prototype.getFlowName = function getFlowName () {
    return this._readParameter(SMFAdProtocolParam.FLOWNAME, stripNullTerminate);
  };

  /**
   * @returns {?Number} The router-assigned flow ID, if present
   */
  AdProtocolMessage.prototype.getFlowId = function getFlowId () {
    return this._readParameter(SMFAdProtocolParam.FLOWID, strToUInt32);
  };

  /**
   * @returns {?String} The UTF-8 encoded, null terminated endpoint name
   */
  AdProtocolMessage.prototype.getTopicEndpointBytes = function getTopicEndpointBytes () {
    return this._readParameter(SMFAdProtocolParam.DTENAME);
  };

  /**
   * @returns {?QueuePermissions} The granted permissions for the flow, if present
   */
  AdProtocolMessage.prototype.getGrantedPermissions = function getGrantedPermissions () {
    var permissions = this._readParameter(SMFAdProtocolParam.GRANTED_PERMISSIONS, strToUInt32);
    var result;
    Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(function (key) {
      if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
        result = key;
      }
    });
    return result;
  };

  /**
   * @returns {?Long} The last message ID acked, if present
   */
  AdProtocolMessage.prototype.getLastMsgIdAcked = function getLastMsgIdAcked () {
    return this._readParameter(SMFAdProtocolParam.LASTMSGIDACKED,
                               strToUInt64);
  };

  /**
   * @returns {?Long} The last message ID received, if present
   */
  AdProtocolMessage.prototype.getLastMsgIdReceived = function getLastMsgIdReceived () {
    return this._readParameter(SMFAdProtocolParam.LASTMSGIDRECEIVED,
                               strToUInt64);
  };

  /**
   * @returns {?Number} The publisher ID, if present
   */
  AdProtocolMessage.prototype.getPublisherId = function getPublisherId () {
    return this._readParameter(SMFAdProtocolParam.PUBLISHER_ID, strToUInt32);
  };

  /**
   * @returns {?Number} Whether we want flow change notifications, if present
   */
  AdProtocolMessage.prototype.getWantFlowChangeNotify = function getWantFlowChangeNotify () {
    return !!this._readParameter(SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, strToInt8);
  };

  /**
   * @returns {?Number} The Window parameter, if present
   */
  AdProtocolMessage.prototype.getWindow = function getWindow () {
    return this._readParameter(SMFAdProtocolParam.WINDOW, strToInt8);
  };

  /**
   * @returns {?Number} The max unacked messages parameter, if present
   */
  AdProtocolMessage.prototype.getMaxUnackedMessages = function getMaxUnackedMessages () {
    return this._readParameter(SMFAdProtocolParam.MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW,
                               strToUInt32);
  };

  /**
   * Creates a CLOSEPUBFLOW message
   * @param {Number} flowId The publisher flow to close
   * @param {Number} correlationTag The correlation tag for the request
   * @returns {AdProtocolMessage} The newly created message
   * @internal
   * @static
   */
  AdProtocolMessage.getCloseMessagePublisher = function getCloseMessagePublisher (flowId,
                                  correlationTag) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.CLOSEPUBFLOW);

    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.FLOWID,
                                          flowId));
    return message;
  };

  /**
   * Returns an AdProtocolMessage that describes a publisher open-flow request.
   * @static
   * @param {?Long} lastMsgIdAcked Last message ID acked, if re-opening
   * @param {?Long} lastMsgIdSent Last message ID sent, if re-opening
   * @param {Number} windowSize Desired window size
   * @param {String} flowName Last flow name in use, if re-opening
   * @param {Number} correlationTag Correlation tag for the request
   * @returns {solace.AdProtocolMessage} The OPENPUBFLOW message
   * @internal
   */
  AdProtocolMessage.getOpenMessagePublisher = function getOpenMessagePublisher (
            lastMsgIdAcked,
            lastMsgIdSent,
            windowSize,
            flowName,
            correlationTag) {
    var adMsg = new AdProtocolMessage(SMFAdProtocolMessageType.OPENPUBFLOW);

    var smfHeader = adMsg.smfHeader;
    smfHeader.pm_corrtag = correlationTag;

    if (lastMsgIdAcked !== undefined) {
      adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.LASTMSGIDACKED,
                                          lastMsgIdAcked));
    }
    if (lastMsgIdSent !== undefined) {
      adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.LASTMSGIDSENT,
                                          lastMsgIdSent));
    }

    adMsg.addParameter(new SMFParameter(SMFUH.REJECT,
                                        SMFAdProtocolParam.WINDOW,
                                        windowSize));

    adMsg.addParameter(new SMFParameter(SMFUH.IGNORE,
                                        SMFAdProtocolParam.FLOWNAME,
                                        flowName || ''));

    /* #stripped LOG_TRACE(`Create open publisher: lastMsgIdAcked=${lastMsgIdAcked} lastMsgIdSent=${lastMsgIdSent} window=${windowSize} flowName=${flowName || '(null)'}`) */


    return adMsg;
  };

  /**
   * Returns an AdProtocolMessage that describes a subscriber (MessageConsumer) bind request.
   * @static
   * @param {solace.QueueDescriptor} queueDescriptor The endpoint descriptor for the bind request
   * @param {?solace.QueueProperties} queueProperties The properties for the bind request
   * @param {solace.Destination} endpoint The endpoint for the bind request
   * @param {?solace.Topic} topicSubscription The topic endpoint
   * @param {String} correlationTag The correlation tag for the request
   * @param {Number} windowSize The desired window size
   * @param {Boolean} [noLocal=false] If true, local publisher messages are not delivered
   * @param {Boolean} [wantFlowChangeUpdate] default is true if destination is a {solace.Queue}
   * @param {Long} [lastMsgIdAcked=Long.UZERO] Last message ID acked, if re-binding
   * @param {Long} [lastMsgIdReceived=Long.UZERO] Last message ID received, if re-binding
   * @returns {solace.AdProtocolMessage} The BIND message
   * @internal
   */
  AdProtocolMessage.getOpenMessageConsumer = function getOpenMessageConsumer (queueDescriptor,
                                queueProperties,
                                endpoint,
                                topicSubscription,
                                correlationTag,
                                windowSize,
                                noLocal,
                                wantFlowChangeUpdate,
                                lastMsgIdAcked,
                                lastMsgIdReceived) {
    if ( lastMsgIdAcked === void 0 ) lastMsgIdAcked = Long.UZERO;
    if ( lastMsgIdReceived === void 0 ) lastMsgIdReceived = Long.UZERO;

    /*
    QUEUE FLOW                                      TE FLOW

    {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
    [Correlation Tag Parameter]                     [Correlation Tag Parameter]
    {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}

    {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
    ***                                             {AssuredCtrl TopicName Parameter}
    [AssuredCtrl Last Message Id Acked Parameter]   ***
    [AssuredCtrl Last Message Id Recv'd Parameter]  ***
    {AssuredCtrl Transport Window Size Parameter}   {AssuredCtrl Transport Window Size Parameter}
    [AssuredCtrl Durability Parameter]              [AssuredCtrl Durability Parameter]
    [AssuredCtrl Message Selector Parameter]        [AssuredCtrl Message Selector Parameter]
    [AssuredCtrl FlowType Parameter]                [AssuredCtrl FlowType Parameter]
    [AssuredCtrl Selector Parameter]                [AssuredCtrl Selector Parameter]
    [AssuredCtrl AllOthersPermissions Parameter]    [AssuredCtrl AllOthersPermissions Parameter]
    [AssuredCtrl EndpointQuotaMB Parameter]         [AssuredCtrl EndpointQuotaMB Parameter]
    [AssuredCtrl EndpointMaxMessageSize Parameter]  [AssuredCtrl EndpointMaxMessageSize Parameter]
    [AssuredCtrl TransactedSessionId Parameter]     [AssuredCtrl TransactedSessionId Parameter]
    [AssuredCtrl NoLocal Parameter]                 [AssuredCtrl NoLocal Parameter]
    [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
    [AssuredCtrl qEndpointBehaviourFlags Parameter] [AssuredCtrl qEndpointBehaviourFlags Parameter]
    [AssuredCtrl MaxRedelivery Parameter]           [AssuredCtrl MaxRedelivery Parameter]

    */
    var durable = queueDescriptor.durable;
    var endpointBytes = endpoint.bytes;
    var endpointType = endpoint.type;

    // {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
    // [Correlation Tag Parameter]                     [Correlation Tag Parameter]
    // {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.BIND);
    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    // {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
    var endpointTypeParam = EndpointTypeToParam[endpointType];
    if (endpointTypeParam === undefined) { throw new OperationError('Unknown destination type'); }
    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      endpointTypeParam,
      endpointBytes
    ));

    // ***                                             {AssuredCtrl TopicName Parameter}
    if (topicSubscription) {
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.TOPICNAME,
        topicSubscription.bytes
      ));
    }

    if (endpointType === DestinationType.QUEUE) {
      //     [AssuredCtrl Last Message Id Acked Parameter]   ***
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.LASTMSGIDACKED,
        lastMsgIdAcked
      ));
      //     [AssuredCtrl Last Message Id Recv'd Parameter]  ***
      message.addParameter(new SMFParameter(
        SMFUH.IGNORE,
        SMFAdProtocolParam.LASTMSGIDRECEIVED,
        lastMsgIdReceived
      ));
    }

    // {AssuredCtrl Transport Window Size Parameter}
    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.WINDOW,
      windowSize
    ));

    // [AssuredCtrl Durability Parameter]
    message.addParameter(new SMFParameter(
      SMFUH.IGNORE,
      SMFAdProtocolParam.EP_DURABLE,
      durable
    ));

    // Omit Message Selector
    // Omit FlowType, CONSUMER assumed (not BROWSER currently)
    // Omit TransactedSessionId

    if (queueProperties) {
      var discardBehavior = queueProperties.discardBehavior;
      var maxMessageRedelivery = queueProperties.maxMessageRedelivery;
      var maxMessageSize = queueProperties.maxMessageSize;
      var permissions = queueProperties.permissions;
      var quotaMB = queueProperties.quotaMB;
      var respectsTTL = queueProperties.respectsTTL;

      // [AssuredCtrl AllOthersPermissions Parameter]
      if (permissions && QUEUE_PERMISSIONS_TO_BITS[permissions]) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_ALLOTHER_PERMISSION,
          QUEUE_PERMISSIONS_TO_BITS[permissions]
        ));
      }

      // [AssuredCtrl EndpointQuotaMB Parameter]
      if (quotaMB !== null && quotaMB !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_QUOTA,
          quotaMB
        ));
      }

      // [AssuredCtrl EndpointMaxMessageSize Parameter]
      if (maxMessageSize !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_MAX_MSGSIZE,
          maxMessageSize
        ));
      }

      var flags = 0x0000;
      if (discardBehavior !== null && discardBehavior !== undefined) {
        var discardBehaviorValue = DISCARD_ENUM_TO_VALUE[discardBehavior];
        flags |= (discardBehaviorValue << 12);
        // Omit cutThrough, << 14
      }
      if (flags /* is nonzero */) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_BEHAVIOUR,
          flags
        ));
      }

      if (maxMessageRedelivery !== undefined) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.MAX_REDELIVERY,
          maxMessageRedelivery
        ));
      }

      if (respectsTTL /* is true */) {
        message.addParameter(new SMFParameter(
          SMFUH.IGNORE,
          SMFAdProtocolParam.EP_RESPECTS_TTL,
          0x1
        ));
      }
    }

    if (noLocal /* is true */) {
      // [AssuredCtrl NoLocal Parameter]
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.NOLOCAL,
        0x1
      ));
    }

    if (wantFlowChangeUpdate /* is true */) {
      // [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
      message.addParameter(new SMFParameter(
        SMFUH.IGNORE,
        SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY,
        0x1
      ));
    }

    return message;
  };

  /**
   * Creates an UNBIND request
   * @param {Number} flowId The flow ID to unbind
   * @param {Number} correlationTag The correlation tag for the request
   * @param {?Long} lastMessageIdAcked The last message ID marked as locally acked
   * @returns {AdProtocolMessage} The new UNBIND request
   * @static
   * @internal
   */
  AdProtocolMessage.getCloseMessageConsumer = function getCloseMessageConsumer (flowId,
                                 correlationTag) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);

    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(SMFUH.REJECT,
                                          SMFAdProtocolParam.FLOWID,
                                          flowId));
    // linger: assume no

    return message;
  };

  AdProtocolMessage.getDTEUnsubscribeMessage = function getDTEUnsubscribeMessage (correlationTag,
                                  topic) {
    var message = new AdProtocolMessage(SMFAdProtocolMessageType.UNSUBSCRIBE);
    var header = message.smfHeader;
    header.pm_corrtag = correlationTag;

    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.DTENAME,
      topic.getBytes()
    ));

    return message;
  };

  /**
   * @param {Number} flowId The flow on which to acknowledge messages.
   * @param {?Long} [lastMessageIdAcked=undefined] The transport acknowledges receipt of all
   *  messages up to and including this ID.
   * @param {?Long} [windowSize=undefined] The size to which the flow window should be set.
   * @param {?Array.<Array.<Long>>} [applicationAckRanges=undefined] Low-high ID pairs of
   *  message IDs to acknowledge at the application level. To application ack a single message,
   *  pass `[ [singleMessageId, singleMessageId] ]`.
   * @returns {solace.AdProtocolMessage} A message containing the given parameters.
   * @internal
   * @static
   */
  AdProtocolMessage.getAck = function getAck (flowId,
                lastMessageIdAcked,
                windowSize,
                applicationAckRanges) {
    if ( lastMessageIdAcked === void 0 ) lastMessageIdAcked = undefined;
    if ( windowSize === void 0 ) windowSize = undefined;
    if ( applicationAckRanges === void 0 ) applicationAckRanges = undefined;

    var message = new AdProtocolMessage(SMFAdProtocolMessageType.CLIENTACK);

    message.addParameter(new SMFParameter(
      SMFUH.REJECT,
      SMFAdProtocolParam.FLOWID,
      flowId
    ));

    if (lastMessageIdAcked) {
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.LASTMSGIDACKED,
        lastMessageIdAcked
      ));
    }

    if (windowSize !== undefined && windowSize !== null) {
      // There are two windowSize options; we'll use the legacy one for smaller
      // window sizes
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        (windowSize <= 0xFF) ? SMFAdProtocolParam.WINDOW : SMFAdProtocolParam.TRANSPORT_WINDOW,
        windowSize
      ));
    }

    if (applicationAckRanges && applicationAckRanges.length) {
      if (applicationAckRanges.length > AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
        throw new OperationError('Application ack range count exceeds limit of 64');
      }
      message.addParameter(new SMFParameter(
        SMFUH.REJECT,
        SMFAdProtocolParam.APPLICATION_ACK,
        applicationAckRanges // DANGER: this needs to be encoded immediately, or else deep-cloned
      ));
    }

    return message;
  };

  return AdProtocolMessage;
}(BaseMessage));

AdProtocolMessage.MAX_CLIENT_ACK_RANGES = 64;

module.exports.AdProtocolMessage = AdProtocolMessage;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Bits = ref.Bits;
var Convert = ref.Convert;

var bits = Bits.get;
var int8ToStr = Convert.int8ToStr;
var strToInt8 = Convert.strToInt8;
var int24ToStr = Convert.int24ToStr;
var strToInt32 = Convert.strToInt32;

/**
 * @classdesc
 *
 * BinaryMetaBlock represents a binary metadata block in a TrMsg
 *
 * @private
 */
var BinaryMetaBlock = function BinaryMetaBlock(type, payload) {
  this.type = type;
  this.payload = payload;
};

BinaryMetaBlock.prototype.asEncodedSmf = function asEncodedSmf () {
  var smf = [];
  smf.push(int8ToStr(1));
  smf.push(int8ToStr(this.type));
  smf.push(int24ToStr(this.payload.length));
  smf.push(this.payload);
  return smf.join('');
};

BinaryMetaBlock.fromEncodedSmf = function fromEncodedSmf (strSmf, offset) {
    if ( offset === void 0 ) offset = 0;

  if ((strSmf.length - offset) < 6) {
    return null; // not enough data
  }
  var chunkCount = strToInt8(strSmf.substr(offset, 1));
  var fourbyte = strToInt32(strSmf.substr(offset + 1, 4));
  var type = bits(fourbyte, 24, 8);
  var payloadLen = bits(fourbyte, 0, 24);
  var payloadOffset = chunkCount * 4 + 1;
  var payload = strSmf.substr(offset + payloadOffset, payloadLen);
  return new BinaryMetaBlock(type, payload);
};


module.exports.BinaryMetaBlock = BinaryMetaBlock;


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(21);
var AuthenticationScheme = ref.AuthenticationScheme;
var CapabilityType = ref.CapabilityType;
var MutableSessionProperty = ref.MutableSessionProperty;
var SessionProperties = ref.SessionProperties;
var ref$1 = __webpack_require__(31);
var BaseMessage = ref$1.BaseMessage;
var ref$2 = __webpack_require__(3);
var Bits = ref$2.Bits;
var Convert = ref$2.Convert;
var ref$3 = __webpack_require__(5);
var DestinationType = ref$3.DestinationType;
var DestinationUtil = ref$3.DestinationUtil;
var ref$4 = __webpack_require__(2);
var ErrorSubcode = ref$4.ErrorSubcode;
var OperationError = ref$4.OperationError;
var ref$5 = __webpack_require__(4);
var Process = ref$5.Process;
var StringUtils = ref$5.StringUtils;
var Version = ref$5.Version;
var ref$6 = __webpack_require__(128);
var SMFClientCtrlMessageType = ref$6.SMFClientCtrlMessageType;
var ref$7 = __webpack_require__(129);
var SMFClientCtrlParam = ref$7.SMFClientCtrlParam;
var ref$8 = __webpack_require__(32);
var SMFHeader = ref$8.SMFHeader;
var ref$9 = __webpack_require__(77);
var SMFParameter = ref$9.SMFParameter;
var ref$10 = __webpack_require__(22);
var SMFProtocol = ref$10.SMFProtocol;

var bits = Bits.get;
var setBits = Bits.set;
var strToInt8 = Convert.strToInt8;
var int16ToStr = Convert.int16ToStr;
var strToInt16 = Convert.strToInt16;
var strToInt32 = Convert.strToInt32;
var nullTerminate = StringUtils.nullTerminate;
var stripNullTerminate = StringUtils.stripNullTerminate;
var validateAndEncode = DestinationUtil.validateAndEncode;

var BOOLEAN_CAPS_BITS = [
  CapabilityType.JNDI,
  CapabilityType.COMPRESSION,
  CapabilityType.GUARANTEED_MESSAGE_CONSUME,
  CapabilityType.TEMPORARY_ENDPOINT,
  CapabilityType.GUARANTEED_MESSAGE_PUBLISH,
  CapabilityType.GUARANTEED_MESSAGE_BROWSE,
  CapabilityType.ENDPOINT_MGMT,
  CapabilityType.SELECTOR,
  CapabilityType.ENDPOINT_MESSAGE_TTL,
  CapabilityType.QUEUE_SUBSCRIPTIONS,
  null, // skip obsolete FLOW_RECOVER
  CapabilityType.SUBSCRIPTION_MANAGER,
  CapabilityType.MESSAGE_ELIDING,
  CapabilityType.TRANSACTED_SESSION,
  CapabilityType.NO_LOCAL,
  CapabilityType.ACTIVE_CONSUMER_INDICATION,
  CapabilityType.PER_TOPIC_SEQUENCE_NUMBERING,
  CapabilityType.ENDPOINT_DISCARD_BEHAVIOR,
  CapabilityType.CUT_THROUGH,
  null ];

/**
 * @classdesc ClientCtrlMessage
 * Represents a ClientCtrl request or reply message
 * @private
 */
var ClientCtrlMessage = (function (BaseMessage) {
  function ClientCtrlMessage(messageType) {
    if ( messageType === void 0 ) messageType = 0;

    BaseMessage.call(this, new SMFHeader(SMFProtocol.CLIENTCTRL, 1));

    // Field: msgtype
    this.msgType = messageType;

    // Field: version
    this.version = 1;
  }

  if ( BaseMessage ) ClientCtrlMessage.__proto__ = BaseMessage;
  ClientCtrlMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  ClientCtrlMessage.prototype.constructor = ClientCtrlMessage;

  ClientCtrlMessage.prototype.getP2PTopicValue = function getP2PTopicValue () {
    var p2pParam = this.getParameter(SMFClientCtrlParam.P2PTOPIC);
    if (!p2pParam) {
      return null;
    }
    return stripNullTerminate(p2pParam.getValue());
  };

  ClientCtrlMessage.prototype.getVpnNameInUseValue = function getVpnNameInUseValue () {
    var vpnParam = this.getParameter(SMFClientCtrlParam.MSGVPNNAME);
    if (!vpnParam) {
      return null;
    }
    return stripNullTerminate(vpnParam.getValue());
  };

  ClientCtrlMessage.prototype.getVridInUseValue = function getVridInUseValue () {
    var vridParam = this.getParameter(SMFClientCtrlParam.VRIDNAME);
    if (!vridParam) {
      return null;
    }
    return stripNullTerminate(vridParam.getValue());
  };

  ClientCtrlMessage.prototype.getUserIdValue = function getUserIdValue () {
    var userIdParam = this.getParameter(SMFClientCtrlParam.USERID);
    if (!userIdParam) {
      return null;
    }
    return stripNullTerminate(userIdParam.getValue());
  };

  ClientCtrlMessage.prototype.getRouterCapabilities = function getRouterCapabilities () {
    var caps = [];

    // Parse the composite capabilities parameter
    var capParam = this.getParameter(SMFClientCtrlParam.ROUTER_CAPABILITIES);
    if (capParam) {
      caps = ClientCtrlMessage.prmParseCapabilitiesValue(capParam.getValue(), caps);
    }

    // Parse out the router status strings
    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREVERSION);
    if (capParam) {
      caps[CapabilityType.PEER_SOFTWARE_VERSION] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREDATE);
    if (capParam) {
      caps[CapabilityType.PEER_SOFTWARE_DATE] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.PLATFORM);
    if (capParam) {
      caps[CapabilityType.PEER_PLATFORM] = stripNullTerminate(capParam.getValue());
    }
    capParam = this.getParameter(SMFClientCtrlParam.PHYSICALROUTERNAME);
    if (capParam) {
      caps[CapabilityType.PEER_ROUTER_NAME] = stripNullTerminate(capParam.getValue());
    }
    return caps;
  };


  ClientCtrlMessage.prmGetDtoPriorityValue = function prmGetDtoPriorityValue (dto) {
    if (dto.local === undefined || dto.network === undefined) {
      return false;
    }
    var twobyte = 0;
    twobyte = setBits(twobyte, dto.local, 8, 8);
    twobyte = setBits(twobyte, dto.network, 0, 8);
    return int16ToStr(twobyte);
  };

  ClientCtrlMessage.prmParseDtoPriorityValue = function prmParseDtoPriorityValue (strDtoPriority) {
    var dto = {};
    var twobyte = strToInt16(strDtoPriority.substr(0, 2));
    dto.local = bits(twobyte, 8, 8);
    dto.network = bits(twobyte, 0, 8);
    return dto;
  };

  /*
  strCapabilities: parameter value
  caps: an already existing hash array of CapabilityType
   */
  ClientCtrlMessage.prmParseCapabilitiesValue = function prmParseCapabilitiesValue (strCapabilities, capsIn) {
    var caps = capsIn;
    if (!(strCapabilities && caps)) {
      return false;
    }
    var CT = CapabilityType;
    var pos = 0;

    // parse boolean capabilities
    var boolCapCount = strToInt8(strCapabilities[pos]);
    ++pos;

    // The boolean caps are listed in order as in the documentation,
    // that is from MSB to LSB for each caps byte.
    var capsByte;
    for (var bitIndex = 0; bitIndex < boolCapCount; ++bitIndex) {
      var msbIndex = bitIndex & 0x7;
      if (msbIndex === 0) { // Consume a byte
        capsByte = strToInt8(strCapabilities[pos]);
        ++pos;
      }
      var capsKey = BOOLEAN_CAPS_BITS[bitIndex];
      if (!capsKey) { continue; } // We don't know about this cap
      // BOOLEAN_CAPS_BITS counts left to right,
      // so set caps bits from MSB (bit 7) to LSB (bit 0)
      caps[capsKey] = !!bits(capsByte, 7 - msbIndex, 1);
    }

    // parse non-boolean capabilities
    var sanityLoop = 500;
    for (var i = 0; pos < strCapabilities.length && i < sanityLoop; ++i) {
      var onebyte = strToInt8(strCapabilities[pos]); // type
      pos++;
      var capLen = strToInt32(strCapabilities.substr(pos, 4)) - 5;
      pos += 4;
      var strValue = strCapabilities.substr(pos, capLen);
      pos += capLen;
      switch (onebyte) {
        case 0x00:
          caps[CT.PEER_PORT_SPEED] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        case 0x01:
          caps[CT.PEER_PORT_TYPE] = (strValue.length === 1) ? strToInt8(strValue) : 0;
          break;
        case 0x02:
          caps[CT.MAX_GUARANTEED_MSG_SIZE] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        case 0x03:
          caps[CT.MAX_DIRECT_MSG_SIZE] = (strValue.length === 4) ? strToInt32(strValue) : 0;
          break;
        default:
          // NOOP (unknown cap)
          break;
      }
    }
    return caps;
  };

  ClientCtrlMessage.getLogin = function getLogin (sprop, correlationTag) {
    if (!(sprop instanceof SessionProperties)) {
      return false;
    }

    var cc = new ClientCtrlMessage(SMFClientCtrlMessageType.LOGIN);
    var smfHeader = cc._smfHeader;
    var isClientCert = sprop.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
    smfHeader.pm_corrtag = correlationTag;
    if (sprop.password && !isClientCert) {
      smfHeader.pm_password = sprop.password;
    }
    if (sprop.userName) {
      smfHeader.pm_username = sprop.userName;
    }
    if (sprop.subscriberLocalPriority && sprop.subscriberNetworkPriority) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.DELIVERTOONEPRIORITY,
                                       ClientCtrlMessage.prmGetDtoPriorityValue({
                                         local:   sprop.subscriberLocalPriority,
                                         network: sprop.subscriberNetworkPriority })));
    }
    if (sprop.vpnName && sprop.vpnName.length > 0) {
      cc.addParameter(new SMFParameter(1,
                                       SMFClientCtrlParam.MSGVPNNAME,
                                       nullTerminate(sprop.vpnName)));
    }

    if (sprop.applicationDescription && sprop.applicationDescription.length > 0) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTDESC,
                                       nullTerminate(sprop.applicationDescription)));
    }

    if (sprop.userIdentification && sprop.userIdentification.length > 0) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.USERID,
                                       nullTerminate(sprop.userIdentification)));
    }

    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.CLIENTNAME,
                                     nullTerminate(sprop.clientName)));
    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.PLATFORM,
                                     nullTerminate(((Process.platform) + " - JS API (" + (Version.mode) + ")"))));

    if (sprop.noLocal) {
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.NO_LOCAL,
                                       '\x01'));
    }

    if (isClientCert) {
      cc.addParameter(new SMFParameter(1,
                                       SMFClientCtrlParam.AUTHENTICATION_SCHEME,
                                       '\x01'));
    }

    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.SOFTWAREDATE,
                                     nullTerminate(Version.formattedDate)));
    cc.addParameter(new SMFParameter(0,
                                     SMFClientCtrlParam.SOFTWAREVERSION,
                                     nullTerminate(Version.version)));
    return cc;
  };

  /**
   * Get a CC update message.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property to update
   * @param {String} newValue The new value for the property
   * @param {String} correlationTag The correlation tag for the request
   * @returns {ClientCtrlMessage} The new UPDATE message
   *
   * @private
   */
  ClientCtrlMessage.getUpdate = function getUpdate (mutableSessionProperty, newValue, correlationTag) {
    var cc = new ClientCtrlMessage(SMFClientCtrlMessageType.UPDATE);
    var smfHeader = cc.smfHeader;
    smfHeader.pm_corrtag = correlationTag;
    if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
      var appdesc = (newValue || '').toString().substr(0, 250);
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTDESC,
                                       nullTerminate(appdesc)));
    } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
      var error =
        ClientCtrlMessage.validateClientName(
          newValue,
          function (errorMessage) { return new OperationError(("Invalid clientName: " + errorMessage),
                               ErrorSubcode.PARAMETER_OUT_OF_RANGE); });
      if (error) {
        throw error;
      }
      cc.addParameter(new SMFParameter(0,
                                       SMFClientCtrlParam.CLIENTNAME,
                                       nullTerminate(newValue)));
    }
    return cc;
  };

  ClientCtrlMessage.validateClientName = function validateClientName (strName, exceptionCreator) {
    var encodeResult = validateAndEncode(DestinationType.TOPIC, strName, exceptionCreator);
    if (encodeResult.error) {
      return encodeResult.error;
    }
    // Add 1: bytes includes terminator, 160 excludes terminator
    if (encodeResult.bytes.length > 161) {
      return exceptionCreator('Client Name too long (max length: 160).');
    }
    return null;
  };

  return ClientCtrlMessage;
}(BaseMessage));


module.exports.ClientCtrlMessage = ClientCtrlMessage;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;
var ref$1 = __webpack_require__(32);
var SMFHeader = ref$1.SMFHeader;
var ref$2 = __webpack_require__(22);
var SMFProtocol = ref$2.SMFProtocol;

var KeepAliveMessage = (function (BaseMessage) {
  function KeepAliveMessage() {
    BaseMessage.call(this, new SMFHeader(SMFProtocol.KEEPALIVEV2, 2));
    this._smfHeader.smf_uh = 2;
  }

  if ( BaseMessage ) KeepAliveMessage.__proto__ = BaseMessage;
  KeepAliveMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  KeepAliveMessage.prototype.constructor = KeepAliveMessage;

  return KeepAliveMessage;
}(BaseMessage));

module.exports.KeepAliveMessage = KeepAliveMessage;


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var assert = ref.assert;
var ref$1 = __webpack_require__(31);
var BaseMessage = ref$1.BaseMessage;
var ref$2 = __webpack_require__(5);
var Destination = ref$2.Destination;
var ref$3 = __webpack_require__(32);
var SMFHeader = ref$3.SMFHeader;
var ref$4 = __webpack_require__(22);
var SMFProtocol = ref$4.SMFProtocol;
var ref$5 = __webpack_require__(79);
var SMFSMPMessageType = ref$5.SMFSMPMessageType;
var ref$6 = __webpack_require__(130);
var SMFSMPMessageTypeFlags = ref$6.SMFSMPMessageTypeFlags;

/**
 * Represents an SMP request or reply message
 * @memberof solace
 * @private
 */
var SMPMessage = (function (BaseMessage) {
  function SMPMessage() {
    BaseMessage.call(this, new SMFHeader(SMFProtocol.SMP, 1));

    // Field: msgtype
    this.msgType = 0;

    // Field: subscription string
    this.encodedUtf8Subscription = null;

    this.smpFlags = (0 | SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC); // default flags

    this._encodedQueueName = null; // unused in solclientjs
    this._encodedClientName = null; // unused in solclientjs
  }

  if ( BaseMessage ) SMPMessage.__proto__ = BaseMessage;
  SMPMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  SMPMessage.prototype.constructor = SMPMessage;

  SMPMessage.prototype.isFlag = function isFlag (flagMask) {
    return (this.smpFlags & flagMask);
  };

  SMPMessage.prototype.setFlag = function setFlag (flagMask, value) {
    if (value) {
      this.smpFlags |= flagMask;
    } else {
      this.smpFlags &= (~flagMask);
    }
  };

  SMPMessage.getSubscriptionMessage = function getSubscriptionMessage (correlationTag, topic, add, requestConfirm) {
    assert(topic instanceof Destination, 'Topics are not UCS-2 strings. Pass a Topic object.');
    var smp = new SMPMessage();
    smp.msgType = add
      ? SMFSMPMessageType.ADDSUBSCRIPTION
      : SMFSMPMessageType.REMSUBSCRIPTION;
    smp.encodedUtf8Subscription = topic.getBytes();
    assert(smp.encodedUtf8Subscription, 'Topic had no encoding');
    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
    if (requestConfirm) {
      smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
    }

    // Always put a correlation tag
    smp._smfHeader.pm_corrtag = correlationTag;
    return smp;
  };

  return SMPMessage;
}(BaseMessage));


module.exports.SMPMessage = SMPMessage;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(31);
var BaseMessage = ref.BaseMessage;

/**
 * @classdesc
 * Transport SMF Message
 * @memberof solace
 * @private
 */
var TransportSMFMessage = (function (BaseMessage) {
  function TransportSMFMessage() {
    BaseMessage.call(this, null, null);
    this.uh = 0;
    this.messageType = null;
    this.sessionId = null;
    this.routerTag = null;
    this.payload = null;
    this.payloadLength = 0;
    this.tsHeaderLength = 0;
  }

  if ( BaseMessage ) TransportSMFMessage.__proto__ = BaseMessage;
  TransportSMFMessage.prototype = Object.create( BaseMessage && BaseMessage.prototype );
  TransportSMFMessage.prototype.constructor = TransportSMFMessage;

  return TransportSMFMessage;
}(BaseMessage));

module.exports.TransportSMFMessage = TransportSMFMessage;


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var CacheGetResultCode = {
  INVALID: 0,
  OK:      1,
};

module.exports.CacheGetResultCode = Enum.new(CacheGetResultCode);


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(229);
var CacheGetResultCode = ref.CacheGetResultCode;

var DEFAULTS = {
  messageID:         null,
  version:           0,
  responseCode:      CacheGetResultCode.INVALID,
  responseString:    '',
  matchTopic:        '',
  sessionID:         null,
  isSuspect:         null,
  hasMore:           null,
  hasTimestamps:     null,
  replyTo:           null,
  messageStream:     null,
  clusterNameStream: null,
};

/**
 * @classdesc CacheGetResult encapsulates the result of a cache get request
 * @private
 */
var CacheGetResult = function CacheGetResult(options) {
  if ( options === void 0 ) options = DEFAULTS;

  Object.assign(this, options);
};

CacheGetResult.prototype.readFromStream = function readFromStream (stream) {
  this.messageID = stream.getNext().getValue();
  this.version = stream.getNext().getValue();
  this.responseCode = stream.getNext().getValue();
  this.responseString = stream.getNext().getValue();
  // SD claims instanceName is present here but empirically, it's not

  this.matchTopic = stream.getNext().getValue();
  this.sessionID = stream.getNext().getValue();
  this.isSuspect = stream.getNext().getValue();
  this.hasMore = stream.getNext().getValue();

  this.hasTimestamps = stream.getNext().getValue();

  if (stream.hasNext()) { // first stream
    this.messageStream = stream.getNext().getValue();
  }
  if (stream.hasNext()) { // if two streams, first was cluster name stream
    this.clusterNameStream = this.messageStream;
    this.messageStream = stream.getNext().getValue();
  }
};

module.exports.CacheGetResult = CacheGetResult;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

/**
 * @private
 * @enum {number}
 */
var CacheRequestType = {
  INVALID:                       0,
  BULK_MSG:                      1,
  REGISTER_REQUEST:              2,
  REGISTER_RESPONSE:             3,
  HEARTBEAT_REQUEST:             4,
  HEARTBEAT_RESPONSE:            5,
  EVENT_NOTIFY:                  6,
  EVENT_ACK:                     7,
  ACTION_REQUEST:                8,
  ACTION_RESPONSE:               9,
  GET_REQUEST:                   10,
  GET_RESPONSE:                  11,
  GET_NEXT_REQUEST:              12,
  GET_NEXT_RESPONSE:             13,
  SET_REQUEST:                   14,
  SET_RESPONSE:                  15,
  GET_MSG_REQUEST:               16,
  GET_MSG_RESPONSE:              17,
  GET_NEXT_MSG_REQUEST:          18,
  GET_NEXT_MSG_RESPONSE:         19,
  UNREGISTER_IND:                20,
  BULK_SET_REQUEST:              21,
  BULK_SET_RESPONSE:             22,
  PURGE_MSG_SEQUENCE_REQUEST:    23,
  PURGE_MSG_SEQUENCE_RESPONSE:   24,
  GET_MSG_SEQUENCE_REQUEST:      25,
  GET_NEXT_MSG_SEQUENCE_REQUEST: 26,
  GET_TOPIC_INFO_REQUEST:        27,
  GET_TOPIC_INFO_RESPONSE:       28,
  READY_MARKER:                  29,
  GET_TOPIC_INFO_REQUEST_RANGE:  30,
  SYNC_READY_MARKER:             31,
  VACUUM_REQUEST:                32,
  VACUUM_RESPONSE:               33,
};

module.exports.CacheRequestType = Enum.new(CacheRequestType);


/***/ }),
/* 232 */
/***/ (function(module, exports) {

/**
 * A tuple associating subscriptions, correlation IDs and cache sessions.
 * @param {String} correlationID The correlation ID for this tuple
 * @param {Topic} topic The topic for this tuple
 * @param {CacheSession} cacheSession The cache session for this tuple
 * @private
 */
var CacheSessionSubscribeInfo = function CacheSessionSubscribeInfo(correlationID, topic, cacheSession) {
  Object.assign(this, {
    correlationID: correlationID,
    topic: topic,
    cacheSession: cacheSession,
  });
};

module.exports.CacheSessionSubscribeInfo = CacheSessionSubscribeInfo;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var MessageLib = __webpack_require__(16);
var SessionLib = __webpack_require__(21);
var SMFLib = __webpack_require__(8);
var StatType = __webpack_require__(19);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var LOG_DEBUG = ref$1.LOG_DEBUG;
var LOG_INFO = ref$1.LOG_INFO;
var LOG_WARN = ref$1.LOG_WARN;
var ref$2 = __webpack_require__(10);
var SDTField = ref$2.SDTField;
var SDTFieldType = ref$2.SDTFieldType;
var SDTStreamContainer = ref$2.SDTStreamContainer;
var ref$3 = __webpack_require__(132);
var CacheCBInfo = ref$3.CacheCBInfo;
var ref$4 = __webpack_require__(81);
var CacheContext = ref$4.CacheContext;
var ref$5 = __webpack_require__(230);
var CacheGetResult = ref$5.CacheGetResult;
var ref$6 = __webpack_require__(133);
var CacheLiveDataAction = ref$6.CacheLiveDataAction;
var ref$7 = __webpack_require__(135);
var CacheRequest = ref$7.CacheRequest;
var ref$8 = __webpack_require__(134);
var CacheRequestResult = ref$8.CacheRequestResult;
var ref$9 = __webpack_require__(231);
var CacheRequestType = ref$9.CacheRequestType;
var ref$10 = __webpack_require__(136);
var CacheReturnCode = ref$10.CacheReturnCode;
var ref$11 = __webpack_require__(137);
var CacheReturnSubcode = ref$11.CacheReturnSubcode;
var ref$12 = __webpack_require__(138);
var CacheSessionProperties = ref$12.CacheSessionProperties;
var ref$13 = __webpack_require__(232);
var CacheSessionSubscribeInfo = ref$13.CacheSessionSubscribeInfo;
var ref$14 = __webpack_require__(5);
var Destination = ref$14.Destination;
var Topic = ref$14.Topic;

var CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;

var noOp = function () { return undefined; };

/**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.Session#createCacheSession}</b>
 * <p>
 * A session for performing cache requests.
 *
 * Applications must use {@link solace.Session#createCacheSession} to construct this class.
 *
 * The supplied {@link solace.CacheSessionProperties} will be copied. Subsequent modifications
 * to the passed properties will not modify the session. The properties may be reused.
 *
 * @memberof solace
 */
var CacheSession = function CacheSession(props, session, privateInterface) {
  CacheSession._validateProps(props);
  var properties = new CacheSessionProperties(props.cacheName,
                                                props.maxAgeSec,
                                                props.maxMessages,
                                                props.timeoutMsec);
  Object.assign(this,
                {
                  _outstandingRequests:        {},
                  _outstandingIDs:             {},
                  _disposed:                   false,
                  _nextMessageCallbackInfo:    null,
                  _nextSessionEventCallbackInfo: null,
                  _properties:                 properties,
                  _session:                    session,
                  _sessionIF:                  privateInterface,
                });
  this._connectToSession(session);
};

/**
 * @param {solace.Session} session The session to connect
 * @private
 */
CacheSession.prototype._connectToSession = function _connectToSession (session) {
    var this$1 = this;

  this._nextSessionEventCallbackInfo = session.getEventCBInfo();
  this._nextMessageCallbackInfo = session.getMessageCBInfo();
  session.setMessageCBInfo(new SessionLib.MessageRxCBInfo(function (_, message) {
    this$1._handleMessage(message);
  }, this));
  session.setEventCBInfo(this._createCompoundEventCB(this._nextSessionEventCallbackInfo));
};

/**
 * Takes the session's existing event callback and sets it as the next delegate in a
 * chain of responsibility. The next delegate could be the client application, or another
 * cache session.
 * @param {SessionEventCBInfo} nextDelegate The next event receiver in the chain
 * @returns {SessionEventCBInfo} An event receiver that delegates to the supplied receiver
 * @private
 */
CacheSession.prototype._createCompoundEventCB = function _createCompoundEventCB (nextDelegate) {
    var this$1 = this;

  return new SessionLib.SessionEventCBInfo(function (session, sessionEvent, userObject, rfuObject) {
    this$1._handleSessionEvent(nextDelegate, session, sessionEvent, userObject, rfuObject);
  }, null);
};

/**
 * Modified chain of responsibility. Handles the event, then passes the event to the next
 * delegate.
 * @param {SessionEventCBInfo} nextDelegate The next delegate to notify
 * @param {solace.Session} session The associated session
 * @param {SessionEvent} sessionEvent The session event to dispatch
 * @private
 */
CacheSession.prototype._handleSessionEvent = function _handleSessionEvent (nextDelegate, session, sessionEvent /*, userObject, rfuObject */) {
  var passEvent = this._processSessionEvent(session, sessionEvent);
  if (!passEvent) {
    return;
  }
  var cbUserObject = nextDelegate.userObject;
  if (!cbUserObject) {
    nextDelegate.sessionEventCBFunction(session, sessionEvent);
  } else {
    nextDelegate.sessionEventCBFunction(session, sessionEvent, cbUserObject);
  }
};

/**
 * @param {Message} message The message to forward
 * @private
 */
CacheSession.prototype._sendToNextDelegate = function _sendToNextDelegate (message) {
  var cbUserObject = this._nextMessageCallbackInfo.userObject;
  if (!cbUserObject) {
    this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message);
  } else {
    this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message, cbUserObject);
  }
};

/**
 * @param {solace.Session} session The associated session
 * @param {SessionEvent} event The event to process
 * @returns {Boolean} true if event should pass to next delegate
 * @private
 */
CacheSession.prototype._processSessionEvent = function _processSessionEvent (session, event) {
  switch (event.sessionEventCode) {
    case SessionLib.SessionEventCode.SUBSCRIPTION_ERROR:
    case SessionLib.SessionEventCode.SUBSCRIPTION_OK:
      return this._checkSubscriptionStatus(event);
    case SessionLib.SessionEventCode.DOWN_ERROR:
      this.dispose();
      return true;
    default:
      /* #stripped LOG_TRACE(`Unhandled session event: ${event.sessionEventCode}`) */

      return true;
  }
};

/**
 * @param {SessionEvent} event The event to check
 * @returns {Boolean} `true` if event should pass to next delegate
 * @private
 */
CacheSession.prototype._checkSubscriptionStatus = function _checkSubscriptionStatus (event) {
  // Incremental checks for whether this is our subscription.
  if ((event.correlationKey === null || event.correlationKey === undefined) ||
      (!(event.correlationKey instanceof CacheSessionSubscribeInfo)) ||
      (event.correlationKey.cacheSession !== this)) {
    return true;
  }
  var request = this._getOutstandingRequest(event.correlationKey.correlationID);
  if (!request) {
    LOG_WARN(("No request found for subscription success on " + (event.correlationKey.topic)));
    return true;
  }
  if (event.sessionEventCode === SessionLib.SessionEventCode.SUBSCRIPTION_OK) {
    this._handleSubscriptionSuccess(request, event.correlationKey.topic);
    return false;
  }
  this._handleSubscriptionError(request, event);
  return false;
};

/**
 * @param {CacheRequest} requestIn The cache on which to register success
 * @param {Topic} topic The topic on which to issue the request.
 * @private
 */
CacheSession.prototype._handleSubscriptionSuccess = function _handleSubscriptionSuccess (requestIn /*, topic */) {
  // Null out this field and check completion status.
  var request = requestIn;
  request.subscriptionWaiting = null;
  this._startCacheRequest(request);
};

/**
 * @param {CacheRequest} request The cache request on which to register failure
 * @private
 */
CacheSession.prototype._handleSubscriptionError = function _handleSubscriptionError (request/*, event */) {
  this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.SUBSCRIPTION_ERROR);
};

/**
 * @param {CacheRequest} request The cache request on which to check completion
 * @private
 */
CacheSession.prototype._checkRequestCompletion = function _checkRequestCompletion (request) {
  if (request.childRequests.length) {
    // Not finished with spawned child requests.
    /* #stripped LOG_DEBUG(`Awaiting termination of ${request.childRequests.length} children`) */

    return;
  }
  if (request.subscriptionWaiting) {
    // Waiting for confirmation of subscription to a topic.
    /* #stripped LOG_DEBUG('Awaiting subscription') */

    return;
  }
  if (request.timeoutHandle !== null && (!request.replyReceived)) {
    /* #stripped LOG_DEBUG('Awaiting timeout') */

    return;
  }
  if (request.parentRequest) {
    // We're no longer waiting for a child to complete.
    var parent = request.parentRequest;
    request.cancel();
    this._unregisterRequest(request);
    this._checkRequestCompletion(parent);
    return;
  }

  // This is a parent request and it is done.
  var code;
  var subcode;
  if (request.isSuspect) {
    code = CacheReturnCode.INCOMPLETE;
    subcode = CacheReturnSubcode.SUSPECT_DATA;
  } else if (request.dataReceived) {
    code = CacheReturnCode.OK;
    if (request.liveDataFulfilled) {
      subcode = CacheReturnSubcode.LIVE_DATA_FULFILL;
    } else {
      subcode = CacheReturnSubcode.REQUEST_COMPLETE;
    }
  } else if (request.replyReceived) {
    code = CacheReturnCode.INCOMPLETE;
    subcode = CacheReturnSubcode.NO_DATA;
  } else {
    throw new Error('Sanity: should never happen');
  }
  this._terminateRequest(request, code, subcode);
};

/**
 * @param {CacheRequest} parentRequest The parent node for the new request
 * @param {CacheGetResult} cacheGetResult The result of this request
 * @private
 */
CacheSession.prototype._sendSeeOther = function _sendSeeOther (parentRequest, cacheGetResult) {
  var clusterName = cacheGetResult.clusterNameStream.getNext().getValue();
  // var root = parentRequest.getRootRequest();
  /* #stripped LOG_DEBUG(`See Other for ${clusterName}. Sending child request`) */

  var childRequest = new CacheRequest(this,
                                        CacheRequestType.GET_MSG_REQUEST,
                                        parentRequest.requestID,
                                        new CacheCBInfo(noOp, null),
                                        parentRequest.liveDataAction,
                                        parentRequest.topic,
                                        clusterName);
  // Add this request to its parent
  parentRequest.addChild(childRequest);
  // Start the request
  this._registerRequest(childRequest);
  childRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                                   this._properties.timeoutMsec);
  this._startCacheRequest(childRequest, // request to send
                          null, // no session ID
                          null, // no specific instance target
                          true); // don't return other clusters
};

/**
 * @param {CacheRequest} parentRequest The parent node for the new request
 * @param {CacheGetResult} cacheGetResult The result of this request
 * @private
 */
CacheSession.prototype._sendGetNext = function _sendGetNext (parentRequest, cacheGetResult) {
  /* #stripped LOG_DEBUG('Cache result has more, sending GET_NEXT_MSG_REQUEST as child') */

  var nextRequest = new CacheRequest(this,
                                       CacheRequestType.GET_NEXT_MSG_REQUEST,
                                       parentRequest.requestID,
                                       new CacheCBInfo(noOp, null),
                                       parentRequest.liveDataAction,
                                       parentRequest.topic,
                                       parentRequest.cacheName);
  // Set up parent-child relationship
  parentRequest.addChild(nextRequest);
  // Start the request
  this._registerRequest(nextRequest);
  nextRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                                  this._properties.timeoutMsec);
  this._startCacheRequest(nextRequest, // request to send
                          cacheGetResult.sessionID, // supplied session ID
                          cacheGetResult.replyTo); // supplied cache instance target
};

/**
 * @param {Message} message The message to inspect and handle
 * @private
 */
CacheSession.prototype._handleMessage = function _handleMessage (message) {
    var this$1 = this;

  // Determine if the message is associated with one of this session's requests
  var correlationID = message.getCorrelationId();
  var request = correlationID === null || correlationID === undefined
    ? null
    : this._outstandingRequests[correlationID];

  // This could be live data on a relevant topic.Check that.
  if (!request) {
    if (this._relevantLiveData(message)) {
      this._sendToNextDelegate(message);
    }
    return;
  }

  // It's ours!
  /* #stripped LOG_DEBUG(`Processing reply to ${request}`) */

  // bug 36404: We have a response. Cancel the timeout for this request.
  request.clearRequestTimeout();
  var streamField = message.getSdtContainer();
  var stream = streamField && streamField.getValue();
  if (!stream) {
    LOG_INFO(
      ("Invalid message format for cache response: no SDT container (" + streamField + ") or stream (" + stream + ")"));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
  }
  // The session will never see this reply, so we need to update the stats
  // from here.
  this._incStat(StatType.RX_REPLY_MSG_RECVED);
  request.replyReceived = true;

  // If the request was fulfilled by live data, discard the reply and stop processing
  // the response.
  if (request.getRootRequest().liveDataFulfilled) {
    this._incStat(StatType.CACHE_REQUEST_FULFILL_DISCARD_RESPONSE);
    this._checkRequestCompletion(request);
    return;
  }

  if (!stream) {
    LOG_INFO('Invalid cache response did not fulfill request. Skipping response processing');
    return;
  }

  try {
    // Fill the result object with values from the result stream.
    var result = new CacheGetResult();
    result.readFromStream(stream);
    result.replyTo = message.getReplyTo();
    if (result.responseString) {
      /* #stripped LOG_DEBUG(`Cluster response: ${result.responseString}`) */

    }
    // Apply the isSuspect flag. Don't clear it if the result is already suspect.
    request.isSuspect = request.isSuspect || result.isSuspect;
    // Get any inner messages.
    var messages = CacheSession._decodeMessageStream(request, result);
    // Update statistics.
    this._incStat(StatType.RX_CACHE_MSG, messages.length);
    // If we have more results to come, send a get next request.
    if (result.hasMore) {
      this._sendGetNext(request, result);
    }
    // If we have more clusters to visit, send requests to those clusters.
    if (result.clusterNameStream) {
      /* #stripped LOG_DEBUG('Receiving cluster stream') */

      while (result.clusterNameStream.hasNext()) {
        this$1._sendSeeOther(request, result);
      }
    }
    // Forward any retrieved messages.
    if (messages) {
      messages.forEach(function (m) {
        this$1._sendToNextDelegate(m);
      });
    }
    this._checkRequestCompletion(request);
  } catch (exception) {
    LOG_INFO(("Invalid message format for cache response: " + (exception.stack)));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
  }
};

/**
 * @param {Message} message The message to inspect and handle
 * @returns {Boolean} `true` if the next delegate should handle this message
 * @private
 */
CacheSession.prototype._relevantLiveData = function _relevantLiveData (message) {
    var this$1 = this;

  // If the next message processor does not belong to a cache
  // session, and this is a CRQ message, suppress it.
  if (message.getCorrelationId() &&
      message.getCorrelationId().startsWith(CACHE_REQUEST_PREFIX) &&
      !(this._nextMessageCallbackInfo.userObject instanceof CacheSession)) {
    LOG_WARN('DROP: Dropping CRQ reply due to no remaining Cache Session processors on message ' +
             'callback chain');
    this._incStat(StatType.RX_REPLY_MSG_DISCARD);
    return false;
  }
  // Otherwise, assume the message should flow through.
  // If all _performLiveDataAction calls return true, we return true;
  return Object.keys(this._outstandingRequests).every(function (checkCID) { return this$1._performLiveDataAction(this$1._outstandingRequests[checkCID], message); });
};

/**
 * @param {CacheRequest} requestIn The cache request for which to perform the action
 * @param {Message} message The message to process on the request
 * @returns {Boolean} true if message should flow through after action.
 * @private
 */
CacheSession.prototype._performLiveDataAction = function _performLiveDataAction (requestIn, message) {
  var request = requestIn;
  request.dataReceived = true;
  switch (request.liveDataAction) {
    case CacheLiveDataAction.QUEUE:
      request.queuedLiveData.push(message);
      return false;

    case CacheLiveDataAction.FULFILL:
      if (!request.liveDataFulfilled) {
        this._fulfillRequest(request);
      }
      return true;

    default:
      return true;
  }
};

/**
 * @param {CacheRequest} requestIn The request to fulfill
 * @private
 */
CacheSession.prototype._fulfillRequest = function _fulfillRequest (requestIn) {
  var request = requestIn;
  request.liveDataFulfilled = true;
  this._trackCompletionStats(CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL);
  // We have more work to do here -- we need to return the live data first.
  // Schedule the notification for later.
  setTimeout(function () {
    CacheSession._notifyCallback(request,
                                 CacheReturnCode.OK,
                                 CacheReturnSubcode.LIVE_DATA_FULFILL,
                                 request.getTopic(),
                                 null);
  }, 0);
};

/**
 * Disposes the session.No cache requests will be sent by this CacheSession after it is
 * _disposed.
 *
 * Any subsequent operations on the session will throw {OperationError}.
 *
 * Any pending operations will immediately terminate, returning
 * * {@link solace.CacheRequestResult}
 *   * #returnCode === {@link solace.CacheReturnCode.INCOMPLETE}
 *   * #subcode === {@link solace.CacheReturnSubcode.CACHE_SESSION_DISPOSED}
 * @throws {solace.OperationError} if the CacheSession is already _disposed.
 */
CacheSession.prototype.dispose = function dispose () {
    var this$1 = this;

  var toTerminate = Object.keys(this._outstandingRequests)
    .map(function (correlationID) { return this$1._outstandingRequests[correlationID]; })
    .filter(function (request) { return request instanceof CacheRequest; });
  toTerminate.forEach(function (request) {
    this$1._terminateRequest(request,
                           CacheReturnCode.INCOMPLETE,
                           CacheReturnSubcode.CACHE_SESSION_DISPOSED);
  });
  this._outstandingRequests = [];
  // Restore original listeners
  this._session.setEventCBInfo(this._nextSessionEventCallbackInfo);
  this._session.setMessageCBInfo(this._nextMessageCallbackInfo);
  // Set _disposed
  this._disposed = true;
};

/**
 * Gets the cache session properties.
 *
 * @returns {solace.CacheSessionProperties} The properties for the session.
 * @throws {solace.OperationError} if the CacheSession is disposed.
 */
CacheSession.prototype.getProperties = function getProperties () {
  return this._properties;
};

/**
 * Issues an asynchronous cache request. The result of the request will be returned via the
 * listener. Messages returned as a result of issuing the request will be returned to the
 * application via the {@link solace.MessageRxCBInfo} associated with this
 * {@link solace.CacheSession}'s {@link solace.Session}
 *
 * @param {Number} requestID The application-assigned ID number for the request.
 * @param {solace.Destination} topic The topic destination for which the cache request will be
 *  made.
 * @param {Boolean} subscribe If true, the session will subscribe to the given {Topic}, if it is
 * not already subscribed, before performing the cache request.
 * @param {solace.CacheLiveDataAction} liveDataAction The action to perform when the
 *  {@link solace.CacheSession} receives live data on the given topic.
 * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
 *
 * @throws {solace.OperationError} In the following cases:
 * * If the CacheSession is disposed.
 *  Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
 * * If one or more parameters were invalid.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}
 * * If the supplied topic and live data action cannot be combined.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 * * If the supplied topic or live data action cannot be used given the current outstanding
 *  requests.
 *  Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 */
CacheSession.prototype.sendCacheRequest = function sendCacheRequest (requestID, topic, subscribe, liveDataAction, cbInfo) {
    var this$1 = this;

  if (arguments.length !== 5) {
    throw new OperationError(("sendCacheRequest() invoked with an illegal argument count of " + (arguments.length)));
  }
  if (typeof subscribe !== 'boolean') {
    throw new OperationError(
      ("Invalid subscribe flag argument, should be a boolean but was " + (typeof subscribe)));
  }
  if (typeof requestID !== 'number' || Number.isNaN(requestID)) {
    throw new OperationError('Invalid requestID', ErrorSubcode.PARAMETER_INVALID_TYPE, null);
  }
  if (this._outstandingIDs[requestID]) {
    throw new OperationError('Request already in progress with this requestID');
  }
  if (!(topic instanceof Destination)) {
    throw new OperationError('Invalid topic', ErrorSubcode.PARAMETER_INVALID_TYPE, (typeof topic));
  }
  topic.validate();
  if (!(liveDataAction === CacheLiveDataAction.FLOW_THRU || liveDataAction ===
      CacheLiveDataAction.FULFILL || liveDataAction === CacheLiveDataAction.QUEUE)) {
    throw new OperationError('Invalid live data action', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if (topic.isWildcarded() && liveDataAction !== CacheLiveDataAction.FLOW_THRU) {
    throw new OperationError('Wildcarded topic not supported for this live data action',
      ErrorSubcode.PARAMETER_CONFLICT);
  }
  if (!(cbInfo instanceof CacheCBInfo)) {
    throw new OperationError('Callback info was not an instance of CacheCBInfo');
  }
  if (this._disposed) {
    CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL,
                                      CacheReturnSubcode.CACHE_SESSION_DISPOSED, topic,
                                      'Cache request failed: the cache session is disposed.');
    return;
  }
  if (this._session._disposed) {
    CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL,
                                      CacheReturnSubcode.INVALID_SESSION, topic,
                                      'Cache request failed: the session is disposed.');
    return;
  }

  var request = new CacheRequest(this,
    CacheRequestType.GET_MSG_REQUEST,
    requestID,
    cbInfo,
    liveDataAction,
    topic,
    this._properties.cacheName);

  var matchingRequestKeys = Object.keys(this._outstandingRequests).filter(function (key) { return this$1._outstandingRequests[key].topic.getName() === topic.getName(); });

  if (matchingRequestKeys.length) {
    // Topic name matches mean a conflict unless both requests are FLOW_THRU
    var conflictKeys = (
      liveDataAction !== CacheLiveDataAction.FLOW_THRU
        ? matchingRequestKeys
        : matchingRequestKeys.filter(function (k) { return this$1._outstandingRequests[k].liveDataAction !== CacheLiveDataAction.FLOW_THRU; }));
    if (conflictKeys.length) {
      var conflictRequest = this._outstandingRequests[conflictKeys[0]];
      LOG_WARN(("Existing request " + conflictRequest + " conflicts. Rejecting request " + request));
       // Register this request so that it is not dismissed as an orphan.
      this._registerRequest(request);
      this._terminateRequest(request,
                             CacheReturnCode.FAIL,
                             CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS);
      return;
    }
  }

  this._registerRequest(request);
  request.startRequestTimeout(CacheSession._handleCacheRequestTimeout,
                              this._properties.timeoutMsec);
  if (subscribe) {
    var waitingForSubscribeInfo = new CacheSessionSubscribeInfo(request.correlationID, topic,
      this);
    request._subscriptionWaiting = waitingForSubscribeInfo;
    this._session.subscribe(topic, true, waitingForSubscribeInfo);
    return;
  }
  this._startCacheRequest(request);
};

/**
 * @param {solace.Session} session The session associated with the request
 * @param {SessionEvent} sessionEvent The session event
 * @param {CacheRequest} userObject The user-specified context object
 * @private
 */
CacheSession.prototype._handleCacheRequestFailed = function _handleCacheRequestFailed (session, sessionEvent, userObject /*, rfuObject */) {
  this._terminateRequest(userObject.getRequestID(),
                         CacheReturnCode.FAIL,
                         CacheReturnSubcode.ERROR_RESPONSE);
};

/**
 * @param {CacheRequest} request The new request to register
 * @private
 */
CacheSession.prototype._registerRequest = function _registerRequest (request) {
  this._outstandingRequests[request.correlationID] = request;
  if (!request.parentRequest) {
    this._outstandingIDs[request.requestID] = request;
  }
};

/**
 * @param {Number} correlationID The ID of an existing request
 * @returns {CacheRequest} The existing request with the given ID
 * @private
 */
CacheSession.prototype._getOutstandingRequest = function _getOutstandingRequest (correlationID) {
  return this._outstandingRequests[correlationID];
};

/**
 *
 * @param {CacheRequest} request The request to start
 * @param {?Number} sessionID Only when returned from a cache instance as part of a
 * previous message
 * @param {?Topic} destination Only when required by a cache reply
 * @param {?Boolean} suppressClusters True when other clusters should be excluded from
 * the response, as in a request resulting from a "see other"
 * @private
 */
CacheSession.prototype._startCacheRequest = function _startCacheRequest (request, sessionID, destination, suppressClusters) {
  var message = new MessageLib.Message();

  // Prepare message
  message.setCorrelationId(request.correlationID);
  if (destination) {
    message.setDestination(destination);
  } else {
    message.setDestination(
      Topic.createFromName(this._properties.cachePrefix + request.cacheName));
  }
  message.setReplyTo(Topic.createFromName(this._session.getSessionProperties().p2pInboxInUse));
  message.setDeliverToOne(request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST);

  // Prepare stream container
  var stream = new SDTStreamContainer();
  stream.addField(SDTFieldType.UINT32, request.cacheMessageType);
  stream.addField(SDTFieldType.UINT32, CacheRequest.VERSION);
  stream.addField(SDTFieldType.STRING, request.topic.getName());
  stream.addField(SDTFieldType.UINT32, CacheRequest.REPLY_SIZE_LIMIT);

  if (typeof sessionID === 'number') {
    /* #stripped LOG_DEBUG(`Including session ID: ${sessionID}`) */

    stream.addField(SDTFieldType.UINT32, sessionID);
  }

  stream.addField(SDTFieldType.UINT32, this._properties.maxMessages);
  stream.addField(SDTFieldType.UINT32, this._properties.maxAgeSec);
  if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
    stream.addField(SDTFieldType.BOOL,
                    this._properties.includeOtherClusters && (!suppressClusters));
  }

  stream.addField(SDTFieldType.BOOL, false); // includeTimestamps, 6.17.1
  if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
    stream.addField(SDTFieldType.UINT32, Math.round(this._properties.timeoutMsec / 1000));
  }

  // Load stream container
  message.setSdtContainer(SDTField.create(SDTFieldType.STREAM, stream));
  try {
    /* #stripped LOG_DEBUG(`Sending ${request}`) */

    this._session.send(message);

    if (!request.parentRequest) { // Don't count child requests in CACHE_REQUEST_SENT total
      this._incStat(StatType.CACHE_REQUEST_SENT);
    }
  } catch (e) {
    LOG_INFO(("Failed to send request: " + (e.message)));
    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE, e);
  }
};

/**
 * Increments a stat.
 * @param{String} statType The stat to increment
 * @param{Number} value  The amount by which to increment the state
 * @private
 */
CacheSession.prototype._incStat = function _incStat (statType, value) {
  if (!this._session) {
    /* #stripped LOG_DEBUG("Can't log stat: session is disposed") */

    return;
  }
  if (!this._sessionIF) {
    LOG_INFO("Can't log stat: session statistics not available");
    return;
  }
  this._sessionIF.incStat(statType, value);
};

/**
 * Unregisters the given request.
 * @param{CacheRequest} request The request to unreguster
 * @private
 */
CacheSession.prototype._unregisterRequest = function _unregisterRequest (request) {
  delete this._outstandingRequests[request.correlationID];
  delete this._outstandingIDs[request.requestID];
};

/**
 * @param {CacheReturnCode} returnCode The return code for this completion
 * @param {CacheReturnSubcode} subcode The subcode for this completion
 * @private
 */
CacheSession.prototype._trackCompletionStats = function _trackCompletionStats (returnCode, subcode) {
  switch (returnCode) {
    case CacheReturnCode.OK:
      this._incStat(StatType.CACHE_REQUEST_OK_RESPONSE);
      if (subcode === CacheReturnSubcode.LIVE_DATA_FULFILL) {
        this._incStat(StatType.CACHE_REQUEST_LIVE_DATA_FULFILL);
      }
      break;
    case CacheReturnCode.INCOMPLETE:
      this._incStat(StatType.CACHE_REQUEST_INCOMPLETE_RESPONSE);
      break;
    case CacheReturnCode.FAIL:
      this._incStat(StatType.CACHE_REQUEST_FAIL_RESPONSE);
      break;
    default:
      throw new Error('Sanity: no return code supplied');
  }
};

/**
 * @param {CacheRequest} requestIn The request to terminate
 * @param {CacheReturnCode} returnCode The return code for this operation
 * @param {CacheReturnSubcode} subcode The subcode for this operation
 * @param {Error} error Any error associated with this operation
 * @private
 */
CacheSession.prototype._terminateRequest = function _terminateRequest (requestIn, returnCode, subcode, error) {
    var this$1 = this;

  var request = requestIn.getRootRequest();
  if (!this._outstandingRequests[request.correlationID]) {
    // Request is unknown or was previously terminated
    return;
  }
  var cbInfo = request.cbInfo;
  if (!cbInfo) {
    LOG_WARN(("No callback info provided for " + request + ". Cannot notify"));
    return; // Cannot continue
  }
  var callback = cbInfo.getCallback();
  if (!callback) {
    LOG_WARN(("No callback provided for " + request + ". Cannot notify"));
    return; // Cannot continue
  }
  var topic = request.getTopic();
  if (!topic) {
    LOG_WARN(("No topic provided for " + request));
  }
  request.queuedLiveData.forEach(function (data) { return this$1._sendToNextDelegate(data); });

  // Unregister before callback so that the client application can treat the request ID
  // as "freed" and reuse it
  request.cancel();
  this._unregisterRequest(request);

  if (!request.liveDataFulfilled) {
    // All of this has already been done on fulfill.
    this._trackCompletionStats(returnCode, subcode);
    CacheSession._notifyCallback(request, returnCode, subcode, topic, error);
  }
};

/**
 * @param {CacheRequest} requestIn The request with a result to decode
 * @param {CacheGetResult} result The result to decode
 * @returns {Array.<Message>} The messages contained in the result
 * @private
 */
CacheSession._decodeMessageStream = function _decodeMessageStream (requestIn, result) {
  if (!result.messageStream) {
    return [];
  }

  /* #stripped LOG_DEBUG('Receiving messages') */

  var messages = [];
  var request = requestIn;
  while (result.messageStream.hasNext()) {
    request.dataReceived = true;
    var data = result.messageStream.getNext().getValue();
    var innerMessage = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
    if (!innerMessage) {
      continue;
    }
    var cacheStatus = result.isSuspect
      ? MessageLib.MessageCacheStatus.SUSPECT
      : MessageLib.MessageCacheStatus.CACHED;
    innerMessage._setCacheStatus(cacheStatus);
    innerMessage._setCacheRequestID(request.requestID);
    messages.push(innerMessage);
  }
  /* #stripped LOG_DEBUG(`${messages.length} cached messages received`) */

  return messages;
};

/**
 * Closure call context; `this` will be redefined
 * @param {CacheRequest} cacheRequest The request that timed out
 * @private
 */
CacheSession._handleCacheRequestTimeout = function _handleCacheRequestTimeout (cacheRequest) {
  var context = cacheRequest.cacheSession;
  if (!context._getOutstandingRequest(cacheRequest.correlationID)) {
    LOG_INFO(("Timeout for " + cacheRequest + " was not unregistered. Ignoring"));
    // already completed
    return;
  }

  // bug 36404: Cache request timeout is to be interpreted as timeout per session request-reply,
  // not timeout per cache request-reply.
  // Implementation: Timeouts on parent requests are cancelled when a child request is spawned.
  // Timeouts on child requests cause the root request to fail.
  LOG_INFO(("Request " + cacheRequest + " timed out"));
  context._terminateRequest(cacheRequest.getRootRequest(), CacheReturnCode.INCOMPLETE,
                            CacheReturnSubcode.REQUEST_TIMEOUT);
};


/**
 * @param {CacheRequest} request The request that is notifying
 * @param {CacheReturnCode} returnCode The return code for the notification
 * @param {CacheReturnSubcode} subcode The subcode for the notification
 * @param {Destination} topic The topic associated with the notification
 * @param {Error} error Any error associated with the notification
 * @private
 */
CacheSession._notifyCallback = function _notifyCallback (request, returnCode, subcode, topic, error) {
  var cbInfo = request.cbInfo;
  var callback = cbInfo.getCallback();
  callback(request.requestID,
           new CacheRequestResult(returnCode, subcode, topic, error),
           cbInfo.getUserObject());
};

/**
 * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
 * @param {Number} requestID The application-assigned ID number for the request
 * @param {CacheReturnCode} returnCode The return code for the notification
 * @param {CacheReturnSubcode} subcode The subcode for the notification
 * @param {Destination} topic The topic associated with the notification
 * @param {Error} error Any error associated with the notification
 * @private
 */
CacheSession._notifyCallbackError = function _notifyCallbackError (cbInfo, requestID, returnCode, subcode, topic, error) {
  var callback = cbInfo.getCallback();
  callback(requestID,
           new CacheRequestResult(returnCode, subcode, topic, error),
           cbInfo.getUserObject());
};

/**
 * Validates the cache session properties.
 * @param {solace.CacheSessionProperties} props The properties to validate
 * @private
 */
CacheSession._validateProps = function _validateProps (props) {
  if ((typeof (props.cacheName) !== 'string')) {
    throw new OperationError('Invalid parameter type for cacheName', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  // Create from name will throw if the cacheName is invalid.This performs more checking than
  // the legacy API did, but I think it is all justified as we shouldn't be able to use anything
  // that would be rejected here as a cacheName.
  if (Topic.createFromName(props.cacheName).isWildcarded()) {
    throw new OperationError(
      ("Invalid cacheName '" + (props.cacheName) + "'. The cacheName cannot be wildcarded"),
      ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.maxAgeSec) !== 'number')) {
    throw new OperationError('Invalid parameter type for maxAgeSec', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.maxAgeSec < 0) {
    throw new OperationError('Invalid value for maxAgeSec; must be >= 0', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.maxMessages) !== 'number')) {
    throw new OperationError('Invalid parameter type for maxMessages', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.maxMessages < 0) {
    throw new OperationError('Invalid value for maxMessages; must be >= 0', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
  if ((typeof (props.timeoutMsec) !== 'number')) {
    throw new OperationError('Invalid parameter type for timeoutMsec', ErrorSubcode.PARAMETER_INVALID_TYPE);
  }
  if (props.timeoutMsec < 3000) {
    throw new OperationError('Invalid value for timeoutMsec; must be >= 3000', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
  }
};

module.exports.CacheSession = CacheSession;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(82);
var StatType = ref.StatType;

module.exports = {
  StatsByMode: {
    STAT_TX_BYMODE_MSGS: [
      StatType.TX_DIRECT_MSGS,
      StatType.TX_PERSISTENT_MSGS,
      StatType.TX_NONPERSISTENT_MSGS ],
    STAT_TX_BYMODE_BYTES: [
      StatType.TX_DIRECT_BYTES,
      StatType.TX_PERSISTENT_BYTES,
      StatType.TX_NONPERSISTENT_BYTES ],
    STAT_TX_BYMODE_REDELIVERED: [
      StatType.TX_DIRECT_MSGS,     // unused placeholder, direct messsages are not redelivered
      StatType.TX_PERSISTENT_REDELIVERED,
      StatType.TX_NONPERSISTENT_REDELIVERED ],
    STAT_TX_BYMODE_BYTES_REDELIVERED: [
      StatType.TX_DIRECT_BYTES,     // unused placeholder, direct messsages are not redelivered
      StatType.TX_PERSISTENT_BYTES_REDELIVERED,
      StatType.TX_NONPERSISTENT_BYTES_REDELIVERED ],
    STAT_RX_BYMODE_MSGS: [
      StatType.RX_DIRECT_MSGS,
      StatType.RX_PERSISTENT_MSGS,
      StatType.RX_NONPERSISTENT_MSGS ],
    STAT_RX_BYMODE_BYTES: [
      StatType.RX_DIRECT_BYTES,
      StatType.RX_PERSISTENT_BYTES,
      StatType.RX_NONPERSISTENT_BYTES ],
  },
};


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(35);
var EventEmitter = ref.EventEmitter;
var ref$1 = __webpack_require__(82);
var StatType = ref$1.StatType;

/**
 * @private
 */
var Stats = (function (EventEmitter) {
  function Stats(parent) {
    var this$1 = this;

    EventEmitter.call(this);

    this._parent = parent;
    this._statsMap = [];
    StatType.values.forEach(function (value) {
      this$1._statsMap[value] = 0;
    });
  }

  if ( EventEmitter ) Stats.__proto__ = EventEmitter;
  Stats.prototype = Object.create( EventEmitter && EventEmitter.prototype );
  Stats.prototype.constructor = Stats;

  Stats.prototype.resetStats = function resetStats () {
    this.emit('reset');
    // The stat types are sequential, so .fill(0) would work, but the API design
    // doesn't really guarantee this so overwriting every existing index is safer.
    this._statsMap = this._statsMap.map(function () { return 0; });
  };

  Stats.prototype.incStat = function incStat (statType, value) {
    if ( value === void 0 ) value = 1;

    // should we validate statType?
    this._statsMap[statType] += value;
    if (this._parent) {
      this._parent.incStat(statType, value);
    }
  };

  Stats.prototype.getStat = function getStat (statType) {
    return this._statsMap[statType];
  };

  return Stats;
}(EventEmitter));

module.exports.Stats = Stats;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {


// eslint-disable-next-line global-require
var BufferImpl = Buffer || __webpack_require__(266).Buffer;

function newBuffer(size) {
  /* eslint-env shared-browser-node */
  if (BufferImpl.allocUnsafe) { return BufferImpl.allocUnsafe(size); }
  if (BufferImpl.alloc) { return BufferImpl.alloc(size); }
  return new BufferImpl(size);
}

/**
 * @internal
 */
var BufferDataQueue = function BufferDataQueue(maxSize) {
  var _buffer = newBuffer(maxSize);
  var _position = 0;
  var _remaining = 0;

  // Functions that directly access the buffer are declared in the constructor.
  // This removes _buffer from inspection scope and lets the class be debuggable.

  /**
   * Creates a slice (view) of the buffer with the given size. If the read
   * overlaps the end of the buffer, the buffer is compacted, invalidating
   * all previous peekViews.
   *
   * Contents of views should be copied by the caller if they are to be retained,
   * before any other buffer operation is performed.
   *
   * @param {Number} size Bytes to view
   * @returns {?Buffer} if there was enough data to peek, or `null`
   */
  this.peekView = function peekView(size) {
    if (size > _remaining) { return null; }
    if (_position + size > maxSize) { this.compact(); }
    var linearEnd = _position + size;
    return _buffer.slice(_position, linearEnd);
  };

  this.advance = function advance(size) {
    _remaining -= size;
    _position += size;
  };

  this.remaining = function remaining() {
    return _remaining;
  };

  /**
   * Puts bytes from a source buffer into the internal buffer.Compacts the buffer
   * if needed.Returns if the operation was successful.put() will fail if the
   * internal buffer (after compaction) does not have space to hold the source
   * buffer.
   *
   * This operation can invalidate previous views.
   *
   * @param {Buffer} dataIn Source data
   * @returns {Boolean} `true` if all bytes were inserted
   */
  this.put = function put(dataIn) {
    var buffer = BufferDataQueue.adaptData(dataIn);
    var size = buffer.length;

    if (_remaining + size >= maxSize) { return false; }
    if (_position + _remaining + size >= maxSize) { this.compact(); }

    buffer.copy(_buffer, _position + _remaining);
    _remaining += size;

    return true;
  };


  this.reset = function reset() {
    _position = 0;
    _remaining = 0;
  };

  /**
   * Shifts the remaining data so that it is aligned at zero.
   */
  this.compact = function compact() {
    _buffer.copy(_buffer, 0, _position, _position + _remaining);
    _position = 0;
  };
};

/**
 * Peeks a specified length and formats it as a string. This operation can invalidate
 * previous views.
 *
 * @param {Number} size The number of bytes to peek
 * @param {String} [encoding='binary'] The encoding for the string to be returned
 * @returns {?String} The decoded string
 */
BufferDataQueue.prototype.peekString = function peekString (size, encoding) {
    if ( encoding === void 0 ) encoding = 'binary';

  var target = this.peekView(size);
  return target ? target.toString(encoding) : null;
};

/**
 * Creates a slice (view) of the buffer with the given size. If the read
 * overlaps the end of the buffer, the buffer is compacted, invalidating
 * all previous peekViews. The bytes are consumed.
 *
 * Contents of views should be copied by the caller if they are to be retained,
 * before any other buffer operation is performed.
 *
 * @param {Number} size Bytes to copy
 * @returns {?Buffer} if there was enough data to peek, or `null`
 */
BufferDataQueue.prototype.getView = function getView (size) {
  var target = this.peekView(size);
  if (target) { this.advance(size); }
  return target;
};

/**
 * Gets a specified length and formats it as a string. This operation can invalidate
 * previous views.
 *
 * @param {Number} size The number of bytes to consume
 * @param {String} [encoding='binary'] The encoding for the string to be returned
 * @returns {?String} The decoded string if there was enough data to consumer, or `null`
 */
BufferDataQueue.prototype.getString = function getString (size, encoding) {
    if ( encoding === void 0 ) encoding = 'binary';

  var target = this.getView(size);
  return target ? target.toString(encoding) : null;
};

/**
 * Adapt incoming data to the format expected by this.put().
 * @param {*} data The data to adapt.
 * @returns {Buffer} The adapted data.
 */
BufferDataQueue.adaptData = function adaptData (data) {
  if (data instanceof Buffer) { return data; }
  if (data instanceof ArrayBuffer) { return new Buffer(data); }
  return Buffer.from(data);
};

module.exports.BufferDataQueue = BufferDataQueue;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;
var ref$1 = __webpack_require__(236);
var BufferDataQueue = ref$1.BufferDataQueue;
var ref$2 = __webpack_require__(3);
var Convert = ref$2.Convert;
var Hex = ref$2.Hex;
var ref$3 = __webpack_require__(1);
var LogFormatter = ref$3.LogFormatter;

var stringToUint8Array = Convert.stringToUint8Array;
var formatHexString = Hex.formatHexString;

var SMF_LOST_FRAMING_THRESHOLD = 80000000;

var ref$4 = new LogFormatter('[buffer-smf-client]');
var LOG_TRACE = ref$4.LOG_TRACE;
var LOG_ERROR = ref$4.LOG_ERROR;

// ----------------------------------------------------------------------------
// These functions properly belong in a binary SMF decoder package
// vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

function makeHeaderbuffer(ringbuffer) {
  if (ringbuffer.remaining() < 12) { return null; }
  return ringbuffer.peekView(12);
}

function isHeaderbufferValid(headerbuffer) {
  var version = headerbuffer[0] & 0x7;
  if (version !== 3) {
    LOG_ERROR(("Invalid smf version in smf header, version=" + version));
    return false;
  }
  return true;
}

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

function makeMessagebuffer(headerbuffer, ringbuffer) {
  var messageLen = headerbuffer.readUInt32BE(8);
  var remaining = ringbuffer.remaining();
  if (messageLen > remaining) { return null; }
  return ringbuffer.peekView(messageLen);
}

function logPeekBuffer(buffer) {
  LOG_ERROR(("First 64 bytes (or fewer) of incoming buffer: \n" + (DebugLib.Debug.formatDumpBytes(buffer.peekString(Math.min(buffer.remaining(), 64)), true, 0))));
}

/**
 * Interact with underlying transport to send and receive SMF messages
 * @private
 */
var BufferSMFClient = (function (BaseSMFClient) {
  function BufferSMFClient(rxSmfCB, rxMessageErrorCB, session) {
    BaseSMFClient.call(this, rxSmfCB, rxMessageErrorCB, session);
    this._incomingBuffer = new BufferDataQueue(SMF_LOST_FRAMING_THRESHOLD);
  }

  if ( BaseSMFClient ) BufferSMFClient.__proto__ = BaseSMFClient;
  BufferSMFClient.prototype = Object.create( BaseSMFClient && BaseSMFClient.prototype );
  BufferSMFClient.prototype.constructor = BufferSMFClient;

  BufferSMFClient.prototype.reset = function reset () {
    BaseSMFClient.prototype.reset.call(this);
    // Called from super constructor, so guard this
    if (this._incomingBuffer) { this._incomingBuffer.reset(); }
  };

  /**
   * @param {String} data Incoming data as binary string
   */
  BufferSMFClient.prototype.rxDataString = function rxDataString (data) {
    this._rxDataCB(Buffer.from(stringToUint8Array(data)));
  };

  /**
   * @param {ArrayBuffer} data Incoming data
   */
  BufferSMFClient.prototype.rxDataArrayBuffer = function rxDataArrayBuffer (data) {
    this._rxDataCB(Buffer.from(data));
  };

  /**
   * @param {Buffer} data Incoming data
   */
  BufferSMFClient.prototype.rxDataBuffer = function rxDataBuffer (data) {
    this._rxDataCB(data);
  };

  /**
   * Invoked by transport session. Handles multiple SMF messages in input, as well as defragmenting
   * partial SMF messages. The state we keep is in this._incomingBuffer.
   * @param {Buffer} data The binary data to decode
   */
  BufferSMFClient.prototype._rxDataCB = function _rxDataCB (data) {
    var this$1 = this;

    var buffer = this._incomingBuffer;
    if (this._session) {
      /* #stripped LOG_TRACE('Reset KeepAliveCounter') */

      // each incoming data chunk resets KA counter
      this._session.resetKeepAliveCounter();
    }

    // Add incoming data to the buffer. In node, this is only one copy:
    // wrapping ArrayBuffer in Buffer creates a view of the underlying allocation.
    var putSuccess = buffer.put(data);
    var remaining = buffer.remaining();

    if (!putSuccess) {
      // 80 megabytes - lost SMF framing: may never complete
      logPeekBuffer(buffer);
      this._rxMessageErrorCB(("Buffer overflow (length: " + remaining + ")"));
      this._incomingBuffer.reset();
    }

    var headerbuffer;
    while (remaining > 0) {
      headerbuffer = makeHeaderbuffer(buffer);
      if (!headerbuffer) { break; } // no header yet

      if (!isHeaderbufferValid(headerbuffer)) {
        // Throw away the buffer and bail out
        LOG_ERROR("BufferSMFClient._rxDataCB(): couldn't decode message due to invalid smf header");
        logPeekBuffer(buffer);
        this$1._incomingBuffer.reset();
        this$1._rxMessageErrorCB('Error parsing incoming SMF - invalid SMF header detected');
        return;
      }

      var messageBuffer = makeMessagebuffer(headerbuffer, buffer);
      if (!messageBuffer) {
        break; // no full message
      }

      /* #stripped LOG_TRACE('BufferSMFClient incoming buffer has a full SMF message') */

      var binaryString = messageBuffer.toString('binary');
      var incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(binaryString, 0);
      if (incomingMsg && incomingMsg.smfHeader) {
        buffer.advance(incomingMsg.smfHeader.messageLength);
        this$1._rxSmfCB(incomingMsg); // hand over to core API callback
      } else {
        // couldn't decode! Lost SMF framing.
        // throw away the buffer and bail out
        var sessionId = this$1._session ? this$1._session._sessionId : null;
        var sessionIdHex = sessionId ? formatHexString(sessionId) : 'N/A';
        LOG_ERROR(("BufferSMFClient._rxDataCB(): couldn't decode message (sessionId=" + sessionIdHex + ")"));
        logPeekBuffer(buffer);
        this$1._incomingBuffer.reset();
        this$1._rxMessageErrorCB('Error parsing incoming SMF');
        return;
      }
      remaining = buffer.remaining();
    }

    if (remaining) {
      // We have a partial header, or a valid header and a partial message.
      /* #stripped LOG_TRACE(`BufferSMFClient message chunk of ${remaining} bytes: partial message kept in incoming buffer`) */

      // partial message remaining: keep it in incoming buffer
    } else {
      /* #stripped LOG_TRACE('BufferSMFClient clear incoming buffer') */

      // clear incoming buffer
      this._incomingBuffer.reset();
    }
  };

  return BufferSMFClient;
}(BaseSMFClient));

module.exports.BufferSMFClient = BufferSMFClient;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(83);
var BaseSMFClient = ref.BaseSMFClient;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;

var arrayBufferToString = Convert.arrayBufferToString;
var formatHexString = Hex.formatHexString;

var SMF_LOST_FRAMING_THRESHOLD = 80000000;

var ref$3 = new LogFormatter('[string-smf-client]');
var LOG_DEBUG = ref$3.LOG_DEBUG;
var LOG_ERROR = ref$3.LOG_ERROR;

/**
 * Interact with underlying transport to send and receive SMF messages
 * @private
 */
var StringSMFClient = (function (BaseSMFClient) {
  function StringSMFClient () {
    BaseSMFClient.apply(this, arguments);
  }

  if ( BaseSMFClient ) StringSMFClient.__proto__ = BaseSMFClient;
  StringSMFClient.prototype = Object.create( BaseSMFClient && BaseSMFClient.prototype );
  StringSMFClient.prototype.constructor = StringSMFClient;

  StringSMFClient.prototype.reset = function reset () {
    BaseSMFClient.prototype.reset.call(this);
    this._incomingBuffer = '';
  };

  /**
   * @param {String} data Incoming data
   */
  StringSMFClient.prototype.rxDataString = function rxDataString (data) {
    this._rxDataCB(data);
  };

  /**
   * @param {String} data Incoming data
   */
  StringSMFClient.prototype.rxDataArrayBuffer = function rxDataArrayBuffer (data) {
    this._rxDataCB(arrayBufferToString(data));
  };

  /**
   * @param {Buffer} data incoming data
   */
  StringSMFClient.prototype.rxDataBuffer = function rxDataBuffer (data) {
    this._rxDataCB(data.toString());
  };

  /**
   * Invoked by transport session. Handles multiple SMF messages in input, as well as defragmenting
   * partial SMF messages. The state we keep is in this._incomingBuffer.
   * @param {String} data The binary data to decode
   */
  StringSMFClient.prototype._rxDataCB = function _rxDataCB (data) {
    var this$1 = this;

    if (this._session) {
      /* #stripped LOG_DEBUG('Reset KeepAliveCounter') */

      // each incoming data chunk resets KA counter
      this._session.resetKeepAliveCounter();
    }
    if (this._incomingBuffer.length === 0) {
      // optimization: set reference (cheaper than append)
      this._incomingBuffer = data;
    } else {
      // append to existing data
      this._incomingBuffer += data;
      if (this._incomingBuffer.length > SMF_LOST_FRAMING_THRESHOLD) {
        // sanity check
        // 80 megabytes - lost SMF framing: may never complete
        LOG_ERROR(("First 64 bytes (or fewer) of incoming buffer: \n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substr(0, 64), true, 0))));
        this._rxMessageErrorCB(("Buffer overflow (length: " + (this._incomingBuffer.length) + ")"));
        this._incomingBuffer = '';
      }
    }

    var pos = 0;
    while ((pos < this._incomingBuffer.length) &&
          (SMFLib.Codec.ParseSMF.isSMFAvailable(this._incomingBuffer, pos))) {
      /* #stripped LOG_DEBUG('StringSMFClient incoming buffer has a full SMF message') */


      var incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(this$1._incomingBuffer, pos);
      if (incomingMsg && incomingMsg.smfHeader) {
        pos += incomingMsg.smfHeader.messageLength;
        this$1._rxSmfCB(incomingMsg); // hand over to core API callback
      } else {
        // couldn't decode! Lost SMF framing.
        var sessionId = this$1._session ? this$1._session._sessionId : null;
        var sessionIdHex = sessionId ? formatHexString(sessionId) : 'N/A';
        LOG_ERROR(("StringSMFClient.rxDataCB(): couldn't decode message (sessionId=" + sessionIdHex + "), dumping buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this$1._incomingBuffer.substr(pos), true, 0))));
        this$1._incomingBuffer = '';
        this$1._rxMessageErrorCB(("Error parsing incoming SMF at position " + pos));
        return; // throw away all we have for now
      }
    }

    if (pos < this._incomingBuffer.length) {
      /* #stripped LOG_DEBUG(`StringSMFClient message chunk of ${data.length
                } bytes: partial message kept in incoming buffer`) */

      // isSMFHeaderValid calls isSMFHeaderAvailable
      // PERF
      if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(this._incomingBuffer, pos) &&
          (!SMFLib.Codec.ParseSMF.isSMFHeaderValid(this._incomingBuffer, pos))) {
        LOG_ERROR("StringSMFClient.rxDataCB(): couldn't decode message due to invalid smf header, dump " +
                  "first 64 bytes (or fewer) of buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(pos, 64), true, 0)));
        this._incomingBuffer = '';
        this._rxMessageErrorCB(("Error parsing incoming SMF at position " + pos + " - invalid SMF header detected"));
        return; // throw away all we have for now
      }
      // partial message remaining: keep it in incoming buffer
      var inBuffer = this._incomingBuffer;
      this._incomingBuffer = inBuffer.substr(pos, inBuffer.length - pos);
    } else {
      /* #stripped LOG_DEBUG('StringSMFClient clear incoming buffer') */

      // clear incoming buffer
      this._incomingBuffer = '';
    }
  };

  return StringSMFClient;
}(BaseSMFClient));

module.exports.StringSMFClient = StringSMFClient;


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(240);
var TcpTransportSession = ref.TcpTransportSession;

module.exports.TcpTransportSession = TcpTransportSession;


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

var net = __webpack_require__(288);
var tls = __webpack_require__(290);
var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(3);
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_WARN = ref$2.LOG_WARN;
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(0);
var mixin = ref$3.mixin;
var ref$4 = __webpack_require__(139);
var NodeTLSOptsMixin = ref$4.NodeTLSOptsMixin;
var ref$5 = __webpack_require__(4);
var parseURL = ref$5.parseURL;
var ref$6 = __webpack_require__(46);
var TransportBase = ref$6.TransportBase;
var ref$7 = __webpack_require__(141);
var TransportClientStats = ref$7.TransportClientStats;
var ref$8 = __webpack_require__(33);
var TransportError = ref$8.TransportError;
var ref$9 = __webpack_require__(17);
var TransportReturnCode = ref$9.TransportReturnCode;
var ref$10 = __webpack_require__(47);
var TransportSessionEvent = ref$10.TransportSessionEvent;
var ref$11 = __webpack_require__(24);
var TransportSessionEventCode = ref$11.TransportSessionEventCode;
var ref$12 = __webpack_require__(34);
var TransportSessionState = ref$12.TransportSessionState;


var formatHexString = Hex.formatHexString;

/**
 *
 * Tcp (smf) transport with TLS (tcps://) support.
 * Only works in node.js.
 * Modelled after the WebSocket transport mostly,
 * except there is no downgrade mechanism.
 * There is no separate "Transport" class
 * to manage the downgrade FSM:
 * The TransportSession is the Transport.

 * @private
 */
var TcpTransportSession = (function (TransportBase) {
  function TcpTransportSession(url, eventCB, client, props) {
    // instanitate instance properties defined in TransportBase
    TransportBase.call(this, url, eventCB, client, props);

    /**
     * @private
     * @type {TransportClientStats}
     */
    this._clientstats = new TransportClientStats();

    /**
     * Maximum amount of send data than can be queued.
     * NodeJS socket.write accepts all writes, growing a
     * user space buffer indefinitely.
     * The TCP transport (same as WS transport)
     * manages the size of that buffer to stay below this limit.
     * @private
     * @type {Number}
     */
    this._sendBufferMaxSize = props.sendBufferMaxSize;

    /*
     * When true, the upper layer was told NO_SPACE and must be notified
     * of the next "drained" event.
     * @private
     * @type {Boolean}
     */
    this._canSendNeeded = false;

    /*
     * One-shot flush callback.
     * Set on flush(), ran and cleared on socket drain event.
     * @private
     */
    this._flushCallback = null;

    /**
     * Flag to keep track of socket drained state:
     * Set to false when socket.write returns false,
     * (indicating user-space buffering)
     * Set to true on socket drain events.
     * (indicating the user space buffer has flushed to the OS.)
     * @type {Boolean}
     * @private
     */
    this._drained = true;

    /**
     * @type {TransportSessionState}
     * @private
     */
    this._state = TransportSessionState.DOWN;

    /**
     * @type {?Socket}
     * @private
     */
    this._socket = null;

    /**
     * Save the Event in the onError listener
     * Use it in onClose to populate the event.
     * (Tcp socket calls onError with the error then onClose.
     * WS socket calls only onClose and passes the error directly.)
     * @private
     * @type {?Error}
     */
    this._socketError = null;

    /**
     * @type {?string}
     * @private
     */
    this._sessionId = new Date().getTime();

    // Some whitebox tests expect a transport->transportSession nesting.
    this._transportSession = this;

    this._props.transportProtocol = null;
  }

  if ( TransportBase ) TcpTransportSession.__proto__ = TransportBase;
  TcpTransportSession.prototype = Object.create( TransportBase && TransportBase.prototype );
  TcpTransportSession.prototype.constructor = TcpTransportSession;

  /**
   * @override
   */
  TcpTransportSession.prototype.getClientStats = function getClientStats () {
    return this._clientstats;
  };

  /**
   * Extracts host and port from the router URL.
   * @private
   * @param {String} urlString the url
   * @returns {{String, Number}} host and port
   */
  TcpTransportSession.prototype.parseHostPort = function parseHostPort (urlString) {
    var port = null;
    var urlParsed = parseURL(urlString);
    if (urlParsed.protocol !== 'tcp:' && urlParsed.protocol !== 'tcps:') {
      // Should not happen.
      LOG_ERROR(("Tcp Transport: URL with unexpected scheme: " + (urlParsed.protocol)));
    }
    var host = urlParsed.hostname;
    port = urlParsed.port;
    if (port === null) {
      port = this._ssl ? 55443 : 55555;
    }
    // The rest of the URL (path, etc) is ignored.
    /* #stripped LOG_TRACE(`Parsing url ${urlString} -> host: ${host} , port: ${port}`) */

    return { host: host, port: port };
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   * @param {Buffer} data the data
   */
  TcpTransportSession.prototype.onData = function onData (originalSocket, data) {
    // We do not collect Rx stats.
    if (originalSocket && originalSocket !== this._socket) {
      /* #stripped LOG_DEBUG('TcpTransportSession stray onData for previous socket, ignoring.') */

      return;
    }
    if (this._client) {
      this._client.rxDataBuffer(data);
    }
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   * @param {Error} error the error
   */
  TcpTransportSession.prototype.onError = function onError (originalSocket, error) {
    if (originalSocket && originalSocket !== this._socket) {
      /* #stripped LOG_DEBUG('TcpTransportSession stray onError for previous socket, ignoring.') */

      return;
    }
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_TRACE('Tcp transport is being destroyed, ignore error') */

      return;
    }
    /* #stripped LOG_DEBUG(`Tcp transport connection error ${error}`) */

    // net.socket invokes the error handler before the close handler.
    // Websocket does not, and that's what the upper layer expects.
    // Suppressing the "double tap" error events when connected,
    // saving the error for the onClose handler in _socketerror.
    if (this._state !== TransportSessionState.SESSION_UP) {
      this._eventCB(
        new TransportSessionEvent(
          TransportSessionEventCode.SEND_ERROR,
          ("Connection error" + error),
          null,
          ErrorSubcode.CONNECTION_ERROR, null));
    } else { // we rely on the close listener to notify the upper layer.
      this._socketError = error;
    }
  };

  /**
   * Socket callback.
   * Bind the socket argument to guard against stray invocations in a
   * quick connect()-destroy()-connect() scenario.
   * @private
   * @param {Socket} originalSocket original socket
   * @param {Boolean} hadError wheter there was an error
   */
  TcpTransportSession.prototype.onClose = function onClose (originalSocket, hadError) {
    //process.stdout.write('TCP transport onClose called.\n');
    if (originalSocket && originalSocket !== this._socket) {
      /* #stripped LOG_DEBUG('TcpTransportSession stray onClose for previous socket, ignoring.') */

      return;
    }
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_TRACE('Tcp transport is being destroyed, ignore close') */

      return;
    }
    var msg = hadError ? 'with error' : 'cleanly';
    var errorMsg = this._socketError && this._socketError.message;
    this._socketError = null; // clear on read.
    /* #stripped LOG_DEBUG(`Tcp transport connection is closed ${msg}. Message: i${errorMsg}`) */

    //process.stdout.write(`Tcp transport connection is closed ${msg}. Message: ${errorMsg}`);
    this._state = TransportSessionState.CONNECTION_FAILED;
    this.destroy(("Connection closed " + msg + ". Message:" + errorMsg), ErrorSubcode.COMMUNICATION_ERROR);
  };

  /**
   * Callback for Socket.connect.
   * Bind the socket argument to guard against stray invocations in a
   * quick connect()-destroy()-connect() scenario.
   * @private
   * @param {Socket} originalSocket original socket
   */
  TcpTransportSession.prototype.onOpen = function onOpen (originalSocket) {
    /* #stripped LOG_TRACE('TcpTransportSession received socket open event.') */

    if (originalSocket && originalSocket !== this._socket) {
      /* #stripped LOG_DEBUG('TcpTransportSession stray onOpen for previous socket, ignoring.') */

      return;
    }
    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
      /* #stripped LOG_DEBUG(`TcpTransportSession stray onOpen when in state ${this._state}, ignoring.`) */

      return;
    }
    this._state = TransportSessionState.SESSION_UP;
      // Send the event to the application letting it know that the session is up
    this._eventCB(
          new TransportSessionEvent(
              TransportSessionEventCode.UP_NOTICE,
              'Connected',
              0,
              null,
              this._sessionId));
  };

  /**
   * Establish underlying transport.
   * @override
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.connect = function connect () {
    if (this._state !== TransportSessionState.DOWN) {
      LOG_ERROR(("Invalid state for operation: " + (TransportSessionState.nameOf(this._state))));
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (this._socket) {
      LOG_ERROR('TCP transport can not connect once _socket exists.');
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }
    if (!this._url) {
      LOG_WARN('Cannot connect to null URL');
      return TransportReturnCode.CONNECTION_ERROR;
    }

    /* #stripped LOG_DEBUG('Establishing Tcp transport session') */

    try {
      this._state = TransportSessionState.WAITING_FOR_CREATE;
      var ref = this.parseHostPort(this._url);
      var host = ref.host;
      var port = ref.port;
      /* #stripped LOG_DEBUG('Constructing socket') */

      // Luckily raw and tls sockets have the same API.
      if (!this._ssl) {
        this._socket = new net.Socket();
        this._socket.connect(
          port, host,
          this.onOpen.bind(this, this._socket)
        );
      } else {
        var tlsOptions = this.createTLSOptions();
        this._socket = tls.connect(
          port, host, tlsOptions
        );
        this._socket.on('secureConnect', this.onOpen.bind(this, this._socket));
      }
      /* #stripped LOG_TRACE('Assigning properties to socket') */

      // WARNING!
      // This is the kind of thing that breaks on minification.
      // Re-run unit tests in production mode when changed:
      // grunt --gruntfile=Gruntfile_Production.js
      // When broken, consult the closure compiler exceptions file:
      // (sdk-root)/builder/template/-common/env/externs.js
      this._socket.on('data', this.onData.bind(this, this._socket));
      this._socket.on('error', this.onError.bind(this, this._socket));
      this._socket.on('close', this.onClose.bind(this, this._socket));
      this._socket.on('drain', this.onDrain.bind(this, this._socket));
      this._socket.setNoDelay(true);

      /* #stripped LOG_TRACE('Prepared socket') */

    } catch (error) {
      /* #stripped LOG_DEBUG(`Error connecting: ${error}`) */

      this._state = TransportSessionState.CONNECTION_FAILED;
      throw new TransportError(("Could not create Tcp socket: " + (error.message)),
        error.subcode || ErrorSubcode.CONNECTION_ERROR);
    }
    /* #stripped LOG_DEBUG('Tcp transport is connecting') */

    return TransportReturnCode.OK;
  };

  /**
   * Destroy the underlying transport.
   * Returns transport return code.
   * @override
   * @param {?String} msg The message associated with this operation, if any.
   * @param {?ErrorSubcode} subcode The subcode associated with this operation, if any.
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.destroy = function destroy (msg, subcode) {
    if (this._state !== TransportSessionState.DOWN) {
      /* #stripped LOG_DEBUG(`Destroy Tcp transport: ${msg}`) */


      // Set state for connection teardown.
      this._state = TransportSessionState.WAITING_FOR_DESTROY;

      if (this._socket) {
        var onerrorStub = function onerrorStub() { };
        this._socket.removeAllListeners('open');
        this._socket.removeAllListeners('data');
        this._socket.removeAllListeners('close');
        this._socket.removeAllListeners('drain');
        this._socket.removeAllListeners('error');
        this._socket.on('error', onerrorStub); // Prevent unhandled errors
        // Prefering destroy() over end() as it seems to
        // cancel pending callbacks like onOpen more reliably.
        //this._socket.destroy();
        this._socket.end();
        this._socket = null;
      }

      this._canSendNeeded = false;
      this._flushCallback = null;
      this._drained = true;
      this._state = TransportSessionState.DOWN;
      this._client = null; // Don't accept data.
    }

    // always send a DESTROYED_NOTICE in response to a destroy() even
    // if we think the transport is already destroyed
    /* #stripped LOG_TRACE(`Destroying TCP transport. msg: ${msg} subcode: ${subcode}`) */

    if (this._eventCB) {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                              msg || 'Session is destroyed',
                                              null,
                                              subcode || 0,
                                              this._sessionId));
      // Release references to other components
      this._eventCB = null;
    }
    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @description Intended for clean shutdowns.
   * Callback is invoked when all nodejs-buffered data
   * has been flushed to the OS socket.
   */
  TcpTransportSession.prototype.flush = function flush (callback) {
    if (this._drained) {
      /* #stripped LOG_DEBUG('Transport emitting FLUSH immediately.') */

      callback();
    } else if (callback) {
      this._flushCallback = callback;
    }
    return TransportReturnCode.OK;
  };

  /**
   * @override
   * @description Send encoded SMF message
   * Returns transport return code.
   * @param {String} message The encoded SMF message to send
   * @param {?Boolean} [forceAllowEnqueue=false] If true, do not fail due to transport buffer full
   * @returns {TransportReturnCode} The result of this operation
   */
  TcpTransportSession.prototype.send = function send (message, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    // Limiting socket buffer size to _sendBufferMaxSize unless
    // the force flag was set
    // or the socket is drained, in which case any size message goes.
    if (forceAllowEnqueue
      || this._drained
      || this._socket.bufferSize + message.length <
      this._sendBufferMaxSize) {
      // _drained keeps track of "overflowing" writes.
      // nodejs never refuses a read but warns when it starts buffering.
      this._drained = this._socket.write(message, 'ascii');
      this._clientstats.bytesWritten += message.length;
      ++this._clientstats.msgWritten;
      return TransportReturnCode.OK;
    }
    // We'll unblock the user on the next onDrain.
    this._canSendNeeded = true;
    return TransportReturnCode.NO_SPACE;
  };

  /**
   * Socket callback.
   * Bind the socket on setup to avoid stray errors from old sockets
   * in quick connect()-destry()-connect() scenarios.
   * @private
   * @param {Socket} originalSocket the original socket
   */
  TcpTransportSession.prototype.onDrain = function onDrain (originalSocket) {
    if (originalSocket && originalSocket !== this._socket) {
      /* #stripped LOG_DEBUG('TcpTransportSession stray onDrain for previous socket, ignoring.') */

      return;
    }
    this._drained = true;

    if (this._flushCallback) {
      /* #stripped LOG_DEBUG('Transport emitting FLUSH after drain.') */

      var prevCallback = this._flushCallback;
      this._flushCallback = null;
      prevCallback();
    }

    if (this._canSendNeeded) {
      /* #stripped LOG_TRACE('Transport emitting CAN_ACCEPT_DATA') */

      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '', null, 0, this._sessionId));
    }
  };

  /**
   * @override
   */
  TcpTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "TcpTransportSession; sid=" + (formatHexString(this._sessionId));
    return str;
  };

  return TcpTransportSession;
}(TransportBase));

mixin(TcpTransportSession, NodeTLSOptsMixin);

module.exports.TcpTransportSession = TcpTransportSession;


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(84);
var WebTransportCapabilities = ref.WebTransportCapabilities;

var TransportCapabilities = {
  web: WebTransportCapabilities,
};

module.exports.TransportCapabilities = TransportCapabilities;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var TcpTransportsLib =  true ? __webpack_require__(239) : null;
var ref = __webpack_require__(84);
var WebTransport = ref.WebTransport;

var TransportFactory = {
  createTransport: function createTransport(host, eventCB, client, props, getId) {
    var url = host;
    Object.assign(props, {
      connectTimeoutInMsecs: 100000,  // TODO: can we eliminate this
    });
    // TCP transport is dictated by the URL (tcp:// or tcps://)
    // It is unaffected by the transportProtocol config parameter.
    if (TcpTransportsLib && url.trim().startsWith('tcp')) {
      return new TcpTransportsLib.TcpTransportSession(url, eventCB, client, props, getId);
    }
    return new WebTransport(url, eventCB, client, props, getId);
  },
};

module.exports.TransportFactory = TransportFactory;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var WebTransportsLib = __webpack_require__(84);
var ref = __webpack_require__(0);
var Lazy = ref.Lazy;
var ref$1 = __webpack_require__(1);
var LOG_TRACE = ref$1.LOG_TRACE;
var ref$2 = __webpack_require__(46);
var TransportBase = ref$2.TransportBase;
var ref$3 = __webpack_require__(20);
var TransportProtocol = ref$3.TransportProtocol;

var lazyValue = Lazy.lazyValue;

// Define transportProtocol to transport mapping
var lutTransportProtocols = lazyValue(function () {
  var protocols = {};
  protocols[TransportProtocol.HTTP_BASE64] = WebTransportsLib.StateBase64;
  protocols[TransportProtocol.HTTP_BINARY] = WebTransportsLib.StateBinary;
  protocols[TransportProtocol.HTTP_BINARY_STREAMING] = WebTransportsLib.StateStreamingAndBinary;
  protocols[TransportProtocol.WS_BINARY] = WebTransportsLib.StateWebSocketBinary;
  return protocols;
});

/**
 * @classdesc
 * Handles web transport selection and downgrade without creating the actual transport
 * session object
 * @memberof solace
 * @private
 */
var TransportProtocolHandler = function TransportProtocolHandler(url, webTransportProtocolList) {
  var this$1 = this;

  var useSSL = TransportBase.useSsl(url);
  var transport = null;
  var downgradeTransport = null;
  webTransportProtocolList.slice().reverse().forEach(function (el) {
    var TransportConstructor = lutTransportProtocols.value[el];
    transport = new TransportConstructor(useSSL, this$1.switchState.bind(this$1), downgradeTransport);
    downgradeTransport = transport;
  });
  this._transport = transport;
  this._transport.onEnter();
};

TransportProtocolHandler.prototype.getTransportProtocol = function getTransportProtocol () {
  return this._transport.getTransportProtocol();
};

TransportProtocolHandler.prototype.completeDowngrade = function completeDowngrade (err) {
  return this._transport.completeDowngrade(err);
};

TransportProtocolHandler.prototype.canCompleteDowngrade = function canCompleteDowngrade () {
  return (this._transport.getNextState() !== null);
};

TransportProtocolHandler.prototype.toString = function toString () {
  return this._transport.toString();
};

TransportProtocolHandler.prototype.switchState = function switchState (newState, reason) {
  /* #stripped LOG_TRACE(`Switching ${this._transport} => ${newState} (${reason})`) */

  this._transport = newState;
  newState.onEnter();
};

module.exports.TransportProtocolHandler = TransportProtocolHandler;


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

var DebugLib = __webpack_require__(14);
var SMFLib = __webpack_require__(8);
var ref = __webpack_require__(7);
var Check = ref.Check;
var ref$1 = __webpack_require__(3);
var Convert = ref$1.Convert;
var Hex = ref$1.Hex;
var ref$2 = __webpack_require__(2);
var ErrorSubcode = ref$2.ErrorSubcode;
var OperationError = ref$2.OperationError;
var ref$3 = __webpack_require__(142);
var HTTPConnection = ref$3.HTTPConnection;
var ref$4 = __webpack_require__(1);
var LogFormatter = ref$4.LogFormatter;
var ref$5 = __webpack_require__(140);
var SMFClient = ref$5.SMFClient;
var ref$6 = __webpack_require__(33);
var TransportError = ref$6.TransportError;
var ref$7 = __webpack_require__(20);
var TransportProtocol = ref$7.TransportProtocol;
var ref$8 = __webpack_require__(17);
var TransportReturnCode = ref$8.TransportReturnCode;
var ref$9 = __webpack_require__(47);
var TransportSessionEvent = ref$9.TransportSessionEvent;
var ref$10 = __webpack_require__(24);
var TransportSessionEventCode = ref$10.TransportSessionEventCode;
var ref$11 = __webpack_require__(34);
var TransportSessionState = ref$11.TransportSessionState;
var ref$12 = __webpack_require__(145);
var WebTransportSessionBase = ref$12.WebTransportSessionBase;

var int32ToStr = Convert.int32ToStr;
var strToByteArray = Convert.strToByteArray;
var strToHexArray = Convert.strToHexArray;
var formatHexString = Hex.formatHexString;

var ref$13 = new LogFormatter('[http-transport-session]');
var LOG_TRACE = ref$13.LOG_TRACE;
var LOG_DEBUG = ref$13.LOG_DEBUG;
var LOG_ERROR = ref$13.LOG_ERROR;
var LOG_INFO = ref$13.LOG_INFO;

/**
 * @private
 * @namespace Values for tracking current state of incoming streaming data
 */
var PacketReadState = {
  READING_HEADER: 0,
  STREAMING:      1,
};

/**
 * @private
 */
var MSIE_TRANSPORT_PADDING = 257;

function adaptURL(url) {
  var v = url.match(/(ws|http)(s?:\/\/.+)/);
  return ("http" + (v[2]));
}

/** ===========================================================================
 * HTTPTransportSession :
 *
 * This contains all data and code required to maintain HTTP transport sessions
 * with Solace routers
 * ============================================================================
 * @extends WebTransportSessionBase
 * @private
 */
var HTTPTransportSession = (function (WebTransportSessionBase) {
  function HTTPTransportSession(baseUrl, eventCB, client, props) {
    // Our internal data format (for now) is binary string, so we wrap the callback
    // in a function that does the required conversion to ArrayBuffer.
    WebTransportSessionBase.call(this, baseUrl,
          eventCB,
          client,
          props);

    // const self = this;
    // logger.formatter = function formatter(...args) {
    //   return [self.sessionIdHex, ...args];
    // };

    // Set to true if we have the data token that we need for sending data to the router
    this._haveToken = true;

    // Maximum payload chunk size in web transport
    this._confMaxWebPayload = props.maxWebPayload;
    this._maxPayloadBytes = 0;

    // Timer that will keep track of the destroy time
    this._destroyTimer = null;
    this._destroyTimeout = props.connectTimeoutInMsecs;

    // The URL used for create messages
    this._createUrl = adaptURL(baseUrl);

    // The URL used for all other messages - it will have the router tag appended
    // after the session has been created
    this._routerUrl = this._createUrl;

    // SMF client (instantiated after session is created)
    this._rxChannelClient = null;
    // Send data connection (instantiated after session is created)
    this._httpSendConn = null;

    // Receive data connection (instantiated after session is created)
    this._httpReceiveConn = null;

    // Data Token SMF header - this is preformatted for performance
    // It will be set after session is created
    this._smfDataTokenTSHeader = null;

    // Router Tag - a string that will be added to HTTP request URLs
    this._routerTag = '';

    // Session ID - 8-byte identifier that will associate this client
    // with client resources on the router
    this._sid = null;

    if (props.transportProtocol === null || props.transportProtocol === undefined) {
      throw new OperationError('transportProtocol is not set', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }

    this._transportProtocol = props.transportProtocol;
    this._useBinaryTransport = false;
    this._useStreamingTransport = false;
    this._streamingTransportPadding = 0;

    this._useBinaryTransport = (props.transportProtocol !== TransportProtocol.HTTP_BASE64);
    this._useStreamingTransport = (props.transportProtocol ===
                                   TransportProtocol.HTTP_BINARY_STREAMING);

    // extra state for STREAMING transport
    this._incomingBuffer = '';
    this._packetReadState = PacketReadState.READING_HEADER;

    var agent = navigator.userAgent || '';
    if (agent.match(/trident/i) || agent.match(/msie/i)) {
      this._streamingTransportPadding = MSIE_TRANSPORT_PADDING;
    }

    if (props.transportContentType === null || props.transportContentType === undefined) {
      throw new OperationError('transportContentType is not set', ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
    this._contentType = props.transportContentType;
  }

  if ( WebTransportSessionBase ) HTTPTransportSession.__proto__ = WebTransportSessionBase;
  HTTPTransportSession.prototype = Object.create( WebTransportSessionBase && WebTransportSessionBase.prototype );
  HTTPTransportSession.prototype.constructor = HTTPTransportSession;

  var prototypeAccessors = { sessionIdHex: {} };

  /**
   * @override
   */
  HTTPTransportSession.prototype.connectTimerExpiry = function connectTimerExpiry () {
    LOG_INFO('HTTP transport connect timeout');
    this.destroyCleanup('HTTP transport connect timeout', ErrorSubcode.TIMEOUT);
  };

  prototypeAccessors.sessionIdHex.get = function () {
    return (this._sid) ? formatHexString(this._sid) : '';
  };

  HTTPTransportSession.prototype.updateMaxWebPayload = function updateMaxWebPayload () {
    // 22 Bytes of TransportSMF wrapping overhead
    var trLessEncapSMF = this._confMaxWebPayload - 22;
    // Base64 has a 4:3 expansion
    this._maxPayloadBytes = this._useBinaryTransport
      ? trLessEncapSMF
      : Math.floor(trLessEncapSMF * 0.75);
  };

  /**
   * Connect transport session to router
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.connect = function connect () {
    // Check that we we are in an acceptable state for connection
    if (this._state !== TransportSessionState.DOWN) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    return this.connectInternal();
  };

  HTTPTransportSession.prototype.connectInternal = function connectInternal () {
    var this$1 = this;

    // Create the XHR to talk to the router
    this._connError = null;
    try {
      this._createConn = new HTTPConnection(this._createUrl,
                                            !(this._useBinaryTransport),
                                            false,
                                            function (rc, data) { return this$1.handleCreateResponse(rc, data); },
                                            function (rc, data) { return this$1.handleCreateConnFailure(rc, data); },
                                            this._contentType);
    } catch (e) {
      LOG_INFO(("Failed to create connection to router: " + (e.message)));
      this._connError = e;
      return TransportReturnCode.CONNECTION_ERROR;
    }
    if (Check.nothing(this._createConn)) {
      LOG_INFO('Failed to create connection to router');
      return TransportReturnCode.CONNECTION_ERROR;
    }

    // Get an SMF transport session create message
    var createMsg = SMFLib.Codec.Transport.genTsCreateHeader();

    // TODO: What is going on here?  If we are already waiting for create
    // TODO: we just skip starting the timer but other do everything else, overwriting
    // TODO: _createConn in the process with a new XMLHTTPRequest object?
    if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
      // already connecting (this is likely a retry with Base64 encoding)
      /* #stripped LOG_DEBUG('Connect attempt while in WAITING_FOR_CREATE (retry)') */

    } else {
      this.createConnectTimeout();
      // Set the current state
      this._state = TransportSessionState.WAITING_FOR_CREATE;
    }

    // Send the create message to the router.  When the response is received, the
    // handleCreateResponse method will be called
    try {
      this._createConn.send(createMsg);
    } catch (connError) {
      /* #stripped LOG_DEBUG(`Error connecting: ${connError.message}`) */

      /* #stripped LOG_TRACE('Error details:', connError.stack || connError) */

      this._state = TransportSessionState.CONNECTION_FAILED;
      this.cancelConnectTimeout();
      if (connError instanceof TransportError) {
        this._connError = connError;
      } else {
        this._connError = new TransportError(
          ("Could not create HTTP transport session: " + (connError.message)),
          connError.subcode || ErrorSubcode.CONNECTION_ERROR);
      }
      return TransportReturnCode.CONNECTION_ERROR;
    }

    return TransportReturnCode.OK;
  };

  /**
   * Destroy transport session to router
   * @param {String} msg The message associated with the operation
   * @param {ErrorSubcode} subcode The subcode associated with the operation
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.destroy = function destroy (msg, subcode) {
    var this$1 = this;

    /* #stripped LOG_TRACE(`Destroy transport session when in state ${this._state}`) */

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY ||
        this._state === TransportSessionState.DOWN) {
      // Nothing to do
      return TransportReturnCode.OK;
    }

    if (this._state === TransportSessionState.CONNECTION_FAILED ||
        this._state === TransportSessionState.WAITING_FOR_CREATE) {
      // The connections are in an unreliable state - we will just
      // kill our local object and let the router clean itself up with its inactivity timer
      /* #stripped LOG_DEBUG('The connection is in unreliable state, close transport') */

      this.destroyCleanup(msg, subcode, true);
      return TransportReturnCode.OK;
    }

    /* #stripped LOG_DEBUG('Destroy transport session immediately') */

    // Set the current state
    this._state = TransportSessionState.WAITING_FOR_DESTROY;

    // Abort any current requests for this session
    if (this._httpSendConn !== null) {
      /* #stripped LOG_DEBUG('Destroy transport session: abort sendConn') */

      this._httpSendConn.abort();
    }
    if (this._httpReceiveConn !== null) {
      /* #stripped LOG_DEBUG('Destroy transport session: abort receiveConn') */

      this._httpReceiveConn.abort();
    }

    // Start a timer
    this._destroyTimer = setTimeout(function () {
      this$1.destroyTimerExpiry();
    }, this._destroyTimeout);

    // Send the destroy message over new HTTPConnection to the router so that the async abort
    // can properly finish in the old _httpSendConn.
    // When the response is received, the handleDestroyResponse method will be called.
    this._httpSendConn = new HTTPConnection(
        this._routerUrl,
        !(this._useBinaryTransport), false,
        function (rc, data) { return this$1.handleRxDataToken(rc, data); }, // RxData callback
        function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
        this._contentType,
        true);

    // Get an SMF transport session destroy message
    var destroyMsg = SMFLib.Codec.Transport.genTsDestroyHeader(this._sid);

    /* #stripped LOG_TRACE(`destroy message: ${strToHexArray(destroyMsg)}`) */

    this._httpSendConn.send(destroyMsg);

    return TransportReturnCode.OK;
  };

  /**
   * Send data over the connection - this requires a send token
   * @param {String} dataIn The data to send
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, do not fail due to out of space
   * @returns {TransportReturnCode} The result of the operation
   */
  HTTPTransportSession.prototype.send = function send (dataIn, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var data = dataIn;
    // LOG_TRACE(`HTTPTransportSession:send ${data.length}, tx_queued:${this._queuedDataSize}`);
    if (this._state !== TransportSessionState.SESSION_UP) {
      return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
    }

    // Check to see if we already have queued data
    if ((this._queuedData.length > 0) || (!this._haveToken)) {
      return this.enqueueData(data, forceAllowEnqueue);
    }

    // Check if we need to chop up the payload
    var remainder = null;
    if (data.length > this._maxPayloadBytes) {
      remainder = data.substr(this._maxPayloadBytes);
      data = data.substr(0, this._maxPayloadBytes);

      // If no space for remainder, return FAIL without sending anything.
      if (!this.allowEnqueue(remainder.length)) {
        return this.enqueueFailNoSpace();
      }

    // LOG_DEBUG("$$ send dataChunk:" + data.length + ", remainderChunk:" + remainder.length);
    }

    // We have the token, so send the data
    this._haveToken = false;

    var transportPacketLen = (this._smfDataTSHeaderParts[0].length + 4 +
                                this._smfDataTSHeaderParts[1].length + data.length);

    this._httpSendConn.send(this._smfDataTSHeaderParts[0] +
                            int32ToStr(transportPacketLen) +
                            this._smfDataTSHeaderParts[1] +
                            data);
    this._clientstats.bytesWritten += data.length;

    if (remainder) {
      // The message was partially sent. The message written count will be incremented
      // when its last bytes go out.
      return this.enqueueData(remainder, null);
    }

    // The whole message was sent.
    this._clientstats.msgWritten++;
    return TransportReturnCode.OK;
  };

  /**
   * Push data onto the pending send queue as long as it doesn't violate
   * the max stored message size
   * @param {String} data The data to enqueue
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, don't fail due to no space.
   * @returns {TransportReturnCode} The result of the operation.
   */
  HTTPTransportSession.prototype.enqueueData = function enqueueData (data, forceAllowEnqueue) {
    if ( forceAllowEnqueue === void 0 ) forceAllowEnqueue = false;

    var dataLen = data.length;

    // LOG_DEBUG("enqueueing data: " + data.length + ", queue depth: " + this._queuedDataSize);
    if (forceAllowEnqueue || this.allowEnqueue(dataLen)) {
      this._queuedDataSize += dataLen;
      this._queuedData.push(data);
    } else {
      return this.enqueueFailNoSpace();
    }

    return TransportReturnCode.OK;
  };

  /**
   * Set the data in the preformatted headers.  The headers are set up this way
   * for performance reasons
   * @param {String} sid The session ID to incorporate into the headers
   */
  HTTPTransportSession.prototype.initPreformattedHeaders = function initPreformattedHeaders (sid) {
    // _smfDataTSHeaderParts is a two entry array - one part before the total length
    // and the other after.  The total length is not known until actual data is sent
    this._smfDataTSHeaderParts = SMFLib.Codec.Transport.genTsDataMsgHeaderParts(sid);

    // _smfDataTokenTSHeader is a single header that all data-token messages require
    if (this._useStreamingTransport) {
      this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataStreamTokenMsg(
        sid,
        this._streamingTransportPadding);
    } else {
      this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataTokenMsg(sid);
    }
  };

  /**
   * @override
   */
  HTTPTransportSession.prototype.flush = function flush (callback) {
    if (this._queuedDataSize) {
      this._flushCallback = callback;
    } else {
      callback();
    }
  };

  /**
   * Check if there is any data waiting to be sent to the router.
   * If there is, send it.
   */
  HTTPTransportSession.prototype.sendQueuedData = function sendQueuedData () {
    if (this._queuedDataSize === 0) {
      return;
    }
    this._haveToken = false;
    var data = this.getQueuedDataToSend();
    var transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 +
                               this._smfDataTSHeaderParts[1].length + data.length;

    this._httpSendConn.send(this._smfDataTSHeaderParts[0] +
                            int32ToStr(transportPacketLen) +
                            this._smfDataTSHeaderParts[1] +
                            data);
    this._clientstats.bytesWritten += data.length;


    if (this._canSendNeeded) {
      this._canSendNeeded = false;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA,
                                  '',
                                  null,
                                  0,
                                  this._sid));
    }

    if (this._flushCallback) {
      var cb = this._flushCallback;
      this._flushCallback = null;
      cb();
    }
  };

  // Internal Callbacks

  // Called when a create response message has been received
  HTTPTransportSession.prototype.handleCreateResponse = function handleCreateResponse (tsRc, response) {
    var this$1 = this;

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY ||
        this._state === TransportSessionState.DOWN) {
      /* #stripped LOG_DEBUG('Received create response on a destroyed transport session, ignore') */

      return;
    }

    // Was: stop the connect timer. We don't do that in this transport now.
    // We wait for the login response.

    // We know whether we're using Base64 or not, so update our max payload size.
    this.updateMaxWebPayload();

    if (tsRc !== TransportReturnCode.OK) {
      /* #stripped LOG_DEBUG(`Received create response with return code ${TransportReturnCode.describe(tsRc)}`) */

      if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
        this.destroyCleanup('Received data decode error on create session response', ErrorSubcode.DATA_DECODE_ERROR);
      } else {
        this.destroyCleanup('Failed to handle create session response', ErrorSubcode.CONNECTION_ERROR);
      }
      return;
    }

    if (response.length === 0) {
      return; // null read indicating end of stream
    }

    // Parse the Transport Session SMF
    var parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(response, 0);

    if (!parsedResponse) {
      LOG_ERROR('Could not parse create response as SMF. Destroying transport');
      this.destroyCleanup('Failed to parse create response message', ErrorSubcode.CONNECTION_ERROR);
      return;
    }

    var smfresponse = parsedResponse.getResponse();
    if (smfresponse.responseCode !== 200) {
      this.destroyCleanup(("Transport create request failed (" + (smfresponse.responseCode) + ", " + (smfresponse.responseString) + ")"),
                          ErrorSubcode.CONNECTION_ERROR);
      return;
    }

    this.cancelConnectTimeout();
    this._createConn.abort();
    this._createConn = null;
    this._state = TransportSessionState.SESSION_UP;
    this._sid = parsedResponse.sessionId;
    this._routerTag = parsedResponse.routerTag;

    // Trim any parameters off the create url before using it for the routerUrl
    this._routerUrl = this._createUrl.replace(/\?.*/, '');
    if (this._routerTag !== '') {
      this._routerUrl = this._routerUrl + this._routerTag;
    }

    this.initPreformattedHeaders(this._sid);
    var useBase64 = !this._useBinaryTransport;
    var useStreaming = this._useStreamingTransport;

    // Create the two connections to the router
    // By now, getXhrObj() should not throw any exception inside HTTPConnection constructor
    this._httpSendConn = new HTTPConnection(this._routerUrl, useBase64, false,
        function (rc, data) { return this$1.handleRxDataToken(rc, data); }, // RxData callback
        function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
        this._contentType);
    if (this._useStreamingTransport) {
      // When the transport is HTTP_BINARY_STREAMING the SMF encapsulation
      // is complete, the SMF header indicates a message length of 0xFFFFFFFF
      // and after decoding just the header alone the data is passed through
      // to the session layer, so we must use a simplified SMF parser and a
      // stateful data callback in that case.
      this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming,
            function (rc, data) { return this$1.handleRxStreaming(rc, data); }, // RxData Callback
            function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
            this._contentType,
            true);
    } else {
      // Create a SMF client for the Receive Data channel, when http is used.
      // SMF messages are encapsualated in a solace http-transport which is itself
      // encapsulated in SMF.  So create an SMF client that will callback with
      // an smfMessage construct to the HTTPTransportSession.
      this._rxChannelClient = new SMFClient(
            function (rxData) { return this$1.handleSmfMessage(rxData); },
            function (rxError) { return this$1.handleSmfParseError(rxError); },
            null);    // we don't have a 'session' for this client. It's just a parser.
      this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming,
            function (rc, data) { return this$1.handleRxData(rc, data); }, // RxData Callback
            function (rc, data) { return this$1.handleSendFailure(rc, data); }, // connection close or error callback
            this._contentType);
    }

    // Give the router the data token so that it will be able to send data
    this._httpReceiveConn.send(this._smfDataTokenTSHeader);

    // Send the event to the application letting it know that the session is up
    this._eventCB(
      new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE,
                                smfresponse.responseString,
                                smfresponse.responseCode,
                                0,
                                parsedResponse.sessionId));
  };

  // Called when receiving a destroy response
  HTTPTransportSession.prototype.handleDestroyResponse = function handleDestroyResponse (response) {
    /* #stripped LOG_DEBUG('Handle destroy response') */

    // Stop the timer
    this.cancelDestroyTimeout();
    var innerResponse = response.getResponse();
    var responseString = innerResponse ? innerResponse.responseString : '';
    this.destroyCleanup(
      (responseString + " handled Destroy Response addressed to session " + (formatHexString(response.sessionId)) + ", on session " + (formatHexString(this._sid))),
      0);
  };

  HTTPTransportSession.prototype.handleSmfMessage = function handleSmfMessage (tsmsg) {
    var smfHeader = tsmsg.smfHeader;
    if (smfHeader.smf_protocol !== SMFLib.SMFProtocol.TSESSION) {
      this.handleSmfParseError(("Unexpected Message Prototcol (" + (smfHeader.smf_protocol) + ") on ReceiveData connection"));
      return;
    }

      // we have found a transport SMF, can we now read the Transport SMF chunk
    var data = tsmsg.payload;
    var TotalPayloadToRead = tsmsg.payloadLength;

    switch (tsmsg.messageType) {
      case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
        this.handleDestroyResponse(tsmsg);
        return;

      case SMFLib.SMFTransportSessionMessageType.DATA:
        if (tsmsg.sessionId !== this._sid) {
          // The router may have given us an error code; if so, include in the error message.
          var smfErrResponse = tsmsg.getResponse();
          var responseErrStr = smfErrResponse
              ? ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")"))
              : '';
          var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

          /* #stripped LOG_DEBUG(`HandleRxData Bad Session ID received in message. Expected: ${strToByteArray(this._sid)
                        }, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`) */


          this._state = TransportSessionState.CONNECTION_FAILED;
          this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                        ("Session ID mismatch in data message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(tsmsg.sessionId)) + ", " + responseErrStr),
                        responseCode,
                        ErrorSubcode.PROTOCOL_ERROR, this._sid));
          return;
        }

        // pass-through encapsulated data to parent
        if (TotalPayloadToRead > 0) {
          this._client.rxDataString(data);
        }
        break;
      default:
        // Unexpected message type
        this.handleSmfParseError(("Unexpected message type (" + (tsmsg.messageType) + ") on ReceiveData connection"));
    }
  };

  HTTPTransportSession.prototype.handleSmfParseError = function handleSmfParseError () {
    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR,
        'Received data decode error', null,
        ErrorSubcode.DATA_DECODE_ERROR, this._sid));
  };

  // Called when data is received on the connection
  HTTPTransportSession.prototype.handleRxData = function handleRxData (tsRc, data) {
    if (this._httpReceiveConn === null || this._rxChannelClient === null) {
      if (this._state === TransportSessionState.DOWN) {
        /* #stripped LOG_DEBUG('Transport session is down, ignore data from receive connection') */

      } else {
        LOG_ERROR(("Transport session is not in working state, state: " + (this._state)));
      }
      return;
    }

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_DEBUG('Transport session is being destroyed, ignore data from receive connection, ' +
               `dump first 64 bytes (or fewer) of data:\n${
                 DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`) */

      return;
    }

    this._httpReceiveConn.recStat('GotData');
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      /* #stripped LOG_DEBUG('Send write token to router') */

      this._httpReceiveConn.send(this._smfDataTokenTSHeader);
    } else {
      this._rxChannelClient.rxDataString(data);
    } // end have data to process
  };

  // Called when data is received on a HTTP_BINARY_STREAMING connection
  HTTPTransportSession.prototype.handleRxStreaming = function handleRxStreaming (tsRc, data) {
    if (this._httpReceiveConn === null) {
      if (this._state === TransportSessionState.DOWN) {
        /* #stripped LOG_DEBUG('Transport session is down, ignore data from receive connection') */

      } else {
        LOG_ERROR(("Transport session is not in working state, state: " + (this._state)));
      }
      return;
    }

    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      /* #stripped LOG_DEBUG('Transport session is being destroyed, ignore data from streaming receive ' +
               `connection, dump first 64 bytes (or fewer) of data:\n${
               DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`) */

      return;
    }

    this._httpReceiveConn.recStat('GotData');
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      /* #stripped LOG_TRACE('Send write token to router') */

      this._packetReadState = PacketReadState.READING_HEADER;
      this._httpReceiveConn.send(this._smfDataTokenTSHeader);
      return;
    }

    // pass-through encapsulated data to parent
    if (this._packetReadState === PacketReadState.STREAMING) {
      this._client.rxDataString(data);
      return;
    }

    this._incomingBuffer += data;
    var smfheader = SMFLib.Codec.ParseSMF.parseSMFAt(this._incomingBuffer, 0, true);
    if (smfheader) {
        // we have a valid smf header, see if there is a transport header and session-id
      var tsmsg = SMFLib.Codec.Transport.parseTsSmfHdrAt(this._incomingBuffer,
                                                           smfheader.headerLength,
                                                           smfheader);
      if (!tsmsg) {
        // Not tsMsg but there is an smf header, just return until more data arrives
        return;
      }

      // We have the transport message header too, if it is a DATA message enter
      // STREAMING state
      switch (tsmsg.messageType) {
        case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
          this.handleDestroyResponse(tsmsg);
          return;

        case SMFLib.SMFTransportSessionMessageType.DATA:
          if (tsmsg.sessionId !== this._sid) {
            // The router may have given us an error code, if so, include in the error message.
            var smfErrResponse = tsmsg.getResponse();
            var responseErrStr = smfErrResponse
                ? ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")"))
                : '';
            var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

            /* #stripped LOG_DEBUG(`HandleRxData Bad Session ID received in message.  Expected: ${strToByteArray(this._sid)
                        }, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`) */

            /* #stripped LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`) */


            this._state = TransportSessionState.CONNECTION_FAILED;
            this._eventCB(
              new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                                        ("Session ID mismatch in data message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(tsmsg.sessionId)) + ", " + responseErrStr),
                                        responseCode,
                                        ErrorSubcode.PROTOCOL_ERROR, this._sid));
            return;
          }
          // all is good. We can now STREAM the rest of the data until a empty message is received.
          this._packetReadState = PacketReadState.STREAMING;
          // pass-through any remaining data
          if (this._incomingBuffer.length > (smfheader.headerLength + tsmsg.tsHeaderLength)) {
            this._client.rxDataString(
              this._incomingBuffer.substr(smfheader.headerLength + tsmsg.tsHeaderLength));
          }
          this._incomingBuffer = '';
          return;

        default:
          // Unexpected message type
          throw new TransportError(("Unexpected message type (" + (tsmsg.messageType) + ") on ReceiveData connection"), 0);
      }
    } else if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(this._incomingBuffer, 0) &&
               !SMFLib.Codec.ParseSMF.isSMFHeaderValid(this._incomingBuffer, 0)) {
      // Probably lost framing
      LOG_ERROR(("Couldn't decode message due to invalid smf header, dump first 64 bytes (or fewer) of buffer content:\n" + (DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(0, 64), true, 0))));

      var errorInfo = 'Error parsing incoming message - invalid SMF header detected';
      this._state = TransportSessionState.CONNECTION_FAILED;
      this._eventCB(
        new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                                  errorInfo, null,
                                  ErrorSubcode.PROTOCOL_ERROR,
                                  null));
    }
  };

  // Called when data is received on the httpDataSend
  HTTPTransportSession.prototype.handleRxDataToken = function handleRxDataToken (tsRc, data) {
    if (tsRc !== TransportReturnCode.OK) {
      this.handleRxError(tsRc, data);
      return;
    }

    if (data.length === 0) {
      return; // handle End of Stream
    }

    var parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
    if (!parsedResponse) {
      if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
        this._state = TransportSessionState.CONNECTION_FAILED;
        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                'Failed to parse received data message', null,
                ErrorSubcode.PROTOCOL_ERROR, this._sid));
      } else {
        this.destroyCleanup('Failed to parse received data message', ErrorSubcode.PROTOCOL_ERROR);
      }
      return;
    }

    if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DESTROY_RESP) {
      this.handleDestroyResponse(parsedResponse);
      return;
    }

    if (parsedResponse.sessionId !== this._sid) {
        // The router may have given us an error code, if so, include in the error message.
      var smfErrResponse = parsedResponse.getResponse();
      var responseErrStr = smfErrResponse ?
            ((" (" + (smfErrResponse.responseCode) + " " + (smfErrResponse.responseString) + ")")) :
            '';
      var responseCode = smfErrResponse ? smfErrResponse.responseCode : null;

      /* #stripped LOG_DEBUG(`HandleRxDataToken Bad SID received in message.  Expected: ${strToByteArray(this._sid)
            }, Received: ${strToByteArray(parsedResponse.sessionId)}${responseErrStr}`) */

      /* #stripped LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`) */


      if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
        this._state = TransportSessionState.CONNECTION_FAILED;
        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE,
                ("Session ID mismatch in response message, expected: " + (formatHexString(this._sid)) + ", got: " + (formatHexString(parsedResponse.sessionId)) + ", " + responseErrStr),
                responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
      } else {
        this.destroyCleanup('Session ID mismatch in response message', ErrorSubcode.PROTOCOL_ERROR);
      }
      return;
    }

    if (parsedResponse.messageType ===
        SMFLib.SMFTransportSessionMessageType.DATA_TOKEN ||
        parsedResponse.messageType ===
        SMFLib.SMFTransportSessionMessageType.DATA_STREAM_TOKEN) {
      this._haveToken = true;
      this._httpSendConn.recStat('GotToken');
      // this._eventCB(
      //    new TransportSessionEvent(TransportSessionEventCode.NOTIFY_GOT_TOKEN, "", null, null));
      this.sendQueuedData();
    } else {
        // Unexpected message type
      throw (new TransportError(("Unexpected message type (" + (parsedResponse.messageType) + ") on SendData connection"), 0));
    }
  };

  HTTPTransportSession.prototype.handleRxError = function handleRxError (tsRc /*, data */) {
    LOG_INFO(("handleRxError, transport return code " + (TransportReturnCode.name(tsRc))));
    this._state = TransportSessionState.CONNECTION_FAILED;
    if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR,
            'Received data decode error', null,
            ErrorSubcode.DATA_DECODE_ERROR, this._sid));
    } else {
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR,
            'Connection error',
            ErrorSubcode.CONNECTION_ERROR, this._sid));
    }
  };

  // Called when there is an error on a connection or the connection is aborted
  HTTPTransportSession.prototype.handleSendFailure = function handleSendFailure (status, msg) {
    // failed to send message, if it is a destroy message, just complete the destroy process\
    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
      LOG_INFO(("Connection destroy failure (" + msg + ") while in state " + (this._state)));
      this.destroyCleanup(("Connection destroy failure: " + msg), ErrorSubcode.CONNECTION_ERROR);
    } else {
      // Failed to send message, return error to upper layer which may  tear the session down
      LOG_INFO(("Connection failure (" + msg + ") while in state " + (this._state)));
      this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR,
            ("Connection error: " + msg), status,
            ErrorSubcode.CONNECTION_ERROR, this._sid));
    }
  };

  // Called when there is an error on a connection for a session create request
  HTTPTransportSession.prototype.handleCreateConnFailure = function handleCreateConnFailure (status, msg) {
    if (this._state === TransportSessionState.DOWN) {
      return;
    }

    LOG_INFO(("Connection create failure (" + msg + ") while in state " + (this._state)));
    this.destroyCleanup(("Connection create failure: " + msg), ErrorSubcode.CONNECTION_ERROR);
  };

  // Called when the destroy timer expires
  HTTPTransportSession.prototype.destroyTimerExpiry = function destroyTimerExpiry () {
    this.destroyCleanup('Destroy request timeout', ErrorSubcode.CONNECTION_ERROR);
  };

  HTTPTransportSession.prototype.cancelDestroyTimeout = function cancelDestroyTimeout () {
    if (this._destroyTimer) {
      clearTimeout(this._destroyTimer);
      this._destroyTimer = null;
    }
  };

  /**
   * Called after receiving ts destroy response from router
   * @param {String} infoStr The informational string to pass along
   * @param {ErrorSubcode} subcode The subcode associated with the event
   * @param {Boolean} asyncSendEvent If true, always send the event asynchronously.
   */
  HTTPTransportSession.prototype.destroyCleanup = function destroyCleanup (infoStr, subcode, asyncSendEvent) {
    var this$1 = this;

    /* #stripped LOG_DEBUG(`Destroy cleanup: ${infoStr}`) */


    // Abort any current requests for this session
    if (this._createConn) {
      /* #stripped LOG_DEBUG('Destroy cleanup: Abort createConn') */

      this._createConn.abort();
    }
    if (this._httpSendConn) {
      /* #stripped LOG_DEBUG('Destroy cleanup: Abort sendConn') */

      this._httpSendConn.abort();
    }
    if (this._httpReceiveConn) {
      /* #stripped LOG_DEBUG('Destroy cleanup: Abort receiveConn') */

      this._httpReceiveConn.abort();
    }

    // Clear most internal state
    this._createUrl = null;
    this._routerUrl = null;
    this._createConn = null;
    this._httpSendConn = null;
    this._httpReceiveConn = null;
    this._smfDataTokenTSHeader = null;
    this._rxChannelClient = null;
    this._routerTag = '';
    this._queuedData = [];
    this._queuedDataSize = 0;
    this._canSendNeeded = false;

    // Clear timers.
    this.cancelDestroyTimeout();
    this.cancelConnectTimeout();

    // Set final state
    this._state = TransportSessionState.DOWN;

    // Send the event to the application letting it know that the session is down
    var finalize = function () {
      // Check whether the callback was cleared before the timeout completes.
      if (this$1._eventCB) {
        this$1._eventCB(
            new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE,
                                      infoStr || 'Session is destroyed',
                                      null,
                                      subcode || 0,
                                      this$1._sid));
      }

      // release reference to smf client object
      this$1._client = null;
      // release reference to session object
      this$1._eventCB = null;
    };

    if (asyncSendEvent) {
      setTimeout(finalize, 0); // TODO: setImmediate
    } else {
      finalize();
    }
  };

  HTTPTransportSession.prototype.getInfoStr = function getInfoStr () {
    var str = "HTTPTransportSession; sid=" + (formatHexString(this._sid)) + "; routerTag=" + (this._routerTag);
    return str;
  };

  Object.defineProperties( HTTPTransportSession.prototype, prototypeAccessors );

  return HTTPTransportSession;
}(WebTransportSessionBase));

module.exports.HTTPTransportSession = HTTPTransportSession;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(3);
var Base64 = ref.Base64;
var Convert = ref.Convert;
var ref$1 = __webpack_require__(143);
var XHRFactory = ref$1.XHRFactory;

var base64Encode = Base64.encode;
var stringToUint8Array = Convert.stringToUint8Array;

function sendXhrBinaryMSIE10(xhr, data, contentType) {
  xhr.responseType = 'arraybuffer';
  xhr.overrideMimeType((contentType + "; charset=x-user-defined"));
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(stringToUint8Array(data));
}

function sendXhrBinaryXHR2(xhr, data, contentType) {
  xhr.overrideMimeType((contentType + "; charset=x-user-defined"));
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(stringToUint8Array(data).buffer);
}

function sendXhrText(xhr, data, contentType, connClose) {
  xhr.setRequestHeader('Content-Type', (contentType + "; charset=x-user-defined"));
  xhr.send(data === null || data === undefined ? data : base64Encode(data), connClose);
}

var sendXhrBinary = (function () {
  // Uint8Array is probably shimmed by core-js. We don't use window.Blob, but
  // it is a Working Draft, not  part of ES6, and not shimmed by core-js.
  // Therefore it makes a workable canary for IE10 detection.
  if (typeof window !== 'undefined' && window.Uint8Array && window.Blob /* !ie9 */) {
    var xhr = XHRFactory.create(true);
    if (xhr.responseType /* ie10 */) {
      return sendXhrBinaryMSIE10;
    }
    return sendXhrBinaryXHR2;
  }
  return sendXhrText;
})();

module.exports.sendXhrBinary = sendXhrBinary;
module.exports.sendXhrText = sendXhrText;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;

/**
 * @classdesc
 * HTTP Base64 transport
 * @memberof solace
 * @private
 */
var StateBase64 = (function (TSHState) {
  function StateBase64(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BASE64, exitCb, nextState);
  }

  if ( TSHState ) StateBase64.__proto__ = TSHState;
  StateBase64.prototype = Object.create( TSHState && TSHState.prototype );
  StateBase64.prototype.constructor = StateBase64;

  return StateBase64;
}(TSHState));

module.exports.StateBase64 = StateBase64;



/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * HTTP Binary transport
 * @memberof solace
 * @private
 */
var StateBinary = (function (TSHState) {
  function StateBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BINARY, exitCb, nextState);
  }

  if ( TSHState ) StateBinary.__proto__ = TSHState;
  StateBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateBinary.prototype.constructor = StateBinary;

  StateBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.xhrBinary();
  };

  return StateBinary;
}(TSHState));

module.exports.StateBinary = StateBinary;



/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * HTTP Binary Streaming transport
 * @memberof solace
 * @private
 */
var StateStreamingAndBinary = (function (TSHState) {
  function StateStreamingAndBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.HTTP_BINARY_STREAMING, exitCb, nextState);
  }

  if ( TSHState ) StateStreamingAndBinary.__proto__ = TSHState;
  StateStreamingAndBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateStreamingAndBinary.prototype.constructor = StateStreamingAndBinary;

  StateStreamingAndBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.streaming() && WebTransportCapabilities.xhrBinary();
  };

  return StateStreamingAndBinary;
}(TSHState));

module.exports.StateStreamingAndBinary = StateStreamingAndBinary;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(20);
var TransportProtocol = ref.TransportProtocol;
var ref$1 = __webpack_require__(48);
var TSHState = ref$1.TSHState;
var ref$2 = __webpack_require__(49);
var WebTransportCapabilities = ref$2.WebTransportCapabilities;

/**
 * @classdesc
 * WebSocket transport
 * @memberof solace
 * @private
 */
var StateWebSocketBinary = (function (TSHState) {
  function StateWebSocketBinary(useSsl, exitCb, nextState) {
    TSHState.call(this, useSsl, TransportProtocol.WS_BINARY, exitCb, nextState);
  }

  if ( TSHState ) StateWebSocketBinary.__proto__ = TSHState;
  StateWebSocketBinary.prototype = Object.create( TSHState && TSHState.prototype );
  StateWebSocketBinary.prototype.constructor = StateWebSocketBinary;

  StateWebSocketBinary.prototype.validateLegal = function validateLegal () { // eslint-disable-line class-methods-use-this
    return WebTransportCapabilities.webSocket();
  };

  return StateWebSocketBinary;
}(TSHState));

module.exports.StateWebSocketBinary = StateWebSocketBinary;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {


var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var ref$1 = __webpack_require__(15);
var FsmEvent = ref$1.FsmEvent;
var State = ref$1.State;
var StateMachine = ref$1.StateMachine;
var ref$2 = __webpack_require__(1);
var LogFormatter = ref$2.LogFormatter;
var ref$3 = __webpack_require__(17);
var TransportReturnCode = ref$3.TransportReturnCode;
var ref$4 = __webpack_require__(47);
var TransportSessionEvent = ref$4.TransportSessionEvent;
var ref$5 = __webpack_require__(24);
var TransportSessionEventCode = ref$5.TransportSessionEventCode;
var ref$6 = __webpack_require__(144);
var WebTransportEvent = ref$6.WebTransportEvent;
var ref$7 = __webpack_require__(251);
var WebTransportState = ref$7.WebTransportState;

var ref$8 = new LogFormatter();
var LOG_TRACE = ref$8.LOG_TRACE;
var LOG_DEBUG = ref$8.LOG_DEBUG;

var WebTransportFSM = (function (StateMachine) {
  function WebTransportFSM(transportIn, getId) {
    var this$1 = this;

    StateMachine.call(this, { name: 'WebTransportFSM' });
    var transport = transportIn;
    var fsm = this;
    var logger = new LogFormatter();
    logger.formatter = function logFormatter() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return [("[web-transport-fsm=" + (getId()) + "]") ].concat( args);
    };
    this.log = logger.wrap(this.log, this);
    this.transport = transport;

    this.initial(function onInitial() {
      return this.transitionTo(
        this.WebTransportDown,
        function (context) {
          /* #stripped LOG_TRACE(`Starting ${context.getStateMachine().getName()}`) */

        });
    });

    this.unhandledEventReaction(function onUnhandledEvent(wEvent) {
      /* #stripped LOG_TRACE(`Ignoring event ${wEvent.getName()} in state ${this.getCurrentState().getName()}`) */

      return this;
    });

    this.WebTransportDown = new State({
      name:          WebTransportState.DOWN,
      parentContext: this,
    })
      .reaction(WebTransportEvent.CONNECT, function onConnect(/* wEevent */) {
        return this.transitionTo(fsm.WebTransportConnecting);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });

    this.WebTransportConnecting = new State({
      name:          WebTransportState.CONNECTING,
      parentContext: this,
    })
      .entry(function () {
        try {
          var rc = transport.connectInternal();
          if (rc !== TransportReturnCode.OK) {
            var connError = transport.getConnError();
            var wEvent = new FsmEvent({ name: WebTransportEvent.DESTROY });
            wEvent._destroyMsg = connError ? connError.message : 'Error occurred while establishing transport';
            wEvent._subcode = connError ? connError.subcode : null;
            wEvent._eventReason = connError;
            return this$1.processEvent(wEvent);
          }
        } catch (e) {
          /* #stripped LOG_DEBUG(`transport.connectInternal threw: ${e.message}`) */

          var wEvent$1 = new FsmEvent({ name: WebTransportEvent.DESTROY });
          wEvent$1._destroyMsg = e.message;
          wEvent$1._subcode = e.subcode ? e.subcode : ErrorSubcode.CONNECTION_ERROR;
          wEvent$1._eventReason = e;
          return this$1.processEvent(wEvent$1);
        }
        return undefined;
      })
      // Transport destroy is async, so in downgrade cases we need an event to start the downgrade
      // (and associated transport destroy) and one to complete it (DESTROYED_NOTICE).
      // These two events trigger downgrade: SEND_ERROR on connection (protocol issue) and
      // CONNECT_TIMEOUT (possible black hole proxy).
      .reaction(WebTransportEvent.SEND_ERROR, function (wEvent) {
        transport.notifyEvent(wEvent._transportEvent); // Give the session a chance to intervene
        return fsm.attemptDowngrade(wEvent._transportEvent);
      })
      .reaction(WebTransportEvent.CONNECT_TIMEOUT, function (e) { return fsm.attemptDowngrade(e._transportEvent); })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function (wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this$1.transitionTo(fsm.WebTransportDown);
      })
      .reaction(WebTransportEvent.UP_NOTICE, function onUpNotice(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportUp);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportDowngrading = new State({
      name:          WebTransportState.DOWNGRADING,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        /* #stripped LOG_DEBUG('Web transport: request downgrade') */

        if (!transport.completeDowngrade()) {
          /* #stripped LOG_DEBUG('Web transport: connection error, no downgrade') */

          transport.notifyEvent(wEvent._transportEvent);
          fsm.notifyDowngradeFailed();
          return this.transitionTo(fsm.WebTransportDown);
        }
        return this.transitionTo(fsm.WebTransportConnecting);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportUp = new State({
      name:          WebTransportState.UP,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DOWNGRADE, function (wEvent) { return fsm.attemptDowngrade(new TransportSessionEvent(wEvent._downgradeMsg, wEvent._subcode)); })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportDown);
      })
      .reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      })
      .reaction(WebTransportEvent.SEND_ERROR, function onUpNotice(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
        return this.transitionTo(fsm.WebTransportDestroying);
      });
    this.WebTransportDestroying = new State({
      name:          WebTransportState.DESTROYING,
      parentContext: this,
    })
      .reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
        transport.notifyEvent(wEvent._transportEvent);
        return this.transitionTo(fsm.WebTransportDown);
      });
  }

  if ( StateMachine ) WebTransportFSM.__proto__ = StateMachine;
  WebTransportFSM.prototype = Object.create( StateMachine && StateMachine.prototype );
  WebTransportFSM.prototype.constructor = WebTransportFSM;


    /**
     * Attempt a downgrade. This is the procedure.
     * 1. Call this. If it returns true, wait for DESTROYED_NOTICE, then
     * 2. Call transport.completeDowngrade().
     * @param {TransportSessionEvent} tsEvent The event triggering the downgrade
     * @returns {Boolean} `true` if downgrade is starting (by destroying the transport)
     */
  WebTransportFSM.prototype.attemptDowngrade = function attemptDowngrade (tsEvent) {
    var infoStr = tsEvent.infoStr;
    var errorSubcode = tsEvent.errorSubcode;
    if (!this.transport.beginDowngrade(infoStr, errorSubcode)) {
      /* #stripped LOG_TRACE('Downgrade unavailable') */

      this.transport.destroyInternal(infoStr, errorSubcode);
      this.transport.notifyEvent(tsEvent);
      return this.transitionTo(this.WebTransportDestroying);
    }
    /* #stripped LOG_TRACE('Downgrade available') */

    return this.transitionTo(this.WebTransportDowngrading);
  };

  WebTransportFSM.prototype.notifyDowngradeFailed = function notifyDowngradeFailed () {
    /* #stripped LOG_TRACE('Notifying of downgrade failure') */

    this.transport.notifyEvent(new TransportSessionEvent(TransportSessionEventCode.DOWNGRADE_FAILED,
                                  'Downgrade failed'));
  };

  return WebTransportFSM;
}(StateMachine));

module.exports.WebTransportFSM = WebTransportFSM;


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(0);
var Enum = ref.Enum;

// WebTransport states, used by WebTransport
var WebTransportState = {
  DOWN:        'WebTransportDown',
  CONNECTING:  'WebTransportConnecting',
  DOWNGRADING: 'WebTransportDowngrading',
  DESTROYING:  'WebTransportDestroying',
  UP:          'WebTransportUp',
};

module.exports.WebTransportState = Enum.new(WebTransportState);


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(2);
var ErrorSubcode = ref.ErrorSubcode;
var OperationError = ref.OperationError;
var ref$1 = __webpack_require__(85);
var HTTPTransportSession = ref$1.HTTPTransportSession;
var ref$2 = __webpack_require__(1);
var LOG_TRACE = ref$2.LOG_TRACE;
var LOG_DEBUG = ref$2.LOG_DEBUG;
var LOG_ERROR = ref$2.LOG_ERROR;
var ref$3 = __webpack_require__(15);
var FsmEvent = ref$3.FsmEvent;
var ref$4 = __webpack_require__(46);
var TransportBase = ref$4.TransportBase;
var ref$5 = __webpack_require__(20);
var TransportProtocol = ref$5.TransportProtocol;
var ref$6 = __webpack_require__(243);
var TransportProtocolHandler = ref$6.TransportProtocolHandler;
var ref$7 = __webpack_require__(17);
var TransportReturnCode = ref$7.TransportReturnCode;
var ref$8 = __webpack_require__(24);
var TransportSessionEventCode = ref$8.TransportSessionEventCode;
var ref$9 = __webpack_require__(146);
var WebSocketTransportSession = ref$9.WebSocketTransportSession;
var ref$10 = __webpack_require__(144);
var WebTransportEvent = ref$10.WebTransportEvent;
var ref$11 = __webpack_require__(250);
var WebTransportFSM = ref$11.WebTransportFSM;

/**
 * @classdesc
 * This class manages all the web based transport protocols.
 * <ul>
 *     <li>{@link TransportProtocol.HTTP_BASE64}
 *     <li>{@link TransportProtocol.HTTP_BINARY}
 *     <li>{@link TransportProtocol.HTTP_BINARY_STREAMING}
 *     <li>{@link TransportProtocol.WS_BINARY}
 * </ul>
 * @extends TransportBase
 * @private
 */
var WebTransport = (function (TransportBase) {
  function WebTransport(url, eventCB, client, props, getId) {
    TransportBase.call(this, url, eventCB, client, props);
    /* #stripped LOG_TRACE(`webTransportProtocolList ${props.webTransportProtocolList}`) */

    this._transportHandler = new TransportProtocolHandler(url, props.webTransportProtocolList);
    this._webTransportFsm = new WebTransportFSM(this, getId);
    this._webTransportFsm.start();
  }

  if ( TransportBase ) WebTransport.__proto__ = TransportBase;
  WebTransport.prototype = Object.create( TransportBase && TransportBase.prototype );
  WebTransport.prototype.constructor = WebTransport;

  WebTransport.prototype.notifyEvent = function notifyEvent (event) {
    this._eventCB(event);
  };

  WebTransport.prototype.handleDestroyed = function handleDestroyed () {
    this._transportSession = null;
  };

  WebTransport.prototype.handleTransportEvent = function handleTransportEvent (transportEvent) {
    /* #stripped LOG_DEBUG(`Web transport receive transport event: ${transportEvent}`) */

    var wEvent;
    switch (transportEvent.getTransportEventCode()) {
      case TransportSessionEventCode.UP_NOTICE:
        wEvent = new FsmEvent({ name: WebTransportEvent.UP_NOTICE });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.DESTROYED_NOTICE:
        this.handleDestroyed();
        wEvent = new FsmEvent({ name: WebTransportEvent.DESTROYED_NOTICE });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.SEND_ERROR:
        wEvent = new FsmEvent({ name: WebTransportEvent.SEND_ERROR });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.CONNECT_TIMEOUT:
        wEvent = new FsmEvent({ name: WebTransportEvent.CONNECT_TIMEOUT });
        wEvent._transportEvent = transportEvent;
        this._webTransportFsm.processEvent(wEvent);
        break;

      case TransportSessionEventCode.DOWNGRADE_FAILED:
        this._lastDowngradeSucceeded = false;
        break;

      case TransportSessionEventCode.DOWNGRADE_SUCCEEDED:
        this._lastDowngradeSucceeded = true;
        break;

      default:
        // All other transport events have no effect on the web transport and are passed through
        this._eventCB(transportEvent);
    }
  };

  /**
   * @override
   */
  WebTransport.prototype.connect = function connect () {
    var wEvent = new FsmEvent({ name: WebTransportEvent.CONNECT });
    this._webTransportFsm.processEvent(wEvent);
    return TransportReturnCode.OK;
  };

  WebTransport.prototype.connectInternal = function connectInternal () {
    var this$1 = this;

    this._transportSession = null;
    var tpProtocol = this._transportHandler.getTransportProtocol();
    this._props.transportProtocol = tpProtocol;
    switch (tpProtocol) {
      case TransportProtocol.HTTP_BASE64:
      case TransportProtocol.HTTP_BINARY:
      case TransportProtocol.HTTP_BINARY_STREAMING:
        this._transportSession = new HTTPTransportSession(
          this._url,
          function (evt) { return this$1.handleTransportEvent(evt); },
          this._client,
          this._props
        );
        break;

      case TransportProtocol.WS_BINARY:
        this._transportSession = new WebSocketTransportSession(
          this._url,
          function (evt) { return this$1.handleTransportEvent(evt); },
          this._client,
          this._props
        );
        break;

      default:
        LOG_ERROR(("Web transport unrecognized TransportProtocol: " + tpProtocol));
        throw new OperationError(("No transport session provider for scheme: " + tpProtocol),
                                 ErrorSubcode.CONNECTION_ERROR,
                                 tpProtocol);
    }

    /* #stripped LOG_DEBUG(`Connect Transport ${tpProtocol}`) */

    return this._transportSession.connect();
  };

  /**
   * @override
   */
  WebTransport.prototype.destroy = function destroy (msg, subcode) {
    var wEvent = new FsmEvent({ name: WebTransportEvent.DESTROY });
    wEvent._destroyMsg = msg;
    wEvent._subcode = subcode;
    this._webTransportFsm.processEvent(wEvent);
    return TransportReturnCode.OK;
  };

  /**
   * @param {String} msg The message associated with the downgrade
   * @param {ErrorSubcode} subcode The subcode associated with the downgrade
   * @returns {Boolean} `true` if there are downgrade options available. `false` otherwise.
   * @private
   */
  WebTransport.prototype.beginDowngrade = function beginDowngrade (msg, subcode) {
    if (this._transportHandler.canCompleteDowngrade()) {
      /* #stripped LOG_TRACE('Web transport downgrade') */

      // Destroy the underlying transport session
      // This will asynchronously cause DESTROYED_NOTICE to be emitted.
      // The receiver can then call completeDowngrade, which will complete the downgrade.
      this.destroyInternal(msg, subcode);
      return true;
    }
    /* #stripped LOG_TRACE('Web transport downgrade rejected') */

    return false;
  };

  WebTransport.prototype.completeDowngrade = function completeDowngrade () {
    if (!this._transportHandler.canCompleteDowngrade()) {
      return false;
    }
    return this._transportHandler.completeDowngrade();
  };

  WebTransport.prototype.destroyInternal = function destroyInternal (msg, subcode) {
    if (this._transportSession) {
      this._transportSession.destroy(msg, subcode);
    }
  };

  /**
   * @override
   */
  WebTransport.prototype.flush = function flush (callback) {
    return this._transportSession.flush(callback);
  };

  WebTransport.prototype.getConnError = function getConnError () {
    if (this._transportSession) {
      return this._transportSession._connError;
    }
    return null;
  };

  /**
   * @override
   */
  WebTransport.prototype.getInfoStr = function getInfoStr () {
    if (this._transportSession) {
      return this._transportSession.getInfoStr();
    }
    return 'Not connected.';
  };

  /**
   * @override
   */
  WebTransport.prototype.getTransportProtocol = function getTransportProtocol () {
    return this._transportHandler.getTransportProtocol();
  };

  /**
   * @override
   */
  WebTransport.prototype.getClientStats = function getClientStats () {
    if (this._transportSession) {
      return this._transportSession.getClientStats();
    }
    return null;
  };

  /**
   * @override
   */
  WebTransport.prototype.requestDowngrade = function requestDowngrade (msg, subcode) {
    /* #stripped LOG_TRACE('Creating downgrade request event') */

    this._lastDowngradeSucceeded = undefined; // will be reset by handler for TS DOWNGRADE_ events
    var wEvent = new FsmEvent({ name: WebTransportEvent.DOWNGRADE });
    wEvent._downgradeMsg = msg;
    wEvent._subcode = subcode;
    this._webTransportFsm.processEvent(wEvent);
    return this._lastDowngradeSucceeded;
  };

  /**
   * @override
   */
  WebTransport.prototype.send = function send (message, forceAllowEnqueue) {
    return this._transportSession.send(message, forceAllowEnqueue);
  };

  return WebTransport;
}(TransportBase));

module.exports.WebTransport = WebTransport;


/***/ }),
/* 253 */
/***/ (function(module, exports) {

module.exports.WebSocketCloseCodes = {
  0: {
    name:        'Unknown code',
    description: 'No status code was returned by the operation',
  },
  1000: {
    name:        'Normal Closure',
    description: 'The connection closed normally',
  },
  1001: {
    name:        'Going Away',
    description: 'The endpoint is going away due to a server failure or client navigation',
  },
  1002: {
    name:        'Protocol Error',
    description: 'A WebSocket protocol error occurred',
  },
  1003: {
    name:        'Unsupported Data',
    description: 'The endpoint cannot handle the specified data type',
  },
  1004: {
    name:        'Reserved',
    description: '',
  },
  1005: {
    name:        'No Status Recvd',
    description: 'Expected a status code but none was provided',
  },
  1006: {
    name:        'Abnormal Closure',
    description: 'No close frame was received before remote hangup',
  },
  1007: {
    name:        'Invalid Frame Payload Data',
    description: 'A message contained data inconsistent with its encoding',
  },
  1008: {
    name:        'Policy Violation',
    description: 'A message violated endpoint policy',
  },
  1009: {
    name:        'Message Too Big',
    description: 'A data frame was too large',
  },
  1010: {
    name:        'Missing Extension',
    description: 'The endpoint did not negotiate an expected extension',
  },
  1011: {
    name:        'Internal Error',
    description: 'The server encountered an unexpected condition that prevented it from fulfilling the request',
  },
  1012: {
    name:        'Service Restart',
    description: 'The server is restarting',
  },
  1013: {
    name:        'Try Again Later',
    description: 'The server is terminating the connection due to a temporary condition',
  },
  1014: {
    name:        'Bad Gateway',
    description: 'A gateway or proxy received an invalid response from the upstream server',
  },
  1015: {
    name:        'TLS Handshake',
    description: 'The connection was closed due to a failure to perform a TLS handshake',
  },
};


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(7);
var Check = ref.Check;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;

var APIPropertiesValidators = {
  validateInstance: function validateInstance(typeDesc, instance, name) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

    args.forEach(function (check) {
      var validator = check.shift();
      var validatorArgs = [typeDesc, instance, name ].concat( check);
      validator.apply(void 0, validatorArgs);
    });
  },

  valInstance: function valInstance(typeDesc, instance, name, typeInstance, typeInstanceDesc) {
    if (!Check.instanceOf(instance[name], typeInstance)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be instance of " + typeInstanceDesc));
    }
  },

  valNotEmpty: function valNotEmpty(typeDesc, instance, name) {
    if (Check.none(instance[name]) || instance[name] === '') {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot be empty."),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valLength: function valLength(typeDesc, instance, name, max) {
    if (Check.string(instance[name]) && instance[name].length > max) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' exceeded max length " + max),
                             ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valRange: function valRange(typeDesc, instance, name, min, max) {
    if (Check.number(instance[name]) && (instance[name] < min || instance[name] > max)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' out of range [" + min + "; " + max + "]."),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valString: function valString(typeDesc, instance, name) {
    if (!Check.string(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type string; was " + (typeof instance[name])),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valNumber: function valNumber(typeDesc, instance, name) {
    if (!Check.number(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type number; was " + (typeof instance[name])),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valBoolean: function valBoolean(typeDesc, instance, name) {
    var val = instance[name];
    if (!Check.boolean(val)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type boolean; was " + (typeof val)),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valIsMember: function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
    if ( allowNull === void 0 ) allowNull = false;

    var val = instance[key];
    if (allowNull && (val === null || val === undefined)) { return; }
    if (enumInstance.values.indexOf(val) >= 0) { return; }
    throw new OperationError((typeDesc + " validation: Property '" + key + "'=" + val + " must be a member of " + enumName),
                             ErrorSubcode.PARAMETER_INVALID_TYPE);
  },

  valStringOrArray: function valStringOrArray(typeDesc, instance, name) {
    var val = instance[name];
    if (typeof val !== 'string' && !Array.isArray(val)) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be a string or array"),
                                ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
  },

  valArrayIsMember: function valArrayIsMember(typeDesc, instance, name, enumInstance, enumName,
                   allowUndefined, allowEmpty, allowDuplicate) {
    var val = instance[name];
    if ((val === undefined || val === null)) {
      if (allowUndefined) {
        return;
      }
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }

    if (!Array.isArray(instance[name])) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }
    if (!allowEmpty && instance[name].length === 0) {
      throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot be empty"),
                              ErrorSubcode.PARAMETER_INVALID_TYPE);
    }

    instance[name].forEach(function (ele, index) {
      if (!enumInstance.values.includes(ele)) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' must be an array of " + enumName),
                                ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      if (!allowDuplicate) {
        if (instance[name].indexOf(ele, index + 1) >= 0) {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' cannot have duplicate element value"),
                          ErrorSubcode.PARAMETER_OUT_OF_RANGE);
        }
      }
    });
  },

  valArrayOfString: function valArrayOfString(typeDesc, instance, name) {
    var val = instance[name];
    if (Check.something(val)) {
      if (!Array.isArray(val)) {
        throw new OperationError((typeDesc + " validation: Property '" + name + "' must be type Array"),
                               ErrorSubcode.PARAMETER_INVALID_TYPE);
      }
      val.forEach(function (ele) {
        if (typeof ele !== 'string') {
          throw new OperationError((typeDesc + " validation: Property '" + name + "' must be an array of string"),
                                 ErrorSubcode.PARAMETER_INVALID_TYPE);
        }
      });
    }
  },

  valTopicString: function valTopicString(typedesc, instance, name) {
    // Pardon this late import. I need to break a circular dependency.
    // eslint-disable-next-line global-require
    var ref = __webpack_require__(5);
    var DestinationUtil = ref.DestinationUtil;
    var DestinationType = ref.DestinationType;
    module.exports.APIPropertiesValidators.valString(typedesc, instance, name);
    var val = instance[name];
    var result = DestinationUtil.validateAndEncode(DestinationType.TOPIC, val);
    if (result.error) {
      throw new OperationError(typedesc + " validation: Property '" + name + "' must be " +
                               "a valid topic string: " + (result.error),
                              ErrorSubcode.PARAMETER_OUT_OF_RANGE);
    }
  },

  valTopicStringOrEmpty: function valTopicStringOrEmpty(typedesc, instance, name) {
    var val = instance[name];
    if (val && val.length) {
      module.exports.APIPropertiesValidators.valTopicString(typedesc, instance, name);
    }
  },
};

module.exports.APIPropertiesValidators = APIPropertiesValidators;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

var cloneObj = __webpack_require__(149);
var util = __webpack_require__(6);

var CLONE_CIRCULAR = false; // If true, handles circular references safely.
var CLONE_DEPTH = 1; // Don't deep-clone nested values.

/**
 * @memberof solace
 * @private
 */
var APIProperties = function APIProperties() {
  var options = [], len = arguments.length;
  while ( len-- ) options[ len ] = arguments[ len ];

  Object.assign.apply(Object, [ this ].concat( options ));
};

/**
 * Can be overridden.For instance sessionProperties
 * overrides this to suppress printing the password.
 * @returns {String} The string representation of this object
 * @private
 */
APIProperties.prototype.toString = function toString () {
  return util.inspect(this);
};

APIProperties.prototype.clone = function clone () {
  return cloneObj(this, CLONE_CIRCULAR, CLONE_DEPTH);
};

module.exports.APIProperties = APIProperties;


/***/ }),
/* 256 */
/***/ (function(module, exports) {

function flatten(array) {
  return array.reduce(function (acc, el) { return acc.concat(Array.isArray(el) ? flatten(el) : el); }, []);
}

function includes(array, el) {
  return array.some(function (v) { return v === el; });
}

module.exports.ArrayUtils = {
  flatten: flatten,
  includes: includes,
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {


var WINDOWS_VERSION_MAP = {
  '6.4':  '10.0',
  '6.3':  '8.1',
  '6.2':  '8',
  '6.1':  '7',
  '6.0':  'Vista',
  '5.2':  'Server 2003',
  '5.1':  'XP',
  '5.01': '2000 SP1',
  '5.0':  '2000',
  '4.0':  '4.0',
};

var NODE_OS_TYPES = {
  Darwin:     'OSX',
  Windows_NT: 'Windows',
};

var context = typeof window !== 'undefined' ? window : global;

var DEFAULT = {
};

var NODE_PROCESS = {
  product:  'solclientjs',
  platform: 'node',
  agent:    'node',
  process:  context.process,
};

// Worst case fallbacks
var BROWSER_PROCESS = {
  product:  'solclientjs',
  platform: 'unknown',
  agent:    'Gecko',
};

function getBrowserAgentInfo() {
  /* eslint-env browser */
  var navObj = typeof navigator !== 'undefined' ? navigator : null;
  if (!navObj) { return null; }
  var agentStr = navigator.userAgent;

  // Execute these regex checks against the user agent string in this order.
  // The earlier browsers have a lot of impersonation substrings in their user
  // agent list so we positively test for them before considering the browsers
  // that are frequently impersonated.
  var browsers = [
    ['edge', /Edge\/([0-9._]+)/],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9.]+)(?:\s|$)/],
    ['opera', /Opera\/([0-9.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9.]+)(:?\s|$)$/],
    ['ie', /Trident\/7\.0.*rv:([0-9.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9.]+);.*Trident\/[4-8].0/], // Edit: IE11 in IE9 emu mode uses Trident 8
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9.]+)/],
    ['android', /Android\s([0-9.]+)/],
    ['ios', /Version\/([0-9._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9._]+).*Safari/] ];

  var agentInfo = {
    browser:  { name: 'unknown', version: '0.0.0' },
    platform: { os: 'unknown', arch: 'unknown', version: 'unknown' },
  };

  var agentHas = function () {
    var strs = [], len = arguments.length;
    while ( len-- ) strs[ len ] = arguments[ len ];

    return strs.some(function (str) { return agentStr.indexOf(str) >= 0; });
  };
  var firstValue = function () {
    var vals = [], len = arguments.length;
    while ( len-- ) vals[ len ] = arguments[ len ];

    return vals.filter(Boolean).shift();
  };

  Object.assign(
    agentInfo, // start with fallbacks above
    // 1. Run the callback below for each browser name/regex-rule pair.
    // 2. Decompose the pair into variables called `key` and `rule`.
    browsers.map(function (ref) {
      var key = ref[0];
      var rule = ref[1];

      // 3. Skip if the rule doesn't match the user agent string.
      if (!rule.test(agentStr)) { return false; }
      // 4. Get the matches for the rule.
      var match = rule.exec(agentStr);
      // 5. Extract the version from match group 1.
      var versionStrs = match && match[1].split(/[._]/).slice(0, 3);
      // 6. Convert the version strings to numbers.
      var version = versionStrs.map(function (str) { return parseInt(str, 10); });
      // 7. Ensure our version tuple is length 3 by appending 0 elements.
      while (version.length < 3) { version.push(0); }
      // 8. Return an agentInfo object in the same form as above, consuming the version array.
      return { browser: { name: key, version: version.join('.') } };
    }).filter(Boolean).shift()); // 9. Filter out anything that returned `false` (#3)...
    // 10. ...and return the first element.

  // Now try to extract platform info
  var os = firstValue(
    agentHas('Windows Phone') && 'WindowsPhone',
    agentHas('Windows') && 'Windows',
    agentHas('Linux') && 'Linux',
    agentHas('like Mac OS X') && 'iOS',
    agentHas('OS X') && 'OSX',
    agentHas('Android', 'Adr') && 'Android',
    agentHas('BB10', 'RIM Tablet OS', 'BlackBerry') && 'BlackBerry'
  );
  var versionTests = {
    'Windows': function () { return firstValue(
      agentHas('Win16') && '3.1.1',
      agentHas('Windows CE') && 'CE',
      agentHas('Windows 95') && '4.00.950',
      agentHas('Windows 98; Win 9x 4.90') && '4.90',
      agentHas('Windows 98') && '4.10',
      (function () {
        // Look in the first set of parentheses for a version string key.
        // This will fail when Windows 16 comes out
        var parenParts = agentStr.match(/\(.+?\)/);
        var versionPart = parenParts[0];
        if (!versionPart) { return false; }
        var versionMatch = function (str) { return versionPart.indexOf(str) >= 0; };
        return firstValue.apply(void 0, Object.keys(WINDOWS_VERSION_MAP).map(function (k) { return versionMatch(k) && WINDOWS_VERSION_MAP[k]; }));
      })()
    ); },
    'OSX':        function () { return agentStr.match(/OS X ((\d+[._])+\d+)\b/)[1]; },
    'Linux':      function () { return ''; },
    'iOS':        function () { return agentStr.match(/OS ((\d+[._])+\d+) like Mac OS X/)[1]; },
    'Android':    function () { return agentStr.match(/(?:Android|Adr) ((\d+[._])+\d_)/)[1]; },
    'BlackBerry': function () { return agentStr.match(/(?:Version\/|RIM Tablet OS )((\d+\.)+\d+)/)[1]; },
  };
  var versionTest = versionTests[os];
  agentInfo.platform.os = os || 'Unknown';
  agentInfo.platform.version = (versionTest && versionTest() || '0.0.0').replace(/_/g, '.');
  return agentInfo;
}
/* eslint-env shared-browser-node */

try {
  if (context.navigator) {
    // These are historical defaults
    var safeEncode = function (str) { return str.replace(/[^a-zA-Z0-9_/.]/g, '-'); };
    Object.assign(BROWSER_PROCESS, {
      platform:    context.navigator.platform,
      agent:       context.navigator.product,
      description: safeEncode(context.navigator.userAgent),
      navigator:   context.navigator,
    });
    var browserAgentInfo = getBrowserAgentInfo();
    if (browserAgentInfo) {
      BROWSER_PROCESS.agent = safeEncode(((browserAgentInfo.browser.name) + "-" + (browserAgentInfo.browser.version)));
      BROWSER_PROCESS.platform = (BROWSER_PROCESS.agent) + "-" + (safeEncode(
        ((browserAgentInfo.platform.os) + "-" + (browserAgentInfo.platform.version))));
    }
  }
  if (context.process) {
    var os = __webpack_require__(289); // eslint-disable-line global-require
    var ostype = os.type();
    var osname = NODE_OS_TYPES[ostype] || ostype || 'unknown';
    var nodeVersionStr = "node-" + (process.version.substr(1));
    Object.assign(NODE_PROCESS, {
      platform:    (nodeVersionStr + "-" + osname + "-" + (os.release()) + "-" + (os.arch())),
      agent:       nodeVersionStr,
      description: nodeVersionStr,
    });
  }
} catch (ex) {
  // Fall back to defaults
}

var Process = Object.assign({}, DEFAULT,
                               false ? BROWSER_PROCESS : {},
                               true ? NODE_PROCESS : {});

module.exports.Process = Process;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(147);
var StringBuffer = ref.StringBuffer;

var PAD_LEFT = 0;
var PAD_RIGHT = 1;

var LUT_PRINTABLE = (function () {
  var tmp = [];
  for (var c = 0; c < 256; ++c) {
    tmp[c] = (c < 33 || c > 126) ? '.' : String.fromCharCode(c);
  }
  return tmp;
})();

function padLeftRight(str, minLen, padSide, padChar) {
  if ( padChar === void 0 ) padChar = ' ';

  if (typeof str !== 'string') {
    return str;
  }
  if (str.length >= minLen) {
    return str;
  }

  var buf = new StringBuffer();
  for (var i = 0; i < (minLen - str.length); i++) {
    buf.append(padChar.charAt(0));
  }
  switch (padSide) {
    case PAD_LEFT:
      return ("" + buf + str);
    case PAD_RIGHT:
      return ("" + str + buf);
    default:
      return str;
  }
}

function leastSpaces(length, line) {
  if (!line.length) { return length; }
  var spaces = line.match(/^\s*/)[0].length;
  return spaces < length ? spaces : length;
}

function capitalizeWord(str) {
  return ("" + (str.charAt(0).toUpperCase()) + (str.substr(1)));
}

/**
 * @private
 * @type {StringUtils}
 */
var StringUtils = {

  capitalize: function capitalize(str) {
    if (!(str && str.length)) {
      return str;
    }

    return str.split(' ').map(capitalizeWord).join(' ');
  },

  isEmpty: function isEmpty(str) {
    return (
      str === undefined ||
      str === null ||
      str.length === 0
    );
  },

  notEmpty: function notEmpty(str) {
    return !(this.isEmpty(str));
  },

  toSafeChars: function toSafeChars(str) {
    return str.replace(/[^a-zA-Z0-9_/.]/g, '');
  },

  padLeft: function padLeft(str, minLen, padChar) {
    return padLeftRight(str, minLen, PAD_LEFT, padChar);
  },

  padRight: function padRight(str, minLen, padChar) {
    return padLeftRight(str, minLen, PAD_RIGHT, padChar);
  },

  nullTerminate: function nullTerminate(str) {
    if (str === null || str === undefined) {
      throw new Error('non str in nullTerminate');
    }
    var lastChar = str.charCodeAt(str.length - 1);
    if (lastChar === 0) {
      return str;
    }
    return str + String.fromCharCode(0x00);
  },

  stripNullTerminate: function stripNullTerminate(str) {
    if (str === null || str === undefined) {
      throw new Error('null str in stripNullTerminate');
    }
    var lastChar = str.charCodeAt(str.length - 1);
    if (lastChar === 0) {
      return str.substr(0, str.length - 1);
    }
    return str;
  },

  hexdump: function hexdump(s) {
    var this$1 = this;

    var output = new StringBuffer();
    var printable = new StringBuffer();
    var spacer = function (pos) { return (pos === 8 || pos === 16 ? '  ' : ' '); };
    var linelen = 0;
    for (var i = 0, sLength = s.length; i < sLength; i++) {
      var ccode = s.charCodeAt(i);
      output.append(this$1.padLeft(ccode.toString(16), 2));
      printable.append(LUT_PRINTABLE[ccode] || '.');
      output.append(spacer(++linelen));

      if (i === s.length - 1) {
        // input finished: complete the line
        while (linelen < 16) {
          output.append(("  " + (spacer(++linelen))));
        }
      }

      if (linelen === 16) {
        output.append(printable.join(''));
        output.append('\n');
        linelen = 0;
        printable.clear();
      }
    }
    return output.toString();
  },

  /**
   * Use heredoc`....` to create multi-line heredoc strings. Leading blank lines are removed, as are
   * leading spaces, up to the number of spaces on the least-indented line.
   * @param {String} literals The document template
   * @param {...String} substitutions The substitutions to make in the document
   * @returns {String} The interpolated representation of the document
   */
  heredoc: function heredoc(literals) {
    var substitutions = [], len = arguments.length - 1;
    while ( len-- > 0 ) substitutions[ len ] = arguments[ len + 1 ];

    var subst = substitutions.concat( ['']);
    var lines = literals.map(function (k) { return k + subst.shift(); })
      .join('')
      .split(/\r?\n/);
    var spaces = lines.length === 1 ? 0 : lines.reduce(leastSpaces, Infinity);
    while (lines[0] === '') {
      lines.shift();
    }
    return lines.map(function (line) { return line.substring(spaces); }).join('\n');
  },
};

module.exports.StringUtils = StringUtils;


/***/ }),
/* 259 */
/***/ (function(module, exports) {

var TimingBucket = function TimingBucket(name, interval) {
  this.name = name;
  this.interval = interval;
  this.buckets = [];
};

var prototypeAccessors = { bucketCount: {} };

prototypeAccessors.bucketCount.get = function () {
    var this$1 = this;

  var c = 0;
  for (var i = 0, n = this.buckets.length; i < n; ++i) {
    c += this$1.buckets[i] || 0;
  }
  return c;
};

TimingBucket.prototype.log = function log (v) {
  if (v === undefined || isNaN(v)) {
    return;
  }
  var normalized = Math.floor(v / this.interval) * this.interval;
  this.buckets[normalized] = this.buckets[normalized] || 0;
  this.buckets[normalized]++;
};

TimingBucket.prototype.toString = function toString () {
    var this$1 = this;

  var cont = [];
  this.buckets.forEach(function (i) {
    cont.push((i + ": " + (this$1.buckets[i])));
  });
  return ("{" + (cont.join(', ')) + "}");
};

Object.defineProperties( TimingBucket.prototype, prototypeAccessors );

module.exports.TimingBucket = TimingBucket;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable global-require */
var parseURL;
if (true) {
  /* eslint-env node */
  parseURL = __webpack_require__(291).parse;
} else {
  /* eslint-env browser */
  var scope = typeof window !== 'undefined' ? window : this;
  require('./browser-url-polyfill')(scope);
  parseURL = function makeURL() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return new (Function.prototype.bind.apply( URL, [ null ].concat( args) ));
  };
}

module.exports.parseURL = parseURL;


/***/ }),
/* 261 */
/***/ (function(module, exports) {

// TODO: consider using high-precision timer from performance
//       or consider using a JS library, such as uuid-js

function generateUUID() { // Public Domain/MIT
  var d = new Date().getTime();
  // if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
  //   d += performance.now(); //use high-precision timer if available
  // }


  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
  });
}

module.exports.UUID = {
  generateUUID: generateUUID,
};


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var VERSION = "10.1.0" || '0.0.0-source';
// Parse the date if provided. Was seeing NaN formatted dates in source mode, so add fallback
var DATE =  true
  ? new Date(Date.parse("Mon Jul 30 2018 14:55:33 GMT-0400 (EDT)"))
  : new Date();
var MODE = "RELEASE";

// These property names are all for export, so make sure they're not mangled
var TARGET = {
  'name':    "node",
  'node':    true,
  'browser': false,
};

var FORMATTED_DATE = (function () {
  var pad = function (n) { return (n < 10 ? ("0" + n) : n); };
  var d = DATE;
  var YYYY = d.getFullYear();
  var MM = pad(d.getMonth() + 1);
  var DD = pad(d.getDate());
  var hh = pad(d.getHours());
  var mm = pad(d.getMinutes());
  return (YYYY + "/" + MM + "/" + DD + " " + hh + ":" + mm);
})();
var SUMMARY = ['SolclientJS', "10.1.0", MODE, FORMATTED_DATE].join(', ');

/**
 * Returns the API version. Use version, date and mode properties for build details.
 * Use the summary property or the .toString() method to return a summary.
 * @static
 * @type {Object}
 * @namespace
 * @memberof solace
 */
var Version = {
  /**
   * The API version, as an informational string. The format of this string is subject to change.
   * @type {String}
   */
  'version':       VERSION,
  /**
   * The API build date.
   * @type {Date}
   */
  'date':          DATE,
  /**
   * The API build date, as a formatted string.
   * The format of this date is:
   * `YYYY-MM-DD hh:mm`
   * where
   *  * `YYYY` is the 4-digit year,
   *  * `MM` is the 2-digit month   (01-12),
   *  * `DD` is the 2-digit day     (01-31),
   *  * `hh` is the 2-digit hour    (00-23),
   *  * `mm` is the 2-digit minute  (00-59)
   *
   * @type {String}
   */
  'formattedDate': FORMATTED_DATE,
  /**
   * Information about the build target. This object is informational; its type, structure and
   * content are subject to change.
   * @type {Object}
   */
  'target':        TARGET,
  /**
   * The build mode. This may be one of 'debug' or 'release'. Other build modes may be added
   * in the future.
   * @type {String}
   */
  'mode':          MODE,
  /**
   * If `true`, this is an unoptimized debug build.
   * @type {Boolean}
   */
  'debug':         false,
  /**
   * If `true`, this is an optimized release build. Note that there may be multiple release
   * builds in a distribution, with varying degrees of optimization.
   * @type {Boolean}
   */
  'release':       true,
  /**
   * An informational string summarizing the API name, version and build date.
   * @type {String}
   */
  'summary':       SUMMARY,

  toString: function toString() {
    return SUMMARY;
  },
};
module.exports.Version = Version;


/***/ }),
/* 263 */
/***/ (function(module, exports) {

var EPSILON = 1e6;

/**
 * @param {Array} arr The array to flatten
 * @returns {Array} A maximally flattened array. The original array is not modified.
 * @private
 */
function flatten(arr) {
  return arr.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []);
}

/**
 * @private
 */
var BaseChecks = (function () {
  var result = {
    /**
     * Checks whether a value is undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined or null.
     *
     * @private
     */
    nothing: function nothing(value) {
      return (value === undefined || value === null);
    },

    /**
     * Checks whether a value is anything, i.e. not undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True unless the value is undefined or null.
     *
     * @private
     */
    anything: function anything(value) {
      return !BaseChecks.nothing(value);
    },

    /**
     * Checks whether a value is undefined. Uses the conservative
     * typeof check for compatibility with particularly ill-behaved
     * libraries that redefine <code>undefined</code>.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined.
     *
     * @private
     */
    undefined: function undefined(value) {
      return typeof value === 'undefined';
    },

    /**
     * Checks whether a value is defined. This is true for any value with
     * a type that is not 'undefined'.
     *
     * @param {any} value The value to check
     * @returns {Boolean} True if the value is defined.
     *
     * @private
     */
    defined: function defined(value) {
      return !BaseChecks.undefined(value);
    },

    /**
     * Checks whether a value is an array.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an array.
     *
     * @private
     */
    array: function array(value) {
      return BaseChecks.anything(value) && Array.isArray(value);
    },

    /**
     * Checks whether a value is an object. If a value is an array, it is not an object.
     * If a value is null, it is not an object.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an object (and not an array).
     *
     * @private
     */
    object: function object(value) {
      return (!BaseChecks.array(value) &&
              value !== null &&
              (typeof value === 'object' || value instanceof Object));
    },

    /**
     * Checks whether a value is an instance of the given type.
     *
     * @param   {*} val The value to check.
     * @param   {Object} type The type to check.
     *
     * @returns {Boolean} True if type is in value's prototype chain.
     *
     * @private
     */
    instanceOf: function instanceOf(val, type) {
      return BaseChecks.object(val) && val instanceof type;
    },

    /**
     * Checks whether a value's typeof is equal to the given type string.
     *
     * @param {*} val The value to check.
     * @param {String} type The type string for comparison.
     *
     * @returns {Boolean} True if typeof(val) == type
     *
     * @private
     */
    type: function type(val, type$1) {
      return typeof val === type$1; /* dynamic */ // eslint-disable-line valid-typeof
    },

    /**
     * Checks whether a value is an instance of any of the given types.
     *
     * @param   {*} val The value to check.
     * @param   {Object} types The types to check.
     *
     * @returns {Boolean} True if any element of types is in val's prototype chain.
     *
     * @private
     */
    instanceOfAny: function instanceOfAny(val) {
      var types = [], len = arguments.length - 1;
      while ( len-- > 0 ) types[ len ] = arguments[ len + 1 ];

      return (BaseChecks.array(types) &&
              flatten(types).some(function (type) { return BaseChecks.instanceOf(val, type); }));
    },

    /**
     * Checks whether the given value is empty.
     *
     * Emptiness is determined using the following checks:
     *
     * <ol>
     *  <li>If an object is nothing, it is empty.</li>
     *  <li>If it is an object, and it has no keys of its own, it is empty.</li>
     *  <li>If it has a length property, it is empty if length === 0.</li>
     *  <li>If none of the above apply, the object is not empty.</li>
     * </ol>
     *
     * @param   {*} val The value to check.
     *
     * @returns {Boolean} True if the value is empty.
     *
     * @private
     */
    empty: function empty(val) {
      if (BaseChecks.nothing(val)) { return true; }
      if (BaseChecks.object(val)) {
        if (Object.keys(val).length === 0) {
          return true;
        }
      }
      if (val.length === 0) {
        return true;
      }
      return false;
    },

    /**
     * A user-defined check.
     *
     * @param   {*} val The value to check
     * @param   {Function} fn The function(val) to use.
     *
     * @returns {Boolean} The result of the function, coerced to a boolean.
     *
     * @private
     */
    truthy: function truthy(val, fn) {
      return !!fn(val);
    },

    rangeGe: function rangeGe(val, rangeMinInclusive) {
      return val >= rangeMinInclusive;
    },

    rangeGt: function rangeGt(val, rangeMin) {
      return val > rangeMin;
    },

    rangeLe: function rangeLe(val, rangeMaxInclusive) {
      return val <= rangeMaxInclusive;
    },

    rangeLt: function rangeLt(val, rangeMax) {
      return val < rangeMax;
    },

    rangeCompare: function rangeCompare(val, operator, operand) {
      var args = [], len = arguments.length - 3;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

      switch (operator) {
        case '=':
        case '==':
        case '===':
          return val === operand;
        case '~=':
        case '=~':
          {
            var epsilon = args[0] || EPSILON;
            return Math.abs(val - operand) < epsilon;
          }
        case '<':
          return val < operand;
        case '<=':
          return val <= operand;
        case '>':
          return val > operand;
        case '>=':
          return val >= operand;
        default:
          throw new Error(("Illegal operator for rangeCompare: " + operator));
      }
    },

    NaN: function NaN(val) {
      return Number.isNaN(val);
    },

    /**
     * Checks whether val is included in the object. If obj is an array, val is included if
     * val is an element of the array. Otherwise, if obj is an object, val is included if
     * val is one of the keys of obj.
     *
     * @param   {*} val The value to test
     * @param   {*} obj The object to test
     *
     * @returns {Boolean} True if the value is included in the object
     */
    included: function included(val, obj) {
      if (BaseChecks.nothing(obj)) {
        return false;
      }
      if (obj.includes) {
        return obj.includes(val);
      }
      if (Array.isArray(obj)) {
        // Not exactly Array.prototype.includes, which uses SameValueZero (+0 == -0)
        return obj.indexOf(val) >= 0;
      }
      if (BaseChecks.object(obj)) {
        var keys = Object.keys(obj);
        return BaseChecks.included(val, keys);
      }
      return false;
    },

    /**
     * Checks whether val is equal to expected.
     *
     * @param {any} val The value to check.
     * @param {any} expected The expected value.
     * @returns {Boolean} True if the value was equal to the expected value.
     */
    equal: function equal(val, expected) {
      return val === expected;
    },

    /**
     * Checks whether the given value appears as an attribute value in the given attributes object,
     * e.g. whether an enumeration contains the given value. If the attributes object is an array,
     * the array membership check {@link #included} is used instead.
     *
     * @param   {*} val The value to check.
     * @param   {Object} obj The object with attributes to check.
     *
     * @returns {Boolean} True if attrs has any attribute equal to val.
     */
    member: function member(val, obj) {
      return (BaseChecks.anything(obj) &&
              (BaseChecks.array(obj)
                ? BaseChecks.included(val, obj)
                : Object.keys(obj).some(function (k) { return obj[k] === val; }))
      );
    },

    boolean: function boolean(v) {
      return BaseChecks.type(v, 'boolean');
    },

    number: function number(v) {
      return BaseChecks.type(v, 'number');
    },

    string: function string(v) {
      return BaseChecks.type(v, 'string');
    },

    function: function function$1(v) {
      return BaseChecks.type(v, 'function');
    },
  };

  /**
   * Checks whether an object is none. This is the same check as <code>nothing</code>
   * @see {@link nothing}
   */
  result.none = result.nothing;

  /**
   * Checks whether an object is something. This is the same check as <code>anything</code>
   */
  result.something = result.anything;

  // Add check-loosening suffixes, (t | null), (t | undefined) and (t | null | undefined).
  // Do the t check last, just in case it is not (null | undefined) safe.
  Object.keys(result).forEach(function (key) {
    /**
     * .orNull checks. These are equivalent to the similarly named check, but also pass if the value
     * supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orNull = function orNull(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return val === null || result[key].apply(result, [ val ].concat( args ));
    };

    /**
     * .orUndefined checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orUndefined = function orUndefined(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return val === undefined || result[key].apply(result, [ val ].concat( args ));
    };

    /**
     * .orNothing checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was null or undefined.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
    result[key].orNothing = function orNothing(val) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      return result.nothing(val) || result[key].apply(result, [ val ].concat( args ));
    };
  });

  return result;
})();

module.exports.BaseChecks = BaseChecks;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var ref = __webpack_require__(148);
var Check = ref.Check;
var ref$1 = __webpack_require__(2);
var ErrorSubcode = ref$1.ErrorSubcode;
var OperationError = ref$1.OperationError;

var NO_OBJ = {}; // anonymous object

function objectValues(object) {
  return Object.keys(object).map(function (k) { return object[k]; });
}

function subcodeSummary(subcode, expected, got) {
  if ( expected === void 0 ) expected = null;
  if ( got === void 0 ) got = NO_OBJ;

  var expectedStr = expected ? ("; expected: " + expected) : '';
  var gotStr = got !== NO_OBJ ? ("; got: " + got) : '';
  switch (subcode) {
    case ErrorSubcode.PARAMETER_INVALID_TYPE:
      return ("Parameter type was invalid" + expectedStr + gotStr);
    default:
      return ErrorSubcode.nameOf(subcode).toLowerCase().replace(/_/, ' ') + expectedStr;
  }
}

function validateError(name, subcode, message) {
  throw new OperationError(("Parameter " + name + " failed validation"), subcode, message);
}

function validate(name, subcode, message, check, value) {
  var validatorArgs = [], len = arguments.length - 5;
  while ( len-- > 0 ) validatorArgs[ len ] = arguments[ len + 5 ];

  if (!check.apply(void 0, [ value ].concat( validatorArgs ))) {
    return validateError(name, subcode, message);
  }
  return value;
}

var typename = function (x) { return x && x.constructor && x.constructor.name || typeof x; };

/**
 * The Check object is a powerful validation API but it is partially built at runtime by composing
 * functions, and it requires significant boilerplate for parameter validation.
 *
 * The Parameter API expresses concrete validations using the Check API, returning values on success
 * and throwing the appropriate SDK exception on failure. It would be tempting to try to
 * automatically build a Parameter method for every Check method, but this would make Parameter
 * difficult to understand and use.
 *
 * @private
 */
var Parameter = {

  isArray: function isArray(name, value,
          subcode,
          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'array', value);

    return validate(name, subcode, message, Check.isArray, value);
  },

  isBoolean: function isBoolean(name, value,
            subcode,
            message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'boolean', value);

    return validate(name, subcode, message, Check.boolean, value);
  },

  isBooleanOrNothing: function isBooleanOrNothing(name, value,
                     subcode,
                     message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'boolean or nothing', value);

    return validate(name, subcode, message, Check.boolean.orNothing, value);
  },

  isEnumMember: function isEnumMember(name, value, memberOfEnum,
               subcode,
               message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
                subcode,
                ("one of [" + (memberOfEnum.names.join(', ')) + "]"),
                value);

    return validate(name, subcode, message, Check.member, value, memberOfEnum);
  },

  isEnumMemberOrNothing: function isEnumMemberOrNothing(name, value, memberOfEnum,
                        subcode,
                        message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
                subcode,
                ("one of [" + (memberOfEnum.names.join(', ')) + "]"),
                value);

    return validate(name, subcode, message, Check.member.orNothing, value, memberOfEnum);
  },

  isFunction: function isFunction(name, value,
             subcode,
             message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'function', value);

    return validate(name, subcode, message, Check.function, value);
  },

  isFunctionOrNothing: function isFunctionOrNothing(name, value,
                      subcode,
                      message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'function or nothing', value);

    return validate(name, subcode, message, Check.function.orNothing, value);
  },

  isInstanceOf: function isInstanceOf(name, value, instanceOf,
               subcode,
               message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, instanceOf.name, typename(value));

    return validate(name, subcode, message, Check.instanceOf, value, instanceOf);
  },

  isInstanceOfOrNothing: function isInstanceOfOrNothing(name, value, instanceOf,
                        subcode,
                        message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                                 ((instanceOf.name) + " or nothing"),
                                                 typename(value));

    return validate(name, subcode, message, Check.instanceOf.orNothing, value, instanceOf);
  },

  isInstanceOfOrNull: function isInstanceOfOrNull(name, value, instanceOf,
                     subcode,
                     message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                              ((instanceOf.name) + " or null"),
                                              typename(value));

    return validate(name, subcode, message, Check.instanceOf.orNull, value, instanceOf);
  },

  isInstanceOfOrUndefined: function isInstanceOfOrUndefined(name, value, instanceOf,
                          subcode,
                          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode,
                                                   ((instanceOf.name) + " or undefined"),
                                                   typename(value));

    return validate(name, subcode, message, Check.instanceOf.orUndefined, value, instanceOf);
  },

  isMember: function isMember(name, value, memberOf,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(
            subcode,
            ("one of " + (memberOf.name) + ".[" + (objectValues(memberOf).join(', ')) + "]"),
            value);

    return validate(name, subcode, message, Check.member, value, memberOf);
  },

  isNumber: function isNumber(name, value,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number', value);

    return validate(name, subcode, message, Check.number, value);
  },

  isNumberOrNothing: function isNumberOrNothing(name, value,
                    subcode,
                    message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number or nothing', value);

    return validate(name, subcode, message, Check.number.orNothing, value);
  },

  isNumberOrNull: function isNumberOrNull(name, value,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'number or null', value);

    return validate(name, subcode, message, Check.number.orNull, value);
  },

  isRangeCompare: function isRangeCompare(name, value, operator, operand,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, (operator + " " + operand), value);

    return validate(name, subcode, message, Check.rangeCompare, value, operator, operand);
  },

  isRangeCompareOrNothing: function isRangeCompareOrNothing(name, value, operator, operand,
                          subcode,
                          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, (operator + " " + operand + " or nothing"), value);

    return validate(name, subcode, message,
                    Check.rangeCompare.orNothing, value, operator, operand);
  },

  isStringOrNull: function isStringOrNull(name, value,
                 subcode,
                 message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string or null', value);

    return validate(name, subcode, message, Check.string.orNull, value);
  },


  isString: function isString(name, value,
           subcode,
           message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string', value);

    return validate(name, subcode, message, Check.string, value);
  },

  isStringOrNothing: function isStringOrNothing(name, value,
                    subcode,
                    message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_INVALID_TYPE;
    if ( message === void 0 ) message = subcodeSummary(subcode, 'string or nothing', value);

    return validate(name, subcode, message, Check.string.orNothing, value);
  },

  isValue: function isValue(name, value, expected,
          subcode,
          message) {
    if ( subcode === void 0 ) subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE;
    if ( message === void 0 ) message = subcodeSummary(subcode, ("must be " + value));

    return validate(name, subcode, message, Check.equal, value, expected);
  },

};

module.exports.Parameter = Parameter;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {


function propertySpec(value, spec) {
  return Object.assign(
    { value: value }, 
    spec.indexOf('c') >= 0 ? { configurable: true } : {},
    spec.indexOf('e') >= 0 ? { enumerable: true }   : {},
    spec.indexOf('w') >= 0 ? { writable: true }     : {}
  );
}

var solace = __webpack_require__(151);
try {
  /*****************************************
 * solace namespace
 *****************************************/


// --------------------------
// solace.AbstractQueueDescriptor
// --------------------------
solace['AbstractQueueDescriptor'] = solace.AbstractQueueDescriptor;
Object.defineProperty(solace.AbstractQueueDescriptor.prototype, 'getType', propertySpec(solace.AbstractQueueDescriptor.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.AbstractQueueDescriptor.prototype, 'isDurable', propertySpec(solace.AbstractQueueDescriptor.prototype.isDurable, 'cw')); // GDP
// --------------------------
// solace.AuthenticationScheme
// --------------------------
solace['AuthenticationScheme'] = solace.AuthenticationScheme;
solace.AuthenticationScheme._setCanonical({"BASIC":"AuthenticationScheme_basic","CLIENT_CERTIFICATE":"AuthenticationScheme_clientCertificate","AUTHENTICATION_SCHEME_BASIC":"AuthenticationScheme_basic","AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE":"AuthenticationScheme_clientCertificate"}, true);
Object.defineProperty(solace.AuthenticationScheme, 'describe', propertySpec(solace.AuthenticationScheme.describe, 'cw')); // GDP
Object.defineProperty(solace.AuthenticationScheme, 'nameOf', propertySpec(solace.AuthenticationScheme.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheCBInfo
// --------------------------
solace['CacheCBInfo'] = solace.CacheCBInfo;
Object.defineProperty(solace.CacheCBInfo.prototype, 'getCallback', propertySpec(solace.CacheCBInfo.prototype.getCallback, 'cw')); // GDP
Object.defineProperty(solace.CacheCBInfo.prototype, 'getUserObject', propertySpec(solace.CacheCBInfo.prototype.getUserObject, 'cw')); // GDP
// --------------------------
// solace.CacheLiveDataAction
// --------------------------
solace['CacheLiveDataAction'] = solace.CacheLiveDataAction;
solace.CacheLiveDataAction._setCanonical({"FULFILL":1,"QUEUE":2,"FLOW_THRU":3}, true);
Object.defineProperty(solace.CacheLiveDataAction, 'describe', propertySpec(solace.CacheLiveDataAction.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheLiveDataAction, 'nameOf', propertySpec(solace.CacheLiveDataAction.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheRequestResult
// --------------------------
solace['CacheRequestResult'] = solace.CacheRequestResult;
Object.defineProperty(solace.CacheRequestResult.prototype, 'getReturnCode', propertySpec(solace.CacheRequestResult.prototype.getReturnCode, 'cw')); // GDP
Object.defineProperty(solace.CacheRequestResult.prototype, 'getReturnSubcode', propertySpec(solace.CacheRequestResult.prototype.getReturnSubcode, 'cw')); // GDP
Object.defineProperty(solace.CacheRequestResult.prototype, 'getTopic', propertySpec(solace.CacheRequestResult.prototype.getTopic, 'cw')); // GDP
// --------------------------
// solace.CacheReturnCode
// --------------------------
solace['CacheReturnCode'] = solace.CacheReturnCode;
solace.CacheReturnCode._setCanonical({"OK":1,"FAIL":2,"INCOMPLETE":3}, true);
Object.defineProperty(solace.CacheReturnCode, 'describe', propertySpec(solace.CacheReturnCode.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheReturnCode, 'nameOf', propertySpec(solace.CacheReturnCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheReturnSubcode
// --------------------------
solace['CacheReturnSubcode'] = solace.CacheReturnSubcode;
solace.CacheReturnSubcode._setCanonical({"REQUEST_COMPLETE":0,"LIVE_DATA_FULFILL":1,"ERROR_RESPONSE":2,"INVALID_SESSION":3,"REQUEST_TIMEOUT":4,"REQUEST_ALREADY_IN_PROGRESS":5,"NO_DATA":6,"SUSPECT_DATA":7,"CACHE_SESSION_DISPOSED":8,"SUBSCRIPTION_ERROR":9}, true);
Object.defineProperty(solace.CacheReturnSubcode, 'describe', propertySpec(solace.CacheReturnSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.CacheReturnSubcode, 'nameOf', propertySpec(solace.CacheReturnSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.CacheSession
// --------------------------
solace['CacheSession'] = solace.CacheSession;
Object.defineProperty(solace.CacheSession.prototype, 'getProperties', propertySpec(solace.CacheSession.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.CacheSession.prototype, 'sendCacheRequest', propertySpec(solace.CacheSession.prototype.sendCacheRequest, 'cw')); // GDP
// --------------------------
// solace.CacheSessionProperties
// --------------------------
solace['CacheSessionProperties'] = solace.CacheSessionProperties;
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getCacheName', propertySpec(solace.CacheSessionProperties.prototype.getCacheName, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setCacheName', propertySpec(solace.CacheSessionProperties.prototype.setCacheName, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getMaxMessageAgeSec', propertySpec(solace.CacheSessionProperties.prototype.getMaxMessageAgeSec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setMaxMessageAgeSec', propertySpec(solace.CacheSessionProperties.prototype.setMaxMessageAgeSec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getMaxMessages', propertySpec(solace.CacheSessionProperties.prototype.getMaxMessages, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setMaxMessages', propertySpec(solace.CacheSessionProperties.prototype.setMaxMessages, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'getTimeoutMsec', propertySpec(solace.CacheSessionProperties.prototype.getTimeoutMsec, 'cw')); // GDP
Object.defineProperty(solace.CacheSessionProperties.prototype, 'setTimeoutMsec', propertySpec(solace.CacheSessionProperties.prototype.setTimeoutMsec, 'cw')); // GDP
// --------------------------
// solace.CapabilityType
// --------------------------
solace['CapabilityType'] = solace.CapabilityType;
solace.CapabilityType._setCanonical({"PEER_SOFTWARE_VERSION":0,"PEER_SOFTWARE_DATE":1,"PEER_PLATFORM":2,"PEER_PORT_SPEED":3,"PEER_PORT_TYPE":4,"MAX_DIRECT_MSG_SIZE":5,"PEER_ROUTER_NAME":6,"MESSAGE_ELIDING":7,"NO_LOCAL":8,"GUARANTEED_MESSAGE_CONSUME":9,"TEMPORARY_ENDPOINT":10,"GUARANTEED_MESSAGE_PUBLISH":11,"GUARANTEED_MESSAGE_BROWSE":12,"ENDPOINT_MGMT":13,"SELECTOR":14,"MAX_GUARANTEED_MSG_SIZE":15,"ACTIVE_CONSUMER_INDICATION":16,"COMPRESSION":17,"CUT_THROUGH":18,"ENDPOINT_DISCARD_BEHAVIOR":19,"ENDPOINT_MESSAGE_TTL":20,"JNDI":21,"PER_TOPIC_SEQUENCE_NUMBERING":22,"QUEUE_SUBSCRIPTIONS":23,"SUBSCRIPTION_MANAGER":24,"TRANSACTED_SESSION":25}, true);
Object.defineProperty(solace.CapabilityType, 'describe', propertySpec(solace.CapabilityType.describe, 'cw')); // GDP
Object.defineProperty(solace.CapabilityType, 'nameOf', propertySpec(solace.CapabilityType.nameOf, 'cw')); // GDP
// --------------------------
// solace.ConsoleLogImpl
// --------------------------
solace['ConsoleLogImpl'] = solace.ConsoleLogImpl;
// --------------------------
// solace.Destination
// --------------------------
solace['Destination'] = solace.Destination;
Object.defineProperty(solace.Destination.prototype, 'getType', propertySpec(solace.Destination.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'getBytes', propertySpec(solace.Destination.prototype.getBytes, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'getOffset', propertySpec(solace.Destination.prototype.getOffset, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'validate', propertySpec(solace.Destination.prototype.validate, 'cw')); // GDP
Object.defineProperty(solace.Destination.prototype, 'isWildcarded', propertySpec(solace.Destination.prototype.isWildcarded, 'cw')); // GDP
// --------------------------
// solace.DestinationType
// --------------------------
solace['DestinationType'] = solace.DestinationType;
solace.DestinationType._setCanonical({"TOPIC":"topic","QUEUE":"queue","TEMPORARY_QUEUE":"temporary_queue"}, true);
Object.defineProperty(solace.DestinationType, 'describe', propertySpec(solace.DestinationType.describe, 'cw')); // GDP
Object.defineProperty(solace.DestinationType, 'nameOf', propertySpec(solace.DestinationType.nameOf, 'cw')); // GDP
// --------------------------
// solace.ErrorSubcode
// --------------------------
solace['ErrorSubcode'] = solace.ErrorSubcode;
solace.ErrorSubcode._setCanonical({"UNKNOWN_ERROR":4294967295,"NO_ERROR":0,"SESSION_NOT_CONNECTED":2,"INVALID_SESSION_OPERATION":3,"INVALID_OPERATION":3,"TIMEOUT":4,"MESSAGE_VPN_NOT_ALLOWED":5,"MESSAGE_VPN_UNAVAILABLE":6,"CLIENT_USERNAME_IS_SHUTDOWN":7,"DYNAMIC_CLIENTS_NOT_ALLOWED":8,"CLIENT_NAME_ALREADY_IN_USE":9,"CLIENT_NAME_INVALID":10,"CLIENT_DELETE_IN_PROGRESS":11,"TOO_MANY_CLIENTS":12,"LOGIN_FAILURE":13,"INVALID_VIRTUAL_ADDRESS":14,"CLIENT_ACL_DENIED":15,"SUBSCRIPTION_ACL_DENIED":16,"PUBLISH_ACL_DENIED":17,"PARAMETER_OUT_OF_RANGE":18,"PARAMETER_CONFLICT":19,"PARAMETER_INVALID_TYPE":20,"INTERNAL_ERROR":21,"INSUFFICIENT_SPACE":22,"OUT_OF_RESOURCES":23,"PROTOCOL_ERROR":24,"COMMUNICATION_ERROR":25,"KEEP_ALIVE_FAILURE":26,"TOPIC_MISSING":28,"INVALID_TOPIC_SYNTAX":31,"MESSAGE_TOO_LARGE":32,"XML_PARSE_ERROR":33,"SUBSCRIPTION_ALREADY_PRESENT":34,"SUBSCRIPTION_NOT_FOUND":35,"SUBSCRIPTION_INVALID":36,"SUBSCRIPTION_ERROR_OTHER":37,"SUBSCRIPTION_TOO_MANY":38,"SUBSCRIPTION_ATTRIBUTES_CONFLICT":39,"NO_LOCAL_NOT_SUPPORTED":40,"DATA_ERROR_OTHER":42,"CREATE_XHR_FAILED":43,"CONNECTION_ERROR":44,"DATA_DECODE_ERROR":45,"INACTIVITY_TIMEOUT":46,"UNKNOWN_TRANSPORT_SESSION_ID":47,"AD_MESSAGING_NOT_SUPPORTED":48,"CREATE_WEBSOCKET_FAILED":49,"REPLICATION_IS_STANDBY":50,"BASIC_AUTHENTICATION_IS_SHUTDOWN":51,"CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN":52,"GM_UNAVAILABLE":100,"UNKNOWN_FLOW_NAME":111,"ALREADY_BOUND":112,"INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT":113,"UNKNOWN_QUEUE_NAME":114,"UNKNOWN_TOPIC_ENDPOINT_NAME":115,"MAX_CLIENTS_FOR_QUEUE":116,"MAX_CLIENTS_FOR_TE":117,"UNEXPECTED_UNBIND":118,"QUEUE_NOT_FOUND":119,"SPOOL_OVER_QUOTA":120,"QUEUE_SHUTDOWN":121,"TOPIC_ENDPOINT_SHUTDOWN":122,"NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT":123,"ENDPOINT_ALREADY_EXISTS":124,"PERMISSION_NOT_ALLOWED":125,"INVALID_SELECTOR":126,"MAX_MESSAGE_USAGE_EXCEEDED":127,"ENDPOINT_PROPERTY_MISMATCH":128,"NO_SUBSCRIPTION_MATCH":129,"MESSAGE_DELIVERY_MODE_MISMATCH":130,"MESSAGE_ALREADY_ACKNOWLEDGED":131,"SUBSCRIPTION_DOES_NOT_MATCH":133,"SELECTOR_DOES_NOT_MATCH":134,"INVALID_DTE_NAME":135,"UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND":136,"CALLBACK_ERROR":137,"NOLOCAL_DISCARD":138,"GM_NOT_READY":140,"LOW_PRIORITY_MSG_CONGESTION":141,"QUOTA_OUT_OF_RANGE":142,"FAILED_LOADING_TRUSTSTORE":143,"FAILED_LOADING_CERTIFICATE_AND_KEY":144,"UNRESOLVED_HOSTS":145}, true);
Object.defineProperty(solace.ErrorSubcode, 'describe', propertySpec(solace.ErrorSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.ErrorSubcode, 'nameOf', propertySpec(solace.ErrorSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.LogImpl
// --------------------------
solace['LogImpl'] = solace.LogImpl;
// --------------------------
// solace.LogLevel
// --------------------------
solace['LogLevel'] = solace.LogLevel;
solace.LogLevel._setCanonical({"FATAL":0,"ERROR":1,"WARN":2,"INFO":3,"DEBUG":4,"TRACE":5}, true);
Object.defineProperty(solace.LogLevel, 'describe', propertySpec(solace.LogLevel.describe, 'cw')); // GDP
Object.defineProperty(solace.LogLevel, 'nameOf', propertySpec(solace.LogLevel.nameOf, 'cw')); // GDP
// --------------------------
// solace.Long
// --------------------------
solace['Long'] = solace.Long;
// --------------------------
// solace.Message
// --------------------------
solace['Message'] = solace.Message;
Object.defineProperty(solace.Message.prototype, 'getType', propertySpec(solace.Message.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setApplicationMessageId', propertySpec(solace.Message.prototype.setApplicationMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getApplicationMessageId', propertySpec(solace.Message.prototype.getApplicationMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setApplicationMessageType', propertySpec(solace.Message.prototype.setApplicationMessageType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getApplicationMessageType', propertySpec(solace.Message.prototype.getApplicationMessageType, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getBinaryAttachment', propertySpec(solace.Message.prototype.getBinaryAttachment, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setBinaryAttachment', propertySpec(solace.Message.prototype.setBinaryAttachment, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCacheRequestId', propertySpec(solace.Message.prototype.getCacheRequestId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCorrelationId', propertySpec(solace.Message.prototype.getCorrelationId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setCorrelationId', propertySpec(solace.Message.prototype.setCorrelationId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCorrelationKey', propertySpec(solace.Message.prototype.getCorrelationKey, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setCorrelationKey', propertySpec(solace.Message.prototype.setCorrelationKey, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDeliverToOne', propertySpec(solace.Message.prototype.isDeliverToOne, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDeliverToOne', propertySpec(solace.Message.prototype.setDeliverToOne, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getDeliveryMode', propertySpec(solace.Message.prototype.getDeliveryMode, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDeliveryMode', propertySpec(solace.Message.prototype.setDeliveryMode, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getDestination', propertySpec(solace.Message.prototype.getDestination, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDestination', propertySpec(solace.Message.prototype.setDestination, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDiscardIndication', propertySpec(solace.Message.prototype.isDiscardIndication, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDiscardIndication', propertySpec(solace.Message.prototype.setDiscardIndication, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isElidingEligible', propertySpec(solace.Message.prototype.isElidingEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setElidingEligible', propertySpec(solace.Message.prototype.setElidingEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPublisherId', propertySpec(solace.Message.prototype.getPublisherId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPublisherId', propertySpec(solace.Message.prototype.setPublisherId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPublisherMessageId', propertySpec(solace.Message.prototype.getPublisherMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPublisherMessageId', propertySpec(solace.Message.prototype.setPublisherMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getTimeToLive', propertySpec(solace.Message.prototype.getTimeToLive, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setTimeToLive', propertySpec(solace.Message.prototype.setTimeToLive, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGMExpiration', propertySpec(solace.Message.prototype.getGMExpiration, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGMExpiration', propertySpec(solace.Message.prototype.setGMExpiration, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isDMQEligible', propertySpec(solace.Message.prototype.isDMQEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setDMQEligible', propertySpec(solace.Message.prototype.setDMQEligible, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getFlowId', propertySpec(solace.Message.prototype.getFlowId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setFlowId', propertySpec(solace.Message.prototype.setFlowId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGuaranteedPreviousMessageId', propertySpec(solace.Message.prototype.getGuaranteedPreviousMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGuaranteedPreviousMessageId', propertySpec(solace.Message.prototype.setGuaranteedPreviousMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getMessageConsumer', propertySpec(solace.Message.prototype.getMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setMessageConsumer', propertySpec(solace.Message.prototype.setMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getGuaranteedMessageId', propertySpec(solace.Message.prototype.getGuaranteedMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setGuaranteedMessageId', propertySpec(solace.Message.prototype.setGuaranteedMessageId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getTopicSequenceNumber', propertySpec(solace.Message.prototype.getTopicSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setTopicSequenceNumber', propertySpec(solace.Message.prototype.setTopicSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'acknowledge', propertySpec(solace.Message.prototype.acknowledge, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isAcknowledgeImmediately', propertySpec(solace.Message.prototype.isAcknowledgeImmediately, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setAcknowledgeImmediately', propertySpec(solace.Message.prototype.setAcknowledgeImmediately, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getCacheStatus', propertySpec(solace.Message.prototype.getCacheStatus, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isReplyMessage', propertySpec(solace.Message.prototype.isReplyMessage, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'isRedelivered', propertySpec(solace.Message.prototype.isRedelivered, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setRedelivered', propertySpec(solace.Message.prototype.setRedelivered, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setAsReplyMessage', propertySpec(solace.Message.prototype.setAsReplyMessage, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getReceiverTimestamp', propertySpec(solace.Message.prototype.getReceiverTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getReplyTo', propertySpec(solace.Message.prototype.getReplyTo, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setReplyTo', propertySpec(solace.Message.prototype.setReplyTo, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSenderId', propertySpec(solace.Message.prototype.getSenderId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSenderId', propertySpec(solace.Message.prototype.setSenderId, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSenderTimestamp', propertySpec(solace.Message.prototype.getSenderTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSenderTimestamp', propertySpec(solace.Message.prototype.setSenderTimestamp, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSequenceNumber', propertySpec(solace.Message.prototype.getSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSequenceNumber', propertySpec(solace.Message.prototype.setSequenceNumber, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getUserCos', propertySpec(solace.Message.prototype.getUserCos, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getPriority', propertySpec(solace.Message.prototype.getPriority, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setUserCos', propertySpec(solace.Message.prototype.setUserCos, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setPriority', propertySpec(solace.Message.prototype.setPriority, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlContent', propertySpec(solace.Message.prototype.getXmlContent, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlContentDecoded', propertySpec(solace.Message.prototype.getXmlContentDecoded, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setXmlContent', propertySpec(solace.Message.prototype.setXmlContent, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setXmlMetadata', propertySpec(solace.Message.prototype.setXmlMetadata, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getXmlMetadata', propertySpec(solace.Message.prototype.getXmlMetadata, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getUserPropertyMap', propertySpec(solace.Message.prototype.getUserPropertyMap, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setUserPropertyMap', propertySpec(solace.Message.prototype.setUserPropertyMap, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'setSdtContainer', propertySpec(solace.Message.prototype.setSdtContainer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'getSdtContainer', propertySpec(solace.Message.prototype.getSdtContainer, 'cw')); // GDP
Object.defineProperty(solace.Message.prototype, 'reset', propertySpec(solace.Message.prototype.reset, 'cw')); // GDP
// --------------------------
// solace.MessageCacheStatus
// --------------------------
solace['MessageCacheStatus'] = solace.MessageCacheStatus;
solace.MessageCacheStatus._setCanonical({"LIVE":0,"CACHED":1,"SUSPECT":2}, true);
Object.defineProperty(solace.MessageCacheStatus, 'describe', propertySpec(solace.MessageCacheStatus.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageCacheStatus, 'nameOf', propertySpec(solace.MessageCacheStatus.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumer
// --------------------------
solace['MessageConsumer'] = solace.MessageConsumer;
Object.defineProperty(solace.MessageConsumer.prototype, 'getDestination', propertySpec(solace.MessageConsumer.prototype.getDestination, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'applicationAck', propertySpec(solace.MessageConsumer.prototype.applicationAck, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getDisposedEvent', propertySpec(solace.MessageConsumer.prototype.getDisposedEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleDataMessage', propertySpec(solace.MessageConsumer.prototype.handleDataMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleUncorrelatedControlMessage', propertySpec(solace.MessageConsumer.prototype.handleUncorrelatedControlMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getProperties', propertySpec(solace.MessageConsumer.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'onVRNChanged', propertySpec(solace.MessageConsumer.prototype.onVRNChanged, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'clearStats', propertySpec(solace.MessageConsumer.prototype.clearStats, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getDisposedEvent', propertySpec(solace.MessageConsumer.prototype.getDisposedEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getProperties', propertySpec(solace.MessageConsumer.prototype.getProperties, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'getStat', propertySpec(solace.MessageConsumer.prototype.getStat, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'handleUncorrelatedControlMessage', propertySpec(solace.MessageConsumer.prototype.handleUncorrelatedControlMessage, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'incStat', propertySpec(solace.MessageConsumer.prototype.incStat, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'processFSMEvent', propertySpec(solace.MessageConsumer.prototype.processFSMEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'formatErrorEvent', propertySpec(solace.MessageConsumer.prototype.formatErrorEvent, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumer.prototype, 'disableEmitter', propertySpec(solace.MessageConsumer.prototype.disableEmitter, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerAcknowledgeMode
// --------------------------
solace['MessageConsumerAcknowledgeMode'] = solace.MessageConsumerAcknowledgeMode;
solace.MessageConsumerAcknowledgeMode._setCanonical({"AUTO":"AUTO","CLIENT":"CLIENT"}, true);
Object.defineProperty(solace.MessageConsumerAcknowledgeMode, 'describe', propertySpec(solace.MessageConsumerAcknowledgeMode.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumerAcknowledgeMode, 'nameOf', propertySpec(solace.MessageConsumerAcknowledgeMode.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerEventName
// --------------------------
solace['MessageConsumerEventName'] = solace.MessageConsumerEventName;
solace.MessageConsumerEventName._setCanonical({"UP":"MessageConsumerEventName_up","DOWN":"MessageConsumerEventName_down","ACTIVE":"MessageConsumerEventName_active","INACTIVE":"MessageConsumerEventName_inactive","DOWN_ERROR":"MessageConsumerEventName_downError","CONNECT_FAILED_ERROR":"MessageConsumerEventName_connectFailedError","GM_DISABLED":"MessageConsumerEventName_GMDisabled","DISPOSED":"MessageConsumerEventName_disposed","MESSAGE":"MessageConsumerEventName_message"}, true);
Object.defineProperty(solace.MessageConsumerEventName, 'describe', propertySpec(solace.MessageConsumerEventName.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageConsumerEventName, 'nameOf', propertySpec(solace.MessageConsumerEventName.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageConsumerProperties
// --------------------------
solace['MessageConsumerProperties'] = solace.MessageConsumerProperties;
// --------------------------
// solace.MessageDeliveryModeType
// --------------------------
solace['MessageDeliveryModeType'] = solace.MessageDeliveryModeType;
solace.MessageDeliveryModeType._setCanonical({"DIRECT":0,"PERSISTENT":1,"NON_PERSISTENT":2}, true);
Object.defineProperty(solace.MessageDeliveryModeType, 'describe', propertySpec(solace.MessageDeliveryModeType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageDeliveryModeType, 'nameOf', propertySpec(solace.MessageDeliveryModeType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageDumpFlag
// --------------------------
solace['MessageDumpFlag'] = solace.MessageDumpFlag;
solace.MessageDumpFlag._setCanonical({"MSGDUMP_BRIEF":0,"MSGDUMP_FULL":1}, true);
Object.defineProperty(solace.MessageDumpFlag, 'describe', propertySpec(solace.MessageDumpFlag.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageDumpFlag, 'nameOf', propertySpec(solace.MessageDumpFlag.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessagePublisherAcknowledgeMode
// --------------------------
solace['MessagePublisherAcknowledgeMode'] = solace.MessagePublisherAcknowledgeMode;
solace.MessagePublisherAcknowledgeMode._setCanonical({"PER_MESSAGE":"PER_MESSAGE","WINDOWED":"WINDOWED"}, true);
Object.defineProperty(solace.MessagePublisherAcknowledgeMode, 'describe', propertySpec(solace.MessagePublisherAcknowledgeMode.describe, 'cw')); // GDP
Object.defineProperty(solace.MessagePublisherAcknowledgeMode, 'nameOf', propertySpec(solace.MessagePublisherAcknowledgeMode.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessagePublisherProperties
// --------------------------
solace['MessagePublisherProperties'] = solace.MessagePublisherProperties;
// --------------------------
// solace.MessageRxCBInfo
// --------------------------
solace['MessageRxCBInfo'] = solace.MessageRxCBInfo;
// --------------------------
// solace.MessageType
// --------------------------
solace['MessageType'] = solace.MessageType;
solace.MessageType._setCanonical({"BINARY":0,"MAP":1,"STREAM":2,"TEXT":3}, true);
Object.defineProperty(solace.MessageType, 'describe', propertySpec(solace.MessageType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageType, 'nameOf', propertySpec(solace.MessageType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MessageUserCosType
// --------------------------
solace['MessageUserCosType'] = solace.MessageUserCosType;
solace.MessageUserCosType._setCanonical({"COS1":0,"COS2":1,"COS3":2}, true);
Object.defineProperty(solace.MessageUserCosType, 'describe', propertySpec(solace.MessageUserCosType.describe, 'cw')); // GDP
Object.defineProperty(solace.MessageUserCosType, 'nameOf', propertySpec(solace.MessageUserCosType.nameOf, 'cw')); // GDP
// --------------------------
// solace.MutableSessionProperty
// --------------------------
solace['MutableSessionProperty'] = solace.MutableSessionProperty;
solace.MutableSessionProperty._setCanonical({"CLIENT_NAME":1,"CLIENT_DESCRIPTION":2}, true);
Object.defineProperty(solace.MutableSessionProperty, 'describe', propertySpec(solace.MutableSessionProperty.describe, 'cw')); // GDP
Object.defineProperty(solace.MutableSessionProperty, 'nameOf', propertySpec(solace.MutableSessionProperty.nameOf, 'cw')); // GDP
// --------------------------
// solace.NotImplementedError
// --------------------------
solace['NotImplementedError'] = solace.NotImplementedError;
Object.defineProperty(solace.NotImplementedError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.OperationError
// --------------------------
solace['OperationError'] = solace.OperationError;
Object.defineProperty(solace.OperationError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.QueueAccessType
// --------------------------
solace['QueueAccessType'] = solace.QueueAccessType;
solace.QueueAccessType._setCanonical({"EXCLUSIVE":"EXCLUSIVE","NONEXCLUSIVE":"NONEXCLUSIVE"}, true);
Object.defineProperty(solace.QueueAccessType, 'describe', propertySpec(solace.QueueAccessType.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueAccessType, 'nameOf', propertySpec(solace.QueueAccessType.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueueDescriptor
// --------------------------
solace['QueueDescriptor'] = solace.QueueDescriptor;
Object.defineProperty(solace.QueueDescriptor, 'createFromSpec', propertySpec(solace.QueueDescriptor.createFromSpec, 'cw')); // GDP
Object.defineProperty(solace.QueueDescriptor.prototype, 'getType', propertySpec(solace.QueueDescriptor.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.QueueDescriptor.prototype, 'isDurable', propertySpec(solace.QueueDescriptor.prototype.isDurable, 'cw')); // GDP
// --------------------------
// solace.QueueDiscardBehavior
// --------------------------
solace['QueueDiscardBehavior'] = solace.QueueDiscardBehavior;
solace.QueueDiscardBehavior._setCanonical({"NOTIFY_SENDER_ON":"NOTIFY_SENDER_ON","NOTIFY_SENDER_OFF":"NOTIFY_SENDER_OFF"}, true);
Object.defineProperty(solace.QueueDiscardBehavior, 'describe', propertySpec(solace.QueueDiscardBehavior.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueDiscardBehavior, 'nameOf', propertySpec(solace.QueueDiscardBehavior.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueuePermissions
// --------------------------
solace['QueuePermissions'] = solace.QueuePermissions;
solace.QueuePermissions._setCanonical({"NONE":"NONE","READ_ONLY":"READ_ONLY","CONSUME":"CONSUME","MODIFY_TOPIC":"MODIFY_TOPIC","DELETE":"DELETE"}, true);
Object.defineProperty(solace.QueuePermissions, 'describe', propertySpec(solace.QueuePermissions.describe, 'cw')); // GDP
Object.defineProperty(solace.QueuePermissions, 'nameOf', propertySpec(solace.QueuePermissions.nameOf, 'cw')); // GDP
// --------------------------
// solace.QueueProperties
// --------------------------
solace['QueueProperties'] = solace.QueueProperties;
// --------------------------
// solace.QueueType
// --------------------------
solace['QueueType'] = solace.QueueType;
solace.QueueType._setCanonical({"QUEUE":"QUEUE","TOPIC_ENDPOINT":"TOPIC_ENDPOINT"}, true);
Object.defineProperty(solace.QueueType, 'describe', propertySpec(solace.QueueType.describe, 'cw')); // GDP
Object.defineProperty(solace.QueueType, 'nameOf', propertySpec(solace.QueueType.nameOf, 'cw')); // GDP
// --------------------------
// solace.RequestError
// --------------------------
solace['RequestError'] = solace.RequestError;
Object.defineProperty(solace.RequestError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.RequestEventCode
// --------------------------
solace['RequestEventCode'] = solace.RequestEventCode;
solace.RequestEventCode._setCanonical({"REQUEST_ABORTED":8,"REQUEST_TIMEOUT":9}, true);
Object.defineProperty(solace.RequestEventCode, 'describe', propertySpec(solace.RequestEventCode.describe, 'cw')); // GDP
Object.defineProperty(solace.RequestEventCode, 'nameOf', propertySpec(solace.RequestEventCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.SDTField
// --------------------------
solace['SDTField'] = solace.SDTField;
Object.defineProperty(solace.SDTField, 'create', propertySpec(solace.SDTField.create, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'getType', propertySpec(solace.SDTField.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'getValue', propertySpec(solace.SDTField.prototype.getValue, 'cw')); // GDP
Object.defineProperty(solace.SDTField.prototype, 'setError', propertySpec(solace.SDTField.prototype.setError, 'cw')); // GDP
// --------------------------
// solace.SDTFieldType
// --------------------------
solace['SDTFieldType'] = solace.SDTFieldType;
solace.SDTFieldType._setCanonical({"BOOL":0,"UINT8":1,"INT8":2,"UINT16":3,"INT16":4,"UINT32":5,"INT32":6,"UINT64":7,"INT64":8,"WCHAR":9,"STRING":10,"BYTEARRAY":11,"FLOATTYPE":12,"DOUBLETYPE":13,"MAP":14,"STREAM":15,"DESTINATION":16,"NULLTYPE":17,"UNKNOWN":18,"SMF_MESSAGE":19}, true);
Object.defineProperty(solace.SDTFieldType, 'describe', propertySpec(solace.SDTFieldType.describe, 'cw')); // GDP
Object.defineProperty(solace.SDTFieldType, 'nameOf', propertySpec(solace.SDTFieldType.nameOf, 'cw')); // GDP
// --------------------------
// solace.SDTMapContainer
// --------------------------
solace['SDTMapContainer'] = solace.SDTMapContainer;
Object.defineProperty(solace.SDTMapContainer.prototype, 'getKeys', propertySpec(solace.SDTMapContainer.prototype.getKeys, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'getField', propertySpec(solace.SDTMapContainer.prototype.getField, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'deleteField', propertySpec(solace.SDTMapContainer.prototype.deleteField, 'cw')); // GDP
Object.defineProperty(solace.SDTMapContainer.prototype, 'addField', propertySpec(solace.SDTMapContainer.prototype.addField, 'cw')); // GDP
// --------------------------
// solace.SDTStreamContainer
// --------------------------
solace['SDTStreamContainer'] = solace.SDTStreamContainer;
Object.defineProperty(solace.SDTStreamContainer.prototype, 'hasNext', propertySpec(solace.SDTStreamContainer.prototype.hasNext, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'getNext', propertySpec(solace.SDTStreamContainer.prototype.getNext, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'rewind', propertySpec(solace.SDTStreamContainer.prototype.rewind, 'cw')); // GDP
Object.defineProperty(solace.SDTStreamContainer.prototype, 'addField', propertySpec(solace.SDTStreamContainer.prototype.addField, 'cw')); // GDP
// --------------------------
// solace.SDTUnsupportedValueError
// --------------------------
solace['SDTUnsupportedValueError'] = solace.SDTUnsupportedValueError;
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'inspect', propertySpec(solace.SDTUnsupportedValueError.prototype.inspect, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'getSubcode', propertySpec(solace.SDTUnsupportedValueError.prototype.getSubcode, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'getSourceData', propertySpec(solace.SDTUnsupportedValueError.prototype.getSourceData, 'cw')); // GDP
Object.defineProperty(solace.SDTUnsupportedValueError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.SDTValueErrorSubcode
// --------------------------
solace['SDTValueErrorSubcode'] = solace.SDTValueErrorSubcode;
solace.SDTValueErrorSubcode._setCanonical({"VALUE_OUTSIDE_SUPPORTED_RANGE":1}, true);
Object.defineProperty(solace.SDTValueErrorSubcode, 'describe', propertySpec(solace.SDTValueErrorSubcode.describe, 'cw')); // GDP
Object.defineProperty(solace.SDTValueErrorSubcode, 'nameOf', propertySpec(solace.SDTValueErrorSubcode.nameOf, 'cw')); // GDP
// --------------------------
// solace.Session
// --------------------------
solace['Session'] = solace.Session;
Object.defineProperty(solace.Session.prototype, 'subscribe', propertySpec(solace.Session.prototype.subscribe, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'unsubscribe', propertySpec(solace.Session.prototype.unsubscribe, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'unsubscribeDurableTopicEndpoint', propertySpec(solace.Session.prototype.unsubscribeDurableTopicEndpoint, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'updateProperty', propertySpec(solace.Session.prototype.updateProperty, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendRequest', propertySpec(solace.Session.prototype.sendRequest, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendReply', propertySpec(solace.Session.prototype.sendReply, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getStat', propertySpec(solace.Session.prototype.getStat, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'resetStats', propertySpec(solace.Session.prototype.resetStats, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getSessionProperties', propertySpec(solace.Session.prototype.getSessionProperties, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'isCapable', propertySpec(solace.Session.prototype.isCapable, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getCapability', propertySpec(solace.Session.prototype.getCapability, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getSessionState', propertySpec(solace.Session.prototype.getSessionState, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getFSMState', propertySpec(solace.Session.prototype.getFSMState, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createCacheSession', propertySpec(solace.Session.prototype.createCacheSession, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createMessageConsumer', propertySpec(solace.Session.prototype.createMessageConsumer, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createDestinationFromDescriptor', propertySpec(solace.Session.prototype.createDestinationFromDescriptor, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'createTemporaryDestination', propertySpec(solace.Session.prototype.createTemporaryDestination, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'sendEvent', propertySpec(solace.Session.prototype.sendEvent, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getTransportInfo', propertySpec(solace.Session.prototype.getTransportInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'injectTransportInterceptor', propertySpec(solace.Session.prototype.injectTransportInterceptor, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'allowOperation', propertySpec(solace.Session.prototype.allowOperation, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'updateCapabilities', propertySpec(solace.Session.prototype.updateCapabilities, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'validateAndSendMessage', propertySpec(solace.Session.prototype.validateAndSendMessage, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'enqueueOutstandingDataReq', propertySpec(solace.Session.prototype.enqueueOutstandingDataReq, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'cancelOutstandingDataReq', propertySpec(solace.Session.prototype.cancelOutstandingDataReq, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'cleanupSession', propertySpec(solace.Session.prototype.cleanupSession, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleDataMessage', propertySpec(solace.Session.prototype.handleDataMessage, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleSubscriptionUpdateResponse', propertySpec(solace.Session.prototype.handleSubscriptionUpdateResponse, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleDTEUnsubscribeResponse', propertySpec(solace.Session.prototype.handleDTEUnsubscribeResponse, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'handleSubscriptionUpdateError', propertySpec(solace.Session.prototype.handleSubscriptionUpdateError, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getEventCBInfo', propertySpec(solace.Session.prototype.getEventCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'setEventCBInfo', propertySpec(solace.Session.prototype.setEventCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getMessageCBInfo', propertySpec(solace.Session.prototype.getMessageCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'setMessageCBInfo', propertySpec(solace.Session.prototype.setMessageCBInfo, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'getCorrelationTag', propertySpec(solace.Session.prototype.getCorrelationTag, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'wrapEventCallback', propertySpec(solace.Session.prototype.wrapEventCallback, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'wrapMessageCallback', propertySpec(solace.Session.prototype.wrapMessageCallback, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'formatErrorEvent', propertySpec(solace.Session.prototype.formatErrorEvent, 'cw')); // GDP
Object.defineProperty(solace.Session.prototype, 'disableEmitter', propertySpec(solace.Session.prototype.disableEmitter, 'cw')); // GDP
// --------------------------
// solace.SessionEvent
// --------------------------
solace['SessionEvent'] = solace.SessionEvent;
Object.defineProperty(solace.SessionEvent.prototype, 'hasOwnProperty', propertySpec(solace.SessionEvent.prototype.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'toLocaleString', propertySpec(solace.SessionEvent.prototype.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'valueOf', propertySpec(solace.SessionEvent.prototype.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'isPrototypeOf', propertySpec(solace.SessionEvent.prototype.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SessionEvent.prototype, 'propertyIsEnumerable', propertySpec(solace.SessionEvent.prototype.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SessionEventCBInfo
// --------------------------
solace['SessionEventCBInfo'] = solace.SessionEventCBInfo;
// --------------------------
// solace.SessionEventCode
// --------------------------
solace['SessionEventCode'] = solace.SessionEventCode;
solace.SessionEventCode._setCanonical({"UP_NOTICE":0,"DOWN_ERROR":1,"CONNECT_FAILED_ERROR":2,"REJECTED_MESSAGE_ERROR":4,"SUBSCRIPTION_ERROR":5,"SUBSCRIPTION_OK":6,"VIRTUALROUTER_NAME_CHANGED":7,"REQUEST_ABORTED":8,"REQUEST_TIMEOUT":9,"PROPERTY_UPDATE_OK":10,"PROPERTY_UPDATE_ERROR":11,"CAN_ACCEPT_DATA":13,"DISCONNECTED":14,"RECONNECTING_NOTICE":22,"RECONNECTED_NOTICE":23,"REPUBLISHING_UNACKED_MESSAGES":24,"ACKNOWLEDGED_MESSAGE":25,"UNSUBSCRIBE_TE_TOPIC_OK":26,"UNSUBSCRIBE_TE_TOPIC_ERROR":27,"MESSAGE":28,"GUARANTEED_MESSAGE_PUBLISHER_DOWN":29}, true);
Object.defineProperty(solace.SessionEventCode, 'describe', propertySpec(solace.SessionEventCode.describe, 'cw')); // GDP
Object.defineProperty(solace.SessionEventCode, 'nameOf', propertySpec(solace.SessionEventCode.nameOf, 'cw')); // GDP
// --------------------------
// solace.SessionProperties
// --------------------------
solace['SessionProperties'] = solace.SessionProperties;
// --------------------------
// solace.SessionState
// --------------------------
solace['SessionState'] = solace.SessionState;
solace.SessionState._setCanonical({"CONNECTING":1,"CONNECTED":2,"SESSION_ERROR":3,"DISCONNECTING":4,"DISCONNECTED":5}, true);
Object.defineProperty(solace.SessionState, 'describe', propertySpec(solace.SessionState.describe, 'cw')); // GDP
Object.defineProperty(solace.SessionState, 'nameOf', propertySpec(solace.SessionState.nameOf, 'cw')); // GDP
// --------------------------
// solace.SolclientFactory
// --------------------------
solace['SolclientFactory'] = solace.SolclientFactory;
Object.defineProperty(solace.SolclientFactory, 'hasOwnProperty', propertySpec(solace.SolclientFactory.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'toLocaleString', propertySpec(solace.SolclientFactory.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'valueOf', propertySpec(solace.SolclientFactory.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'isPrototypeOf', propertySpec(solace.SolclientFactory.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactory, 'propertyIsEnumerable', propertySpec(solace.SolclientFactory.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SolclientFactoryProfiles
// --------------------------
solace['SolclientFactoryProfiles'] = solace.SolclientFactoryProfiles;
Object.defineProperty(solace.SolclientFactoryProfiles, 'hasOwnProperty', propertySpec(solace.SolclientFactoryProfiles.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'toLocaleString', propertySpec(solace.SolclientFactoryProfiles.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'valueOf', propertySpec(solace.SolclientFactoryProfiles.valueOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'isPrototypeOf', propertySpec(solace.SolclientFactoryProfiles.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.SolclientFactoryProfiles, 'propertyIsEnumerable', propertySpec(solace.SolclientFactoryProfiles.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.SolclientFactoryProperties
// --------------------------
solace['SolclientFactoryProperties'] = solace.SolclientFactoryProperties;
// --------------------------
// solace.StatType
// --------------------------
solace['StatType'] = solace.StatType;
solace.StatType._setCanonical({"TX_TOTAL_DATA_BYTES":0,"TX_TOTAL_DATA_MSGS":1,"TX_DIRECT_BYTES":2,"TX_DIRECT_MSGS":3,"TX_CONTROL_BYTES":4,"TX_CONTROL_MSGS":5,"TX_REQUEST_SENT":6,"TX_REQUEST_TIMEOUT":7,"RX_TOTAL_DATA_BYTES":8,"RX_TOTAL_DATA_MSGS":9,"RX_DIRECT_BYTES":10,"RX_DIRECT_MSGS":11,"RX_CONTROL_BYTES":12,"RX_CONTROL_MSGS":13,"RX_DISCARD_MSG_INDICATION":14,"RX_REPLY_MSG_RECVED":15,"RX_REPLY_MSG_DISCARD":16,"RX_DISCARD_SMF_UNKNOWN_ELEMENT":17,"CACHE_REQUEST_SENT":18,"CACHE_REQUEST_OK_RESPONSE":19,"CACHE_REQUEST_FAIL_RESPONSE":20,"CACHE_REQUEST_FULFILL_DISCARD_RESPONSE":21,"RX_CACHE_MSG":22,"CACHE_REQUEST_INCOMPLETE_RESPONSE":23,"CACHE_REQUEST_LIVE_DATA_FULFILL":24,"TX_PERSISTENT_BYTES":25,"TX_PERSISTENT_MSGS":26,"TX_NONPERSISTENT_BYTES":27,"TX_NONPERSISTENT_MSGS":28,"TX_PERSISTENT_BYTES_REDELIVERED":29,"TX_PERSISTENT_REDELIVERED":30,"TX_NONPERSISTENT_BYTES_REDELIVERED":31,"TX_NONPERSISTENT_REDELIVERED":32,"TX_ACKS_RXED":33,"TX_WINDOW_CLOSE":34,"TX_ACK_TIMEOUT":35,"RX_PERSISTENT_BYTES":36,"RX_PERSISTENT_MSGS":37,"RX_NONPERSISTENT_BYTES":38,"RX_NONPERSISTENT_MSGS":39,"RX_ACKED":40,"RX_DISCARD_DUPLICATE":41,"RX_DISCARD_NO_MATCHING_CONSUMER":42,"RX_DISCARD_OUT_OF_ORDER":43}, true);
Object.defineProperty(solace.StatType, 'describe', propertySpec(solace.StatType.describe, 'cw')); // GDP
Object.defineProperty(solace.StatType, 'nameOf', propertySpec(solace.StatType.nameOf, 'cw')); // GDP
// --------------------------
// solace.Topic
// --------------------------
solace['Topic'] = solace.Topic;
Object.defineProperty(solace.Topic, 'createFromName', propertySpec(solace.Topic.createFromName, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getType', propertySpec(solace.Topic.prototype.getType, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getBytes', propertySpec(solace.Topic.prototype.getBytes, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'getOffset', propertySpec(solace.Topic.prototype.getOffset, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'validate', propertySpec(solace.Topic.prototype.validate, 'cw')); // GDP
Object.defineProperty(solace.Topic.prototype, 'isWildcarded', propertySpec(solace.Topic.prototype.isWildcarded, 'cw')); // GDP
// --------------------------
// solace.TransportError
// --------------------------
solace['TransportError'] = solace.TransportError;
Object.defineProperty(solace.TransportError.prototype, 'message', propertySpec("", 'cw')); // GDP
// --------------------------
// solace.TransportProtocol
// --------------------------
solace['TransportProtocol'] = solace.TransportProtocol;
solace.TransportProtocol._setCanonical({"HTTP_BASE64":"HTTP_BASE64","HTTP_BINARY":"HTTP_BINARY","HTTP_BINARY_STREAMING":"HTTP_BINARY_STREAMING","WS_BINARY":"WS_BINARY"}, true);
Object.defineProperty(solace.TransportProtocol, 'describe', propertySpec(solace.TransportProtocol.describe, 'cw')); // GDP
Object.defineProperty(solace.TransportProtocol, 'nameOf', propertySpec(solace.TransportProtocol.nameOf, 'cw')); // GDP
// --------------------------
// solace.Version
// --------------------------
solace['Version'] = solace.Version;
Object.defineProperty(solace.Version, 'hasOwnProperty', propertySpec(solace.Version.hasOwnProperty, 'cw')); // GDP
Object.defineProperty(solace.Version, 'toLocaleString', propertySpec(solace.Version.toLocaleString, 'cw')); // GDP
Object.defineProperty(solace.Version, 'valueOf', propertySpec(solace.Version.valueOf, 'cw')); // GDP
Object.defineProperty(solace.Version, 'isPrototypeOf', propertySpec(solace.Version.isPrototypeOf, 'cw')); // GDP
Object.defineProperty(solace.Version, 'propertyIsEnumerable', propertySpec(solace.Version.propertyIsEnumerable, 'cw')); // GDP
// --------------------------
// solace.makeIterator
// --------------------------
solace['makeIterator'] = solace.makeIterator;
  module.exports = solace;
} catch (e) {
  console.error(e.stack);
}

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 267 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 268 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/array");

/***/ }),
/* 269 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/date");

/***/ }),
/* 270 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/function");

/***/ }),
/* 271 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/map");

/***/ }),
/* 272 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/math");

/***/ }),
/* 273 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/number");

/***/ }),
/* 274 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/object");

/***/ }),
/* 275 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/parse-float");

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/parse-int");

/***/ }),
/* 277 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/regexp");

/***/ }),
/* 278 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/set");

/***/ }),
/* 279 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/string");

/***/ }),
/* 280 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/symbol");

/***/ }),
/* 281 */
/***/ (function(module, exports) {

module.exports = require("core-js/es6/typed");

/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = require("core-js/fn/array/includes");

/***/ }),
/* 283 */
/***/ (function(module, exports) {

module.exports = require("core-js/fn/set/from");

/***/ }),
/* 284 */
/***/ (function(module, exports) {

module.exports = require("dns");

/***/ }),
/* 285 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 286 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 287 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 288 */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),
/* 289 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 290 */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),
/* 291 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 292 */
/***/ (function(module, exports) {

module.exports = require("ws");

/***/ })
/******/ ]);
//# sourceMappingURL=solclientjs-full.js.map